

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="别人问你哪里丑态你再把他反手挂到自己的小 slub 里寻求认同">
<meta property="og:type" content="article">
<meta property="og:title" content="【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator">
<meta property="og:url" content="https://arttnba3.github.io/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="别人问你哪里丑态你再把他反手挂到自己的小 slub 里寻求认同">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/02/21/D4idvgzLAaqIBQM.png">
<meta property="article:published_time" content="2023-02-23T15:24:42.000Z">
<meta property="article:modified_time" content="2023-04-23T17:58:23.750Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Linux Kernel">
<meta property="article:tag" content="学习札记">
<meta property="article:tag" content="内存管理">
<meta property="article:tag" content="slub allocator">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2023/02/21/D4idvgzLAaqIBQM.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"arttnba3.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s2.loli.net/2023/02/22/wCchFdIZLOn3m7W.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-24 02:24" pubdate>
          2023年2月24日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          350 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年4月24日 凌晨
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>别人问你哪里丑态你再把他反手挂到自己的小 slub 里寻求认同</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote>
<p>因为这系列文章🕊🕊🕊太久了，内核的内存管理也发生了一定的变化，所以本文直接用最新的 6.2 版本的内核源码：）</p>
</blockquote>
<p>在<a target="_blank" rel="noopener" href="https://arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/">上一篇文章</a> 中笔者简要介绍了 buddy system 的基本流程，但其为一个「页」这一级的 allocator，在日常生活中使用（？）难免有些浪费，因为内核中需要动态内存分配的场景虽然很多，但是我们<strong>通常并不需要使用一整页起步的内存，而往往是需要分配一些比较小的对象</strong>——因此 slab allocator 应运而生，其代替我们向 buddy system 请求内存页，并分割为多个小的 object，当我们每次需要时只需要取一个 object 即可</p>
<blockquote>
<p>slab 又被称为内核的堆（heap）内存管理，因为其与用户态的内存“堆”（heap）类似，都是动态分配的内存</p>
</blockquote>
<p>slab allocator 一共有三种版本：</p>
<ul>
<li>slab（最初的版本，机制比较复杂，效率不高）</li>
<li>slob（用于嵌入式等场景的极为简化版本）</li>
<li><strong>slub</strong>（优化后的版本，<strong>现在的通用版本</strong>）</li>
</ul>
<blockquote>
<p>这三种内存分配器的顶层 API 是一致的，但内部实现是不一致的（例如 slab 和 slub 各自有一个对 <code>kmem_cache</code> 的不同定义）</p>
</blockquote>
<p>本篇文章中我们主要介绍的是 <strong>slub</strong> ，也是现在内核中最为通用的小对象分配器</p>
<h1 id="0x01-slub-allocator-的基本结构"><a href="#0x01-slub-allocator-的基本结构" class="headerlink" title="0x01. slub allocator 的基本结构"></a>0x01. slub allocator 的基本结构</h1><p>首先来一张 Overview：</p>
<p><img src="https://i.loli.net/2021/07/22/ivPnbsjHyI94m5z.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="一、slab：单份-object-池"><a href="#一、slab：单份-object-池" class="headerlink" title="一、slab：单份 object 池"></a>一、slab：单份 object 池</h2><p>Linux kernel 中用以统筹所有内存的依然是 buddy system，slub allocator 也不例外，其负责向 buddy system 请求内存后分割给多个小 object 后再返还给上层调用者，<strong>单次向 buddy system 所请求的一份连续内存页便称之为一张 slab</strong>，在内核中对应 <code>slab</code> 结构体，<strong>本质上是复用 page 结构体</strong>：</p>
<blockquote>
<p>这里我们仅关注 slub，所以笔者仅截取 slub 所需字段</p>
<blockquote>
<p>老版本中 slab 是直接内嵌在 page 结构体中的</p>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Reuses the bits in struct page */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __page_flags;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SLUB)</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>				<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br>				<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>					<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">next</span>;</span><br>					<span class="hljs-type">int</span> slabs;	<span class="hljs-comment">/* 剩余的 slabs 数量 */</span><br>				&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>			&#125;;<br>			<span class="hljs-comment">/* Double-word boundary */</span><br>			<span class="hljs-type">void</span> *freelist;		<span class="hljs-comment">/* 第一个空闲对象 */</span><br>			<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>				<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br>				<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>					<span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br>					<span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br>					<span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>				&#125;;<br>			&#125;;<br>		&#125;;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><br>	&#125;;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __unused;<br><br><span class="hljs-comment">//...</span><br><br>	<span class="hljs-type">atomic_t</span> __page_refcount;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> memcg_data;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>slab_cache</code> ：该 slab 对应的内存池</li>
<li><code>freelist</code> ：<strong>Slab 上的空闲对象组织为一个 NULL 结尾的单向链表</strong>，该指针指向第一个空闲对象，耗尽时为 NULL</li>
<li><code>slab_list</code> ：按用途连接多个 slabs 的双向链表</li>
<li><code>inuse</code> ：已被使用的对象数量</li>
<li><code>objects</code>：该 slab 上的对象总数</li>
<li><code>frozen</code>：是否被冻结，即<strong>已经归属于特定的 CPU</strong></li>
</ul>
<blockquote>
<p>这里我们需要注意的是 <strong>counters 成员直接涵盖了 inuse &amp; objects &amp; frozen</strong>，后面会有大量的直接通过 counters 成员进行赋值的操作，<strong>实际上就是赋值了 inuse &amp; objects &amp; frozen</strong></p>
</blockquote>
<p>正如一个 page 结构体直接对应一张内存页（或复合页），复用了 page 结构体的 slab 也<strong>直接对应一份 slab 内存页</strong>，借助 <code>page_to_pfn()</code> 等函数可以直接完成 slab 结构体到对应内存页虚拟地址的转换，反之亦然，即<strong>我们可以直接通过一个空闲对象的虚拟地址找到对应的 slab 结构体</strong></p>
<p><img src="https://s2.loli.net/2023/02/21/cBXCGF4Z18VLMzl.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="二、kmem-cache：特定大小-amp-用途对象（堆块）的内存池"><a href="#二、kmem-cache：特定大小-amp-用途对象（堆块）的内存池" class="headerlink" title="二、kmem_cache：特定大小&amp;用途对象（堆块）的内存池"></a>二、kmem_cache：特定大小&amp;用途对象（堆块）的内存池</h2><p><code>kmem_cache</code> 为一个基本的 allocator 组件，可以理解为 <strong>用于分配某个特定大小（某种特定用途）的对象的内存池</strong>，所有的 kmem_cache 构成一个双向链表，并存在一个对应的通用 <code>kmem_cache</code> 数组 <code>kmalloc_caches</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *</span><br><span class="hljs-class"><span class="hljs-title">kmalloc_caches</span>[<span class="hljs-title">NR_KMALLOC_TYPES</span>][<span class="hljs-title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="hljs-title">ro_after_init</span> =</span><br>&#123; <span class="hljs-comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;<br>EXPORT_SYMBOL(kmalloc_caches);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>老版本还有个 dma 专用数组 <code>kmalloc_dma_caches</code> ，在 <a target="_blank" rel="noopener" href="https://patchwork.kernel.org/project/linux-mm/patch/20180718133620.6205-2-vbabka@suse.cz/">这个 commit</a> 给合并起来了</p>
</blockquote>
<h3 id="I-基本结构"><a href="#I-基本结构" class="headerlink" title="I. 基本结构"></a>I. 基本结构</h3><p>该结构体定义于 <code>include/linux/slub_def.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 缓存管理.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLUB_TINY</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_slab</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">/* 用于取回 partial slabs 等. */</span><br>	<span class="hljs-type">slab_flags_t</span> flags;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_partial;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;	<span class="hljs-comment">/* 一个对象包含元数据的大小 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> object_size;<span class="hljs-comment">/* 一个对象不包含元数据的大小 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reciprocal_value</span> <span class="hljs-title">reciprocal_size</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;	<span class="hljs-comment">/* 空闲指针的偏移 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br>	<span class="hljs-comment">/* 要保留的 per cpu partial 对象数量 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial;<br>	<span class="hljs-comment">/* 要保留的 per cpu partial slub 数量 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial_slabs;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><br><br>	<span class="hljs-comment">/* 分配与释放 slabs */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><br>	<span class="hljs-type">gfp_t</span> allocflags;	<span class="hljs-comment">/* （译注：向 buddy system）分配时所用的 gfp 标志位 */</span><br>	<span class="hljs-type">int</span> refcount;		<span class="hljs-comment">/* 用于 slab 缓存销毁的引用计数 */</span><br>	<span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;		<span class="hljs-comment">/* 元数据的偏移 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> align;		<span class="hljs-comment">/* 对齐 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> red_left_pad;	<span class="hljs-comment">/* Left redzone padding size */</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;	<span class="hljs-comment">/* Name (only for display!) */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span>	<span class="hljs-comment">/* slab 缓存链表 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSFS</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span>	<span class="hljs-comment">/* For sysfs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> random;	<span class="hljs-comment">// 用于加密 freelist 指针的随机值</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 通过从一个 remote node 分配以去碎片化.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> remote_node_defrag_ratio;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *random_seq;	<span class="hljs-comment">// 用于在初始化时随机化 freelist</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kasan_cache</span> <span class="hljs-title">kasan_info</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> useroffset;	<span class="hljs-comment">/* 用户拷贝区域的偏移 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> usersize;		<span class="hljs-comment">/* 用户拷贝区域的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">node</span>[<span class="hljs-title">MAX_NUMNODES</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>cpu_slab</code>： <em>percpu 变量</em> ，指向一个 <code>kmem_cache_cpu</code> 结构体，即<strong>当前 CPU 独占的内存池</strong></p>
</li>
<li><p><code>flags</code>：标志位</p>
</li>
<li><p><code>min_partial</code>：node partial 链表上 slab 的<strong>最大数量</strong>（👴也不知道为什么要叫min，但实际判定发挥的是max的作用）</p>
</li>
<li><p><code>size</code>：一个对象的实际大小</p>
</li>
<li><p><code>object_size</code>：一个对象所用数据的大小</p>
<blockquote>
<p>例如 <code>struct cred</code> 大小为 176（object_size），实际分配的对象大小为 192 （size）</p>
</blockquote>
</li>
<li><p><code>offset</code>：slab 上空闲对象链表指针在对象上的偏移</p>
</li>
<li><p><code>oo</code> ： <em>其实就是一个 int</em> </p>
<ul>
<li>低 16 位：一张 slab 上的对象数量</li>
<li>高 16 位：一张 slab 的大小（2<sup>n</sup> 张内存页）</li>
</ul>
</li>
<li><p><code>min</code>：一张 slab 上最少的对象数量</p>
</li>
<li><p><code>allocflags</code>：向 buddy system 请求页面时所用的 gfp flag</p>
</li>
<li><p><code>ctor</code>：对象的构造函数，在分配对象后会调用该函数进行初始化</p>
</li>
<li><p><code>inuse</code>：实际上就是 <code>object_size</code></p>
</li>
<li><p><code>align</code>：对象对齐的宽度</p>
</li>
<li><p>Randomed freelist 保护相关：</p>
<ul>
<li><code>random_seq</code> ：用于在 slab 初始化时随机化 freelist 上空闲对象的连接顺序</li>
</ul>
</li>
<li><p>Hardened Usercopy 保护相关</p>
<ul>
<li><code>useroffset</code>：用户空间能读写区域的起始偏移</li>
<li><code>usersize</code>：用户空间能读写区域的大小</li>
</ul>
</li>
<li><p><code>node</code>：一个 <code>kmem_cache_node</code> 数组，对应多个<strong>不同 node 的后备内存池</strong></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/21/D4idvgzLAaqIBQM.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="II-类型"><a href="#II-类型" class="headerlink" title="II. 类型"></a>II. 类型</h3><p>初始时一共有如下几种类型的 <code>kmem_cache</code>，在进行内存分配时若未指定内存池则会根据对应的 flag 从不同的 <code>kmem_cache</code> 中取：</p>
<ul>
<li><code>KMALLOC_NORMAL</code> ：通用类型内存池，对应 <code>kmalloc-*</code>，对应分配 flag 为 <code>GFP_KERNEL</code></li>
<li><code>KMALLOC_DMA</code>：用于 DMA 的内存池，对应 <code>kmalloc-dma-*</code></li>
<li><code>KMALLOC_RECLAIM</code> 可以被回收的内存池，对应 <code>kmalloc-rcl-*</code></li>
<li><code>KMALLOC_CGROUP</code> ：用于需要进行数量统计（<code>accounted</code>，主要用于 CGROUP 相关）的内存池，对应 <code>kmalloc-cg-*</code> ，对应分配 flag 为 <code>GFP_KERNEL_ACCOUNT</code></li>
</ul>
<p>若是未开启对应的编译选项，则默认合并入 <code>KMALLOC_NORMAL</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Whenever changing this, take care of that kmalloc_type() and</span><br><span class="hljs-comment"> * create_kmalloc_caches() still work as intended.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * KMALLOC_NORMAL can contain only unaccounted objects whereas KMALLOC_CGROUP</span><br><span class="hljs-comment"> * is for accounted but unreclaimable and non-dma objects. All the other</span><br><span class="hljs-comment"> * kmem caches can have both accounted and unaccounted objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">kmalloc_cache_type</span> &#123;</span><br>	KMALLOC_NORMAL = <span class="hljs-number">0</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_ZONE_DMA</span><br>	KMALLOC_DMA = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MEMCG_KMEM</span><br>	KMALLOC_CGROUP = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_TINY</span><br>	KMALLOC_RECLAIM = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>	KMALLOC_RECLAIM,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span><br>	KMALLOC_DMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br>	KMALLOC_CGROUP,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	NR_KMALLOC_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="III-slab-alias（mergeability）"><a href="#III-slab-alias（mergeability）" class="headerlink" title="III. slab alias（mergeability）"></a>III. slab alias（mergeability）</h3><p>slab alias 机制是一种对同等&#x2F;相近大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p>
<ul>
<li>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配相等&#x2F;近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong></li>
</ul>
<blockquote>
<p>举个🌰，<code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配</p>
</blockquote>
<p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code> 而非为原有的建立 alias，🌰如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong></p>
<h2 id="三、kmem-cache-cpu：各-CPU-独占内存池"><a href="#三、kmem-cache-cpu：各-CPU-独占内存池" class="headerlink" title="三、kmem_cache_cpu：各 CPU 独占内存池"></a>三、kmem_cache_cpu：各 CPU 独占内存池</h2><p>当进程向 slab allocator 请求内存分配时，首先会尝试从当前 CPU 的独占内存池进行分配 ——<code>kmem_cache_cpu</code> 结构体表示<strong>每个 CPU 独占的内存池</strong>，其在 <code>kmem_cache</code> 中为一个 percpu 变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When changing the layout, make sure freelist and tid are still compatible</span><br><span class="hljs-comment"> * with this_cpu_cmpxchg_double() alignment requirements.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> &#123;</span><br>	<span class="hljs-type">void</span> **freelist;	<span class="hljs-comment">/* 指向下一个可用对象的指针 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;	<span class="hljs-comment">/* Globally unique transaction id */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span>	<span class="hljs-comment">/* 用以内存分配的 slab */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">partial</span>;</span>	<span class="hljs-comment">/* Partially allocated frozen slabs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-type">local_lock_t</span> lock;	<span class="hljs-comment">/* Protects the fields above */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_STATS</span><br>	<span class="hljs-type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>freelist</code>：指向下一个空闲对象的指针</li>
<li><code>slab</code>：当前用以进行内存分配的 slab</li>
<li><code>partial</code>：percpu partial slab 链表，链表上为仍有一定空闲对象的 slab</li>
</ul>
<p>slab 的 freelist 仅当其在 partial 链表上时有用，当一张 slab 为当前 CPU 正在使用的 slab 时，其 freelist 为 NULL，由 <code>kmem_cache_cpu.freelist</code> 指向第一个空闲对象</p>
<p><img src="https://s2.loli.net/2023/02/21/xSLqghNZ23nCMiz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="四、kmem-cache-node：各-node-后备内存池"><a href="#四、kmem-cache-node：各-node-后备内存池" class="headerlink" title="四、kmem_cache_node：各 node 后备内存池"></a>四、kmem_cache_node：各 node 后备内存池</h2><p><strong>每个 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/#0x03-struct-pglist-data%EF%BC%9A%E8%8A%82%E7%82%B9">node</a> 对应的后备内存池</strong>，当 percpu 的独占内存池耗尽后便会从对应 node 的后备内存池尝试分配</p>
<blockquote>
<p>不过大部分计算机都仅有一个 node，所以通常情况下每个 <code>kmem_cache</code> 也就只有一个 <code>kmem_cache_node</code>  😄</p>
</blockquote>
<p>因为本文主要讲 slub，所以仅截取 slub 相关字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The slab lists for all objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB</span><br>	<span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB</span><br>	<span class="hljs-type">spinlock_t</span> list_lock;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_partial;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">partial</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span><br>	<span class="hljs-type">atomic_long_t</span> nr_slabs;<br>	<span class="hljs-type">atomic_long_t</span> total_objects;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">full</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>list_lock</code>：保护 partial 和 full 链表的锁</li>
<li><code>partial</code>：partial slab 链表，连接<strong>有着部分空闲对象剩余的 slab</strong></li>
<li><code>nr_partial</code>：partial slab 的数量</li>
<li><code>full</code>：full slab 链表，连接<strong>空闲对象完全耗尽的 slab</strong>（注：该链表基本上不常用）</li>
<li><code>nr_slabs</code>：总的 slab 数量</li>
<li><code>total_objects</code>：总的对象数量</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/21/ECDOVtxAyiwd1UZ.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="0x02-对象的分配"><a href="#0x02-对象的分配" class="headerlink" title="0x02. 对象的分配"></a>0x02. 对象的分配</h1><h2 id="※-一、slab-alloc-node-：从指定的-kmem-cache-分配-object"><a href="#※-一、slab-alloc-node-：从指定的-kmem-cache-分配-object" class="headerlink" title="※ 一、slab_alloc_node()：从指定的 kmem_cache 分配 object"></a>※ 一、slab_alloc_node()：从指定的 kmem_cache 分配 object</h2><p>在 slab allocator 中存在着多个不同的内存分配接口，其最后都会调用到 <code>slab_alloc_node()</code> 完成内存分配的工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 内联化的快速路径以让分配函数 (kmalloc, kmem_cache_alloc) 中包含快速路径.</span><br><span class="hljs-comment"> * 因此，对于快速路径可以满足的请求，没有函数调用的开销.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径首先检查无锁的空闲链表是否可以被使用.</span><br><span class="hljs-comment"> * 若否，调用 __slab_alloc 进行缓慢处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则我们可以简单地从无锁空闲链表取出下一个对象.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> *<span class="hljs-title function_">slab_alloc_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> list_lru *lru,</span><br><span class="hljs-params">		<span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)</span><br>&#123;<br>	<span class="hljs-type">void</span> *object;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-type">bool</span> init = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<p>该函数首先会调用 <code>slab_pre_alloc_hook()</code> 进行分配前的检查工作，不通过则返回 NULL，这一步主要是检查分配标志位是否合法等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="hljs-number">1</span>, gfpflags);<br><span class="hljs-keyword">if</span> (!s)<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p>接下来调用 <code>kfence_alloc()</code> 进行内存错误检测，不通过则直接跳转到 <code>out</code>，这里用到了 <em>Kfence (Kernel Electric Fence)</em>  内存纠错机制，主要是检查对 <code>data page</code> 的访问是否越界：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">object = kfence_alloc(s, orig_size, gfpflags);<br><span class="hljs-keyword">if</span> (unlikely(object))<br>	<span class="hljs-keyword">goto</span> out;<br></code></pre></td></tr></table></figure>

<p><strong>接下来调用 <code>__slab_alloc_node()</code> 进行正式的内存分配，这一步便是真正的核心分配函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);<br></code></pre></td></tr></table></figure>

<p>最后调用 <code>maybe_wipe_obj_freeptr()</code> 将 object 原本存放 next free object 指针的位置清零，之后调用 <code>slab_want_init_on_alloc()</code> 检查标志位是否有 <code>__GFP_ZERO</code>，若有则调用 <code>slab_post_alloc_hook()</code> 将 object 上数据清零</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">	maybe_wipe_obj_freeptr(s, object);<br>	init = slab_want_init_on_alloc(gfpflags, s);<br><br>out:<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 当 init == &#x27;true&#x27;, 类似 kzalloc() 族, </span><br><span class="hljs-comment">	 * 仅有 @orig_size 字节会被清零，而非 s-&gt;object_size</span><br><span class="hljs-comment">	 */</span><br>	slab_post_alloc_hook(s, objcg, gfpflags, <span class="hljs-number">1</span>, &amp;object, init, orig_size);<br><br>	<span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们来看真正的核心分配函数 <code>__slab_alloc_node()</code></p>
<h3 id="I-slab-alloc-node-：从-percpu-freelist-进行分配（fast-path）"><a href="#I-slab-alloc-node-：从-percpu-freelist-进行分配（fast-path）" class="headerlink" title="I. __slab_alloc_node()：从 percpu freelist 进行分配（fast path）"></a>I. __slab_alloc_node()：从 percpu freelist 进行分配（fast path）</h3><p>该函数首先会先获取 percpu 的 <code>kmem_cache_cpu</code> 上的 freelist 与 slab，<strong>若 slab 或 freelist 为空</strong> &#x2F; slab 与 node 不匹配，则调用 <code>__slab_alloc()</code> 分配一张新 slab 并从其中获取一个空闲对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *__slab_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s,<br>		<span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br>	<span class="hljs-type">void</span> *object;<br><br>redo:<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 必须通过该 cpu ptr 读取 kmem_cache cpu 数据. 抢占是开启的.</span><br><span class="hljs-comment">	 * 我们可能会在从一个 cpu 区域读取时在 cpu 间切换.</span><br><span class="hljs-comment">	 * 只要我们在 cmpxchg 时在原本的 cpu 上重新结束便不要紧.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 我们必须保证 tid 与 kmem_cache_cpu 被在同一 cpu 上取回.</span><br><span class="hljs-comment">	 * 我们首先读取 kmem_cache_cpu 指针并用其读取 tid.</span><br><span class="hljs-comment">	 * 若我们在两次读取间被抢占并切换到另一 cpu，由于这两者仍与同一 cpu 关联，</span><br><span class="hljs-comment">	 * cmpxchg 稍后将会验证 cpu ，这是 OK 的.</span><br><span class="hljs-comment">	 */</span><br>	c = raw_cpu_ptr(s-&gt;cpu_slab);<br>	tid = READ_ONCE(c-&gt;tid);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 此处使用的无中断（irqless） 对象分配/释放算法决定于获取 cpu_slab 数据的顺序.</span><br><span class="hljs-comment">	 * tid 应当在在 c 上的任何事之前被获取以确保与此前 tid 关联的对象与 slab</span><br><span class="hljs-comment">	 * 不会被与当前 tid 一起使用. 若我们先获取 tid，对象与 slab 可能会与下一个 tid </span><br><span class="hljs-comment">	 * 相关联，而我们的分配/释放请求也将会失败.这种情况下我们会重试所以没问题.</span><br><span class="hljs-comment">	 */</span><br>	barrier();<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The transaction ids are globally unique per cpu and per operation on</span><br><span class="hljs-comment">	 * a per cpu queue（这句翻成中文咋都不顺，直接看原文吧😄）.</span><br><span class="hljs-comment">	 * 由此可以确保 cmpxchg_double 发生在正确的处理器上且其间在链表上没有任何操作.</span><br><span class="hljs-comment">	 */</span><br><br>	object = c-&gt;freelist;<br>	slab = c-&gt;slab;<br><br>	<span class="hljs-keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||<br>	    unlikely(!object || !slab || !node_match(slab, node))) &#123;<br>		object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);<br></code></pre></td></tr></table></figure>

<p>若有 freelist &amp; slub，则<strong>调用 <code>get_freepointer_safe()</code> 获取当前空闲对象下一个空闲对象</strong>；接下来 <code>this_cpu_cmpxchg_double()</code> 会检查是否 <code>freelist == object</code>、<code>cpu_slab-&gt;tid == tid</code>，若是则<strong>将 freelist 设为 next_object 并获取设置下一 tid</strong>，否则说明发生了抢占（我们已经不在原 cpu 上了），跳转回 <code>redo</code> 重新在当前 cpu 上进行分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> &#123;<br>	<span class="hljs-type">void</span> *next_object = get_freepointer_safe(s, object);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 仅当没有额外操作且我们在正确的处理器上时 cmpxchg 将匹配.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * cmpxchg 原子地进行了如下： (没有锁语义!)</span><br><span class="hljs-comment">	 * 1. 重定位第一个指针到当前的 per cpu 区域.</span><br><span class="hljs-comment">	 * 2. 验证 tid &amp; freelist 没有被改变</span><br><span class="hljs-comment">	 * 3. 若未被改变，替换 tid &amp; freelist</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 自从没有锁语义，保护仅需要对抗在该 cpu 上执行的代码*不*从其他的 cpu 上访问.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>			s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>			object, tid,<br>			next_object, next_tid(tid)))) &#123;<br><br>		note_cmpxchg_failure(<span class="hljs-string">&quot;slab_alloc&quot;</span>, s, tid);<br>		<span class="hljs-keyword">goto</span> redo;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>最后对于直接从 cpu_slab 上分配的对象会通过 <code>prefetch_freepointer()</code> 调用 prefetchw 指令提前将已分配对象的地址载入缓存中，之后就是返回分配成功的空闲对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">		prefetch_freepointer(s, next_object);<br>		stat(s, ALLOC_FASTPATH);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="II-slab-alloc-：获取另一-slab-进行分配（slow-path）"><a href="#II-slab-alloc-：获取另一-slab-进行分配（slow-path）" class="headerlink" title="II. ___slab_alloc()：获取另一 slab 进行分配（slow path）"></a>II. ___slab_alloc()：获取另一 slab 进行分配（slow path）</h3><p><code>__slab_alloc()</code> 其实是在开启了抢占的情况下（默认开启）对 <code>___slab_alloc()</code> 的一个简单的 wrapper，主要就是重新读取 <code>kmem_cache_cpu</code> 的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当抢占没有关闭时 ___slab_alloc() 用于上下文的 wrapper.</span><br><span class="hljs-comment"> * 通过重新获取 percpu 区域的指针来补偿可能的 cpu 更改.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>			  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br>	<span class="hljs-type">void</span> *p;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 我们可能已被抢占且在关闭抢占前调度到了不同的 cpu 上.</span><br><span class="hljs-comment">	 * 需要重新载入 cpu 区域指针.</span><br><span class="hljs-comment">	 */</span><br>	c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br>	slub_put_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们来看 <code>___slab_alloc()</code>，该函数便是慢速分配路径的核心函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 慢速路径. 无锁 freelist 为空或是我们需要进行调试任务.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若新的对象已经被释放到常规的 freelist 上，则过程仍是很快的.</span><br><span class="hljs-comment"> * 这种情况下我们简单地让常规的 freelist 取代无锁 freelist</span><br><span class="hljs-comment"> * 并 zap the regular freelist.（zap想不出咋翻译好😄）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若这不起作用，则我们回退到 partial 链表. 我们将 freelist 上的第一个元素</span><br><span class="hljs-comment"> * 作为要分配的对象并将 freelist 的剩余部分移动到无锁 freelist.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若我们无法从 partial slab 链表上获得一个新的 slab，我们需要分配一个新的 slab.</span><br><span class="hljs-comment"> * 因为这包含对页分配器的调用与新 slab 的设置，这是最慢的路径.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当我们知道抢占被禁用时所用的 __slab_alloc 的版本 (也是造成大量分配的原因).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *___slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>			  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br>	<span class="hljs-type">void</span> *freelist;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partial_context</span> <span class="hljs-title">pc</span>;</span><br><br>	stat(s, ALLOC_SLOWPATH);<br></code></pre></td></tr></table></figure>

<p>接下来笔者按照代码标签顺序进行分析</p>
<h4 id="①-reread-slab：读取-percpu-slab"><a href="#①-reread-slab：读取-percpu-slab" class="headerlink" title="① reread_slab：读取 percpu slab"></a>① reread_slab：读取 percpu slab</h4><p>首先读取 percpu 的 slab，若没有 slab 则判断分配节点，并跳转到 <code>new_slab</code> 分配新的 slab，注意这一块代码对应 <code>reread_slab</code> 标签：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">reread_slab:<br><br>	slab = READ_ONCE(c-&gt;slab);<br>	<span class="hljs-keyword">if</span> (!slab) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 若 node 未上线或没有 normal memory，忽略 node 约束</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;<br>			     !node_isset(node, slab_nodes)))<br>			node = NUMA_NO_NODE;<br>		<span class="hljs-keyword">goto</span> new_slab;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="②-redo：获取-percpu-slab-gt-freelist"><a href="#②-redo：获取-percpu-slab-gt-freelist" class="headerlink" title="② redo：获取 percpu slab-&gt;freelist"></a>② redo：获取 percpu slab-&gt;freelist</h4><p>接下来这块代码对应 <code>redo</code> 标签：</p>
<ul>
<li><p>若 percpu slab 不为空，判断 slab 是否属于指定的节点且与分配标志位匹配，若否，则跳转到 <code>deactivate_slab</code> 标签</p>
</li>
<li><p>接下来检查 slab 是否仍为原来的 cpu slab（因为我们可能被抢占），若否，则跳转回 <code>reread_slab</code></p>
</li>
<li><p>接下来获取 per-cpu 的 freelist，若不为空，则跳转到 <code>load_freelist</code>，否则<strong>调用 <code>get_freelist()</code> 获取 slab 的 freelist</strong></p>
</li>
<li><p>若 slab 的 freelist 仍为空，将 per-cpu freelist 设为 NULL，获取下一个 tid，并跳转到 <code>new_slab</code> 分配新的 slab</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br><br>	<span class="hljs-keyword">if</span> (unlikely(!node_match(slab, node))) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 与上面相同但 node_match() 为 false 则早已说明 node != NUMA_NO_NODE</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!node_isset(node, slab_nodes)) &#123;<br>			node = NUMA_NO_NODE;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			stat(s, ALLOC_NODE_MISMATCH);<br>			<span class="hljs-keyword">goto</span> deactivate_slab;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 我们理应搜索一个 PFMEMALLOC 的 slab 页面，但现在，</span><br><span class="hljs-comment">	 * 当页面离开 per-cpu 分配器，我们正在失去 pfmemalloc 信息</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))<br>		<span class="hljs-keyword">goto</span> deactivate_slab;<br><br>	<span class="hljs-comment">/* 必须再次检查 c-&gt;slab 以免我们被抢占使其发生了更改 */</span><br>	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>	<span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>		<span class="hljs-keyword">goto</span> reread_slab;<br>	&#125;<br>	freelist = c-&gt;freelist;<br>	<span class="hljs-keyword">if</span> (freelist)<br>		<span class="hljs-keyword">goto</span> load_freelist;<br><br>	freelist = get_freelist(s, slab);<br><br>	<span class="hljs-keyword">if</span> (!freelist) &#123;<br>		c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>		c-&gt;tid = next_tid(c-&gt;tid);<br>		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>		stat(s, DEACTIVATE_BYPASS);<br>		<span class="hljs-keyword">goto</span> new_slab;<br>	&#125;<br><br>	stat(s, ALLOC_REFILL);<br></code></pre></td></tr></table></figure>

<p><code>get_freelist()</code> 函数主要就是获取 <code>slab-&gt;freelist</code> 后将 <code>slab-&gt;freelist</code> 设为 NULL 并返回原来的 freelist</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检查 slab-&gt;freelist 并将 freelist 传送给 percpu freelist</span><br><span class="hljs-comment"> * 或是将 slab 给 deactivate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若返回值非 NULL 则 slab 仍被冻结.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若该函数返回 NULL 则 slab 被解冻.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_freelist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br>	<span class="hljs-type">void</span> *freelist;<br><br>	lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br>	<span class="hljs-keyword">do</span> &#123;<br>		freelist = slab-&gt;freelist;<br>		counters = slab-&gt;counters;<br><br>		new.counters = counters;<br>		VM_BUG_ON(!new.frozen);<br><br>		new.inuse = slab-&gt;objects;<br>		new.frozen = freelist != <span class="hljs-literal">NULL</span>;<br><br>	&#125; <span class="hljs-keyword">while</span> (!__cmpxchg_double_slab(s, slab,<br>		freelist, counters,<br>		<span class="hljs-literal">NULL</span>, new.counters,<br>		<span class="hljs-string">&quot;get_freelist&quot;</span>));<br><br>	<span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="③-load-freelist：从-freelist-分配对象"><a href="#③-load-freelist：从-freelist-分配对象" class="headerlink" title="③ load_freelist：从 freelist 分配对象"></a>③ load_freelist：从 freelist 分配对象</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>load_freelist</code> 标签，主要就是调用 <code>get_freepointer()</code> 将 percpu freelist 指向第二个空闲对象，并获取下一个 tid 后返回前面获取的 freelist（也就是第一个空闲对象）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">load_freelist:<br><br>	lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * freelist 指向要被使用的对象链表. slab 指向获得对象的 slab.</span><br><span class="hljs-comment">	 * 因此 slab 必须被冻结以让 percpu 的分配正常工作.</span><br><span class="hljs-comment">	 */</span><br>	VM_BUG_ON(!c-&gt;slab-&gt;frozen);<br>	c-&gt;freelist = get_freepointer(s, freelist);<br>	c-&gt;tid = next_tid(c-&gt;tid);<br>	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>	<span class="hljs-keyword">return</span> freelist;<br></code></pre></td></tr></table></figure>

<p>这里注意在 <code>get_freepointer()</code> 里套了两层，最后会调用到 <code>freelist_ptr()</code> 获取到第二个空闲对象的指针，这里需要注意的是当开启了 Hardened freelist 保护后在 next 指针的位置存放的是 <strong>第一个空闲对象地址 ^ 第二个空闲对象地址 ^ 一个随机值</strong>（<code>kmem_cache-&gt;random</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 返回 freelist 指针 (ptr). 在有加固的情况下其通过一个</span><br><span class="hljs-comment"> * 对存储指针的地址与 per-cache 随机值的异或进行混淆.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">freelist_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *ptr,</span><br><span class="hljs-params">				 <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptr_addr)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 当开启了 CONFIG_KASAN_SW/HW_TAGS, ptr_addr 可能被打上标签.</span><br><span class="hljs-comment">	 * 通常这不会造成任何问题，因为 set_freepointer() 与 get_freepointer() </span><br><span class="hljs-comment">	 * 调用时都会有标签相同的指针.</span><br><span class="hljs-comment">	 * 但是 CONFIG_SLUB_DEBUG 的代码有些问题. 例如当 __free_slub() 在</span><br><span class="hljs-comment">	 * 一个 cache 中迭代对象时,其将没有标签的指针传给 check_object(). </span><br><span class="hljs-comment">	 * check_object() 依次带着一个没有标签的指针调用 get_freepointer()，</span><br><span class="hljs-comment">	 * 从而造成 freepointer 存储错误.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr ^ s-&gt;random ^<br>			swab((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)ptr_addr)));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>	<span class="hljs-keyword">return</span> ptr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>从这里我们也可以看出 <strong>slab-&gt;freelist 是没有加密的，但链表上的后续指针都是加密了的</strong></p>
<h4 id="④-deactivate-slab：deactivate-percpu-slab"><a href="#④-deactivate-slab：deactivate-percpu-slab" class="headerlink" title="④ deactivate_slab：deactivate percpu slab"></a>④ deactivate_slab：deactivate percpu slab</h4><p>继续返回 <code>___slab_alloc()</code> 中，接下来这块代码对应 <code>deactivate_slab</code> 标签，首先还是惯例地检查是否被抢占调度到了别的 CPU，若是则跳转回 <code>reread_slab</code>；之后就是简单地将 percpu 的 slab 和 freelist 设为 NULL 并获取下一个 tid，之后调用 <code>deactivate_slab()</code> 将这张 slab 给 deactivate 了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">deactivate_slab:<br><br>	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>	<span class="hljs-keyword">if</span> (slab != c-&gt;slab) &#123;<br>		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>		<span class="hljs-keyword">goto</span> reread_slab;<br>	&#125;<br>	freelist = c-&gt;freelist;<br>	c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>	c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>	c-&gt;tid = next_tid(c-&gt;tid);<br>	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>	deactivate_slab(s, slab, freelist);<br></code></pre></td></tr></table></figure>

<p><code>deactivate_slab()</code> 的逻辑如下：</p>
<ul>
<li>遍历 freelist 检查是否被破坏，放弃被破坏的部分</li>
<li>将 <code>slab-&gt;freelist</code> 设为原 <code>kmem_cache_cpu-&gt;freelist</code>，若 slab 上原有 freelist 不为 NULL 则再接到后面</li>
<li>设置 slab 的 counters，其中<strong>将 <code>frozen</code> 设为 0</strong></li>
<li>若 slab 上的对象全部空闲**且 node 的 partial slab 数量大于 <code>kmem_cache-&gt;min_partial</code>**，调用 <code>discard_slab()</code> 将 slab 释放</li>
<li>若 slab 上存在空闲对象，调用 <code>add_partial()</code> 将其加入 node 的 partial 链表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 结束移除 cpu slab. 合并 cpu&#x27;s freelist 与 slab&#x27;s freelist,</span><br><span class="hljs-comment"> * 解冻 slabs 并放在合适的链表上.</span><br><span class="hljs-comment"> * 假设 slab 已经被调用者安全地从 kmem_cache_cpu 上取下.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">deactivate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">			    <span class="hljs-type">void</span> *freelist)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> &#123;</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST &#125;;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> get_node(s, slab_nid(slab));<br>	<span class="hljs-type">int</span> free_delta = <span class="hljs-number">0</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> <span class="hljs-title">mode</span> =</span> M_NONE;<br>	<span class="hljs-type">void</span> *nextfree, *freelist_iter, *freelist_tail;<br>	<span class="hljs-type">int</span> tail = DEACTIVATE_TO_HEAD;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags = <span class="hljs-number">0</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">old</span>;</span><br><br>	<span class="hljs-keyword">if</span> (slab-&gt;freelist) &#123;<br>		stat(s, DEACTIVATE_REMOTE_FREES);<br>		tail = DEACTIVATE_TO_TAIL;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 阶段一: 统计 cpu&#x27;s freelist 上的对象数量（free_delta） </span><br><span class="hljs-comment">	 * 并保存最后一个对象（freelist_tail） 用于后面的拼接.</span><br><span class="hljs-comment">	 */</span><br>	freelist_tail = <span class="hljs-literal">NULL</span>;<br>	freelist_iter = freelist;<br>	<span class="hljs-keyword">while</span> (freelist_iter) &#123;<br>		nextfree = get_freepointer(s, freelist_iter);<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 若 &#x27;nextfree&#x27; 无效, 在 &#x27;freelist_iter&#x27; 上的对象可能已被破坏.</span><br><span class="hljs-comment">		 * 故通过略过 &#x27;freelist_iter&#x27; 起的所有对象来进行隔离.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))<br>			<span class="hljs-keyword">break</span>;<br><br>		freelist_tail = freelist_iter;<br>		free_delta++;<br><br>		freelist_iter = nextfree;<br>	&#125;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 阶段二: 解冻slab并将per-cpu freelist拼接到slab&#x27;s freelist头部.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 确保链表的存在反映了在解冻期间实际的对象数量时，slab 已被解冻.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 我们首先在持有锁的情况下进行compxchg并当其成功时将 slab 插入链表.</span><br><span class="hljs-comment">	 * 若有不匹配的情况则 slab 为未冻结且 slab 上的数量可能发生了改变.</span><br><span class="hljs-comment">	 * 释放锁并再次重试 cmpxchg.</span><br><span class="hljs-comment">	 */</span><br>redo:<br><br>	old.freelist = READ_ONCE(slab-&gt;freelist);<br>	old.counters = READ_ONCE(slab-&gt;counters);<br>	VM_BUG_ON(!old.frozen);<br><br>	<span class="hljs-comment">/* 确定 slab 的目标状态 */</span><br>	new.counters = old.counters;<br>	<span class="hljs-keyword">if</span> (freelist_tail) &#123;<br>		new.inuse -= free_delta;<br>		set_freepointer(s, freelist_tail, old.freelist);<br>		new.freelist = freelist;<br>	&#125; <span class="hljs-keyword">else</span><br>		new.freelist = old.freelist;<br><br>	new.frozen = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123;<br>		mode = M_FREE;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.freelist) &#123;<br>		mode = M_PARTIAL;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 持有自旋锁消除了acquire_slab()看到一个slab为冻结的可能性</span><br><span class="hljs-comment">		 */</span><br>		spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		mode = M_FULL_NOLIST;<br>	&#125;<br><br><br>	<span class="hljs-keyword">if</span> (!cmpxchg_double_slab(s, slab,<br>				old.freelist, old.counters,<br>				new.freelist, new.counters,<br>				<span class="hljs-string">&quot;unfreezing slab&quot;</span>)) &#123;<br>		<span class="hljs-keyword">if</span> (mode == M_PARTIAL)<br>			spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>		<span class="hljs-keyword">goto</span> redo;<br>	&#125;<br><br><br>	<span class="hljs-keyword">if</span> (mode == M_PARTIAL) &#123;<br>		add_partial(n, slab, tail);<br>		spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>		stat(s, tail);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FREE) &#123;<br>		stat(s, DEACTIVATE_EMPTY);<br>		discard_slab(s, slab);<br>		stat(s, FREE_SLAB);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FULL_NOLIST) &#123;<br>		stat(s, DEACTIVATE_FULL);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="④-new-slab：获取-percpu-partial-slab"><a href="#④-new-slab：获取-percpu-partial-slab" class="headerlink" title="④ new_slab：获取 percpu partial slab"></a>④ new_slab：获取 percpu partial slab</h4><p>接下来是 <code>new_slab</code> 标签，主要就是检查若有 percpu partial slab 则从 percpu partial 链表上获取一个 slab 将其设为 percpu slab 后 再跳转回 <code>redo</code> 标签：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">new_slab:<br><br>	<span class="hljs-keyword">if</span> (slub_percpu_partial(c)) &#123;<span class="hljs-comment">//有 percpu partial slab</span><br>		local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>		<span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<span class="hljs-comment">//percpu slab 不为空，直接跳回 redo</span><br>			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>			<span class="hljs-keyword">goto</span> reread_slab;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123;<span class="hljs-comment">//被抢占然后partial空了</span><br>			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>			<span class="hljs-comment">/* 我们被抢占了且 partial 链表空了 */</span><br>			<span class="hljs-keyword">goto</span> new_objects;<br>		&#125;<br><br>		<span class="hljs-comment">// 获取一张 percpu patial slab，跳回 redo</span><br>		slab = c-&gt;slab = slub_percpu_partial(c);<br>		slub_set_percpu_partial(c, slab);<br>		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>		stat(s, CPU_PARTIAL_ALLOC);<br>		<span class="hljs-keyword">goto</span> redo;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="⑤-new-objects：获取-node-pertial-slab-或向-buddy-请求新-slab-进行分配"><a href="#⑤-new-objects：获取-node-pertial-slab-或向-buddy-请求新-slab-进行分配" class="headerlink" title="⑤ new_objects：获取 node pertial slab 或向 buddy 请求新 slab 进行分配"></a>⑤ new_objects：获取 node pertial slab 或向 buddy 请求新 slab 进行分配</h4><p>若 percpu partial 链表也为空，那么便来到接下来的 <code>new_objects</code> 标签分配一个新的 slab，首先会设置 <code>partial_context</code>，调用 <code>get_partial()</code> 尝试从 <code>kmem_cache_node</code> 的 partial 链表分配一个 slab，若分配成功则直接跳转到 <code>check_new_slab</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">new_objects:<br><br>	pc.flags = gfpflags;<br>	pc.slab = &amp;slab;<br>	pc.orig_size = orig_size;<br>	freelist = get_partial(s, node, &amp;pc);<br>	<span class="hljs-keyword">if</span> (freelist)<br>		<span class="hljs-keyword">goto</span> check_new_slab;<br><br></code></pre></td></tr></table></figure>

<p><code>get_partial()</code> 首先会调用 <code>get_partial_node()</code> 从当前 node 的 <code>kmem_cache_node</code> 的 partial 链表分配 slab，若成功了则直接返回，如果失败了但是指定了分配的 node 为 <code>NUMA_NO_NODE</code>，则调用 <code>get_any_partial()</code> 从其他的 <code>kmem_cache_node</code> 的 partial 链表尝试分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 获取一个 partial slab, 加锁并返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_partial</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">int</span> node, <span class="hljs-keyword">struct</span> partial_context *pc)</span><br>&#123;<br>	<span class="hljs-type">void</span> *object;<br>	<span class="hljs-type">int</span> searchnode = node;<br><br>	<span class="hljs-keyword">if</span> (node == NUMA_NO_NODE)<br>		searchnode = numa_mem_id();<br><br>	<span class="hljs-comment">// 从当前 node 的 partial 链表分配 slab</span><br>	object = get_partial_node(s, get_node(s, searchnode), pc);<br>	<span class="hljs-keyword">if</span> (object || node != NUMA_NO_NODE)<br>		<span class="hljs-keyword">return</span> object;<br><br>	<span class="hljs-comment">// 从其他 node 的 partial 链表分配 slab</span><br>	<span class="hljs-keyword">return</span> get_any_partial(s, pc);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>若 <code>get_partial()</code> 没法获取到 slab，则调用 <code>new_slab()</code> 向 buddy system 请求一份新的 slab，若失败了则直接返回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">slub_put_cpu_ptr(s-&gt;cpu_slab);<br>slab = new_slab(s, gfpflags, node);<br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<br>	slab_out_of_memory(s, gfpflags, node);<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>stat(s, ALLOC_SLAB);<br></code></pre></td></tr></table></figure>

<p><code>new_slab()</code> 最后会调用到 <code>allocate_slab()</code>：</p>
<ul>
<li>首先检查页面分配标志位，之后调用 <code>alloc_slab_page()</code> 在指定 node 上进行分配<ul>
<li>若 <code>node == NUMA_NO_NODE</code>，则该函数会调用 <code>alloc_pages()</code>，否则会调用 <code>__alloc_pages_node()</code></li>
</ul>
</li>
<li>若失败了则再次调用  <code>alloc_slab_page()</code>  尝试进行最小内存分配（<code>kmem_cache-&gt;min</code>），仍失败则直接返回 NULL</li>
<li>初始化 slab 各成员，并调用 <code>shuffle_freelist()</code> 为空闲对象构造随机化链表，若未开启随机化则将空闲对象按顺序连接</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> slab *<span class="hljs-title function_">allocate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span> =</span> s-&gt;oo;<br>	<span class="hljs-type">gfp_t</span> alloc_gfp;<br>	<span class="hljs-type">void</span> *start, *p, *next;<br>	<span class="hljs-type">int</span> idx;<br>	<span class="hljs-type">bool</span> shuffle;<br><br>	flags &amp;= gfp_allowed_mask;<br><br>	flags |= s-&gt;allocflags;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 让最初的 higher-order 分配在内存压力下失败</span><br><span class="hljs-comment">	 * 由此我们返回到最小 order 的分配.</span><br><span class="hljs-comment">	 */</span><br>	alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;<br>	<span class="hljs-keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))<br>		alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~__GFP_RECLAIM;<br><br>	slab = alloc_slab_page(alloc_gfp, node, oo);<br>	<span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<span class="hljs-comment">//分配失败，尝试最小内存分配</span><br>		oo = s-&gt;min;<br>		alloc_gfp = flags;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 分配可能因为碎片化而失败.</span><br><span class="hljs-comment">		 * 可能的话尝试一个 lower order 的分配</span><br><span class="hljs-comment">		 */</span><br>		slab = alloc_slab_page(alloc_gfp, node, oo);<br>		<span class="hljs-keyword">if</span> (unlikely(!slab))<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>		stat(s, ORDER_FALLBACK);<br>	&#125;<br><br>	slab-&gt;objects = oo_objects(oo);<br>	slab-&gt;inuse = <span class="hljs-number">0</span>;<br>	slab-&gt;frozen = <span class="hljs-number">0</span>;<br><br>	account_slab(slab, oo_order(oo), s, flags);<br><br>	slab-&gt;slab_cache = s;<br><br>	kasan_poison_slab(slab);<br><br>	start = slab_address(slab);<br><br>	setup_slab_debug(s, slab, start);<br><br>	<span class="hljs-comment">//开启了随机化会在该函数内随机连接</span><br>	shuffle = shuffle_freelist(s, slab);<br><br>	<span class="hljs-comment">//未开启随机化，按顺序连接</span><br>	<span class="hljs-keyword">if</span> (!shuffle) &#123;<br>		start = fixup_red_left(s, start);<br>		start = setup_object(s, start);<br>		slab-&gt;freelist = start;<br>		<span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="hljs-number">1</span>; idx++) &#123;<br>			next = p + s-&gt;size;<br>			next = setup_object(s, next);<br>			set_freepointer(s, p, next);<br>			p = next;<br>		&#125;<br>		set_freepointer(s, p, <span class="hljs-literal">NULL</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> slab;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里用了一个函数 <code>set_freepointer()</code>，主要就是用 <code>freelist_ptr()</code> 向 <code>object + s-&gt;offset</code> 的位置写入用 <code>freelist_ptr()</code> 加密后的 <code>fp</code> 指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">set_freepointer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *object, <span class="hljs-type">void</span> *fp)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)object + s-&gt;offset;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br>	BUG_ON(object == fp); <span class="hljs-comment">/* naive detection of double free or corruption */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	freeptr_addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)kasan_reset_tag((<span class="hljs-type">void</span> *)freeptr_addr);<br>	*(<span class="hljs-type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>返回 <code>___slab_alloc()</code>，如果<strong>该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位</strong>，则接下来会调用 <code>alloc_single_from_new_slab()</code> <strong>从新获取到的 slab 上分配一个对象后将 slab 重新挂回 partial&#x2F;full 链表</strong>，若分配失败则跳转回 <code>new_objects</code>，成功则直接返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br>	freelist = alloc_single_from_new_slab(s, slab, orig_size);<br><br>	<span class="hljs-keyword">if</span> (unlikely(!freelist))<br>		<span class="hljs-keyword">goto</span> new_objects;<br><br>	<span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>		set_track(s, freelist, TRACK_ALLOC, addr);<br><br>	<span class="hljs-keyword">return</span> freelist;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果没有设置 <code>SLAB_DEBUG_FLAGS</code> 标志位，则接下来获取 slab 的 freelist，并调用 <code>inc_slabs_node()</code> 增加 node 上的计数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * No other reference to the slab yet so we can</span><br><span class="hljs-comment"> * muck around with it freely without cmpxchg</span><br><span class="hljs-comment"> */</span><br>freelist = slab-&gt;freelist;<br>slab-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>slab-&gt;inuse = slab-&gt;objects;<br>slab-&gt;frozen = <span class="hljs-number">1</span>;<br><br>inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);<br></code></pre></td></tr></table></figure>

<h4 id="⑥-check-new-slab：检查-slab"><a href="#⑥-check-new-slab：检查-slab" class="headerlink" title="⑥ check_new_slab：检查 slab"></a>⑥ check_new_slab：检查 slab</h4><p>接下来对新获取的 slab 进行检查，若该 kmem_cache 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位，检查是否设置了 <code>SLAB_STORE_USER</code> 标志位，之后直接返回 freelist</p>
<p>接下来调用 <code>pfmemalloc_match()</code> 检查 slab 与分配标志位是否不匹配，若是则调用 <code>deactivate_slab()</code> 使其不再活动并返回 freelist</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">check_new_slab:<br><br>	<span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * For debug caches here we had to go through</span><br><span class="hljs-comment">		 * alloc_single_from_partial() so just store the tracking info</span><br><span class="hljs-comment">		 * and return the object</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>			set_track(s, freelist, TRACK_ALLOC, addr);<br><br>		<span class="hljs-keyword">return</span> freelist;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * For !pfmemalloc_match() case we don&#x27;t load freelist so that</span><br><span class="hljs-comment">		 * we don&#x27;t make further mismatched allocations easier.</span><br><span class="hljs-comment">		 */</span><br>		deactivate_slab(s, slab, get_freepointer(s, freelist));<br>		<span class="hljs-keyword">return</span> freelist;<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="⑦-retry-load-slab："><a href="#⑦-retry-load-slab：" class="headerlink" title="⑦ retry_load_slab："></a>⑦ retry_load_slab：</h4><p>最后就是尝试加载新获得的 slab，如果 percpu slab 不为 NULL 则使其不再活动，并设置 percpu slab &amp; freelist 为 NULL，并获取下一个 tid</p>
<p>最后就是将 percpu slab 设为新获取的 slab 并跳转回 <code>load_freelist</code> 分配对象并返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">retry_load_slab:<br><br>	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>	<span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123;<br>		<span class="hljs-type">void</span> *flush_freelist = c-&gt;freelist;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">flush_slab</span> =</span> c-&gt;slab;<br><br>		c-&gt;slab = <span class="hljs-literal">NULL</span>;<br>		c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>		c-&gt;tid = next_tid(c-&gt;tid);<br><br>		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><br>		deactivate_slab(s, flush_slab, flush_freelist);<br><br>		stat(s, CPUSLAB_FLUSH);<br><br>		<span class="hljs-keyword">goto</span> retry_load_slab;<br>	&#125;<br>	c-&gt;slab = slab;<br><br>	<span class="hljs-keyword">goto</span> load_freelist;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此， slub 分配算法的核心逻辑分析结束</p>
<h2 id="二、kmalloc：-NUMA-NO-NODE-的通用上层分配接口"><a href="#二、kmalloc：-NUMA-NO-NODE-的通用上层分配接口" class="headerlink" title="二、kmalloc： NUMA_NO_NODE 的通用上层分配接口"></a>二、kmalloc： NUMA_NO_NODE 的通用上层分配接口</h2><p>我们日常生活中（？）最常用的其实还是 <code>kmalloc()</code>，其会根据分配的大小与标志位帮我们完成 <code>kmem_cache</code> 的选取并进行对象分配</p>
<p>函数整体逻辑比较简单：</p>
<ul>
<li>若分配的大小在编译期已知（<code>__builtin_constant_p()</code>）则判断大小：<ul>
<li>若大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 则使用 <code>kmalloc_large()</code> 进行分配</li>
<li>通过 <code>kmalloc_index()</code> 与 <code>kmalloc_type()</code> 获取 <code>kmalloc_caches</code> 中对应的数组下标并调用 <code>kmalloc_trace</code> 进行对象分配</li>
</ul>
</li>
<li>若大小是动态传入的，调用 <code>__kmalloc()</code> 进行分配</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kmalloc - 分配内核内存</span><br><span class="hljs-comment"> * @size: 需要的内存字节数.</span><br><span class="hljs-comment"> * @flags: 描述分配上下文</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * kmalloc 是内核中分配小于页面大小的内存对象的通用方法.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 被分配的对象地址至少要对齐到 ARCH_KMALLOC_MINALIGN 字节.</span><br><span class="hljs-comment"> * 对于 2^n 字节的 @size , 对齐也需要保证至少到该大小.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @flags argument 可能是 include/linux/gfp.h 中定义的GFP 标志位，描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 推荐的对 @flags 使用描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 以下为最常用的 GFP 标志位简要概述</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_KERNEL</span><br><span class="hljs-comment"> *	分配普通内核内存. 可能睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_NOWAIT</span><br><span class="hljs-comment"> *	分配将不会睡眠.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_ATOMIC</span><br><span class="hljs-comment"> *	分配将不会睡眠.  可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 也可以通过异或以下的一个或多个额外@flags来设置不同的标志位:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_ZERO</span><br><span class="hljs-comment"> *	在返回前清零分配的内存. 也可参见 kzalloc().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_HIGH</span><br><span class="hljs-comment"> *	这个分配有着高优先级且可能使用 emergency pools.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOFAIL</span><br><span class="hljs-comment"> *	表示此次分配不允许失败</span><br><span class="hljs-comment"> *	(在使用前再次思考).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NORETRY</span><br><span class="hljs-comment"> *	若内存不会马上可用,立即放弃.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOWARN</span><br><span class="hljs-comment"> *	若分配失败，不要提交警告.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_RETRY_MAYFAIL</span><br><span class="hljs-comment"> *	努力尝试使分配成功，但最终失败.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLOB</span><br><span class="hljs-type">static</span> __always_inline __alloc_size(<span class="hljs-number">1</span>) <span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;<br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br>		<span class="hljs-keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)<br>			<span class="hljs-keyword">return</span> kmalloc_large(size, flags);<br><br>		index = kmalloc_index(size);<br>		<span class="hljs-keyword">return</span> kmalloc_trace(<br>				kmalloc_caches[kmalloc_type(flags)][index],<br>				flags, size);<br>	&#125;<br>	<span class="hljs-keyword">return</span> __kmalloc(size, flags);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="I-kmalloc-large-：直接向-buddy-system-请求内存"><a href="#I-kmalloc-large-：直接向-buddy-system-请求内存" class="headerlink" title="I. kmalloc_large()：直接向 buddy system 请求内存"></a>I. kmalloc_large()：直接向 buddy system 请求内存</h3><p>对于请求大小大于 <code>KMALLOC_MAX_CACHE_SIZE</code> 的内存分配请求而言， <code>kmalloc()</code> 会直接调用 <code>kmalloc_large()</code> 完成内存分配，最后实际上会在 <code>__kmalloc_large_node()</code> 调用 <code>alloc_pages()</code> 向 buddy system 请求内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 为了避免不必要的开销,我们将大的分配请求直接传递给页面分配器.</span><br><span class="hljs-comment"> * 我们使用 __GFP_COMP, 因为我们需要知道分配的 order 以在 kfree 中恰当地释放.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__kmalloc_large_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br>	<span class="hljs-type">void</span> *ptr = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = get_order(size);<br><br>	<span class="hljs-keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))<br>		flags = kmalloc_fix_flags(flags);<br><br>	flags |= __GFP_COMP;<br>	page = alloc_pages_node(node, flags, order);<br>	<span class="hljs-keyword">if</span> (page) &#123;<br>		ptr = page_address(page);<br>		mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,<br>				      PAGE_SIZE &lt;&lt; order);<br>	&#125;<br><br>	ptr = kasan_kmalloc_large(ptr, size, flags);<br>	<span class="hljs-comment">/* As ptr might get tagged, call kmemleak hook after KASAN. */</span><br>	kmemleak_alloc(ptr, size, <span class="hljs-number">1</span>, flags);<br>	kmsan_kmalloc_large(ptr, size, flags);<br><br>	<span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_large</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br>	<span class="hljs-type">void</span> *ret = __kmalloc_large_node(size, flags, NUMA_NO_NODE);<br><br>	trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),<br>		      flags, NUMA_NO_NODE);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_large);<br></code></pre></td></tr></table></figure>



<h3 id="II-kmalloc-index-：获取size对应下标"><a href="#II-kmalloc-index-：获取size对应下标" class="headerlink" title="II. __kmalloc_index()：获取size对应下标"></a>II. __kmalloc_index()：获取size对应下标</h3><p><code>kmalloc_index()</code> 其实就是 <code>__kmalloc_index（）</code>，根据请求的大小返回对应的下标，整体逻辑非常简单粗暴：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 算出一个特定大小的分配属于哪个 kmalloc slab .</span><br><span class="hljs-comment"> * 0 = zero alloc</span><br><span class="hljs-comment"> * 1 =  65 .. 96 bytes</span><br><span class="hljs-comment"> * 2 = 129 .. 192 bytes</span><br><span class="hljs-comment"> * n = 2^(n-1)+1 .. 2^n</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注意: __kmalloc_index() 在编译期优化, 没有运行时优化;</span><br><span class="hljs-comment"> * 典型的用法为通过 kmalloc_index() 以在编译期优化.</span><br><span class="hljs-comment"> * 大小非常量的调用者仅应当为__kmalloc_index()的运行时开销可以被接受的测试模块.</span><br><span class="hljs-comment"> * 同样参见 kmalloc_slab().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __kmalloc_index(<span class="hljs-type">size_t</span> size,<br>						    <span class="hljs-type">bool</span> size_is_constant)<br>&#123;<br>	<span class="hljs-keyword">if</span> (!size)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)<br>		<span class="hljs-keyword">return</span> KMALLOC_SHIFT_LOW;<br><br>	<span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">32</span> &amp;&amp; size &gt; <span class="hljs-number">64</span> &amp;&amp; size &lt;= <span class="hljs-number">96</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">64</span> &amp;&amp; size &gt; <span class="hljs-number">128</span> &amp;&amp; size &lt;= <span class="hljs-number">192</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=          <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">16</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">32</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">64</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">128</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">256</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">512</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=       <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">2</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">13</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">14</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">16</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">256</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">19</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br>	<span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">21</span>;<br><br>	<span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)<br>		BUILD_BUG_ON_MSG(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;unexpected size in kmalloc_index()&quot;</span>);<br>	<span class="hljs-keyword">else</span><br>		BUG();<br><br>	<span class="hljs-comment">/* Will never be reached. Needed because the compiler may complain */</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="III-kmalloc-types-：获取标志位对应类型"><a href="#III-kmalloc-types-：获取标志位对应类型" class="headerlink" title="III. kmalloc_types()：获取标志位对应类型"></a>III. kmalloc_types()：获取标志位对应类型</h3><p><code>kmalloc_type()</code> 其实主要就是根据标志位返回类型，除了指定了 <code>__GFP_DMA/__GFP_RECLAIMABLE/__GFP_ACCOUNT</code> 以外就都是 <code>KMALLOC_NORMAL</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-keyword">enum</span> kmalloc_cache_type <span class="hljs-title function_">kmalloc_type</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 最常规的情况为 KMALLOC_NORMAL, 所以用一个单独的分支测试所有相关的标志位.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (likely((flags &amp; KMALLOC_NOT_NORMAL_BITS) == <span class="hljs-number">0</span>))<br>		<span class="hljs-keyword">return</span> KMALLOC_NORMAL;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 至少需要设置一种标志位. 优先顺序为:</span><br><span class="hljs-comment">	 *  1) __GFP_DMA</span><br><span class="hljs-comment">	 *  2) __GFP_RECLAIMABLE</span><br><span class="hljs-comment">	 *  3) __GFP_ACCOUNT</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (flags &amp; __GFP_DMA))<br>		<span class="hljs-keyword">return</span> KMALLOC_DMA;<br>	<span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags &amp; __GFP_RECLAIMABLE))<br>		<span class="hljs-keyword">return</span> KMALLOC_RECLAIM;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> KMALLOC_CGROUP;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="IV-kmalloc-trace-：常规大小的-NUMA-NO-NODE-对象分配"><a href="#IV-kmalloc-trace-：常规大小的-NUMA-NO-NODE-对象分配" class="headerlink" title="IV. kmalloc_trace()：常规大小的 NUMA_NO_NODE 对象分配"></a>IV. kmalloc_trace()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>kmalloc_trace()</code> 主要是对 <code>__kmem_cache_alloc_node()</code> 的 wrapper，加上 tracepoint 和 kasan 的相关设置，需要注意的是这里会指定 node 为 <code>NUMA_NO_NODE</code>：</p>
<blockquote>
<p>不知道什么是 kernel trace point 的可以参见 <a target="_blank" rel="noopener" href="https://docs.kernel.org/trace/tracepoints.html">这里</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_trace</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>	<span class="hljs-type">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,<br>					    size, _RET_IP_);<br><br>	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);<br><br>	ret = kasan_kmalloc(s, ret, size, gfpflags);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(kmalloc_trace);<br></code></pre></td></tr></table></figure>

<p><code>__kmem_cache_alloc_node()</code> 其实就是 <code>slab_alloc_node()</code> 的 wrapper：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmem_cache_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags,<br>			      <span class="hljs-type">int</span> node, <span class="hljs-type">size_t</span> orig_size,<br>			      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br>	<span class="hljs-keyword">return</span> slab_alloc_node(s, <span class="hljs-literal">NULL</span>, gfpflags, node,<br>			       caller, orig_size);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="V-kmalloc-：常规大小的-NUMA-NO-NODE-对象分配"><a href="#V-kmalloc-：常规大小的-NUMA-NO-NODE-对象分配" class="headerlink" title="V. __kmalloc()：常规大小的 NUMA_NO_NODE 对象分配"></a>V. __kmalloc()：常规大小的 NUMA_NO_NODE 对象分配</h3><p><code>__kmalloc()</code> 其实就是指定 node 为 <code> NUMA_NO_NODE</code> 的 <code>__do_kmalloc_node()</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmalloc(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)<br>&#123;<br>	<span class="hljs-keyword">return</span> __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(__kmalloc);<br></code></pre></td></tr></table></figure>

<h3 id="VI-do-kmalloc-node-：判断所需-kmem-cache-并进行对象分配"><a href="#VI-do-kmalloc-node-：判断所需-kmem-cache-并进行对象分配" class="headerlink" title="VI. __do_kmalloc_node()：判断所需 kmem_cache 并进行对象分配"></a>VI. __do_kmalloc_node()：判断所需 kmem_cache 并进行对象分配</h3><p>该函数的主要逻辑为：</p>
<ul>
<li>若 <code>size &gt; KMALLOC_MAX_CACHE_SIZE</code> ，则调用 <code>__kmalloc_large_node()</code> 进行分配，并进行 tracepoint 与 kasan 相关设置</li>
<li>对于常规 size：<ul>
<li>首先调用 <code>kmalloc_slab()</code> 获取对应的 <code>kmem_cache</code></li>
<li>接下来调用 <code>__kmem_cache_alloc_node()</code> 进行内存分配</li>
<li>最后进行 tracepoint 与 kasan 相关设置</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline<br><span class="hljs-type">void</span> *__do_kmalloc_node(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br>	<span class="hljs-type">void</span> *ret;<br><br>	<span class="hljs-keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;<br>		ret = __kmalloc_large_node(size, flags, node);<br>		trace_kmalloc(caller, ret, size,<br>			      PAGE_SIZE &lt;&lt; get_order(size), flags, node);<br>		<span class="hljs-keyword">return</span> ret;<br>	&#125;<br><br>	s = kmalloc_slab(size, flags);<br><br>	<span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))<br>		<span class="hljs-keyword">return</span> s;<br><br>	ret = __kmem_cache_alloc_node(s, flags, node, size, caller);<br>	ret = kasan_kmalloc(s, ret, size, flags);<br>	trace_kmalloc(caller, ret, size, s-&gt;size, flags, node);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>kmalloc_slab()</code> 中寻找 <code>kmem_cache</code> 的过程和 kmalloc 类似，不过寻找下标用的是 <code>size_index[size_index_elem(size)]</code> 和 <code>fls()</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 寻找满足给定大小的分配的 kmem_cache 结构体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> kmem_cache *<span class="hljs-title function_">kmalloc_slab</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br>	<span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">192</span>) &#123;<br>		<span class="hljs-keyword">if</span> (!size)<br>			<span class="hljs-keyword">return</span> ZERO_SIZE_PTR;<br><br>		index = size_index[size_index_elem(size)];<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>		index = fls(size - <span class="hljs-number">1</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> kmalloc_caches[kmalloc_type(flags)][index];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>size_index</code> 和 <code>size_index_elem()</code> 的定义都非常简单粗暴：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Conversion table for small slabs sizes / 8 to the index in the</span><br><span class="hljs-comment"> * kmalloc array. This is necessary for slabs &lt; 192 since we have non power</span><br><span class="hljs-comment"> * of two cache sizes there. The size of larger slabs can be determined using</span><br><span class="hljs-comment"> * fls.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> u8 size_index[<span class="hljs-number">24</span>] __ro_after_init = &#123;<br>	<span class="hljs-number">3</span>,	<span class="hljs-comment">/* 8 */</span><br>	<span class="hljs-number">4</span>,	<span class="hljs-comment">/* 16 */</span><br>	<span class="hljs-number">5</span>,	<span class="hljs-comment">/* 24 */</span><br>	<span class="hljs-number">5</span>,	<span class="hljs-comment">/* 32 */</span><br>	<span class="hljs-number">6</span>,	<span class="hljs-comment">/* 40 */</span><br>	<span class="hljs-number">6</span>,	<span class="hljs-comment">/* 48 */</span><br>	<span class="hljs-number">6</span>,	<span class="hljs-comment">/* 56 */</span><br>	<span class="hljs-number">6</span>,	<span class="hljs-comment">/* 64 */</span><br>	<span class="hljs-number">1</span>,	<span class="hljs-comment">/* 72 */</span><br>	<span class="hljs-number">1</span>,	<span class="hljs-comment">/* 80 */</span><br>	<span class="hljs-number">1</span>,	<span class="hljs-comment">/* 88 */</span><br>	<span class="hljs-number">1</span>,	<span class="hljs-comment">/* 96 */</span><br>	<span class="hljs-number">7</span>,	<span class="hljs-comment">/* 104 */</span><br>	<span class="hljs-number">7</span>,	<span class="hljs-comment">/* 112 */</span><br>	<span class="hljs-number">7</span>,	<span class="hljs-comment">/* 120 */</span><br>	<span class="hljs-number">7</span>,	<span class="hljs-comment">/* 128 */</span><br>	<span class="hljs-number">2</span>,	<span class="hljs-comment">/* 136 */</span><br>	<span class="hljs-number">2</span>,	<span class="hljs-comment">/* 144 */</span><br>	<span class="hljs-number">2</span>,	<span class="hljs-comment">/* 152 */</span><br>	<span class="hljs-number">2</span>,	<span class="hljs-comment">/* 160 */</span><br>	<span class="hljs-number">2</span>,	<span class="hljs-comment">/* 168 */</span><br>	<span class="hljs-number">2</span>,	<span class="hljs-comment">/* 176 */</span><br>	<span class="hljs-number">2</span>,	<span class="hljs-comment">/* 184 */</span><br>	<span class="hljs-number">2</span>	<span class="hljs-comment">/* 192 */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size_index_elem</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bytes)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> (bytes - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="三、上层调用接口关系图"><a href="#三、上层调用接口关系图" class="headerlink" title="三、上层调用接口关系图"></a>三、上层调用接口关系图</h2><p>因为很多比如说 <code>__kmem_cache_alloc_lru()</code> 一类的函数其实最后都是对 <code>slab_alloc_node()</code> 的套娃，这里笔者直接给出一个简易的调用关系图：</p>
<blockquote>
<p>只截取了笔者认为比较主要的那些，<del>因为作图作到后面实在蚌埠住了</del></p>
</blockquote>
<p><img src="https://s2.loli.net/2023/02/22/wCchFdIZLOn3m7W.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="0x03-对象的释放"><a href="#0x03-对象的释放" class="headerlink" title="0x03. 对象的释放"></a>0x03. 对象的释放</h1><h2 id="※-一、do-slab-free-：向指定的-kmem-cache-释放对象（链）"><a href="#※-一、do-slab-free-：向指定的-kmem-cache-释放对象（链）" class="headerlink" title="※ 一、do_slab_free()：向指定的 kmem_cache 释放对象（链）"></a>※ 一、do_slab_free()：向指定的 kmem_cache 释放对象（链）</h2><p>在 slab allocator 中存在着多个不同的内存释放接口，其最后都会调用到 <code>do_slab_free()</code> 完成内存释放的工作，需要注意的是该函数  <em><strong>允许释放已经连接成一条 freelist 且已经加密好的多个对象</strong></em>  ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 强制内联快速路径以创造无需额外的函数调用便能完成快速路径释放的kfree&amp;kmem_cache_free.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 快速路径仅在我们要释放会当前 cpu slab 时生效.</span><br><span class="hljs-comment"> * 这通常是在我们刚刚分配了该对象的情况.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若快速路径不可用则退回 __slab_free 以处理所有种类的特殊处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过指定 head &amp; tail 指针 加上对象数量（cnt），可以大量释放包含多个对象的freelist.</span><br><span class="hljs-comment"> * Bulk free indicated by tail pointer being set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">do_slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params">				<span class="hljs-keyword">struct</span> slab *slab, <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail,</span><br><span class="hljs-params">				<span class="hljs-type">int</span> cnt, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br>	<span class="hljs-type">void</span> *tail_obj = tail ? : head;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br>	<span class="hljs-type">void</span> **freelist;<br></code></pre></td></tr></table></figure>

<p>与分配类似，释放同样分为快速路径与慢速路径</p>
<h3 id="I-直接释放回-percpu-slab（fast-path）"><a href="#I-直接释放回-percpu-slab（fast-path）" class="headerlink" title="I. 直接释放回 percpu slab（fast path）"></a>I. 直接释放回 percpu slab（fast path）</h3><p>快速路径比较简单，主要就是<strong>对比待释放对象所属 slab 是否为 percpu slab，若是则直接挂回去即可，遵循 LIFO 机制</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c">redo:<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 确定当前的 per cpu slab. </span><br><span class="hljs-comment">	 * cpu 可能在之后改变.但由于数据已经通过该指针获得，这并没问题.</span><br><span class="hljs-comment">	 * 若我们在 cmpxchg 期间在同一 cpu 上，释放将会成功.</span><br><span class="hljs-comment">	 */</span><br>	c = raw_cpu_ptr(s-&gt;cpu_slab);<br>	tid = READ_ONCE(c-&gt;tid);<br><br>	<span class="hljs-comment">/* 与 slab_alloc_node() 中在 barrier() 上的注释一样 */</span><br>	barrier();<br><br>	<span class="hljs-comment">// 不属于 percpu slab，调用 __slab_free() 进行释放</span><br>	<span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>		__slab_free(s, slab, head, tail_obj, cnt, addr);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123;<br>		freelist = READ_ONCE(c-&gt;freelist);<br><br>		<span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>		set_freepointer(s, tail_obj, freelist);<br><br>		<span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>				s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>				freelist, tid,<br>				head, next_tid(tid)))) &#123;<br><br>			note_cmpxchg_failure(<span class="hljs-string">&quot;slab_free&quot;</span>, s, tid);<br>			<span class="hljs-keyword">goto</span> redo;<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">/* Update the free list under the local lock */</span><br>		local_lock(&amp;s-&gt;cpu_slab-&gt;lock);<br>		c = this_cpu_ptr(s-&gt;cpu_slab);<br>		<span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>			local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br>			<span class="hljs-keyword">goto</span> redo;<br>		&#125;<br>		tid = c-&gt;tid;<br>		freelist = c-&gt;freelist;<br><br>		<span class="hljs-comment">// 直接将 percpu freelist 接到 tail_obj 后面</span><br>		set_freepointer(s, tail_obj, freelist);<br>		c-&gt;freelist = head;<br>		c-&gt;tid = next_tid(tid);<br><br>		local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br>	&#125;<br>	stat(s, FREE_FASTPATH);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="II-slab-free-：释放回对应的-slab（slow-path）"><a href="#II-slab-free-：释放回对应的-slab（slow-path）" class="headerlink" title="II. __slab_free()：释放回对应的 slab（slow path）"></a>II. __slab_free()：释放回对应的 slab（slow path）</h3><p>如果待释放对象不属于 percpu clab，则调用 <code>__slab_free()</code> 进行释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 处理慢速路径. 这可能会被频繁调用因为在大部分情况下对象比cpu slab生命周期更长</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所以我们仍尝试减少缓存行的使用率. 拿取 slab lock 并释放对象即可.</span><br><span class="hljs-comment"> * 若不需要额外的 partial slab handling 我们便可立即返回.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __slab_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,<br>			<span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">int</span> cnt,<br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)<br><br>&#123;<br>	<span class="hljs-type">void</span> *prior;<br>	<span class="hljs-type">int</span> was_frozen;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>	stat(s, FREE_SLOWPATH);<br></code></pre></td></tr></table></figure>

<p>首先还是 kfence 和 debug 相关，如果该 <code>kmem_cache</code> 设置了 <code>SLAB_DEBUG_FLAGS</code> 标志位则直接调用 <code>free_to_partial_list()</code> 后返回即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (kfence_free(head))<br>	<span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;<br>	free_to_partial_list(s, slab, head, tail, cnt, addr);<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之后是一个 <code>do while</code> 循环，首先会将 <strong><code>待释放 freelist 所属 slab 的 freelist</code></strong> 连接到 <strong><code>待释放 freelist 的 tail object</code></strong> 后边，这里的 <code>new</code> 是一个栈上的临时 slab 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>	<span class="hljs-keyword">if</span> (unlikely(n)) &#123;<br>		spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>		n = <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	prior = slab-&gt;freelist;<br>	counters = slab-&gt;counters;<br>	set_freepointer(s, tail, prior);<br>	new.counters = counters;<br>	was_frozen = new.frozen;<br>	new.inuse -= cnt;<br></code></pre></td></tr></table></figure>

<p>接下来检查是否  <strong><code>(所有的对象都*将*为空闲对象 || 原 slab 上无空闲对象) &amp;&amp; slab 未被冻结</code></strong> ，若满足该条件则：</p>
<ul>
<li>检查是否有 percpu partial slab 且原 slab 上无空闲对象（即 slab-&gt;freelist（也就是代码中的 <code>prior</code>）为 NULL）：<ul>
<li>若是，则设置 slab 将被冻结（<code>new.frozen=1</code>）</li>
<li>若否，则获取 slab 所对应的 <code>kmem_cache_node</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;<br><br>	<span class="hljs-keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Slab 之前不在链表上且将会部分为空</span><br><span class="hljs-comment">		 * 我们可以推迟链表移动，而是反之将其冻结.</span><br><span class="hljs-comment">		 */</span><br>		new.frozen = <span class="hljs-number">1</span>;<br><br>	&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 需要从一个链表上取下 */</span><br><br>		n = get_node(s, slab_nid(slab));<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 推测性地获取 list_lock.</span><br><span class="hljs-comment">		 * 若 cmpxchg 未成功，则我们可能</span><br><span class="hljs-comment">		 * 在不进行任何处理的情况下放弃 list_lock.</span><br><span class="hljs-comment">		 *</span><br><span class="hljs-comment">		 * 否则 list_lock 将与其他处理器同步更新 slabs 链表</span><br><span class="hljs-comment">		 */</span><br>		spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>循环的终止条件用了一个 <code>cmpxchg_double_slab()</code> 函数，<del>套娃套得👴头昏眼花</del>，主要逻辑为：</p>
<ul>
<li><strong>对比 slab-&gt;freelist &#x3D;&#x3D; prior &amp;&amp; slab-&gt;counters &#x3D;&#x3D; counters，若是，则将 slab-&gt;freelist 设为 head 且将 slab-&gt;counters 设为 new.counters</strong>，该操作成功则返回 true，条件不符则返回 false</li>
</ul>
<p>成功了循环将会直接跳出：）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">while</span> (!cmpxchg_double_slab(s, slab,<br>	prior, counters,<br>	head, new.counters,<br>	<span class="hljs-string">&quot;__slab_free&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>接下来检查<strong>该 slab 是否需要从一个 <code>kmem_cache_node</code> 的链表上取下，若否，</strong>则：</p>
<ul>
<li>若 slab 已经被冻结，stat() 一下（基本上等于啥都不做）</li>
<li>若 slab 需要被冻结 （<code>new.frozen</code> 为 true），调用 <code>put_cpu_partial()</code> 直接将 slab 放到 percpu partial 链表</li>
<li>释放工作完成，返回</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (likely(!n)) &#123;<br><br>	<span class="hljs-keyword">if</span> (likely(was_frozen)) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * 链表锁未被占用，因此不需要活跃任何链表.</span><br><span class="hljs-comment">		 */</span><br>		stat(s, FREE_FROZEN);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.frozen) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * If we just froze the slab then put it onto the</span><br><span class="hljs-comment">		 * per cpu partial list.</span><br><span class="hljs-comment">		 */</span><br>		put_cpu_partial(s, slab, <span class="hljs-number">1</span>);<br>		stat(s, CPU_PARTIAL_FREE);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 slab 上所有对象都被释放，且 node 上的 partial slab 数量已经超过 <code>kmem_cache-&gt;min_partial</code> ，<strong>这意味着这是一张完全空闲的 slab</strong>，接下来跳转到 <code>slab_empty</code> 标签，该标签对应代码块主要是：</p>
<ul>
<li>若 slab 上原来有空闲对象（位于 node partial 链表），则从 partial 链表移除</li>
<li>若 slab 上原来无空闲对象（位于 node full 链表），则从 full 链表移除</li>
<li><strong>最后调用 <code>discard_slab()</code> 释放这一张 slab</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">	<span class="hljs-keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))<br>		<span class="hljs-keyword">goto</span> slab_empty;<br><br>	<span class="hljs-comment">//...</span><br><br>slab_empty:<br>	<span class="hljs-keyword">if</span> (prior) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Slab on the partial list.</span><br><span class="hljs-comment">		 */</span><br>		remove_partial(n, slab);<br>		stat(s, FREE_REMOVE_PARTIAL);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">/* Slab must be on the full list */</span><br>		remove_full(s, n, slab);<br>	&#125;<br><br>	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>	stat(s, FREE_SLAB);<br>	discard_slab(s, slab);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>若不满足上面的条件，则检查是否没有 percpu partial slab 且 slab 上原 freelist 为 NULL（即位于 node full 链表），若是则从 full 链表移除并添加到 node partial 链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Objects left in the slab. If it was not on the partial list before</span><br><span class="hljs-comment"> * then add it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;<br>	remove_full(s, n, slab);<br>	add_partial(n, slab, DEACTIVATE_TO_TAIL);<br>	stat(s, FREE_ADD_PARTIAL);<br>&#125;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure>

<p>至此， slub 算法的释放逻辑分析完毕</p>
<h2 id="二、kfree：通用的上层释放接口"><a href="#二、kfree：通用的上层释放接口" class="headerlink" title="二、kfree：通用的上层释放接口"></a>二、kfree：通用的上层释放接口</h2><p>正如同 <code>kmalloc()</code> 是最为通用的内核对象分配函数，与之相对应的释放函数便是 <code>kfree()</code> 了，这个函数其实主要就是 <code>__kmem_cache_free()</code> 的 wrapper，对于较大的对象则会用 <code>free_large_kmalloc()</code> 进行释放，如果 object 为 NULL 则直接返回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kfree - 释放之前分配的对象</span><br><span class="hljs-comment"> * @object: kmalloc 返回的指针.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 若 @object 为 NULL, 则不会进行任何操作.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 不要释放不由 kmalloc() 分配的内存，否则会出问题.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *object)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">folio</span> *<span class="hljs-title">folio</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><br>	trace_kfree(_RET_IP_, object);<br><br>	<span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))<br>		<span class="hljs-keyword">return</span>;<br><br>	folio = virt_to_folio(object);<br>	<span class="hljs-keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;<br>		free_large_kmalloc(folio, (<span class="hljs-type">void</span> *)object);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	slab = folio_slab(folio);<br>	s = slab-&gt;slab_cache;<br>	__kmem_cache_free(s, (<span class="hljs-type">void</span> *)object, _RET_IP_);<br>&#125;<br>EXPORT_SYMBOL(kfree);<br></code></pre></td></tr></table></figure>

<h3 id="I-folio-结构：一段物理、虚拟、逻辑上都连续的内存"><a href="#I-folio-结构：一段物理、虚拟、逻辑上都连续的内存" class="headerlink" title="I. folio 结构：一段物理、虚拟、逻辑上都连续的内存"></a>I. folio 结构：一段物理、虚拟、逻辑上都连续的内存</h3><p>注意到这里用了一个名为 <code>folio</code> 的结构体，其表示了<strong>一块物理、虚拟、逻辑上都连续的内存</strong>，  <em>其实本质上还是复用了 page 结构体，只不过这一次是将 page 转为 folio</em>  ，定义比较长这里就不贴代码了</p>
<p><code>virt_to_folio()</code> 首先会用 <code>virt_to_page()</code> 找到待释放对象虚拟地址对应的 <code>page</code> 结构体，之后用 <code>page_folio()</code> 将其转换为 folio 结构体——其实就是对于复合页而言会找到第一张页面，由此如果是复合页的话那说明是大 slab 所以会调用 <code>free_large_kmalloc()</code>，不是复合页说明是小 slab 所以会调用 <code>__kmem_cache_free()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> folio *<span class="hljs-title function_">virt_to_folio</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *x)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> virt_to_page(x);<br><br>	<span class="hljs-keyword">return</span> page_folio(page);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> page_folio(p)		(_Generic((p),				\</span><br><span class="hljs-meta">	const struct page *:	(const struct folio *)_compound_head(p), \</span><br><span class="hljs-meta">	struct page *:		(struct folio *)_compound_head(p)))</span><br></code></pre></td></tr></table></figure>

<p>然后 <code>folio_test_slab()</code> 其实是 <code>include/linux/page-flags.h</code> 里的拼接宏，这里就不深入展开了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">bool</span> folio_test_#<span class="hljs-meta">#lname(struct folio *folio)	\</span><br><span class="hljs-meta">&#123; return test_bit(PG_##lname, folio_flags(folio, FOLIO_##policy)); &#125;	\</span><br></code></pre></td></tr></table></figure>

<h3 id="II-free-large-kmalloc-：直接将页面释放回-buddy-system"><a href="#II-free-large-kmalloc-：直接将页面释放回-buddy-system" class="headerlink" title="II. free_large_kmalloc()：直接将页面释放回 buddy system"></a>II. free_large_kmalloc()：直接将页面释放回 buddy system</h3><p>正如对于大对象的分配 <code>kmalloc_large()</code> 会直接从 buddy system 请求内存一般，相对应的 <code>free_large_kmalloc()</code> 也会直接将页面释放回 buddy system：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_large_kmalloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> folio *folio, <span class="hljs-type">void</span> *object)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = folio_order(folio);<br><br>	<span class="hljs-keyword">if</span> (WARN_ON_ONCE(order == <span class="hljs-number">0</span>))<br>		pr_warn_once(<span class="hljs-string">&quot;object pointer: 0x%p\n&quot;</span>, object);<br><br>	kmemleak_free(object);<br>	kasan_kfree_large(object);<br>	kmsan_kfree_large(object);<br><br>	mod_lruvec_page_state(folio_page(folio, <span class="hljs-number">0</span>), NR_SLAB_UNRECLAIMABLE_B,<br>			      -(PAGE_SIZE &lt;&lt; order));<br>	__free_pages(folio_page(folio, <span class="hljs-number">0</span>), order);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="III-kmem-cache-free-：常规的释放函数"><a href="#III-kmem-cache-free-：常规的释放函数" class="headerlink" title="III. __kmem_cache_free()：常规的释放函数"></a>III. __kmem_cache_free()：常规的释放函数</h3><p><code>__kmem_cache_free()</code> 主要就是对 <code>slab_free()</code> 的 wrapper，不过会指定 tail 为 NULL：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __kmem_cache_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *x, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br>	slab_free(s, virt_to_slab(x), x, <span class="hljs-literal">NULL</span>, &amp;x, <span class="hljs-number">1</span>, caller);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而 <code>slab_free()</code> 则会最终调用到 <code>do_slab_free()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> <span class="hljs-title function_">slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">				      <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">void</span> **p, <span class="hljs-type">int</span> cnt,</span><br><span class="hljs-params">				      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br>	memcg_slab_free_hook(s, slab, p, cnt);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * With KASAN enabled slab_free_freelist_hook modifies the freelist</span><br><span class="hljs-comment">	 * to remove objects, whose reuse must be delayed.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))<br>		do_slab_free(s, slab, head, tail, cnt, addr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里用到了一个函数 <code>slab_free_freelist_hook()</code>，主要的作用是遍历待释放的 freelist：</p>
<ul>
<li>如果设置了 free hook（ <code>slab_free_hook() == true</code> ），则仅减少计数以推迟释放</li>
<li>否则重新建立一遍 freelist 后返回</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">slab_free_freelist_hook</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params">					   <span class="hljs-type">void</span> **head, <span class="hljs-type">void</span> **tail,</span><br><span class="hljs-params">					   <span class="hljs-type">int</span> *cnt)</span><br>&#123;<br><br>	<span class="hljs-type">void</span> *object;<br>	<span class="hljs-type">void</span> *next = *head;<br>	<span class="hljs-type">void</span> *old_tail = *tail ? *tail : *head;<br><br>	<span class="hljs-keyword">if</span> (is_kfence_address(next)) &#123;<br>		slab_free_hook(s, next, <span class="hljs-literal">false</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br><br>	<span class="hljs-comment">/* Head and tail of the reconstructed freelist */</span><br>	*head = <span class="hljs-literal">NULL</span>;<br>	*tail = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-keyword">do</span> &#123;<br>		object = next;<br>		next = get_freepointer(s, object);<br><br>		<span class="hljs-comment">/* If object&#x27;s reuse doesn&#x27;t have to be delayed */</span><br>		<span class="hljs-keyword">if</span> (!slab_free_hook(s, object, slab_want_init_on_free(s))) &#123;<br>			<span class="hljs-comment">/* Move object to the new freelist */</span><br>			set_freepointer(s, object, *head);<br>			*head = object;<br>			<span class="hljs-keyword">if</span> (!*tail)<br>				*tail = object;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * Adjust the reconstructed freelist depth</span><br><span class="hljs-comment">			 * accordingly if object&#x27;s reuse is delayed.</span><br><span class="hljs-comment">			 */</span><br>			--(*cnt);<br>		&#125;<br>	&#125; <span class="hljs-keyword">while</span> (object != old_tail);<br><br>	<span class="hljs-keyword">if</span> (*head == *tail)<br>		*tail = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-keyword">return</span> *head != <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="三、上层调用接口关系图-1"><a href="#三、上层调用接口关系图-1" class="headerlink" title="三、上层调用接口关系图"></a>三、上层调用接口关系图</h2><p>涉及到内存释放的函数相较于内存分配其实少很多，常用的主要就是 <code>kfree()</code>、<code>kfree_sensitive()</code>、<code>kmem_cache_free()</code> 这三大函数：</p>
<p><img src="https://s2.loli.net/2023/02/24/Itbqo2eO15yn7ZW.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OS/" class="category-chain-item">OS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Linux/">#Linux</a>
      
        <a href="/tags/Linux-Kernel/">#Linux Kernel</a>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/">#学习札记</a>
      
        <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">#内存管理</a>
      
        <a href="/tags/slub-allocator/">#slub allocator</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator</div>
      <div>https://arttnba3.github.io/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月24日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/" title="【FUZZ.0x02】syzkaller - II：syz-manager源码分析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【FUZZ.0x02】syzkaller - II：syz-manager源码分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/29/PAPER-0X01-HUNTING_THE_HAUNTER-EFFICIENT_RELATIONAL_SYMBOLIC_EXECUTION_FOR_SPECTRE_WITH_HAUNTED_RELSE/" title="【PAPER.0x01】论文笔记：Hunting the Haunter — Efficient Relational Symbolic Execution for Spectre with Haunted RelSE ">
                        <span class="hidden-mobile">【PAPER.0x01】论文笔记：Hunting the Haunter — Efficient Relational Symbolic Execution for Spectre with Haunted RelSE </span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
