

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="BEE BEE I’M A SHEEP">
<meta property="og:type" content="article">
<meta property="og:title" content="【EBPF.0x00】eBPF 入门指北（一）：简介">
<meta property="og:url" content="https://arttnba3.github.io/2023/05/31/EBPF_0X00/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="BEE BEE I’M A SHEEP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/05/31/U695RNuab3EwL1l.png">
<meta property="article:published_time" content="2023-05-30T19:46:24.000Z">
<meta property="article:modified_time" content="2023-08-13T08:31:06.000Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="eBPF">
<meta property="article:tag" content="Linux kernel">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2023/05/31/U695RNuab3EwL1l.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【EBPF.0x00】eBPF 入门指北（一）：简介 - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"arttnba3.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s2.loli.net/2022/07/21/Cpf7VY9z5lsG2u3.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【EBPF.0x00】eBPF 入门指北（一）：简介"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-31 05:46" pubdate>
          2023年5月31日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          300 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【EBPF.0x00】eBPF 入门指北（一）：简介</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年8月13日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>BEE BEE I’M A SHEEP</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><blockquote>
<p>因为最近毕设搞得有点头大（←因为这个人各种摸鱼导致进度差的太多然后最后几天疯狂各种赶工），所以看点和毕设无关的东西（这样毕设不是更加做不完了嘛（悲）</p>
</blockquote>
<p>笔者一直想着有机会深入学习一下 eBPF 相关的东西，可惜总是习惯性一头扎进源码各种繁杂的细节当中迷失自己然后放弃（悲）</p>
<p><del>于是趁现在有时间（？）</del> 虽然现在没什么时间，笔者还是想给这玩意先开个头写第一篇博客，毕竟只要开了一个头之后后面的事情也就会简单得多了吧（大嘘）</p>
<h2 id="What-is-eBPF"><a href="#What-is-eBPF" class="headerlink" title="What is eBPF?"></a>What is eBPF?</h2><p><strong>伯克利包过滤器</strong>（Berkeley Packet Filter）是一个 Linux kernel 中用以对来自于链路层的数据包进行过滤的架构，其位于内核中的架构如下图所示：</p>
<p><img src="https://s2.loli.net/2022/07/21/Cpf7VY9z5lsG2u3.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>相比起传统的数据包过滤器而言，BPF <strong>在内核中</strong>实现了一个新的<strong>虚拟机</strong>设计，通过<strong>即时编译</strong>（Just-In-Time compilation）技术将 BPF 指令翻译为 BPF 虚拟机的字节码，可以高效地工作在基于寄存器结构的 CPU 上</p>
<p>Linux kernel 自 3.18 版本起提供了<strong>扩展伯克利包过滤器</strong>（<strong>e</strong>xtended <strong>BPF</strong>，即 <code>eBPF</code>），其应用范围更广，能够被应用于更多的场景，原来的 BPF 被称为 <strong>c</strong>lassic <strong>BPF</strong>（cBPF），且目前基本上已经被废弃，Linux 会将 cBPF 字节码转化为 eBPF 字节码再执行</p>
<p>作为一个<strong>位于内核层面的虚拟机</strong>，eBPF 无疑为攻击者提供了一个相当大的新攻击面，因此也成为近几年内核利用中的“大热门”，本篇博客中笔者将简述 eBPF 的基本原理</p>
<blockquote>
<p>本篇文章中涉及到的 Linux kernel 源码来自版本 6.3.2</p>
</blockquote>
<h1 id="0x01-eBPF-的基本架构"><a href="#0x01-eBPF-的基本架构" class="headerlink" title="0x01.eBPF 的基本架构"></a>0x01.eBPF 的基本架构</h1><h2 id="一、eBPF-的运行过程"><a href="#一、eBPF-的运行过程" class="headerlink" title="一、eBPF 的运行过程"></a>一、eBPF 的运行过程</h2><p>Linux 下 eBPF 的整体架构如下图所示：</p>
<p><img src="https://s2.loli.net/2022/03/20/HfExF3JwKX9nOvi.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>用户进程首先在用户空间编写相应的 BPF 字节码程序，传入内核</li>
<li>内核通过 <code>verifier</code> 对字节码程序进行安全性检查，通过检查后便通过 JIT 编译运行，eBPF 程序主要分为如下类型：<ul>
<li><code>kprobes</code> ：内核中的动态跟踪，可以跟踪至内核中的函数入口或返回点</li>
<li><code>uprobes</code> ：用户空间中的动态跟踪，与 kprobes 不同的是跟踪的函数位于用户程序中</li>
<li><code>tracepoints</code> ：内核中的静态跟踪</li>
<li><code>perf_events</code> ：定时采样与 PMC</li>
</ul>
</li>
<li>映射（map）作为用以保存数据的通用结构，可以在不同的 eBPF 程序之间或是用户进程与内核间共享数据</li>
</ul>
<blockquote>
<p>不同版本的 eBPF 所支持的功能是不同的，参见<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">这↑里↓</a></p>
<table>
<thead>
<tr>
<th>version</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>4.1</td>
<td>kprobe support</td>
</tr>
<tr>
<td>4.4</td>
<td>Perf events</td>
</tr>
<tr>
<td>4.7</td>
<td>Tracepoints support</td>
</tr>
<tr>
<td>4.8</td>
<td>XDP core</td>
</tr>
<tr>
<td>4.10</td>
<td>cgroups support</td>
</tr>
</tbody></table>
</blockquote>
<p>一个 eBPF 程序可以被挂载到多个事件上，不同的 eBPF 程序之间可以共享同一个映射</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">tracing     tracing    tracing    packet      packet     packet<br>event A     event B    event C    on eth0     on eth1    on eth2<br> |<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">           </span>|<span class="hljs-string">          ^</span><br><span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">           v          </span>|<br> --&gt; tracing <span class="hljs-variable">&lt;--     tracing      socket    tc ingress   tc egress</span><br><span class="hljs-variable">      prog_1          prog_2      prog_3    classifier    action</span><br><span class="hljs-variable">      |  |              |           |         prog_4      prog_5</span><br><span class="hljs-variable">   |---  -----|  |------|          map_3        |           |</span><br><span class="hljs-variable"> map_1       map_2                              --| map_4 |--</span><br></code></pre></td></tr></table></figure>

<h2 id="二、eBPF-verifier"><a href="#二、eBPF-verifier" class="headerlink" title="二、eBPF verifier"></a>二、eBPF verifier</h2><p>在 eBPF 字节码被传入到内核空间后，其首先需要经过 <code>verifier</code> 的安全检查，之后才能进行 JIT 编译，verifier 主要检查以下几点：</p>
<ul>
<li>没有回向边（back edge）、环路（loop）、不可达（unreachable）指令</li>
<li>不能在指针之间进行比较，指针只能与标量进行加减（eBPF 中的标量值为不从指针派生的值），verifier 会追踪哪些寄存器包含指针、哪些寄存器包含标量值</li>
<li>指针运算不能离开一个 map 的“安全”边界，这意味着程序不能访问预定义的 map 外的内存，verifier 通过追踪每个寄存器值的上界与下界</li>
<li>不能将指针存储在 map 中或作为返回值，以避免将内核地址泄露到用户空间</li>
</ul>
<p>在 <code>kernel/bpf/verifier.c</code>  开头注释阐述如下：</p>
<blockquote>
<p>这里为了方便阅读，有的保留原文没有翻译</p>
<blockquote>
<p>比如说直接说 <code>map element key</code> 你肯定知道是什么东西，但是我要是说 <code>映射元素键</code> 那你肯定得楞一会….</p>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* bpf_check() 是一个静态代码分析器，其逐条遍历 eBPF 程序中的指令，</span><br><span class="hljs-comment"> * 并更新寄存器/堆栈的状态。</span><br><span class="hljs-comment"> * 条件分支的所有路径都会被分析，直到 &#x27;bpf_exit&#x27; 指令。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 首先通过深度优先搜索检查程序是否为有向无环图（Directed Acyclic Graph）</span><br><span class="hljs-comment"> * 其拒绝以下程序:</span><br><span class="hljs-comment"> * - 指令数大于 BPF_MAXINSNS </span><br><span class="hljs-comment"> * - 出现了循环 (通过后向边检测)</span><br><span class="hljs-comment"> * - 存在不可达指令 (不应当是一个森林. 程序 = 一个函数)</span><br><span class="hljs-comment"> * - 越界或畸形跳转</span><br><span class="hljs-comment"> * 接着是第一条指令展开的所有可能路径。</span><br><span class="hljs-comment"> * 由于其分析程序中所有的路径，分析的长度被限制为 64k 指令，</span><br><span class="hljs-comment"> * 即使总的指令数仅有 4k 可也能达到，但这有太多的会改变栈/寄存器的分支。</span><br><span class="hljs-comment"> * “被分析的分支”的数量被限制在 1k</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在每条指令的入口，每个寄存器都有一个类型，该指令根据指令语义改变寄存器的类型。</span><br><span class="hljs-comment"> * 若指令为 BPF_MOV64_REG(BPF_REG_1, BPF_REG_5),  则 R5 的类型会被复制给 R1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所有的寄存器都是 64 位的</span><br><span class="hljs-comment"> * R0 - 返回寄存器</span><br><span class="hljs-comment"> * R1-R5 传参寄存器</span><br><span class="hljs-comment"> * R6-R9 callee 保存的寄存器</span><br><span class="hljs-comment"> * R10 - 只读帧指针</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在 BPF 程序起始， R1 寄存器包含一个指向 bpf_context 的指针，</span><br><span class="hljs-comment"> * 其类型为 PTR_TO_CTX.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Verifier 跟踪指针上的运算，以免:</span><br><span class="hljs-comment"> *    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),</span><br><span class="hljs-comment"> *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -20),</span><br><span class="hljs-comment"> * 第一条指令将 R10 (FRAME_PTR) 的类型拷贝给 R1，</span><br><span class="hljs-comment"> * 第二条算术指令通过模式匹配以识别其想要构造一个指向栈内元素的指针。</span><br><span class="hljs-comment"> * 因此在第二条指令后，寄存器 R1 的类型为 PTR_TO_STACK</span><br><span class="hljs-comment"> * (以及常量 -20 被存储用作未来的栈边界检查).</span><br><span class="hljs-comment"> * 这意味着该寄存器为一个指向[栈 + 已知立即数常量]的指针</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 大部分情况下寄存器都有着 SCALAR_VALUE 类型，</span><br><span class="hljs-comment"> * 这意味着寄存器存储着一些值，但并非一个可用的指针.</span><br><span class="hljs-comment"> * (例如指针加上指针会变为 SCALAR_VALUE 类型)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当 verifier 遇到 load 或 store 指令时基寄存器（base register）的类型可以为：</span><br><span class="hljs-comment"> * PTR_TO_MAP_VALUE, PTR_TO_CTX, PTR_TO_STACK, PTR_TO_SOCKET.</span><br><span class="hljs-comment"> * 这些是 4 种被 check_mem_access() 函数所识别的指针类型.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * PTR_TO_MAP_VALUE 意为该寄存器指向 &#x27;map element value&#x27;</span><br><span class="hljs-comment"> * 可访问的范围为 [ptr, ptr + map&#x27;s value_size).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 用以在函数调用时传值的寄存器被根据函数参数约束进行检查</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ARG_PTR_TO_MAP_KEY 便是其中一个这样的参数约束.</span><br><span class="hljs-comment"> * 其意为传递给该函数的寄存器类型必须为 PTR_TO_STACK</span><br><span class="hljs-comment"> * 且其在函数内将被作为 &#x27;pointer to map element key&#x27; 使用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 例如，这些是 bpf_map_lookup_elem() 的参数约定:</span><br><span class="hljs-comment"> *   .ret_type = RET_PTR_TO_MAP_VALUE_OR_NULL,</span><br><span class="hljs-comment"> *   .arg1_type = ARG_CONST_MAP_PTR,</span><br><span class="hljs-comment"> *   .arg2_type = ARG_PTR_TO_MAP_KEY,</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ret_type 表示该函数返回 &#x27;pointer to map elem value or null&#x27;</span><br><span class="hljs-comment"> * 函数希望第一个参数为一个指向 &#x27;struct bpf_map&#x27; 的常量指针，</span><br><span class="hljs-comment"> * 第二个参数则应为指向栈的指针，其会在 helper 函数内用作</span><br><span class="hljs-comment"> * 指向[map element key]的指针</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 内核侧的 helper 函数有如下形式:</span><br><span class="hljs-comment"> * u64 bpf_map_lookup_elem(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)</span><br><span class="hljs-comment"> * &#123;</span><br><span class="hljs-comment"> *    struct bpf_map *map = (struct bpf_map *) (unsigned long) r1;</span><br><span class="hljs-comment"> *    void *key = (void *) (unsigned long) r2;</span><br><span class="hljs-comment"> *    void *value;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    这里内核可以安全地访问 &#x27;key&#x27; 与 &#x27;map&#x27; 指针, 知晓</span><br><span class="hljs-comment"> *    [key, key + map-&gt;key_size) 字节为可用的且被</span><br><span class="hljs-comment"> *    初始化在 eBPF 程序的栈上.</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 相应的 eBPF 程序或许形如:</span><br><span class="hljs-comment"> *    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),  // 这条指令后 R2 的类型为 FRAME_PTR</span><br><span class="hljs-comment"> *    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), // 这条指令后 R2 的类型为 PTR_TO_STACK</span><br><span class="hljs-comment"> *    BPF_LD_MAP_FD(BPF_REG_1, map_fd),      // 这条指令后 R1 的类型为 CONST_PTR_TO_MAP</span><br><span class="hljs-comment"> *    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span><br><span class="hljs-comment"> * 这里 verifier 关注 map_lookup_elem() 的原型，会看到:</span><br><span class="hljs-comment"> * .arg1_type == ARG_CONST_MAP_PTR 以及 R1-&gt;type == CONST_PTR_TO_MAP, 这是 🆗 的,</span><br><span class="hljs-comment"> * 现在 verifier 知道该 map 有一个 R1-&gt;map_ptr-&gt;key_size 字节的 key</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 然后， .arg2_type == ARG_PTR_TO_MAP_KEY and R2-&gt;type == PTR_TO_STACK, 到现在还🆗,</span><br><span class="hljs-comment"> * 现在 verifier 检查 [R2, R2 + map&#x27;s key_size) 在栈的限制内，</span><br><span class="hljs-comment"> * 且在该调用之前被初始化.</span><br><span class="hljs-comment"> * 若🆗, verifier 接下来允许该 BPF_CALL 指令并关注</span><br><span class="hljs-comment"> * .ret_type （为 RET_PTR_TO_MAP_VALUE_OR_NULL）, 故让</span><br><span class="hljs-comment"> * R0-&gt;type = PTR_TO_MAP_VALUE_OR_NULL ，这意味着 bpf_map_lookup_elem() 函数</span><br><span class="hljs-comment"> * 返回指向 map value 的指针或 NULL.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当类型 PTR_TO_MAP_VALUE_OR_NULL 通过 &#x27;if (reg != 0) goto +off&#x27; 指令，</span><br><span class="hljs-comment"> * 在 true 分支中持有指针的寄存器将状态改变为 PTR_TO_MAP_VALUE，</span><br><span class="hljs-comment"> * 在 false 分支中同样的寄存器将状态改变为 CONST_IMM 。</span><br><span class="hljs-comment"> * 参见 check_cond_jmp_op().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在调用后 R0 被设为函数返回值，寄存器 R1-R5 被设为 NOT_INIT</span><br><span class="hljs-comment"> * 以表示其不再可读.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 以下引用类型表示一个对内核资源的潜在引用，</span><br><span class="hljs-comment"> * 在其第一次被分配后， BPF 程序必须检查并释放该资源:</span><br><span class="hljs-comment"> * - PTR_TO_SOCKET_OR_NULL, PTR_TO_SOCKET</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当 verifier 遇到一个 helper 调用返回一个引用类型, </span><br><span class="hljs-comment"> * 其为该引用分配一个指针 id 并将他储存在当前的函数状态中.</span><br><span class="hljs-comment"> * 类似于将 PTR_TO_MAP_VALUE_OR_NULL 转化为 PTR_TO_MAP_VALUE 的方式，</span><br><span class="hljs-comment"> * 当类型通过一个 NULL-check 条件， PTR_TO_SOCKET_OR_NULL 变为 PTR_TO_SOCKET。</span><br><span class="hljs-comment"> * 对于状态变为 CONST_IMM 的分支，verifier会释放引用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 对每个会分配一个引用的 helper 函数，例如 bpf_sk_lookup_tcp()，</span><br><span class="hljs-comment"> * 都有一个对应的释放函数，例如bpf_sk_release()。</span><br><span class="hljs-comment"> * 当一个引用类型传入释放函数时，verifier 同样释放引用。</span><br><span class="hljs-comment"> * 若在程序末尾仍保留有任何未检查或未释放的引用，verifier 会拒绝他</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h3 id="ALU-Sanitation"><a href="#ALU-Sanitation" class="headerlink" title="ALU Sanitation"></a>ALU Sanitation</h3><p><code>ALU Sanitation</code> 是 eBPF 中一个<strong>代码加固与运行时动态检测</strong>的框架，通过对程序正在处理的实际值进行运行时检查以弥补 verifier 静态分析的不足，这项技术通过调用 <code>fixup_bpf_calls()</code> <strong>为 eBPF 程序中的每一条指令的前面都添加上额外的辅助指令、替换部分指令</strong>等方式来实现</p>
<h2 id="三、eBPF-虚拟机"><a href="#三、eBPF-虚拟机" class="headerlink" title="三、eBPF 虚拟机"></a>三、eBPF 虚拟机</h2><p>eBPF 虚拟机本质上是 RISC 架构，一共有 11 个 64 位寄存器，一个程序计数器（PC）与一个固定大小的堆栈（通常为 512KB），在 x86 架构下的对应关系如下：</p>
<table>
<thead>
<tr>
<th align="center">eBPF 寄存器</th>
<th align="center">映射 x86_64 寄存器</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">R0</td>
<td align="center">rax</td>
<td align="center">函数返回值</td>
</tr>
<tr>
<td align="center">R1</td>
<td align="center">rdi</td>
<td align="center">argv1</td>
</tr>
<tr>
<td align="center">R2</td>
<td align="center">rsi</td>
<td align="center">argv2</td>
</tr>
<tr>
<td align="center">R3</td>
<td align="center">rdx</td>
<td align="center">argv3</td>
</tr>
<tr>
<td align="center">R4</td>
<td align="center">rcx</td>
<td align="center">argv4</td>
</tr>
<tr>
<td align="center">R5</td>
<td align="center">r8</td>
<td align="center">argv5</td>
</tr>
<tr>
<td align="center">R6</td>
<td align="center">rbx</td>
<td align="center">callee 保存</td>
</tr>
<tr>
<td align="center">R7</td>
<td align="center">r13</td>
<td align="center">callee 保存</td>
</tr>
<tr>
<td align="center">R8</td>
<td align="center">r14</td>
<td align="center">callee 保存</td>
</tr>
<tr>
<td align="center">R9</td>
<td align="center">r15</td>
<td align="center">callee 保存</td>
</tr>
<tr>
<td align="center">R10（只读）</td>
<td align="center">rbp</td>
<td align="center">堆栈指针寄存器</td>
</tr>
</tbody></table>
<p>r1 ~ r5 这五个寄存器用作 eBPF 中的函数调用传参，且只能保存常数或是指向堆栈的指针，因此所有的内存访问都需要先把数据加载到 eBPF 堆栈中才能使用，这种限制简化了 eBPF 的内存模型，也更方便 verifier 进行检查</p>
<p><img src="https://s2.loli.net/2023/05/28/68e53xiKbH4TQz7.png" srcset="/img/loading.gif" lazyload alt="eBPF.png"></p>
<h3 id="bpf-reg-state-eBPF-寄存器状态"><a href="#bpf-reg-state-eBPF-寄存器状态" class="headerlink" title="bpf_reg_state - eBPF 寄存器状态"></a>bpf_reg_state - eBPF 寄存器状态</h3><p>在 eBPF 中，一个寄存器的状态信息使用 <code>bpf_reg_state</code> 进行表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> &#123;</span><br>	<span class="hljs-comment">/* 各字段的顺序是重要的.  参见 states_equal() */</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> <span class="hljs-title">type</span>;</span><br>	<span class="hljs-comment">/* 指针偏移的固定部分, 仅指针类型 */</span><br>	s32 off;<br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-comment">/* 当 type == PTR_TO_PACKET 时可用 */</span><br>		<span class="hljs-type">int</span> range;<br><br>		<span class="hljs-comment">/* 当 type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span><br><span class="hljs-comment">		 *   PTR_TO_MAP_VALUE_OR_NULL 时可用</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map_ptr</span>;</span><br>			<span class="hljs-comment">/* 为了从外部映射中区分映射查找</span><br><span class="hljs-comment">			 * map_uid 对于指向内部映射的寄存器为非 0 值</span><br><span class="hljs-comment">			 */</span><br>			u32 map_uid;<br>		&#125;;<br><br>		<span class="hljs-comment">/* for PTR_TO_BTF_ID */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">btf</span>;</span><br>			u32 btf_id;<br>		&#125;;<br><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* for PTR_TO_MEM | PTR_TO_MEM_OR_NULL */</span><br>			u32 mem_size;<br>			u32 dynptr_id; <span class="hljs-comment">/* for dynptr slices */</span><br>		&#125;;<br><br>		<span class="hljs-comment">/* For dynptr stack slots */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_dynptr_type</span> <span class="hljs-title">type</span>;</span><br>			<span class="hljs-comment">/* 一个 dynptr 为 16 字节， 故其占用 2 个 stack slots.</span><br><span class="hljs-comment">			 * 我们需要追踪哪一个 slot 为第一个防止用户可能尝试传入一个从</span><br><span class="hljs-comment">			 * dynptr 的第二个 slot 开始的地址的情况的 slot.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-type">bool</span> first_slot;<br>		&#125; dynptr;<br><br>		<span class="hljs-comment">/* 以上任意一个的最大尺寸. */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> raw1;<br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> raw2;<br>		&#125; raw;<br><br>		u32 subprogno; <span class="hljs-comment">/* for PTR_TO_FUNC */</span><br>	&#125;;<br>	<span class="hljs-comment">/* 对于标量类型 (SCALAR_VALUE), 其表示我们对实际值的了解.</span><br><span class="hljs-comment">	 * 对于指针类型, 其表示从被指向对象的偏移的可变部分，</span><br><span class="hljs-comment">	 * 且同与我们有相同 id 的所有 bpf_reg_states 共享.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">var_off</span>;</span><br>	<span class="hljs-comment">/* 被用于确定任何使用该寄存器的内存访问是否将导致一个坏的访问.</span><br><span class="hljs-comment">	 * These refer to the same value as var_off, not necessarily the actual</span><br><span class="hljs-comment">	 * contents of the register.</span><br><span class="hljs-comment">	 */</span><br>	s64 smin_value; <span class="hljs-comment">/* 最小可能值 (s64) */</span><br>	s64 smax_value; <span class="hljs-comment">/* 最大可能值 (s64) */</span><br>	u64 umin_value; <span class="hljs-comment">/* 最小可能值 (u64) */</span><br>	u64 umax_value; <span class="hljs-comment">/* 最大可能值 (u64) */</span><br>	s32 s32_min_value; <span class="hljs-comment">/* 最小可能值 (s32) */</span><br>	s32 s32_max_value; <span class="hljs-comment">/* 最大可能值 (s32) */</span><br>	u32 u32_min_value; <span class="hljs-comment">/* 最小可能值 (u32) */</span><br>	u32 u32_max_value; <span class="hljs-comment">/* 最大可能值 (u32) */</span><br>	<span class="hljs-comment">/* 对于 PTR_TO_PACKET, 用以找到有着相同变量偏移的其他指针，</span><br><span class="hljs-comment">	 * 由此他们可以共享范围信息.</span><br><span class="hljs-comment">	 * 对于 PTR_TO_MAP_VALUE_OR_NULL 其被用于共享我们来自哪一个映射值</span><br><span class="hljs-comment">	 * 当其一被测试于 != NULL.</span><br><span class="hljs-comment">	 * 对于 PTR_TO_MEM_OR_NULL 其被用于辨识内存分配以追踪其释放.</span><br><span class="hljs-comment">	 * 对于 PTR_TO_SOCKET 其被用于共享哪一个指针保留了对 socket 的相同引用，</span><br><span class="hljs-comment">	 * 以确定合适的引用释放.</span><br><span class="hljs-comment">	 * 对于作为 dynptrs 的 stack slots, 其被用于追踪对 dynptr的引用</span><br><span class="hljs-comment">	 * 以确定合适的引用释放.</span><br><span class="hljs-comment">	 */</span><br>	u32 id;<br>	<span class="hljs-comment">/* PTR_TO_SOCKET 与 PTR_TO_TCP_SOCK 可以为一个返回自一个 pointer-cast helper</span><br><span class="hljs-comment">	 * bpf_sk_fullsock() 与 bpf_tcp_sock() 的指针 .</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 考虑如下情况， &quot;sk&quot; 为一个返回自 &quot;sk = bpf_sk_lookup_tcp();&quot; 的引用计数指针:</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 1: sk = bpf_sk_lookup_tcp();</span><br><span class="hljs-comment">	 * 2: if (!sk) &#123; return 0; &#125;</span><br><span class="hljs-comment">	 * 3: fullsock = bpf_sk_fullsock(sk);</span><br><span class="hljs-comment">	 * 4: if (!fullsock) &#123; bpf_sk_release(sk); return 0; &#125;</span><br><span class="hljs-comment">	 * 5: tp = bpf_tcp_sock(fullsock);</span><br><span class="hljs-comment">	 * 6: if (!tp) &#123; bpf_sk_release(sk); return 0; &#125;</span><br><span class="hljs-comment">	 * 7: bpf_sk_release(sk);</span><br><span class="hljs-comment">	 * 8: snd_cwnd = tp-&gt;snd_cwnd;  // verifier 将抗议</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 在第 7 行的 bpf_sk_release(sk) 之后, &quot;fullsock&quot; 指针与</span><br><span class="hljs-comment">	 * &quot;tp&quot; 指针都应当被无效化.  为了这么做, 保存 &quot;fullsock&quot; 与 &quot;sk&quot;</span><br><span class="hljs-comment">	 * 的寄存器需要记住在 ref_obj_id 中的原始引用计数指针 id(即， sk_reg-&gt;id)</span><br><span class="hljs-comment">	 * 这样 verifier 便能重置所有 ref_obj_id 匹配 sk_reg-&gt;id 的寄存器</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * sk_reg-&gt;ref_obj_id 在第 1 行被设为 sk_reg-&gt;id.</span><br><span class="hljs-comment">	 * sk_reg-&gt;id 将仅作为 NULL-marking 的目的保持.</span><br><span class="hljs-comment">	 * 在 NULL-marking 完成后, sk_reg-&gt;id 可以被重置为 0.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 在第 3 行的 &quot;fullsock = bpf_sk_fullsock(sk);&quot; 之后,</span><br><span class="hljs-comment">	 * fullsock_reg-&gt;ref_obj_id 被设为 sk_reg-&gt;ref_obj_id.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 在第 5 行的 &quot;tp = bpf_tcp_sock(fullsock);&quot; 之后,</span><br><span class="hljs-comment">	 * tp_reg-&gt;ref_obj_id 被设为 fullsock_reg-&gt;ref_obj_id</span><br><span class="hljs-comment">	 * 与 sk_reg-&gt;ref_obj_id 一致.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * 从 verifier 的角度而言, 若 sk, fullsock 与 tp 都非 NULL,</span><br><span class="hljs-comment">	 * 他们为有着不同 reg-&gt;type 的相同指针.</span><br><span class="hljs-comment">	 * 特别地, bpf_sk_release(tp) 也被允许且有着与 bpf_sk_release(sk) </span><br><span class="hljs-comment">	 * 相同的影响.</span><br><span class="hljs-comment">	 */</span><br>	u32 ref_obj_id;<br>	<span class="hljs-comment">/* 用于存活检查的亲子链 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_reg_state</span> *<span class="hljs-title">parent</span>;</span><br>	<span class="hljs-comment">/* 在被调用方中两个寄存器可以同时为 PTR_TO_STACK 如同 R1=fp-8 与 R2=fp-8,</span><br><span class="hljs-comment">	 * 但其一指向该函数栈而另一指向调用方的栈. 为了区分他们 &#x27;frameno&#x27; 被使用，</span><br><span class="hljs-comment">	 * 其为一个指向 bpf_func_state 的 bpf_verifier_state-&gt;frame[] 数组中的下标.</span><br><span class="hljs-comment">	 */</span><br>	u32 frameno;<br>	<span class="hljs-comment">/* 追踪子寄存器（subreg）定义. 保存的值为写入 insn 的 insn_idx.</span><br><span class="hljs-comment">	 * 这是安全的因为 subreg_def 在任何仅在主校验结束后发生的 insn 修补前被使用.</span><br><span class="hljs-comment">	 */</span><br>	s32 subreg_def;<br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_liveness</span> <span class="hljs-title">live</span>;</span><br>	<span class="hljs-comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don&#x27;t affect safety */</span><br>	<span class="hljs-type">bool</span> precise;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="寄存器运行时值与边界范围校验"><a href="#寄存器运行时值与边界范围校验" class="headerlink" title="寄存器运行时值与边界范围校验"></a>寄存器运行时值与边界范围校验</h4><p>eBPF 程序的安全主要是由 verifier 保证的，verifier 会<strong>模拟执行每一条指令</strong>并验证寄存器的值是否合法，主要关注这几个字段：</p>
<ul>
<li><code>smin_value</code>、<code>smax_value</code>： 64 位有符号的值的可能取值边界</li>
<li><code>umin_value</code>、<code>umax_value</code>：64 位无符号的值的可能取值边界</li>
<li><code>s32_min_value</code>、<code>s32_max_value</code>：32 位有符号的值的可能取值边界</li>
<li><code>u32_min_value</code>、<code>u32_max_value</code>：32 位无符号的值的可能取值边界</li>
</ul>
<p>而寄存器中<strong>可以确定的值</strong>实际上通过 <code>var_off</code> 字段进行表示，该值用一个 <code>tnum</code> 结构体表示，<strong>mask 中为 0 对应的 value 位为已知位</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> &#123;</span><br>	u64 value;<br>	u64 mask;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>一个 verifier 完全未知的寄存器如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnum</span> <span class="hljs-title">tnum_unknown</span> =</span> &#123; .value = <span class="hljs-number">0</span>, .mask = <span class="hljs-number">-1</span> &#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是寄存器边界值是 verifier 通过模拟执行推测出来的，<strong>运行时的寄存器值不一定与 verifier 所推测的一致</strong>，这也曾是很多 eBPF 漏洞产生的原因</p>
</blockquote>
<h4 id="寄存器类型"><a href="#寄存器类型" class="headerlink" title="寄存器类型"></a>寄存器类型</h4><p>寄存器在程序运行的不同阶段可能存放着不同类型的值，verifier 通过跟踪寄存器值的类型来防止越界访问的发生，主要有三类：</p>
<ul>
<li>未初始化（not init）：寄存器的初始状态，尚未经过任何赋值操作，此类寄存器不能参与运算</li>
<li>标量值（scalar）：该寄存器被赋予了整型值，此类寄存器不能被作为指针进行内存访问</li>
<li>指针类型（pointer）：该寄存器为一个指针，verifier 会检查内存访问是否超出指针允许的范围<ul>
<li>实际上 eBPF 按照用途的不同划分多个不同的指针类型，例如指向栈的指针为 <code>PTR_TO_STACK</code> 类型</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* types of values stored in eBPF registers */</span><br><span class="hljs-comment">/* Pointer types represent:</span><br><span class="hljs-comment"> * pointer</span><br><span class="hljs-comment"> * pointer + imm</span><br><span class="hljs-comment"> * pointer + (u16) var</span><br><span class="hljs-comment"> * pointer + (u16) var + imm</span><br><span class="hljs-comment"> * if (range &gt; 0) then [ptr, ptr + range - off) is safe to access</span><br><span class="hljs-comment"> * if (id &gt; 0) means that some &#x27;var&#x27; was added</span><br><span class="hljs-comment"> * if (off &gt; 0) means that &#x27;imm&#x27; was added</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> &#123;</span><br>	NOT_INIT = <span class="hljs-number">0</span>,		 <span class="hljs-comment">/* nothing was written into register */</span><br>	SCALAR_VALUE,		 <span class="hljs-comment">/* reg doesn&#x27;t contain a valid pointer */</span><br>	PTR_TO_CTX,		 <span class="hljs-comment">/* reg points to bpf_context */</span><br>	CONST_PTR_TO_MAP,	 <span class="hljs-comment">/* reg points to struct bpf_map */</span><br>	PTR_TO_MAP_VALUE,	 <span class="hljs-comment">/* reg points to map element value */</span><br>	PTR_TO_MAP_VALUE_OR_NULL,<span class="hljs-comment">/* points to map elem value or NULL */</span><br>	PTR_TO_STACK,		 <span class="hljs-comment">/* reg == frame_pointer + offset */</span><br>	PTR_TO_PACKET_META,	 <span class="hljs-comment">/* skb-&gt;data - meta_len */</span><br>	PTR_TO_PACKET,		 <span class="hljs-comment">/* reg points to skb-&gt;data */</span><br>	PTR_TO_PACKET_END,	 <span class="hljs-comment">/* skb-&gt;data + headlen */</span><br>	PTR_TO_FLOW_KEYS,	 <span class="hljs-comment">/* reg points to bpf_flow_keys */</span><br>	PTR_TO_SOCKET,		 <span class="hljs-comment">/* reg points to struct bpf_sock */</span><br>	PTR_TO_SOCKET_OR_NULL,	 <span class="hljs-comment">/* reg points to struct bpf_sock or NULL */</span><br>	PTR_TO_SOCK_COMMON,	 <span class="hljs-comment">/* reg points to sock_common */</span><br>	PTR_TO_SOCK_COMMON_OR_NULL, <span class="hljs-comment">/* reg points to sock_common or NULL */</span><br>	PTR_TO_TCP_SOCK,	 <span class="hljs-comment">/* reg points to struct tcp_sock */</span><br>	PTR_TO_TCP_SOCK_OR_NULL, <span class="hljs-comment">/* reg points to struct tcp_sock or NULL */</span><br>	PTR_TO_TP_BUFFER,	 <span class="hljs-comment">/* reg points to a writable raw tp&#x27;s buffer */</span><br>	PTR_TO_XDP_SOCK,	 <span class="hljs-comment">/* reg points to struct xdp_sock */</span><br>	<span class="hljs-comment">/* PTR_TO_BTF_ID points to a kernel struct that does not need</span><br><span class="hljs-comment">	 * to be null checked by the BPF program. This does not imply the</span><br><span class="hljs-comment">	 * pointer is _not_ null and in practice this can easily be a null</span><br><span class="hljs-comment">	 * pointer when reading pointer chains. The assumption is program</span><br><span class="hljs-comment">	 * context will handle null pointer dereference typically via fault</span><br><span class="hljs-comment">	 * handling. The verifier must keep this in mind and can make no</span><br><span class="hljs-comment">	 * assumptions about null or non-null when doing branch analysis.</span><br><span class="hljs-comment">	 * Further, when passed into helpers the helpers can not, without</span><br><span class="hljs-comment">	 * additional context, assume the value is non-null.</span><br><span class="hljs-comment">	 */</span><br>	PTR_TO_BTF_ID,<br>	<span class="hljs-comment">/* PTR_TO_BTF_ID_OR_NULL points to a kernel struct that has not</span><br><span class="hljs-comment">	 * been checked for null. Used primarily to inform the verifier</span><br><span class="hljs-comment">	 * an explicit null check is required for this struct.</span><br><span class="hljs-comment">	 */</span><br>	PTR_TO_BTF_ID_OR_NULL,<br>	PTR_TO_MEM,		 <span class="hljs-comment">/* reg points to valid memory region */</span><br>	PTR_TO_MEM_OR_NULL,	 <span class="hljs-comment">/* reg points to valid memory region or NULL */</span><br>	PTR_TO_RDONLY_BUF,	 <span class="hljs-comment">/* reg points to a readonly buffer */</span><br>	PTR_TO_RDONLY_BUF_OR_NULL, <span class="hljs-comment">/* reg points to a readonly buffer or NULL */</span><br>	PTR_TO_RDWR_BUF,	 <span class="hljs-comment">/* reg points to a read/write buffer */</span><br>	PTR_TO_RDWR_BUF_OR_NULL, <span class="hljs-comment">/* reg points to a read/write buffer or NULL */</span><br>	PTR_TO_PERCPU_BTF_ID,	 <span class="hljs-comment">/* reg points to a percpu kernel variable */</span><br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="四、eBPF-指令与-eBPF-程序"><a href="#四、eBPF-指令与-eBPF-程序" class="headerlink" title="四、eBPF 指令与 eBPF 程序"></a>四、eBPF 指令与 eBPF 程序</h2><p>eBPF 为 RISC 指令集，单条 eBPF 指令在内核中定义为一个 <code>bpf_insn</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>	__u8	code;		<span class="hljs-comment">/* opcode */</span><br>	__u8	dst_reg:<span class="hljs-number">4</span>;	<span class="hljs-comment">/* dest register */</span><br>	__u8	src_reg:<span class="hljs-number">4</span>;	<span class="hljs-comment">/* source register */</span><br>	__s16	off;		<span class="hljs-comment">/* signed offset */</span><br>	__s32	imm;		<span class="hljs-comment">/* signed immediate constant */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>相应地，一个最简单的 eBPF 程序<strong>便是一个</strong> <code>bpf_insn</code> <strong>结构体数组</strong>，我们可以直接在用户态下编写形如这样的结构体数组来描述一个 eBPF 程序，并作为 eBPF 程序字节码传入内核：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span><br><span class="hljs-meta">    ((struct bpf_insn) &#123;                                \</span><br><span class="hljs-meta">        .code        = CODE,                            \</span><br><span class="hljs-meta">        .dst_reg     = DST,                             \</span><br><span class="hljs-meta">        .src_reg     = SRC,                             \</span><br><span class="hljs-meta">        .off         = OFF,                             \</span><br><span class="hljs-meta">        .imm         = IMM                              \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">test_bpf_prog</span>[] =</span> &#123;<br>    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x114514</span>),<br>    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>载入到内核中后，内核最终会使用一个 <code>bpf_prog</code> 结构体来表示一个 eBPF 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog</span> &#123;</span><br>	u16			pages;		<span class="hljs-comment">/* 分配的页面数量 */</span><br>	u16			jited:<span class="hljs-number">1</span>,	<span class="hljs-comment">/* 我们的 filter 是否是即时编译的? */</span><br>				jit_requested:<span class="hljs-number">1</span>,<span class="hljs-comment">/* 架构需要即时编译程序 */</span><br>				gpl_compatible:<span class="hljs-number">1</span>, <span class="hljs-comment">/* filter 是否兼容 GPL? */</span><br>				cb_access:<span class="hljs-number">1</span>,	<span class="hljs-comment">/* 控制块被访问了吗? */</span><br>				dst_needed:<span class="hljs-number">1</span>,	<span class="hljs-comment">/* 我们是否需要 dst 入口? */</span><br>				blinding_requested:<span class="hljs-number">1</span>, <span class="hljs-comment">/* needs constant blinding */</span><span class="hljs-comment">//译注：不知道咋翻</span><br>				blinded:<span class="hljs-number">1</span>,	<span class="hljs-comment">/* Was blinded */</span><span class="hljs-comment">//译注：瞎了？</span><br>				is_func:<span class="hljs-number">1</span>,	<span class="hljs-comment">/* 程序为一个 bpf 函数 */</span><br>				kprobe_override:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 我们是否在一个 kprobe 之上? */</span><br>				has_callchain_buf:<span class="hljs-number">1</span>, <span class="hljs-comment">/* callchain buffer 分配了吗? */</span><br>				enforce_expected_attach_type:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 在 attach 时强制执行 expected_attach_type 检查 */</span><br>				call_get_stack:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 我们是否调用 bpf_get_stack() 或 bpf_get_stackid() */</span><br>				call_get_func_ip:<span class="hljs-number">1</span>, <span class="hljs-comment">/* 我们是否调用 get_func_ip() */</span><br>				tstamp_type_access:<span class="hljs-number">1</span>; <span class="hljs-comment">/* 被访问的 __sk_buff-&gt;tstamp_type */</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span>	<span class="hljs-title">type</span>;</span>		<span class="hljs-comment">/* BPF 程序类型 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_attach_type</span>	<span class="hljs-title">expected_attach_type</span>;</span> <span class="hljs-comment">/* 用于一些程序类型 */</span><br>	u32			len;		<span class="hljs-comment">/* filter 块的数量 */</span><br>	u32			jited_len;	<span class="hljs-comment">/* 按字节计的被即时编译的指令大小 */</span><br>	u8			tag[BPF_TAG_SIZE];<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog_stats</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">stats</span>;</span><br>	<span class="hljs-type">int</span> __percpu		*active;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span>		<span class="hljs-params">(*bpf_func)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ctx,</span><br><span class="hljs-params">					    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_insn *insn)</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog_aux</span>	*<span class="hljs-title">aux</span>;</span>		<span class="hljs-comment">/* 辅助域 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog_kern</span>	*<span class="hljs-title">orig_prog</span>;</span>	<span class="hljs-comment">/* 原始 BPF 程序 */</span><br>	<span class="hljs-comment">/* 翻译器的指令 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		DECLARE_FLEX_ARRAY(<span class="hljs-keyword">struct</span> sock_filter, insns);<br>		DECLARE_FLEX_ARRAY(<span class="hljs-keyword">struct</span> bpf_insn, insnsi);<br>	&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中 <code>bpf_func</code> 函数指针便指向 BPF 字节码经过 JIT 编译生成的汇编代码入口点</p>
<h2 id="五、eBPF-map"><a href="#五、eBPF-map" class="headerlink" title="五、eBPF map"></a>五、eBPF map</h2><p>bpf map 是一个通用的用以储存不同种类数据的结构，用以在用户进程与 eBPF 程序、eBPF 程序与 eBPF 程序之间进行<strong>数据共享</strong>，这些数据以二进制形式储存，因此用户在创建时只需要指定 key 与 value 的 size</p>
<p>bpf map 主要有以下五个基本属性：</p>
<ul>
<li><code>type</code>：map 的数据结构类型</li>
<li><code>key_size</code>：以字节为单位的用以索引一个元素的 key 的 size（在数组映射中使用）</li>
<li><code>value_size</code>：以字节为单位的每个元素的 size</li>
<li><code>max_entries</code>：map 中 entries 的最大数量</li>
<li><code>map_flags</code>：描述 map 的独特特征，例如是否整个 map 的内存应被预先分配等</li>
</ul>
<p>在内核当中使用一个 <code>bpf_map</code> 结构体表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> &#123;</span><br>	<span class="hljs-comment">/* 前两条缓存行带有以读取为主的成员，</span><br><span class="hljs-comment">	 * 其中一些也在快速路径中被访问 (e.g. ops, max_entries).</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops</span> ____<span class="hljs-title">cacheline_aligned</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">inner_map_meta</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SECURITY</span><br>	<span class="hljs-type">void</span> *security;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_map_type</span> <span class="hljs-title">map_type</span>;</span><br>	u32 key_size;<br>	u32 value_size;<br>	u32 max_entries;<br>	u64 map_extra; <span class="hljs-comment">/* any per-map-type extra fields */</span><br>	u32 map_flags;<br>	u32 id;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_record</span> *<span class="hljs-title">record</span>;</span><br>	<span class="hljs-type">int</span> numa_node;<br>	u32 btf_key_type_id;<br>	u32 btf_value_type_id;<br>	u32 btf_vmlinux_value_type_id;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">btf</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-type">char</span> name[BPF_OBJ_NAME_LEN];<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_field_offs</span> *<span class="hljs-title">field_offs</span>;</span><br>	<span class="hljs-comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span><br><span class="hljs-comment">	 * particularly with refcounting.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">atomic64_t</span> refcnt ____cacheline_aligned;<br>	<span class="hljs-type">atomic64_t</span> usercnt;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">work</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">freeze_mutex</span>;</span><br>	<span class="hljs-type">atomic64_t</span> writecnt;<br>	<span class="hljs-comment">/* &#x27;Ownership&#x27; of program-containing map is claimed by the first program</span><br><span class="hljs-comment">	 * that is going to use this map or by the first program which FD is</span><br><span class="hljs-comment">	 * stored in the map to make sure that all callers and callees have the</span><br><span class="hljs-comment">	 * same prog type, JITed flag and xdp_has_frags flag.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>		<span class="hljs-type">spinlock_t</span> lock;<br>		<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span> <span class="hljs-title">type</span>;</span><br>		<span class="hljs-type">bool</span> jited;<br>		<span class="hljs-type">bool</span> xdp_has_frags;<br>	&#125; owner;<br>	<span class="hljs-type">bool</span> bypass_spec_v1;<br>	<span class="hljs-type">bool</span> frozen; <span class="hljs-comment">/* write-once; write-protected by freeze_mutex */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="map-类型"><a href="#map-类型" class="headerlink" title="map 类型"></a>map 类型</h3><p>可选 map 类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_map_type</span> &#123;</span><br>	BPF_MAP_TYPE_UNSPEC,<br>	BPF_MAP_TYPE_HASH,<br>	BPF_MAP_TYPE_ARRAY,<br>	BPF_MAP_TYPE_PROG_ARRAY,<br>	BPF_MAP_TYPE_PERF_EVENT_ARRAY,<br>	BPF_MAP_TYPE_PERCPU_HASH,<br>	BPF_MAP_TYPE_PERCPU_ARRAY,<br>	BPF_MAP_TYPE_STACK_TRACE,<br>	BPF_MAP_TYPE_CGROUP_ARRAY,<br>	BPF_MAP_TYPE_LRU_HASH,<br>	BPF_MAP_TYPE_LRU_PERCPU_HASH,<br>	BPF_MAP_TYPE_LPM_TRIE,<br>	BPF_MAP_TYPE_ARRAY_OF_MAPS,<br>	BPF_MAP_TYPE_HASH_OF_MAPS,<br>	BPF_MAP_TYPE_DEVMAP,<br>	BPF_MAP_TYPE_SOCKMAP,<br>	BPF_MAP_TYPE_CPUMAP,<br>	BPF_MAP_TYPE_XSKMAP,<br>	BPF_MAP_TYPE_SOCKHASH,<br>	BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,<br>	<span class="hljs-comment">/* BPF_MAP_TYPE_CGROUP_STORAGE is available to bpf programs attaching</span><br><span class="hljs-comment">	 * to a cgroup. The newer BPF_MAP_TYPE_CGRP_STORAGE is available to</span><br><span class="hljs-comment">	 * both cgroup-attached and other progs and supports all functionality</span><br><span class="hljs-comment">	 * provided by BPF_MAP_TYPE_CGROUP_STORAGE. So mark</span><br><span class="hljs-comment">	 * BPF_MAP_TYPE_CGROUP_STORAGE deprecated.</span><br><span class="hljs-comment">	 */</span><br>	BPF_MAP_TYPE_CGROUP_STORAGE = BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,<br>	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,<br>	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,<br>	BPF_MAP_TYPE_QUEUE,<br>	BPF_MAP_TYPE_STACK,<br>	BPF_MAP_TYPE_SK_STORAGE,<br>	BPF_MAP_TYPE_DEVMAP_HASH,<br>	BPF_MAP_TYPE_STRUCT_OPS,<br>	BPF_MAP_TYPE_RINGBUF,<br>	BPF_MAP_TYPE_INODE_STORAGE,<br>	BPF_MAP_TYPE_TASK_STORAGE,<br>	BPF_MAP_TYPE_BLOOM_FILTER,<br>	BPF_MAP_TYPE_USER_RINGBUF,<br>	BPF_MAP_TYPE_CGRP_STORAGE,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>常用的主要是以下几种类型：</p>
<ul>
<li><code>BPF_MAP_TYPE_HASH</code>：以哈希表形式存储键值对，比较常规</li>
<li><code>BPF_MAP_TYPE_ARRAY</code>：以数组形式存储键值对，<strong>key 即为数组下标，对应的 value 皆初始化为 0</strong></li>
<li><code>BPF_MAP_TYPE_PROG_ARRAY</code>：特殊的数组映射，<strong>value 为其他 eBPF 程序的文件描述符</strong></li>
<li><code>BPF_MAP_TYPE_STACK</code>：以栈形式存储数据</li>
</ul>
<h3 id="map-wrapper"><a href="#map-wrapper" class="headerlink" title="map wrapper"></a>map wrapper</h3><h1 id="0x02-bpf-系统调用"><a href="#0x02-bpf-系统调用" class="headerlink" title="0x02.bpf 系统调用"></a>0x02.bpf 系统调用</h1><p>我们对 eBPF 所有的操作其实都是通过 <code>bpf</code> 系统调用来完成的，其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span>;<br></code></pre></td></tr></table></figure>

<h2 id="一、bpf-attr-结构体"><a href="#一、bpf-attr-结构体" class="headerlink" title="一、bpf_attr 结构体"></a>一、bpf_attr 结构体</h2><p>bpf 系统调用中的第二个参数是指向联合体 <code>bpf_attr</code> 的指针，定义于 <code>kernel/bpf/syscall.c</code> 中如下，对于不同的 <code>cmd</code>  而言其含义不同，因此这里是一个由多个结构体构成的联合体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_MAP_CREATE 命令所使用的匿名结构体 */</span><br>		__u32	map_type;	<span class="hljs-comment">/* one of enum bpf_map_type */</span><br>		__u32	key_size;	<span class="hljs-comment">/* key 按字节计的大小 */</span><br>		__u32	value_size;	<span class="hljs-comment">/* value 按字节计的大小 */</span><br>		__u32	max_entries;	<span class="hljs-comment">/* map 中最大的 entries 数量 */</span><br>		__u32	map_flags;	<span class="hljs-comment">/* BPF_MAP_CREATE 相关的</span><br><span class="hljs-comment">					 * 在上面定义的 flags.</span><br><span class="hljs-comment">					 */</span><br>		__u32	inner_map_fd;	<span class="hljs-comment">/* 指向内部 map 的 fd */</span><br>		__u32	numa_node;	<span class="hljs-comment">/* numa node (仅当设置了</span><br><span class="hljs-comment">					 * BPF_F_NUMA_NODE 时有效).</span><br><span class="hljs-comment">					 */</span><br>		<span class="hljs-type">char</span>	map_name[BPF_OBJ_NAME_LEN];<br>		__u32	map_ifindex;	<span class="hljs-comment">/* ifindex of netdev to create on */</span><br>		__u32	btf_fd;		<span class="hljs-comment">/* 指向一个 BTF 类型数据的 fd */</span><br>		__u32	btf_key_type_id;	<span class="hljs-comment">/* BTF type_id of the key */</span><br>		__u32	btf_value_type_id;	<span class="hljs-comment">/* BTF type_id of the value */</span><br>		__u32	btf_vmlinux_value_type_id;<span class="hljs-comment">/* BTF type_id of a kernel-</span><br><span class="hljs-comment">						   * struct stored as the</span><br><span class="hljs-comment">						   * map value</span><br><span class="hljs-comment">						   */</span><br>		<span class="hljs-comment">/* Any per-map-type extra fields</span><br><span class="hljs-comment">		 *</span><br><span class="hljs-comment">		 * BPF_MAP_TYPE_BLOOM_FILTER - 最低 4 位指示了</span><br><span class="hljs-comment">		 * 哈希函数的数量(若为 0, bloom filter 将默认</span><br><span class="hljs-comment">		 * 使用 5 个哈希函数).</span><br><span class="hljs-comment">		 */</span><br>		__u64	map_extra;<br>	&#125;;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_MAP_*_ELEM 命令所使用的匿名结构体 */</span><br>		__u32		map_fd;<br>		__aligned_u64	key;<br>		<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>			__aligned_u64 value;<br>			__aligned_u64 next_key;<br>		&#125;;<br>		__u64		flags;<br>	&#125;;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_MAP_*_BATCH 命令所使用的匿名结构体 */</span><br>		__aligned_u64	in_batch;	<span class="hljs-comment">/* start batch,</span><br><span class="hljs-comment">						 * NULL to start from beginning</span><br><span class="hljs-comment">						 */</span><br>		__aligned_u64	out_batch;	<span class="hljs-comment">/* output: next start batch */</span><br>		__aligned_u64	keys;<br>		__aligned_u64	values;<br>		__u32		count;		<span class="hljs-comment">/* input/output:</span><br><span class="hljs-comment">						 * input: # of key/value</span><br><span class="hljs-comment">						 * elements</span><br><span class="hljs-comment">						 * output: # of filled elements</span><br><span class="hljs-comment">						 */</span><br>		__u32		map_fd;<br>		__u64		elem_flags;<br>		__u64		flags;<br>	&#125; batch;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_LOAD 命令所使用的匿名结构体 */</span><br>		__u32		prog_type;	<span class="hljs-comment">/* one of enum bpf_prog_type */</span><br>		__u32		insn_cnt;<br>		__aligned_u64	insns;<br>		__aligned_u64	license;<br>		__u32		log_level;	<span class="hljs-comment">/* verbosity level of verifier */</span><br>		__u32		log_size;	<span class="hljs-comment">/* size of user buffer */</span><br>		__aligned_u64	log_buf;	<span class="hljs-comment">/* user supplied buffer */</span><br>		__u32		kern_version;	<span class="hljs-comment">/* not used */</span><br>		__u32		prog_flags;<br>		<span class="hljs-type">char</span>		prog_name[BPF_OBJ_NAME_LEN];<br>		__u32		prog_ifindex;	<span class="hljs-comment">/* ifindex of netdev to prep for */</span><br>		<span class="hljs-comment">/* For some prog types expected attach type must be known at</span><br><span class="hljs-comment">		 * load time to verify attach type specific parts of prog</span><br><span class="hljs-comment">		 * (context accesses, allowed helpers, etc).</span><br><span class="hljs-comment">		 */</span><br>		__u32		expected_attach_type;<br>		__u32		prog_btf_fd;	<span class="hljs-comment">/* fd pointing to BTF type data */</span><br>		__u32		func_info_rec_size;	<span class="hljs-comment">/* userspace bpf_func_info size */</span><br>		__aligned_u64	func_info;	<span class="hljs-comment">/* func info */</span><br>		__u32		func_info_cnt;	<span class="hljs-comment">/* number of bpf_func_info records */</span><br>		__u32		line_info_rec_size;	<span class="hljs-comment">/* userspace bpf_line_info size */</span><br>		__aligned_u64	line_info;	<span class="hljs-comment">/* line info */</span><br>		__u32		line_info_cnt;	<span class="hljs-comment">/* number of bpf_line_info records */</span><br>		__u32		attach_btf_id;	<span class="hljs-comment">/* in-kernel BTF type id to attach to */</span><br>		<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>			<span class="hljs-comment">/* valid prog_fd to attach to bpf prog */</span><br>			__u32		attach_prog_fd;<br>			<span class="hljs-comment">/* or valid module BTF object fd or 0 to attach to vmlinux */</span><br>			__u32		attach_btf_obj_fd;<br>		&#125;;<br>		__u32		core_relo_cnt;	<span class="hljs-comment">/* number of bpf_core_relo */</span><br>		__aligned_u64	fd_array;	<span class="hljs-comment">/* array of FDs */</span><br>		__aligned_u64	core_relos;<br>		__u32		core_relo_rec_size; <span class="hljs-comment">/* sizeof(struct bpf_core_relo) */</span><br>	&#125;;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_OBJ_* 命令所使用的匿名结构体 */</span><br>		__aligned_u64	pathname;<br>		__u32		bpf_fd;<br>		__u32		file_flags;<br>	&#125;;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_ATTACH/DETACH 命令所使用的匿名结构体 */</span><br>		__u32		target_fd;	<span class="hljs-comment">/* container object to attach to */</span><br>		__u32		attach_bpf_fd;	<span class="hljs-comment">/* eBPF program to attach */</span><br>		__u32		attach_type;<br>		__u32		attach_flags;<br>		__u32		replace_bpf_fd;	<span class="hljs-comment">/* previously attached eBPF</span><br><span class="hljs-comment">						 * program to replace if</span><br><span class="hljs-comment">						 * BPF_F_REPLACE is used</span><br><span class="hljs-comment">						 */</span><br>	&#125;;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_TEST_RUN 命令所使用的匿名结构体 */</span><br>		__u32		prog_fd;<br>		__u32		retval;<br>		__u32		data_size_in;	<span class="hljs-comment">/* input: len of data_in */</span><br>		__u32		data_size_out;	<span class="hljs-comment">/* input/output: len of data_out</span><br><span class="hljs-comment">						 *   returns ENOSPC if data_out</span><br><span class="hljs-comment">						 *   is too small.</span><br><span class="hljs-comment">						 */</span><br>		__aligned_u64	data_in;<br>		__aligned_u64	data_out;<br>		__u32		repeat;<br>		__u32		duration;<br>		__u32		ctx_size_in;	<span class="hljs-comment">/* input: len of ctx_in */</span><br>		__u32		ctx_size_out;	<span class="hljs-comment">/* input/output: len of ctx_out</span><br><span class="hljs-comment">						 *   returns ENOSPC if ctx_out</span><br><span class="hljs-comment">						 *   is too small.</span><br><span class="hljs-comment">						 */</span><br>		__aligned_u64	ctx_in;<br>		__aligned_u64	ctx_out;<br>		__u32		flags;<br>		__u32		cpu;<br>		__u32		batch_size;<br>	&#125; test;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_*_GET_*_ID 命令所使用的匿名结构体 */</span><br>		<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>			__u32		start_id;<br>			__u32		prog_id;<br>			__u32		map_id;<br>			__u32		btf_id;<br>			__u32		link_id;<br>		&#125;;<br>		__u32		next_id;<br>		__u32		open_flags;<br>	&#125;;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_OBJ_GET_INFO_BY_FD 命令所使用的匿名结构体 */</span><br>		__u32		bpf_fd;<br>		__u32		info_len;<br>		__aligned_u64	info;<br>	&#125; info;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* BPF_PROG_QUERY 命令所使用的匿名结构体 */</span><br>		__u32		target_fd;	<span class="hljs-comment">/* container object to query */</span><br>		__u32		attach_type;<br>		__u32		query_flags;<br>		__u32		attach_flags;<br>		__aligned_u64	prog_ids;<br>		__u32		prog_cnt;<br>		<span class="hljs-comment">/* output: per-program attach_flags.</span><br><span class="hljs-comment">		 * not allowed to be set during effective query.</span><br><span class="hljs-comment">		 */</span><br>		__aligned_u64	prog_attach_flags;<br>	&#125; query;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* anonymous struct used by BPF_RAW_TRACEPOINT_OPEN command */</span><br>		__u64 name;<br>		__u32 prog_fd;<br>	&#125; raw_tracepoint;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* anonymous struct for BPF_BTF_LOAD */</span><br>		__aligned_u64	btf;<br>		__aligned_u64	btf_log_buf;<br>		__u32		btf_size;<br>		__u32		btf_log_size;<br>		__u32		btf_log_level;<br>	&#125;;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>		__u32		pid;		<span class="hljs-comment">/* input: pid */</span><br>		__u32		fd;		<span class="hljs-comment">/* input: fd */</span><br>		__u32		flags;		<span class="hljs-comment">/* input: flags */</span><br>		__u32		buf_len;	<span class="hljs-comment">/* input/output: buf len */</span><br>		__aligned_u64	buf;		<span class="hljs-comment">/* input/output:</span><br><span class="hljs-comment">						 *   tp_name for tracepoint</span><br><span class="hljs-comment">						 *   symbol for kprobe</span><br><span class="hljs-comment">						 *   filename for uprobe</span><br><span class="hljs-comment">						 */</span><br>		__u32		prog_id;	<span class="hljs-comment">/* output: prod_id */</span><br>		__u32		fd_type;	<span class="hljs-comment">/* output: BPF_FD_TYPE_* */</span><br>		__u64		probe_offset;	<span class="hljs-comment">/* output: probe_offset */</span><br>		__u64		probe_addr;	<span class="hljs-comment">/* output: probe_addr */</span><br>	&#125; task_fd_query;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_LINK_CREATE command */</span><br>		__u32		prog_fd;	<span class="hljs-comment">/* eBPF program to attach */</span><br>		<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>			__u32		target_fd;	<span class="hljs-comment">/* object to attach to */</span><br>			__u32		target_ifindex; <span class="hljs-comment">/* target ifindex */</span><br>		&#125;;<br>		__u32		attach_type;	<span class="hljs-comment">/* attach type */</span><br>		__u32		flags;		<span class="hljs-comment">/* extra flags */</span><br>		<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>			__u32		target_btf_id;	<span class="hljs-comment">/* btf_id of target to attach to */</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>				__aligned_u64	iter_info;	<span class="hljs-comment">/* extra bpf_iter_link_info */</span><br>				__u32		iter_info_len;	<span class="hljs-comment">/* iter_info length */</span><br>			&#125;;<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>				<span class="hljs-comment">/* black box user-provided value passed through</span><br><span class="hljs-comment">				 * to BPF program at the execution time and</span><br><span class="hljs-comment">				 * accessible through bpf_get_attach_cookie() BPF helper</span><br><span class="hljs-comment">				 */</span><br>				__u64		bpf_cookie;<br>			&#125; perf_event;<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>				__u32		flags;<br>				__u32		cnt;<br>				__aligned_u64	syms;<br>				__aligned_u64	addrs;<br>				__aligned_u64	cookies;<br>			&#125; kprobe_multi;<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>				<span class="hljs-comment">/* this is overlaid with the target_btf_id above. */</span><br>				__u32		target_btf_id;<br>				<span class="hljs-comment">/* black box user-provided value passed through</span><br><span class="hljs-comment">				 * to BPF program at the execution time and</span><br><span class="hljs-comment">				 * accessible through bpf_get_attach_cookie() BPF helper</span><br><span class="hljs-comment">				 */</span><br>				__u64		cookie;<br>			&#125; tracing;<br>		&#125;;<br>	&#125; link_create;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_LINK_UPDATE command */</span><br>		__u32		link_fd;	<span class="hljs-comment">/* link fd */</span><br>		<span class="hljs-comment">/* new program fd to update link with */</span><br>		__u32		new_prog_fd;<br>		__u32		flags;		<span class="hljs-comment">/* extra flags */</span><br>		<span class="hljs-comment">/* expected link&#x27;s program fd; is specified only if</span><br><span class="hljs-comment">		 * BPF_F_REPLACE flag is set in flags */</span><br>		__u32		old_prog_fd;<br>	&#125; link_update;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>		__u32		link_fd;<br>	&#125; link_detach;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_ENABLE_STATS command */</span><br>		__u32		type;<br>	&#125; enable_stats;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_ITER_CREATE command */</span><br>		__u32		link_fd;<br>		__u32		flags;<br>	&#125; iter_create;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">/* struct used by BPF_PROG_BIND_MAP command */</span><br>		__u32		prog_fd;<br>		__u32		map_fd;<br>		__u32		flags;		<span class="hljs-comment">/* extra flags */</span><br>	&#125; prog_bind_map;<br><br>&#125; __attribute__((aligned(<span class="hljs-number">8</span>)));<br></code></pre></td></tr></table></figure>

<h2 id="二、-sys-bpf-：bpf-系统调用的核心函数"><a href="#二、-sys-bpf-：bpf-系统调用的核心函数" class="headerlink" title="二、__sys_bpf()：bpf 系统调用的核心函数"></a>二、__sys_bpf()：bpf 系统调用的核心函数</h2><p>bpf 系统调用定义于 <code>kernel/bpf/syscall.c</code> 中，最终调用到 <code>__sys_bpf()</code> ，其核心主要是一个巨大的 switch，根据 cmd 的不同进行不同的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __sys_bpf(<span class="hljs-type">int</span> cmd, <span class="hljs-type">bpfptr_t</span> uattr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)<br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span>;</span><br>	<span class="hljs-type">bool</span> capable;<br>	<span class="hljs-type">int</span> err;<br><br>	capable = bpf_capable() || !sysctl_unprivileged_bpf_disabled;<br><br>	<span class="hljs-comment">/* Intent here is for unprivileged_bpf_disabled to block key object</span><br><span class="hljs-comment">	 * creation commands for unprivileged users; other actions depend</span><br><span class="hljs-comment">	 * of fd availability and access to bpffs, so are dependent on</span><br><span class="hljs-comment">	 * object creation success.  Capabilities are later verified for</span><br><span class="hljs-comment">	 * operations such as load and map create, so even with unprivileged</span><br><span class="hljs-comment">	 * BPF disabled, capability checks are still carried out for these</span><br><span class="hljs-comment">	 * and other operations.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!capable &amp;&amp;<br>	    (cmd == BPF_MAP_CREATE || cmd == BPF_PROG_LOAD))<br>		<span class="hljs-keyword">return</span> -EPERM;<br><br>	err = bpf_check_uarg_tail_zero(uattr, <span class="hljs-keyword">sizeof</span>(attr), size);<br>	<span class="hljs-keyword">if</span> (err)<br>		<span class="hljs-keyword">return</span> err;<br>	size = <span class="hljs-type">min_t</span>(u32, size, <span class="hljs-keyword">sizeof</span>(attr));<br><br>	<span class="hljs-comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span><br>	<span class="hljs-built_in">memset</span>(&amp;attr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(attr));<br>	<span class="hljs-keyword">if</span> (copy_from_bpfptr(&amp;attr, uattr, size) != <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> -EFAULT;<br><br>	err = security_bpf(cmd, &amp;attr, size);<br>	<span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> err;<br><br>	<span class="hljs-keyword">switch</span> (cmd) &#123;<br>	<span class="hljs-keyword">case</span> BPF_MAP_CREATE:<br>		err = map_create(&amp;attr);<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-comment">//...</span><br>	<span class="hljs-keyword">default</span>:<br>		err = -EINVAL;<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> err;<br>&#125;<br><br>SYSCALL_DEFINE3(bpf, <span class="hljs-type">int</span>, cmd, <span class="hljs-keyword">union</span> bpf_attr __user *, uattr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, size)<br>&#123;<br>	<span class="hljs-keyword">return</span> __sys_bpf(cmd, USER_BPFPTR(uattr), size);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="0x03-raw-eBPF-程序编写入门"><a href="#0x03-raw-eBPF-程序编写入门" class="headerlink" title="0x03. raw eBPF 程序编写入门"></a>0x03. raw eBPF 程序编写入门</h1><p>由于 eBPF 相关的各种操作实际上都是通过 <code>bpf()</code> 系统调用完成的，因此我们可以通过直接调用 <code>bpf()</code> 系统调用来感受 eBPF 的魅力：）</p>
<blockquote>
<p>注：在 eBPF 的实际应用中很少会直接写 raw BPF 指令，而是会借助诸如 <code>bcc</code> 这样的各类工具，不过那不是这一篇博客的重点：）</p>
<blockquote>
<p>有时间的话再在后面的博客中简单讲讲（</p>
</blockquote>
</blockquote>
<blockquote>
<p>注2：内核在 <code>/samples/bpf</code> 目录下提供了很多帮助我们快速编写 eBPF 程序的工具与一些示例，其中 <code>/samples/bpf/bpf_insn.h</code> 文件<strong>提供了封装好的各类指令模板</strong> ：）</p>
</blockquote>
<h2 id="一、eBPF-指令格式"><a href="#一、eBPF-指令格式" class="headerlink" title="一、eBPF 指令格式"></a>一、eBPF 指令格式</h2><p>eBPF 为优雅的 RISC 指令集（<del>这就要说到 Intel CISC 的含屎量了</del>），单条指令长度为 8 字节，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>	__u8	code;		<span class="hljs-comment">/* 操作码 */</span><br>	__u8	dst_reg:<span class="hljs-number">4</span>;	<span class="hljs-comment">/* 目的寄存器 */</span><br>	__u8	src_reg:<span class="hljs-number">4</span>;	<span class="hljs-comment">/* 源寄存器 */</span><br>	__s16	off;		<span class="hljs-comment">/* 有符号偏移 */</span><br>	__s32	imm;		<span class="hljs-comment">/* 有符号立即数 */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>而 eBPF 实际上有两种编码模式：</p>
<ul>
<li>基础编码，单条指令为 64 bit</li>
<li>宽指令编码， <em>在基础编码后添加一个 64bit 的立即数</em> ，单条指令为 128 bit</li>
</ul>
<p>基础编码的指令格式如下：</p>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">8 bits</th>
<th align="center">4 bits</th>
<th align="center">4 bits</th>
<th align="center">16 bits</th>
<th align="center">32 bits</th>
</tr>
</thead>
<tbody><tr>
<td align="center">含义</td>
<td align="center">opcode(操作码)</td>
<td align="center">dst_reg(目的寄存器)</td>
<td align="center">src_reg(源寄存器)</td>
<td align="center">off(有符号偏移)</td>
<td align="center">imm(有符号32位立即数)</td>
</tr>
</tbody></table>
<p>eBPF 指令中的 <code>opcode</code> 域长度为 8 bit，其中<strong>低 3 位固定表示指令类型</strong>，剩下的高 5 位根据类型不同用途也不同</p>
<p>指令类型如下表所示： </p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_LD</td>
<td align="center">0x00</td>
<td align="center">只能用于宽指令，从 <code>imm64</code> 中加载数据到寄存器</td>
</tr>
<tr>
<td align="center">BPF_LDX</td>
<td align="center">0x01</td>
<td align="center">从内存中加载数据到 <code>dst_reg</code></td>
</tr>
<tr>
<td align="center">BPF_ST</td>
<td align="center">0x02</td>
<td align="center">把 <code>imm32</code> 数据保存到内存中</td>
</tr>
<tr>
<td align="center">BPF_STX</td>
<td align="center">0x03</td>
<td align="center">把 <code>src_reg</code> 寄存器数据保存到内存</td>
</tr>
<tr>
<td align="center">BPF_ALU</td>
<td align="center">0x04</td>
<td align="center">32bit 算术运算</td>
</tr>
<tr>
<td align="center">BPF_JMP</td>
<td align="center">0x05</td>
<td align="center">64bit 跳转操作</td>
</tr>
<tr>
<td align="center">BPF_JMP32</td>
<td align="center">0x06</td>
<td align="center">32bit 跳转操作</td>
</tr>
<tr>
<td align="center">BPF_ALU64</td>
<td align="center">0x07</td>
<td align="center">64bit 算术运算</td>
</tr>
</tbody></table>
<blockquote>
<p>注：在 classic BPF 中 <code>0x06</code> 为函数返回指令 <code>BPF_RET</code> ，<code>0x07</code> 为寄存器交换指令 <code>BPF_MISC</code> （cBPF 只有 <code>A</code> 和 <code>X</code> 两个寄存器）</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/05/29/ctkw1sIlfAYp8Hz.png" srcset="/img/loading.gif" lazyload alt="我超,__！.png"></p>
<h3 id="算术-跳转指令"><a href="#算术-跳转指令" class="headerlink" title="算术 &amp; 跳转指令"></a>算术 &amp; 跳转指令</h3><p>对于算术 &amp; 跳转指令而言由高位到低位分为三个部分：</p>
<table>
<thead>
<tr>
<th align="center">4 bit</th>
<th align="center">1 bit</th>
<th align="center">3 bit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">operation code （操作代码）</td>
<td align="center">source（源）</td>
<td align="center">instruction class （指令类型）</td>
</tr>
</tbody></table>
<h4 id="①-操作代码"><a href="#①-操作代码" class="headerlink" title="① 操作代码"></a>① 操作代码</h4><p>opcode 的<strong>最高 4 bit 用来保存操作代码</strong>，对于算术指令而言有如下类型：</p>
<table>
<thead>
<tr>
<th align="center">指令类型</th>
<th align="center">操作代码</th>
<th align="center">值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_ADD</td>
<td align="center">0x00</td>
<td>dst +&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_SUB</td>
<td align="center">0x10</td>
<td>dst -&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_MUL</td>
<td align="center">0x20</td>
<td>dst *&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_DIV</td>
<td align="center">0x30</td>
<td>dst &#x2F;&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_OR</td>
<td align="center">0x40</td>
<td>dst |&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_AND</td>
<td align="center">0x50</td>
<td>dst &amp;&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_LSH</td>
<td align="center">0x60</td>
<td>dst &lt;&lt;&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_RSH</td>
<td align="center">0x70</td>
<td>dst &gt;&gt;&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_NEG</td>
<td align="center">0x80</td>
<td>dst &#x3D; ~src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_MOD</td>
<td align="center">0x90</td>
<td>dst %&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_XOR</td>
<td align="center">0xA0</td>
<td>dst ^&#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_MOV</td>
<td align="center">0xB0</td>
<td>dst &#x3D; src</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_ARSH</td>
<td align="center">0xC0</td>
<td>算术右移操作（正数补 0 负数补 1 ）</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_END</td>
<td align="center">0xD0</td>
<td>字节序转换</td>
</tr>
</tbody></table>
<p>对于跳转指令而言有如下类型：</p>
<table>
<thead>
<tr>
<th align="center"><strong>指令类型</strong></th>
<th align="center"><strong>操作代码</strong></th>
<th align="center"><strong>值</strong></th>
<th><strong>描述</strong></th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_JMP</td>
<td align="center">BPF_JA</td>
<td align="center">0x00</td>
<td>PC +&#x3D; off</td>
<td>仅用于 BPF_JMP</td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JEQ</td>
<td align="center">0x10</td>
<td>PC +&#x3D; off if dst &#x3D;&#x3D; src</td>
<td></td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JGT</td>
<td align="center">0x20</td>
<td>PC +&#x3D; off if dst &gt; src</td>
<td></td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JGE</td>
<td align="center">0x30</td>
<td>PC +&#x3D; off if dst &gt;&#x3D; src</td>
<td></td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JSET</td>
<td align="center">0x40</td>
<td>PC +&#x3D; off if dst &amp; src</td>
<td></td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JNE</td>
<td align="center">0x50</td>
<td>PC +&#x3D; off if dst !&#x3D; src</td>
<td>仅 eBPF：不等时跳转</td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JSGT</td>
<td align="center">0x60</td>
<td>PC +&#x3D; off if dst &gt; src</td>
<td>仅 eBPF：有符号 ‘&gt;’</td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JSGE</td>
<td align="center">0x70</td>
<td>PC +&#x3D; off if dst &gt;&#x3D; src</td>
<td>仅 eBPF：有符号 ‘&gt;&#x3D;’</td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_CALL</td>
<td align="center">0x80</td>
<td>函数调用</td>
<td>仅 eBPF：函数调用</td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_EXIT</td>
<td align="center">0x90</td>
<td>函数或者程序返回</td>
<td>仅 eBPF：函数返回</td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JLT</td>
<td align="center">0xA0</td>
<td>PC +&#x3D; off if dst &lt; src</td>
<td>仅 eBPF：无符号 ‘&lt;’</td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JLE</td>
<td align="center">0xB0</td>
<td>PC +&#x3D; off if dst &lt;&#x3D; src</td>
<td>仅 eBPF：无符号 ‘&lt;&#x3D;’</td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JSLT</td>
<td align="center">0xC0</td>
<td>PC +&#x3D; off if dst &lt; src</td>
<td>仅 eBPF：有符号 ‘&lt;’</td>
</tr>
<tr>
<td align="center">BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_JSLE</td>
<td align="center">0xD0</td>
<td>PC +&#x3D; off if dst &lt;&#x3D; src</td>
<td>仅 eBPF：有符号 ‘&lt;&#x3D;’</td>
</tr>
</tbody></table>
<h4 id="②-源"><a href="#②-源" class="headerlink" title="② 源"></a>② 源</h4><p>opcode 中间的一个 bit 用来表示 <strong>源</strong> ，对于普通的跳转与算术指令而言含义如下表：</p>
<table>
<thead>
<tr>
<th align="center">指令类型</th>
<th align="center">源</th>
<th align="center">值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64 &#x2F; BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_K</td>
<td align="center">0x00</td>
<td>使用32-bit <code>imm32</code> 作为源操作数</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64 &#x2F; BPF_JMP &#x2F; BPF_JMP64</td>
<td align="center">BPF_X</td>
<td align="center">0x08</td>
<td>使用源寄存器 （<code>src_reg</code>） 作为源操作数</td>
</tr>
</tbody></table>
<p>对于 <code>BPF_END</code> 操作码而言含义如下：</p>
<table>
<thead>
<tr>
<th align="center">指令类型</th>
<th align="center">操作代码</th>
<th align="center">源</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_END</td>
<td align="center">BPF_TO_LE</td>
<td>0x00</td>
<td>转为小端序</td>
</tr>
<tr>
<td align="center">BPF_ALU &#x2F; BPF_ALU64</td>
<td align="center">BPF_END</td>
<td align="center">BPF_TO_BE</td>
<td>0x08</td>
<td>转为大端序</td>
</tr>
</tbody></table>
<h3 id="Load-Store-指令"><a href="#Load-Store-指令" class="headerlink" title="Load &amp; Store 指令"></a>Load &amp; Store 指令</h3><p>对于 Load &amp; Store 指令而言，opcode 由高到低分为如下三部分：</p>
<table>
<thead>
<tr>
<th align="center">3 bits</th>
<th align="center">2 bit</th>
<th align="center">3 bits</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mode（模式）</td>
<td align="center">size（大小）</td>
<td align="center">instruction class （指令类型）</td>
</tr>
</tbody></table>
<h4 id="①-大小"><a href="#①-大小" class="headerlink" title="① 大小"></a>① 大小</h4><p> Load &amp; Store 指令的 <strong>size</strong> 域用来表示<strong>操作的字节数</strong>：</p>
<blockquote>
<p>不知道为啥排序设为 4 2 1 8 :（</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">大小</th>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_W</td>
<td align="center">0x00</td>
<td align="center">单字（4 字节）</td>
</tr>
<tr>
<td align="center">BPF_H</td>
<td align="center">0x08</td>
<td align="center">半字（2字节）</td>
</tr>
<tr>
<td align="center">BPF_B</td>
<td align="center">0x10</td>
<td align="center">单字节（1字节）</td>
</tr>
<tr>
<td align="center">BPF_DW</td>
<td align="center">0x18</td>
<td align="center">双字（8字节）</td>
</tr>
</tbody></table>
<h4 id="②-模式"><a href="#②-模式" class="headerlink" title="② 模式"></a>② 模式</h4><p> Load &amp; Store 指令的 <strong>mode</strong> 域用来表示<strong>操作的模式</strong>，也就是如何去操作指定大小的数据：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">值</th>
<th align="center">描述</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_IMM</td>
<td align="center">0x00</td>
<td align="center">64 位立即数</td>
<td align="center">eBPF 为64 位立即数，cBPF 中为 32 位</td>
</tr>
<tr>
<td align="center">BPF_ABS</td>
<td align="center">0x20</td>
<td align="center">数据包直接访问</td>
<td align="center">兼容自 cBPF 指令。R6 作为隐式输入，存放 <code>struct *sk_buff</code> ；R0 作为隐式输出，存放包中读出数据；R1 ~ R5 作为 scratch registers，在每次调用后会被清空</td>
</tr>
<tr>
<td align="center">BPF_IND</td>
<td align="center">0x40</td>
<td align="center">数据包间接访问</td>
<td align="center">同 BPF_ABS</td>
</tr>
<tr>
<td align="center">BPF_MEM</td>
<td align="center">0x60</td>
<td align="center">赋值给 *(size *)(dst_reg + off)</td>
<td align="center">标准 load &amp; store 操作</td>
</tr>
<tr>
<td align="center">BPF_LEN</td>
<td align="center">0x80</td>
<td align="center">保留指令</td>
<td align="center">仅用于 cBPF</td>
</tr>
<tr>
<td align="center">BPF_MSH</td>
<td align="center">0xA0</td>
<td align="center">保留指令</td>
<td align="center">仅用于 cBPF</td>
</tr>
<tr>
<td align="center">BPF_XADD</td>
<td align="center">0xC0</td>
<td align="center">原子操作，*(无符号类型 *)(dst_reg + off16) 运算&#x3D; src_reg</td>
<td align="center">仅用于 eBPF，不支持 1 &#x2F; 2 字节曹祖</td>
</tr>
</tbody></table>
<p>对于 <code>BPF_XADD</code>， <code>imm32</code> 域被用来表示原子操作的运算类型：</p>
<table>
<thead>
<tr>
<th align="center">imm32</th>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_ADD</td>
<td align="center">0x00</td>
<td align="center">原子加</td>
</tr>
<tr>
<td align="center">BPF_OR</td>
<td align="center">0x40</td>
<td align="center">原子或</td>
</tr>
<tr>
<td align="center">BPF_AND</td>
<td align="center">0x50</td>
<td align="center">原子与</td>
</tr>
<tr>
<td align="center">BPF_XOR</td>
<td align="center">0xa0</td>
<td align="center">原子异或</td>
</tr>
</tbody></table>
<blockquote>
<p><del>反正👴看得是有点头大的</del></p>
</blockquote>
<h2 id="二、raw-eBPF-程序编写"><a href="#二、raw-eBPF-程序编写" class="headerlink" title="二、raw eBPF 程序编写"></a>二、raw eBPF 程序编写</h2><p>一个最简单的 eBPF 程序<strong>便是一个</strong> <code>bpf_insn</code> <strong>结构体数组</strong>，我们可以直接在用户态下编写一个 <code>bpf_insn</code> 结构体数组并直接调用 <code>bpf()</code> 系统调用完成 eBPF 程序的创建与挂载：）</p>
<p>最简单的方法便是直接按如下形式定义一条基本的 eBPF 指令：</p>
<blockquote>
<p> 注：这里可以直接使用内核源码目录下提供的 <code>/samples/bpf/bpf_insn.h</code> ：）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)        \</span><br><span class="hljs-meta">    ((struct bpf_insn) &#123;                              \</span><br><span class="hljs-meta">        .code         = CODE,                         \</span><br><span class="hljs-meta">        .dst_reg     = DST,                           \</span><br><span class="hljs-meta">        .src_reg     = SRC,                           \</span><br><span class="hljs-meta">        .off         = OFF,                           \</span><br><span class="hljs-meta">        .imm         = IMM                            \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure>

<p>之后直接开写就行，需要注意的是我们应当以一条 <code>跳转结束指令</code> （opcode 为 <code>BPF_JMP | BPF_EXIT</code> ）作为结尾，下面是一个🌰：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span><br><span class="hljs-meta">    ((struct bpf_insn) &#123;                                \</span><br><span class="hljs-meta">        .code        = CODE,                            \</span><br><span class="hljs-meta">        .dst_reg     = DST,                             \</span><br><span class="hljs-meta">        .src_reg     = SRC,                             \</span><br><span class="hljs-meta">        .off         = OFF,                             \</span><br><span class="hljs-meta">        .imm         = IMM                              \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">test_bpf_prog</span>[] =</span> &#123;<br>    BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x114514</span>),<br>    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST_BPF_LOG_SZ 0x10000</span><br><span class="hljs-type">char</span> test_bpf_log_buf[TEST_BPF_LOG_SZ] = &#123; <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">test_bpf_attr</span> =</span> &#123;<br>    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,<br>    .insns = (<span class="hljs-type">uint64_t</span>) &amp;test_bpf_prog,<br>    .insn_cnt = <span class="hljs-keyword">sizeof</span>(test_bpf_prog) / <span class="hljs-keyword">sizeof</span>(test_bpf_prog[<span class="hljs-number">0</span>]),<br>    .license = (<span class="hljs-type">uint64_t</span>) <span class="hljs-string">&quot;GPL&quot;</span>,<br>    .log_level = <span class="hljs-number">2</span>,<br>    .log_buf = (<span class="hljs-type">uint64_t</span>) test_bpf_log_buf,<br>    .log_size = TEST_BPF_LOG_SZ,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="hljs-keyword">sizeof</span>(*attr));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">int</span> test_bpf_prog_fd;<br>    <span class="hljs-type">char</span> *err_msg;<br><br>    <span class="hljs-comment">/* load bpf prog into kernel */</span><br>    test_bpf_prog_fd = bpf(BPF_PROG_LOAD, &amp;test_bpf_attr);<br>    <span class="hljs-keyword">if</span> (test_bpf_prog_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_msg = <span class="hljs-string">&quot;FAILED to load bpf program!&quot;</span>;<br>        <span class="hljs-keyword">goto</span> err_bpf_load;<br>    &#125;<br><br>    <span class="hljs-comment">/* output the log */</span><br>    <span class="hljs-built_in">puts</span>(test_bpf_log_buf);<br><br>    close(test_bpf_prog_fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err_bpf_load:<br>    <span class="hljs-built_in">puts</span>(test_bpf_log_buf);<br>err_socket:<br>    err_exit(err_msg);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>内核会将相关的运行日志写入到我们所指定的缓冲区当中，这里输出日志缓冲区可以看到内核成功地解析了我们的 eBPF 程序：</p>
<p><img src="https://s2.loli.net/2023/05/31/6wJAz7CSFG91DmQ.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="三、raw-eBPF-map-使用"><a href="#三、raw-eBPF-map-使用" class="headerlink" title="三、raw eBPF map 使用"></a>三、raw eBPF map 使用</h2><p>eBPF map 为以 <code>key→value</code> 映射格式存储数据的通用的数据存储结构，用于在不同程序之间共享数据，本节主要介绍 eBPF map 的基本用法</p>
<h3 id="创建-eBPF-map"><a href="#创建-eBPF-map" class="headerlink" title="创建 eBPF map"></a>创建 eBPF map</h3><p>我们可以通过 <code>BPF_MAP_CREATE</code> 命令创建一个新的 eBPF map，其会返回一个文件描述符作为该 map 的引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_create</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> map_type, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> key_size, </span><br><span class="hljs-params">               <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_entries)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_type = map_type,<br>        .key_size = key_size,<br>        .value_size = value_size,<br>        .max_entries = max_entries,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="更新-eBPF-map"><a href="#更新-eBPF-map" class="headerlink" title="更新 eBPF map"></a>更新 eBPF map</h3><p>我们可以通过 <code>BPF_MAP_UPDATE</code> 命令更新 map 中对应的 <code>key→value</code> 映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_update_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *value,<span class="hljs-type">uint64_t</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>        .flags = flags,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>flags 应当为如下之一：</p>
<table>
<thead>
<tr>
<th align="center">flags</th>
<th align="center">描述</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BPF_ANY</td>
<td align="center">有则更新，无则新建</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">BPF_NOEXIST</td>
<td align="center">仅在不存在时进行创建</td>
<td align="center">若已有对应的 key 则返回 <code>-EEXIST</code></td>
</tr>
<tr>
<td align="center">BPF_EXIST</td>
<td align="center">仅在存在时进行更新</td>
<td align="center">若无对应的 key 则返回 <code>-ENOENT</code></td>
</tr>
</tbody></table>
<p>在创建新映射时若 map 中映射数量已经达到 <code>max_entries</code> 则会返回 <code>E2BIG</code></p>
<h3 id="在-eBPF-map-中查找"><a href="#在-eBPF-map-中查找" class="headerlink" title="在 eBPF map 中查找"></a>在 eBPF map 中查找</h3><p>我们可以通过 <code>BPF_MAP_LOOKUP_ELEM</code> 命令查找 map 中是否存在对应的 key，若是则内核会将 value 拷贝到用户空间指定的 value 缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_lookup_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="遍历-eBPF-map"><a href="#遍历-eBPF-map" class="headerlink" title="遍历 eBPF map"></a>遍历 eBPF map</h3><p><code>BPF_MAP_GET_NEXT_KEY</code> 是一个非常有意思的命令，其会在 map 中查找我们所传入的 key，并将该 key 的下一个 key 拷贝回用户空间，若不存在该 key 则会返回 0 并拷贝 map 中第一个 key 到用户空间，若该 key 为最后一个 key 则返回 <code>-1</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_get_next_key</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .next_key = (<span class="hljs-type">uint64_t</span>) value,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>利用这个命令我们可以很方便地遍历一个 eBPF map：先传入一个不存在的 key 获取到 map 中的第一个 key，接下来再不断 <code>BPF_MAP_GET_NEXT_KEY</code> 直到返回 <code>-1</code> 即可</p>
<h3 id="删除-eBPF-map-数据"><a href="#删除-eBPF-map-数据" class="headerlink" title="删除 eBPF map 数据"></a>删除 eBPF map 数据</h3><p>我们可以通过 <code>BPF_MAP_DELETE_ELEM</code> 命令删除 map 中已有的映射，若不存在则会返回 <code>-EPERM</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_delete_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="销毁-eBPF-map"><a href="#销毁-eBPF-map" class="headerlink" title="销毁 eBPF map"></a>销毁 eBPF map</h3><p>在内核的 eBPF map 数据结构中会保存引用了该 map 的程序数量，若该 map 不再被任一程序引用则会自动释放，因此我们并不需要主动去销毁一个 eBPF map：）</p>
<h3 id="一个🌰程序"><a href="#一个🌰程序" class="headerlink" title="一个🌰程序"></a><em>一个🌰程序</em></h3><p>下面是使用 eBPF map 的一个示🌰程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;net/if.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/if_packet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/if_ether.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="hljs-keyword">sizeof</span>(*attr));<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_create</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> map_type, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> key_size, </span><br><span class="hljs-params">               <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_size, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_entries)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_type = map_type,<br>        .key_size = key_size,<br>        .value_size = value_size,<br>        .max_entries = max_entries,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_lookup_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *value)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_update_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *value,<span class="hljs-type">uint64_t</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>        .value = (<span class="hljs-type">uint64_t</span>) value,<br>        .flags = flags,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span><br><span class="hljs-title function_">bpf_map_delete_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> map_fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .map_fd = map_fd,<br>        .key = (<span class="hljs-type">uint64_t</span>) key,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">err_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-type">char</span> orig_value[<span class="hljs-number">0x100</span>] = <span class="hljs-string">&quot;1145141919810&quot;</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>    <span class="hljs-type">char</span> value[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-type">int</span> map_fd;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Creating new eBPF map...&quot;</span>);<br>    map_fd = bpf_map_create(BPF_MAP_TYPE_HASH, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x100</span>, <span class="hljs-number">0x10</span>);<br>    <span class="hljs-keyword">if</span> (map_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to create eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Adding new map of key-&gt;value...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bpf_map_update_elem(map_fd, <span class="hljs-string">&quot;arttnba3&quot;</span>, orig_value, BPF_ANY) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to update eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Looking up element in map...&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bpf_map_lookup_elem(map_fd, <span class="hljs-string">&quot;arttnba3&quot;</span>, value) &lt; <span class="hljs-number">0</span>) &#123;<br>        err_exit(<span class="hljs-string">&quot;FAILED to look up elem in eBPF map!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Successfully get the elem of key %s: %s\n&quot;</span>, <span class="hljs-string">&quot;arttnba3&quot;</span>, value);<br><br>    close(map_fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<p><img src="https://s2.loli.net/2023/05/31/C3vdouj5VryPMws.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>运行在内核中的 eBPF 程序也可以通过 eBPF map 的 fd 访问一个 eBPF map，下面是一个示🌰程序：</p>
<blockquote>
<p>注：这里笔者将常用函数 &amp; 指令封装在了 <a href="/download/bpf_tools.h">bpf_tools.h</a> 中</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure>



<h1 id="0xFF-REFERENCE"><a href="#0xFF-REFERENCE" class="headerlink" title="0xFF.REFERENCE"></a>0xFF.REFERENCE</h1><p><a target="_blank" rel="noopener" href="https://arthurchiao.art/blog/linux-socket-filtering-aka-bpf-zh/">[译] Linux Socket Filtering (LSF, aka BPF)（KernelDoc，2021）</a></p>
<p><a target="_blank" rel="noopener" href="https://heapdump.cn/article/5420563">HeapDump - eBPF指令集规范v1.0</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/263803">BPF之路一bpf系统调用</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/EBPF/" class="category-chain-item">EBPF</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/eBPF/">#eBPF</a>
      
        <a href="/tags/Linux-kernel/">#Linux kernel</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【EBPF.0x00】eBPF 入门指北（一）：简介</div>
      <div>https://arttnba3.github.io/2023/05/31/EBPF_0X00/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月31日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/04/CVE-0X0A-CVE-2021-3490/" title="【CVE.0x0A】CVE-2021-3490 漏洞复现及简要分析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【CVE.0x0A】CVE-2021-3490 漏洞复现及简要分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/" title="【CTF.0x08】D^ 3CTF2023 d3kcache 出题手记">
                        <span class="hidden-mobile">【CTF.0x08】D^ 3CTF2023 d3kcache 出题手记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
