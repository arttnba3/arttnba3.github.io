

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="宁就是👴の Manager 🐎">
<meta property="og:type" content="article">
<meta property="og:title" content="【FUZZ.0x02】syzkaller - II：syz-manager源码分析">
<meta property="og:url" content="http://blog.arttnba3.cn/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="宁就是👴の Manager 🐎">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/03/02/xrfT9S7u3EijaLY.png">
<meta property="article:published_time" content="2023-03-01T20:33:58.000Z">
<meta property="article:modified_time" content="2023-03-01T20:40:20.334Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="漏洞挖掘">
<meta property="article:tag" content="FUZZ">
<meta property="article:tag" content="syzkaller">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2023/03/02/xrfT9S7u3EijaLY.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【FUZZ.0x02】syzkaller - II：syz-manager源码分析 - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.arttnba3.cn","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://i.loli.net/2021/11/12/BnYuNbO2MdiEw5V.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【FUZZ.0x02】syzkaller - II：syz-manager源码分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-02 04:33" pubdate>
          2023年3月2日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          35k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          290 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【FUZZ.0x02】syzkaller - II：syz-manager源码分析</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年3月2日 凌晨
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>宁就是👴の Manager 🐎</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00.一切开始之前"></a>0x00.一切开始之前</h1><p>syzkaller 是一个非常经典的 kernel fuzzer，虽然笔者之前曾经用过（不过笔者太菜了啥都没挖出来）也曾粗略读过源码，但是没有太过于仔细分析就抛在脑后了（悲）</p>
<p>为了深入学习 fuzzing theory，笔者决定先从这个典中典的 syzkaller 源码进行分析学习 ：）</p>
<h2 id="PRE-工作原理"><a href="#PRE-工作原理" class="headerlink" title="PRE.工作原理"></a>PRE.工作原理</h2><p>对于 syzkaller 的架构，官方给出了这样的一张 Overview</p>
<p><img src="https://i.loli.net/2021/11/11/LxNvdhpEX2sBjYc.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>syzkaller 整体上为一个<strong>双机调试结构</strong>：由一台机器负责管控整个 fuzzing 流程（本文称为 <code>Host</code>），在另一台机器上进行 fuzzing（本文称为 <code>Guest</code>），Guest 通常为虚拟机，从而能让 Host 更好地管控整个流程</p>
<p>syzkaller 分为三大组件：</p>
<ul>
<li><p>位于 Host：</p>
<ul>
<li><code>syz-manager</code> ：syzkaller 的控制中枢，其会启动多个 VM 实例（如图所示的一个黄色卡片就是一个实例）并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code></li>
</ul>
</li>
<li><p>位于 Guest：</p>
<ul>
<li><code>syz-fuzzer</code> ：负责引导整个 fuzz 的过程：<ul>
<li>生成 input</li>
<li>启动 <code>syz-executor</code> 进程进行 fuzz</li>
<li>从被 fuzz 的 kernel 的 <code>/sys/kernel/debug/kcov</code> 获得覆盖（coverage）的相关信息</li>
<li>通过 RPC 将新的覆盖回送到 <code>syz-manager</code></li>
</ul>
</li>
<li><code>syz-executor</code>：负责<strong>执行单个输入</strong>——从 <code>syz-fuzzer</code> 处接受 input 并执行，最后回送结果</li>
</ul>
</li>
</ul>
<p><code>syz-manager</code> 为 syzkaller 的控制中枢，其会启动多个 VM 实例并进行监视，同时通过 RPC 来启动 <code>syz-fuzzer</code>，我们通常启动 fuzzing 时便是以 <code>syz-manager</code> 作为程序启动的入口点，因此笔者也先从此处开始分析</p>
<h1 id="0x01-基本结构体"><a href="#0x01-基本结构体" class="headerlink" title="0x01. 基本结构体"></a>0x01. 基本结构体</h1><p>相比于直接开始分析源码，笔者认为有必要在此之前先列出一些基本的结构体，你也可以把这一节当成一个表来查 ：）</p>
<h2 id="VM-管控相关"><a href="#VM-管控相关" class="headerlink" title="VM 管控相关"></a>VM 管控相关</h2><p>Host 需要去感知与管控 Guest VMs，因而在 <code>syz-manager</code> 当中有着一套相应的表示与管理 Guest VM 的结构体</p>
<h3 id="1-Instance：VM-实例"><a href="#1-Instance：VM-实例" class="headerlink" title="1. Instance：VM 实例"></a>1. Instance：VM 实例</h3><p><code>syz-manager</code> 中的 VM 实际上是使用一个名为 <code>Instance</code> 的结构体来表示的，定义于 <code>vm/vm.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">struct</span> &#123;<br>	impl     vmimpl.Instance<br>	workdir  <span class="hljs-type">string</span><br>	timeouts targets.Timeouts<br>	index    <span class="hljs-type">int</span><br>	onClose  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>类似地，其需要实现 <code>Interface</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Instance 表示一个单独的 VM.</span><br><span class="hljs-keyword">type</span> Instance <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">// Copy 复制一个 hostSrc 文件到 VM 中并返回 VM 中的文件名.</span><br>	Copy(hostSrc <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br>	<span class="hljs-comment">// Forward 设置从虚拟机内到主机上给定 tcp 端口的转发，</span><br>	<span class="hljs-comment">// 并返回要在虚拟机中使用的地址.</span><br>	Forward(port <span class="hljs-type">int</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br>	<span class="hljs-comment">// Run 在虚拟机内执行命令 (类似 ssh cmd).</span><br>	<span class="hljs-comment">// outc 接受混合了命令行与内核控制台的输出.</span><br>	<span class="hljs-comment">// errc 接受命令等待返回 error 或 vmimpl.ErrTimeout.</span><br>	<span class="hljs-comment">// Command 在 timeout 后停止. 在 stop chan 上发送可以用以更早将其终止.</span><br>	Run(timeout time.Duration, stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, command <span class="hljs-type">string</span>) (outc &lt;-<span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span>, errc &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, err <span class="hljs-type">error</span>)<br><br>	<span class="hljs-comment">// Diagnose 从 VM 上检索额外的调试信息</span><br>	<span class="hljs-comment">// (例如通过发送一些 sys-rq&#x27;s 或 SIGABORT&#x27;ing 一个 Go 程序).</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// 选择性地直接返回 (一些或所有) 信息. 若 wait == true,</span><br>	<span class="hljs-comment">// 调用者必须等待 VM 直接输出信息到其日志.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// rep 描述了 Diagnose 被调用的原因.</span><br>	Diagnose(rep *report.Report) (diagnosis []<span class="hljs-type">byte</span>, wait <span class="hljs-type">bool</span>)<br><br>	<span class="hljs-comment">// Close 停止并销毁 VM.</span><br>	Close()<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>Copy()</code>：将一个来自宿主机的文件拷贝至虚拟机中，返回虚拟机中的文件名.</li>
<li><code>Forward()</code>：设置从虚拟机内到主机上给定 tcp 端口的转发，并返回要在虚拟机中使用的地址</li>
<li><code>Run()</code>：在虚拟机内执行命令</li>
<li><code>Diagnose()</code>：在虚拟机上检索额外的调试信息</li>
<li><code>Close()</code>：停止并销毁虚拟机</li>
</ul>
<p>需要注意的是<strong>不同类型的 Guest VM 所实现的 Interface 接口是不同的</strong></p>
<blockquote>
<p>以 QEMU 为例，其实现主要位于 <code>vm/qemu/qemu.go</code> 中</p>
</blockquote>
<h3 id="2-Pool：VM-池"><a href="#2-Pool：VM-池" class="headerlink" title="2.Pool：VM 池"></a>2.Pool：VM 池</h3><p>类似于线程池的概念，在 <code>syz-manager</code> 中使用一个 <strong>VM 池</strong> —— <code>Pool</code> 结构体来管控 Guest VM，该结构体定义于 <code>vm/vm.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>	impl        vmimpl.Pool<br>	workdir     <span class="hljs-type">string</span><br>	template    <span class="hljs-type">string</span><br>	timeouts    targets.Timeouts<br>	activeCount <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>该结构体实现了 <code>Pool</code> 接口，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Pool 表示了一组特定类型的测试机器 (虚拟机, 物理设备, etc).</span><br><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">interface</span> &#123;<br>	<span class="hljs-comment">// Count 返回池中所有 VM 的数量.</span><br>	Count() <span class="hljs-type">int</span><br><br>	<span class="hljs-comment">// Create 创建并启动一个新的 VM 实例.</span><br>	Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (Instance, <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>Count()</code>：返回池中所有 VM 的数量</li>
<li><code>Create()</code>：<strong>新建并启动一个 VM实例</strong>，返回新建的实例对象</li>
</ul>
<h4 id="QEMU-VM-浅析"><a href="#QEMU-VM-浅析" class="headerlink" title="QEMU VM 浅析"></a>QEMU VM 浅析</h4><p>以 QEMU 为例的 Pool 接口实现如下，对于 <code>Count()</code> 而言会直接返回配置文件中的计数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Count() <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">return</span> pool.cfg.Count<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Create()</code> 则会首先检查文件系统镜像是否为 <code>9p</code> 格式，若是则会生成一个 ssh key 存放到 <code>key</code> 文件中并生成一个 <code>init.sh</code> 文件；接下来就是调用 <code>ctor()</code> 函数创建虚拟机：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> Create(workdir <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>	sshkey := pool.env.SSHKey<br>	sshuser := pool.env.SSHUser<br>	<span class="hljs-keyword">if</span> pool.env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br>		sshkey = filepath.Join(workdir, <span class="hljs-string">&quot;key&quot;</span>)<br>		sshuser = <span class="hljs-string">&quot;root&quot;</span><br>		<span class="hljs-keyword">if</span> _, err := osutil.RunCmd(<span class="hljs-number">10</span>*time.Minute, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ssh-keygen&quot;</span>, <span class="hljs-string">&quot;-t&quot;</span>, <span class="hljs-string">&quot;rsa&quot;</span>, <span class="hljs-string">&quot;-b&quot;</span>, <span class="hljs-string">&quot;2048&quot;</span>,<br>			<span class="hljs-string">&quot;-N&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-C&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, sshkey); err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>		&#125;<br>		initFile := filepath.Join(workdir, <span class="hljs-string">&quot;init.sh&quot;</span>)<br>		<span class="hljs-keyword">if</span> err := osutil.WriteExecFile(initFile, []<span class="hljs-type">byte</span>(strings.Replace(initScript, <span class="hljs-string">&quot;&#123;&#123;KEY&#125;&#125;&quot;</span>, sshkey, <span class="hljs-number">-1</span>))); err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create init file: %v&quot;</span>, err)<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>		inst, err := pool.ctor(workdir, sshkey, sshuser, index)<br>		<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>		&#125;<br>		<span class="hljs-comment">// Older qemu prints &quot;could&quot;, newer -- &quot;Could&quot;.</span><br>		<span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;ould not set up host forwarding rule&quot;</span>) &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1000</span> &amp;&amp; strings.Contains(err.Error(), <span class="hljs-string">&quot;Device or resource busy&quot;</span>) &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>ctor()</code> 的实现比较简单，主要就是创建一个带着 ssh key 及一些配置信息与一个 channel 的 <code>instance</code> 实例，初始化实例内的管道并调用 <code>boot()</code> 函数进行正式的创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *Pool)</span></span> ctor(workdir, sshkey, sshuser <span class="hljs-type">string</span>, index <span class="hljs-type">int</span>) (vmimpl.Instance, <span class="hljs-type">error</span>) &#123;<br>	inst := &amp;instance&#123;<br>		index:      index,<br>		cfg:        pool.cfg,<br>		target:     pool.target,<br>		archConfig: pool.archConfig,<br>		version:    pool.version,<br>		image:      pool.env.Image,<br>		debug:      pool.env.Debug,<br>		os:         pool.env.OS,<br>		timeouts:   pool.env.Timeouts,<br>		workdir:    workdir,<br>		sshkey:     sshkey,<br>		sshuser:    sshuser,<br>		diagnose:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>),<br>	&#125;<br>	<span class="hljs-keyword">if</span> st, err := os.Stat(inst.image); err != <span class="hljs-literal">nil</span> &amp;&amp; st.Size() == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// Some kernels may not need an image, however caller may still</span><br>		<span class="hljs-comment">// want to pass us a fake empty image because the rest of syzkaller</span><br>		<span class="hljs-comment">// assumes that an image is mandatory. So if the image is empty, we ignore it.</span><br>		inst.image = <span class="hljs-string">&quot;&quot;</span><br>	&#125;<br>	closeInst := inst<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">if</span> closeInst != <span class="hljs-literal">nil</span> &#123;<br>			closeInst.Close()<br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>	inst.rpipe, inst.wpipe, err = osutil.LongPipe()<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> err := inst.boot(); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br><br>	closeInst = <span class="hljs-literal">nil</span><br>	<span class="hljs-keyword">return</span> inst, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>boot()</code> 函数主要就是各种参数判断，之后<strong>把 QEMU 起了以后 ssh 连上去</strong>，这里就不摘抄代码了：）</p>
<h3 id="3-Env：单个-VM-Pool-的环境变量"><a href="#3-Env：单个-VM-Pool-的环境变量" class="headerlink" title="3. Env：单个  VM Pool 的环境变量"></a>3. Env：单个  VM Pool 的环境变量</h3><p><code>Env</code> 结构体为用于一个 VM Pool 的环境变量，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Env 包含了用于 VM 池的全局常量参数.</span><br><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// 独特的名字</span><br>	<span class="hljs-comment">// 若几个 Pool 共享了全局命名空间则可被用于 VM name 的冲突解决</span><br>	Name      <span class="hljs-type">string</span><br>	OS        <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 OS</span><br>	Arch      <span class="hljs-type">string</span> <span class="hljs-comment">// 目标 arch</span><br>	Workdir   <span class="hljs-type">string</span><br>	Image     <span class="hljs-type">string</span><br>	SSHKey    <span class="hljs-type">string</span><br>	SSHUser   <span class="hljs-type">string</span><br>	Timeouts  targets.Timeouts<br>	Debug     <span class="hljs-type">bool</span><br>	Config    []<span class="hljs-type">byte</span> <span class="hljs-comment">// json-序列化的 VM-类型-特定配置</span><br>	KernelSrc <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="4-Type：VM-类型"><a href="#4-Type：VM-类型" class="headerlink" title="4. Type：VM 类型"></a>4. Type：VM 类型</h3><p>一个 VM Pool 中只能有一种类型的 VM，因而不同类型的 VM 的 Pool 应当要有不同的构造函数，在 <code>syz-manager</code> 中使用 <code>Type</code> 结构体表示一种 VM 的类型信息，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>	Ctor       ctorFunc<br>	Overcommit <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ctorFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(env *Env)</span></span> (Pool, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure>

<p><code>ctorFunc</code> 为构造函数类型，其接受一个 <code>Env</code> 类型的结构体指针（储存了全局的一些基本信息），并返回一个 VM Pool 实例</p>
<p>由一个全局的 <code>string→Type</code> 映射表存储了不同类型 VM 的信息，在正式启动之前程序会通过 <code>Register()</code> 函数将不同类型的 VM 信息注册到该表中，定义于 <code>vm/vmimpl/vmimpl.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Register 在包中注册一个新的 VM 类型.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(typ <span class="hljs-type">string</span>, ctor ctorFunc, allowsOvercommit <span class="hljs-type">bool</span>)</span></span> &#123;<br>	Types[typ] = Type&#123;<br>		Ctor:       ctor,<br>		Overcommit: allowsOvercommit,<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">var</span>(<br>    <span class="hljs-comment">//...</span><br>	Types = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Type)<br></code></pre></td></tr></table></figure>

<p>以 <code>QEMU</code> 为例，其在包被导入时注册构造函数，主要是调用 <code>LoadData()</code> 解析配置文件后进行检查，这里不再赘叙：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> _ vmimpl.Infoer = (*instance)(<span class="hljs-literal">nil</span>)<br>	vmimpl.Register(<span class="hljs-string">&quot;qemu&quot;</span>, ctor, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ctor</span><span class="hljs-params">(env *vmimpl.Env)</span></span> (vmimpl.Pool, <span class="hljs-type">error</span>) &#123;<br>	archConfig := archConfigs[env.OS+<span class="hljs-string">&quot;/&quot;</span>+env.Arch]<br>	cfg := &amp;Config&#123;<br>		Count:       <span class="hljs-number">1</span>,<br>		CPU:         <span class="hljs-number">1</span>,<br>		Mem:         <span class="hljs-number">1024</span>,<br>		ImageDevice: <span class="hljs-string">&quot;hda&quot;</span>,<br>		Qemu:        archConfig.Qemu,<br>		QemuArgs:    archConfig.QemuArgs,<br>		NetDev:      archConfig.NetDev,<br>		Snapshot:    <span class="hljs-literal">true</span>,<br>	&#125;<br>	<span class="hljs-keyword">if</span> err := config.LoadData(env.Config, cfg); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to parse qemu vm config: %v&quot;</span>, err)<br>	&#125;<br>	<span class="hljs-keyword">if</span> cfg.Count &lt; <span class="hljs-number">1</span> || cfg.Count &gt; <span class="hljs-number">128</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;invalid config param count: %v, want [1, 128]&quot;</span>, cfg.Count)<br>	&#125;<br>	<span class="hljs-keyword">if</span> env.Debug &amp;&amp; cfg.Count &gt; <span class="hljs-number">1</span> &#123;<br>		log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;limiting number of VMs from %v to 1 in debug mode&quot;</span>, cfg.Count)<br>		cfg.Count = <span class="hljs-number">1</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> _, err := exec.LookPath(cfg.Qemu); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	<span class="hljs-keyword">if</span> env.Image == <span class="hljs-string">&quot;9p&quot;</span> &#123;<br>		<span class="hljs-keyword">if</span> env.OS != targets.Linux &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image is supported for linux only&quot;</span>)<br>		&#125;<br>		<span class="hljs-keyword">if</span> cfg.Kernel == <span class="hljs-string">&quot;&quot;</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;9p image requires kernel&quot;</span>)<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">if</span> !osutil.IsExist(env.Image) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;image file &#x27;%v&#x27; does not exist&quot;</span>, env.Image)<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> cfg.CPU &lt;= <span class="hljs-number">0</span> || cfg.CPU &gt; <span class="hljs-number">1024</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu cpu: %v, want [1-1024]&quot;</span>, cfg.CPU)<br>	&#125;<br>	<span class="hljs-keyword">if</span> cfg.Mem &lt; <span class="hljs-number">128</span> || cfg.Mem &gt; <span class="hljs-number">1048576</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;bad qemu mem: %v, want [128-1048576]&quot;</span>, cfg.Mem)<br>	&#125;<br>	cfg.Kernel = osutil.Abs(cfg.Kernel)<br>	cfg.Initrd = osutil.Abs(cfg.Initrd)<br><br>	output, err := osutil.RunCmd(time.Minute, <span class="hljs-string">&quot;&quot;</span>, cfg.Qemu, <span class="hljs-string">&quot;--version&quot;</span>)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	version := <span class="hljs-type">string</span>(bytes.Split(output, []<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;\n&#x27;</span>&#125;)[<span class="hljs-number">0</span>])<br><br>	pool := &amp;Pool&#123;<br>		env:        env,<br>		cfg:        cfg,<br>		version:    version,<br>		target:     targets.Get(env.OS, env.Arch),<br>		archConfig: archConfig,<br>	&#125;<br>	<span class="hljs-keyword">return</span> pool, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-ResourcePool：VM-资源池队列"><a href="#5-ResourcePool：VM-资源池队列" class="headerlink" title="5. ResourcePool：VM 资源池队列"></a>5. ResourcePool：VM 资源池队列</h3><p>Guest VM 的资源调配主要是通过<code>ResourcePool</code> 这一结构来完成的，这实际上是一个 <strong>存放空闲 VM の idx 的单向队列，决定了 VM 的调度顺序</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResourcePool <span class="hljs-keyword">struct</span> &#123;<br>	ids   []<span class="hljs-type">int</span><br>	mu    sync.RWMutex<br>	Freed <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要定义了这些方法来操纵资源池队列：</p>
<ul>
<li><code>Put()</code> ：向队列末尾添加空闲 VM の idx</li>
<li><code>Len()</code> ：获取队列长度</li>
<li><code>Take()</code>：从队列首部取出 <code>cnt</code> 个成员</li>
<li><code>TakeOne()</code> ：从队列首部取出单个成员</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Put(ids ...<span class="hljs-type">int</span>) &#123;<br>	pool.mu.Lock()<br>	<span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>	pool.ids = <span class="hljs-built_in">append</span>(pool.ids, ids...)<br>	<span class="hljs-comment">// Notify the listener.</span><br>	<span class="hljs-keyword">select</span> &#123;<br>	<span class="hljs-keyword">case</span> pool.Freed &lt;- <span class="hljs-literal">true</span>:<br>	<span class="hljs-keyword">default</span>:<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>	pool.mu.RLock()<br>	<span class="hljs-keyword">defer</span> pool.mu.RUnlock()<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pool.ids)<br>&#125;<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> Take(cnt <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<br>	pool.mu.Lock()<br>	<span class="hljs-keyword">defer</span> pool.mu.Unlock()<br>	totalItems := <span class="hljs-built_in">len</span>(pool.ids)<br>	<span class="hljs-keyword">if</span> totalItems &lt; cnt &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	ret := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, pool.ids[totalItems-cnt:]...)<br>	pool.ids = pool.ids[:totalItems-cnt]<br>	<span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pool *ResourcePool)</span></span> TakeOne() *<span class="hljs-type">int</span> &#123;<br>	ret := pool.Take(<span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">if</span> ret == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> &amp;ret[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同时有一个 <code>SequentialResourcePool()</code> 函数用以初始化资源池：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SequentialResourcePool</span><span class="hljs-params">(count <span class="hljs-type">int</span>, delay time.Duration)</span></span> *ResourcePool &#123;<br>	ret := &amp;ResourcePool&#123;Freed: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">1</span>)&#125;<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>			ret.Put(i)<br>			time.Sleep(delay)<br>		&#125;<br>	&#125;()<br>	<span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="全局管控相关"><a href="#全局管控相关" class="headerlink" title="全局管控相关"></a>全局管控相关</h2><h3 id="1-Manager：基本信息"><a href="#1-Manager：基本信息" class="headerlink" title="1. Manager：基本信息"></a>1. Manager：基本信息</h3><p><code>Manager</code> 结构体用于<strong>表示一个 syz-manager 的基本信息</strong>，定义于 <code>syz-manager/manager.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Manager <span class="hljs-keyword">struct</span> &#123;<br>	cfg            *mgrconfig.Config<br>	vmPool         *vm.Pool<br>	target         *prog.Target<br>	sysTarget      *targets.Target<br>	reporter       *report.Reporter<br>	crashdir       <span class="hljs-type">string</span><br>	serv           *RPCServer<br>	corpusDB       *db.DB<br>	startTime      time.Time<br>	firstConnect   time.Time<br>	fuzzingTime    time.Duration<br>	stats          *Stats<br>	crashTypes     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>	vmStop         <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>	checkResult    *rpctype.CheckArgs<br>	fresh          <span class="hljs-type">bool</span><br>	numFuzzing     <span class="hljs-type">uint32</span><br>	numReproducing <span class="hljs-type">uint32</span><br><br>	dash *dashapi.Dashboard<br><br>	mu                    sync.Mutex<br>	phase                 <span class="hljs-type">int</span><br>	targetEnabledSyscalls <span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span><br><br>	candidates       []rpctype.Candidate <span class="hljs-comment">// untriaged inputs from corpus and hub</span><br>	disabledHashes   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br>	corpus           <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem<br>	seeds            [][]<span class="hljs-type">byte</span><br>	newRepros        [][]<span class="hljs-type">byte</span><br>	lastMinCorpus    <span class="hljs-type">int</span><br>	memoryLeakFrames <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>	dataRaceFrames   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br>	saturatedCalls   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br>	needMoreRepros <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>	hubReproQueue  <span class="hljs-keyword">chan</span> *Crash<br>	reproRequest   <span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br>	<span class="hljs-comment">// For checking that files that we are using are not changing under us.</span><br>	<span class="hljs-comment">// Maps file name to modification time.</span><br>	usedFiles <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time<br><br>	modules            []host.KernelModule<br>	coverFilter        <span class="hljs-keyword">map</span>[<span class="hljs-type">uint32</span>]<span class="hljs-type">uint32</span><br>	coverFilterBitmap  []<span class="hljs-type">byte</span><br>	modulesInitialized <span class="hljs-type">bool</span><br><br>	assetStorage *asset.Storage<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里只说明比较关键的几个字段：</p>
<ul>
<li><code>cfg</code>：基本设置信息，对应存放在一个 json 文件中</li>
<li><code>vmPool</code> ：所用的 VM Pool</li>
<li><code>reporter</code>：用以报告 crash</li>
<li><code>serv</code> ：RPC Server，用以与 Guest 间通信</li>
<li><code>corpusDB</code>：存放语料的数据库</li>
<li><code>targetEnabledSyscalls</code>：测试用例所允许使用的系统调用</li>
<li><code>candidates</code>：待执行测试用例</li>
<li><code>corpus</code>：语料库</li>
<li><code>seeds</code>：用来对语料库变异的种子</li>
</ul>
<h3 id="2-fuzzing-phase"><a href="#2-fuzzing-phase" class="headerlink" title="2. fuzzing phase"></a>2. fuzzing phase</h3><p><code>syz-manager</code> 中将 fuzzing 流程分为如下的不同阶段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>	<span class="hljs-comment">// 刚刚开始，啥都没做.</span><br>	phaseInit = <span class="hljs-literal">iota</span><br>	<span class="hljs-comment">// 加载了语料库且检查了机器.</span><br>	phaseLoadedCorpus<br>	<span class="hljs-comment">// 从语料库中分类了所有输入.</span><br>	<span class="hljs-comment">// 这是我们开始查询 hub 与最小化连续语料库的时候.</span><br>	phaseTriagedCorpus<br>	<span class="hljs-comment">// 第一个请求发送到了 hub.</span><br>	phaseQueriedHub<br>	<span class="hljs-comment">// 分类所有来自 hub 的新输入.</span><br>	<span class="hljs-comment">// 这是我们开始复现 crashes 的时候.</span><br>	phaseTriagedHub<br>)<br></code></pre></td></tr></table></figure>

<h2 id="Fuzzing-结果相关"><a href="#Fuzzing-结果相关" class="headerlink" title="Fuzzing 结果相关"></a>Fuzzing 结果相关</h2><h3 id="1-Crash：记录-crash-信息"><a href="#1-Crash：记录-crash-信息" class="headerlink" title="1. Crash：记录 crash 信息"></a>1. Crash：记录 crash 信息</h3><p><code>manager.go</code> 中定义了<code>Crash</code> 结构体用以记录产生 crash 的 VM、机器信息等，<strong>真正的 crash 信息主要存放在一个 <code>Report</code> 结构体中</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Crash <span class="hljs-keyword">struct</span> &#123;<br>	vmIndex <span class="hljs-type">int</span><br>	hub     <span class="hljs-type">bool</span> <span class="hljs-comment">// this crash was created based on a repro from hub</span><br>	*report.Report<br>	machineInfo []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-Report：单次执行结果报告"><a href="#2-Report：单次执行结果报告" class="headerlink" title="2. Report：单次执行结果报告"></a>2. Report：单次执行结果报告</h3><p><code>pkg/report/rteport.go</code> 中的 <code>Report</code> 结构体用以表示单次执行的结果，包括是否产生了 crash、Oops 的信息等等：</p>
<ul>
<li><p><code>Title</code>：<strong>Oops 的第一行文本，用来标识特定类型的 crash</strong></p>
<blockquote>
<p>例如 <code>BUG: unable to handle page fault for address: ffffffff81001619</code> 这样的</p>
</blockquote>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Report <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// Title contains a representative description of the first oops.</span><br>	Title <span class="hljs-type">string</span><br>	<span class="hljs-comment">// Alternative titles, used for better deduplication.</span><br>	<span class="hljs-comment">// If two crashes have a non-empty intersection of Title/AltTitles, they are considered the same bug.</span><br>	AltTitles []<span class="hljs-type">string</span><br>	<span class="hljs-comment">// Bug type (e.g. hang, memory leak, etc).</span><br>	Type Type<br>	<span class="hljs-comment">// The indicative function name.</span><br>	Frame <span class="hljs-type">string</span><br>	<span class="hljs-comment">// Report contains whole oops text.</span><br>	Report []<span class="hljs-type">byte</span><br>	<span class="hljs-comment">// Output contains whole raw console output as passed to Reporter.Parse.</span><br>	Output []<span class="hljs-type">byte</span><br>	<span class="hljs-comment">// StartPos/EndPos denote region of output with oops message(s).</span><br>	StartPos <span class="hljs-type">int</span><br>	EndPos   <span class="hljs-type">int</span><br>	<span class="hljs-comment">// SkipPos is position in output where parsing for the next report should start.</span><br>	SkipPos <span class="hljs-type">int</span><br>	<span class="hljs-comment">// Suppressed indicates whether the report should not be reported to user.</span><br>	Suppressed <span class="hljs-type">bool</span><br>	<span class="hljs-comment">// Corrupted indicates whether the report is truncated of corrupted in some other way.</span><br>	Corrupted <span class="hljs-type">bool</span><br>	<span class="hljs-comment">// CorruptedReason contains reason why the report is marked as corrupted.</span><br>	CorruptedReason <span class="hljs-type">string</span><br>	<span class="hljs-comment">// Recipients is a list of RecipientInfo with Email, Display Name, and type.</span><br>	Recipients vcs.Recipients<br>	<span class="hljs-comment">// GuiltyFile is the source file that we think is to blame for the crash  (filled in by Symbolize).</span><br>	GuiltyFile <span class="hljs-type">string</span><br>	<span class="hljs-comment">// reportPrefixLen is length of additional prefix lines that we added before actual crash report.</span><br>	reportPrefixLen <span class="hljs-type">int</span><br>	<span class="hljs-comment">// symbolized is set if the report is symbolized.</span><br>	symbolized <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="0x02-main-：加载配置文件，启动-manager"><a href="#0x02-main-：加载配置文件，启动-manager" class="headerlink" title="0x02. main()：加载配置文件，启动 manager"></a>0x02. main()：加载配置文件，启动 manager</h1><p><code>syz-manager</code> 的 <code>main()</code> 函数其实比较简单，主要就是载入配置文件信息并调用 <code>RunManager()</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">if</span> prog.GitRevision == <span class="hljs-string">&quot;&quot;</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;bad syz-manager build: build with make, run bin/syz-manager&quot;</span>)<br>	&#125;<br>	flag.Parse()<br>	log.EnableLogCaching(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)<br>	cfg, err := mgrconfig.LoadFile(*flagConfig)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>	&#125;<br>	RunManager(cfg)<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><del>👴寻思好像没什么好说的</del></p>
</blockquote>
<h1 id="0x03-RunManager-：进行初始化工作"><a href="#0x03-RunManager-：进行初始化工作" class="headerlink" title="0x03. RunManager()：进行初始化工作"></a>0x03. RunManager()：进行初始化工作</h1><h3 id="Step-1-初始化-VM-Pool"><a href="#Step-1-初始化-VM-Pool" class="headerlink" title="Step 1. 初始化 VM Pool"></a>Step 1. 初始化 VM Pool</h3><p>首先是初始化 VM Pool，这里调用了 <code>vm/vm.go</code> 中的 <code>Create()</code> 来完成 VM pool 的创建</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vmPool *vm.Pool<br>   <span class="hljs-comment">// &quot;none&quot; 类型对于调试/开发而言是一种特殊情况，manager 并不会启动任何 VM，</span><br>   <span class="hljs-comment">// 但相应的是你应当手动启动 VM 并在此启动 syz-fuzzer.</span><br><span class="hljs-keyword">if</span> cfg.Type != <span class="hljs-string">&quot;none&quot;</span> &#123;<br>	<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>	vmPool, err = vm.Create(cfg, *flagDebug)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该函数主要就是获取 VM 类型、封装一个 Env 结构体、调用对应类型 VM Pool 的构造函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 创建一个可用于创建独立 VMs 的 VM pool.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Create</span><span class="hljs-params">(cfg *mgrconfig.Config, debug <span class="hljs-type">bool</span>)</span></span> (*Pool, <span class="hljs-type">error</span>) &#123;<br>	typ, ok := vmimpl.Types[cfg.Type]<br>	<span class="hljs-keyword">if</span> !ok &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unknown instance type &#x27;%v&#x27;&quot;</span>, cfg.Type)<br>	&#125;<br>	env := &amp;vmimpl.Env&#123;<br>		Name:      cfg.Name,<br>		OS:        cfg.TargetOS,<br>		Arch:      cfg.TargetVMArch,<br>		Workdir:   cfg.Workdir,<br>		Image:     cfg.Image,<br>		SSHKey:    cfg.SSHKey,<br>		SSHUser:   cfg.SSHUser,<br>		Timeouts:  cfg.Timeouts,<br>		Debug:     debug,<br>		Config:    cfg.VM,<br>		KernelSrc: cfg.KernelSrc,<br>	&#125;<br>	impl, err := typ.Ctor(env)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	<span class="hljs-keyword">return</span> &amp;Pool&#123;<br>		impl:     impl,<br>		workdir:  env.Workdir,<br>		template: cfg.WorkdirTemplate,<br>		timeouts: cfg.Timeouts,<br>	&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Step-2-初始化-Manager，载入语料库，建立通信服务器"><a href="#Step-2-初始化-Manager，载入语料库，建立通信服务器" class="headerlink" title="Step 2. 初始化 Manager，载入语料库，建立通信服务器"></a>Step 2. 初始化 Manager，载入语料库，建立通信服务器</h3><p>随后会创建用于存储 crash 的文件夹与一个新的 Reporter 实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">crashdir := filepath.Join(cfg.Workdir, <span class="hljs-string">&quot;crashes&quot;</span>)<br>osutil.MkdirAll(crashdir)<br><br>reporter, err := report.NewReporter(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来创建一个基本的 Manager 实例，然后是四步走：</p>
<ul>
<li><p><code>preloadCorpus()</code>：检查 <code>corpus.db</code> 文件是否存在（若不存在则创建）并载入 <code>sys/要fuzz的OS/test</code> 目录下的测试用模板</p>
<blockquote>
<p>语料库载入的模板本身类似于 syzlang 文件，例如 <code>sys/linux/pipe</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs syzlang">pipe2(&amp;(0x7f0000000000)=&#123;&lt;r0=&gt;0x0, &lt;r1=&gt;0x0&#125;, 0x0)<br>close(r0)<br>close(r1)<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>initStats()</code>：注册一个 prometheus 监视器（一个开源的监视&amp;预警工具包）</p>
</li>
<li><p><code>initHTTP()</code>：创建一个 HTTP 服务器并注册一系列的目录（用以供使用者访问）</p>
</li>
<li><p><code>collectUsedFiles()</code>：检查所需文件是否存在</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">mgr := &amp;Manager&#123;<br>	cfg:              cfg,<br>	vmPool:           vmPool,<br>	target:           cfg.Target,<br>	sysTarget:        cfg.SysTarget,<br>	reporter:         reporter,<br>	crashdir:         crashdir,<br>	startTime:        time.Now(),<br>	stats:            &amp;Stats&#123;haveHub: cfg.HubClient != <span class="hljs-string">&quot;&quot;</span>&#125;,<br>	crashTypes:       <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>	corpus:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]CorpusItem),<br>	disabledHashes:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>	memoryLeakFrames: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>	dataRaceFrames:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>	fresh:            <span class="hljs-literal">true</span>,<br>	vmStop:           <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>	hubReproQueue:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Crash, <span class="hljs-number">10</span>),<br>	needMoreRepros:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>),<br>	reproRequest:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>	usedFiles:        <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]time.Time),<br>	saturatedCalls:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>),<br>&#125;<br><br>mgr.preloadCorpus()<br>mgr.initStats() <span class="hljs-comment">// 初始化 prometheus 变量.</span><br>mgr.initHTTP()  <span class="hljs-comment">// 创建 HTTP 服务.</span><br>mgr.collectUsedFiles()<br></code></pre></td></tr></table></figure>

<p>之后创建一个 RPC Server，用以在 Host 与 Guest VMs 之间进行通信：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create 为 fuzzer 创建 PRC 服务器.</span><br>mgr.serv, err = startRPCServer(mgr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	log.Fatalf(<span class="hljs-string">&quot;failed to create rpc server: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Step-3-初始化-dashboard-相关"><a href="#Step-3-初始化-dashboard-相关" class="headerlink" title="Step 3.  初始化 dashboard 相关"></a><em>Step 3.  初始化 dashboard 相关</em></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> cfg.DashboardAddr != <span class="hljs-string">&quot;&quot;</span> &#123;<br>	mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;failed to create dashapi connection: %v&quot;</span>, err)<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> !cfg.AssetStorage.IsEmpty() &#123;<br>	mgr.assetStorage, err = asset.StorageFromConfig(cfg.AssetStorage, mgr.dash)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;failed to init asset storage: %v&quot;</span>, err)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Step-4-创建【日志输出】协程"><a href="#Step-4-创建【日志输出】协程" class="headerlink" title="Step 4. 创建【日志输出】协程"></a>Step 4. 创建【日志输出】协程</h3><p>接下来会新起一个协程进行数据记录的工作，内部其实就是一个<strong>每 10s 进行一次进度采集并输出日志的无限循环</strong>，主要是采集执行信息、语料覆盖率、crashes 信息等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">for</span> lastTime := time.Now(); ; &#123;<br>		time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>		now := time.Now()<br>		diff := now.Sub(lastTime)<br>		lastTime = now<br>		mgr.mu.Lock()<br>		<span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>			mgr.mu.Unlock()<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		mgr.fuzzingTime += diff * time.Duration(atomic.LoadUint32(&amp;mgr.numFuzzing))<br>		executed := mgr.stats.execTotal.get()<br>		crashes := mgr.stats.crashes.get()<br>		corpusCover := mgr.stats.corpusCover.get()<br>		corpusSignal := mgr.stats.corpusSignal.get()<br>		maxSignal := mgr.stats.maxSignal.get()<br>		mgr.mu.Unlock()<br>		numReproducing := atomic.LoadUint32(&amp;mgr.numReproducing)<br>		numFuzzing := atomic.LoadUint32(&amp;mgr.numFuzzing)<br><br>		log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;VMs %v, executed %v, cover %v, signal %v/%v, crashes %v, repro %v&quot;</span>,<br>			numFuzzing, executed, corpusCover, corpusSignal, maxSignal, crashes, numReproducing)<br>	&#125;<br>&#125;()<br></code></pre></td></tr></table></figure>

<h3 id="Step-5-创建-bench-协程（每隔一分钟最小化语料库并将-bench-data-写入-bench-文件）"><a href="#Step-5-创建-bench-协程（每隔一分钟最小化语料库并将-bench-data-写入-bench-文件）" class="headerlink" title="Step 5. 创建 bench 协程（每隔一分钟最小化语料库并将 bench data 写入 bench 文件）"></a>Step 5. 创建 bench 协程（每隔一分钟最小化语料库并将 bench data 写入 bench 文件）</h3><p>这里会判断命令行传入参数是否有 <code>bench=</code>，若是则调用 <code>initBench()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> *flagBench != <span class="hljs-string">&quot;&quot;</span> &#123;<br>	mgr.initBench()<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 这里的 <code>flagBench</code> 是一个全局的 flag 变量，golang 提供了一个 <code>flag</code> 包用以处理命令行参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>	flagConfig = flag.String(<span class="hljs-string">&quot;config&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;configuration file&quot;</span>)<br>	flagDebug  = flag.Bool(<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;dump all VM output to console&quot;</span>)<br>	flagBench  = flag.String(<span class="hljs-string">&quot;bench&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;write execution statistics into this file periodically&quot;</span>)<br>)<br></code></pre></td></tr></table></figure>

<p><code>initBench()</code> 会启动一个协程，主要就是一个每隔一分钟运行一次的循环：</p>
<ul>
<li>调用 <code>minimizeCorpus()</code> 将语料库进行最小化</li>
<li>向 <code>bench</code> 参数指定的文件当中写入 <code>语料库长度、启动时间、fuzzing 时间\n</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> initBench() &#123;<br>	f, err := os.OpenFile(*flagBench, os.O_WRONLY|os.O_CREATE|os.O_EXCL, osutil.DefaultFilePerm)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;failed to open bench file: %v&quot;</span>, err)<br>	&#125;<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">for</span> &#123;<br>			time.Sleep(time.Minute)<br>			vals := mgr.stats.all()<br>			mgr.mu.Lock()<br>			<span class="hljs-keyword">if</span> mgr.firstConnect.IsZero() &#123;<br>				mgr.mu.Unlock()<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			mgr.minimizeCorpus()<br>			vals[<span class="hljs-string">&quot;corpus&quot;</span>] = <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(mgr.corpus))<br>			vals[<span class="hljs-string">&quot;uptime&quot;</span>] = <span class="hljs-type">uint64</span>(time.Since(mgr.firstConnect)) / <span class="hljs-number">1e9</span><br>			vals[<span class="hljs-string">&quot;fuzzing&quot;</span>] = <span class="hljs-type">uint64</span>(mgr.fuzzingTime) / <span class="hljs-number">1e9</span><br>			mgr.mu.Unlock()<br><br>			data, err := json.MarshalIndent(vals, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>)<br>			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>				log.Fatalf(<span class="hljs-string">&quot;failed to serialize bench data&quot;</span>)<br>			&#125;<br>			<span class="hljs-keyword">if</span> _, err := f.Write(<span class="hljs-built_in">append</span>(data, <span class="hljs-string">&#x27;\n&#x27;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>				log.Fatalf(<span class="hljs-string">&quot;failed to write bench data&quot;</span>)<br>			&#125;<br>		&#125;<br>	&#125;()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Step-6-启动-dashboard-协程，进入下一阶段"><a href="#Step-6-启动-dashboard-协程，进入下一阶段" class="headerlink" title="Step 6. 启动 dashboard 协程，进入下一阶段"></a>Step 6. 启动 dashboard 协程，进入下一阶段</h3><p>接下来会启动一个新的协程，主要是 <em>每隔一分钟上报一次 syz-manager 的状态，这里不再展开</em> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> mgr.dash != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">go</span> mgr.dashboardReporter()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后会简单检查一下 VM Pool ，随后调用 <code>vmLoop()</code> 进入下一阶段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">	osutil.HandleInterrupts(vm.Shutdown)<br>	<span class="hljs-keyword">if</span> mgr.vmPool == <span class="hljs-literal">nil</span> &#123;<br>		log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;no VMs started (type=none)&quot;</span>)<br>		log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;you are supposed to start syz-fuzzer manually as:&quot;</span>)<br>		log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;syz-fuzzer -manager=manager.ip:%v [other flags as necessary]&quot;</span>, mgr.serv.port)<br>		&lt;-vm.Shutdown<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	mgr.vmLoop()<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="0x04-vmLoop-：启动-fuzzing，管控整体流程"><a href="#0x04-vmLoop-：启动-fuzzing，管控整体流程" class="headerlink" title="0x04. vmLoop()：启动 fuzzing，管控整体流程"></a>0x04. vmLoop()：启动 fuzzing，管控整体流程</h1><h2 id="一、VM-分组，初始化资源池等变量"><a href="#一、VM-分组，初始化资源池等变量" class="headerlink" title="一、VM 分组，初始化资源池等变量"></a>一、VM 分组，初始化资源池等变量</h2><p>一开始首先会将所有的 VM 分为两组：一组负责 fuzzing，一组负责复现 crash （<code>maxReproVMs</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Manager needs to be refactored (#605).</span><br><span class="hljs-comment">// nolint: gocyclo, gocognit, funlen</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> vmLoop() &#123;<br>	log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;booting test machines...&quot;</span>)<br>	log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;wait for the connection from test machine...&quot;</span>)<br>	instancesPerRepro := <span class="hljs-number">4</span><br>	vmCount := mgr.vmPool.Count()<br>	maxReproVMs := vmCount - mgr.cfg.FuzzingVMs<br>	<span class="hljs-keyword">if</span> instancesPerRepro &gt; maxReproVMs &amp;&amp; maxReproVMs &gt; <span class="hljs-number">0</span> &#123;<br>		instancesPerRepro = maxReproVMs<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>随后会调用 <code>SequentialResourcePool()</code> 新建一个 <code>ResourcePool</code> 队列，主要负责对<strong>空闲 VM 使用顺序</strong>的调控 ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">instances := SequentialResourcePool(vmCount, <span class="hljs-number">10</span>*time.Second*mgr.cfg.Timeouts.Scale)<br></code></pre></td></tr></table></figure>

<p>接下来会初始化一系列的变量：</p>
<ul>
<li><code>runDone</code>：保存 fuzzing 结果为 crash 的 <strong>Crash 队列</strong></li>
<li><code>pendingRepro</code>：标识<strong>待复现的 Crash</strong></li>
<li><code>reproducing</code>：标识<strong>某个类型 Crash</strong> 是否准备被复现</li>
<li><code>reproQueue</code>：Crash 的复现队列</li>
<li><code>reproDone</code>：Crash 的复现结果</li>
<li><code>stopPending</code>：等待停止标志位</li>
<li><code>shutdown</code>：工作终止标志位</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">runDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *RunResult, <span class="hljs-number">1</span>)<br>pendingRepro := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Crash]<span class="hljs-type">bool</span>)<br>reproducing := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">var</span> reproQueue []*Crash<br>reproDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ReproResult, <span class="hljs-number">1</span>)<br>stopPending := <span class="hljs-literal">false</span><br>shutdown := vm.Shutdown<br></code></pre></td></tr></table></figure>

<p>最后进入到一个大循环中，这个大循环才是真正的 fuzzing 调控流程</p>
<h2 id="二、外层大循环：调配空闲-VM-进行-fuzz-amp-crash-repro，等待处理不同-channel-数据"><a href="#二、外层大循环：调配空闲-VM-进行-fuzz-amp-crash-repro，等待处理不同-channel-数据" class="headerlink" title="二、外层大循环：调配空闲 VM 进行 fuzz &amp; crash repro，等待处理不同 channel 数据"></a>二、外层大循环：调配空闲 VM 进行 fuzz &amp; crash repro，等待处理不同 channel 数据</h2><p>大循环的终止条件为 <code>shutdown == nil</code> 或是 ResourcePool 中的 VM 数量与总数量不相等，进入循环后首先会获取当前所在阶段： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> shutdown != <span class="hljs-literal">nil</span> || instances.Len() != vmCount &#123;<br>	mgr.mu.Lock()<br>	phase := mgr.phase<br>	mgr.mu.Unlock()<br></code></pre></td></tr></table></figure>

<h3 id="Step-1-内层小循环：获取待复现-crash-加入复现队列"><a href="#Step-1-内层小循环：获取待复现-crash-加入复现队列" class="headerlink" title="Step 1. 内层小循环：获取待复现 crash 加入复现队列"></a>Step 1. 内层小循环：获取待复现 crash 加入复现队列</h3><p>小循环会遍历 <code>pendingRepro</code> 中的 crash：</p>
<ul>
<li>若未被复现则从 pendingRepro 中删除</li>
<li>调用 <code>needRepro()</code> 检查是否需要复现</li>
<li>标记该标题的 crash 已在复现，并加入复现队列中</li>
</ul>
<p>这里的 <code>crash.Title</code> 其实是 <strong>Oops 的第一行文本，</strong>即<strong>同一时刻仅会复现同类 crash 中的一个</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> crash := <span class="hljs-keyword">range</span> pendingRepro &#123;<br>	<span class="hljs-keyword">if</span> reproducing[crash.Title] &#123;<br>		<span class="hljs-keyword">continue</span><br>	&#125;<br>	<span class="hljs-built_in">delete</span>(pendingRepro, crash)<br>	<span class="hljs-keyword">if</span> !mgr.needRepro(crash) &#123;<br>		<span class="hljs-keyword">continue</span><br>	&#125;<br>	log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add to repro queue &#x27;%v&#x27;&quot;</span>, crash.Title)<br>	reproducing[crash.Title] = <span class="hljs-literal">true</span><br>	reproQueue = <span class="hljs-built_in">append</span>(reproQueue, crash)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Step-2-判断是否可以对-crash-进行复现并调控-VM"><a href="#Step-2-判断是否可以对-crash-进行复现并调控-VM" class="headerlink" title="Step 2. 判断是否可以对 crash 进行复现并调控 VM"></a>Step 2. 判断是否可以对 crash 进行复现并调控 VM</h3><p>接下来会输出一行日志，之后定义一个闭包函数 <code>canRepro</code>，用来判断<strong>当前是否可以进行 crash 复现</strong>，主要判断以下三个条件是否满足：</p>
<ul>
<li>当前阶段是否超过 <code>phaseTriagedHub</code> </li>
<li>待复现队列 <code>reproQueue</code> 是否不为空</li>
<li>加上该 crash 后所有用来复现 crash 的 VM 数量是否小于 <code>maxReproVMs</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: phase=%v shutdown=%v instances=%v/%v %+v repro: pending=%v reproducing=%v queued=%v&quot;</span>,<br>	phase, shutdown == <span class="hljs-literal">nil</span>, instances.Len(), vmCount, instances.Snapshot(),<br>	<span class="hljs-built_in">len</span>(pendingRepro), <span class="hljs-built_in">len</span>(reproducing), <span class="hljs-built_in">len</span>(reproQueue))<br><br>canRepro := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br>	<span class="hljs-keyword">return</span> phase &gt;= phaseTriagedHub &amp;&amp; <span class="hljs-built_in">len</span>(reproQueue) != <span class="hljs-number">0</span> &amp;&amp;<br>		(<span class="hljs-type">int</span>(atomic.LoadUint32(&amp;mgr.numReproducing))+<span class="hljs-number">1</span>)*instancesPerRepro &lt;= maxReproVMs<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来是两个小循环：</p>
<h4 id="①-循环启动协程调度-VM-进行-crash-复现"><a href="#①-循环启动协程调度-VM-进行-crash-复现" class="headerlink" title="① 循环启动协程调度 VM 进行 crash 复现"></a>① 循环启动协程调度 VM 进行 crash 复现</h4><p>第一个小循环会循环判断是否可以进行 crash 复现：</p>
<ul>
<li>若可以复现则从资源池队列中取出一个 VM idx，若资源池为空则直接跳出</li>
<li>从 <code>reproQueue</code> 中取出一个 crash，更新 manager 的 <code>numReproducing</code> 计数</li>
<li>启动一个新的协程调用 <code>runRepro()</code> 对该 crash 进行复现，结果输出至 <code>reproDone</code> 队列中</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">for</span> canRepro() &#123;<br>		vmIndexes := instances.Take(instancesPerRepro)<br>		<span class="hljs-keyword">if</span> vmIndexes == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		last := <span class="hljs-built_in">len</span>(reproQueue) - <span class="hljs-number">1</span><br>		crash := reproQueue[last]<br>		reproQueue[last] = <span class="hljs-literal">nil</span><br>		reproQueue = reproQueue[:last]<br>		atomic.AddUint32(&amp;mgr.numReproducing, <span class="hljs-number">1</span>)<br>		log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting repro of &#x27;%v&#x27; on instances %+v&quot;</span>, crash.Title, vmIndexes)<br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			reproDone &lt;- mgr.runRepro(crash, vmIndexes, instances.Put)<br>		&#125;()<br>	&#125;<br></code></pre></td></tr></table></figure>

<p> 而 <code>runRepro()</code> 其实就是 <code>repro.Run()</code> 的 wrapper ＋ 一些错误检查后将 VM idx 放回资源池，这里就不展开了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runRepro(crash *Crash, vmIndexes []<span class="hljs-type">int</span>, putInstances <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(...<span class="hljs-type">int</span>)</span></span>) *ReproResult &#123;<br>	features := mgr.checkResult.Features<br>	res, stats, err := repro.Run(crash.Output, mgr.cfg, features, mgr.reporter, mgr.vmPool, vmIndexes)<br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure>

<p><code>Run()</code> 一开始主要是一些检查，之后根据 crash 类型的不同设置不同的复现时间上限：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Run</span><span class="hljs-params">(crashLog []<span class="hljs-type">byte</span>, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,</span></span><br><span class="hljs-params"><span class="hljs-function">	vmPool *vm.Pool, vmIndexes []<span class="hljs-type">int</span>)</span></span> (*Result, *Stats, <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmIndexes) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;no VMs provided&quot;</span>)<br>	&#125;<br>	entries := cfg.Target.ParseLog(crashLog)<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;crash log does not contain any programs&quot;</span>)<br>	&#125;<br>	crashStart := <span class="hljs-built_in">len</span>(crashLog)<br>	crashTitle, crashType := <span class="hljs-string">&quot;&quot;</span>, report.Unknown<br>	<span class="hljs-keyword">if</span> rep := reporter.Parse(crashLog); rep != <span class="hljs-literal">nil</span> &#123;<br>		crashStart = rep.StartPos<br>		crashTitle = rep.Title<br>		crashType = rep.Type<br>	&#125;<br>	testTimeouts := []time.Duration&#123;<br>		<span class="hljs-number">3</span> * cfg.Timeouts.Program, <span class="hljs-comment">// 以捕获更简单的 crashes (即 no races and no hangs)</span><br>		<span class="hljs-number">20</span> * cfg.Timeouts.Program,<br>		cfg.Timeouts.NoOutputRunningTime, <span class="hljs-comment">// 以捕获 &quot;no output&quot;, races and hangs</span><br>	&#125;<br>	<span class="hljs-keyword">switch</span> &#123;<br>	<span class="hljs-keyword">case</span> crashTitle == <span class="hljs-string">&quot;&quot;</span>:<br>		crashTitle = <span class="hljs-string">&quot;no output/lost connection&quot;</span><br>		<span class="hljs-comment">// Lost connection 可以被更快地检测到,</span><br>		<span class="hljs-comment">// 但理论上若其由竞争造成，则可能需要最长的 timeout.</span><br>		<span class="hljs-comment">// No output 仅能在最大的 timeout 下被复现.</span><br>		<span class="hljs-comment">// 作为妥协，我们使用最小与最大的 timeouts.</span><br>		testTimeouts = []time.Duration&#123;testTimeouts[<span class="hljs-number">0</span>], testTimeouts[<span class="hljs-number">2</span>]&#125;<br>	<span class="hljs-keyword">case</span> crashType == report.MemoryLeak:<br>		<span class="hljs-comment">// 由于昂贵的设置与扫描，内存泄露不能被很快地检测到.</span><br>		testTimeouts = testTimeouts[<span class="hljs-number">1</span>:]<br>	<span class="hljs-keyword">case</span> crashType == report.Hang:<br>		testTimeouts = testTimeouts[<span class="hljs-number">2</span>:]<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>接下来会将崩溃信息存储到一个 <code>context</code> 结构体中，并新建一个 WaitGroup：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx := &amp;context&#123;<br>	target:       cfg.SysTarget,<br>	reporter:     reporter,<br>	crashTitle:   crashTitle,<br>	crashType:    crashType,<br>	instances:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *reproInstance, <span class="hljs-built_in">len</span>(vmIndexes)),<br>	bootRequests: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(vmIndexes)),<br>	testTimeouts: testTimeouts,<br>	startOpts:    createStartOptions(cfg, features, crashType),<br>	stats:        <span class="hljs-built_in">new</span>(Stats),<br>	timeouts:     cfg.Timeouts,<br>&#125;<br>ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v programs, %v VMs, timeouts %v&quot;</span>, <span class="hljs-built_in">len</span>(entries), <span class="hljs-built_in">len</span>(vmIndexes), testTimeouts)<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-built_in">len</span>(vmIndexes))<br></code></pre></td></tr></table></figure>

<p>随后循环获取用以复现的 VM idx 并依次启动新协程调用 <code>CreateExecProgInstance()</code> <strong>创建 VM 并拷贝 crash 程序</strong>，若失败则休眠 10s 后重试，最多会尝试 <code>maxTry</code> 次；成功的结果会输出到 <code>ctx.instances</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, vmIndex := <span class="hljs-keyword">range</span> vmIndexes &#123;<br>	ctx.bootRequests &lt;- vmIndex<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">defer</span> wg.Done()<br>		<span class="hljs-keyword">for</span> vmIndex := <span class="hljs-keyword">range</span> ctx.bootRequests &#123;<br>			<span class="hljs-keyword">var</span> inst *instance.ExecProgInstance<br>			maxTry := <span class="hljs-number">3</span><br>			<span class="hljs-keyword">for</span> try := <span class="hljs-number">0</span>; try &lt; maxTry; try++ &#123;<br>				<span class="hljs-keyword">select</span> &#123;<br>				<span class="hljs-keyword">case</span> &lt;-vm.Shutdown:<br>					try = maxTry<br>					<span class="hljs-keyword">continue</span><br>				<span class="hljs-keyword">default</span>:<br>				&#125;<br>				<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>				inst, err = instance.CreateExecProgInstance(vmPool, vmIndex, cfg,<br>					reporter, &amp;instance.OptionalConfig&#123;Logf: ctx.reproLogf&#125;)<br>				<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>					ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to init instance: %v&quot;</span>, err)<br>					time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>					<span class="hljs-keyword">continue</span><br>				&#125;<br>				<span class="hljs-keyword">break</span><br>			&#125;<br>			<span class="hljs-keyword">if</span> inst == <span class="hljs-literal">nil</span> &#123;<br>				<span class="hljs-keyword">break</span><br>			&#125;<br>			ctx.instances &lt;- &amp;reproInstance&#123;execProg: inst, index: vmIndex&#125;<br>		&#125;<br>	&#125;()<br>&#125;<br><span class="hljs-comment">// 一些收尾工作...</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	wg.Wait()<br>	<span class="hljs-built_in">close</span>(ctx.instances)<br>&#125;()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-built_in">close</span>(ctx.bootRequests)<br>	<span class="hljs-keyword">for</span> inst := <span class="hljs-keyword">range</span> ctx.instances &#123;<br>		inst.execProg.VMInstance.Close()<br>	&#125;<br>&#125;()<br></code></pre></td></tr></table></figure>

<p><code>CreateExecProgInstance()</code> 主要就是调用 <code>vmPool.Create()</code> 启动虚拟机后调用 <code>SetupExecProg()</code> 拷贝要执行的二进制文件，这里就不展开了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateExecProgInstance</span><span class="hljs-params">(vmPool *vm.Pool, vmIndex <span class="hljs-type">int</span>, mgrCfg *mgrconfig.Config,</span></span><br><span class="hljs-params"><span class="hljs-function">	reporter *report.Reporter, opt *OptionalConfig)</span></span> (*ExecProgInstance, <span class="hljs-type">error</span>) &#123;<br>	vmInst, err := vmPool.Create(vmIndex)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create VM: %v&quot;</span>, err)<br>	&#125;<br>	ret, err := SetupExecProg(vmInst, mgrCfg, reporter, opt)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		vmInst.Close()<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	<span class="hljs-keyword">return</span> ret, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>回到 <code>Run()</code>  中，其最后会调用 <code>context.repro()</code> <strong>正式开始复现 crash 的工作</strong>，检查结果后返回：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">	res, err := ctx.repro(entries, crashStart)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	<span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>		ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>			ctx.report.Corrupted, ctx.report.Report)<br>		<span class="hljs-comment">// Try to rerun the repro if the report is corrupted.</span><br>		<span class="hljs-keyword">for</span> attempts := <span class="hljs-number">0</span>; ctx.report.Corrupted &amp;&amp; attempts &lt; <span class="hljs-number">3</span>; attempts++ &#123;<br>			ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;report is corrupted, running repro again&quot;</span>)<br>			<span class="hljs-keyword">if</span> res.CRepro &#123;<br>				_, err = ctx.testCProg(res.Prog, res.Duration, res.Opts)<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				_, err = ctx.testProg(res.Prog, res.Duration, res.Opts)<br>			&#125;<br>			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err<br>			&#125;<br>		&#125;<br>		ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;final repro crashed as (corrupted=%v):\n%s&quot;</span>,<br>			ctx.report.Corrupted, ctx.report.Report)<br>		res.Report = ctx.report<br>	&#125;<br>	<span class="hljs-keyword">return</span> res, ctx.stats, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>repro()</code> 函数主要分两部分：</p>
<ul>
<li><p>调用 <code>extractProg()</code> <strong>获取触发 crash 的程序集合</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> repro(entries []*prog.LogEntry, crashStart <span class="hljs-type">int</span>) (*Result, <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-comment">// 去除在 crash 发生后执行的程序.</span><br>	<span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br>		<span class="hljs-keyword">if</span> ent.Start &gt; crashStart &#123;<br>			entries = entries[:i]<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br><br>	reproStart := time.Now()<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;reproducing took %s&quot;</span>, time.Since(reproStart))<br>	&#125;()<br><br>	res, err := ctx.extractProg(entries)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	<span class="hljs-keyword">if</span> res == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>			res.Opts.Repro = <span class="hljs-literal">false</span><br>		&#125;<br>	&#125;()<br></code></pre></td></tr></table></figure>
</li>
<li><p>最小化程序集合并尝试生成可以触发该 crash 的 C 程序，返回结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-comment">// 尝试最小化程序集</span><br>	res, err = ctx.minimizeProg(res)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br><br>	<span class="hljs-comment">// 首先尝试在不简化配置的情况下提取 C repro.</span><br>	res, err = ctx.extractC(res)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br><br>	<span class="hljs-comment">// 简化配置并尝试提取 C repro.</span><br>	<span class="hljs-keyword">if</span> !res.CRepro &#123;<br>		res, err = ctx.simplifyProg(res)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 简化 C 相关的配置.</span><br>	<span class="hljs-keyword">if</span> res.CRepro &#123;<br>		res, err = ctx.simplifyC(res)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>extractProg()</code> 的逻辑比较简单：</p>
<ul>
<li>逆序后调用 <code>context.extractProgSingle()</code> <strong>逐个运行单个程序</strong>，若某一程序触发了 crash 则直接返回</li>
<li>若单一程序无法触发 crash，则调用 <code>context.extractProgBisect()</code> <strong>使用二分法找出触发 crash 的程序集合</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *context)</span></span> extractProg(entries []*prog.LogEntry) (*Result, <span class="hljs-type">error</span>) &#123;<br>	ctx.reproLogf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;extracting reproducer from %v programs&quot;</span>, <span class="hljs-built_in">len</span>(entries))<br>	start := time.Now()<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		ctx.stats.ExtractProgTime = time.Since(start)<br>	&#125;()<br><br>	<span class="hljs-comment">// Extract last program on every proc.</span><br>	procs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>	<span class="hljs-keyword">for</span> i, ent := <span class="hljs-keyword">range</span> entries &#123;<br>		procs[ent.Proc] = i<br>	&#125;<br>	<span class="hljs-keyword">var</span> indices []<span class="hljs-type">int</span><br>	<span class="hljs-keyword">for</span> _, idx := <span class="hljs-keyword">range</span> procs &#123;<br>		indices = <span class="hljs-built_in">append</span>(indices, idx)<br>	&#125;<br>	sort.Ints(indices)<br>	<span class="hljs-keyword">var</span> lastEntries []*prog.LogEntry<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(indices) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>		lastEntries = <span class="hljs-built_in">append</span>(lastEntries, entries[indices[i]])<br>	&#125;<br>	<span class="hljs-keyword">for</span> _, timeout := <span class="hljs-keyword">range</span> ctx.testTimeouts &#123;<br>		<span class="hljs-comment">// 分别执行每个程序以检测由单个程序造成的简单的 crash.</span><br>		<span class="hljs-comment">// 程序被逆序执行, 通常最后一个程序就是罪魁祸首.</span><br>		res, err := ctx.extractProgSingle(lastEntries, timeout)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>		&#125;<br>		<span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>			ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br>			<span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>		&#125;<br><br>		<span class="hljs-comment">// 若只有一个 entry 则不进行二分.</span><br>		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) == <span class="hljs-number">1</span> &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br><br>		<span class="hljs-comment">// 执行多个程序并二分 log 以找到造成崩溃的多个程序.</span><br>		res, err = ctx.extractProgBisect(entries, timeout)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>		&#125;<br>		<span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>			ctx.reproLogf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="hljs-built_in">len</span>(res.Prog.Calls))<br>			<span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>		&#125;<br>	&#125;<br><br>	ctx.reproLogf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to extract reproducer&quot;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这两个函数主要就是通过如下调用链来在 VM 中执行程序，这里就不展开了：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">context.test<span class="hljs-constructor">Prog()</span><br>	context.test<span class="hljs-constructor">Progs()</span><br>		context.test<span class="hljs-constructor">WithInstance()</span><br>			ExecProgInstance.<span class="hljs-constructor">RunSyzProg()</span><br>				ExecProgInstance.<span class="hljs-constructor">RunSyzProgFile()</span><br>					<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecProgInstance</span>.</span></span>run<span class="hljs-constructor">Command()</span><br></code></pre></td></tr></table></figure>



<h4 id="②-循环启动协程进行-fuzzing"><a href="#②-循环启动协程进行-fuzzing" class="headerlink" title="② 循环启动协程进行 fuzzing"></a>② 循环启动协程进行 fuzzing</h4><p>此时已经不满足可以进行 crash 复现的条件了，因而会有第二个小循环启动新协程<strong>将资源池中剩余 VM 调度去 fuzzing</strong>， 并将结果输出到 <code>runDone</code> 中： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-keyword">for</span> !canRepro() &#123;<br>		idx := instances.TakeOne()<br>		<span class="hljs-keyword">if</span> idx == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: starting instance %v&quot;</span>, *idx)<br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			crash, err := mgr.runInstance(*idx)<br>			runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;<br>		&#125;()<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>runInstance()</code> 函数实际上会调用 <code>runInstanceInner()</code>，该函数<strong>仅当产生了 Crash 时返回的结果才不为 nil，即 runRepro 队列实际上为 Crash 队列：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstance(index <span class="hljs-type">int</span>) (*Crash, <span class="hljs-type">error</span>) &#123;<br>	mgr.checkUsedFiles()<br>	instanceName := fmt.Sprintf(<span class="hljs-string">&quot;vm-%d&quot;</span>, index)<br><br>	rep, vmInfo, err := mgr.runInstanceInner(index, instanceName)<br><br>	machineInfo := mgr.serv.shutdownInstance(instanceName)<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(vmInfo) != <span class="hljs-number">0</span> &#123;<br>		machineInfo = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>(vmInfo, <span class="hljs-string">&#x27;\n&#x27;</span>), machineInfo...)<br>	&#125;<br><br>	<span class="hljs-comment">// Error that is not a VM crash.</span><br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	<span class="hljs-comment">// No crash.</span><br>	<span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>	&#125;<br>	crash := &amp;Crash&#123;<br>		vmIndex:     index,<br>		hub:         <span class="hljs-literal">false</span>,<br>		Report:      rep,<br>		machineInfo: machineInfo,<br>	&#125;<br>	<span class="hljs-keyword">return</span> crash, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>runInstanceInner()</code> 的核心部分主要是：</p>
<ul>
<li><p>调用 <code>vmPool.Create()</code> 创建 VM，调用 <code>inst.Forward()</code> 进行 TCP 转发，拷贝 <code>syz-fuzzer</code> 与 <code>syz-executor</code> 到 VM 文件系统中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> runInstanceInner(index <span class="hljs-type">int</span>, instanceName <span class="hljs-type">string</span>) (*report.Report, []<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>	inst, err := mgr.vmPool.Create(index)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create instance: %v&quot;</span>, err)<br>	&#125;<br>	<span class="hljs-keyword">defer</span> inst.Close()<br><br>	fwdAddr, err := inst.Forward(mgr.serv.port)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to setup port forwarding: %v&quot;</span>, err)<br>	&#125;<br><br>	fuzzerBin, err := inst.Copy(mgr.cfg.FuzzerBin)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>	&#125;<br><br>	<span class="hljs-comment">// 若提供了 ExecutorBin , 这意味着 syz-executor 早已在镜像中,</span><br>	<span class="hljs-comment">// 故无需进行拷贝.</span><br>	executorBin := mgr.sysTarget.ExecutorBin<br>	<span class="hljs-keyword">if</span> executorBin == <span class="hljs-string">&quot;&quot;</span> &#123;<br>		executorBin, err = inst.Copy(mgr.cfg.ExecutorBin)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to copy binary: %v&quot;</span>, err)<br>		&#125;<br>	&#125;<br><br>	fuzzerV := <span class="hljs-number">0</span><br>	procs := mgr.cfg.Procs<br>	<span class="hljs-keyword">if</span> *flagDebug &#123;<br>		fuzzerV = <span class="hljs-number">100</span><br>		procs = <span class="hljs-number">1</span><br>	&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>instance.FuzzerCmd()</code> 生成命令行后调用 <code>inst.Run()</code> 启动 <code>syz-fuzzer</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Run the fuzzer binary.</span><br>start := time.Now()<br>atomic.AddUint32(&amp;mgr.numFuzzing, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">defer</span> atomic.AddUint32(&amp;mgr.numFuzzing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>  <br>args := &amp;instance.FuzzerCmdArgs&#123;<br>	Fuzzer:    fuzzerBin,<br>	Executor:  executorBin,<br>	Name:      instanceName,<br>	OS:        mgr.cfg.TargetOS,<br>	Arch:      mgr.cfg.TargetArch,<br>	FwdAddr:   fwdAddr,<br>	Sandbox:   mgr.cfg.Sandbox,<br>	Procs:     procs,<br>	Verbosity: fuzzerV,<br>	Cover:     mgr.cfg.Cover,<br>	Debug:     *flagDebug,<br>	Test:      <span class="hljs-literal">false</span>,<br>	Runtest:   <span class="hljs-literal">false</span>,<br>	Optional: &amp;instance.OptionalFuzzerArgs&#123;<br>		Slowdown:   mgr.cfg.Timeouts.Slowdown,<br>		RawCover:   mgr.cfg.RawCover,<br>		SandboxArg: mgr.cfg.SandboxArg,<br>	&#125;,<br>&#125;<br>cmd := instance.FuzzerCmd(args)<br>outc, errc, err := inst.Run(mgr.cfg.Timeouts.VMRunningTime, mgr.vmStop, cmd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to run fuzzer: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>inst.MonitorExecution()</code> 监控 VM 运行，该函数主要是<strong>通过获取 kernel oops 来判断是否触发了 crash</strong>（KASAN 不会造成 kernel panic，从而使得一个 VM 实例长期运行，不过 dmesg 中仍有 oops）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-keyword">var</span> vmInfo []<span class="hljs-type">byte</span><br>	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)<br>	<span class="hljs-keyword">if</span> rep == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-comment">// This is the only &quot;OK&quot; outcome.</span><br>		log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%s: running for %v, restarting&quot;</span>, instanceName, time.Since(start))<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		vmInfo, err = inst.Info()<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			vmInfo = []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;error getting VM info: %v\n&quot;</span>, err))<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> rep, vmInfo, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Step-3-等待处理不同-channel-数据"><a href="#Step-3-等待处理不同-channel-数据" class="headerlink" title="Step 3. 等待处理不同 channel 数据"></a>Step 3. 等待处理不同 channel 数据</h3><p><code>vmLoop()</code> 的最后主要就是一个大的 <code>select</code>，等待某个 channel 中有数据后进行处理，之后重新跳回等待处理或是开始下一轮循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-keyword">var</span> stopRequest <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>	<span class="hljs-keyword">if</span> !stopPending &amp;&amp; canRepro() &#123;<br>		stopRequest = mgr.vmStop<br>	&#125;<br><br>wait:<br>	<span class="hljs-keyword">select</span> &#123;<br></code></pre></td></tr></table></figure>

<p>首先是资源池的 <code>Freed</code> channel，在 <code>Put()</code> 中会将空闲 VM idx 放回资源池后向该 channel 送入一个 <code>true</code>，而这里什么都没有做，笔者估计会在后续版本中更新：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-instances.Freed:<br>	<span class="hljs-comment">// An instance has been released.</span><br></code></pre></td></tr></table></figure>

<p><code>stopRequest</code> 其实是 <code>Manager.vmStop</code> ，这个 channel 会在 VM instance 所实现的 <code>Run()</code> 方法中被使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> stopRequest &lt;- <span class="hljs-literal">true</span>:<br>	log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: issued stop request&quot;</span>)<br>	stopPending = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>当 <code>runDone</code> 中有数据时说明<strong>fuzz 产生了 crash</strong>，此时会将产生 crash 的 VM 释放回资源池，将 crash 写入 <code>pendingRepro</code> 表中等待下一轮循环进行处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-runDone:<br>	log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: instance %v finished, crash=%v&quot;</span>, res.idx, res.crash != <span class="hljs-literal">nil</span>)<br>	<span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &amp;&amp; shutdown != <span class="hljs-literal">nil</span> &#123;<br>		log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v&quot;</span>, res.err)<br>	&#125;<br>	stopPending = <span class="hljs-literal">false</span><br>	instances.Put(res.idx)<br>	<span class="hljs-comment">// On shutdown qemu crashes with &quot;qemu: terminating on signal 2&quot;,</span><br>	<span class="hljs-comment">// which we detect as &quot;lost connection&quot;. Don&#x27;t save that as crash.</span><br>	<span class="hljs-keyword">if</span> shutdown != <span class="hljs-literal">nil</span> &amp;&amp; res.crash != <span class="hljs-literal">nil</span> &#123;<br>		needRepro := mgr.saveCrash(res.crash)<br>		<span class="hljs-keyword">if</span> needRepro &#123;<br>			log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: add pending repro for &#x27;%v&#x27;&quot;</span>, res.crash.Title)<br>			pendingRepro[res.crash] = <span class="hljs-literal">true</span><br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><code>reproDone</code> 中为 crash 的复现结果，这里会保存复现结果并将对应的 crash 从 <code>reproducing</code> 表中删除</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> res := &lt;-reproDone:<br>	atomic.AddUint32(&amp;mgr.numReproducing, ^<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))<br>	crepro := <span class="hljs-literal">false</span><br>	title := <span class="hljs-string">&quot;&quot;</span><br>	<span class="hljs-keyword">if</span> res.repro != <span class="hljs-literal">nil</span> &#123;<br>		crepro = res.repro.CRepro<br>		title = res.repro.Report.Title<br>	&#125;<br>	log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: repro on %+v finished &#x27;%v&#x27;, repro=%v crepro=%v desc=&#x27;%v&#x27;&quot;</span>,<br>		res.instances, res.report0.Title, res.repro != <span class="hljs-literal">nil</span>, crepro, title)<br>	<span class="hljs-keyword">if</span> res.err != <span class="hljs-literal">nil</span> &#123;<br>		log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;repro failed: %v&quot;</span>, res.err)<br>	&#125;<br>	<span class="hljs-built_in">delete</span>(reproducing, res.report0.Title)<br>	<span class="hljs-keyword">if</span> res.repro == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">if</span> !res.hub &#123;<br>			mgr.saveFailedRepro(res.report0, res.stats)<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		mgr.saveRepro(res)<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><code>shutdown</code> 中有数据则表示收到了终止信号，此时会将 <code>shutdown</code> 置为 nil，终止循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-shutdown:<br>	log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: shutting down...&quot;</span>)<br>	shutdown = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure>

<p><code>hubReproQueue</code> 上也可能传来 crash，此处将其送入 <code>pendingRepro</code> 表中等待在后续循环中复现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> crash := &lt;-mgr.hubReproQueue:<br>	log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;loop: get repro from hub&quot;</span>)<br>	pendingRepro[crash] = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p><code>needMoreRepros</code> 是一个传输 channel 的 channel，这里会将一个条件判断结果传入传来的 channel 中并重新跳回等待：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> reply := &lt;-mgr.needMoreRepros:<br>	reply &lt;- phase &gt;= phaseTriagedHub &amp;&amp;<br>		<span class="hljs-built_in">len</span>(reproQueue)+<span class="hljs-built_in">len</span>(pendingRepro)+<span class="hljs-built_in">len</span>(reproducing) == <span class="hljs-number">0</span><br>	<span class="hljs-keyword">goto</span> wait<br></code></pre></td></tr></table></figure>

<p>最后是 <code>reproRequest</code>，该 channel 意为<strong>主动进行复现的请求</strong>，这里会拷贝 <code>reproducing</code> 位图后将其传入传来的 channel 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">		<span class="hljs-keyword">case</span> reply := &lt;-mgr.reproRequest:<br>			repros := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br>			<span class="hljs-keyword">for</span> title := <span class="hljs-keyword">range</span> reproducing &#123;<br>				repros[title] = <span class="hljs-literal">true</span><br>			&#125;<br>			reply &lt;- repros<br>			<span class="hljs-keyword">goto</span> wait<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，<code>syz-manager</code> 的基本运行逻辑分析完毕</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/FUZZ/" class="category-chain-item">FUZZ</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/">#漏洞挖掘</a>
      
        <a href="/tags/FUZZ/">#FUZZ</a>
      
        <a href="/tags/syzkaller/">#syzkaller</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【FUZZ.0x02】syzkaller - II：syz-manager源码分析</div>
      <div>http://blog.arttnba3.cn/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月2日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/14/PAPER-0X01_VTW/" title="【PAPER.0x01】论文笔记：Virtual Wall: Filtering Rootkit Attacks To Protect Linux Kernel Functions ">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【PAPER.0x01】论文笔记：Virtual Wall: Filtering Rootkit Attacks To Protect Linux Kernel Functions </span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/" title="【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator">
                        <span class="hidden-mobile">【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
