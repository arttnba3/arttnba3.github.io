

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="arttnba3">
  <meta name="keywords" content="">
  
    <meta name="description" content="（摘下眼镜）Furry？（戴上眼镜）Fuzzer！">
<meta property="og:type" content="article">
<meta property="og:title" content="【FUZZ.0x03】syzkaller - III：syz-fuzzer 源码分析">
<meta property="og:url" content="https://arttnba3.github.io/2023/09/27/FUZZ-0X03-SYZKALLER-III_SOURCE_SYZFUZZER/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="（摘下眼镜）Furry？（戴上眼镜）Fuzzer！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/09/27/lbsTAikSnVxNcat.png">
<meta property="article:published_time" content="2023-09-26T15:26:14.000Z">
<meta property="article:modified_time" content="2023-12-30T09:06:06.000Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="漏洞挖掘">
<meta property="article:tag" content="FUZZ">
<meta property="article:tag" content="syzkaller">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2023/09/27/lbsTAikSnVxNcat.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【FUZZ.0x03】syzkaller - III：syz-fuzzer 源码分析 - arttnba3&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"arttnba3.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>arttnba3&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                rss
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://i.loli.net/2021/11/11/LxNvdhpEX2sBjYc.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【FUZZ.0x03】syzkaller - III：syz-fuzzer 源码分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-09-27 01:26" pubdate>
          2023年9月27日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          67k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          561 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【FUZZ.0x03】syzkaller - III：syz-fuzzer 源码分析</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年12月30日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>（摘下眼镜）Furry？（戴上眼镜）Fuzzer！</p>
<span id="more"></span>

<h1 id="0x00-一切开始之前"><a href="#0x00-一切开始之前" class="headerlink" title="0x00. 一切开始之前"></a>0x00. 一切开始之前</h1><p>在<a target="_blank" rel="noopener" href="https://arttnba3.cn/2023/03/02/FUZZ-0X02-SYZKALLER-II_SOURCE_SYZMANAGER/">上一篇文章</a>当中我们分析了 syzkaller 三大组件当中的 syz-manager 的源码，本篇文章我们继续来分析 syz-fuzzer 的源码</p>
<p>与 syz-manager 所不同的是，syz-fuzzer 位于 Guest VM 当中，<strong>本质上涵盖了一个传统 fuzzer 的所有基本功能</strong>：输入生成与变异、启动新进程（syz-executor）执行输入、获取覆盖率信息…</p>
<p>在 syz-fuzzer 运行过程中其会通过 RPC 调用 syz-manager 中的部分函数，因此本篇也会分析上篇所未涉及到的 syz-manager 中的一些函数：）</p>
<blockquote>
<p>这一系列文章确实鸽了挺久了，但最近确实是比较忙没啥时间写博客（这一篇其实之前大致的初稿就写好了，但是后面又鸽掉了…），不知道下一篇会是什么时候了 XD</p>
</blockquote>
<h1 id="0x01-基本结构体"><a href="#0x01-基本结构体" class="headerlink" title="0x01. 基本结构体"></a>0x01. 基本结构体</h1><p>相比于直接开始一头雾水地分析源码，笔者认为还是有必要在此之前先列出一些基本的结构体，你也可以把这一节当成一个表来查 ：）</p>
<h2 id="Fuzzing-过程相关"><a href="#Fuzzing-过程相关" class="headerlink" title="Fuzzing 过程相关"></a>Fuzzing 过程相关</h2><h3 id="1-Syscall：单个系统调用的基本信息"><a href="#1-Syscall：单个系统调用的基本信息" class="headerlink" title="1. Syscall：单个系统调用的基本信息"></a>1. Syscall：单个系统调用的基本信息</h3><p>syzkaller <strong>以系统调用为基本输入单位</strong>，定义于 <code>prog/types.go</code> 中的 <code>Syscall</code> 结构体被用来表示单个系统调用的基本信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Syscall <span class="hljs-keyword">struct</span> &#123;<br>	ID          <span class="hljs-type">int</span><br>	NR          <span class="hljs-type">uint64</span> <span class="hljs-comment">// kernel syscall number</span><br>	Name        <span class="hljs-type">string</span><br>	CallName    <span class="hljs-type">string</span><br>	MissingArgs <span class="hljs-type">int</span> <span class="hljs-comment">// number of trailing args that should be zero-filled</span><br>	Args        []Field<br>	Ret         Type<br>	Attrs       SyscallAttrs<br><br>	inputResources  []*ResourceDesc<br>	outputResources []*ResourceDesc<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们编写 syzlang 文件时，我们可以为系统调用<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/#call-attributes">添加一些属性</a>，这被封装于内嵌在 <code>Syscall</code> 里的 <code>SyscallAttrs</code> 结构体中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SyscallAttrs 表示 syzlang 的调用属性.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 该结构为系统所有其他部分的 source of truth.</span><br><span class="hljs-comment">// pkg/compiler 使用该结构对描述进行语法分析.</span><br><span class="hljs-comment">// syz-sysgen 使用该结构为 executor 生成代码.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 目前仅支持 `bool`s 与 `uint64`s.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 对于独立属性的描述，参见 docs/syscall_descriptions_syntax.md </span><br><span class="hljs-keyword">type</span> SyscallAttrs <span class="hljs-keyword">struct</span> &#123;<br>	Disabled      <span class="hljs-type">bool</span><br>	Timeout       <span class="hljs-type">uint64</span><br>	ProgTimeout   <span class="hljs-type">uint64</span><br>	IgnoreReturn  <span class="hljs-type">bool</span><br>	BreaksReturns <span class="hljs-type">bool</span><br>	NoGenerate    <span class="hljs-type">bool</span><br>	NoMinimize    <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-ChoiceTable：系统调用生成优先级表"><a href="#2-ChoiceTable：系统调用生成优先级表" class="headerlink" title="2. ChoiceTable：系统调用生成优先级表"></a>2. ChoiceTable：系统调用生成优先级表</h3><p>定义于 <code>prog/prio.go</code> 中的 <code>ChoiceTable</code> 是 syz-fuzzer 中非常核心的一个结构，其用于表示<strong>对于给定的系统调用 x，在添加入系统调用 y 后，代码覆盖率会上升的可能性</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ChooseTable（译注：原文如此）允许对给定的一个系统调用，</span><br><span class="hljs-comment">// 对一个系统调用进行一次权重选择，这基于调用到调用的优先级与开启&amp;可生成的系统调用集合</span><br><span class="hljs-keyword">type</span> ChoiceTable <span class="hljs-keyword">struct</span> &#123;<br>	target          *Target	<span class="hljs-comment">/* 目标架构信息 */</span><br>	runs            [][]<span class="hljs-type">int32</span> <span class="hljs-comment">/* 优先级表 */</span><br>	calls           []*Syscall <span class="hljs-comment">/* 系统调用信息 */</span><br>	noGenerateCalls <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>  <span class="hljs-comment">/* 不用于输入生成的系统调用号 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>优先级权重值存放在二维数组 <code>run</code> 中，需要注意的是这个优先级为<strong>累加值</strong>，例如有给定的三个系统调用 A、B、C，有这样的一个生成优先级表 <code>prios</code>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>那么在 <code>run</code> 表中则会将一列的结果逐个加起来，从而有这样的一个结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>为什么要这么做笔者也不知道 ：(</p>
<h3 id="3-weights：权重"><a href="#3-weights：权重" class="headerlink" title="3. weights：权重"></a>3. weights：权重</h3><p>定义于 <code>prog/prio.go</code> 中的 <code>weights</code> 结构体用于表示【目标系统调用的权重】：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> weights <span class="hljs-keyword">struct</span> &#123;<br>	call  <span class="hljs-type">int</span> <span class="hljs-comment">/* 系统调用号 */</span><br>	in    <span class="hljs-type">int32</span>  <span class="hljs-comment">/* 以该系统调用作为输入的权重值？ */</span><br>	inout <span class="hljs-type">int32</span>  <span class="hljs-comment">/* 以该系统调用作为输出的权重值？ */</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-Call：用作输入的单个系统调用"><a href="#4-Call：用作输入的单个系统调用" class="headerlink" title="4. Call：用作输入的单个系统调用"></a>4. Call：用作输入的单个系统调用</h3><p>syzkaller 的 fuzzing 以 syscall 为单位，<code>Syscall</code> 结构体用于表示单个系统调用的基本信息，<code>Call</code> 结构体则表示<strong>带有参数的一个系统调用</strong>，是 syzkaller 中所谓的最小输入单位</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Call <span class="hljs-keyword">struct</span> &#123;<br>	Meta    *Syscall<br>	Args    []Arg<br>	Ret     *ResultArg<br>	Props   CallProps<br>	Comment <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-ArgCtx：带上下文的参数"><a href="#5-ArgCtx：带上下文的参数" class="headerlink" title="5. ArgCtx：带上下文的参数"></a>5. ArgCtx：带上下文的参数</h3><p>系统调用的参数用 <code>Arg</code> 接口表示， <code>ArgCtx</code> 为实现了该接口的带有上下文的一个参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ArgCtx <span class="hljs-keyword">struct</span> &#123;<br>	Parent *[]Arg      <span class="hljs-comment">// GroupArg.Inner (for structs) or Call.Args containing this arg.</span><br>	Fields []Field     <span class="hljs-comment">// Fields of the parent struct/syscall.</span><br>	Base   *PointerArg <span class="hljs-comment">// Pointer to the base of the heap object containing this arg.</span><br>	Offset <span class="hljs-type">uint64</span>      <span class="hljs-comment">// Offset of this arg from the base.</span><br>	Stop   <span class="hljs-type">bool</span>        <span class="hljs-comment">// If set by the callback, subargs of this arg are not visited.</span><br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="6-Prog：单个输入程序"><a href="#6-Prog：单个输入程序" class="headerlink" title="6. Prog：单个输入程序"></a>6. Prog：单个输入程序</h3><p>通常情况下我们并不仅以一个系统调用作为输入，而是以<strong>一组系统调用序列</strong>作为输入单位——即一个<strong>程序</strong>，这也是 syzkaller 中<strong>实质上的最小输入单位</strong>，在 syz-fuzzer 当中使用 <code>Prog</code> 结构体来表示<strong>单个输入</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Prog <span class="hljs-keyword">struct</span> &#123;<br>	Target   *Target <span class="hljs-comment">/* 目标架构信息 */</span><br>	Calls    []*Call <span class="hljs-comment">/* 系统调用序列 */</span><br>	Comments []<span class="hljs-type">string</span>  <span class="hljs-comment">/* 注释？ */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-Candidate：序列化的单个输入项"><a href="#6-Candidate：序列化的单个输入项" class="headerlink" title="6. Candidate：序列化的单个输入项"></a>6. Candidate：序列化的单个输入项</h3><p>我们通常会有多个 syz-fuzzer 进程与 VM，而我们更希望<strong>在 fuzzer 之间共享那些有用的输入</strong>，这通常通过 <code>syz-fuzzer</code> 向 <code>syz-manager</code> 发起 RPC <code>poll()</code> 来完成——<code>candidate</code> 用以表示<strong>序列化后的输入</strong>，从而方便在不同 进程间传递：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Candidate <span class="hljs-keyword">struct</span> &#123;<br>	Prog      []<span class="hljs-type">byte</span>	<span class="hljs-comment">/* 序列化后的程序 */</span><br>	Minimized <span class="hljs-type">bool</span>	<span class="hljs-comment">/* 是否最小化？ */</span><br>	Smashed   <span class="hljs-type">bool</span>	<span class="hljs-comment">/* 是否要打碎重组？ */</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-CallInfo：单个系统调用的运行结果"><a href="#7-CallInfo：单个系统调用的运行结果" class="headerlink" title="7. CallInfo：单个系统调用的运行结果"></a>7. CallInfo：单个系统调用的运行结果</h3><p>执行完程序之后我们自然想要知道程序的执行结果，在 syz-fuzzer 当中使用 <code>CallInfo</code> 结构体表示<strong>单个系统调用的执行结果</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CallInfo <span class="hljs-keyword">struct</span> &#123;<br>	Flags  CallFlags<br>	Signal []<span class="hljs-type">uint32</span> <span class="hljs-comment">// 反馈信号, 若设置了 FlagSignal 则填充</span><br>	Cover  []<span class="hljs-type">uint32</span> <span class="hljs-comment">// 每个系统调用的覆盖率, 若设置了 FlagSignal 且 cover == true 则填充,</span><br>	<span class="hljs-comment">// if dedup == false, 则 cov 实际上包含了一个 trace, 否则重复项被删除</span><br>	Comps prog.CompMap <span class="hljs-comment">// 每个系统调用的比较操作数</span><br>	Errno <span class="hljs-type">int</span>          <span class="hljs-comment">// 调用的 errno (若调用成功则为 0)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 <code>CompMap</code> 为一个二重映射 <code>uint64 → 【uint64 → bool】</code> ，我们将在后文解释这个东西：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Example: for comparisons &#123;(op1, op2), (op1, op3), (op1, op4), (op2, op1)&#125;</span><br><span class="hljs-comment">// this map will store the following:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//	m = &#123;</span><br><span class="hljs-comment">//			op1: &#123;map[op2]: true, map[op3]: true, map[op4]: true&#125;,</span><br><span class="hljs-comment">//			op2: &#123;map[op1]: true&#125;</span><br><span class="hljs-comment">//	&#125;.</span><br><span class="hljs-keyword">type</span> CompMap <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure>



<h3 id="8-ProgInfo：单个程序的运行结果"><a href="#8-ProgInfo：单个程序的运行结果" class="headerlink" title="8. ProgInfo：单个程序的运行结果"></a>8. ProgInfo：单个程序的运行结果</h3><p>syzkaller 中单次运行的最小粒度其实是由一组系统调用构成的一个程序，因此程序的运行结果很自然地就是由一组 <code>CallInfo</code> 构成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ProgInfo <span class="hljs-keyword">struct</span> &#123;<br>	Calls []CallInfo<br>	Extra CallInfo <span class="hljs-comment">// stores Signal and Cover collected from background threads</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="9-Env：syz-executor-的执行环境信息"><a href="#9-Env：syz-executor-的执行环境信息" class="headerlink" title="9. Env：syz-executor 的执行环境信息"></a>9. Env：syz-executor 的执行环境信息</h3><p> <code>Env</code> 结构体用来记录 syz-executor 的执行环境信息，如输入、输出、执行的命令行等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br>	in  []<span class="hljs-type">byte</span><br>	out []<span class="hljs-type">byte</span><br><br>	cmd       *command<br>	inFile    *os.File<br>	outFile   *os.File<br>	bin       []<span class="hljs-type">string</span><br>	linkedBin <span class="hljs-type">string</span><br>	pid       <span class="hljs-type">int</span><br>	config    *Config<br><br>	StatExecs    <span class="hljs-type">uint64</span><br>	StatRestarts <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="10-WorkTriage-WorkCandidate-WorkSmash-：实际的单个输入项"><a href="#10-WorkTriage-WorkCandidate-WorkSmash-：实际的单个输入项" class="headerlink" title="10. WorkTriage&#x2F;WorkCandidate&#x2F;WorkSmash ：实际的单个输入项"></a>10. WorkTriage&#x2F;WorkCandidate&#x2F;WorkSmash ：实际的单个输入项</h3><p>在 fuzzing 过程当中 我们实际上不直接以 raw 的 <code>Prog</code> 作为输入，我们还想要在输入上标识更多额外的信息——因此便需要加上一层 wrapper，一共有如下<strong>三种类型</strong>：</p>
<ul>
<li><code>WorkTriage</code>：可能提供新的覆盖率的程序</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkTriage 为我们在初次执行时所注意到的潜在新覆盖的程序.</span><br><span class="hljs-comment">// 但我们并不能确定是否这是真实的覆盖率.</span><br><span class="hljs-comment">// 在分类中我们明白了这些程序是否真的给出了新的覆盖率，</span><br><span class="hljs-comment">// 若是，则将其最小化并添加到语料库中.</span><br><span class="hljs-keyword">type</span> WorkTriage <span class="hljs-keyword">struct</span> &#123;<br>	p     *prog.Prog	<span class="hljs-comment">/* 系统调用序列 */</span><br>	call  <span class="hljs-type">int</span>	<span class="hljs-comment">/* interesting 的系统调用号？ */</span><br>	info  ipc.CallInfo	<span class="hljs-comment">/* 运行结果 */</span><br>	flags ProgTypes<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>WorkCandidate</code>：由 hub（也就是 syz-manager）传来的程序</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkCandidate 为来自 hub 的程序.</span><br><span class="hljs-comment">// 我们暂不知道她们对当前 fuzzer 是否有用.</span><br><span class="hljs-comment">// 进程以对本地生成/变异程序相同的方式处理她们.</span><br><span class="hljs-keyword">type</span> WorkCandidate <span class="hljs-keyword">struct</span> &#123;<br>	p     *prog.Prog	<span class="hljs-comment">/* 系统调用序列 */</span><br>	flags ProgTypes<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>WorkSmash</code>：刚刚被加入到语料库中的程序</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkSmash 为刚刚添加到语料库中的程序.</span><br><span class="hljs-comment">// 在 smashing 过程中这些程序将收到一次特别的关注</span><br><span class="hljs-comment">// (emit faults, collect comparison hints, etc).</span><br><span class="hljs-keyword">type</span> WorkSmash <span class="hljs-keyword">struct</span> &#123;<br>	p    *prog.Prog	<span class="hljs-comment">/* 系统调用序列 */</span><br>	call <span class="hljs-type">int</span>	<span class="hljs-comment">/* interesting 的系统调用号？ */</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="11-Cover：覆盖率信息"><a href="#11-Cover：覆盖率信息" class="headerlink" title="11. Cover：覆盖率信息"></a>11. Cover：覆盖率信息</h3><p>主流的 fuzzer 都是基于覆盖率指导的，syzkaller 也不例外，在 syz-fuzzer 中使用 <code>Cover</code> 结构体表示覆盖率信息：</p>
<blockquote>
<p> 没有注释所以笔者也没太看明白是怎么个意思：( </p>
<p>目前推测 key 是 program counter，val 目前无实际意义只是用来占位表示覆盖到了该地址</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cover <span class="hljs-keyword">map</span>[<span class="hljs-type">uint32</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure>



<h2 id="输入生成变异相关"><a href="#输入生成变异相关" class="headerlink" title="输入生成变异相关"></a>输入生成变异相关</h2><h3 id="0-hint-机制"><a href="#0-hint-机制" class="headerlink" title="0. hint 机制"></a>0. hint 机制</h3><p>我们首先来看 syz-executor 中一个重要的变异机制——<code>mutate with hint</code> （可以理解为 hint 辅助的变异），在 <code>hint.go</code> 开头有如下注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一个 hint 大体而言为一个由指向一个程序中一个系统调用的一个参数的指针</span><br><span class="hljs-comment">// 与一个应当被赋给该参数的值（我们称之为 replacer）组成.</span><br><span class="hljs-comment">//（译注：什么B长难句）</span><br><br><span class="hljs-comment">// 一个简易版本的 hints workflow 形如:</span><br><span class="hljs-comment">//		1. Fuzzer 启动一个程序 (称之为 hint 种子) 并为程序中的每个系统调用</span><br><span class="hljs-comment">// 收集所有的比较数据.</span><br><span class="hljs-comment">//		2. 接下来其尝试将所获得的比较操作数的值于输入参数值进行匹配.</span><br><span class="hljs-comment">//		3. 对于每一个这样的匹配，fuzzer 通过将指向的参数使用保存的值进行替换来变异程序.</span><br><span class="hljs-comment">//		4. 若获得了一个合法的程序, fuzzer 将其启动并检查是否获得了新的覆盖率.</span><br><span class="hljs-comment">// 要了解更多关于特定突变的信息，参见 prog/hints_test.go.</span><br></code></pre></td></tr></table></figure>

<h3 id="1-CompMap：用作比较的参数的收缩-扩展替换取值表【核心】"><a href="#1-CompMap：用作比较的参数的收缩-扩展替换取值表【核心】" class="headerlink" title="1.CompMap：用作比较的参数的收缩&#x2F;扩展替换取值表【核心】"></a>1.CompMap：用作比较的参数的收缩&#x2F;扩展替换取值表【核心】</h3><p>CompMap 为一个 <code>uint64 </code>到 <code>[uint64 到 bool 的映射]</code> 的映射，用来在<strong>输入变异的时候进行参数值的替换</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 🌰: 对于比较对 &#123;(op1, op2), (op1, op3), (op1, op4), (op2, op1)&#125;</span><br><span class="hljs-comment">// 该映射将存储如下:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//	m = &#123;</span><br><span class="hljs-comment">//			op1: &#123;map[op2]: true, map[op3]: true, map[op4]: true&#125;,</span><br><span class="hljs-comment">//			op2: &#123;map[op1]: true&#125;</span><br><span class="hljs-comment">//	&#125;.</span><br><span class="hljs-keyword">type</span> CompMap <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure>

<p>看着比较抽象，<del>笔者看了半天也不知道这™是个啥玩意</del>，下面我们结合 <code>prog/hints_test.go</code> 中的示例来看：）</p>
<p><strong>条件分支</strong>是现代编程语言中的一个基本结构，例如我们有如下函数，其会根据不同的取值进入不同的分支：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Models the following code:</span><br><span class="hljs-comment">// void f(u64 qw) &#123;</span><br><span class="hljs-comment">//		u8 b = (u8) qw</span><br><span class="hljs-comment">//		u16 w = (u16) qw</span><br><span class="hljs-comment">//		u32 dw = (u32) qw</span><br><span class="hljs-comment">//		if (b == 0xab) &#123;...&#125;</span><br><span class="hljs-comment">//		if (w == 0xcdcd) &#123;...&#125;</span><br><span class="hljs-comment">//		if (dw == 0xefefefef) &#123;...&#125;</span><br><span class="hljs-comment">//		if (qw == 0x0101010101010101) &#123;...&#125;</span><br><span class="hljs-comment">//  &#125;; f(0x1234567890abcdef);</span><br></code></pre></td></tr></table></figure>

<p>我们给该函数传入的参数为 <code>0x1234567890abcdef</code> 在该函数当中参数由于强制类型转换而发生了<strong>截断</strong>，我们称之为<strong>收缩</strong>（shrink），由于参数截断之后一个条件都匹配不上，所以我们一个分支都进不去：(</p>
<p>那么如果我们想要走进不同的分支该怎么办呢？ <code>0x1234567890abcdef</code> 截断成 <code>u8</code> 后变成 <code>0xef</code>，如果我们想要走进第一个条件分支那就要替换成 <code>0xab</code>；类似地， <code>0x1234567890abcdef</code> 截断成 <code>u16</code> 后变成 <code>0xcdef</code>，如果我们想要走进第二个条件分支那就要替换成 <code>0xcdcd</code> ； <code>0x1234567890abcdef</code> 截断成 <code>u32</code> 后变成 <code>0xabcdef</code>，如果我们想要走进第三个条件分支那就要替换成 <code>0xefefef</code> ； 而如果我们想要走进最后一个条件分支，则需要将参数整个替换成 <code>0x0101010101010101</code> ，<strong>由此我们得到如下 CompMap</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">CompMap&#123;<br>	<span class="hljs-number">0xef</span>:               compSet(<span class="hljs-number">0xab</span>, <span class="hljs-number">0xef</span>),<br>	<span class="hljs-number">0xcdef</span>:             compSet(<span class="hljs-number">0xcdcd</span>),<br>	<span class="hljs-number">0x90abcdef</span>:         compSet(<span class="hljs-number">0xefefefef</span>),<br>	<span class="hljs-number">0x1234567890abcdef</span>: compSet(<span class="hljs-number">0x0101010101010101</span>),<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>根据该 <code>CompMap</code> ，我们最后得到<strong>可以用来替换原参数的新参数值为</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">[]<span class="hljs-type">uint64</span>&#123;<br>	<span class="hljs-number">0x0101010101010101</span>,<br>	<span class="hljs-number">0x1234567890abcdab</span>,<br>	<span class="hljs-number">0x1234567890abcdcd</span>,<br>	<span class="hljs-number">0x12345678efefefef</span>,<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>在 syzkaller 的实际运行过程当中，这些比较操作数<strong>对应的是内核中的代码分支</strong>，syzkaller 通过 <code>KCOV</code> 获取这些比较操作数，从而对程序输入变异<strong>以获取更高的代码覆盖率</strong></p>
<h2 id="全局管控相关"><a href="#全局管控相关" class="headerlink" title="全局管控相关"></a>全局管控相关</h2><h3 id="1-Fuzzer：基本信息"><a href="#1-Fuzzer：基本信息" class="headerlink" title="1. Fuzzer：基本信息"></a>1. Fuzzer：基本信息</h3><p><code>Fuzzer</code> 结构体用以存储一个 syz-fuzzer 的所有基本信息，定义于 <code>syz-fuzzer/fuzzer.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Fuzzer <span class="hljs-keyword">struct</span> &#123;<br>	name        <span class="hljs-type">string</span><br>	outputType  OutputType<br>	config      *ipc.Config<br>	execOpts    *ipc.ExecOpts<br>	procs       []*Proc<br>	gate        *ipc.Gate<br>	workQueue   *WorkQueue<br>	needPoll    <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>	choiceTable *prog.ChoiceTable<br>	noMutate    <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span><br>	<span class="hljs-comment">// stats 域不幸的无法仅是一个 uint64 数组, 因为其在 32 位平台上</span><br>	<span class="hljs-comment">// 会造成 &quot;unaligned 64-bit atomic operation&quot; 错误</span><br>	stats             []<span class="hljs-type">uint64</span><br>	manager           *rpctype.RPCClient<br>	target            *prog.Target<br>	triagedCandidates <span class="hljs-type">uint32</span><br>	timeouts          targets.Timeouts<br><br>	faultInjectionEnabled    <span class="hljs-type">bool</span><br>	comparisonTracingEnabled <span class="hljs-type">bool</span><br>	fetchRawCover            <span class="hljs-type">bool</span><br><br>	corpusMu     sync.RWMutex<br>	corpus       []*prog.Prog<br>	corpusHashes <span class="hljs-keyword">map</span>[hash.Sig]<span class="hljs-keyword">struct</span>&#123;&#125;<br>	corpusPrios  []<span class="hljs-type">int64</span><br>	sumPrios     <span class="hljs-type">int64</span><br><br>	signalMu     sync.RWMutex<br>	corpusSignal signal.Signal <span class="hljs-comment">// 语料库中的输入的信号</span><br>	maxSignal    signal.Signal <span class="hljs-comment">// 包括 flakes 在内的所观察到的最大信号</span><br>	newSignal    signal.Signal <span class="hljs-comment">// 自上次与 master 同步以来的 diff of maxSignal</span><br><br>	checkResult *rpctype.CheckArgs<br>	logMu       sync.Mutex<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="2-Target：目标架构信息"><a href="#2-Target：目标架构信息" class="headerlink" title="2. Target：目标架构信息"></a>2. Target：目标架构信息</h3><p>定义于 <code>prog/target.go</code> 中的 <code>Target</code> 结构体用以表示 fuzzing 目标架构的基本信息：</p>
<blockquote>
<p>懒得翻译了，太多字了，自己看：）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Target describes target OS/arch pair.</span><br><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> &#123;<br>	OS                <span class="hljs-type">string</span><br>	Arch              <span class="hljs-type">string</span><br>	Revision          <span class="hljs-type">string</span> <span class="hljs-comment">// unique hash representing revision of the descriptions</span><br>	PtrSize           <span class="hljs-type">uint64</span><br>	PageSize          <span class="hljs-type">uint64</span><br>	NumPages          <span class="hljs-type">uint64</span><br>	DataOffset        <span class="hljs-type">uint64</span><br>	LittleEndian      <span class="hljs-type">bool</span><br>	ExecutorUsesShmem <span class="hljs-type">bool</span><br><br>	Syscalls  []*Syscall<br>	Resources []*ResourceDesc<br>	Consts    []ConstValue<br><br>	<span class="hljs-comment">// MakeDataMmap creates calls that mmaps target data memory range.</span><br>	MakeDataMmap <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> []*Call<br><br>	<span class="hljs-comment">// Neutralize neutralizes harmful calls by transforming them into non-harmful ones</span><br>	<span class="hljs-comment">// (e.g. an ioctl that turns off console output is turned into ioctl that turns on output).</span><br>	<span class="hljs-comment">// fixStructure determines whether it&#x27;s allowed to make structural changes (e.g. add or</span><br>	<span class="hljs-comment">// remove arguments). It is helpful e.g. when we do neutralization while iterating over the</span><br>	<span class="hljs-comment">// arguments.</span><br>	Neutralize <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Call, fixStructure <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">error</span><br><br>	<span class="hljs-comment">// AnnotateCall annotates a syscall invocation in C reproducers.</span><br>	<span class="hljs-comment">// The returned string will be placed inside a comment except for the</span><br>	<span class="hljs-comment">// empty string which will omit the comment.</span><br>	AnnotateCall <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c ExecCall)</span></span> <span class="hljs-type">string</span><br><br>	<span class="hljs-comment">// SpecialTypes allows target to do custom generation/mutation for some struct&#x27;s and union&#x27;s.</span><br>	<span class="hljs-comment">// Map key is struct/union name for which custom generation/mutation is required.</span><br>	<span class="hljs-comment">// Map value is custom generation/mutation function that will be called</span><br>	<span class="hljs-comment">// for the corresponding type. g is helper object that allows generate random numbers,</span><br>	<span class="hljs-comment">// allocate memory, etc. typ is the struct/union type. old is the old value of the struct/union</span><br>	<span class="hljs-comment">// for mutation, or nil for generation. The function returns a new value of the struct/union,</span><br>	<span class="hljs-comment">// and optionally any calls that need to be inserted before the arg reference.</span><br>	SpecialTypes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(g *Gen, typ Type, dir Dir, old Arg)</span></span> (Arg, []*Call)<br><br>	<span class="hljs-comment">// Resources that play auxiliary role, but widely used throughout all syscalls (e.g. pid/uid).</span><br>	AuxResources <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span><br><br>	<span class="hljs-comment">// Additional special invalid pointer values besides NULL to use.</span><br>	SpecialPointers []<span class="hljs-type">uint64</span><br><br>	<span class="hljs-comment">// Special file name length that can provoke bugs (e.g. PATH_MAX).</span><br>	SpecialFileLenghts []<span class="hljs-type">int</span><br><br>	<span class="hljs-comment">// Filled by prog package:</span><br>	SyscallMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Syscall<br>	ConstMap   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">uint64</span><br><br>	init        sync.Once<br>	initArch    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target *Target)</span></span><br>	types       []Type<br>	resourceMap <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*ResourceDesc<br>	<span class="hljs-comment">// Maps resource name to a list of calls that can create the resource.</span><br>	resourceCtors <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]*Syscall<br>	any           anyTypes<br><br>	<span class="hljs-comment">// The default ChoiceTable is used only by tests and utilities, so we initialize it lazily.</span><br>	defaultOnce        sync.Once<br>	defaultChoiceTable *ChoiceTable<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-Proc：syz-executor-实例对象"><a href="#3-Proc：syz-executor-实例对象" class="headerlink" title="3. Proc：syz-executor 实例对象"></a>3. Proc：syz-executor 实例对象</h3><p>在 syz-fuzzer 当中 <code>Proc</code> 结构体被用以表示<strong>一个 syz-executor 实例</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Proc 表示一个单独的 fuzzing 程序 (executor).</span><br><span class="hljs-keyword">type</span> Proc <span class="hljs-keyword">struct</span> &#123;<br>	fuzzer          *Fuzzer<br>	pid             <span class="hljs-type">int</span><br>	env             *ipc.Env<br>	rnd             *rand.Rand<br>	execOpts        *ipc.ExecOpts<br>	execOptsCollide *ipc.ExecOpts<br>	execOptsCover   *ipc.ExecOpts<br>	execOptsComps   *ipc.ExecOpts<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 <code>env</code> 成员用以表示单个 syz-executor 的运行环境，定义于 <code>pkg/ipc/ipc.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">struct</span> &#123;<br>	in  []<span class="hljs-type">byte</span><br>	out []<span class="hljs-type">byte</span><br><br>	cmd       *command<br>	inFile    *os.File<br>	outFile   *os.File<br>	bin       []<span class="hljs-type">string</span><br>	linkedBin <span class="hljs-type">string</span><br>	pid       <span class="hljs-type">int</span><br>	config    *Config<br><br>	StatExecs    <span class="hljs-type">uint64</span><br>	StatRestarts <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Env-&gt;cmd</code> 则用以表示执行 syz-executor 的命令信息，包括 pid、配置、命令行参数等：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> command <span class="hljs-keyword">struct</span> &#123;<br>	pid      <span class="hljs-type">int</span><br>	config   *Config<br>	timeout  time.Duration<br>	cmd      *exec.Cmd<br>	dir      <span class="hljs-type">string</span><br>	readDone <span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span><br>	exited   <span class="hljs-keyword">chan</span> <span class="hljs-type">error</span><br>	inrp     *os.File<br>	outwp    *os.File<br>	outmem   []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>command-&gt;cmd</code> 为最终用来执行 syz-executor 的命令行，来自于 golang 原生的 exec 库</p>
<h3 id="4-WorkQueue：待使用的单-syz-fuzer-的全局输入队列"><a href="#4-WorkQueue：待使用的单-syz-fuzer-的全局输入队列" class="headerlink" title="4. WorkQueue：待使用的单 syz-fuzer 的全局输入队列"></a>4. WorkQueue：待使用的单 syz-fuzer 的全局输入队列</h3><p>在 syz-fuzzer 当中所有的输入都被存放在 <code>WorkQueue</code> 队列当中，一个 syz-fuzzer 可能会启动多个 syz-executor 进程，他们共享同一个 <code>WorkQueue</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WorkQueue 存放全局的 non-fuzzing 工作项目 (参见下面的 Work* 结构体).</span><br><span class="hljs-comment">// WorkQueue 也在工作项目间进行优先排序，例如我们想要在我们碎片化程序前</span><br><span class="hljs-comment">// 分类并向 manager 发送新的输入以在 VM 崩溃的情况下不会永久失去有趣的程序.</span><br><span class="hljs-comment">//（译注：interesting input 在 fuzzing 中是经典概念了，这里应该不需要笔者注释了）</span><br><span class="hljs-keyword">type</span> WorkQueue <span class="hljs-keyword">struct</span> &#123;<br>	mu              sync.RWMutex<br>	triageCandidate []*WorkTriage<br>	candidate       []*WorkCandidate<br>	triage          []*WorkTriage<br>	smash           []*WorkSmash<br><br>	procs          <span class="hljs-type">int</span><br>	needCandidates <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们可以看到 <code>WorkQueue</code> 为 <code>WorkTriage/WorkCandidate/WorkSmash</code> 都分别建立了一个新的队列 </p>
<h2 id="fuzzer-executor-通信相关"><a href="#fuzzer-executor-通信相关" class="headerlink" title="fuzzer &amp; executor 通信相关"></a>fuzzer &amp; executor 通信相关</h2><h3 id="1-executeReq：fuzzer→executor-请求头"><a href="#1-executeReq：fuzzer→executor-请求头" class="headerlink" title="1. executeReq：fuzzer→executor 请求头"></a>1. executeReq：fuzzer→executor 请求头</h3><p>fuzzing 的主体进程由 syz-fuzzer 完成，syz-executor 仅需要完成单个输入程序的运行，因此 syz-fuzzer 需要多次与 syz-executor 间通信：发送待运行的数据并接收运行结果</p>
<p>syz-fuzzer 与 syz-executor 间通信通过管道完成，因此每次通信前 syz-fuzzer 需要手动告诉 syz-executor 本次待接收的数据类型、长度等信息，这些信息被封装在固定大小的 <code>executeReq</code> 结构体当中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> executeReq <span class="hljs-keyword">struct</span> &#123;<br>	magic            <span class="hljs-type">uint64</span><br>	envFlags         <span class="hljs-type">uint64</span> <span class="hljs-comment">// env flags</span><br>	execFlags        <span class="hljs-type">uint64</span> <span class="hljs-comment">// exec flags</span><br>	pid              <span class="hljs-type">uint64</span><br>	syscallTimeoutMS <span class="hljs-type">uint64</span><br>	programTimeoutMS <span class="hljs-type">uint64</span><br>	slowdownScale    <span class="hljs-type">uint64</span><br>	progSize         <span class="hljs-type">uint64</span><br>	<span class="hljs-comment">// 该结构体之后跟着一个 encodingexec 格式的序列化的测试程序.</span><br>	<span class="hljs-comment">// Both when sent over a pipe or in shared memory.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以理解为 <code>executeReq</code> 为单次请求的请求头，后面跟着的序列化输入程序 <code>progData</code> 为单次请求的请求体，故 syz-fuzzer 向 syz-executor 发送单个程序执行请求的示例如下：</p>
<p><img src="https://s2.loli.net/2023/04/24/I6od1evyCE3MZWH.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="2-executeReply-callReply：executor-方响应的单个系统调用执行结果"><a href="#2-executeReply-callReply：executor-方响应的单个系统调用执行结果" class="headerlink" title="2. executeReply &amp; callReply：executor 方响应的单个系统调用执行结果"></a>2. executeReply &amp; callReply：executor 方响应的单个系统调用执行结果</h3><p>有收便有发，syz-executor 在完成执行后会通过另一个管道将执行结果发送给 syz-fuzzer，由于 syzkaller 以单个系统调用为执行的最小粒度，因此syz-executor 每次返回给 syz-fuzzer 的便是<strong>单个系统调用的执行结果</strong>，使用一个头部 <code>executeReply</code> 标识信息，使用 <code>callReply</code> 存储具体结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> executeReply <span class="hljs-keyword">struct</span> &#123;<br>	magic <span class="hljs-type">uint32</span><br>	<span class="hljs-comment">// If done is 0, then this is call completion message followed by callReply.</span><br>	<span class="hljs-comment">// If done is 1, then program execution is finished and status is set.</span><br>	done   <span class="hljs-type">uint32</span><br>	status <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> callReply <span class="hljs-keyword">struct</span> &#123;<br>	magic      <span class="hljs-type">uint32</span><br>	index      <span class="hljs-type">uint32</span> <span class="hljs-comment">// call index in the program</span><br>	num        <span class="hljs-type">uint32</span> <span class="hljs-comment">// syscall number (for cross-checking)</span><br>	errno      <span class="hljs-type">uint32</span><br>	flags      <span class="hljs-type">uint32</span> <span class="hljs-comment">// see CallFlags</span><br>	signalSize <span class="hljs-type">uint32</span><br>	coverSize  <span class="hljs-type">uint32</span><br>	compsSize  <span class="hljs-type">uint32</span><br>	<span class="hljs-comment">// signal/cover/comps follow</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>executeReply</code> 中的 done 标志位用以标识传输是否结束，对于来自 syz-fuzzer 的单次执行请求，syz-executor 的返回结果如下（以一个 <code>done != 0</code> 的 <code>executeReply</code> 作为终止）：</p>
<p><img src="https://s2.loli.net/2023/04/24/seE43rD2uaXCbwj.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="0x02-main-：与-manager-建立-RPC-连接，进行初始化工作"><a href="#0x02-main-：与-manager-建立-RPC-连接，进行初始化工作" class="headerlink" title="0x02. main()：与 manager 建立 RPC 连接，进行初始化工作"></a>0x02. main()：与 manager 建立 RPC 连接，进行初始化工作</h1><p>我们还是按照惯例从程序入口点进行分析，<code>syz-fuzzer()</code> 的 <code>main()</code> 函数做的工作比较简单，主要还是一些初始化工作以及引导后续工作流程</p>
<h2 id="初始化参数解析与-RPC-连接，获取语料库与输入"><a href="#初始化参数解析与-RPC-连接，获取语料库与输入" class="headerlink" title="初始化参数解析与 RPC 连接，获取语料库与输入"></a>初始化参数解析与 RPC 连接，获取语料库与输入</h2><h3 id="Step-I-一些初始化工作"><a href="#Step-I-一些初始化工作" class="headerlink" title="Step.I - 一些初始化工作"></a>Step.I - 一些初始化工作</h3><p>一开始还是惯例的各种初始化和配置参数解析工作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// nolint: funlen</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	debug.SetGCPercent(<span class="hljs-number">50</span>)<br><br>	<span class="hljs-keyword">var</span> (<br>		flagName     = flag.String(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;unique name for manager&quot;</span>)<br>		flagOS       = flag.String(<span class="hljs-string">&quot;os&quot;</span>, runtime.GOOS, <span class="hljs-string">&quot;target OS&quot;</span>)<br>		flagArch     = flag.String(<span class="hljs-string">&quot;arch&quot;</span>, runtime.GOARCH, <span class="hljs-string">&quot;target arch&quot;</span>)<br>		flagManager  = flag.String(<span class="hljs-string">&quot;manager&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;manager rpc address&quot;</span>)<br>		flagProcs    = flag.Int(<span class="hljs-string">&quot;procs&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;number of parallel test processes&quot;</span>)<br>		flagOutput   = flag.String(<span class="hljs-string">&quot;output&quot;</span>, <span class="hljs-string">&quot;stdout&quot;</span>, <span class="hljs-string">&quot;write programs to none/stdout/dmesg/file&quot;</span>)<br>		flagTest     = flag.Bool(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;enable image testing mode&quot;</span>)      <span class="hljs-comment">// used by syz-ci</span><br>		flagRunTest  = flag.Bool(<span class="hljs-string">&quot;runtest&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;enable program testing mode&quot;</span>) <span class="hljs-comment">// used by pkg/runtest</span><br>		flagRawCover = flag.Bool(<span class="hljs-string">&quot;raw_cover&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;fetch raw coverage&quot;</span>)<br>	)<br>	<span class="hljs-keyword">defer</span> tool.Init()()<br>	outputType := parseOutputType(*flagOutput)<br>	log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;fuzzer started&quot;</span>)<br><br>	target, err := prog.GetTarget(*flagOS, *flagArch)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>	&#125;<br><br>	config, execOpts, err := ipcconfig.Default(target)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;failed to create default ipc config: %v&quot;</span>, err)<br>	&#125;<br>	<span class="hljs-keyword">if</span> *flagRawCover &#123;<br>		execOpts.Flags &amp;^= ipc.FlagDedupCover<br>	&#125;<br>	timeouts := config.Timeouts<br>	sandbox := ipc.FlagsToSandbox(config.Flags)<br></code></pre></td></tr></table></figure>

<p>接下来会创建一个 <code>shutdown</code> channel 并启动一个协程进行监测，当该 channel 有数据时说明遇到了一些情况，此时 syz-fuzzer 需要主动退出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">shutdown := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>osutil.HandleInterrupts(shutdown)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// Handles graceful preemption on GCE.</span><br>	&lt;-shutdown<br>	log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;SYZ-FUZZER: PREEMPTED&quot;</span>)<br>	os.Exit(<span class="hljs-number">1</span>)<br>&#125;()<br></code></pre></td></tr></table></figure>

<p><code>osutil.HandleInterrupts()</code> 则是一个根据不同的目标 os 进行定制的函数，对于 unix 系 os 而言该函数定义于 <code>osutil_unix.go</code> 中，其会等待收到三个 SIGINT 信号才真正关闭程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HandleInterrupts 在第一个 SIGINT 时关闭 shutdown chan</span><br><span class="hljs-comment">// (希望程序能优雅地 shutdown 并 exit)</span><br><span class="hljs-comment">// 并在第三个 SIGINT 时终止程序.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleInterrupts</span><span class="hljs-params">(shutdown <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">3</span>)<br>		signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)<br>		&lt;-c<br>		<span class="hljs-built_in">close</span>(shutdown)<br>		fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;SIGINT: shutting down...\n&quot;</span>)<br>		&lt;-c<br>		fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;SIGINT: shutting down harder...\n&quot;</span>)<br>		&lt;-c<br>		fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;SIGINT: terminating\n&quot;</span>)<br>		os.Exit(<span class="hljs-type">int</span>(syscall.SIGINT))<br>	&#125;()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Step-II-与-syz-manager-间建立-RPC-通信，加载语料库"><a href="#Step-II-与-syz-manager-间建立-RPC-通信，加载语料库" class="headerlink" title="Step.II - 与 syz-manager 间建立 RPC 通信，加载语料库"></a>Step.II - 与 syz-manager 间建立 RPC 通信，加载语料库</h3><p>回到 <code>main()</code> 中，接下来会收集 Guest 信息并尝试与 Host（syz-manager） 间建立 RPC 连接，若失败则直接退出，这里我们传给 syz-manager 的是 <code>rpctype.ConnectArgs</code>，收到的响应结果为 <code>rpctype.ConnectRes</code> ，其中包含有很多信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go">checkArgs := &amp;checkArgs&#123;<br>	target:         target,<br>	sandbox:        sandbox,<br>	ipcConfig:      config,<br>	ipcExecOpts:    execOpts,<br>	gitRevision:    prog.GitRevision,<br>	targetRevision: target.Revision,<br>&#125;<br><span class="hljs-keyword">if</span> *flagTest &#123;<br>	testImage(*flagManager, checkArgs)<br>	<span class="hljs-keyword">return</span><br>&#125;<br><br>machineInfo, modules := collectMachineInfos(target)<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;dialing manager at %v&quot;</span>, *flagManager)<br>manager, err := rpctype.NewRPCClient(*flagManager, timeouts.Scale)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	log.Fatalf(<span class="hljs-string">&quot;failed to create an RPC client: %v &quot;</span>, err)<br>&#125;<br><br>log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;connecting to manager...&quot;</span>)<br>a := &amp;rpctype.ConnectArgs&#123;<br>	Name:        *flagName,<br>	MachineInfo: machineInfo,<br>	Modules:     modules,<br>&#125;<br>r := &amp;rpctype.ConnectRes&#123;&#125;<br><span class="hljs-keyword">if</span> err := manager.Call(<span class="hljs-string">&quot;Manager.Connect&quot;</span>, a, r); err != <span class="hljs-literal">nil</span> &#123;<br>	log.Fatalf(<span class="hljs-string">&quot;failed to call Manager.Connect(): %v &quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>syz-fuzzer 中的 RPC 都会调用到 <code>syz-manager/rpc.go</code> 中的 <code>RPCServer</code> 的成员函数，我们最终会调用到 syz-manager 上的 <code>Connect()</code> 函数进行连接，其核心是调用 <code>RPCServer.RPCManagerView.fuzzerConnect()</code> 最小化语料库并拷贝 BugFrame 等信息，这里就不展开分析了：）</p>
<p>接下来解析要开启的特性标志位；随后检查与 syz-manager 进行 RPC 连接的响应结果中的 <code>CoverFilterBitmap</code> 是否为空，不为空则写入到 <code>&quot;syz-cover-bitmap&quot;</code> 文件中，该信息主要是给 syz-executor 用的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">featureFlags, err := csource.ParseFeaturesFlags(<span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> r.CoverFilterBitmap != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">if</span> err := osutil.WriteFile(<span class="hljs-string">&quot;syz-cover-bitmap&quot;</span>, r.CoverFilterBitmap); err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;failed to write syz-cover-bitmap: %v&quot;</span>, err)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之后若 syz-manager 返回结果中的 <code>CheckResult</code> 为空，则重新生成配置信息后通过 RPC 调用 syz-manager 的 <code>Manager.Check()</code> ，若有错误则直接退出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> r.CheckResult == <span class="hljs-literal">nil</span> &#123;<br>	checkArgs.gitRevision = r.GitRevision<br>	checkArgs.targetRevision = r.TargetRevision<br>	checkArgs.enabledCalls = r.EnabledCalls<br>	checkArgs.allSandboxes = r.AllSandboxes<br>	checkArgs.featureFlags = featureFlags<br>	r.CheckResult, err = checkMachine(checkArgs)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">if</span> r.CheckResult == <span class="hljs-literal">nil</span> &#123;<br>			r.CheckResult = <span class="hljs-built_in">new</span>(rpctype.CheckArgs)<br>		&#125;<br>		r.CheckResult.Error = err.Error()<br>	&#125;<br>	r.CheckResult.Name = *flagName<br>	<span class="hljs-keyword">if</span> err := manager.Call(<span class="hljs-string">&quot;Manager.Check&quot;</span>, r.CheckResult, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;Manager.Check call failed: %v&quot;</span>, err)<br>	&#125;<br>	<span class="hljs-keyword">if</span> r.CheckResult.Error != <span class="hljs-string">&quot;&quot;</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;%v&quot;</span>, r.CheckResult.Error)<br>	&#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>这次 RPC 实际上会调用到 syz-manager 中的 <code>machineChecked()</code>，该函数会调用 <code>loadCorpus()</code> <strong>完成语料库的加载</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mgr *Manager)</span></span> machineChecked(a *rpctype.CheckArgs, enabledSyscalls <span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span>) &#123;<br>	mgr.mu.Lock()<br>	<span class="hljs-keyword">defer</span> mgr.mu.Unlock()<br>	mgr.checkResult = a<br>	mgr.targetEnabledSyscalls = enabledSyscalls<br>	mgr.target.UpdateGlobs(a.GlobFiles)<br>	mgr.loadCorpus()<br>	mgr.firstConnect = time.Now()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>回到 syz-fuzzer，若 <code>CheckResult</code> 不为空则调用 <code>target.UpdateGlobs()</code> 将 manager 返回数据存放到 <code>GlobFiles</code> 映射中，再调用 <code>Setup()</code> 根据所开启的特性配置 executor 的参数并调用 <code>osutil.RunCmd()</code> 在 5min 后启动 executor，这里就不展开了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">else</span> &#123;<br>		target.UpdateGlobs(r.CheckResult.GlobFiles)<br>		<span class="hljs-keyword">if</span> err = host.Setup(target, r.CheckResult.Features, featureFlags, config.Executor); err != <span class="hljs-literal">nil</span> &#123;<br>			log.Fatal(err)<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Step-III-初始化-Fuzzer-结构信息，获取-input-与-candidate"><a href="#Step-III-初始化-Fuzzer-结构信息，获取-input-与-candidate" class="headerlink" title="Step.III - 初始化 Fuzzer 结构信息，获取 input 与 candidate"></a>Step.III - 初始化 Fuzzer 结构信息，获取 input 与 candidate</h3><p>之后日志输出开启的系统调用数量及特性信息，创建 IPC 配置信息，若设置了 <code>runtest</code> 标志位（默认为 false）则调用 <code>runTest()</code> 后直接返回，这个主要是测试用的这里就不展开了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;syscalls: %v&quot;</span>, <span class="hljs-built_in">len</span>(r.CheckResult.EnabledCalls[sandbox]))<br><span class="hljs-keyword">for</span> _, feat := <span class="hljs-keyword">range</span> r.CheckResult.Features.Supported() &#123;<br>	log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;%v: %v&quot;</span>, feat.Name, feat.Reason)<br>&#125;<br>createIPCConfig(r.CheckResult.Features, config)<br><br><span class="hljs-keyword">if</span> *flagRunTest &#123;<br>	runTest(target, manager, *flagName, config.Executor)<br>	<span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>之后创建 <code>needPoll</code> channel 并写入数据，主要用来标识是否需要向 <code>syz-manager()</code> 发起 poll（向 syz-manager 获取语料库与 candidate）；接下来创建了一个标识当前 <code>syz-fuzzer</code> 信息的 Fuzzer 结构体以及一个 <code>ipc.Gate</code> 结构体（用于将并发级别和窗口限制为给定的值）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><br>needPoll := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>needPoll &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>fuzzer := &amp;Fuzzer&#123;<br>	name:                     *flagName,<br>	outputType:               outputType,<br>	config:                   config,<br>	execOpts:                 execOpts,<br>	workQueue:                newWorkQueue(*flagProcs, needPoll),<br>	needPoll:                 needPoll,<br>	manager:                  manager,<br>	target:                   target,<br>	timeouts:                 timeouts,<br>	faultInjectionEnabled:    r.CheckResult.Features[host.FeatureFault].Enabled,<br>	comparisonTracingEnabled: r.CheckResult.Features[host.FeatureComparisons].Enabled,<br>	corpusHashes:             <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[hash.Sig]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>	checkResult:              r.CheckResult,<br>	fetchRawCover:            *flagRawCover,<br>	noMutate:                 r.NoMutateCalls,<br>	stats:                    <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint64</span>, StatCount),<br>&#125;<br>gateCallback := fuzzer.useBugFrames(r, *flagProcs)<br>fuzzer.gate = ipc.NewGate(<span class="hljs-number">2</span>**flagProcs, gateCallback)<br><br></code></pre></td></tr></table></figure>

<p>接下来是一个小循环，调用 <code>poll()</code> 以<strong>向 syz-manager 获取语料库与 candidate 加入到本地工作队列中</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> needCandidates, more := <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>; more; needCandidates = <span class="hljs-literal">false</span> &#123;<br>	more = fuzzer.poll(needCandidates, <span class="hljs-literal">nil</span>)<br>	<span class="hljs-comment">// 该循环在 qemu 模拟中为 &quot;no output&quot; , 以告诉 manager 我们还没死.</span><br>	log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;fetching corpus: %v, signal %v/%v (executing program)&quot;</span>,<br>		<span class="hljs-built_in">len</span>(fuzzer.corpus), <span class="hljs-built_in">len</span>(fuzzer.corpusSignal), <span class="hljs-built_in">len</span>(fuzzer.maxSignal))<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="poll-：通过-RPC-向-syz-manager-获取语料库与-candidate-加入本地工作队列中"><a href="#poll-：通过-RPC-向-syz-manager-获取语料库与-candidate-加入本地工作队列中" class="headerlink" title="poll()：通过 RPC 向 syz-manager 获取语料库与 candidate 加入本地工作队列中"></a>poll()：通过 RPC 向 syz-manager 获取语料库与 candidate 加入本地工作队列中</h4><p>该函数主要做了两件事：</p>
<ul>
<li>通过 RPC 向 syz-manager 获取语料库与 candidate</li>
<li>将获得的 candidate 加入本地工作队列中</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fuzzer *Fuzzer)</span></span> poll(needCandidates <span class="hljs-type">bool</span>, stats <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">uint64</span>) <span class="hljs-type">bool</span> &#123;<br>	a := &amp;rpctype.PollArgs&#123;<br>		Name:           fuzzer.name,<br>		NeedCandidates: needCandidates,<br>		MaxSignal:      fuzzer.grabNewSignal().Serialize(),<br>		Stats:          stats,<br>	&#125;<br>	r := &amp;rpctype.PollRes&#123;&#125;<br>    <span class="hljs-comment">/* RPC 向 syz-manager 请求信息 */</span> <br>	<span class="hljs-keyword">if</span> err := fuzzer.manager.Call(<span class="hljs-string">&quot;Manager.Poll&quot;</span>, a, r); err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;Manager.Poll call failed: %v&quot;</span>, err)<br>	&#125;<br>    <span class="hljs-comment">/* 解析：最大信号数量 */</span><br>	maxSignal := r.MaxSignal.Deserialize()<br>	log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;poll: candidates=%v inputs=%v signal=%v&quot;</span>,<br>		<span class="hljs-built_in">len</span>(r.Candidates), <span class="hljs-built_in">len</span>(r.NewInputs), maxSignal.Len())<br>	fuzzer.addMaxSignal(maxSignal)<br>    <span class="hljs-comment">/* 解析：syz-manager 给予的从其他 fuzzer 获得的新输入 */</span><br>	<span class="hljs-keyword">for</span> _, inp := <span class="hljs-keyword">range</span> r.NewInputs &#123;<br>		fuzzer.addInputFromAnotherFuzzer(inp)<br>	&#125;<br>    <span class="hljs-comment">/* 解析：candidate */</span><br>	<span class="hljs-keyword">for</span> _, candidate := <span class="hljs-keyword">range</span> r.Candidates &#123;<br>		fuzzer.addCandidateInput(candidate)<br>	&#125;<br>	<span class="hljs-keyword">if</span> needCandidates &amp;&amp; <span class="hljs-built_in">len</span>(r.Candidates) == <span class="hljs-number">0</span> &amp;&amp; atomic.LoadUint32(&amp;fuzzer.triagedCandidates) == <span class="hljs-number">0</span> &#123;<br>		atomic.StoreUint32(&amp;fuzzer.triagedCandidates, <span class="hljs-number">1</span>)<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(r.NewInputs) != <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(r.Candidates) != <span class="hljs-number">0</span> || maxSignal.Len() != <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>该函数会通过 RPC 调用到 syz-manager 中 <code>syz-manager/rpc.go</code> 下的 <code>Poll()</code> 函数：</p>
<ul>
<li>首先会获取在 syz-manager 中该 syz-fuzzer 的信息，并检查最大信号量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(serv *RPCServer)</span></span> Poll(a *rpctype.PollArgs, r *rpctype.PollRes) <span class="hljs-type">error</span> &#123;<br>	serv.stats.mergeNamed(a.Stats)<br><br>	serv.mu.Lock()<br>	<span class="hljs-keyword">defer</span> serv.mu.Unlock()<br><br>	f := serv.fuzzers[a.Name]<br>	<span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-comment">// 若我们调用了 shutdownInstance 、但已经有一个来自该实例的待处理请求，则这是有可能的</span><br>		log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;poll: fuzzer %v is not connected&quot;</span>, a.Name)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	newMaxSignal := serv.maxSignal.Diff(a.MaxSignal.Deserialize())<br>	<span class="hljs-keyword">if</span> !newMaxSignal.Empty() &#123;<br>		serv.maxSignal.Merge(newMaxSignal)<br>		serv.stats.maxSignal.set(<span class="hljs-built_in">len</span>(serv.maxSignal))<br>		<span class="hljs-keyword">for</span> _, f1 := <span class="hljs-keyword">range</span> serv.fuzzers &#123;<br>			<span class="hljs-keyword">if</span> f1 == f || f1.rotated &#123;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			f1.newMaxSignal.Merge(newMaxSignal)<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果该 syz-fuzzer 对应的 VM 实例正在轮转运行，则直接返回</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> f.rotated &#123;<br>	<span class="hljs-comment">// 让轮转中的 VMs 独立运行，不要向他们发送任何东西</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>接下来写入新的最大信号，之后检查 syz-fuzzer 是否向 syz-manager 请求了新的 candidate，若是则调用 <code>candidateBatch()</code> 获取，该函数的作用主要是从 syz-manager 上的 candidate 队列中获取一定数量的 candidate</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">r.MaxSignal = f.newMaxSignal.Split(<span class="hljs-number">2000</span>).Serialize()<br><span class="hljs-keyword">if</span> a.NeedCandidates &#123;<br>	r.Candidates = serv.mgr.candidateBatch(serv.batchSize)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>若获取到的 candidate 数量为 0，说明是第一次 <code>poll()</code>，这时便从初始化时所读取的语料库中获取输入作为 candidate 返还给 syz-fuzzer</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(r.Candidates) == <span class="hljs-number">0</span> &#123;<br>		batchSize := serv.batchSize<br>		<span class="hljs-comment">// 当 fuzzer 启动时, 其会抽取所有的语料库.</span><br>		<span class="hljs-comment">// 若我们使用最后的 batchSize 进行操作, 这将会非常慢</span><br>		<span class="hljs-comment">// (对于 50k 的语料库与慢内核而言，一批大小为 6 可能需要10min以上的时间).</span><br>		<span class="hljs-comment">// 所以在最初就使用更大的批量 (we use no stats as approximation of initial pump).</span><br>		<span class="hljs-keyword">const</span> initialBatch = <span class="hljs-number">50</span><br>		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a.Stats) == <span class="hljs-number">0</span> &amp;&amp; batchSize &lt; initialBatch &#123;<br>			batchSize = initialBatch<br>		&#125;<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; batchSize &amp;&amp; <span class="hljs-built_in">len</span>(f.inputs) &gt; <span class="hljs-number">0</span>; i++ &#123;<br>			last := <span class="hljs-built_in">len</span>(f.inputs) - <span class="hljs-number">1</span><br>			r.NewInputs = <span class="hljs-built_in">append</span>(r.NewInputs, f.inputs[last])<br>			f.inputs[last] = rpctype.Input&#123;&#125;<br>			f.inputs = f.inputs[:last]<br>		&#125;<br>		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(f.inputs) == <span class="hljs-number">0</span> &#123;<br>			f.inputs = <span class="hljs-literal">nil</span><br>		&#125;<br>	&#125;<br>	log.Logf(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;poll from %v: candidates=%v inputs=%v maxsignal=%v&quot;</span>,<br>		a.Name, <span class="hljs-built_in">len</span>(r.Candidates), <span class="hljs-built_in">len</span>(r.NewInputs), <span class="hljs-built_in">len</span>(r.MaxSignal.Elems))<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="构建【系统调用生成优先级表】"><a href="#构建【系统调用生成优先级表】" class="headerlink" title="构建【系统调用生成优先级表】"></a>构建【系统调用生成优先级表】</h2><p>接下来是正式进行 fuzzing 之前最核心的一步——构建<strong>【系统调用生成优先级表】</strong> <code>choiceTable</code> ，该表的作用是：</p>
<ul>
<li><strong>计算对于给定的系统调用 x，在添加入系统调用 y 后，代码覆盖率会上升的可能性</strong></li>
</ul>
<p>从而<strong>在后续的 fuzzing 过程当中使用该表对输入进行变异</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">calls := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*prog.Syscall]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> _, id := <span class="hljs-keyword">range</span> r.CheckResult.EnabledCalls[sandbox] &#123;<br>	calls[target.Syscalls[id]] = <span class="hljs-literal">true</span><br>&#125;<br>fuzzer.choiceTable = target.BuildChoiceTable(fuzzer.corpus, calls)<br></code></pre></td></tr></table></figure>

<p><code>choiceTable</code> 的计算通过 定义于<code>prog/prio.go</code> 中的 <code>BuildChoiceTable()</code> 完成：</p>
<ul>
<li>首先建立两个表：<ul>
<li>① <code>Syscall→bool</code> 的表 <code>enable</code>，表示<strong>启用的系统调用</strong>，并将所有系统调用都初始化为 <code>true</code> </li>
<li>② <code>int→bool</code> 的表 <code>noGenerateCalls</code> ，表示<strong>不用于生成的系统调用</strong></li>
</ul>
</li>
<li>接下来遍历系统调用属性（在 syzlang 规则文件中编写），若某个系统调用不开启则将其从 <code>enable</code> 表中去除，若某个系统调用不用于生成则将其从 <code>enable</code> 表中去除并添加到 <code>noGenerateCalls</code> 表</li>
<li>之后创建第三个表 <code>generateCalls</code>，为 <code>enable</code> 表的拷贝，表示<strong>用于生成的系统调用</strong>，并根据系统调用号进行从小到大的排序</li>
</ul>
<blockquote>
<p>这里的【生成】指的是生成新的输入，即我们是否在输入生成时添加该系统调用</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> BuildChoiceTable(corpus []*Prog, enabled <span class="hljs-keyword">map</span>[*Syscall]<span class="hljs-type">bool</span>) *ChoiceTable &#123;<br>	<span class="hljs-keyword">if</span> enabled == <span class="hljs-literal">nil</span> &#123;<br>		enabled = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Syscall]<span class="hljs-type">bool</span>)<br>		<span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> target.Syscalls &#123;<br>			enabled[c] = <span class="hljs-literal">true</span><br>		&#125;<br>	&#125;<br>	noGenerateCalls := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>	<span class="hljs-keyword">for</span> call := <span class="hljs-keyword">range</span> enabled &#123;<br>		<span class="hljs-keyword">if</span> call.Attrs.Disabled &#123;<br>			<span class="hljs-built_in">delete</span>(enabled, call)<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> call.Attrs.NoGenerate &#123;<br>			noGenerateCalls[call.ID] = <span class="hljs-literal">true</span><br>			<span class="hljs-built_in">delete</span>(enabled, call)<br>		&#125;<br>	&#125;<br>    <span class="hljs-keyword">var</span> generatableCalls []*Syscall<br>	<span class="hljs-keyword">for</span> c := <span class="hljs-keyword">range</span> enabled &#123;<br>		generatableCalls = <span class="hljs-built_in">append</span>(generatableCalls, c)<br>	&#125;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(generatableCalls) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;no syscalls enabled and generatable&quot;</span>)<br>	&#125;<br>	sort.Slice(generatableCalls, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>		<span class="hljs-keyword">return</span> generatableCalls[i].ID &lt; generatableCalls[j].ID<br>	&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>接下来判断语料库中是否包含有禁用的系统调用，若是则直接退出</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> corpus &#123;<br>	<span class="hljs-keyword">for</span> _, call := <span class="hljs-keyword">range</span> p.Calls &#123;<br>		<span class="hljs-keyword">if</span> !enabled[call.Meta] &amp;&amp; !noGenerateCalls[call.Meta.ID] &#123;<br>			fmt.Printf(<span class="hljs-string">&quot;corpus contains disabled syscall %v\n&quot;</span>, call.Meta.Name)<br>			<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;disabled syscall&quot;</span>)<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>最后调用 <code>target.CalculatePriorities(corpus)</code> <strong>基于语料库进行系统调用生成优先级表的计算</strong></li>
<li>完成后生成一个新的表 <code>run</code> 作为结果与生成&amp;不生成系统调用表一起返回，其中存储的是对于启用的系统调用而言的<strong>加权权重的累加和</strong></li>
</ul>
<blockquote>
<p>例如有给定的三个系统调用 A、B、C，有这样的一个生成优先级表 <code>prios</code>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>那么在 <code>run</code> 表中则会将一列的结果逐个加起来，从而有这样的一个结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">A</span> B C<br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>为什么要这么做笔者也不知道：(</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">	prios := target.CalculatePriorities(corpus)<br>	run := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>	<span class="hljs-comment">// ChoiceTable.runs[][] 包含对加权优先级数字的累加总和.</span><br>	<span class="hljs-comment">// 这在生成程序时有助于带权快速二叉搜索.</span><br>	<span class="hljs-comment">// 这仅用于在目标上所启用的系统调用.</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> run &#123;<br>		<span class="hljs-keyword">if</span> !enabled[target.Syscalls[i]] &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		run[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>		<span class="hljs-keyword">var</span> sum <span class="hljs-type">int32</span><br>		<span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> run[i] &#123;<br>			<span class="hljs-keyword">if</span> enabled[target.Syscalls[j]] &#123;<br>				sum += prios[i][j]<br>			&#125;<br>			run[i][j] = sum<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> &amp;ChoiceTable&#123;target, run, generatableCalls, noGenerateCalls&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="【核心】target-CalculatePriorities-corpus-：计算-call-to-call-的权重表"><a href="#【核心】target-CalculatePriorities-corpus-：计算-call-to-call-的权重表" class="headerlink" title="【核心】target.CalculatePriorities(corpus)：计算 call-to-call 的权重表"></a>【核心】target.CalculatePriorities(corpus)：计算 call-to-call 的权重表</h3><p>定义于 <code>prog/prio.go</code> 中的 <code>CalculatePriorities(corpus)</code> 为系统调用生成优先级表的核心计算过程，代码其实比较简单（不过注释很长），主要分为<strong>静态优先级</strong>与<strong>动态优先级</strong>两部分进行计算，默认进行静态优先级的计算，若语料库不为空则再计算动态优先级：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 计算 call-to-call 的优先级.</span><br><span class="hljs-comment">// 对于一对给定的调用 X 与 Y, 优先级便是我们对于</span><br><span class="hljs-comment">// 将一个额外的调用 Y 添加到一个包含有调用 X 的程序当中</span><br><span class="hljs-comment">// 是否有可能给出新的覆盖率的猜测.</span><br><span class="hljs-comment">// 当前的算法有两个部分：静态与动态.</span><br><span class="hljs-comment">// 静态部分基于对参数类型的分析. 举个🌰,</span><br><span class="hljs-comment">// 若调用 X 与 Y 都接受 fd[sock], 则他们更有可能一起给出新的覆盖率.</span><br><span class="hljs-comment">// 动态部分则基于语料库中一对特定的系统调用在一个程序中出现的频率.</span><br><span class="hljs-comment">// 例如，若 socket 与 connect 频繁地在一个程序中一起出现，</span><br><span class="hljs-comment">// 我们给这对系统调用更高的优先级.</span><br><span class="hljs-comment">// 注意: 当前的实现非常简陋, 任何常量背后都没有理论支持.</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> CalculatePriorities(corpus []*Prog) [][]<span class="hljs-type">int32</span> &#123;<br>	static := target.calcStaticPriorities()<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(corpus) != <span class="hljs-number">0</span> &#123;<br>		dynamic := target.calcDynamicPrio(corpus)<br>		<span class="hljs-keyword">for</span> i, prios := <span class="hljs-keyword">range</span> dynamic &#123;<br>			dst := static[i]<br>			<span class="hljs-keyword">for</span> j, p := <span class="hljs-keyword">range</span> prios &#123;<br>				dst[j] = dst[j] * p / prioHigh<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> static<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于给定的系统调用 X，添加系统调用 Y 的优先级为：<br>$$<br>最终优先级 &#x3D; 静态优先级 * 动态优先级 &#x2F; prioHigh<br>$$<br> 其中 <code>prioHigh</code> 为一个常量 <code>1000</code></p>
<h4 id="①-calcStaticPriorities-：静态优先级计算"><a href="#①-calcStaticPriorities-：静态优先级计算" class="headerlink" title="① calcStaticPriorities()：静态优先级计算"></a>① calcStaticPriorities()：静态优先级计算</h4><h5 id="Step-I-计算资源使用情况"><a href="#Step-I-计算资源使用情况" class="headerlink" title="Step.I - 计算资源使用情况"></a>Step.I - 计算资源使用情况</h5><blockquote>
<p>注：这里的【资源】更严谨地说应该是 syzlang 中的 <a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/11/24/FUZZ-0X01-SYZKALLER-I/#VI-%E8%B5%84%E6%BA%90%EF%BC%88resources%EF%BC%89">resource</a></p>
</blockquote>
<p><code>calcStaticPriorities()</code> 用以完成静态优先级的计算，该函数首先会调用 <code>calcResourceUsage()</code> 获取当前的【资源使用情况】：</p>
<ul>
<li>该函数的返回结果为一个二重映射 <code>资源名（string）→【系统调用号（int）→权重（weights）】</code> </li>
<li>该函数的核心逻辑便是调用 <code>ForeachType()</code> 进行分析</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> calcStaticPriorities() [][]<span class="hljs-type">int32</span> &#123;<br>	uses := target.calcResourceUsage()<br>	<span class="hljs-comment">//...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> calcResourceUsage() <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights &#123;<br>	uses := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights)<br>	ForeachType(target.Syscalls, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t Type, ctx *TypeCtx)</span></span> &#123;<br>	<span class="hljs-comment">//...</span><br>	<span class="hljs-keyword">return</span> uses<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们稍后再来分析传入的闭包函数，我们首先分析 <code>ForeachType()</code> ，其会遍历系统调用表并调用 <code>foreachTypeImpl()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForeachTypePost</span><span class="hljs-params">(syscalls []*Syscall, f <span class="hljs-keyword">func</span>(t Type, ctx *TypeCtx)</span></span>) &#123;<br>	<span class="hljs-keyword">for</span> _, meta := <span class="hljs-keyword">range</span> syscalls &#123;<br>		foreachTypeImpl(meta, <span class="hljs-literal">false</span>, f)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <code>foreachTypeImpl()</code>  用以处理单个系统调用，其首先会创建一个 <code>类型→bool</code> 的映射 <code>seen</code>，接下来会创建一个闭包函数 <code>rec</code> ，该函数会根据传入类型的不同进行不同操作：</p>
<blockquote>
<p>注：这里的类型应当为 syzlang 中的类型</p>
</blockquote>
<ul>
<li>若是指针类型 （<code>PtrType</code> ），则递归调用  <code>rec</code> </li>
<li>若是数组类型（<code>ArrayType</code> ），则递归调用 <code>rec</code></li>
<li>若是结构体类型（<code>StructType</code>）且不在 <code>seen</code> 中，将其添加到 <code>seen</code> 中，并为每一个结构体成员调用 <code>rec</code> </li>
<li>若是联合类型（<code>UnionType</code>）且不在 <code>seen</code> 中，将其添加到 <code>seen</code> 中，并为每一个联合成员调用 <code>rec</code> </li>
<li>其他合法类型则直接跳过，非法类型（syzlang 编译期错误）则 panic</li>
<li>最后调用上层传入的闭包函数（我们在 <code>ForeachTypePost()</code> 中传入 <code>preorder = false</code>）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foreachTypeImpl</span><span class="hljs-params">(meta *Syscall, preorder <span class="hljs-type">bool</span>, f <span class="hljs-keyword">func</span>(t Type, ctx *TypeCtx)</span></span>) &#123;<br>	<span class="hljs-comment">// 注意: 我们特意不在 ForeachType 中创建 seen..</span><br>	<span class="hljs-comment">// 其能更好地对递归进行剪枝 (在系统调用间), 但大量的使用者需要</span><br>	<span class="hljs-comment">// 对单个系统调用访问每个结构体 (例如 prio, used resources).</span><br>	seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Type]<span class="hljs-type">bool</span>)<br>	<span class="hljs-keyword">var</span> rec <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Type, Dir)</span></span><br>	rec = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ptr *Type, dir Dir)</span></span> &#123;<br>		ctx := &amp;TypeCtx&#123;Meta: meta, Dir: dir, Ptr: ptr&#125;<br>		<span class="hljs-keyword">if</span> preorder &#123;<br>			f(*ptr, ctx)<br>			<span class="hljs-keyword">if</span> ctx.Stop &#123;<br>				<span class="hljs-keyword">return</span><br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">switch</span> a := (*ptr).(<span class="hljs-keyword">type</span>) &#123;<br>		<span class="hljs-keyword">case</span> *PtrType:<br>			rec(&amp;a.Elem, a.ElemDir)<br>		<span class="hljs-keyword">case</span> *ArrayType:<br>			rec(&amp;a.Elem, dir)<br>		<span class="hljs-keyword">case</span> *StructType:<br>			<span class="hljs-keyword">if</span> seen[a] &#123;<br>				<span class="hljs-keyword">break</span> <span class="hljs-comment">// 通过对structs/unions的指针来剪枝掉递归</span><br>			&#125;<br>			seen[a] = <span class="hljs-literal">true</span><br>			<span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> a.Fields &#123;<br>				rec(&amp;a.Fields[i].Type, f.Dir(dir))<br>			&#125;<br>		<span class="hljs-keyword">case</span> *UnionType:<br>			<span class="hljs-keyword">if</span> seen[a] &#123;<br>				<span class="hljs-keyword">break</span> <span class="hljs-comment">// 通过对structs/unions的指针来剪枝掉递归</span><br>			&#125;<br>			seen[a] = <span class="hljs-literal">true</span><br>			<span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> a.Fields &#123;<br>				rec(&amp;a.Fields[i].Type, f.Dir(dir))<br>			&#125;<br>		<span class="hljs-keyword">case</span> *ResourceType, *BufferType, *VmaType, *LenType, *FlagsType,<br>			*ConstType, *IntType, *ProcType, *CsumType:<br>		<span class="hljs-keyword">case</span> Ref:<br>			<span class="hljs-comment">// 仅 pkg/compiler 需要.</span><br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown type&quot;</span>)<br>		&#125;<br>		<span class="hljs-keyword">if</span> !preorder &#123;<br>			f(*ptr, ctx)<br>			<span class="hljs-keyword">if</span> ctx.Stop &#123;<br>				<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Stop is set in post-order iteration&quot;</span>)<br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>而 <code>foreachTypeImpl()</code> 实际上便是为传入的系统调用的每个参数都调用 <code>rec()</code>，若存在返回值也为其调用 <code>rec</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> meta.Args &#123;<br>		rec(&amp;meta.Args[i].Type, DirIn)<br>	&#125;<br>	<span class="hljs-keyword">if</span> meta.Ret != <span class="hljs-literal">nil</span> &#123;<br>		rec(&amp;meta.Ret, DirOut)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们回到 <code>calcResourceUsage()</code> 看其传给 <code>ForeachType()</code> 的闭包函数，也是根据系统调用的参数的类型不同进行处理：</p>
<blockquote>
<p>这里的 <code>a</code> 为 Type 接口， a.Desc 为 ResourceDesc类型，即对一个资源的描述，其 Kind 域为一个 string 数组，Values 域为一个 uint64 数组</p>
</blockquote>
<ul>
<li><p>若是资源类型 （<code>ResourceType</code> ）：</p>
<ul>
<li>若在 <code>AuxResources</code> 表（辅助资源表，即扮演着辅助角色但是在所有系统调用中都会用到的资源（例如uid&#x2F;gid））里已有记录，则调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 1</li>
<li>否则，遍历 <code>a.Desc.Kind</code> ，调用 <code>noteUsage()</code> 更新权重值，这里给除了最后一个 Kind 以外的权重值为 2，最后一个为 10</li>
</ul>
</li>
<li><p>若是指针类型（<code>PttrType</code>），则判断指针所指对象类型（结构体&#x2F;联合体&#x2F;数组）并调用 <code>noteUsage()</code> 更新权重值，这里给的权重值都为 10</p>
</li>
<li><p>若是 buffer 类型（<code>BufferType</code>），则根据 <code>a.Kind</code> 进行不同处理：</p>
<ul>
<li><code>BufferBlobRand, BufferBlobRange, BufferText, BufferCompressed</code> ：无处理</li>
<li><code>BufferString, BufferGlob</code> ：若 <code>a.SubKind != &quot;&quot;</code>，则调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 2</li>
<li><code>BufferFilename</code>：调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 10</li>
</ul>
</li>
<li><p>若为 VMA 类型 （<code>VmaType</code>），则调用 <code>noteUsage()</code> 更新权重值，这里给的权重值为 5</p>
</li>
<li><p>对于整型则检查 <code>a.Kind</code> 是否为 <code>IntPlain, IntRange</code>，若不是则直接 panic</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t Type, ctx *TypeCtx)</span></span> &#123;<br>		c := ctx.Meta<br>		<span class="hljs-keyword">switch</span> a := t.(<span class="hljs-keyword">type</span>) &#123;<br>		<span class="hljs-keyword">case</span> *ResourceType:<br>			<span class="hljs-keyword">if</span> target.AuxResources[a.Desc.Name] &#123;<br>				noteUsage(uses, c, <span class="hljs-number">1</span>, ctx.Dir, <span class="hljs-string">&quot;res%v&quot;</span>, a.Desc.Name)<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				str := <span class="hljs-string">&quot;res&quot;</span><br>				<span class="hljs-keyword">for</span> i, k := <span class="hljs-keyword">range</span> a.Desc.Kind &#123;<br>					str += <span class="hljs-string">&quot;-&quot;</span> + k<br>					w := <span class="hljs-type">int32</span>(<span class="hljs-number">10</span>)<br>					<span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(a.Desc.Kind)<span class="hljs-number">-1</span> &#123;<br>						w = <span class="hljs-number">2</span><br>					&#125;<br>					noteUsage(uses, c, w, ctx.Dir, str)<br>				&#125;<br>			&#125;<br>		<span class="hljs-keyword">case</span> *PtrType:<br>			<span class="hljs-keyword">if</span> _, ok := a.Elem.(*StructType); ok &#123;<br>				noteUsage(uses, c, <span class="hljs-number">10</span>, ctx.Dir, <span class="hljs-string">&quot;ptrto-%v&quot;</span>, a.Elem.Name())<br>			&#125;<br>			<span class="hljs-keyword">if</span> _, ok := a.Elem.(*UnionType); ok &#123;<br>				noteUsage(uses, c, <span class="hljs-number">10</span>, ctx.Dir, <span class="hljs-string">&quot;ptrto-%v&quot;</span>, a.Elem.Name())<br>			&#125;<br>			<span class="hljs-keyword">if</span> arr, ok := a.Elem.(*ArrayType); ok &#123;<br>				noteUsage(uses, c, <span class="hljs-number">10</span>, ctx.Dir, <span class="hljs-string">&quot;ptrto-%v&quot;</span>, arr.Elem.Name())<br>			&#125;<br>		<span class="hljs-keyword">case</span> *BufferType:<br>			<span class="hljs-keyword">switch</span> a.Kind &#123;<br>			<span class="hljs-keyword">case</span> BufferBlobRand, BufferBlobRange, BufferText, BufferCompressed:<br>			<span class="hljs-keyword">case</span> BufferString, BufferGlob:<br>				<span class="hljs-keyword">if</span> a.SubKind != <span class="hljs-string">&quot;&quot;</span> &#123;<br>					noteUsage(uses, c, <span class="hljs-number">2</span>, ctx.Dir, fmt.Sprintf(<span class="hljs-string">&quot;str-%v&quot;</span>, a.SubKind))<br>				&#125;<br>			<span class="hljs-keyword">case</span> BufferFilename:<br>				noteUsage(uses, c, <span class="hljs-number">10</span>, DirIn, <span class="hljs-string">&quot;filename&quot;</span>)<br>			<span class="hljs-keyword">default</span>:<br>				<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown buffer kind&quot;</span>)<br>			&#125;<br>		<span class="hljs-keyword">case</span> *VmaType:<br>			noteUsage(uses, c, <span class="hljs-number">5</span>, ctx.Dir, <span class="hljs-string">&quot;vma&quot;</span>)<br>		<span class="hljs-keyword">case</span> *IntType:<br>			<span class="hljs-keyword">switch</span> a.Kind &#123;<br>			<span class="hljs-keyword">case</span> IntPlain, IntRange:<br>			<span class="hljs-keyword">default</span>:<br>				<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unknown int kind&quot;</span>)<br>			&#125;<br>		&#125;<br>	&#125;)<br></code></pre></td></tr></table></figure>

<p>这里大量用到了 <code>noteUsage()</code> 函数，该函数其实就是用来<strong>更新传入的表中 X 到 Y 的权重值</strong>（取最大值）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">noteUsage</span><span class="hljs-params">(uses <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights, c *Syscall, weight <span class="hljs-type">int32</span>, dir Dir, str <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	id := fmt.Sprintf(str, args...)<br>	<span class="hljs-keyword">if</span> uses[id] == <span class="hljs-literal">nil</span> &#123;<br>		uses[id] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]weights)<br>	&#125;<br>	callWeight := uses[id][c.ID]<br>	callWeight.call = c.ID<br>	<span class="hljs-keyword">if</span> dir != DirOut &#123;<br>		<span class="hljs-keyword">if</span> weight &gt; uses[id][c.ID].in &#123;<br>			callWeight.in = weight<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> weight &gt; uses[id][c.ID].inout &#123;<br>		callWeight.inout = weight<br>	&#125;<br>	uses[id][c.ID] = callWeight<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="Step-II-建立-call-to-call-的权重表"><a href="#Step-II-建立-call-to-call-的权重表" class="headerlink" title="Step.II - 建立 call-to-call 的权重表"></a>Step.II - 建立 call-to-call 的权重表</h5><p>现在我们回到 <code>calcStaticPriorities()</code> 中，在完成了资源使用表 <code>uses</code> 的建立之后，接下来会建立 call-to-call 的权重表 <code>prios</code>：</p>
<ul>
<li>遍历资源使用表中的每个权重，基于参数方向赋予静态权重值（例如，当 c0 为创建了一个资源的调用，而 c1 为使用该资源的调用，则一个更高的权重将被赋予）</li>
<li>调用 <code>normalizePrio()</code> 将表中权重值进行标准化</li>
<li>对于自我系统调用权重进行单独赋值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go">	prios := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prios &#123;<br>		prios[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>	&#125;<br>	<span class="hljs-keyword">for</span> _, weights := <span class="hljs-keyword">range</span> uses &#123;<br>		<span class="hljs-keyword">for</span> _, w0 := <span class="hljs-keyword">range</span> weights &#123;<br>			<span class="hljs-keyword">for</span> _, w1 := <span class="hljs-keyword">range</span> weights &#123;<br>				<span class="hljs-keyword">if</span> w0.call == w1.call &#123;<br>					<span class="hljs-comment">// 自身权重在下方赋值.</span><br>					<span class="hljs-keyword">continue</span><br>				&#125;<br>				<span class="hljs-comment">// 静态权重值基于参数方向赋值.当 c0 为创建了一个资源的调用</span><br>				<span class="hljs-comment">// 而 c1 为使用该资源的调用，则一个更高的权重将被赋予.</span><br>				prios[w0.call][w1.call] += w0.inout*w1.in*<span class="hljs-number">3</span>/<span class="hljs-number">2</span> + w0.inout*w1.inout<br>			&#125;<br>		&#125;<br>	&#125;<br>	normalizePrio(prios)<br>	<span class="hljs-comment">// 自身权重值(call wrt itself) 的赋值应当高些, 但不要太高.</span><br>	<span class="hljs-keyword">for</span> c0, pp := <span class="hljs-keyword">range</span> prios &#123;<br>		pp[c0] = prioHigh * <span class="hljs-number">9</span> / <span class="hljs-number">10</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> prios<br>&#125;<br></code></pre></td></tr></table></figure>

<p>完成基于资源使用的权重值计算之后静态优先级就算计算完毕了：）</p>
<h4 id="②-calcDynamicPrio-：动态优先级计算"><a href="#②-calcDynamicPrio-：动态优先级计算" class="headerlink" title="② calcDynamicPrio()：动态优先级计算"></a>② calcDynamicPrio()：动态优先级计算</h4><p>动态优先级的计算基于现有的语料库完成，这一部分的代码比较简单，主要是遍历语料库，对于同时出现的系统调用对 X、Y 的优先级值 <code>+1</code>，完成后调用 <code>normalizePrio()</code> 进行标准化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> calcDynamicPrio(corpus []*Prog) [][]<span class="hljs-type">int32</span> &#123;<br>	prios := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prios &#123;<br>		prios[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int32</span>, <span class="hljs-built_in">len</span>(target.Syscalls))<br>	&#125;<br>	<span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> corpus &#123;<br>		<span class="hljs-keyword">for</span> idx0, c0 := <span class="hljs-keyword">range</span> p.Calls &#123;<br>			<span class="hljs-keyword">for</span> _, c1 := <span class="hljs-keyword">range</span> p.Calls[idx0+<span class="hljs-number">1</span>:] &#123;<br>				prios[c0.Meta.ID][c1.Meta.ID]++<br>			&#125;<br>		&#125;<br>	&#125;<br>	normalizePrio(prios)<br>	<span class="hljs-keyword">return</span> prios<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="③-normalizePrio-：优先级值标准化"><a href="#③-normalizePrio-：优先级值标准化" class="headerlink" title="③ normalizePrio()：优先级值标准化"></a>③ normalizePrio()：优先级值标准化</h4><p>这个函数逻辑比较简单，主要就是将权重值标准化到 [prioLow..prioHigh] 范围：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>	prioLow  = <span class="hljs-number">10</span><br>	prioHigh = <span class="hljs-number">1000</span><br>)<br><br><span class="hljs-comment">// normalizePrio 将权重值标准化到 [prioLow..prioHigh] 范围.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">normalizePrio</span><span class="hljs-params">(prios [][]<span class="hljs-type">int32</span>)</span></span> &#123;<br>	<span class="hljs-keyword">for</span> _, prio := <span class="hljs-keyword">range</span> prios &#123;<br>		max := <span class="hljs-type">int32</span>(<span class="hljs-number">1</span>)<br>		<span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> prio &#123;<br>			<span class="hljs-keyword">if</span> max &lt; p &#123;<br>				max = p<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> prio &#123;<br>			prio[i] = prioLow + p*(prioHigh-prioLow)/max<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="为每个-syz-executor-启动一个协程，正式开始-fuzz"><a href="#为每个-syz-executor-启动一个协程，正式开始-fuzz" class="headerlink" title="为每个 syz-executor 启动一个协程，正式开始 fuzz"></a>为每个 syz-executor 启动一个协程，正式开始 fuzz</h2><p>完成前面的所有准备工作之后，接下来我们终于可以正式开始进行 fuzzing 了，syz-fuzzer 会调用 <code>newProc()</code> 为每个要启动的 syz-executor 创建一个 <code>Proc</code> 实例对象（都存放在 <code>fuzzer.procs</code> 列表中），并<strong>为每个 syz-executor 启动一个新的协程负责具体的 fuzzing 工作</strong>（<code>proc.Loop()</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> r.CoverFilterBitmap != <span class="hljs-literal">nil</span> &#123;<br>	fuzzer.execOpts.Flags |= ipc.FlagEnableCoverageFilter<br>&#125;<br><br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;starting %v fuzzer processes&quot;</span>, *flagProcs)<br><span class="hljs-keyword">for</span> pid := <span class="hljs-number">0</span>; pid &lt; *flagProcs; pid++ &#123;<br>	proc, err := newProc(fuzzer, pid)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		log.Fatalf(<span class="hljs-string">&quot;failed to create proc: %v&quot;</span>, err)<br>	&#125;<br>	fuzzer.procs = <span class="hljs-built_in">append</span>(fuzzer.procs, proc)<br>	<span class="hljs-keyword">go</span> proc.loop()<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>最后主线程调用 <code>pollLoop()</code>，循环等待需要 poll 的情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">	fuzzer.pollLoop()<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="0x03-pollLooop-：循环等待处理-fuzzing-协程请求，与-syz-manager-通信"><a href="#0x03-pollLooop-：循环等待处理-fuzzing-协程请求，与-syz-manager-通信" class="headerlink" title="0x03. pollLooop()：循环等待处理 fuzzing 协程请求，与 syz-manager 通信"></a>0x03. pollLooop()：循环等待处理 fuzzing 协程请求，与 syz-manager 通信</h1><p>fuzzing 的工作是由协程 <code>proc.loop()</code> 完成的，在继续深入 fuzzing 过程之前我们先来看看主线程最后还会做些什么：）</p>
<p>主线程在启动这些协程之后所需要做的工作其实就是响应这些协程的请求，并负责与 syz-manager 间进行 RPC 通信，通过一个不会返回的 <code>pollLoop()</code> 函数完成，该函数核心其实就是一个<strong>无限循环</strong>：</p>
<ul>
<li>循环等待 <code>ticker</code> （每 3s 响应一次的计时器）或 <code>fuzzer.needPoll</code> 这两个 channel 之一有数据传来</li>
<li>如果是  <code>fuzzer.needPoll</code> 传来请求或是距离上次 poll 的时间大于 10s：<ul>
<li>检查 workQueue 是否需要新的 candidate（candidate 数量少于 executor 数量），若不是且本次请求处理为  <code>fuzzer.needPoll</code> 传来请求，则等到到距离上次 poll 的时间大于 10s</li>
<li>收集 executor 数据，调用 <code>poll()</code> 通过 RPC 向 syz-manager 获取新的 candidate</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go">unc (fuzzer *Fuzzer) pollLoop() &#123;<br>	<span class="hljs-keyword">var</span> execTotal <span class="hljs-type">uint64</span><br>	<span class="hljs-keyword">var</span> lastPoll time.Time<br>	<span class="hljs-keyword">var</span> lastPrint time.Time<br>	ticker := time.NewTicker(<span class="hljs-number">3</span> * time.Second * fuzzer.timeouts.Scale).C<br>	<span class="hljs-keyword">for</span> &#123;<br>		poll := <span class="hljs-literal">false</span><br>		<span class="hljs-keyword">select</span> &#123;<br>		<span class="hljs-keyword">case</span> &lt;-ticker:	<span class="hljs-comment">/* 3s 一次的计时器 */</span><br>		<span class="hljs-keyword">case</span> &lt;-fuzzer.needPoll: <span class="hljs-comment">/* fuzzing 协程的 poll 请求 */</span><br>			poll = <span class="hljs-literal">true</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> fuzzer.outputType != OutputStdout &amp;&amp; time.Since(lastPrint) &gt; <span class="hljs-number">10</span>*time.Second*fuzzer.timeouts.Scale &#123;<br>			<span class="hljs-comment">// Keep-alive for manager.</span><br>			log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;alive, executed %v&quot;</span>, execTotal)<br>			lastPrint = time.Now()<br>		&#125;<br>		<span class="hljs-comment">/* 对于计时器而言至少 10s 才 poll 一次 */</span><br>		<span class="hljs-keyword">if</span> poll || time.Since(lastPoll) &gt; <span class="hljs-number">10</span>*time.Second*fuzzer.timeouts.Scale &#123;<br>			<span class="hljs-comment">/* workqueue 里 work item 数量少于 executor 数量才 poll */</span><br>			needCandidates := fuzzer.workQueue.wantCandidates()<br>			<span class="hljs-keyword">if</span> poll &amp;&amp; !needCandidates &#123;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			stats := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">uint64</span>)<br>			<span class="hljs-keyword">for</span> _, proc := <span class="hljs-keyword">range</span> fuzzer.procs &#123;<br>				stats[<span class="hljs-string">&quot;exec total&quot;</span>] += atomic.SwapUint64(&amp;proc.env.StatExecs, <span class="hljs-number">0</span>)<br>				stats[<span class="hljs-string">&quot;executor restarts&quot;</span>] += atomic.SwapUint64(&amp;proc.env.StatRestarts, <span class="hljs-number">0</span>)<br>			&#125;<br>			<span class="hljs-keyword">for</span> stat := Stat(<span class="hljs-number">0</span>); stat &lt; StatCount; stat++ &#123;<br>				v := atomic.SwapUint64(&amp;fuzzer.stats[stat], <span class="hljs-number">0</span>)<br>				stats[statNames[stat]] = v<br>				execTotal += v<br>			&#125;<br>			<span class="hljs-keyword">if</span> !fuzzer.poll(needCandidates, stats) &#123;<br>				lastPoll = time.Now()<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="0x04-proc-loop-：真正负责-fuzzing-的核心协程"><a href="#0x04-proc-loop-：真正负责-fuzzing-的核心协程" class="headerlink" title="0x04. proc.loop()：真正负责 fuzzing 的核心协程"></a>0x04. proc.loop()：真正负责 fuzzing 的核心协程</h1><p>下面我们来到 syz-fuzzer 的另一个核心——<strong>真正的 fuzzing 过程</strong>，syz-fuzzer 会为每个 syz-executor 启动一个新的协程负责具体的 fuzzing 工作（对于 executor 来说相当于督工和不断给任务的上司属于是），该协程对应 <code>proc.loop()</code> 函数，该函数的核心其实还是一个<strong>无限循环</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> loop() &#123;<br>	generatePeriod := <span class="hljs-number">100</span><br>	<span class="hljs-keyword">if</span> proc.fuzzer.config.Flags&amp;ipc.FlagSignal == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// 如果我们没有真的覆盖率信号, 更加频繁地生成程序</span><br>		<span class="hljs-comment">// 因为反馈信号很弱.</span><br>		generatePeriod = <span class="hljs-number">2</span><br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br></code></pre></td></tr></table></figure>

<h2 id="从全局-WorkQueue-中获取输入，分类处理执行"><a href="#从全局-WorkQueue-中获取输入，分类处理执行" class="headerlink" title="从全局 WorkQueue 中获取输入，分类处理执行"></a>从全局 WorkQueue 中获取输入，分类处理执行</h2><p>大循环的核心逻辑之一为不断地从全局 <code>WorkQueue</code> 中获取新的输入，按照其类型不同调用不同的处理函数，完成后又继续下一轮循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">item := proc.fuzzer.workQueue.dequeue()<br><span class="hljs-keyword">if</span> item != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">switch</span> item := item.(<span class="hljs-keyword">type</span>) &#123;<br>	<span class="hljs-keyword">case</span> *WorkTriage:<br>		proc.triageInput(item)<br>	<span class="hljs-keyword">case</span> *WorkCandidate:<br>		proc.execute(proc.execOpts, item.p, item.flags, StatCandidate)<br>	<span class="hljs-keyword">case</span> *WorkSmash:<br>		proc.smashInput(item)<br>	<span class="hljs-keyword">default</span>:<br>		log.Fatalf(<span class="hljs-string">&quot;unknown work type: %#v&quot;</span>, item)<br>	&#125;<br>	<span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="①-proc-triageInput-：执行输入-尝试最小化后发送给-manager-并添加到本地语料库，若未-smash-则添加到-smash-队列"><a href="#①-proc-triageInput-：执行输入-尝试最小化后发送给-manager-并添加到本地语料库，若未-smash-则添加到-smash-队列" class="headerlink" title="① proc.triageInput()：执行输入&amp;尝试最小化后发送给 manager 并添加到本地语料库，若未 smash 则添加到 smash 队列"></a>① proc.triageInput()：执行输入&amp;尝试最小化后发送给 manager 并添加到本地语料库，若未 smash 则添加到 smash 队列</h3><p>该函数用来处理 WorkQueue 中的 WorkTraige，即<strong>可能会提供新覆盖率的程序</strong>：</p>
<ul>
<li>一开始先调用 <code>signalPrio()</code> 检查该输入之前执行结果的 <code>errno</code>，为 <code>0</code> 则 <code>prio |= 1 &lt;&lt; 1</code>，同时还会检查是否 <code>item.p</code> 的 <code>target</code> 不包含 <code>item.p.Calls[call]</code> 对应的调用，若是则 <code>prio |= 1 &lt;&lt; 0</code></li>
<li>判断是否产生了语料库中没有的新信号，若无则直接返回</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> triageInput(item *WorkTriage) &#123;<br>	log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: triaging type=%x&quot;</span>, proc.pid, item.flags)<br><br>	prio := signalPrio(item.p, &amp;item.info, item.call)<br>	inputSignal := signal.FromRaw(item.info.Signal, prio)<br>	newSignal := proc.fuzzer.corpusSignalDiff(inputSignal)<br>	<span class="hljs-keyword">if</span> newSignal.Empty() &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	callName := <span class="hljs-string">&quot;.extra&quot;</span><br>	logCallName := <span class="hljs-string">&quot;extra&quot;</span><br>	<span class="hljs-keyword">if</span> item.call != <span class="hljs-number">-1</span> &#123;<br>		callName = item.p.Calls[item.call].Meta.Name<br>		logCallName = fmt.Sprintf(<span class="hljs-string">&quot;call #%v %v&quot;</span>, item.call, callName)<br>	&#125;<br>	log.Logf(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;triaging input for %v (new signal=%v)&quot;</span>, logCallName, newSignal.Len())<br></code></pre></td></tr></table></figure>

<p>完成前面的这些判断工作之后，接下来来到一个会运行三次的小循环：</p>
<ul>
<li>调用 <code>proc.executeRaw()</code> <strong>将该输入重新执行一次</strong>，若执行失败（这里的 <code>reexecutionSuccess()</code> 主要检查信号长度是否不为 0）则重新开始循环，失败 2次直接返回</li>
<li>获取执行所得信号与覆盖率，将覆盖率合并到 <code>inputCover</code> 中，如果 <code>rawCover</code> 为空则还会往里边放一份</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> inputCover cover.Cover<br><span class="hljs-keyword">const</span> (<br>	signalRuns       = <span class="hljs-number">3</span><br>	minimizeAttempts = <span class="hljs-number">3</span><br>)<br><span class="hljs-comment">// 计算输入覆盖与 non-flaky 信号以最小化.</span><br>notexecuted := <span class="hljs-number">0</span><br>rawCover := []<span class="hljs-type">uint32</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; signalRuns; i++ &#123;<br>	info := proc.executeRaw(proc.execOptsCover, item.p, StatTriage)<br>	<span class="hljs-keyword">if</span> !reexecutionSuccess(info, &amp;item.info, item.call) &#123;<br>		<span class="hljs-comment">// 调用未被执行或失败了.</span><br>		notexecuted++<br>		<span class="hljs-keyword">if</span> notexecuted &gt; signalRuns/<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-comment">// 发生得太频繁，放弃</span><br>		&#125;<br>		<span class="hljs-keyword">continue</span><br>	&#125;<br>	thisSignal, thisCover := getSignalAndCover(item.p, info, item.call)<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rawCover) == <span class="hljs-number">0</span> &amp;&amp; proc.fuzzer.fetchRawCover &#123;<br>		rawCover = <span class="hljs-built_in">append</span>([]<span class="hljs-type">uint32</span>&#123;&#125;, thisCover...)<br>	&#125;<br>	newSignal = newSignal.Intersection(thisSignal)<br>	<span class="hljs-comment">// 没有 !minimized 检查的情况下 manager 在每次重启后开始丢失相当大量的覆盖率.</span><br>	<span class="hljs-comment">// Mechanics of this are not completely clear.</span><br>	<span class="hljs-keyword">if</span> newSignal.Empty() &amp;&amp; item.flags&amp;ProgMinimized == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	inputCover.Merge(thisCover)<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里这个 <code>Merge()</code> 其实笔者没太看明白 :（</p>
<p>目前笔者推测 <code>pc</code> 是 <code>program counter</code> ，这样比较能说得通，不过这样为什么不用 <code>map[uint32]bool</code> 呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cov *Cover)</span></span> Merge(raw []<span class="hljs-type">uint32</span>) &#123;<br>	c := *cov<br>	<span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>		c = <span class="hljs-built_in">make</span>(Cover)<br>		*cov = c<br>	&#125;<br>	<span class="hljs-keyword">for</span> _, pc := <span class="hljs-keyword">range</span> raw &#123;<br>		c[pc] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
<p>循环结束后会检查 item 的标志位，如果未设置 <code>ProgMinimized</code> 说明该输入还未进行最小化，<strong>此时调用</strong> <code>prog.Minimize()</code> <strong>将输入进行最小化</strong></p>
<p>这里传入的闭包函数主要是一个 <code>minimizeAttempts</code> （3）次的小循环，其中会调用 <code>proc.execute()</code> 执行最小化后的程序，执行失败则返回，若三次循环执行中无法再产生新的信号信号则返回 true，否则返回 false</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> item.flags&amp;ProgMinimized == <span class="hljs-number">0</span> &#123;<br>	item.p, item.call = prog.Minimize(item.p, item.call, <span class="hljs-literal">false</span>,<br>		<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p1 *prog.Prog, call1 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>			<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; minimizeAttempts; i++ &#123;<br>				info := proc.execute(proc.execOpts, p1, ProgNormal, StatMinimize)<br>				<span class="hljs-keyword">if</span> !reexecutionSuccess(info, &amp;item.info, call1) &#123;<br>					<span class="hljs-comment">// The call was not executed or failed.</span><br>					<span class="hljs-keyword">continue</span><br>				&#125;<br>				thisSignal, _ := getSignalAndCover(p1, info, call1)<br>				<span class="hljs-keyword">if</span> newSignal.Intersection(thisSignal).Len() == newSignal.Len() &#123;<br>					<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>		&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后将这个输入序列化后<strong>发送给 syz-manager 并将其添加到本地语料库中</strong>，如果未设置 <code>ProgSmashed</code> 标志位则再将这个输入放到 WorkSmash 队列中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">	data := item.p.Serialize()<br>	sig := hash.Hash(data)<br><br>	log.Logf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;added new input for %v to corpus:\n%s&quot;</span>, logCallName, data)<br>	proc.fuzzer.sendInputToManager(rpctype.Input&#123;<br>		Call:     callName,<br>		CallID:   item.call,<br>		Prog:     data,<br>		Signal:   inputSignal.Serialize(),<br>		Cover:    inputCover.Serialize(),<br>		RawCover: rawCover,<br>	&#125;)<br><br>	proc.fuzzer.addInputToCorpus(item.p, inputSignal, sig)<br><br>	<span class="hljs-keyword">if</span> item.flags&amp;ProgSmashed == <span class="hljs-number">0</span> &#123;<br>		proc.fuzzer.workQueue.enqueue(&amp;WorkSmash&#123;item.p, item.call&#125;)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="②-proc-execute-：执行输入，将有意思的输入放到-traige-队列"><a href="#②-proc-execute-：执行输入，将有意思的输入放到-traige-队列" class="headerlink" title="② proc.execute()：执行输入，将有意思的输入放到 traige 队列"></a>② proc.execute()：执行输入，将有意思的输入放到 traige 队列</h3><p>该函数的逻辑比较简单，主要便是调用 <code>proc.executeRaw()</code> 执行传入的输入，并调用 <code>checkNewSignal()</code> 检查执行的结果，将其中有意思的那些放入 traige 队列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> execute(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) *ipc.ProgInfo &#123;<br>	info := proc.executeRaw(execOpts, p, stat)<br>	<span class="hljs-keyword">if</span> info == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	calls, extra := proc.fuzzer.checkNewSignal(p, info)<br>	<span class="hljs-keyword">for</span> _, callIndex := <span class="hljs-keyword">range</span> calls &#123;<br>		proc.enqueueCallTriage(p, flags, callIndex, info.Calls[callIndex])<br>	&#125;<br>	<span class="hljs-keyword">if</span> extra &#123;<br>		proc.enqueueCallTriage(p, flags, <span class="hljs-number">-1</span>, info.Extra)<br>	&#125;<br>	<span class="hljs-keyword">return</span> info<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>executeRaw()</code> 函数的主要逻辑其实就是先检查禁用的系统调用然后是一个伪无限循环调用 <code>proc.env.Exec()</code> 执行输入（好多层套娃），若执行失败则进行错误记录并休眠 1s 后重新进行，执行成功则直接返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> executeRaw(opts *ipc.ExecOpts, p *prog.Prog, stat Stat) *ipc.ProgInfo &#123;<br>	proc.fuzzer.checkDisabledCalls(p)<br><br>	<span class="hljs-comment">// 限制并发窗口，每隔一段时间进行一次泄漏检查.</span><br>	ticket := proc.fuzzer.gate.Enter()<br>	<span class="hljs-keyword">defer</span> proc.fuzzer.gate.Leave(ticket)<br><br>	proc.logProgram(opts, p)<br>	<span class="hljs-keyword">for</span> try := <span class="hljs-number">0</span>; ; try++ &#123;<br>		atomic.AddUint64(&amp;proc.fuzzer.stats[stat], <span class="hljs-number">1</span>)<br>		output, info, hanged, err := proc.env.Exec(opts, p)<br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">if</span> err == prog.ErrExecBufferTooSmall &#123;<br>				<span class="hljs-comment">// 若我们系统地在序列化程序上失败则非常糟糕,</span><br>				<span class="hljs-comment">// 但目前为止除了统计以外我们没有更好的处理方式.</span><br>				<span class="hljs-comment">// 该错误在 seeded seeded syz_mount_image 调用上观察到很多.</span><br>				atomic.AddUint64(&amp;proc.fuzzer.stats[StatBufferTooSmall], <span class="hljs-number">1</span>)<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>			&#125;<br>			<span class="hljs-keyword">if</span> try &gt; <span class="hljs-number">10</span> &#123;<br>				log.Fatalf(<span class="hljs-string">&quot;executor %v failed %v times: %v&quot;</span>, proc.pid, try, err)<br>			&#125;<br>			log.Logf(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;fuzzer detected executor failure=&#x27;%v&#x27;, retrying #%d&quot;</span>, err, try+<span class="hljs-number">1</span>)<br>			debug.FreeOSMemory()<br>			time.Sleep(time.Second)<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		log.Logf(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;result hanged=%v: %s&quot;</span>, hanged, output)<br>		<span class="hljs-keyword">return</span> info<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Env-Exec-：启动-syz-executor-并将输入程序序列化后交给其执行"><a href="#Env-Exec-：启动-syz-executor-并将输入程序序列化后交给其执行" class="headerlink" title="Env.Exec()：启动 syz-executor 并将输入程序序列化后交给其执行"></a>Env.Exec()：启动 syz-executor 并将输入程序序列化后交给其执行</h4><p><code>Env.Exec()</code> 函数用来启动 syz-executor 并将输入交给其进行执行，<strong>syz-executor 在被启动后会一直等待 syz-fuzzer 传来的输入并执行</strong>，而不是每个输入都要重新启动一次 executor：</p>
<ul>
<li>首先将输入序列化到 <code>env.in</code> （作为 syz-executor 的输入，syz-executor 会反序列化后再将其执行），并将 <code>env.out</code> 的前 4 字节（<code>ncmd and nsig</code> ）置 0；这里我们注意到 syz-fuzzer 与 syz-executor 间有两种传递数据的方式：管道&#x2F;共享内存</li>
<li>接下来检查 executor 是否已启动，若未启动（ <code>env.cmd == nil</code> ）则调用 <code>makeCommand()</code> <strong>启动 syz-executor</strong></li>
<li>接下来调用 <code>cmd.exec()</code> <strong>真正开始让 syz-executor 执行程序</strong>，若出错则关闭 syz-executor（等 <code>executeRaw()</code> 的下次循环重新启动）</li>
<li>最后解析程序输出，返回结果</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Exec 启动 executor 二进制文件以执行程序 p 并返回关于执行的信息:</span><br><span class="hljs-comment">// output: 程序输出</span><br><span class="hljs-comment">// info: per-call info</span><br><span class="hljs-comment">// hanged: 程序挂起且被杀死</span><br><span class="hljs-comment">// err0: 启动程序失败或是 executor 自身有问题.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(env *Env)</span></span> Exec(opts *ExecOpts, p *prog.Prog) (output []<span class="hljs-type">byte</span>, info *ProgInfo, hanged <span class="hljs-type">bool</span>, err0 <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-comment">// Copy-in serialized program.</span><br>	progSize, err := p.SerializeForExec(env.in)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		err0 = err<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">var</span> progData []<span class="hljs-type">byte</span><br>	<span class="hljs-keyword">if</span> !env.config.UseShmem &#123;<br>		progData = env.in[:progSize]<br>	&#125;<br>	<span class="hljs-comment">// 清零前两个字 (ncmd and nsig), 由此若 executor 在写入非垃圾数据前崩溃，</span><br>	<span class="hljs-comment">// 我们在这里便没有垃圾.</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>		env.out[i] = <span class="hljs-number">0</span><br>	&#125;<br><br>	atomic.AddUint64(&amp;env.StatExecs, <span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">if</span> env.cmd == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">/* syz-executor 未启动 */</span><br>		<span class="hljs-keyword">if</span> p.Target.OS != targets.TestOS &amp;&amp; targets.Get(p.Target.OS, p.Target.Arch).HostFuzzer &#123;<br>			<span class="hljs-comment">// executor 实际上是 ssh,</span><br>			<span class="hljs-comment">// 太频繁地启动他们会导致延迟.</span><br>			&lt;-rateLimit.C<br>		&#125;<br>		tmpDirPath := <span class="hljs-string">&quot;./&quot;</span><br>		atomic.AddUint64(&amp;env.StatRestarts, <span class="hljs-number">1</span>)<br>		env.cmd, err0 = makeCommand(env.pid, env.bin, env.config, env.inFile, env.outFile, env.out, tmpDirPath)<br>		<span class="hljs-keyword">if</span> err0 != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>	&#125;<br>	output, hanged, err0 = env.cmd.exec(opts, progData)<span class="hljs-comment">/* 执行输入 */</span><br>	<span class="hljs-keyword">if</span> err0 != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">/* 出错，关闭 executor */</span><br>		env.cmd.<span class="hljs-built_in">close</span>()<br>		env.cmd = <span class="hljs-literal">nil</span><br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	info, err0 = env.parseOutput(p, opts)<br>	<span class="hljs-keyword">if</span> info != <span class="hljs-literal">nil</span> &amp;&amp; env.config.Flags&amp;FlagSignal == <span class="hljs-number">0</span> &#123;<br>		addFallbackSignal(p, info)<br>	&#125;<br>	<span class="hljs-keyword">if</span> !env.config.UseForkServer &#123;<br>		env.cmd.<span class="hljs-built_in">close</span>()<br>		env.cmd = <span class="hljs-literal">nil</span><br>	&#125;<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="【核心】makeCommand-：建立通信管道，启动-syz-executor"><a href="#【核心】makeCommand-：建立通信管道，启动-syz-executor" class="headerlink" title="【核心】makeCommand()：建立通信管道，启动 syz-executor"></a>【核心】makeCommand()：建立通信管道，启动 syz-executor</h4><p><code>makeCommand()</code> 函数是真正启动 syz-executor 的函数，其首先会先创建一个临时文件夹 <code>syzkaller-testdir</code> 并更改权限为 <code>0777</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeCommand</span><span class="hljs-params">(pid <span class="hljs-type">int</span>, bin []<span class="hljs-type">string</span>, config *Config, inFile, outFile *os.File, outmem []<span class="hljs-type">byte</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">	tmpDirPath <span class="hljs-type">string</span>)</span></span> (*command, <span class="hljs-type">error</span>) &#123;<br>	dir, err := os.MkdirTemp(tmpDirPath, <span class="hljs-string">&quot;syzkaller-testdir&quot;</span>)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create temp dir: %v&quot;</span>, err)<br>	&#125;<br>	dir = osutil.Abs(dir)<br><br>	timeout := config.Timeouts.Program<br>	<span class="hljs-keyword">if</span> config.UseForkServer &#123;<br>		<span class="hljs-comment">// 在启用了 fork server 时，Executor 有一个内部的 timeout，可以防止大部分的挂起，</span><br>		<span class="hljs-comment">// 因此我们用一个非常大的 timeout. Executor 可以因为命名空间中的全局锁与其他东西而变慢，</span><br>		<span class="hljs-comment">// 故我们最好等待，而非上报虚假的误导性 crashes.</span><br>		timeout *= <span class="hljs-number">10</span><br>	&#125;<br><br>	c := &amp;command&#123;<br>		pid:     pid,<br>		config:  config,<br>		timeout: timeout,<br>		dir:     dir,<br>		outmem:  outmem,<br>	&#125;<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">if</span> c != <span class="hljs-literal">nil</span> &#123;<br>			c.<span class="hljs-built_in">close</span>()<br>		&#125;<br>	&#125;()<br><br>	<span class="hljs-keyword">if</span> err := os.Chmod(dir, <span class="hljs-number">0777</span>); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to chmod temp dir: %v&quot;</span>, err)<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>接下来创建三个用以与 <code>syz-executor</code> 通信的管道，分别用于捕获输出、向 executor 传递命令、从 executor 接收命令：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Output 捕获管道.</span><br>rp, wp, err := os.Pipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create pipe: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> wp.Close()<br><br><span class="hljs-comment">// executor-&gt;ipc 命令管道.</span><br>inrp, inwp, err := os.Pipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create pipe: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> inwp.Close()<br>c.inrp = inrp<br><br><span class="hljs-comment">// ipc-&gt;executor 命令管道.</span><br>outrp, outwp, err := os.Pipe()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create pipe: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> outrp.Close()<br>c.outwp = outwp<br><br>c.readDone = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>接下来会调用 <code>osutil</code> 中的 <code>Command()</code> 创建一个 <code>exec.Cmd</code> 实例（该函数为 golag 原生的 <code>exec.Command()</code> 的 wrapper），executor 实际上要等到后面显式调用 <code>Start()</code> 或 <code>Run()</code> 才正式开始运行（参见<a target="_blank" rel="noopener" href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter10/10.1.html">创建进程 · Go语言标准库</a>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">cmd := osutil.Command(bin[<span class="hljs-number">0</span>], bin[<span class="hljs-number">1</span>:]...)<br><span class="hljs-keyword">if</span> inFile != <span class="hljs-literal">nil</span> &amp;&amp; outFile != <span class="hljs-literal">nil</span> &#123;<br>	cmd.ExtraFiles = []*os.File&#123;inFile, outFile&#125;<br>&#125;<br>cmd.Dir = dir<br><span class="hljs-comment">// Tell ASAN to not mess with our NONFAILING.</span><br>cmd.Env = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>&#123;&#125;, os.Environ()...), <span class="hljs-string">&quot;ASAN_OPTIONS=handle_segv=0 allow_user_segv_handler=1&quot;</span>)<br>cmd.Stdin = outrp<br>cmd.Stdout = inwp<br></code></pre></td></tr></table></figure>

<p>若是未设置 <code>FlagDebug</code> 则还会启动一个新的协程持续读取 syz-executor 输出管道中的内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> config.Flags&amp;FlagDebug != <span class="hljs-number">0</span> &#123;<br>	<span class="hljs-built_in">close</span>(c.readDone)<br>	cmd.Stderr = os.Stdout<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	cmd.Stderr = wp<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *command)</span></span> &#123;<br>		<span class="hljs-comment">// 读出输出以防 executor 持续地打印一些东西。</span><br>		<span class="hljs-keyword">const</span> bufSize = <span class="hljs-number">128</span> &lt;&lt; <span class="hljs-number">10</span><br>		output := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, bufSize)<br>		<span class="hljs-keyword">var</span> size <span class="hljs-type">uint64</span><br>		<span class="hljs-keyword">for</span> &#123;<br>			n, err := rp.Read(output[size:])<br>			<span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> &#123;<br>				size += <span class="hljs-type">uint64</span>(n)<br>				<span class="hljs-keyword">if</span> size &gt;= bufSize*<span class="hljs-number">3</span>/<span class="hljs-number">4</span> &#123;<br>					<span class="hljs-built_in">copy</span>(output, output[size-bufSize/<span class="hljs-number">2</span>:size])<br>					size = bufSize / <span class="hljs-number">2</span><br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>				rp.Close()<br>				c.readDone &lt;- output[:size]<br>				<span class="hljs-built_in">close</span>(c.readDone)<br>				<span class="hljs-keyword">return</span><br>			&#125;<br>		&#125;<br>	&#125;(c)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后调用 <code>cmd.Start()</code> 真正启动 syz-executor（该方法不会阻塞父进程），并启动一个新的协程等待 syz-executor 的退出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-keyword">if</span> err := cmd.Start(); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to start executor binary: %v&quot;</span>, err)<br>	&#125;<br>	c.exited = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-number">1</span>)<br>	c.cmd = cmd<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *command)</span></span> &#123;<br>		err := c.cmd.Wait()<br>		c.exited &lt;- err<br>		<span class="hljs-built_in">close</span>(c.exited)<br>		<span class="hljs-comment">// 若 cmd.Stderr 已被泄露给另一个活动进程，防止 livelock.</span><br>		rp.SetDeadline(time.Now().Add(<span class="hljs-number">5</span> * time.Second))<br>	&#125;(c)<br>	wp.Close()<br>	<span class="hljs-comment">// 注意: 尽管我们在上面 defer 了，我们在调用🤝前明确地关闭 inwp.</span><br>	<span class="hljs-comment">// 若我们不这么做且 executor 在写入🤝答复前退出了,</span><br>	<span class="hljs-comment">// 由于我们持有另一个打开的管道末端，从 inrp 上读取将挂起.</span><br>	inwp.Close()<br><br>	<span class="hljs-keyword">if</span> c.config.UseForkServer &#123;<br>		<span class="hljs-keyword">if</span> err := c.handshake(); err != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>		&#125;<br>	&#125;<br>	tmp := c<br>	c = <span class="hljs-literal">nil</span> <span class="hljs-comment">// disable defer above</span><br>	<span class="hljs-keyword">return</span> tmp, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="【核心】cmd-exec-：将单个程序输入传递给-syz-executor-执行"><a href="#【核心】cmd-exec-：将单个程序输入传递给-syz-executor-执行" class="headerlink" title="【核心】cmd.exec()：将单个程序输入传递给 syz-executor 执行"></a>【核心】cmd.exec()：将单个程序输入传递给 syz-executor 执行</h4><p><code>command.exec()</code> 函数用以将一个序列化后的输入传递给 syz-executor 进程执行，传递的方式主要是通过在 <code>makeCommand()</code> 中建立的 <code>ipc→executor</code> 管道完成的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *command)</span></span> exec(opts *ExecOpts, progData []<span class="hljs-type">byte</span>) (output []<span class="hljs-type">byte</span>, hanged <span class="hljs-type">bool</span>, err0 <span class="hljs-type">error</span>) &#123;<br>	req := &amp;executeReq&#123;<br>		magic:            inMagic,<br>		envFlags:         <span class="hljs-type">uint64</span>(c.config.Flags),<br>		execFlags:        <span class="hljs-type">uint64</span>(opts.Flags),<br>		pid:              <span class="hljs-type">uint64</span>(c.pid),<br>		syscallTimeoutMS: <span class="hljs-type">uint64</span>(c.config.Timeouts.Syscall / time.Millisecond),<br>		programTimeoutMS: <span class="hljs-type">uint64</span>(c.config.Timeouts.Program / time.Millisecond),<br>		slowdownScale:    <span class="hljs-type">uint64</span>(c.config.Timeouts.Scale),<br>		progSize:         <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(progData)),<br>	&#125;<br>	reqData := (*[unsafe.Sizeof(*req)]<span class="hljs-type">byte</span>)(unsafe.Pointer(req))[:]<br>	<span class="hljs-keyword">if</span> _, err := c.outwp.Write(reqData); err != <span class="hljs-literal">nil</span> &#123;<br>		output = &lt;-c.readDone<br>		err0 = fmt.Errorf(<span class="hljs-string">&quot;executor %v: failed to write control pipe: %v&quot;</span>, c.pid, err)<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> progData != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">if</span> _, err := c.outwp.Write(progData); err != <span class="hljs-literal">nil</span> &#123;<br>			output = &lt;-c.readDone<br>			err0 = fmt.Errorf(<span class="hljs-string">&quot;executor %v: failed to write control pipe: %v&quot;</span>, c.pid, err)<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 在这个点程序已经开始运行了.</span><br></code></pre></td></tr></table></figure>

<p>对于单个输入程序的传输实际上会先传递一个 <code>executeReq</code> 头部，接下来再传递序列化后的输入程序：</p>
<p><img src="https://s2.loli.net/2023/04/24/I6od1evyCE3MZWH.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>当数据传递过去之后<strong>输入程序就已经开始执行了</strong>，因此该函数后面的部分就都是对结果的处理；）</p>
<p>完成数据发送后会启动一个协程定时等待 executor 执行完毕，若超时则会将 executor 给 kill 掉：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>hang := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	t := time.NewTimer(c.timeout)<br>	<span class="hljs-keyword">select</span> &#123;<br>	<span class="hljs-keyword">case</span> &lt;-t.C:<br>		c.cmd.Process.Kill()<br>		hang &lt;- <span class="hljs-literal">true</span><br>	<span class="hljs-keyword">case</span> &lt;-done:<br>		t.Stop()<br>		hang &lt;- <span class="hljs-literal">false</span><br>	&#125;<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>随后是一个无限大循环，从 <code>executor→ipc</code> 管道中读取 syz-executor 的执行结果，同样是一个 header <code>executeReply</code> 带一份数据 <code>callReply</code> ，单次请求可能有多份返回数据因此这里是一个无限循环，通过 <code>executeReply</code> 中的 <code>done</code> 标志位标识结束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go">exitStatus := <span class="hljs-number">-1</span><br>completedCalls := (*<span class="hljs-type">uint32</span>)(unsafe.Pointer(&amp;c.outmem[<span class="hljs-number">0</span>]))<br>outmem := c.outmem[<span class="hljs-number">4</span>:]<br><span class="hljs-keyword">for</span> &#123;<br>	reply := &amp;executeReply&#123;&#125;<br>	replyData := (*[unsafe.Sizeof(*reply)]<span class="hljs-type">byte</span>)(unsafe.Pointer(reply))[:]<br>	<span class="hljs-keyword">if</span> _, err := io.ReadFull(c.inrp, replyData); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">break</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> reply.magic != outMagic &#123;<br>		fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;executor %v: got bad reply magic 0x%x\n&quot;</span>, c.pid, reply.magic)<br>		os.Exit(<span class="hljs-number">1</span>)<br>	&#125;<br>	<span class="hljs-keyword">if</span> reply.done != <span class="hljs-number">0</span> &#123;<br>		exitStatus = <span class="hljs-type">int</span>(reply.status)<br>		<span class="hljs-keyword">break</span><br>	&#125;<br>	callReply := &amp;callReply&#123;&#125;<br>	callReplyData := (*[unsafe.Sizeof(*callReply)]<span class="hljs-type">byte</span>)(unsafe.Pointer(callReply))[:]<br>	<span class="hljs-keyword">if</span> _, err := io.ReadFull(c.inrp, callReplyData); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">break</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> callReply.signalSize != <span class="hljs-number">0</span> || callReply.coverSize != <span class="hljs-number">0</span> || callReply.compsSize != <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// 暂不支持.</span><br>		fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;executor %v: got call reply with coverage\n&quot;</span>, c.pid)<br>		os.Exit(<span class="hljs-number">1</span>)<br>	&#125;<br>	<span class="hljs-built_in">copy</span>(outmem, callReplyData)<br>	outmem = outmem[<span class="hljs-built_in">len</span>(callReplyData):]<br>	*completedCalls++<br>&#125;<br></code></pre></td></tr></table></figure>

<p>syz-fuzzer 接收 syz-executor 返回数据的示例如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/24/seE43rD2uaXCbwj.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>最后检查本次执行结果，如果说执行结果一切顺利则直接返回，<strong>否则会终止 syz-executor 的继续运行</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-built_in">close</span>(done)<br>	<span class="hljs-keyword">if</span> exitStatus == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// Program was OK.</span><br>		&lt;-hang<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	c.cmd.Process.Kill()<br>	output = &lt;-c.readDone<br>	<span class="hljs-keyword">if</span> err := c.wait(); &lt;-hang &#123;<br>		hanged = <span class="hljs-literal">true</span><br>		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>			output = <span class="hljs-built_in">append</span>(output, err.Error()...)<br>			output = <span class="hljs-built_in">append</span>(output, <span class="hljs-string">&#x27;\n&#x27;</span>)<br>		&#125;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> exitStatus == <span class="hljs-number">-1</span> &#123;<br>		exitStatus = osutil.ProcessExitStatus(c.cmd.ProcessState)<br>	&#125;<br>	<span class="hljs-comment">// 忽略其他的所有错误.</span><br>	<span class="hljs-comment">// 在没有 fork server 的情况下 executor 可以合法地退出 (program contains exit_group),</span><br>	<span class="hljs-comment">// 在带有 fork server 的情况下若 top process 想要特殊的处理，则其可以带着 statusFail 退出.</span><br>	<span class="hljs-keyword">if</span> exitStatus == statusFail &#123;<br>		err0 = fmt.Errorf(<span class="hljs-string">&quot;executor %v: exit status %d\n%s&quot;</span>, c.pid, exitStatus, output)<br>	&#125;<br>	<span class="hljs-keyword">return</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="③-proc-smashInput-：执行并变异刚刚被加入到语料库中的程序【核心】"><a href="#③-proc-smashInput-：执行并变异刚刚被加入到语料库中的程序【核心】" class="headerlink" title="③ proc.smashInput()：执行并变异刚刚被加入到语料库中的程序【核心】"></a>③ proc.smashInput()：执行并变异刚刚被加入到语料库中的程序【核心】</h3><p><code>proc.smashInput()</code> 用以<strong>执行并变异刚刚被加入到语料库中的程序</strong>（即 <code>WorkSmash</code> ）：</p>
<ul>
<li>首先检查 <code>faultInjectionEnabled</code> ，若设置了则调用 <code>proc.failCall()</code> <ul>
<li>该函数用以将一个 fault 注入到程序中，其会循环一百次，设置 <code>newProg.Calls[call].Props.FailNth = nth</code> （<code>newProg</code> 为输入程序的克隆）后调用 <code>proc.executeRaw()</code> 进行执行</li>
</ul>
</li>
<li>接下来检查 <code>comparisonTracingEnabled</code> ，若设置了则调用 <code>proc.executeHintSeed()</code> <strong>使用 hint 进行变异</strong></li>
<li>随后获取 syz-fuzzer 当前快照，并循环一百次：<strong>调用</strong> <code>prog.Mutate()</code> <strong>将输入程序进行变异后再调用</strong> <code>proc.executeAndCollide()</code> <strong>执行变异后的程序</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> smashInput(item *WorkSmash) &#123;<br>	<span class="hljs-keyword">if</span> proc.fuzzer.faultInjectionEnabled &amp;&amp; item.call != <span class="hljs-number">-1</span> &#123;<br>		proc.failCall(item.p, item.call)<br>	&#125;<br>	<span class="hljs-keyword">if</span> proc.fuzzer.comparisonTracingEnabled &amp;&amp; item.call != <span class="hljs-number">-1</span> &#123;<br>		proc.executeHintSeed(item.p, item.call)<br>	&#125;<br>	fuzzerSnapshot := proc.fuzzer.snapshot()<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>		p := item.p.Clone()<br>		p.Mutate(proc.rnd, prog.RecommendedCalls, proc.fuzzer.choiceTable, proc.fuzzer.noMutate, fuzzerSnapshot.corpus)<br>		log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: smash mutated&quot;</span>, proc.pid)<br>		proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatSmash)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>变异函数 <code>prog.Mutate()</code> 我们将在下一节中深入分析，本节我们先来看另外两个函数：</p>
<h4 id="proc-executeHintSeed-：使用-hint-变异程序并执行"><a href="#proc-executeHintSeed-：使用-hint-变异程序并执行" class="headerlink" title="proc.executeHintSeed()：使用 hint 变异程序并执行"></a>proc.executeHintSeed()：使用 hint 变异程序并执行</h4><p>该函数首先会将输入程序执行一次，接下来调用 <code>prog.MutateWithHints</code> 使用执行所得的 CompMap <strong>对输入程序中的一些参数值进行替换</strong>，最后再将该输入程序执行一次：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> executeHintSeed(p *prog.Prog, call <span class="hljs-type">int</span>) &#123;<br>	log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: collecting comparisons&quot;</span>, proc.pid)<br>	<span class="hljs-comment">// 首先执行原始程序以从 KCOV 获取比较值.</span><br>	info := proc.execute(proc.execOptsComps, p, ProgNormal, StatSeed)<br>	<span class="hljs-keyword">if</span> info == <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br><br>	<span class="hljs-comment">// 接下来为每个系统调用参数于一个比较操作数的匹配对变异原始程序.</span><br>	<span class="hljs-comment">// 执行每一个这样的变异，以检查是否给出了新的覆盖率.</span><br>	p.MutateWithHints(call, info.Calls[call].Comps, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *prog.Prog)</span></span> &#123;<br>		log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: executing comparison hint&quot;</span>, proc.pid)<br>		proc.execute(proc.execOpts, p, ProgNormal, StatHint)<br>	&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>MutateWithHints()</code> 当中输入进程会先被克隆一份，接下来使用 <code>ForeachArg</code> 遍历指定系统调用中的每个参数，并传入了一些闭包函数套娃（套中套中套属于是）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用存储在 compMaps中的比较操作数变异程序.</span><br><span class="hljs-comment">// 对于每个变种，执行 exec 回调.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Prog)</span></span> MutateWithHints(callIndex <span class="hljs-type">int</span>, comps CompMap, exec <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Prog)</span></span>) &#123;<br>	p = p.Clone()<br>	c := p.Calls[callIndex]<br>	execValidate := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-comment">// 不要尝试修复 candidate 程序.</span><br>		<span class="hljs-comment">// 假设原来的调用被 sanitized, 我们会得到一个坏的调用作为 hint 的替代结果，将其丢掉就行.</span><br>		<span class="hljs-keyword">if</span> p.Target.sanitize(c, <span class="hljs-literal">false</span>) != <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>		p.debugValidate()<br>		exec(p)<br>	&#125;<br>	ForeachArg(c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arg Arg, _ *ArgCtx)</span></span> &#123;<br>		generateHints(comps, arg, execValidate)<br>	&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类似于我们上文分析的 <code>ForeachType()</code>，<code>ForeachArg()</code> 会为该调用的返回值与每一个参数都调用 <code>foreachArgImpl()</code>，该函数首先会调用上层传入的闭包 <code>generateHints()</code>，接下来会根据参数类型进行不同操作：</p>
<ul>
<li><code>GroupArg</code> （逻辑上的一组参数，即<strong>结构体</strong>与<strong>数组</strong>）：获取并遍历其中的每个成员，递归调用 <code>foreachArgImpl()</code></li>
<li><code>PointerArg</code> （指针类型）：判断其指向 （pointee）是否为 nil，若否，递归调用 <code>foreachArgImpl()</code></li>
<li><code>UnionArg</code>  （联合体类型）：递归调用 <code>foreachArgImpl()</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForeachArg</span><span class="hljs-params">(c *Call, f <span class="hljs-keyword">func</span>(Arg, *ArgCtx)</span></span>) &#123;<br>	ctx := &amp;ArgCtx&#123;&#125;<br>	<span class="hljs-keyword">if</span> c.Ret != <span class="hljs-literal">nil</span> &#123;<br>		foreachArgImpl(c.Ret, ctx, f)<br>	&#125;<br>	ctx.Parent = &amp;c.Args<br>	ctx.Fields = c.Meta.Args<br>	<span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.Args &#123;<br>		foreachArgImpl(arg, ctx, f)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foreachArgImpl</span><span class="hljs-params">(arg Arg, ctx *ArgCtx, f <span class="hljs-keyword">func</span>(Arg, *ArgCtx)</span></span>) &#123;<br>	ctx0 := *ctx<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; *ctx = ctx0 &#125;()<br>	f(arg, ctx)<br>	<span class="hljs-keyword">if</span> ctx.Stop &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">switch</span> a := arg.(<span class="hljs-keyword">type</span>) &#123;<br>	<span class="hljs-keyword">case</span> *GroupArg:<br>		overlayField := <span class="hljs-number">0</span><br>		<span class="hljs-keyword">if</span> typ, ok := a.Type().(*StructType); ok &#123;<br>			ctx.Parent = &amp;a.Inner<br>			ctx.Fields = typ.Fields<br>			overlayField = typ.OverlayField<br>		&#125;<br>		<span class="hljs-keyword">var</span> totalSize <span class="hljs-type">uint64</span><br>		<span class="hljs-keyword">for</span> i, arg1 := <span class="hljs-keyword">range</span> a.Inner &#123;<br>			<span class="hljs-keyword">if</span> i == overlayField &#123;<br>				ctx.Offset = ctx0.Offset<br>			&#125;<br>			foreachArgImpl(arg1, ctx, f)<br>			size := arg1.Size()<br>			ctx.Offset += size<br>			<span class="hljs-keyword">if</span> totalSize &lt; ctx.Offset &#123;<br>				totalSize = ctx.Offset - ctx0.Offset<br>			&#125;<br>		&#125;<br>		claimedSize := a.Size()<br>		varlen := a.Type().Varlen()<br>		<span class="hljs-keyword">if</span> varlen &amp;&amp; totalSize &gt; claimedSize || !varlen &amp;&amp; totalSize != claimedSize &#123;<br>			<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;bad group arg size %v, should be &lt;= %v for %#v type %#v&quot;</span>,<br>				totalSize, claimedSize, a, a.Type().Name()))<br>		&#125;<br>	<span class="hljs-keyword">case</span> *PointerArg:<br>		<span class="hljs-keyword">if</span> a.Res != <span class="hljs-literal">nil</span> &#123;<br>			ctx.Base = a<br>			ctx.Offset = <span class="hljs-number">0</span><br>			foreachArgImpl(a.Res, ctx, f)<br>		&#125;<br>	<span class="hljs-keyword">case</span> *UnionArg:<br>		foreachArgImpl(a.Option, ctx, f)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们来看 <code>generateHints()</code> 函数，该函数首先会调用 <code>Arg</code> 接口的 <code>Type()</code> 函数获取类型并进行判断，对于大部分类型好像都是直接返回，仅有以下通过：</p>
<ul>
<li><code>ConstType</code>：会检查 <code>IsPad</code> 标志位，若不为真才会继续</li>
<li><code>BufferType</code> 中的 <code>BufferString, BufferGlob</code>：会检查值的长度，为 0 才会继续</li>
<li>其他的不在如下代码中的类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateHints</span><span class="hljs-params">(compMap CompMap, arg Arg, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>	typ := arg.Type()<br>	<span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> || arg.Dir() == DirOut &#123;<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">switch</span> t := typ.(<span class="hljs-keyword">type</span>) &#123;<br>	<span class="hljs-keyword">case</span> *ProcType:<br>		<span class="hljs-comment">// 随机的程序不会通过验证.</span><br>		<span class="hljs-comment">// 我们可以将其变异，但仅当结果值在合法范围内.</span><br>		<span class="hljs-keyword">return</span><br>	<span class="hljs-keyword">case</span> *ConstType:<br>		<span class="hljs-keyword">if</span> IsPad(typ) &#123;<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>	<span class="hljs-keyword">case</span> *CsumType:<br>		<span class="hljs-comment">// Csum 将不会通过验证，且总会被计算.</span><br>		<span class="hljs-keyword">return</span><br>	<span class="hljs-keyword">case</span> *BufferType:<br>		<span class="hljs-keyword">switch</span> t.Kind &#123;<br>		<span class="hljs-keyword">case</span> BufferFilename:<br>			<span class="hljs-comment">// 其可以生成逃逸路径，且通常不会太有用.</span><br>			<span class="hljs-keyword">return</span><br>		<span class="hljs-keyword">case</span> BufferString, BufferGlob:<br>			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(t.Values) != <span class="hljs-number">0</span> &#123;<br>				<span class="hljs-comment">// 这些通常是文件名或完整的枚举。</span><br>				<span class="hljs-comment">// 若我们拦截 strcmp，将其变异可能是有用的</span><br>				<span class="hljs-comment">// (并过滤掉文件名).</span><br>				<span class="hljs-keyword">return</span><br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p> 最后会根据参数实际的存储类型进行判断：</p>
<ul>
<li>对于常量参数 <code>ConstArg</code> 类型会调用 <code>checkConstArg()</code> 处理</li>
<li>对于数据参数 <code>DataArg</code> 类型，首先会判断是否为 <code>BufferCompressed</code> 类型，若是则调用 <code>checkCompressedArg()</code> ，否则调用 <code>checkDataArg()</code> 处理</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-keyword">switch</span> a := arg.(<span class="hljs-keyword">type</span>) &#123;<br>	<span class="hljs-keyword">case</span> *ConstArg:<br>		checkConstArg(a, compMap, exec)<br>	<span class="hljs-keyword">case</span> *DataArg:<br>		<span class="hljs-keyword">if</span> typ.(*BufferType).Kind == BufferCompressed &#123;<br>			checkCompressedArg(a, compMap, exec)<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			checkDataArg(a, compMap, exec)<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这三个函数都会调用到 <code>shrinkExpand()</code>，所以我们先来看看这个函数的实现，该函数用以<strong>使用给定的 CompMap 对参数进行替换，返回结果为可以用来进行替换的新参数值</strong>，其具体实现我们就不深入了，这里来看注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Shrink and expand mutations 在当系统调用参数被转化为更狭窄（与更宽阔）的整型类型时</span><br><span class="hljs-comment">// 对这些情况进行建模.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 收缩的动机:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//	void f(u16 x) &#123;</span><br><span class="hljs-comment">//			u8 y = (u8)x;</span><br><span class="hljs-comment">//			if (y == 0xab) &#123;...&#125;</span><br><span class="hljs-comment">//	&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 若我们调用 f(0x1234), 我们将看到在 0x34 与 0xab 间的比较，</span><br><span class="hljs-comment">// 我们将没法将参数 0x1234 与任何比较操作数匹配.</span><br><span class="hljs-comment">// 由此我们将 0x1234 收缩到 0x34 并尝试匹配 0x34.</span><br><span class="hljs-comment">// 若对于收缩后的值存在一个匹配，则我们替换输入中相应的字节</span><br><span class="hljs-comment">//  (在给出的例子中我们将获得 0x12ab).</span><br><span class="hljs-comment">// 有的时候其他的比较操作数将比收缩后的值要宽</span><br><span class="hljs-comment">// (在上面的例子中考虑比较 if (y == 0xdeadbeef) &#123;...&#125;).</span><br><span class="hljs-comment">// 这种情况下我们忽略这样的比较因为我们无法给出做着类似事情的合法代码🌰.</span><br><span class="hljs-comment">// 为了避免这样的比较，我们我们使用 leastSize() 检查其 size. </span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 扩展的动机:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//	void f(i8 x) &#123;</span><br><span class="hljs-comment">//			i16 y = (i16)x;</span><br><span class="hljs-comment">//			if (y == -2) &#123;...&#125;</span><br><span class="hljs-comment">//	&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 假如我们调用 f(-1), 我们将看到在 0xffff 与 0xfffe 间的比较，</span><br><span class="hljs-comment">// 并无法将输入与任何操作数匹配. 由此我们对输入进行符号扩展并检查扩展.</span><br><span class="hljs-comment">// 与收缩一样，我们忽略了另一个操作数更宽的情况.</span><br><span class="hljs-comment">// 需要注意的是 executor 将所有的比较操作数符号扩展至 int64.</span><br></code></pre></td></tr></table></figure>

<p>下面我们来看这三个 <code>check*Arg()</code> ，我们首先看用来处理常量的 <code>checkConstArg()</code>，主要逻辑是嗲用 <code>shrinkExpand()</code> 并对其结果（<code>CompMap</code> 类型）进行遍历，将 <code>arg.Val</code> 依次替换为其提供的 replacer 值，并调用上层回调函数（也就是 <code>execValidate()</code> ，里面还会调用上层传入的闭包函数，最后会调用 <code>proc.execute()</code> ，也就是说<strong>对于 shrinkExpand() 提供的每个替换结果其都会执行一次</strong>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkConstArg</span><span class="hljs-params">(arg *ConstArg, compMap CompMap, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>	original := arg.Val<br>	<span class="hljs-comment">// Note: because shrinkExpand returns a map, order of programs is non-deterministic.</span><br>	<span class="hljs-comment">// This can affect test coverage reports.</span><br>	<span class="hljs-keyword">for</span> _, replacer := <span class="hljs-keyword">range</span> shrinkExpand(original, compMap, arg.Type().TypeBitSize(), <span class="hljs-literal">false</span>) &#123;<br>		arg.Val = replacer<br>		exec()<br>	&#125;<br>	arg.Val = original<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来看 <code>checkCompressedArg()</code> ，主要就是将数据解压后逐 4 字节进行遍历，每次遍历时都会再调用 <code>shrinkExpand()</code> 获取可替换值并再对其结果进行遍历，调用上层传入的闭包函数执行替换数据后的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkCompressedArg</span><span class="hljs-params">(arg *DataArg, compMap CompMap, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>	data0 := arg.Data()<br>	data, dtor := image.MustDecompress(data0)<br>	<span class="hljs-keyword">defer</span> dtor()<br>	<span class="hljs-comment">// Images are very large so the generic algorithm for data arguments</span><br>	<span class="hljs-comment">// can produce too many mutants. For images we consider only</span><br>	<span class="hljs-comment">// 4/8-byte aligned ints. This is enough to handle all magic</span><br>	<span class="hljs-comment">// numbers and checksums. We also ignore 0 and ^uint64(0) source bytes,</span><br>	<span class="hljs-comment">// because there are too many of these in lots of images.</span><br>	bytes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(data); i += <span class="hljs-number">4</span> &#123;<br>		original := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br>		<span class="hljs-built_in">copy</span>(original, data[i:])<br>		val := binary.LittleEndian.Uint64(original)<br>		<span class="hljs-keyword">for</span> _, replacer := <span class="hljs-keyword">range</span> shrinkExpand(val, compMap, <span class="hljs-number">64</span>, <span class="hljs-literal">true</span>) &#123;<br>			binary.LittleEndian.PutUint64(bytes, replacer)<br>			<span class="hljs-built_in">copy</span>(data[i:], bytes)<br>			arg.SetData(image.Compress(data))<br>			exec()<br>		&#125;<br>		<span class="hljs-built_in">copy</span>(data[i:], original)<br>	&#125;<br>	arg.SetData(data0)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>checkDataArg()</code> 逻辑基本上与 <code>checkCompressedArg()</code> 一致，不过是逐字节遍历且没有解压过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkDataArg</span><span class="hljs-params">(arg *DataArg, compMap CompMap, exec <span class="hljs-keyword">func</span>()</span></span>) &#123;<br>	bytes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br>	data := arg.Data()<br>	size := <span class="hljs-built_in">len</span>(data)<br>	<span class="hljs-keyword">if</span> size &gt; maxDataLength &#123;<br>		size = maxDataLength<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;<br>		original := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">8</span>)<br>		<span class="hljs-built_in">copy</span>(original, data[i:])<br>		val := binary.LittleEndian.Uint64(original)<br>		<span class="hljs-keyword">for</span> _, replacer := <span class="hljs-keyword">range</span> shrinkExpand(val, compMap, <span class="hljs-number">64</span>, <span class="hljs-literal">false</span>) &#123;<br>			binary.LittleEndian.PutUint64(bytes, replacer)<br>			<span class="hljs-built_in">copy</span>(data[i:], bytes)<br>			exec()<br>		&#125;<br>		<span class="hljs-built_in">copy</span>(data[i:], original)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="proc-executeAndCollide-：简易的变异执行："><a href="#proc-executeAndCollide-：简易的变异执行：" class="headerlink" title="proc.executeAndCollide()：简易的变异执行："></a>proc.executeAndCollide()：简易的变异执行：</h4><p>该函数的逻辑比较简单，首先会将程序执行一次，之后循环执行两次，不过会调用 <code>proc.randomCollide()</code> 先将原始程序进行处理后再执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> executeAndCollide(execOpts *ipc.ExecOpts, p *prog.Prog, flags ProgTypes, stat Stat) &#123;<br>	proc.execute(execOpts, p, flags, stat)<br><br>	<span class="hljs-keyword">if</span> proc.execOptsCollide.Flags&amp;ipc.FlagThreaded == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// We cannot collide syscalls without being in the threaded mode.</span><br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">const</span> collideIterations = <span class="hljs-number">2</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; collideIterations; i++ &#123;<br>		proc.executeRaw(proc.execOptsCollide, proc.randomCollide(p), StatCollide)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>randomCollide()</code> 流程如下：</p>
<ul>
<li>首先会有 20% 的几率调用 <code>prog.DoubleExecCollide()</code> （把源程序拷贝一份附加到其自身的末，并使用第一部分的资源），若未出错则直接返回</li>
<li>接下来有 20% 的几率调用 <code>prog.DupCallCollide()</code> （将程序中的部分调用进行复制并标记为异步），若未出错则直接返回</li>
<li>最后会调用 <code>prog.AssignRandomAsync()</code> （确保使用一个异步调用生产的资源的调用与其至少间隔一个非异步调用）并有 50% 的几率调用 <code>prog.AssignRandomRerun()</code>：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(proc *Proc)</span></span> randomCollide(origP *prog.Prog) *prog.Prog &#123;<br>	<span class="hljs-keyword">if</span> proc.rnd.Intn(<span class="hljs-number">5</span>) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// Old-style collide with a 20% probability.</span><br>		p, err := prog.DoubleExecCollide(origP, proc.rnd)<br>		<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> p<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> proc.rnd.Intn(<span class="hljs-number">4</span>) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// Duplicate random calls with a 20% probability (25% * 80%).</span><br>		p, err := prog.DupCallCollide(origP, proc.rnd)<br>		<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>			<span class="hljs-keyword">return</span> p<br>		&#125;<br>	&#125;<br>	p := prog.AssignRandomAsync(origP, proc.rnd)<br>	<span class="hljs-keyword">if</span> proc.rnd.Intn(<span class="hljs-number">2</span>) != <span class="hljs-number">0</span> &#123;<br>		prog.AssignRandomRerun(p, proc.rnd)<br>	&#125;<br>	<span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="生成新输入-变异现有输入，执行"><a href="#生成新输入-变异现有输入，执行" class="headerlink" title="生成新输入&#x2F;变异现有输入，执行"></a>生成新输入&#x2F;变异现有输入，执行</h2><p>继续回到 <code>loop()</code> 的无限循环中，如果说全局 <code>WorkQueue</code> 空了，说明这个时候我们要自己想办法弄新的输入了，首先我们要获取 syz-fuzzer 当前的快照（其中包括语料库、语料库权重值、总的权重值），之后进行判断：</p>
<ul>
<li>若语料库为空，或是已经进行了 <code>generatePeriod</code> 次循环，此时调用 <code>target.Generate()</code> 生成新的输入程序</li>
<li>否则，选择一份现有的输入，调用 <code>prog.Mutate()</code> 将该输入进行变异，生成新的输入</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">		ct := proc.fuzzer.choiceTable<br>		fuzzerSnapshot := proc.fuzzer.snapshot()<br>		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fuzzerSnapshot.corpus) == <span class="hljs-number">0</span> || i%generatePeriod == <span class="hljs-number">0</span> &#123;<br>			<span class="hljs-comment">// Generate a new prog.</span><br>			p := proc.fuzzer.target.Generate(proc.rnd, prog.RecommendedCalls, ct)<br>			log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: generated&quot;</span>, proc.pid)<br>			proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatGenerate)<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// Mutate an existing prog.</span><br>			p := fuzzerSnapshot.chooseProgram(proc.rnd).Clone()<br>			p.Mutate(proc.rnd, prog.RecommendedCalls, ct, proc.fuzzer.noMutate, fuzzerSnapshot.corpus)<br>			log.Logf(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;#%v: mutated&quot;</span>, proc.pid)<br>			proc.executeAndCollide(proc.execOpts, p, ProgNormal, StatFuzz)<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="【核心】target-Generate-：生成一个新的输入程序"><a href="#【核心】target-Generate-：生成一个新的输入程序" class="headerlink" title="【核心】target.Generate()：生成一个新的输入程序"></a>【核心】target.Generate()：生成一个新的输入程序</h3><p>该函数本体其实比较简短，主要就是随机生成指定数量的系统调用并打包到一个新的 <code>Prog</code> 结构体当中，生成的依据主要是我们前面给出的 <code>ChoiceTable</code> 表，最后移除程序末尾多余的系统调用便直接返回了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Generate 生成一个带有 ncalls 个调用的随机程序.</span><br><span class="hljs-comment">// ct 包含一组允许的系统调用, 若为 nil 则将使用所有的系统调用.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(target *Target)</span></span> Generate(rs rand.Source, ncalls <span class="hljs-type">int</span>, ct *ChoiceTable) *Prog &#123;<br>	p := &amp;Prog&#123;<br>		Target: target,<br>	&#125;<br>	r := newRand(target, rs)<br>	s := newState(target, ct, <span class="hljs-literal">nil</span>)<br>	<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &lt; ncalls &#123;<br>		calls := r.generateCall(s, p, <span class="hljs-built_in">len</span>(p.Calls))<br>		<span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> calls &#123;<br>			s.analyze(c)<br>			p.Calls = <span class="hljs-built_in">append</span>(p.Calls, c)<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 对于生成的最后一个调用而言，我们有可能在创造资源的同时增加额外的系统调用，</span><br>	<span class="hljs-comment">// 从而导致调用数量超过 ncalls。移除部分调用。</span><br>    <span class="hljs-comment">/* 译注：例如 read 需要一个 fd，那可能前面会再补一个 open */</span><br>	<span class="hljs-comment">// 在最后的调用中的资源会被替换为默认值,这便是我们所想要的。</span><br>	<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &gt; ncalls &#123;<br>		p.RemoveCall(ncalls - <span class="hljs-number">1</span>)<br>	&#125;<br>	p.sanitizeFix()<br>	p.debugValidate()<br>	<span class="hljs-keyword">return</span> p<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>生成单个系统调用的核心函数是 <code>generateCall()</code>：</p>
<ul>
<li>首先会检查 <code>insertPoint</code> 是否不为 0（为 0 则说明刚开始生成第一个系统调用），若是则随机选取程序中已有的一个调用，若其未设置 <code>NoGenerate</code> 属性则将其 id （系统调用号）作为 <code>biasCall</code>，即<strong>生成的第一个系统调用完全随机，后续系统调用则根据优先级表进行生成</strong></li>
<li>接下来调用 ChoiceTable 的 <code>choose</code> 方法，对于第一个系统调用而言其会从 ChoiceTable 中随机选取一个系统调用作为 <code>biasCall</code>，接下来从优先级表中选取 <code>biasCall</code> 对应的优先级数据，从中随机选取一个范围中优先级最高的一个返回</li>
<li>最后调用 <code>generateParticularCall()</code> 生成该系统调用所要用到的数据，这里就不展开了</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ct *ChoiceTable)</span></span> choose(r *rand.Rand, bias <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> bias &lt; <span class="hljs-number">0</span> &#123;	<span class="hljs-comment">/* 第一个系统调用，随机选择 */</span><br>		bias = ct.calls[r.Intn(<span class="hljs-built_in">len</span>(ct.calls))].ID<br>	&#125;<br>	<span class="hljs-keyword">if</span> !ct.Generatable(bias) &#123;<br>		fmt.Printf(<span class="hljs-string">&quot;bias to disabled or non-generatable syscall %v\n&quot;</span>, ct.target.Syscalls[bias].Name)<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;disabled or non-generatable syscall&quot;</span>)<br>	&#125;<br>	run := ct.runs[bias]<br>	x := <span class="hljs-type">int32</span>(r.Intn(<span class="hljs-type">int</span>(run[<span class="hljs-built_in">len</span>(run)<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>)	<span class="hljs-comment">/* 选择优先级范围 */</span><br>	res := sort.Search(<span class="hljs-built_in">len</span>(run), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>		<span class="hljs-keyword">return</span> run[i] &gt;= x<br>	&#125;)<br>	<span class="hljs-keyword">if</span> !ct.Generatable(res) &#123;<br>		<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;selected disabled or non-generatable syscall&quot;</span>)<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *randGen)</span></span> generateCall(s *state, p *Prog, insertionPoint <span class="hljs-type">int</span>) []*Call &#123;<br>	biasCall := <span class="hljs-number">-1</span><br>	<span class="hljs-keyword">if</span> insertionPoint &gt; <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-comment">// Choosing the base call is based on the insertion point of the new calls sequence.</span><br>		insertionCall := p.Calls[r.Intn(insertionPoint)].Meta<br>		<span class="hljs-keyword">if</span> !insertionCall.Attrs.NoGenerate &#123;<br>			<span class="hljs-comment">// We must be careful not to bias towards a non-generatable call.</span><br>			biasCall = insertionCall.ID<br>		&#125;<br>	&#125;<br>	idx := s.ct.choose(r.Rand, biasCall)<br>	meta := r.target.Syscalls[idx]<br>	<span class="hljs-keyword">return</span> r.generateParticularCall(s, meta)<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="【核心】prog-Mutate-：变异一个输入程序"><a href="#【核心】prog-Mutate-：变异一个输入程序" class="headerlink" title="【核心】prog.Mutate()：变异一个输入程序"></a>【核心】prog.Mutate()：变异一个输入程序</h3><p>该函数的核心其实是一个<strong>随机变异</strong>的循环，这里的变量 <code>r</code> 为一个随机数生成器：</p>
<ul>
<li>生成一个 <code>[0, 5)</code> 之间的随机数，若为 0 则执行 <code>mutator.squashAny()</code> </li>
<li>上一条未命中，则生成一个  <code>[0, 100)</code> 间随机数，若 &gt;&#x3D; 1 则执行 <code>mutator.splice()</code></li>
<li>上一条未命中，则生成一个 <code> [0, 31)</code> 间随机数，若 &gt;&#x3D; 20 则执行 <code>mutator.insertCall()</code></li>
<li>上一条未命中，则生成一个 <code>[0, 11)</code> 间随机数，若 &gt;&#x3D; 10 则执行 <code>mutateArg()</code></li>
<li>皆未命中，执行 <code>mutator.removeCall()</code></li>
</ul>
<p>终止循环的条件是 <code>上述变异操作之一成功执行 &amp; 系统调用数不为 0</code> ，此外还有 2&#x2F;3 的概率重新进入循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Mutate program p.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// p:           要变异的程序.</span><br><span class="hljs-comment">// rs:          随机数资源池.</span><br><span class="hljs-comment">// ncalls:      变异后程序中允许的最大调用数量.</span><br><span class="hljs-comment">// ct:          系统调用的 ChoiceTable.</span><br><span class="hljs-comment">// noMutate:    一组不该被变异的系统调用的 ID 集合.</span><br><span class="hljs-comment">// corpus:      包括原始程序 p 的整个语料库.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Prog)</span></span> Mutate(rs rand.Source, ncalls <span class="hljs-type">int</span>, ct *ChoiceTable, noMutate <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, corpus []*Prog) &#123;<br>	r := newRand(p.Target, rs)<br>	<span class="hljs-keyword">if</span> ncalls &lt; <span class="hljs-built_in">len</span>(p.Calls) &#123;<br>		ncalls = <span class="hljs-built_in">len</span>(p.Calls)<br>	&#125;<br>	ctx := &amp;mutator&#123;<br>		p:        p,<br>		r:        r,<br>		ncalls:   ncalls,<br>		ct:       ct,<br>		noMutate: noMutate,<br>		corpus:   corpus,<br>	&#125;<br>	<span class="hljs-keyword">for</span> stop, ok := <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>; !stop; stop = ok &amp;&amp; <span class="hljs-built_in">len</span>(p.Calls) != <span class="hljs-number">0</span> &amp;&amp; r.oneOf(<span class="hljs-number">3</span>) &#123;<br>		<span class="hljs-keyword">switch</span> &#123;<br>		<span class="hljs-keyword">case</span> r.oneOf(<span class="hljs-number">5</span>):<br>			<span class="hljs-comment">// Not all calls have anything squashable,</span><br>			<span class="hljs-comment">// so this has lower priority in reality.</span><br>			ok = ctx.squashAny()<br>		<span class="hljs-keyword">case</span> r.nOutOf(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):<br>			ok = ctx.splice()<br>		<span class="hljs-keyword">case</span> r.nOutOf(<span class="hljs-number">20</span>, <span class="hljs-number">31</span>):<br>			ok = ctx.insertCall()<br>		<span class="hljs-keyword">case</span> r.nOutOf(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>):<br>			ok = ctx.mutateArg()<br>		<span class="hljs-keyword">default</span>:<br>			ok = ctx.removeCall()<br>		&#125;<br>	&#125;<br>	p.sanitizeFix()<br>	p.debugValidate()<br>	<span class="hljs-keyword">if</span> got := <span class="hljs-built_in">len</span>(p.Calls); got &lt; <span class="hljs-number">1</span> || got &gt; ncalls &#123;<br>		<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;bad number of calls after mutation: %v, want [1, %v]&quot;</span>, got, ncalls))<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们来看这五个不同的变异方案</p>
<h4 id="mutator-squashAny-：随机变异一个系统调用的参数"><a href="#mutator-squashAny-：随机变异一个系统调用的参数" class="headerlink" title="mutator.squashAny()：随机变异一个系统调用的参数"></a>mutator.squashAny()：随机变异一个系统调用的参数</h4><p>该函数一开始会调用 <code>Prog.complexPtr()</code>，其中主要会调用 <code>ForEachArg()</code> 遍历用例程序的参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 选择一个随机的复杂指针并将其参数变为 ANY.</span><br><span class="hljs-comment">// 之后，若 ANY 中包含有 blob，变异一个随机的 blob.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> squashAny() <span class="hljs-type">bool</span> &#123;<br>	p, r := ctx.p, ctx.r<br>	complexPtrs := p.complexPtrs()<br></code></pre></td></tr></table></figure>

<p>传入给 <code>ForEachArg()</code> 的回调函数主要调用 <code>isComplexPtr()</code> 判断每个调用的参数中是否存在复杂指针（多级指针），若是，则将该调用添加到作为返回值的数组中，<strong>即这个函数其实主要是针对多级指针的变异</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Prog)</span></span> complexPtrs() (res []complexPtr) &#123;<br>	<span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> p.Calls &#123;<br>		ForeachArg(c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arg Arg, ctx *ArgCtx)</span></span> &#123;<br>			<span class="hljs-keyword">if</span> ptrArg, ok := arg.(*PointerArg); ok &amp;&amp; p.Target.isComplexPtr(ptrArg) &#123;<br>				res = <span class="hljs-built_in">append</span>(res, complexPtr&#123;ptrArg, c&#125;)<br>				ctx.Stop = <span class="hljs-literal">true</span><br>			&#125;<br>		&#125;)<br>	&#125;<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来会从返回列表中随机选择一个指针，若其对应的调用不允许变异则直接返回，若非指针则调用 <code>squashPtr()</code> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">ptr := complexPtrs[r.Intn(<span class="hljs-built_in">len</span>(complexPtrs))]<br><span class="hljs-keyword">if</span> ctx.noMutate[ptr.call.Meta.ID] &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> !p.Target.isAnyPtr(ptr.arg.Type()) &#123;<br>	p.Target.squashPtr(ptr.arg)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来会调用 <code>ForEachSubArg()</code>（本质上为 <code>ForEachArgImpl()</code> 的封装），对之前随机选取的系统调用的参数进行遍历，这里传入的回调函数主要是检查 <code>arg.Dir()</code> 是否为 <code>DirOut</code>，若没有一个参数符合则直接返回 <code>false</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> blobs []*DataArg<br><span class="hljs-keyword">var</span> bases []*PointerArg<br>ForeachSubArg(ptr.arg, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arg Arg, ctx *ArgCtx)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> data, ok := arg.(*DataArg); ok &amp;&amp; arg.Dir() != DirOut &#123;<br>		blobs = <span class="hljs-built_in">append</span>(blobs, data)<br>		bases = <span class="hljs-built_in">append</span>(bases, ctx.Base)<br>	&#125;<br>&#125;)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(blobs) == <span class="hljs-number">0</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后一部分主要是调用 <code>analyze()</code> 进行分析，之后调用 <code>mutateData()</code> 来对参数的数据进行变异，以及对指针的更新</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">	<span class="hljs-comment">// 注意: 我们需要在变异之前调用 analyze.</span><br>	<span class="hljs-comment">// 在变异后其可以增长到超过数据区域的范围，</span><br>	<span class="hljs-comment">// 在标记现有分配时 analyze 将为 OOB 访问崩溃.</span><br>	s := analyze(ctx.ct, ctx.corpus, p, ptr.call)<br>	<span class="hljs-comment">// TODO(dvyukov): 我们可能想要为 ANY 弄一个特别的变异.</span><br>	<span class="hljs-comment">// 例如，合并相邻的 ANYBLOBs (我们并不创造他们,</span><br>	<span class="hljs-comment">// 但他们能在将来出现); 或是用一个 blob 替代 ANYRES</span><br>	<span class="hljs-comment">// (并使用相邻的 blobs 将其合并).</span><br>	idx := r.Intn(<span class="hljs-built_in">len</span>(blobs))<br>	arg := blobs[idx]<br>	base := bases[idx]<br>	baseSize := base.Res.Size()<br>	arg.data = mutateData(r, arg.Data(), <span class="hljs-number">0</span>, maxBlobLen)<br>	<span class="hljs-comment">// 若 size 变大了则更新基指针.</span><br>	<span class="hljs-keyword">if</span> baseSize &lt; base.Res.Size() &#123;<br>		newArg := r.allocAddr(s, base.Type(), base.Dir(), base.Res.Size(), base.Res)<br>		*base = *newArg<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="mutator-splice-：随机选取语料库中一个程序的系统调用插入到程序随机位置中"><a href="#mutator-splice-：随机选取语料库中一个程序的系统调用插入到程序随机位置中" class="headerlink" title="mutator.splice()：随机选取语料库中一个程序的系统调用插入到程序随机位置中"></a>mutator.splice()：随机选取语料库中一个程序的系统调用插入到程序随机位置中</h4><p>该函数为编译过程当中概率最大的主分支，不过其逻辑比较简短：</p>
<ul>
<li>首先从语料库中随机复制一个程序</li>
<li>选择一个随机下标 <code>idx</code> ，在待变异程序该下标处插入 <code>p0</code> 的系统调用组</li>
<li>从末尾移除多余的调用</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 译注：注释写得比较抽象这里就不贴了：）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> splice() <span class="hljs-type">bool</span> &#123;<br>	p, r := ctx.p, ctx.r<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ctx.corpus) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(p.Calls) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(p.Calls) &gt;= ctx.ncalls &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	p0 := ctx.corpus[r.Intn(<span class="hljs-built_in">len</span>(ctx.corpus))]<br>	p0c := p0.Clone()<br>	idx := r.Intn(<span class="hljs-built_in">len</span>(p.Calls))<br>	p.Calls = <span class="hljs-built_in">append</span>(p.Calls[:idx], <span class="hljs-built_in">append</span>(p0c.Calls, p.Calls[idx:]...)...)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(p.Calls) - <span class="hljs-number">1</span>; i &gt;= ctx.ncalls; i-- &#123;<br>		p.RemoveCall(i)<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="mutator-insertCall-：随机生成一个系统调用插入到程序中随机位置"><a href="#mutator-insertCall-：随机生成一个系统调用插入到程序中随机位置" class="headerlink" title="mutator.insertCall()：随机生成一个系统调用插入到程序中随机位置"></a>mutator.insertCall()：随机生成一个系统调用插入到程序中随机位置</h4><p>该函数的逻辑也比较简短，若程序中调用数量已经达到 <code>ncalls</code> 的限制则直接返回，否则会先调用 <code>analyze()</code> 进行分析，随后调用 <code>generateCall()</code> 生成一个系统调用并插入到程序中的一个随机位置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在一个随机点（倾向于现有程序的末尾）插入一个随机调用</span><br><span class="hljs-comment">// 若该程序调用数量早已达到 ncalls（译注：限制数量）则不会插入）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> insertCall() <span class="hljs-type">bool</span> &#123;<br>	p, r := ctx.p, ctx.r<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.Calls) &gt;= ctx.ncalls &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	idx := r.biasedRand(<span class="hljs-built_in">len</span>(p.Calls)+<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>	<span class="hljs-keyword">var</span> c *Call<br>	<span class="hljs-keyword">if</span> idx &lt; <span class="hljs-built_in">len</span>(p.Calls) &#123;<br>		c = p.Calls[idx]<br>	&#125;<br>	s := analyze(ctx.ct, ctx.corpus, p, c)<br>	calls := r.generateCall(s, p, idx)<br>	p.insertBefore(c, calls)<br>	<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &gt; ctx.ncalls &#123;<br>		p.RemoveCall(idx)<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="mutator-mutateArg-：随机变异程序中某一系统调用的参数"><a href="#mutator-mutateArg-：随机变异程序中某一系统调用的参数" class="headerlink" title="mutator.mutateArg()：随机变异程序中某一系统调用的参数"></a>mutator.mutateArg()：随机变异程序中某一系统调用的参数</h4><p>该函数的主要作用便是随机变异程序中某一系统调用的参数，这里就不深入展开分析了，感兴趣可以直接看源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> mutateArg() <span class="hljs-type">bool</span> &#123;<br>	p, r := ctx.p, ctx.r<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.Calls) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br><br>	idx := chooseCall(p, r)<br>	<span class="hljs-keyword">if</span> idx &lt; <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	c := p.Calls[idx]<br>	<span class="hljs-keyword">if</span> ctx.noMutate[c.Meta.ID] &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	updateSizes := <span class="hljs-literal">true</span><br>	<span class="hljs-keyword">for</span> stop, ok := <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>; !stop; stop = ok &amp;&amp; r.oneOf(<span class="hljs-number">3</span>) &#123;<br>		ok = <span class="hljs-literal">true</span><br>		ma := &amp;mutationArgs&#123;target: p.Target&#125;<br>		ForeachArg(c, ma.collectArg)<br>		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ma.args) == <span class="hljs-number">0</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>		&#125;<br>		s := analyze(ctx.ct, ctx.corpus, p, c)<br>		arg, argCtx := ma.chooseArg(r.Rand)<br>		calls, ok1 := p.Target.mutateArg(r, s, arg, argCtx, &amp;updateSizes)<br>		<span class="hljs-keyword">if</span> !ok1 &#123;<br>			ok = <span class="hljs-literal">false</span><br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		p.insertBefore(c, calls)<br>		idx += <span class="hljs-built_in">len</span>(calls)<br>		<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(p.Calls) &gt; ctx.ncalls &#123;<br>			idx--<br>			p.RemoveCall(idx)<br>		&#125;<br>		<span class="hljs-keyword">if</span> idx &lt; <span class="hljs-number">0</span> || idx &gt;= <span class="hljs-built_in">len</span>(p.Calls) || p.Calls[idx] != c &#123;<br>			<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;wrong call index: idx=%v calls=%v p.Calls=%v ncalls=%v&quot;</span>,<br>				idx, <span class="hljs-built_in">len</span>(calls), <span class="hljs-built_in">len</span>(p.Calls), ctx.ncalls))<br>		&#125;<br>		<span class="hljs-keyword">if</span> updateSizes &#123;<br>			p.Target.assignSizesCall(c)<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="mutator-removeCall-：随机移除程序中的一个系统调用"><a href="#mutator-removeCall-：随机移除程序中的一个系统调用" class="headerlink" title="mutator.removeCall()：随机移除程序中的一个系统调用"></a>mutator.removeCall()：随机移除程序中的一个系统调用</h4><p>该函数也比较简短，主要就是随机移除程序中的一个系统调用，如果程序中没有系统调用则不会进行移除操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ctx *mutator)</span></span> removeCall() <span class="hljs-type">bool</span> &#123;<br>	p, r := ctx.p, ctx.r<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(p.Calls) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>	&#125;<br>	idx := r.Intn(<span class="hljs-built_in">len</span>(p.Calls))<br>	p.RemoveCall(idx)<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，syz-fuzzer 主体源码逻辑分析完毕</p>
<blockquote>
<p>简单总结的话，笔者感觉其实主要都是偏工程性的东西比较多🤔</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/FUZZ/" class="category-chain-item">FUZZ</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/">#漏洞挖掘</a>
      
        <a href="/tags/FUZZ/">#FUZZ</a>
      
        <a href="/tags/syzkaller/">#syzkaller</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【FUZZ.0x03】syzkaller - III：syz-fuzzer 源码分析</div>
      <div>https://arttnba3.github.io/2023/09/27/FUZZ-0X03-SYZKALLER-III_SOURCE_SYZFUZZER/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>arttnba3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年9月27日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/25/OPS-0X01-DOCKER_WAYLAND_GUI/" title="【OPS.0x01】为 Docker 连接 Wayland 图形环境">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【OPS.0x01】为 Docker 连接 Wayland 图形环境</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/25/DISTRO-0X00-INSTALL_ARCH_WINDOWS/" title="【DISTRO.0x00】从零开始的 Arch Linux 生活">
                        <span class="hidden-mobile">【DISTRO.0x00】从零开始的 Arch Linux 生活</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appid":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appkey":"tuvJh3xYxPFcW2JB6K26RKP2","path":"window.location.pathname","placeholder":"说点什么呗（笑）","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appId":"ICj6cPRQWFTNiOttBHlzxnIv-gzGzoHsz","appKey":"tuvJh3xYxPFcW2JB6K26RKP2"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  <!-- 网站运行时间的设置 -->
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
      var now = new Date();
      function createtime() {
          var grt= new Date("04/20/2020 17:48:48");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "arttnba3的小屋已经安全存在了 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
  setInterval("createtime()",250);
  </script>
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      桂ICP备2022005068号-1
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
